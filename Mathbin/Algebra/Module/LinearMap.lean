/-
Copyright (c) 2020 Anne Baanen. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Nathaniel Thomas, Jeremy Avigad, Johannes Hölzl, Mario Carneiro, Anne Baanen,
  Frédéric Dupuis, Heather Macbeth

! This file was ported from Lean 3 source module algebra.module.linear_map
! leanprover-community/mathlib commit 2738d2ca56cbc63be80c3bd48e9ed90ad94e947d
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Hom.GroupAction
import Mathbin.Algebra.Module.Pi
import Mathbin.Algebra.Star.Basic
import Mathbin.Data.Set.Pointwise.Smul
import Mathbin.Algebra.Ring.CompTypeclasses

/-!
# (Semi)linear maps

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file we define

* `linear_map σ M M₂`, `M →ₛₗ[σ] M₂` : a semilinear map between two `module`s. Here,
  `σ` is a `ring_hom` from `R` to `R₂` and an `f : M →ₛₗ[σ] M₂` satisfies
  `f (c • x) = (σ c) • (f x)`. We recover plain linear maps by choosing `σ` to be `ring_hom.id R`.
  This is denoted by `M →ₗ[R] M₂`. We also add the notation `M →ₗ⋆[R] M₂` for star-linear maps.

* `is_linear_map R f` : predicate saying that `f : M → M₂` is a linear map. (Note that this
  was not generalized to semilinear maps.)

We then provide `linear_map` with the following instances:

* `linear_map.add_comm_monoid` and `linear_map.add_comm_group`: the elementwise addition structures
  corresponding to addition in the codomain
* `linear_map.distrib_mul_action` and `linear_map.module`: the elementwise scalar action structures
  corresponding to applying the action in the codomain.
* `module.End.semiring` and `module.End.ring`: the (semi)ring of endomorphisms formed by taking the
  additive structure above with composition as multiplication.

## Implementation notes

To ensure that composition works smoothly for semilinear maps, we use the typeclasses
`ring_hom_comp_triple`, `ring_hom_inv_pair` and `ring_hom_surjective` from
`algebra/ring/comp_typeclasses`.

## Notation

* Throughout the file, we denote regular linear maps by `fₗ`, `gₗ`, etc, and semilinear maps
  by `f`, `g`, etc.

## TODO

* Parts of this file have not yet been generalized to semilinear maps (i.e. `compatible_smul`)

## Tags

linear map
-/


assert_not_exists Submonoid

assert_not_exists Finset

open Function

universe u u' v w x y z

variable {R : Type _} {R₁ : Type _} {R₂ : Type _} {R₃ : Type _}

variable {k : Type _} {S : Type _} {S₃ : Type _} {T : Type _}

variable {M : Type _} {M₁ : Type _} {M₂ : Type _} {M₃ : Type _}

variable {N₁ : Type _} {N₂ : Type _} {N₃ : Type _} {ι : Type _}

#print IsLinearMap /-
/-- A map `f` between modules over a semiring is linear if it satisfies the two properties
`f (x + y) = f x + f y` and `f (c • x) = c • f x`. The predicate `is_linear_map R f` asserts this
property. A bundled version is available with `linear_map`, and should be favored over
`is_linear_map` most of the time. -/
structure IsLinearMap (R : Type u) {M : Type v} {M₂ : Type w} [Semiring R] [AddCommMonoid M]
  [AddCommMonoid M₂] [Module R M] [Module R M₂] (f : M → M₂) : Prop where
  map_add : ∀ x y, f (x + y) = f x + f y
  map_smul : ∀ (c : R) (x), f (c • x) = c • f x
#align is_linear_map IsLinearMap
-/

section

#print LinearMap /-
/-- A map `f` between an `R`-module and an `S`-module over a ring homomorphism `σ : R →+* S`
is semilinear if it satisfies the two properties `f (x + y) = f x + f y` and
`f (c • x) = (σ c) • f x`. Elements of `linear_map σ M M₂` (available under the notation
`M →ₛₗ[σ] M₂`) are bundled versions of such maps. For plain linear maps (i.e. for which
`σ = ring_hom.id R`), the notation `M →ₗ[R] M₂` is available. An unbundled version of plain linear
maps is available with the predicate `is_linear_map`, but it should be avoided most of the time. -/
structure LinearMap {R : Type _} {S : Type _} [Semiring R] [Semiring S] (σ : R →+* S) (M : Type _)
  (M₂ : Type _) [AddCommMonoid M] [AddCommMonoid M₂] [Module R M] [Module S M₂] extends
  AddHom M M₂ where
  map_smul' : ∀ (r : R) (x : M), to_fun (r • x) = σ r • to_fun x
#align linear_map LinearMap
-/

/-- The `add_hom` underlying a `linear_map`. -/
add_decl_doc LinearMap.toAddHom

-- mathport name: «expr →ₛₗ[ ] »
notation:25 M " →ₛₗ[" σ:25 "] " M₂:0 => LinearMap σ M M₂

-- mathport name: «expr →ₗ[ ] »
notation:25 M " →ₗ[" R:25 "] " M₂:0 => LinearMap (RingHom.id R) M M₂

-- mathport name: «expr →ₗ⋆[ ] »
notation:25 M " →ₗ⋆[" R:25 "] " M₂:0 => LinearMap (starRingEnd R) M M₂

#print SemilinearMapClass /-
/-- `semilinear_map_class F σ M M₂` asserts `F` is a type of bundled `σ`-semilinear maps `M → M₂`.

See also `linear_map_class F R M M₂` for the case where `σ` is the identity map on `R`.

A map `f` between an `R`-module and an `S`-module over a ring homomorphism `σ : R →+* S`
is semilinear if it satisfies the two properties `f (x + y) = f x + f y` and
`f (c • x) = (σ c) • f x`. -/
class SemilinearMapClass (F : Type _) {R S : outParam (Type _)} [Semiring R] [Semiring S]
  (σ : outParam <| R →+* S) (M M₂ : outParam (Type _)) [AddCommMonoid M] [AddCommMonoid M₂]
  [Module R M] [Module S M₂] extends AddHomClass F M M₂ where
  map_smulₛₗ : ∀ (f : F) (r : R) (x : M), f (r • x) = σ r • f x
#align semilinear_map_class SemilinearMapClass
-/

end

-- `σ` becomes a metavariable but that's fine because it's an `out_param`
attribute [nolint dangerous_instance] SemilinearMapClass.toAddHomClass

export SemilinearMapClass (map_smulₛₗ)

attribute [simp] map_smulₛₗ

#print LinearMapClass /-
/-- `linear_map_class F R M M₂` asserts `F` is a type of bundled `R`-linear maps `M → M₂`.

This is an abbreviation for `semilinear_map_class F (ring_hom.id R) M M₂`.
-/
abbrev LinearMapClass (F : Type _) (R M M₂ : outParam (Type _)) [Semiring R] [AddCommMonoid M]
    [AddCommMonoid M₂] [Module R M] [Module R M₂] :=
  SemilinearMapClass F (RingHom.id R) M M₂
#align linear_map_class LinearMapClass
-/

namespace SemilinearMapClass

variable (F : Type _)

variable [Semiring R] [Semiring S]

variable [AddCommMonoid M] [AddCommMonoid M₁] [AddCommMonoid M₂] [AddCommMonoid M₃]

variable [AddCommMonoid N₁] [AddCommMonoid N₂] [AddCommMonoid N₃]

variable [Module R M] [Module R M₂] [Module S M₃]

variable {σ : R →+* S}

-- `σ` is an `out_param` so it's not dangerous
@[nolint dangerous_instance]
instance (priority := 100) [SemilinearMapClass F σ M M₃] : AddMonoidHomClass F M M₃ :=
  {
    SemilinearMapClass.toAddHomClass F σ M
      M₃ with
    coe := fun f => (f : M → M₃)
    map_zero := fun f =>
      show f 0 = 0 by
        rw [← zero_smul R (0 : M), map_smulₛₗ]
        simp }

-- `R` is an `out_param` so it's not dangerous
@[nolint dangerous_instance]
instance (priority := 100) [LinearMapClass F R M M₂] : DistribMulActionHomClass F R M M₂ :=
  {
    SemilinearMapClass.addMonoidHomClass
      F with
    coe := fun f => (f : M → M₂)
    map_smul := fun f c x => by rw [map_smulₛₗ, RingHom.id_apply] }

variable {F} (f : F) [i : SemilinearMapClass F σ M M₃]

include i

/- warning: semilinear_map_class.map_smul_inv -> SemilinearMapClass.map_smul_inv is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₃ : Type.{u4}} {F : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_6 : AddCommMonoid.{u4} M₃] [_inst_10 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_12 : Module.{u2, u4} S M₃ _inst_2 _inst_6] {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} (f : F) [i : SemilinearMapClass.{u5, u1, u2, u3, u4} F R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12] {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} [_inst_13 : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'] (c : S) (x : M), Eq.{succ u4} M₃ (SMul.smul.{u2, u4} S M₃ (SMulZeroClass.toHasSmul.{u2, u4} S M₃ (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6))) (SMulWithZero.toSmulZeroClass.{u2, u4} S M₃ (MulZeroClass.toHasZero.{u2} S (MulZeroOneClass.toMulZeroClass.{u2} S (MonoidWithZero.toMulZeroOneClass.{u2} S (Semiring.toMonoidWithZero.{u2} S _inst_2)))) (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6))) (MulActionWithZero.toSMulWithZero.{u2, u4} S M₃ (Semiring.toMonoidWithZero.{u2} S _inst_2) (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6))) (Module.toMulActionWithZero.{u2, u4} S M₃ _inst_2 _inst_6 _inst_12)))) c (coeFn.{succ u5, max (succ u3) (succ u4)} F (fun (_x : F) => M -> M₃) (FunLike.hasCoeToFun.{succ u5, succ u3, succ u4} F M (fun (_x : M) => M₃) (AddHomClass.toFunLike.{u5, u3, u4} F M M₃ (AddZeroClass.toHasAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (AddZeroClass.toHasAdd.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6))) (SemilinearMapClass.toAddHomClass.{u5, u1, u2, u3, u4} F R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12 i))) f x)) (coeFn.{succ u5, max (succ u3) (succ u4)} F (fun (_x : F) => M -> M₃) (FunLike.hasCoeToFun.{succ u5, succ u3, succ u4} F M (fun (_x : M) => M₃) (AddHomClass.toFunLike.{u5, u3, u4} F M M₃ (AddZeroClass.toHasAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (AddZeroClass.toHasAdd.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6))) (SemilinearMapClass.toAddHomClass.{u5, u1, u2, u3, u4} F R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12 i))) f (SMul.smul.{u1, u3} R M (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_3 _inst_10)))) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (fun (_x : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) => S -> R) (RingHom.hasCoeToFun.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) σ' c) x))
but is expected to have type
  forall {R : Type.{u4}} {S : Type.{u5}} {M : Type.{u1}} {M₃ : Type.{u3}} {F : Type.{u2}} {_inst_1 : Semiring.{u4} R} {_inst_2 : Semiring.{u5} S} {_inst_3 : AddCommMonoid.{u1} M} {_inst_6 : AddCommMonoid.{u3} M₃} {_inst_10 : Module.{u4, u1} R M _inst_1 _inst_3} {_inst_12 : Module.{u5, u3} S M₃ _inst_2 _inst_6} {σ : RingHom.{u4, u5} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u5} S _inst_2)} (f : F) [i : SemilinearMapClass.{u2, u4, u5, u1, u3} F R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12] {σ' : RingHom.{u5, u4} S R (Semiring.toNonAssocSemiring.{u5} S _inst_2) (Semiring.toNonAssocSemiring.{u4} R _inst_1)} [_inst_13 : RingHomInvPair.{u4, u5} R S _inst_1 _inst_2 σ σ'] (c : S) (x : M), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₃) x) (HSMul.hSMul.{u5, u3, u3} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₃) x) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₃) x) (instHSMul.{u5, u3} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₃) x) (SMulZeroClass.toSMul.{u5, u3} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₃) x) (AddMonoid.toZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₃) x) (AddCommMonoid.toAddMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₃) x) _inst_6)) (SMulWithZero.toSMulZeroClass.{u5, u3} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₃) x) (MonoidWithZero.toZero.{u5} S (Semiring.toMonoidWithZero.{u5} S _inst_2)) (AddMonoid.toZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₃) x) (AddCommMonoid.toAddMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₃) x) _inst_6)) (MulActionWithZero.toSMulWithZero.{u5, u3} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₃) x) (Semiring.toMonoidWithZero.{u5} S _inst_2) (AddMonoid.toZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₃) x) (AddCommMonoid.toAddMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₃) x) _inst_6)) (Module.toMulActionWithZero.{u5, u3} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₃) x) _inst_2 _inst_6 _inst_12))))) c (FunLike.coe.{succ u2, succ u1, succ u3} F M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₃) _x) (AddHomClass.toFunLike.{u2, u1, u3} F M M₃ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (AddZeroClass.toAdd.{u3} M₃ (AddMonoid.toAddZeroClass.{u3} M₃ (AddCommMonoid.toAddMonoid.{u3} M₃ _inst_6))) (SemilinearMapClass.toAddHomClass.{u2, u4, u5, u1, u3} F R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12 i)) f x)) (FunLike.coe.{succ u2, succ u1, succ u3} F M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₃) _x) (AddHomClass.toFunLike.{u2, u1, u3} F M M₃ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (AddZeroClass.toAdd.{u3} M₃ (AddMonoid.toAddZeroClass.{u3} M₃ (AddCommMonoid.toAddMonoid.{u3} M₃ _inst_6))) (SemilinearMapClass.toAddHomClass.{u2, u4, u5, u1, u3} F R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12 i)) f (HSMul.hSMul.{u4, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : S) => R) c) M M (instHSMul.{u4, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : S) => R) c) M (SMulZeroClass.toSMul.{u4, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : S) => R) c) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u4, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : S) => R) c) M (MonoidWithZero.toZero.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : S) => R) c) (Semiring.toMonoidWithZero.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : S) => R) c) _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u4, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : S) => R) c) M (Semiring.toMonoidWithZero.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : S) => R) c) _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)) (Module.toMulActionWithZero.{u4, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : S) => R) c) M _inst_1 _inst_3 _inst_10))))) (FunLike.coe.{max (succ u4) (succ u5), succ u5, succ u4} (RingHom.{u5, u4} S R (Semiring.toNonAssocSemiring.{u5} S _inst_2) (Semiring.toNonAssocSemiring.{u4} R _inst_1)) S (fun (_x : S) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : S) => R) _x) (MulHomClass.toFunLike.{max u4 u5, u5, u4} (RingHom.{u5, u4} S R (Semiring.toNonAssocSemiring.{u5} S _inst_2) (Semiring.toNonAssocSemiring.{u4} R _inst_1)) S R (NonUnitalNonAssocSemiring.toMul.{u5} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u4} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (NonUnitalRingHomClass.toMulHomClass.{max u4 u5, u5, u4} (RingHom.{u5, u4} S R (Semiring.toNonAssocSemiring.{u5} S _inst_2) (Semiring.toNonAssocSemiring.{u4} R _inst_1)) S R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomClass.toNonUnitalRingHomClass.{max u4 u5, u5, u4} (RingHom.{u5, u4} S R (Semiring.toNonAssocSemiring.{u5} S _inst_2) (Semiring.toNonAssocSemiring.{u4} R _inst_1)) S R (Semiring.toNonAssocSemiring.{u5} S _inst_2) (Semiring.toNonAssocSemiring.{u4} R _inst_1) (RingHom.instRingHomClassRingHom.{u5, u4} S R (Semiring.toNonAssocSemiring.{u5} S _inst_2) (Semiring.toNonAssocSemiring.{u4} R _inst_1))))) σ' c) x))
Case conversion may be inaccurate. Consider using '#align semilinear_map_class.map_smul_inv SemilinearMapClass.map_smul_invₓ'. -/
theorem map_smul_inv {σ' : S →+* R} [RingHomInvPair σ σ'] (c : S) (x : M) :
    c • f x = f (σ' c • x) := by simp
#align semilinear_map_class.map_smul_inv SemilinearMapClass.map_smul_inv

end SemilinearMapClass

namespace LinearMap

section AddCommMonoid

variable [Semiring R] [Semiring S]

section

variable [AddCommMonoid M] [AddCommMonoid M₁] [AddCommMonoid M₂] [AddCommMonoid M₃]

variable [AddCommMonoid N₁] [AddCommMonoid N₂] [AddCommMonoid N₃]

variable [Module R M] [Module R M₂] [Module S M₃]

variable {σ : R →+* S}

instance : SemilinearMapClass (M →ₛₗ[σ] M₃) σ M M₃
    where
  coe := LinearMap.toFun
  coe_injective' f g h := by cases f <;> cases g <;> congr
  map_add := LinearMap.map_add'
  map_smulₛₗ := LinearMap.map_smul'

/-- Helper instance for when there's too many metavariables to apply `fun_like.has_coe_to_fun`
directly.
-/
instance : CoeFun (M →ₛₗ[σ] M₃) fun _ => M → M₃ :=
  ⟨fun f => f⟩

#print LinearMap.toDistribMulActionHom /-
/-- The `distrib_mul_action_hom` underlying a `linear_map`. -/
def toDistribMulActionHom (f : M →ₗ[R] M₂) : DistribMulActionHom R M M₂ :=
  { f with map_zero' := show f 0 = 0 from map_zero f }
#align linear_map.to_distrib_mul_action_hom LinearMap.toDistribMulActionHom
-/

/- warning: linear_map.to_fun_eq_coe -> LinearMap.toFun_eq_coe is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_6 : AddCommMonoid.{u4} M₃] [_inst_10 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_12 : Module.{u2, u4} S M₃ _inst_2 _inst_6] {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {f : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12}, Eq.{max (succ u3) (succ u4)} (M -> M₃) (LinearMap.toFun.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12 f) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f)
but is expected to have type
  forall {R : Type.{u4}} {S : Type.{u3}} {M : Type.{u2}} {M₃ : Type.{u1}} [_inst_1 : Semiring.{u4} R] [_inst_2 : Semiring.{u3} S] [_inst_3 : AddCommMonoid.{u2} M] [_inst_6 : AddCommMonoid.{u1} M₃] [_inst_10 : Module.{u4, u2} R M _inst_1 _inst_3] [_inst_12 : Module.{u3, u1} S M₃ _inst_2 _inst_6] {σ : RingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)} {f : LinearMap.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12}, Eq.{max (succ u2) (succ u1)} (M -> M₃) (AddHom.toFun.{u2, u1} M M₃ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddZeroClass.toAdd.{u1} M₃ (AddMonoid.toAddZeroClass.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6))) (LinearMap.toAddHom.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12 f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u4, u3, u2, u1} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f)
Case conversion may be inaccurate. Consider using '#align linear_map.to_fun_eq_coe LinearMap.toFun_eq_coeₓ'. -/
@[simp]
theorem toFun_eq_coe {f : M →ₛₗ[σ] M₃} : f.toFun = (f : M → M₃) :=
  rfl
#align linear_map.to_fun_eq_coe LinearMap.toFun_eq_coe

/- warning: linear_map.ext -> LinearMap.ext is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_6 : AddCommMonoid.{u4} M₃] [_inst_10 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_12 : Module.{u2, u4} S M₃ _inst_2 _inst_6] {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {f : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12} {g : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12}, (forall (x : M), Eq.{succ u4} M₃ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f x) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) g x)) -> (Eq.{max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) f g)
but is expected to have type
  forall {R : Type.{u4}} {S : Type.{u3}} {M : Type.{u2}} {M₃ : Type.{u1}} [_inst_1 : Semiring.{u4} R] [_inst_2 : Semiring.{u3} S] [_inst_3 : AddCommMonoid.{u2} M] [_inst_6 : AddCommMonoid.{u1} M₃] [_inst_10 : Module.{u4, u2} R M _inst_1 _inst_3] [_inst_12 : Module.{u3, u1} S M₃ _inst_2 _inst_6] {σ : RingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)} {f : LinearMap.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12} {g : LinearMap.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12}, (forall (x : M), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u4, u3, u2, u1} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u4, u3, u2, u1} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) g x)) -> (Eq.{max (succ u2) (succ u1)} (LinearMap.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) f g)
Case conversion may be inaccurate. Consider using '#align linear_map.ext LinearMap.extₓ'. -/
@[ext]
theorem ext {f g : M →ₛₗ[σ] M₃} (h : ∀ x, f x = g x) : f = g :=
  FunLike.ext f g h
#align linear_map.ext LinearMap.ext

/- warning: linear_map.copy -> LinearMap.copy is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_6 : AddCommMonoid.{u4} M₃] [_inst_10 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_12 : Module.{u2, u4} S M₃ _inst_2 _inst_6] {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} (f : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (f' : M -> M₃), (Eq.{max (succ u3) (succ u4)} (M -> M₃) f' (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (fun (f : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f)) -> (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_6 : AddCommMonoid.{u4} M₃] [_inst_10 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_12 : Module.{u2, u4} S M₃ _inst_2 _inst_6] {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} (f : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (f' : M -> M₃), (Eq.{max (succ u3) (succ u4)} (M -> M₃) f' (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) M (fun (f : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) f) (LinearMap.instFunLikeLinearMap.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f)) -> (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12)
Case conversion may be inaccurate. Consider using '#align linear_map.copy LinearMap.copyₓ'. -/
/-- Copy of a `linear_map` with a new `to_fun` equal to the old one. Useful to fix definitional
equalities. -/
protected def copy (f : M →ₛₗ[σ] M₃) (f' : M → M₃) (h : f' = ⇑f) : M →ₛₗ[σ] M₃
    where
  toFun := f'
  map_add' := h.symm ▸ f.map_add'
  map_smul' := h.symm ▸ f.map_smul'
#align linear_map.copy LinearMap.copy

/- warning: linear_map.coe_copy -> LinearMap.coe_copy is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_6 : AddCommMonoid.{u4} M₃] [_inst_10 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_12 : Module.{u2, u4} S M₃ _inst_2 _inst_6] {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} (f : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (f' : M -> M₃) (h : Eq.{max (succ u3) (succ u4)} (M -> M₃) f' (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (fun (f : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f)), Eq.{max (succ u3) (succ u4)} (M -> M₃) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) (LinearMap.copy.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ f f' h)) f'
but is expected to have type
  forall {R : Type.{u4}} {S : Type.{u3}} {M : Type.{u2}} {M₃ : Type.{u1}} [_inst_1 : Semiring.{u4} R] [_inst_2 : Semiring.{u3} S] [_inst_3 : AddCommMonoid.{u2} M] [_inst_6 : AddCommMonoid.{u1} M₃] [_inst_10 : Module.{u4, u2} R M _inst_1 _inst_3] [_inst_12 : Module.{u3, u1} S M₃ _inst_2 _inst_6] {σ : RingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)} (f : LinearMap.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (f' : M -> M₃) (h : Eq.{max (succ u2) (succ u1)} (M -> M₃) f' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) M (fun (f : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) f) (LinearMap.instFunLikeLinearMap.{u4, u3, u2, u1} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f)), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : M), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u4, u3, u2, u1} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) (LinearMap.copy.{u4, u3, u2, u1} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ f f' h)) f'
Case conversion may be inaccurate. Consider using '#align linear_map.coe_copy LinearMap.coe_copyₓ'. -/
@[simp]
theorem coe_copy (f : M →ₛₗ[σ] M₃) (f' : M → M₃) (h : f' = ⇑f) : ⇑(f.copy f' h) = f' :=
  rfl
#align linear_map.coe_copy LinearMap.coe_copy

/- warning: linear_map.copy_eq -> LinearMap.copy_eq is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_6 : AddCommMonoid.{u4} M₃] [_inst_10 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_12 : Module.{u2, u4} S M₃ _inst_2 _inst_6] {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} (f : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (f' : M -> M₃) (h : Eq.{max (succ u3) (succ u4)} (M -> M₃) f' (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (fun (f : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f)), Eq.{max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (LinearMap.copy.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ f f' h) f
but is expected to have type
  forall {R : Type.{u4}} {S : Type.{u3}} {M : Type.{u2}} {M₃ : Type.{u1}} [_inst_1 : Semiring.{u4} R] [_inst_2 : Semiring.{u3} S] [_inst_3 : AddCommMonoid.{u2} M] [_inst_6 : AddCommMonoid.{u1} M₃] [_inst_10 : Module.{u4, u2} R M _inst_1 _inst_3] [_inst_12 : Module.{u3, u1} S M₃ _inst_2 _inst_6] {σ : RingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)} (f : LinearMap.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (f' : M -> M₃) (h : Eq.{max (succ u2) (succ u1)} (M -> M₃) f' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) M (fun (f : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) f) (LinearMap.instFunLikeLinearMap.{u4, u3, u2, u1} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f)), Eq.{max (succ u2) (succ u1)} (LinearMap.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (LinearMap.copy.{u4, u3, u2, u1} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ f f' h) f
Case conversion may be inaccurate. Consider using '#align linear_map.copy_eq LinearMap.copy_eqₓ'. -/
theorem copy_eq (f : M →ₛₗ[σ] M₃) (f' : M → M₃) (h : f' = ⇑f) : f.copy f' h = f :=
  FunLike.ext' h
#align linear_map.copy_eq LinearMap.copy_eq

#print LinearMap.Simps.apply /-
/-- See Note [custom simps projection]. -/
protected def Simps.apply {R S : Type _} [Semiring R] [Semiring S] (σ : R →+* S) (M M₃ : Type _)
    [AddCommMonoid M] [AddCommMonoid M₃] [Module R M] [Module S M₃] (f : M →ₛₗ[σ] M₃) : M → M₃ :=
  f
#align linear_map.simps.apply LinearMap.Simps.apply
-/

initialize_simps_projections LinearMap (toFun → apply)

/- warning: linear_map.coe_mk -> LinearMap.coe_mk is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_6 : AddCommMonoid.{u4} M₃] [_inst_10 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_12 : Module.{u2, u4} S M₃ _inst_2 _inst_6] {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} (f : M -> M₃) (h₁ : forall (x : M) (y : M), Eq.{succ u4} M₃ (f (HAdd.hAdd.{u3, u3, u3} M M M (instHAdd.{u3} M (AddZeroClass.toHasAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)))) x y)) (HAdd.hAdd.{u4, u4, u4} M₃ M₃ M₃ (instHAdd.{u4} M₃ (AddZeroClass.toHasAdd.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6)))) (f x) (f y))) (h₂ : forall (r : R) (x : M), Eq.{succ u4} M₃ (f (SMul.smul.{u1, u3} R M (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_3 _inst_10)))) r x)) (SMul.smul.{u2, u4} S M₃ (SMulZeroClass.toHasSmul.{u2, u4} S M₃ (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6))) (SMulWithZero.toSmulZeroClass.{u2, u4} S M₃ (MulZeroClass.toHasZero.{u2} S (MulZeroOneClass.toMulZeroClass.{u2} S (MonoidWithZero.toMulZeroOneClass.{u2} S (Semiring.toMonoidWithZero.{u2} S _inst_2)))) (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6))) (MulActionWithZero.toSMulWithZero.{u2, u4} S M₃ (Semiring.toMonoidWithZero.{u2} S _inst_2) (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6))) (Module.toMulActionWithZero.{u2, u4} S M₃ _inst_2 _inst_6 _inst_12)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (fun (_x : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) σ r) (f x))), Eq.{max (succ u3) (succ u4)} ((fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) => M -> M₃) (LinearMap.mk.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12 f h₁ h₂)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) (LinearMap.mk.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12 f h₁ h₂)) f
but is expected to have type
  forall {R : Type.{u4}} {S : Type.{u3}} {M : Type.{u2}} {M₃ : Type.{u1}} [_inst_1 : Semiring.{u4} R] [_inst_2 : Semiring.{u3} S] [_inst_3 : AddCommMonoid.{u2} M] [_inst_6 : AddCommMonoid.{u1} M₃] [_inst_10 : Module.{u4, u2} R M _inst_1 _inst_3] [_inst_12 : Module.{u3, u1} S M₃ _inst_2 _inst_6] {σ : RingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)} (f : AddMonoidHom.{u2, u1} M M₃ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (AddMonoid.toAddZeroClass.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6))) (h₁ : forall (x : R) (y : M), Eq.{succ u1} M₃ (AddHom.toFun.{u2, u1} M M₃ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddZeroClass.toAdd.{u1} M₃ (AddMonoid.toAddZeroClass.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6))) (AddHomClass.toAddHom.{u2, u1, max u2 u1} M M₃ (AddMonoidHom.{u2, u1} M M₃ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (AddMonoid.toAddZeroClass.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6))) (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddZeroClass.toAdd.{u1} M₃ (AddMonoid.toAddZeroClass.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} M M₃ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (AddMonoid.toAddZeroClass.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6))) M M₃ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (AddMonoid.toAddZeroClass.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6)) (AddMonoidHom.addMonoidHomClass.{u2, u1} M M₃ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (AddMonoid.toAddZeroClass.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6)))) f) (HSMul.hSMul.{u4, u2, u2} R M M (instHSMul.{u4, u2} R M (SMulZeroClass.toSMul.{u4, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u4, u2} R M (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u4, u2} R M (Semiring.toMonoidWithZero.{u4} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (Module.toMulActionWithZero.{u4, u2} R M _inst_1 _inst_3 _inst_10))))) x y)) (HSMul.hSMul.{u3, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) x) M₃ M₃ (instHSMul.{u3, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) x) M₃ (SMulZeroClass.toSMul.{u3, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) x) M₃ (AddMonoid.toZero.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6)) (SMulWithZero.toSMulZeroClass.{u3, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) x) M₃ (MonoidWithZero.toZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) x) (Semiring.toMonoidWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) x) _inst_2)) (AddMonoid.toZero.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6)) (MulActionWithZero.toSMulWithZero.{u3, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) x) M₃ (Semiring.toMonoidWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) x) _inst_2) (AddMonoid.toZero.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6)) (Module.toMulActionWithZero.{u3, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) x) M₃ _inst_2 _inst_6 _inst_12))))) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (RingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)) R (fun (a : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) a) (MulHomClass.toFunLike.{max u4 u3, u4, u3} (RingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)) R S (NonUnitalNonAssocSemiring.toMul.{u4} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u4 u3, u4, u3} (RingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u4 u3, u4, u3} (RingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)) R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2) (RingHom.instRingHomClassRingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2))))) σ x) (AddHom.toFun.{u2, u1} M M₃ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddZeroClass.toAdd.{u1} M₃ (AddMonoid.toAddZeroClass.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6))) (AddHomClass.toAddHom.{u2, u1, max u2 u1} M M₃ (AddMonoidHom.{u2, u1} M M₃ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (AddMonoid.toAddZeroClass.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6))) (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddZeroClass.toAdd.{u1} M₃ (AddMonoid.toAddZeroClass.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} M M₃ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (AddMonoid.toAddZeroClass.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6))) M M₃ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (AddMonoid.toAddZeroClass.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6)) (AddMonoidHom.addMonoidHomClass.{u2, u1} M M₃ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (AddMonoid.toAddZeroClass.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6)))) f) y))), Eq.{max (succ u2) (succ u1)} (forall (a : M), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) M (fun (a : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) a) (LinearMap.instFunLikeLinearMap.{u4, u3, u2, u1} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) (LinearMap.mk.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12 (AddHomClass.toAddHom.{u2, u1, max u2 u1} M M₃ (AddMonoidHom.{u2, u1} M M₃ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (AddMonoid.toAddZeroClass.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6))) (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddZeroClass.toAdd.{u1} M₃ (AddMonoid.toAddZeroClass.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} M M₃ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (AddMonoid.toAddZeroClass.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6))) M M₃ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (AddMonoid.toAddZeroClass.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6)) (AddMonoidHom.addMonoidHomClass.{u2, u1} M M₃ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (AddMonoid.toAddZeroClass.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6)))) f) h₁)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AddMonoidHom.{u2, u1} M M₃ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (AddMonoid.toAddZeroClass.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6))) M (fun (a : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₃) a) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} M M₃ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (AddMonoid.toAddZeroClass.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6))) M M₃ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddZeroClass.toAdd.{u1} M₃ (AddMonoid.toAddZeroClass.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} M M₃ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (AddMonoid.toAddZeroClass.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6))) M M₃ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (AddMonoid.toAddZeroClass.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6)) (AddMonoidHom.addMonoidHomClass.{u2, u1} M M₃ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (AddMonoid.toAddZeroClass.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6))))) f)
Case conversion may be inaccurate. Consider using '#align linear_map.coe_mk LinearMap.coe_mkₓ'. -/
@[simp]
theorem coe_mk {σ : R →+* S} (f : M → M₃) (h₁ h₂) :
    ((LinearMap.mk f h₁ h₂ : M →ₛₗ[σ] M₃) : M → M₃) = f :=
  rfl
#align linear_map.coe_mk LinearMap.coe_mk

#print LinearMap.id /-
/-- Identity map as a `linear_map` -/
def id : M →ₗ[R] M :=
  { DistribMulActionHom.id R with toFun := id }
#align linear_map.id LinearMap.id
-/

/- warning: linear_map.id_apply -> LinearMap.id_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_10 : Module.{u1, u2} R M _inst_1 _inst_3] (x : M), Eq.{succ u2} M (coeFn.{succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_3 _inst_3 _inst_10 _inst_10) (fun (_x : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_3 _inst_3 _inst_10 _inst_10) => M -> M) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R M M _inst_1 _inst_1 _inst_3 _inst_3 _inst_10 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.id.{u1, u2} R M _inst_1 _inst_3 _inst_10) x) x
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_10 : Module.{u1, u2} R M _inst_1 _inst_3] (x : M), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M) x) (FunLike.coe.{succ u2, succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_3 _inst_3 _inst_10 _inst_10) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} R R M M _inst_1 _inst_1 _inst_3 _inst_3 _inst_10 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.id.{u1, u2} R M _inst_1 _inst_3 _inst_10) x) x
Case conversion may be inaccurate. Consider using '#align linear_map.id_apply LinearMap.id_applyₓ'. -/
theorem id_apply (x : M) : @id R M _ _ _ x = x :=
  rfl
#align linear_map.id_apply LinearMap.id_apply

/- warning: linear_map.id_coe -> LinearMap.id_coe is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_10 : Module.{u1, u2} R M _inst_1 _inst_3], Eq.{succ u2} ((fun (_x : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_3 _inst_3 _inst_10 _inst_10) => M -> M) (LinearMap.id.{u1, u2} R M _inst_1 _inst_3 _inst_10)) (coeFn.{succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_3 _inst_3 _inst_10 _inst_10) (fun (_x : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_3 _inst_3 _inst_10 _inst_10) => M -> M) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R M M _inst_1 _inst_1 _inst_3 _inst_3 _inst_10 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.id.{u1, u2} R M _inst_1 _inst_3 _inst_10)) (id.{succ u2} M)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_10 : Module.{u1, u2} R M _inst_1 _inst_3], Eq.{succ u2} (forall (a : M), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M) a) (FunLike.coe.{succ u2, succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_3 _inst_3 _inst_10 _inst_10) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} R R M M _inst_1 _inst_1 _inst_3 _inst_3 _inst_10 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.id.{u1, u2} R M _inst_1 _inst_3 _inst_10)) (id.{succ u2} M)
Case conversion may be inaccurate. Consider using '#align linear_map.id_coe LinearMap.id_coeₓ'. -/
@[simp, norm_cast]
theorem id_coe : ((LinearMap.id : M →ₗ[R] M) : M → M) = id :=
  rfl
#align linear_map.id_coe LinearMap.id_coe

end

section

variable [AddCommMonoid M] [AddCommMonoid M₁] [AddCommMonoid M₂] [AddCommMonoid M₃]

variable [AddCommMonoid N₁] [AddCommMonoid N₂] [AddCommMonoid N₃]

variable [Module R M] [Module R M₂] [Module S M₃]

variable (σ : R →+* S)

variable (fₗ gₗ : M →ₗ[R] M₂) (f g : M →ₛₗ[σ] M₃)

/- warning: linear_map.is_linear -> LinearMap.isLinear is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_5 : AddCommMonoid.{u3} M₂] [_inst_10 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_11 : Module.{u1, u3} R M₂ _inst_1 _inst_5] (fₗ : LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_5 _inst_10 _inst_11), IsLinearMap.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_5 _inst_10 _inst_11 (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_5 _inst_10 _inst_11) (fun (_x : LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_5 _inst_10 _inst_11) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_3 _inst_5 _inst_10 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) fₗ)
but is expected to have type
  forall {R : Type.{u3}} {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_5 : AddCommMonoid.{u1} M₂] [_inst_10 : Module.{u3, u2} R M _inst_1 _inst_3] [_inst_11 : Module.{u3, u1} R M₂ _inst_1 _inst_5] (fₗ : LinearMap.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M₂ _inst_3 _inst_5 _inst_10 _inst_11), IsLinearMap.{u3, u2, u1} R M M₂ _inst_1 _inst_3 _inst_5 _inst_10 _inst_11 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M₂ _inst_3 _inst_5 _inst_10 _inst_11) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u2, u1} R R M M₂ _inst_1 _inst_1 _inst_3 _inst_5 _inst_10 _inst_11 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) fₗ)
Case conversion may be inaccurate. Consider using '#align linear_map.is_linear LinearMap.isLinearₓ'. -/
theorem isLinear : IsLinearMap R fₗ :=
  ⟨fₗ.map_add', fₗ.map_smul'⟩
#align linear_map.is_linear LinearMap.isLinear

variable {fₗ gₗ f g σ}

/- warning: linear_map.coe_injective -> LinearMap.coe_injective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_6 : AddCommMonoid.{u4} M₃] [_inst_10 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_12 : Module.{u2, u4} S M₃ _inst_2 _inst_6] {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)}, Function.Injective.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (M -> M₃) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (fun (ᾰ : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u4}} {M₃ : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_3 : AddCommMonoid.{u4} M] [_inst_6 : AddCommMonoid.{u3} M₃] [_inst_10 : Module.{u2, u4} R M _inst_1 _inst_3] [_inst_12 : Module.{u1, u3} S M₃ _inst_2 _inst_6] {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)}, Function.Injective.{max (succ u4) (succ u3), max (succ u4) (succ u3)} (LinearMap.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (M -> M₃) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearMap.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) M (fun (ᾰ : M) => M₃) (LinearMap.instFunLikeLinearMap.{u2, u1, u4, u3} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ))
Case conversion may be inaccurate. Consider using '#align linear_map.coe_injective LinearMap.coe_injectiveₓ'. -/
theorem coe_injective : @Injective (M →ₛₗ[σ] M₃) (M → M₃) coeFn :=
  FunLike.coe_injective
#align linear_map.coe_injective LinearMap.coe_injective

/- warning: linear_map.congr_arg -> LinearMap.congr_arg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_6 : AddCommMonoid.{u4} M₃] [_inst_10 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_12 : Module.{u2, u4} S M₃ _inst_2 _inst_6] {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {f : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12} {x : M} {x' : M}, (Eq.{succ u3} M x x') -> (Eq.{succ u4} M₃ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f x) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f x'))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u4}} {M₃ : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_3 : AddCommMonoid.{u4} M] [_inst_6 : AddCommMonoid.{u3} M₃] [_inst_10 : Module.{u2, u4} R M _inst_1 _inst_3] [_inst_12 : Module.{u1, u3} S M₃ _inst_2 _inst_6] {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} {f : LinearMap.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12} {x : M} {x' : M}, (Eq.{succ u4} M x x') -> (Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearMap.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u2, u1, u4, u3} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f x) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearMap.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u2, u1, u4, u3} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f x'))
Case conversion may be inaccurate. Consider using '#align linear_map.congr_arg LinearMap.congr_argₓ'. -/
protected theorem congr_arg {x x' : M} : x = x' → f x = f x' :=
  FunLike.congr_arg f
#align linear_map.congr_arg LinearMap.congr_arg

/- warning: linear_map.congr_fun -> LinearMap.congr_fun is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_6 : AddCommMonoid.{u4} M₃] [_inst_10 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_12 : Module.{u2, u4} S M₃ _inst_2 _inst_6] {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {f : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12} {g : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12}, (Eq.{max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) f g) -> (forall (x : M), Eq.{succ u4} M₃ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f x) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) g x))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u4}} {M₃ : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_3 : AddCommMonoid.{u4} M] [_inst_6 : AddCommMonoid.{u3} M₃] [_inst_10 : Module.{u2, u4} R M _inst_1 _inst_3] [_inst_12 : Module.{u1, u3} S M₃ _inst_2 _inst_6] {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} {f : LinearMap.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12} {g : LinearMap.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12}, (Eq.{max (succ u4) (succ u3)} (LinearMap.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) f g) -> (forall (x : M), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearMap.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u2, u1, u4, u3} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f x) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearMap.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u2, u1, u4, u3} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) g x))
Case conversion may be inaccurate. Consider using '#align linear_map.congr_fun LinearMap.congr_funₓ'. -/
/-- If two linear maps are equal, they are equal at each point. -/
protected theorem congr_fun (h : f = g) (x : M) : f x = g x :=
  FunLike.congr_fun h x
#align linear_map.congr_fun LinearMap.congr_fun

/- warning: linear_map.ext_iff -> LinearMap.ext_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_6 : AddCommMonoid.{u4} M₃] [_inst_10 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_12 : Module.{u2, u4} S M₃ _inst_2 _inst_6] {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {f : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12} {g : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12}, Iff (Eq.{max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) f g) (forall (x : M), Eq.{succ u4} M₃ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f x) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) g x))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u4}} {M₃ : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_3 : AddCommMonoid.{u4} M] [_inst_6 : AddCommMonoid.{u3} M₃] [_inst_10 : Module.{u2, u4} R M _inst_1 _inst_3] [_inst_12 : Module.{u1, u3} S M₃ _inst_2 _inst_6] {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} {f : LinearMap.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12} {g : LinearMap.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12}, Iff (Eq.{max (succ u4) (succ u3)} (LinearMap.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) f g) (forall (x : M), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearMap.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u2, u1, u4, u3} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f x) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearMap.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u2, u1, u4, u3} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) g x))
Case conversion may be inaccurate. Consider using '#align linear_map.ext_iff LinearMap.ext_iffₓ'. -/
theorem ext_iff : f = g ↔ ∀ x, f x = g x :=
  FunLike.ext_iff
#align linear_map.ext_iff LinearMap.ext_iff

/- warning: linear_map.mk_coe -> LinearMap.mk_coe is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_6 : AddCommMonoid.{u4} M₃] [_inst_10 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_12 : Module.{u2, u4} S M₃ _inst_2 _inst_6] {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} (f : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (h₁ : forall (x : M) (y : M), Eq.{succ u4} M₃ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f (HAdd.hAdd.{u3, u3, u3} M M M (instHAdd.{u3} M (AddZeroClass.toHasAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)))) x y)) (HAdd.hAdd.{u4, u4, u4} M₃ M₃ M₃ (instHAdd.{u4} M₃ (AddZeroClass.toHasAdd.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6)))) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f x) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f y))) (h₂ : forall (r : R) (x : M), Eq.{succ u4} M₃ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f (SMul.smul.{u1, u3} R M (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_3 _inst_10)))) r x)) (SMul.smul.{u2, u4} S M₃ (SMulZeroClass.toHasSmul.{u2, u4} S M₃ (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6))) (SMulWithZero.toSmulZeroClass.{u2, u4} S M₃ (MulZeroClass.toHasZero.{u2} S (MulZeroOneClass.toMulZeroClass.{u2} S (MonoidWithZero.toMulZeroOneClass.{u2} S (Semiring.toMonoidWithZero.{u2} S _inst_2)))) (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6))) (MulActionWithZero.toSMulWithZero.{u2, u4} S M₃ (Semiring.toMonoidWithZero.{u2} S _inst_2) (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6))) (Module.toMulActionWithZero.{u2, u4} S M₃ _inst_2 _inst_6 _inst_12)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (fun (_x : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) σ r) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f x))), Eq.{max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (LinearMap.mk.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12 (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f) h₁ h₂) f
but is expected to have type
  forall {R : Type.{u4}} {S : Type.{u3}} {M : Type.{u2}} {M₃ : Type.{u1}} [_inst_1 : Semiring.{u4} R] [_inst_2 : Semiring.{u3} S] [_inst_3 : AddCommMonoid.{u2} M] [_inst_6 : AddCommMonoid.{u1} M₃] [_inst_10 : Module.{u4, u2} R M _inst_1 _inst_3] [_inst_12 : Module.{u3, u1} S M₃ _inst_2 _inst_6] {σ : RingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)} (f : LinearMap.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (h₁ : forall (x : R) (y : M), Eq.{succ u1} M₃ (AddHom.toFun.{u2, u1} M M₃ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddZeroClass.toAdd.{u1} M₃ (AddMonoid.toAddZeroClass.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6))) (AddHomClass.toAddHom.{u2, u1, max u2 u1} M M₃ (LinearMap.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddZeroClass.toAdd.{u1} M₃ (AddMonoid.toAddZeroClass.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6))) (SemilinearMapClass.toAddHomClass.{max u2 u1, u4, u3, u2, u1} (LinearMap.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12 (LinearMap.instSemilinearMapClassLinearMap.{u4, u3, u2, u1} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ)) f) (HSMul.hSMul.{u4, u2, u2} R M M (instHSMul.{u4, u2} R M (SMulZeroClass.toSMul.{u4, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u4, u2} R M (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u4, u2} R M (Semiring.toMonoidWithZero.{u4} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (Module.toMulActionWithZero.{u4, u2} R M _inst_1 _inst_3 _inst_10))))) x y)) (HSMul.hSMul.{u3, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) x) M₃ M₃ (instHSMul.{u3, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) x) M₃ (SMulZeroClass.toSMul.{u3, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) x) M₃ (AddMonoid.toZero.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6)) (SMulWithZero.toSMulZeroClass.{u3, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) x) M₃ (MonoidWithZero.toZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) x) (Semiring.toMonoidWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) x) _inst_2)) (AddMonoid.toZero.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6)) (MulActionWithZero.toSMulWithZero.{u3, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) x) M₃ (Semiring.toMonoidWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) x) _inst_2) (AddMonoid.toZero.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6)) (Module.toMulActionWithZero.{u3, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) x) M₃ _inst_2 _inst_6 _inst_12))))) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (RingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) _x) (MulHomClass.toFunLike.{max u4 u3, u4, u3} (RingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)) R S (NonUnitalNonAssocSemiring.toMul.{u4} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u4 u3, u4, u3} (RingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u4 u3, u4, u3} (RingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)) R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2) (RingHom.instRingHomClassRingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2))))) σ x) (AddHom.toFun.{u2, u1} M M₃ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddZeroClass.toAdd.{u1} M₃ (AddMonoid.toAddZeroClass.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6))) (AddHomClass.toAddHom.{u2, u1, max u2 u1} M M₃ (LinearMap.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddZeroClass.toAdd.{u1} M₃ (AddMonoid.toAddZeroClass.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6))) (SemilinearMapClass.toAddHomClass.{max u2 u1, u4, u3, u2, u1} (LinearMap.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12 (LinearMap.instSemilinearMapClassLinearMap.{u4, u3, u2, u1} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ)) f) y))), Eq.{max (succ u2) (succ u1)} (LinearMap.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (LinearMap.mk.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12 (AddHomClass.toAddHom.{u2, u1, max u2 u1} M M₃ (LinearMap.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddZeroClass.toAdd.{u1} M₃ (AddMonoid.toAddZeroClass.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6))) (SemilinearMapClass.toAddHomClass.{max u2 u1, u4, u3, u2, u1} (LinearMap.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12 (LinearMap.instSemilinearMapClassLinearMap.{u4, u3, u2, u1} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ)) f) h₁) f
Case conversion may be inaccurate. Consider using '#align linear_map.mk_coe LinearMap.mk_coeₓ'. -/
@[simp]
theorem mk_coe (f : M →ₛₗ[σ] M₃) (h₁ h₂) : (LinearMap.mk f h₁ h₂ : M →ₛₗ[σ] M₃) = f :=
  ext fun _ => rfl
#align linear_map.mk_coe LinearMap.mk_coe

variable (fₗ gₗ f g)

/- warning: linear_map.map_add -> LinearMap.map_add is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_6 : AddCommMonoid.{u4} M₃] [_inst_10 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_12 : Module.{u2, u4} S M₃ _inst_2 _inst_6] {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} (f : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (x : M) (y : M), Eq.{succ u4} M₃ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f (HAdd.hAdd.{u3, u3, u3} M M M (instHAdd.{u3} M (AddZeroClass.toHasAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)))) x y)) (HAdd.hAdd.{u4, u4, u4} M₃ M₃ M₃ (instHAdd.{u4} M₃ (AddZeroClass.toHasAdd.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6)))) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f x) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f y))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_6 : AddCommMonoid.{u4} M₃] [_inst_10 : Module.{u2, u3} R M _inst_1 _inst_3] [_inst_12 : Module.{u1, u4} S M₃ _inst_2 _inst_6] {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} (f : LinearMap.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (x : M) (y : M), Eq.{succ u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) (HAdd.hAdd.{u3, u3, u3} M M M (instHAdd.{u3} M (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)))) x y)) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearMap.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u2, u1, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f (HAdd.hAdd.{u3, u3, u3} M M M (instHAdd.{u3} M (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)))) x y)) (HAdd.hAdd.{u4, u4, u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) y) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) (instHAdd.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) (AddZeroClass.toAdd.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) (AddMonoid.toAddZeroClass.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) (AddCommMonoid.toAddMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) _inst_6)))) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearMap.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u2, u1, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f x) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearMap.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u2, u1, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f y))
Case conversion may be inaccurate. Consider using '#align linear_map.map_add LinearMap.map_addₓ'. -/
protected theorem map_add (x y : M) : f (x + y) = f x + f y :=
  map_add f x y
#align linear_map.map_add LinearMap.map_add

/- warning: linear_map.map_zero -> LinearMap.map_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_6 : AddCommMonoid.{u4} M₃] [_inst_10 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_12 : Module.{u2, u4} S M₃ _inst_2 _inst_6] {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} (f : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12), Eq.{succ u4} M₃ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f (OfNat.ofNat.{u3} M 0 (OfNat.mk.{u3} M 0 (Zero.zero.{u3} M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))))))) (OfNat.ofNat.{u4} M₃ 0 (OfNat.mk.{u4} M₃ 0 (Zero.zero.{u4} M₃ (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6))))))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_6 : AddCommMonoid.{u4} M₃] [_inst_10 : Module.{u2, u3} R M _inst_1 _inst_3] [_inst_12 : Module.{u1, u4} S M₃ _inst_2 _inst_6] {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} (f : LinearMap.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12), Eq.{succ u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))))) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearMap.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u2, u1, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))))) (OfNat.ofNat.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))))) 0 (Zero.toOfNat0.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))))) (AddMonoid.toZero.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))))) (AddCommMonoid.toAddMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))))) _inst_6))))
Case conversion may be inaccurate. Consider using '#align linear_map.map_zero LinearMap.map_zeroₓ'. -/
protected theorem map_zero : f 0 = 0 :=
  map_zero f
#align linear_map.map_zero LinearMap.map_zero

/- warning: linear_map.map_smulₛₗ -> LinearMap.map_smulₛₗ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_6 : AddCommMonoid.{u4} M₃] [_inst_10 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_12 : Module.{u2, u4} S M₃ _inst_2 _inst_6] {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} (f : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (c : R) (x : M), Eq.{succ u4} M₃ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f (SMul.smul.{u1, u3} R M (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_3 _inst_10)))) c x)) (SMul.smul.{u2, u4} S M₃ (SMulZeroClass.toHasSmul.{u2, u4} S M₃ (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6))) (SMulWithZero.toSmulZeroClass.{u2, u4} S M₃ (MulZeroClass.toHasZero.{u2} S (MulZeroOneClass.toMulZeroClass.{u2} S (MonoidWithZero.toMulZeroOneClass.{u2} S (Semiring.toMonoidWithZero.{u2} S _inst_2)))) (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6))) (MulActionWithZero.toSMulWithZero.{u2, u4} S M₃ (Semiring.toMonoidWithZero.{u2} S _inst_2) (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6))) (Module.toMulActionWithZero.{u2, u4} S M₃ _inst_2 _inst_6 _inst_12)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (fun (_x : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) σ c) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f x))
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u1}} {M : Type.{u2}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u3} R] [_inst_2 : Semiring.{u1} S] [_inst_3 : AddCommMonoid.{u2} M] [_inst_6 : AddCommMonoid.{u4} M₃] [_inst_10 : Module.{u3, u2} R M _inst_1 _inst_3] [_inst_12 : Module.{u1, u4} S M₃ _inst_2 _inst_6] {σ : RingHom.{u3, u1} R S (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} (f : LinearMap.{u3, u1, u2, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (c : R) (x : M), Eq.{succ u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) (HSMul.hSMul.{u3, u2, u2} R M M (instHSMul.{u3, u2} R M (SMulZeroClass.toSMul.{u3, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u3, u2} R M (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (Module.toMulActionWithZero.{u3, u2} R M _inst_1 _inst_3 _inst_10))))) c x)) (FunLike.coe.{max (succ u2) (succ u4), succ u2, succ u4} (LinearMap.{u3, u1, u2, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u3, u1, u2, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f (HSMul.hSMul.{u3, u2, u2} R M M (instHSMul.{u3, u2} R M (SMulZeroClass.toSMul.{u3, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u3, u2} R M (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (Module.toMulActionWithZero.{u3, u2} R M _inst_1 _inst_3 _inst_10))))) c x)) (HSMul.hSMul.{u1, u4, u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) (instHSMul.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) (SMulZeroClass.toSMul.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) (AddMonoid.toZero.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) (AddCommMonoid.toAddMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) _inst_6)) (SMulWithZero.toSMulZeroClass.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) (MonoidWithZero.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) (Semiring.toMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) _inst_2)) (AddMonoid.toZero.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) (AddCommMonoid.toAddMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) _inst_6)) (MulActionWithZero.toSMulWithZero.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) (Semiring.toMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) _inst_2) (AddMonoid.toZero.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) (AddCommMonoid.toAddMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) _inst_6)) (Module.toMulActionWithZero.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) _inst_2 _inst_6 _inst_12))))) (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (RingHom.{u3, u1} R S (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) _x) (MulHomClass.toFunLike.{max u3 u1, u3, u1} (RingHom.{u3, u1} R S (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)) R S (NonUnitalNonAssocSemiring.toMul.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u3 u1, u3, u1} (RingHom.{u3, u1} R S (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u3 u1, u3, u1} (RingHom.{u3, u1} R S (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)) R S (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2) (RingHom.instRingHomClassRingHom.{u3, u1} R S (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2))))) σ c) (FunLike.coe.{max (succ u2) (succ u4), succ u2, succ u4} (LinearMap.{u3, u1, u2, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u3, u1, u2, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f x))
Case conversion may be inaccurate. Consider using '#align linear_map.map_smulₛₗ LinearMap.map_smulₛₗₓ'. -/
-- TODO: `simp` isn't picking up `map_smulₛₗ` for `linear_map`s without specifying `map_smulₛₗ f`
@[simp]
protected theorem map_smulₛₗ (c : R) (x : M) : f (c • x) = σ c • f x :=
  map_smulₛₗ f c x
#align linear_map.map_smulₛₗ LinearMap.map_smulₛₗ

/- warning: linear_map.map_smul -> LinearMap.map_smul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_5 : AddCommMonoid.{u3} M₂] [_inst_10 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_11 : Module.{u1, u3} R M₂ _inst_1 _inst_5] (fₗ : LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_5 _inst_10 _inst_11) (c : R) (x : M), Eq.{succ u3} M₂ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_5 _inst_10 _inst_11) (fun (_x : LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_5 _inst_10 _inst_11) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_3 _inst_5 _inst_10 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) fₗ (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_3 _inst_10)))) c x)) (SMul.smul.{u1, u3} R M₂ (SMulZeroClass.toHasSmul.{u1, u3} R M₂ (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M₂ (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M₂ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5))) (Module.toMulActionWithZero.{u1, u3} R M₂ _inst_1 _inst_5 _inst_11)))) c (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_5 _inst_10 _inst_11) (fun (_x : LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_5 _inst_10 _inst_11) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_3 _inst_5 _inst_10 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) fₗ x))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_5 : AddCommMonoid.{u3} M₂] [_inst_10 : Module.{u2, u1} R M _inst_1 _inst_3] [_inst_11 : Module.{u2, u3} R M₂ _inst_1 _inst_5] (fₗ : LinearMap.{u2, u2, u1, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M M₂ _inst_3 _inst_5 _inst_10 _inst_11) (c : R) (x : M), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_3 _inst_10))))) c x)) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (LinearMap.{u2, u2, u1, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M M₂ _inst_3 _inst_5 _inst_10 _inst_11) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, u1, u3} R R M M₂ _inst_1 _inst_1 _inst_3 _inst_5 _inst_10 _inst_11 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) fₗ (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_3 _inst_10))))) c x)) (HSMul.hSMul.{u2, u3, u3} R ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (instHSMul.{u2, u3} R ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (SMulZeroClass.toSMul.{u2, u3} R ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (AddMonoid.toZero.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (AddCommMonoid.toAddMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) _inst_5)) (SMulWithZero.toSMulZeroClass.{u2, u3} R ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (AddCommMonoid.toAddMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) _inst_5)) (MulActionWithZero.toSMulWithZero.{u2, u3} R ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (AddCommMonoid.toAddMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) _inst_5)) (Module.toMulActionWithZero.{u2, u3} R ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) _inst_1 _inst_5 _inst_11))))) c (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (LinearMap.{u2, u2, u1, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M M₂ _inst_3 _inst_5 _inst_10 _inst_11) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, u1, u3} R R M M₂ _inst_1 _inst_1 _inst_3 _inst_5 _inst_10 _inst_11 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) fₗ x))
Case conversion may be inaccurate. Consider using '#align linear_map.map_smul LinearMap.map_smulₓ'. -/
protected theorem map_smul (c : R) (x : M) : fₗ (c • x) = c • fₗ x :=
  map_smul fₗ c x
#align linear_map.map_smul LinearMap.map_smul

/- warning: linear_map.map_smul_inv -> LinearMap.map_smul_inv is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_6 : AddCommMonoid.{u4} M₃] [_inst_10 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_12 : Module.{u2, u4} S M₃ _inst_2 _inst_6] {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} (f : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} [_inst_13 : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'] (c : S) (x : M), Eq.{succ u4} M₃ (SMul.smul.{u2, u4} S M₃ (SMulZeroClass.toHasSmul.{u2, u4} S M₃ (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6))) (SMulWithZero.toSmulZeroClass.{u2, u4} S M₃ (MulZeroClass.toHasZero.{u2} S (MulZeroOneClass.toMulZeroClass.{u2} S (MonoidWithZero.toMulZeroOneClass.{u2} S (Semiring.toMonoidWithZero.{u2} S _inst_2)))) (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6))) (MulActionWithZero.toSMulWithZero.{u2, u4} S M₃ (Semiring.toMonoidWithZero.{u2} S _inst_2) (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6))) (Module.toMulActionWithZero.{u2, u4} S M₃ _inst_2 _inst_6 _inst_12)))) c (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f x)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f (SMul.smul.{u1, u3} R M (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_3 _inst_10)))) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (fun (_x : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) => S -> R) (RingHom.hasCoeToFun.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) σ' c) x))
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u4}} {M : Type.{u1}} {M₃ : Type.{u2}} [_inst_1 : Semiring.{u3} R] [_inst_2 : Semiring.{u4} S] [_inst_3 : AddCommMonoid.{u1} M] [_inst_6 : AddCommMonoid.{u2} M₃] [_inst_10 : Module.{u3, u1} R M _inst_1 _inst_3] [_inst_12 : Module.{u4, u2} S M₃ _inst_2 _inst_6] {σ : RingHom.{u3, u4} R S (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u4} S _inst_2)} (f : LinearMap.{u3, u4, u1, u2} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) {σ' : RingHom.{u4, u3} S R (Semiring.toNonAssocSemiring.{u4} S _inst_2) (Semiring.toNonAssocSemiring.{u3} R _inst_1)} [_inst_13 : RingHomInvPair.{u3, u4} R S _inst_1 _inst_2 σ σ'] (c : S) (x : M), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) (HSMul.hSMul.{u4, u2, u2} S ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) (instHSMul.{u4, u2} S ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) (SMulZeroClass.toSMul.{u4, u2} S ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) (AddMonoid.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) (AddCommMonoid.toAddMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) _inst_6)) (SMulWithZero.toSMulZeroClass.{u4, u2} S ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) (MonoidWithZero.toZero.{u4} S (Semiring.toMonoidWithZero.{u4} S _inst_2)) (AddMonoid.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) (AddCommMonoid.toAddMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) _inst_6)) (MulActionWithZero.toSMulWithZero.{u4, u2} S ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) (Semiring.toMonoidWithZero.{u4} S _inst_2) (AddMonoid.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) (AddCommMonoid.toAddMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) _inst_6)) (Module.toMulActionWithZero.{u4, u2} S ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) _inst_2 _inst_6 _inst_12))))) c (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (LinearMap.{u3, u4, u1, u2} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u3, u4, u1, u2} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f x)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (LinearMap.{u3, u4, u1, u2} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u3, u4, u1, u2} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f (HSMul.hSMul.{u3, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : S) => R) c) M M (instHSMul.{u3, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : S) => R) c) M (SMulZeroClass.toSMul.{u3, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : S) => R) c) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u3, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : S) => R) c) M (MonoidWithZero.toZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : S) => R) c) (Semiring.toMonoidWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : S) => R) c) _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u3, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : S) => R) c) M (Semiring.toMonoidWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : S) => R) c) _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)) (Module.toMulActionWithZero.{u3, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : S) => R) c) M _inst_1 _inst_3 _inst_10))))) (FunLike.coe.{max (succ u3) (succ u4), succ u4, succ u3} (RingHom.{u4, u3} S R (Semiring.toNonAssocSemiring.{u4} S _inst_2) (Semiring.toNonAssocSemiring.{u3} R _inst_1)) S (fun (_x : S) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : S) => R) _x) (MulHomClass.toFunLike.{max u3 u4, u4, u3} (RingHom.{u4, u3} S R (Semiring.toNonAssocSemiring.{u4} S _inst_2) (Semiring.toNonAssocSemiring.{u3} R _inst_1)) S R (NonUnitalNonAssocSemiring.toMul.{u4} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (NonUnitalRingHomClass.toMulHomClass.{max u3 u4, u4, u3} (RingHom.{u4, u3} S R (Semiring.toNonAssocSemiring.{u4} S _inst_2) (Semiring.toNonAssocSemiring.{u3} R _inst_1)) S R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomClass.toNonUnitalRingHomClass.{max u3 u4, u4, u3} (RingHom.{u4, u3} S R (Semiring.toNonAssocSemiring.{u4} S _inst_2) (Semiring.toNonAssocSemiring.{u3} R _inst_1)) S R (Semiring.toNonAssocSemiring.{u4} S _inst_2) (Semiring.toNonAssocSemiring.{u3} R _inst_1) (RingHom.instRingHomClassRingHom.{u4, u3} S R (Semiring.toNonAssocSemiring.{u4} S _inst_2) (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) σ' c) x))
Case conversion may be inaccurate. Consider using '#align linear_map.map_smul_inv LinearMap.map_smul_invₓ'. -/
protected theorem map_smul_inv {σ' : S →+* R} [RingHomInvPair σ σ'] (c : S) (x : M) :
    c • f x = f (σ' c • x) := by simp
#align linear_map.map_smul_inv LinearMap.map_smul_inv

/- warning: linear_map.map_eq_zero_iff -> LinearMap.map_eq_zero_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_6 : AddCommMonoid.{u4} M₃] [_inst_10 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_12 : Module.{u2, u4} S M₃ _inst_2 _inst_6] {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} (f : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12), (Function.Injective.{succ u3, succ u4} M M₃ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f)) -> (forall {x : M}, Iff (Eq.{succ u4} M₃ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f x) (OfNat.ofNat.{u4} M₃ 0 (OfNat.mk.{u4} M₃ 0 (Zero.zero.{u4} M₃ (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6))))))) (Eq.{succ u3} M x (OfNat.ofNat.{u3} M 0 (OfNat.mk.{u3} M 0 (Zero.zero.{u3} M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))))))))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u4}} {M₃ : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_3 : AddCommMonoid.{u4} M] [_inst_6 : AddCommMonoid.{u3} M₃] [_inst_10 : Module.{u2, u4} R M _inst_1 _inst_3] [_inst_12 : Module.{u1, u3} S M₃ _inst_2 _inst_6] {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} (f : LinearMap.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12), (Function.Injective.{succ u4, succ u3} M M₃ (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearMap.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u2, u1, u4, u3} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f)) -> (forall {x : M}, Iff (Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearMap.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u2, u1, u4, u3} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f x) (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) 0 (Zero.toOfNat0.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) (AddMonoid.toZero.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) (AddCommMonoid.toAddMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) x) _inst_6))))) (Eq.{succ u4} M x (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))))))
Case conversion may be inaccurate. Consider using '#align linear_map.map_eq_zero_iff LinearMap.map_eq_zero_iffₓ'. -/
-- TODO: generalize to `zero_hom_class`
@[simp]
theorem map_eq_zero_iff (h : Function.Injective f) {x : M} : f x = 0 ↔ x = 0 :=
  ⟨fun w => by
    apply h
    simp [w], fun w => by
    subst w
    simp⟩
#align linear_map.map_eq_zero_iff LinearMap.map_eq_zero_iff

section Pointwise

open Pointwise

variable (M M₃ σ) {F : Type _} (h : F)

/- warning: image_smul_setₛₗ -> image_smul_setₛₗ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} (M : Type.{u3}) (M₃ : Type.{u4}) [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_6 : AddCommMonoid.{u4} M₃] [_inst_10 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_12 : Module.{u2, u4} S M₃ _inst_2 _inst_6] (σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) {F : Type.{u5}} (h : F) [_inst_13 : SemilinearMapClass.{u5, u1, u2, u3, u4} F R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12] (c : R) (s : Set.{u3} M), Eq.{succ u4} (Set.{u4} M₃) (Set.image.{u3, u4} M M₃ (coeFn.{succ u5, max (succ u3) (succ u4)} F (fun (_x : F) => M -> M₃) (FunLike.hasCoeToFun.{succ u5, succ u3, succ u4} F M (fun (_x : M) => M₃) (AddHomClass.toFunLike.{u5, u3, u4} F M M₃ (AddZeroClass.toHasAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (AddZeroClass.toHasAdd.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6))) (SemilinearMapClass.toAddHomClass.{u5, u1, u2, u3, u4} F R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12 _inst_13))) h) (SMul.smul.{u1, u3} R (Set.{u3} M) (Set.smulSet.{u1, u3} R M (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_3 _inst_10))))) c s)) (SMul.smul.{u2, u4} S (Set.{u4} M₃) (Set.smulSet.{u2, u4} S M₃ (SMulZeroClass.toHasSmul.{u2, u4} S M₃ (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6))) (SMulWithZero.toSmulZeroClass.{u2, u4} S M₃ (MulZeroClass.toHasZero.{u2} S (MulZeroOneClass.toMulZeroClass.{u2} S (MonoidWithZero.toMulZeroOneClass.{u2} S (Semiring.toMonoidWithZero.{u2} S _inst_2)))) (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6))) (MulActionWithZero.toSMulWithZero.{u2, u4} S M₃ (Semiring.toMonoidWithZero.{u2} S _inst_2) (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6))) (Module.toMulActionWithZero.{u2, u4} S M₃ _inst_2 _inst_6 _inst_12))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (fun (_x : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) σ c) (Set.image.{u3, u4} M M₃ (coeFn.{succ u5, max (succ u3) (succ u4)} F (fun (_x : F) => M -> M₃) (FunLike.hasCoeToFun.{succ u5, succ u3, succ u4} F M (fun (_x : M) => M₃) (AddHomClass.toFunLike.{u5, u3, u4} F M M₃ (AddZeroClass.toHasAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (AddZeroClass.toHasAdd.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6))) (SemilinearMapClass.toAddHomClass.{u5, u1, u2, u3, u4} F R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12 _inst_13))) h) s))
but is expected to have type
  forall {R : Type.{u4}} {S : Type.{u3}} (M : Type.{u2}) (M₃ : Type.{u1}) [_inst_1 : Semiring.{u4} R] [_inst_2 : Semiring.{u3} S] [_inst_3 : AddCommMonoid.{u2} M] [_inst_6 : AddCommMonoid.{u1} M₃] [_inst_10 : Module.{u4, u2} R M _inst_1 _inst_3] [_inst_12 : Module.{u3, u1} S M₃ _inst_2 _inst_6] (σ : RingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)) {F : Type.{u5}} (h : F) [_inst_13 : SemilinearMapClass.{u5, u4, u3, u2, u1} F R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12] (c : R) (s : Set.{u2} M), Eq.{succ u1} (Set.{u1} M₃) (Set.image.{u2, u1} M M₃ (FunLike.coe.{succ u5, succ u2, succ u1} F M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₃) _x) (AddHomClass.toFunLike.{u5, u2, u1} F M M₃ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddZeroClass.toAdd.{u1} M₃ (AddMonoid.toAddZeroClass.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6))) (SemilinearMapClass.toAddHomClass.{u5, u4, u3, u2, u1} F R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12 _inst_13)) h) (HSMul.hSMul.{u4, u2, u2} R (Set.{u2} M) (Set.{u2} M) (instHSMul.{u4, u2} R (Set.{u2} M) (Set.smulSet.{u4, u2} R M (SMulZeroClass.toSMul.{u4, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u4, u2} R M (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u4, u2} R M (Semiring.toMonoidWithZero.{u4} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (Module.toMulActionWithZero.{u4, u2} R M _inst_1 _inst_3 _inst_10)))))) c s)) (HSMul.hSMul.{u3, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) (Set.{u1} M₃) (Set.{u1} M₃) (instHSMul.{u3, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) (Set.{u1} M₃) (Set.smulSet.{u3, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) M₃ (SMulZeroClass.toSMul.{u3, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) M₃ (AddMonoid.toZero.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6)) (SMulWithZero.toSMulZeroClass.{u3, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) M₃ (MonoidWithZero.toZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) (Semiring.toMonoidWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) _inst_2)) (AddMonoid.toZero.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6)) (MulActionWithZero.toSMulWithZero.{u3, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) M₃ (Semiring.toMonoidWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) _inst_2) (AddMonoid.toZero.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6)) (Module.toMulActionWithZero.{u3, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) M₃ _inst_2 _inst_6 _inst_12)))))) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (RingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) _x) (MulHomClass.toFunLike.{max u4 u3, u4, u3} (RingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)) R S (NonUnitalNonAssocSemiring.toMul.{u4} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u4 u3, u4, u3} (RingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u4 u3, u4, u3} (RingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)) R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2) (RingHom.instRingHomClassRingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2))))) σ c) (Set.image.{u2, u1} M M₃ (FunLike.coe.{succ u5, succ u2, succ u1} F M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₃) _x) (AddHomClass.toFunLike.{u5, u2, u1} F M M₃ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddZeroClass.toAdd.{u1} M₃ (AddMonoid.toAddZeroClass.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6))) (SemilinearMapClass.toAddHomClass.{u5, u4, u3, u2, u1} F R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12 _inst_13)) h) s))
Case conversion may be inaccurate. Consider using '#align image_smul_setₛₗ image_smul_setₛₗₓ'. -/
@[simp]
theorem image_smul_setₛₗ [SemilinearMapClass F σ M M₃] (c : R) (s : Set M) :
    h '' (c • s) = σ c • h '' s := by
  apply Set.Subset.antisymm
  · rintro x ⟨y, ⟨z, zs, rfl⟩, rfl⟩
    exact ⟨h z, Set.mem_image_of_mem _ zs, (map_smulₛₗ _ _ _).symm⟩
  · rintro x ⟨y, ⟨z, hz, rfl⟩, rfl⟩
    exact (Set.mem_image _ _ _).2 ⟨c • z, Set.smul_mem_smul_set hz, map_smulₛₗ _ _ _⟩
#align image_smul_setₛₗ image_smul_setₛₗ

/- warning: preimage_smul_setₛₗ -> preimage_smul_setₛₗ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} (M : Type.{u3}) (M₃ : Type.{u4}) [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_6 : AddCommMonoid.{u4} M₃] [_inst_10 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_12 : Module.{u2, u4} S M₃ _inst_2 _inst_6] (σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) {F : Type.{u5}} (h : F) [_inst_13 : SemilinearMapClass.{u5, u1, u2, u3, u4} F R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12] {c : R}, (IsUnit.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) c) -> (forall (s : Set.{u4} M₃), Eq.{succ u3} (Set.{u3} M) (Set.preimage.{u3, u4} M M₃ (coeFn.{succ u5, max (succ u3) (succ u4)} F (fun (_x : F) => M -> M₃) (FunLike.hasCoeToFun.{succ u5, succ u3, succ u4} F M (fun (_x : M) => M₃) (AddHomClass.toFunLike.{u5, u3, u4} F M M₃ (AddZeroClass.toHasAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (AddZeroClass.toHasAdd.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6))) (SemilinearMapClass.toAddHomClass.{u5, u1, u2, u3, u4} F R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12 _inst_13))) h) (SMul.smul.{u2, u4} S (Set.{u4} M₃) (Set.smulSet.{u2, u4} S M₃ (SMulZeroClass.toHasSmul.{u2, u4} S M₃ (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6))) (SMulWithZero.toSmulZeroClass.{u2, u4} S M₃ (MulZeroClass.toHasZero.{u2} S (MulZeroOneClass.toMulZeroClass.{u2} S (MonoidWithZero.toMulZeroOneClass.{u2} S (Semiring.toMonoidWithZero.{u2} S _inst_2)))) (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6))) (MulActionWithZero.toSMulWithZero.{u2, u4} S M₃ (Semiring.toMonoidWithZero.{u2} S _inst_2) (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6))) (Module.toMulActionWithZero.{u2, u4} S M₃ _inst_2 _inst_6 _inst_12))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (fun (_x : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) σ c) s)) (SMul.smul.{u1, u3} R (Set.{u3} M) (Set.smulSet.{u1, u3} R M (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_3 _inst_10))))) c (Set.preimage.{u3, u4} M M₃ (coeFn.{succ u5, max (succ u3) (succ u4)} F (fun (_x : F) => M -> M₃) (FunLike.hasCoeToFun.{succ u5, succ u3, succ u4} F M (fun (_x : M) => M₃) (AddHomClass.toFunLike.{u5, u3, u4} F M M₃ (AddZeroClass.toHasAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (AddZeroClass.toHasAdd.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6))) (SemilinearMapClass.toAddHomClass.{u5, u1, u2, u3, u4} F R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12 _inst_13))) h) s)))
but is expected to have type
  forall {R : Type.{u4}} {S : Type.{u3}} (M : Type.{u2}) (M₃ : Type.{u1}) [_inst_1 : Semiring.{u4} R] [_inst_2 : Semiring.{u3} S] [_inst_3 : AddCommMonoid.{u2} M] [_inst_6 : AddCommMonoid.{u1} M₃] [_inst_10 : Module.{u4, u2} R M _inst_1 _inst_3] [_inst_12 : Module.{u3, u1} S M₃ _inst_2 _inst_6] (σ : RingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)) {F : Type.{u5}} (h : F) [_inst_13 : SemilinearMapClass.{u5, u4, u3, u2, u1} F R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12] {c : R}, (IsUnit.{u4} R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) c) -> (forall (s : Set.{u1} M₃), Eq.{succ u2} (Set.{u2} M) (Set.preimage.{u2, u1} M M₃ (FunLike.coe.{succ u5, succ u2, succ u1} F M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₃) _x) (AddHomClass.toFunLike.{u5, u2, u1} F M M₃ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddZeroClass.toAdd.{u1} M₃ (AddMonoid.toAddZeroClass.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6))) (SemilinearMapClass.toAddHomClass.{u5, u4, u3, u2, u1} F R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12 _inst_13)) h) (HSMul.hSMul.{u3, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) (Set.{u1} M₃) (Set.{u1} M₃) (instHSMul.{u3, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) (Set.{u1} M₃) (Set.smulSet.{u3, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) M₃ (SMulZeroClass.toSMul.{u3, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) M₃ (AddMonoid.toZero.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6)) (SMulWithZero.toSMulZeroClass.{u3, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) M₃ (MonoidWithZero.toZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) (Semiring.toMonoidWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) _inst_2)) (AddMonoid.toZero.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6)) (MulActionWithZero.toSMulWithZero.{u3, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) M₃ (Semiring.toMonoidWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) _inst_2) (AddMonoid.toZero.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6)) (Module.toMulActionWithZero.{u3, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) M₃ _inst_2 _inst_6 _inst_12)))))) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (RingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) _x) (MulHomClass.toFunLike.{max u4 u3, u4, u3} (RingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)) R S (NonUnitalNonAssocSemiring.toMul.{u4} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u4 u3, u4, u3} (RingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u4 u3, u4, u3} (RingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)) R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2) (RingHom.instRingHomClassRingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2))))) σ c) s)) (HSMul.hSMul.{u4, u2, u2} R (Set.{u2} M) (Set.{u2} M) (instHSMul.{u4, u2} R (Set.{u2} M) (Set.smulSet.{u4, u2} R M (SMulZeroClass.toSMul.{u4, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u4, u2} R M (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u4, u2} R M (Semiring.toMonoidWithZero.{u4} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (Module.toMulActionWithZero.{u4, u2} R M _inst_1 _inst_3 _inst_10)))))) c (Set.preimage.{u2, u1} M M₃ (FunLike.coe.{succ u5, succ u2, succ u1} F M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₃) _x) (AddHomClass.toFunLike.{u5, u2, u1} F M M₃ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddZeroClass.toAdd.{u1} M₃ (AddMonoid.toAddZeroClass.{u1} M₃ (AddCommMonoid.toAddMonoid.{u1} M₃ _inst_6))) (SemilinearMapClass.toAddHomClass.{u5, u4, u3, u2, u1} F R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12 _inst_13)) h) s)))
Case conversion may be inaccurate. Consider using '#align preimage_smul_setₛₗ preimage_smul_setₛₗₓ'. -/
theorem preimage_smul_setₛₗ [SemilinearMapClass F σ M M₃] {c : R} (hc : IsUnit c) (s : Set M₃) :
    h ⁻¹' (σ c • s) = c • h ⁻¹' s := by
  apply Set.Subset.antisymm
  · rintro x ⟨y, ys, hy⟩
    refine' ⟨(hc.unit.inv : R) • x, _, _⟩
    ·
      simp only [← hy, smul_smul, Set.mem_preimage, Units.inv_eq_val_inv, map_smulₛₗ h, ← map_mul,
        IsUnit.val_inv_mul, one_smul, map_one, ys]
    · simp only [smul_smul, IsUnit.mul_val_inv, one_smul, Units.inv_eq_val_inv]
  · rintro x ⟨y, hy, rfl⟩
    refine' ⟨h y, hy, by simp only [RingHom.id_apply, map_smulₛₗ h]⟩
#align preimage_smul_setₛₗ preimage_smul_setₛₗ

variable (R M₂)

/- warning: image_smul_set -> image_smul_set is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_5 : AddCommMonoid.{u3} M₂] [_inst_10 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_11 : Module.{u1, u3} R M₂ _inst_1 _inst_5] {F : Type.{u4}} (h : F) [_inst_13 : LinearMapClass.{u4, u1, u2, u3} F R M M₂ _inst_1 _inst_3 _inst_5 _inst_10 _inst_11] (c : R) (s : Set.{u2} M), Eq.{succ u3} (Set.{u3} M₂) (Set.image.{u2, u3} M M₂ (coeFn.{succ u4, max (succ u2) (succ u3)} F (fun (_x : F) => M -> M₂) (FunLike.hasCoeToFun.{succ u4, succ u2, succ u3} F M (fun (_x : M) => M₂) (SMulHomClass.toFunLike.{u4, u1, u2, u3} F R M M₂ (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (DistribSMul.toSmulZeroClass.{u1, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (DistribMulAction.toDistribSMul.{u1, u2} R M (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_3) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_3 _inst_10)))) (SMulZeroClass.toHasSmul.{u1, u3} R M₂ (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5))) (DistribSMul.toSmulZeroClass.{u1, u3} R M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5)) (DistribMulAction.toDistribSMul.{u1, u3} R M₂ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_5 _inst_11)))) (DistribMulActionHomClass.toSmulHomClass.{u4, u1, u2, u3} F R M M₂ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_3) (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_3 _inst_10) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_5 _inst_11) (SemilinearMapClass.distribMulActionHomClass.{u1, u2, u3, u4} R M M₂ F _inst_1 _inst_3 _inst_5 _inst_10 _inst_11 _inst_13)))) h) (SMul.smul.{u1, u2} R (Set.{u2} M) (Set.smulSet.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_3 _inst_10))))) c s)) (SMul.smul.{u1, u3} R (Set.{u3} M₂) (Set.smulSet.{u1, u3} R M₂ (SMulZeroClass.toHasSmul.{u1, u3} R M₂ (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M₂ (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M₂ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5))) (Module.toMulActionWithZero.{u1, u3} R M₂ _inst_1 _inst_5 _inst_11))))) c (Set.image.{u2, u3} M M₂ (coeFn.{succ u4, max (succ u2) (succ u3)} F (fun (_x : F) => M -> M₂) (FunLike.hasCoeToFun.{succ u4, succ u2, succ u3} F M (fun (_x : M) => M₂) (SMulHomClass.toFunLike.{u4, u1, u2, u3} F R M M₂ (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (DistribSMul.toSmulZeroClass.{u1, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (DistribMulAction.toDistribSMul.{u1, u2} R M (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_3) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_3 _inst_10)))) (SMulZeroClass.toHasSmul.{u1, u3} R M₂ (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5))) (DistribSMul.toSmulZeroClass.{u1, u3} R M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5)) (DistribMulAction.toDistribSMul.{u1, u3} R M₂ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_5 _inst_11)))) (DistribMulActionHomClass.toSmulHomClass.{u4, u1, u2, u3} F R M M₂ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_3) (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_3 _inst_10) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_5 _inst_11) (SemilinearMapClass.distribMulActionHomClass.{u1, u2, u3, u4} R M M₂ F _inst_1 _inst_3 _inst_5 _inst_10 _inst_11 _inst_13)))) h) s))
but is expected to have type
  forall (R : Type.{u3}) (M : Type.{u2}) (M₂ : Type.{u1}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_5 : AddCommMonoid.{u1} M₂] [_inst_10 : Module.{u3, u2} R M _inst_1 _inst_3] [_inst_11 : Module.{u3, u1} R M₂ _inst_1 _inst_5] {F : Type.{u4}} (h : F) [_inst_13 : LinearMapClass.{u4, u3, u2, u1} F R M M₂ _inst_1 _inst_3 _inst_5 _inst_10 _inst_11] (c : R) (s : Set.{u2} M), Eq.{succ u1} (Set.{u1} M₂) (Set.image.{u2, u1} M M₂ (FunLike.coe.{succ u4, succ u2, succ u1} F M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M) => M₂) _x) (SMulHomClass.toFunLike.{u4, u3, u2, u1} F R M M₂ (SMulZeroClass.toSMul.{u3, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (DistribSMul.toSMulZeroClass.{u3, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (DistribMulAction.toDistribSMul.{u3, u2} R M (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_3) (Module.toDistribMulAction.{u3, u2} R M _inst_1 _inst_3 _inst_10)))) (SMulZeroClass.toSMul.{u3, u1} R M₂ (AddMonoid.toZero.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_5)) (DistribSMul.toSMulZeroClass.{u3, u1} R M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_5)) (DistribMulAction.toDistribSMul.{u3, u1} R M₂ (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_5) (Module.toDistribMulAction.{u3, u1} R M₂ _inst_1 _inst_5 _inst_11)))) (DistribMulActionHomClass.toSMulHomClass.{u4, u3, u2, u1} F R M M₂ (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_3) (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_5) (Module.toDistribMulAction.{u3, u2} R M _inst_1 _inst_3 _inst_10) (Module.toDistribMulAction.{u3, u1} R M₂ _inst_1 _inst_5 _inst_11) (SemilinearMapClass.distribMulActionHomClass.{u3, u2, u1, u4} R M M₂ F _inst_1 _inst_3 _inst_5 _inst_10 _inst_11 _inst_13))) h) (HSMul.hSMul.{u3, u2, u2} R (Set.{u2} M) (Set.{u2} M) (instHSMul.{u3, u2} R (Set.{u2} M) (Set.smulSet.{u3, u2} R M (SMulZeroClass.toSMul.{u3, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u3, u2} R M (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (Module.toMulActionWithZero.{u3, u2} R M _inst_1 _inst_3 _inst_10)))))) c s)) (HSMul.hSMul.{u3, u1, u1} R (Set.{u1} M₂) (Set.{u1} M₂) (instHSMul.{u3, u1} R (Set.{u1} M₂) (Set.smulSet.{u3, u1} R M₂ (SMulZeroClass.toSMul.{u3, u1} R M₂ (AddMonoid.toZero.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_5)) (SMulWithZero.toSMulZeroClass.{u3, u1} R M₂ (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddMonoid.toZero.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_5)) (MulActionWithZero.toSMulWithZero.{u3, u1} R M₂ (Semiring.toMonoidWithZero.{u3} R _inst_1) (AddMonoid.toZero.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_5)) (Module.toMulActionWithZero.{u3, u1} R M₂ _inst_1 _inst_5 _inst_11)))))) c (Set.image.{u2, u1} M M₂ (FunLike.coe.{succ u4, succ u2, succ u1} F M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M) => M₂) _x) (SMulHomClass.toFunLike.{u4, u3, u2, u1} F R M M₂ (SMulZeroClass.toSMul.{u3, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (DistribSMul.toSMulZeroClass.{u3, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (DistribMulAction.toDistribSMul.{u3, u2} R M (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_3) (Module.toDistribMulAction.{u3, u2} R M _inst_1 _inst_3 _inst_10)))) (SMulZeroClass.toSMul.{u3, u1} R M₂ (AddMonoid.toZero.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_5)) (DistribSMul.toSMulZeroClass.{u3, u1} R M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_5)) (DistribMulAction.toDistribSMul.{u3, u1} R M₂ (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_5) (Module.toDistribMulAction.{u3, u1} R M₂ _inst_1 _inst_5 _inst_11)))) (DistribMulActionHomClass.toSMulHomClass.{u4, u3, u2, u1} F R M M₂ (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_3) (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_5) (Module.toDistribMulAction.{u3, u2} R M _inst_1 _inst_3 _inst_10) (Module.toDistribMulAction.{u3, u1} R M₂ _inst_1 _inst_5 _inst_11) (SemilinearMapClass.distribMulActionHomClass.{u3, u2, u1, u4} R M M₂ F _inst_1 _inst_3 _inst_5 _inst_10 _inst_11 _inst_13))) h) s))
Case conversion may be inaccurate. Consider using '#align image_smul_set image_smul_setₓ'. -/
theorem image_smul_set [LinearMapClass F R M M₂] (c : R) (s : Set M) : h '' (c • s) = c • h '' s :=
  image_smul_setₛₗ _ _ _ h c s
#align image_smul_set image_smul_set

/- warning: preimage_smul_set -> preimage_smul_set is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_5 : AddCommMonoid.{u3} M₂] [_inst_10 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_11 : Module.{u1, u3} R M₂ _inst_1 _inst_5] {F : Type.{u4}} (h : F) [_inst_13 : LinearMapClass.{u4, u1, u2, u3} F R M M₂ _inst_1 _inst_3 _inst_5 _inst_10 _inst_11] {c : R}, (IsUnit.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) c) -> (forall (s : Set.{u3} M₂), Eq.{succ u2} (Set.{u2} M) (Set.preimage.{u2, u3} M M₂ (coeFn.{succ u4, max (succ u2) (succ u3)} F (fun (_x : F) => M -> M₂) (FunLike.hasCoeToFun.{succ u4, succ u2, succ u3} F M (fun (_x : M) => M₂) (SMulHomClass.toFunLike.{u4, u1, u2, u3} F R M M₂ (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (DistribSMul.toSmulZeroClass.{u1, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (DistribMulAction.toDistribSMul.{u1, u2} R M (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_3) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_3 _inst_10)))) (SMulZeroClass.toHasSmul.{u1, u3} R M₂ (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5))) (DistribSMul.toSmulZeroClass.{u1, u3} R M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5)) (DistribMulAction.toDistribSMul.{u1, u3} R M₂ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_5 _inst_11)))) (DistribMulActionHomClass.toSmulHomClass.{u4, u1, u2, u3} F R M M₂ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_3) (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_3 _inst_10) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_5 _inst_11) (SemilinearMapClass.distribMulActionHomClass.{u1, u2, u3, u4} R M M₂ F _inst_1 _inst_3 _inst_5 _inst_10 _inst_11 _inst_13)))) h) (SMul.smul.{u1, u3} R (Set.{u3} M₂) (Set.smulSet.{u1, u3} R M₂ (SMulZeroClass.toHasSmul.{u1, u3} R M₂ (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M₂ (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M₂ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5))) (Module.toMulActionWithZero.{u1, u3} R M₂ _inst_1 _inst_5 _inst_11))))) c s)) (SMul.smul.{u1, u2} R (Set.{u2} M) (Set.smulSet.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_3 _inst_10))))) c (Set.preimage.{u2, u3} M M₂ (coeFn.{succ u4, max (succ u2) (succ u3)} F (fun (_x : F) => M -> M₂) (FunLike.hasCoeToFun.{succ u4, succ u2, succ u3} F M (fun (_x : M) => M₂) (SMulHomClass.toFunLike.{u4, u1, u2, u3} F R M M₂ (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (DistribSMul.toSmulZeroClass.{u1, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (DistribMulAction.toDistribSMul.{u1, u2} R M (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_3) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_3 _inst_10)))) (SMulZeroClass.toHasSmul.{u1, u3} R M₂ (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5))) (DistribSMul.toSmulZeroClass.{u1, u3} R M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5)) (DistribMulAction.toDistribSMul.{u1, u3} R M₂ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_5 _inst_11)))) (DistribMulActionHomClass.toSmulHomClass.{u4, u1, u2, u3} F R M M₂ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_3) (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_3 _inst_10) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_5 _inst_11) (SemilinearMapClass.distribMulActionHomClass.{u1, u2, u3, u4} R M M₂ F _inst_1 _inst_3 _inst_5 _inst_10 _inst_11 _inst_13)))) h) s)))
but is expected to have type
  forall (R : Type.{u3}) (M : Type.{u2}) (M₂ : Type.{u1}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_5 : AddCommMonoid.{u1} M₂] [_inst_10 : Module.{u3, u2} R M _inst_1 _inst_3] [_inst_11 : Module.{u3, u1} R M₂ _inst_1 _inst_5] {F : Type.{u4}} (h : F) [_inst_13 : LinearMapClass.{u4, u3, u2, u1} F R M M₂ _inst_1 _inst_3 _inst_5 _inst_10 _inst_11] {c : R}, (IsUnit.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) c) -> (forall (s : Set.{u1} M₂), Eq.{succ u2} (Set.{u2} M) (Set.preimage.{u2, u1} M M₂ (FunLike.coe.{succ u4, succ u2, succ u1} F M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M) => M₂) _x) (SMulHomClass.toFunLike.{u4, u3, u2, u1} F R M M₂ (SMulZeroClass.toSMul.{u3, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (DistribSMul.toSMulZeroClass.{u3, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (DistribMulAction.toDistribSMul.{u3, u2} R M (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_3) (Module.toDistribMulAction.{u3, u2} R M _inst_1 _inst_3 _inst_10)))) (SMulZeroClass.toSMul.{u3, u1} R M₂ (AddMonoid.toZero.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_5)) (DistribSMul.toSMulZeroClass.{u3, u1} R M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_5)) (DistribMulAction.toDistribSMul.{u3, u1} R M₂ (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_5) (Module.toDistribMulAction.{u3, u1} R M₂ _inst_1 _inst_5 _inst_11)))) (DistribMulActionHomClass.toSMulHomClass.{u4, u3, u2, u1} F R M M₂ (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_3) (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_5) (Module.toDistribMulAction.{u3, u2} R M _inst_1 _inst_3 _inst_10) (Module.toDistribMulAction.{u3, u1} R M₂ _inst_1 _inst_5 _inst_11) (SemilinearMapClass.distribMulActionHomClass.{u3, u2, u1, u4} R M M₂ F _inst_1 _inst_3 _inst_5 _inst_10 _inst_11 _inst_13))) h) (HSMul.hSMul.{u3, u1, u1} R (Set.{u1} M₂) (Set.{u1} M₂) (instHSMul.{u3, u1} R (Set.{u1} M₂) (Set.smulSet.{u3, u1} R M₂ (SMulZeroClass.toSMul.{u3, u1} R M₂ (AddMonoid.toZero.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_5)) (SMulWithZero.toSMulZeroClass.{u3, u1} R M₂ (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddMonoid.toZero.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_5)) (MulActionWithZero.toSMulWithZero.{u3, u1} R M₂ (Semiring.toMonoidWithZero.{u3} R _inst_1) (AddMonoid.toZero.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_5)) (Module.toMulActionWithZero.{u3, u1} R M₂ _inst_1 _inst_5 _inst_11)))))) c s)) (HSMul.hSMul.{u3, u2, u2} R (Set.{u2} M) (Set.{u2} M) (instHSMul.{u3, u2} R (Set.{u2} M) (Set.smulSet.{u3, u2} R M (SMulZeroClass.toSMul.{u3, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u3, u2} R M (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (Module.toMulActionWithZero.{u3, u2} R M _inst_1 _inst_3 _inst_10)))))) c (Set.preimage.{u2, u1} M M₂ (FunLike.coe.{succ u4, succ u2, succ u1} F M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M) => M₂) _x) (SMulHomClass.toFunLike.{u4, u3, u2, u1} F R M M₂ (SMulZeroClass.toSMul.{u3, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (DistribSMul.toSMulZeroClass.{u3, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (DistribMulAction.toDistribSMul.{u3, u2} R M (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_3) (Module.toDistribMulAction.{u3, u2} R M _inst_1 _inst_3 _inst_10)))) (SMulZeroClass.toSMul.{u3, u1} R M₂ (AddMonoid.toZero.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_5)) (DistribSMul.toSMulZeroClass.{u3, u1} R M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_5)) (DistribMulAction.toDistribSMul.{u3, u1} R M₂ (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_5) (Module.toDistribMulAction.{u3, u1} R M₂ _inst_1 _inst_5 _inst_11)))) (DistribMulActionHomClass.toSMulHomClass.{u4, u3, u2, u1} F R M M₂ (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_3) (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_5) (Module.toDistribMulAction.{u3, u2} R M _inst_1 _inst_3 _inst_10) (Module.toDistribMulAction.{u3, u1} R M₂ _inst_1 _inst_5 _inst_11) (SemilinearMapClass.distribMulActionHomClass.{u3, u2, u1, u4} R M M₂ F _inst_1 _inst_3 _inst_5 _inst_10 _inst_11 _inst_13))) h) s)))
Case conversion may be inaccurate. Consider using '#align preimage_smul_set preimage_smul_setₓ'. -/
theorem preimage_smul_set [LinearMapClass F R M M₂] {c : R} (hc : IsUnit c) (s : Set M₂) :
    h ⁻¹' (c • s) = c • h ⁻¹' s :=
  preimage_smul_setₛₗ _ _ _ h hc s
#align preimage_smul_set preimage_smul_set

end Pointwise

variable (M M₂)

#print LinearMap.CompatibleSMul /-
/-- A typeclass for `has_smul` structures which can be moved through a `linear_map`.
This typeclass is generated automatically from a `is_scalar_tower` instance, but exists so that
we can also add an instance for `add_comm_group.int_module`, allowing `z •` to be moved even if
`R` does not support negation.
-/
class CompatibleSMul (R S : Type _) [Semiring S] [SMul R M] [Module S M] [SMul R M₂]
  [Module S M₂] where
  map_smul : ∀ (fₗ : M →ₗ[S] M₂) (c : R) (x : M), fₗ (c • x) = c • fₗ x
#align linear_map.compatible_smul LinearMap.CompatibleSMul
-/

variable {M M₂}

#print LinearMap.IsScalarTower.compatibleSMul /-
instance (priority := 100) IsScalarTower.compatibleSMul {R S : Type _} [Semiring S] [SMul R S]
    [SMul R M] [Module S M] [IsScalarTower R S M] [SMul R M₂] [Module S M₂] [IsScalarTower R S M₂] :
    CompatibleSMul M M₂ R S :=
  ⟨fun fₗ c x => by rw [← smul_one_smul S c x, ← smul_one_smul S c (fₗ x), map_smul]⟩
#align linear_map.is_scalar_tower.compatible_smul LinearMap.IsScalarTower.compatibleSMul
-/

/- warning: linear_map.map_smul_of_tower -> LinearMap.map_smul_of_tower is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {M₂ : Type.{u2}} [_inst_3 : AddCommMonoid.{u1} M] [_inst_5 : AddCommMonoid.{u2} M₂] {R : Type.{u3}} {S : Type.{u4}} [_inst_13 : Semiring.{u4} S] [_inst_14 : SMul.{u3, u1} R M] [_inst_15 : Module.{u4, u1} S M _inst_13 _inst_3] [_inst_16 : SMul.{u3, u2} R M₂] [_inst_17 : Module.{u4, u2} S M₂ _inst_13 _inst_5] [_inst_18 : LinearMap.CompatibleSMul.{u1, u2, u3, u4} M M₂ _inst_3 _inst_5 R S _inst_13 _inst_14 _inst_15 _inst_16 _inst_17] (fₗ : LinearMap.{u4, u4, u1, u2} S S _inst_13 _inst_13 (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_13)) M M₂ _inst_3 _inst_5 _inst_15 _inst_17) (c : R) (x : M), Eq.{succ u2} M₂ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{u4, u4, u1, u2} S S _inst_13 _inst_13 (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_13)) M M₂ _inst_3 _inst_5 _inst_15 _inst_17) (fun (_x : LinearMap.{u4, u4, u1, u2} S S _inst_13 _inst_13 (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_13)) M M₂ _inst_3 _inst_5 _inst_15 _inst_17) => M -> M₂) (LinearMap.hasCoeToFun.{u4, u4, u1, u2} S S M M₂ _inst_13 _inst_13 _inst_3 _inst_5 _inst_15 _inst_17 (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_13))) fₗ (SMul.smul.{u3, u1} R M _inst_14 c x)) (SMul.smul.{u3, u2} R M₂ _inst_16 c (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{u4, u4, u1, u2} S S _inst_13 _inst_13 (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_13)) M M₂ _inst_3 _inst_5 _inst_15 _inst_17) (fun (_x : LinearMap.{u4, u4, u1, u2} S S _inst_13 _inst_13 (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_13)) M M₂ _inst_3 _inst_5 _inst_15 _inst_17) => M -> M₂) (LinearMap.hasCoeToFun.{u4, u4, u1, u2} S S M M₂ _inst_13 _inst_13 _inst_3 _inst_5 _inst_15 _inst_17 (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_13))) fₗ x))
but is expected to have type
  forall {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_3 : AddCommMonoid.{u2} M] [_inst_5 : AddCommMonoid.{u1} M₂] {R : Type.{u4}} {S : Type.{u3}} [_inst_13 : Semiring.{u3} S] [_inst_14 : SMul.{u4, u2} R M] [_inst_15 : Module.{u3, u2} S M _inst_13 _inst_3] [_inst_16 : SMul.{u4, u1} R M₂] [_inst_17 : Module.{u3, u1} S M₂ _inst_13 _inst_5] [_inst_18 : LinearMap.CompatibleSMul.{u2, u1, u4, u3} M M₂ _inst_3 _inst_5 R S _inst_13 _inst_14 _inst_15 _inst_16 _inst_17] (fₗ : LinearMap.{u3, u3, u2, u1} S S _inst_13 _inst_13 (RingHom.id.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_13)) M M₂ _inst_3 _inst_5 _inst_15 _inst_17) (c : R) (x : M), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) (HSMul.hSMul.{u4, u2, u2} R M M (instHSMul.{u4, u2} R M _inst_14) c x)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u3, u3, u2, u1} S S _inst_13 _inst_13 (RingHom.id.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_13)) M M₂ _inst_3 _inst_5 _inst_15 _inst_17) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u2, u1} S S M M₂ _inst_13 _inst_13 _inst_3 _inst_5 _inst_15 _inst_17 (RingHom.id.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_13))) fₗ (HSMul.hSMul.{u4, u2, u2} R M M (instHSMul.{u4, u2} R M _inst_14) c x)) (HSMul.hSMul.{u4, u1, u1} R ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (instHSMul.{u4, u1} R ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) _inst_16) c (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u3, u3, u2, u1} S S _inst_13 _inst_13 (RingHom.id.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_13)) M M₂ _inst_3 _inst_5 _inst_15 _inst_17) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u2, u1} S S M M₂ _inst_13 _inst_13 _inst_3 _inst_5 _inst_15 _inst_17 (RingHom.id.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_13))) fₗ x))
Case conversion may be inaccurate. Consider using '#align linear_map.map_smul_of_tower LinearMap.map_smul_of_towerₓ'. -/
@[simp]
theorem map_smul_of_tower {R S : Type _} [Semiring S] [SMul R M] [Module S M] [SMul R M₂]
    [Module S M₂] [CompatibleSMul M M₂ R S] (fₗ : M →ₗ[S] M₂) (c : R) (x : M) :
    fₗ (c • x) = c • fₗ x :=
  CompatibleSMul.map_smul fₗ c x
#align linear_map.map_smul_of_tower LinearMap.map_smul_of_tower

#print LinearMap.toAddMonoidHom /-
/-- convert a linear map to an additive map -/
def toAddMonoidHom : M →+ M₃ where
  toFun := f
  map_zero' := f.map_zero
  map_add' := f.map_add
#align linear_map.to_add_monoid_hom LinearMap.toAddMonoidHom
-/

/- warning: linear_map.to_add_monoid_hom_coe -> LinearMap.toAddMonoidHom_coe is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_6 : AddCommMonoid.{u4} M₃] [_inst_10 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_12 : Module.{u2, u4} S M₃ _inst_2 _inst_6] {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} (f : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12), Eq.{max (succ u3) (succ u4)} (M -> M₃) (coeFn.{max (succ u4) (succ u3), max (succ u3) (succ u4)} (AddMonoidHom.{u3, u4} M M₃ (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6))) (fun (_x : AddMonoidHom.{u3, u4} M M₃ (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6))) => M -> M₃) (AddMonoidHom.hasCoeToFun.{u3, u4} M M₃ (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6))) (LinearMap.toAddMonoidHom.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ f)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u4}} {M₃ : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_3 : AddCommMonoid.{u4} M] [_inst_6 : AddCommMonoid.{u3} M₃] [_inst_10 : Module.{u2, u4} R M _inst_1 _inst_3] [_inst_12 : Module.{u1, u3} S M₃ _inst_2 _inst_6] {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} (f : LinearMap.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12), Eq.{max (succ u4) (succ u3)} (forall (ᾰ : M), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₃) ᾰ) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (AddMonoidHom.{u4, u3} M M₃ (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (AddMonoid.toAddZeroClass.{u3} M₃ (AddCommMonoid.toAddMonoid.{u3} M₃ _inst_6))) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₃) _x) (AddHomClass.toFunLike.{max u4 u3, u4, u3} (AddMonoidHom.{u4, u3} M M₃ (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (AddMonoid.toAddZeroClass.{u3} M₃ (AddCommMonoid.toAddMonoid.{u3} M₃ _inst_6))) M M₃ (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) (AddZeroClass.toAdd.{u3} M₃ (AddMonoid.toAddZeroClass.{u3} M₃ (AddCommMonoid.toAddMonoid.{u3} M₃ _inst_6))) (AddMonoidHomClass.toAddHomClass.{max u4 u3, u4, u3} (AddMonoidHom.{u4, u3} M M₃ (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (AddMonoid.toAddZeroClass.{u3} M₃ (AddCommMonoid.toAddMonoid.{u3} M₃ _inst_6))) M M₃ (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (AddMonoid.toAddZeroClass.{u3} M₃ (AddCommMonoid.toAddMonoid.{u3} M₃ _inst_6)) (AddMonoidHom.addMonoidHomClass.{u4, u3} M M₃ (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (AddMonoid.toAddZeroClass.{u3} M₃ (AddCommMonoid.toAddMonoid.{u3} M₃ _inst_6))))) (LinearMap.toAddMonoidHom.{u2, u1, u4, u3} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ f)) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearMap.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u2, u1, u4, u3} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ) f)
Case conversion may be inaccurate. Consider using '#align linear_map.to_add_monoid_hom_coe LinearMap.toAddMonoidHom_coeₓ'. -/
@[simp]
theorem toAddMonoidHom_coe : ⇑f.toAddMonoidHom = f :=
  rfl
#align linear_map.to_add_monoid_hom_coe LinearMap.toAddMonoidHom_coe

section RestrictScalars

variable (R) [Module S M] [Module S M₂] [CompatibleSMul M M₂ R S]

#print LinearMap.restrictScalars /-
/-- If `M` and `M₂` are both `R`-modules and `S`-modules and `R`-module structures
are defined by an action of `R` on `S` (formally, we have two scalar towers), then any `S`-linear
map from `M` to `M₂` is `R`-linear.

See also `linear_map.map_smul_of_tower`. -/
def restrictScalars (fₗ : M →ₗ[S] M₂) : M →ₗ[R] M₂
    where
  toFun := fₗ
  map_add' := fₗ.map_add
  map_smul' := fₗ.map_smul_of_tower
#align linear_map.restrict_scalars LinearMap.restrictScalars
-/

/- warning: linear_map.coe_restrict_scalars -> LinearMap.coe_restrictScalars is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_10 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_11 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_13 : Module.{u2, u3} S M _inst_2 _inst_3] [_inst_14 : Module.{u2, u4} S M₂ _inst_2 _inst_5] [_inst_15 : LinearMap.CompatibleSMul.{u3, u4, u1, u2} M M₂ _inst_3 _inst_5 R S _inst_2 (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_3 _inst_10)))) _inst_13 (SMulZeroClass.toHasSmul.{u1, u4} R M₂ (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) (SMulWithZero.toSmulZeroClass.{u1, u4} R M₂ (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) (MulActionWithZero.toSMulWithZero.{u1, u4} R M₂ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) (Module.toMulActionWithZero.{u1, u4} R M₂ _inst_1 _inst_5 _inst_11)))) _inst_14] (fₗ : LinearMap.{u2, u2, u3, u4} S S _inst_2 _inst_2 (RingHom.id.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) M M₂ _inst_3 _inst_5 _inst_13 _inst_14), Eq.{max (succ u3) (succ u4)} (M -> M₂) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_5 _inst_10 _inst_11) (fun (_x : LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_5 _inst_10 _inst_11) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u1, u3, u4} R R M M₂ _inst_1 _inst_1 _inst_3 _inst_5 _inst_10 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.restrictScalars.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_10 _inst_11 _inst_13 _inst_14 _inst_15 fₗ)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u2, u2, u3, u4} S S _inst_2 _inst_2 (RingHom.id.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) M M₂ _inst_3 _inst_5 _inst_13 _inst_14) (fun (_x : LinearMap.{u2, u2, u3, u4} S S _inst_2 _inst_2 (RingHom.id.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) M M₂ _inst_3 _inst_5 _inst_13 _inst_14) => M -> M₂) (LinearMap.hasCoeToFun.{u2, u2, u3, u4} S S M M₂ _inst_2 _inst_2 _inst_3 _inst_5 _inst_13 _inst_14 (RingHom.id.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) fₗ)
but is expected to have type
  forall (R : Type.{u1}) {S : Type.{u4}} {M : Type.{u3}} {M₂ : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u4} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_5 : AddCommMonoid.{u2} M₂] [_inst_10 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_11 : Module.{u1, u2} R M₂ _inst_1 _inst_5] [_inst_13 : Module.{u4, u3} S M _inst_2 _inst_3] [_inst_14 : Module.{u4, u2} S M₂ _inst_2 _inst_5] [_inst_15 : LinearMap.CompatibleSMul.{u3, u2, u1, u4} M M₂ _inst_3 _inst_5 R S _inst_2 (SMulZeroClass.toSMul.{u1, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u1, u3} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_3 _inst_10)))) _inst_13 (SMulZeroClass.toSMul.{u1, u2} R M₂ (AddMonoid.toZero.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_5)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M₂ (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_5)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M₂ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_5)) (Module.toMulActionWithZero.{u1, u2} R M₂ _inst_1 _inst_5 _inst_11)))) _inst_14] (fₗ : LinearMap.{u4, u4, u3, u2} S S _inst_2 _inst_2 (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2)) M M₂ _inst_3 _inst_5 _inst_13 _inst_14), Eq.{max (succ u3) (succ u2)} (forall (ᾰ : M), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) ᾰ) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (LinearMap.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_5 _inst_10 _inst_11) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, u2} R R M M₂ _inst_1 _inst_1 _inst_3 _inst_5 _inst_10 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.restrictScalars.{u1, u4, u3, u2} R S M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_10 _inst_11 _inst_13 _inst_14 _inst_15 fₗ)) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (LinearMap.{u4, u4, u3, u2} S S _inst_2 _inst_2 (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2)) M M₂ _inst_3 _inst_5 _inst_13 _inst_14) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u4, u4, u3, u2} S S M M₂ _inst_2 _inst_2 _inst_3 _inst_5 _inst_13 _inst_14 (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2))) fₗ)
Case conversion may be inaccurate. Consider using '#align linear_map.coe_restrict_scalars LinearMap.coe_restrictScalarsₓ'. -/
@[simp]
theorem coe_restrictScalars (fₗ : M →ₗ[S] M₂) : ⇑(restrictScalars R fₗ) = fₗ :=
  rfl
#align linear_map.coe_restrict_scalars LinearMap.coe_restrictScalars

/- warning: linear_map.restrict_scalars_apply -> LinearMap.restrictScalars_apply is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_10 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_11 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_13 : Module.{u2, u3} S M _inst_2 _inst_3] [_inst_14 : Module.{u2, u4} S M₂ _inst_2 _inst_5] [_inst_15 : LinearMap.CompatibleSMul.{u3, u4, u1, u2} M M₂ _inst_3 _inst_5 R S _inst_2 (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_3 _inst_10)))) _inst_13 (SMulZeroClass.toHasSmul.{u1, u4} R M₂ (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) (SMulWithZero.toSmulZeroClass.{u1, u4} R M₂ (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) (MulActionWithZero.toSMulWithZero.{u1, u4} R M₂ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) (Module.toMulActionWithZero.{u1, u4} R M₂ _inst_1 _inst_5 _inst_11)))) _inst_14] (fₗ : LinearMap.{u2, u2, u3, u4} S S _inst_2 _inst_2 (RingHom.id.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) M M₂ _inst_3 _inst_5 _inst_13 _inst_14) (x : M), Eq.{succ u4} M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_5 _inst_10 _inst_11) (fun (_x : LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_5 _inst_10 _inst_11) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u1, u3, u4} R R M M₂ _inst_1 _inst_1 _inst_3 _inst_5 _inst_10 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.restrictScalars.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_10 _inst_11 _inst_13 _inst_14 _inst_15 fₗ) x) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u2, u2, u3, u4} S S _inst_2 _inst_2 (RingHom.id.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) M M₂ _inst_3 _inst_5 _inst_13 _inst_14) (fun (_x : LinearMap.{u2, u2, u3, u4} S S _inst_2 _inst_2 (RingHom.id.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) M M₂ _inst_3 _inst_5 _inst_13 _inst_14) => M -> M₂) (LinearMap.hasCoeToFun.{u2, u2, u3, u4} S S M M₂ _inst_2 _inst_2 _inst_3 _inst_5 _inst_13 _inst_14 (RingHom.id.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) fₗ x)
but is expected to have type
  forall (R : Type.{u1}) {S : Type.{u4}} {M : Type.{u3}} {M₂ : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u4} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_5 : AddCommMonoid.{u2} M₂] [_inst_10 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_11 : Module.{u1, u2} R M₂ _inst_1 _inst_5] [_inst_13 : Module.{u4, u3} S M _inst_2 _inst_3] [_inst_14 : Module.{u4, u2} S M₂ _inst_2 _inst_5] [_inst_15 : LinearMap.CompatibleSMul.{u3, u2, u1, u4} M M₂ _inst_3 _inst_5 R S _inst_2 (SMulZeroClass.toSMul.{u1, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u1, u3} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_3 _inst_10)))) _inst_13 (SMulZeroClass.toSMul.{u1, u2} R M₂ (AddMonoid.toZero.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_5)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M₂ (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_5)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M₂ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_5)) (Module.toMulActionWithZero.{u1, u2} R M₂ _inst_1 _inst_5 _inst_11)))) _inst_14] (fₗ : LinearMap.{u4, u4, u3, u2} S S _inst_2 _inst_2 (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2)) M M₂ _inst_3 _inst_5 _inst_13 _inst_14) (x : M), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (LinearMap.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_5 _inst_10 _inst_11) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, u2} R R M M₂ _inst_1 _inst_1 _inst_3 _inst_5 _inst_10 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.restrictScalars.{u1, u4, u3, u2} R S M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_10 _inst_11 _inst_13 _inst_14 _inst_15 fₗ) x) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (LinearMap.{u4, u4, u3, u2} S S _inst_2 _inst_2 (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2)) M M₂ _inst_3 _inst_5 _inst_13 _inst_14) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u4, u4, u3, u2} S S M M₂ _inst_2 _inst_2 _inst_3 _inst_5 _inst_13 _inst_14 (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2))) fₗ x)
Case conversion may be inaccurate. Consider using '#align linear_map.restrict_scalars_apply LinearMap.restrictScalars_applyₓ'. -/
theorem restrictScalars_apply (fₗ : M →ₗ[S] M₂) (x) : restrictScalars R fₗ x = fₗ x :=
  rfl
#align linear_map.restrict_scalars_apply LinearMap.restrictScalars_apply

/- warning: linear_map.restrict_scalars_injective -> LinearMap.restrictScalars_injective is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_10 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_11 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_13 : Module.{u2, u3} S M _inst_2 _inst_3] [_inst_14 : Module.{u2, u4} S M₂ _inst_2 _inst_5] [_inst_15 : LinearMap.CompatibleSMul.{u3, u4, u1, u2} M M₂ _inst_3 _inst_5 R S _inst_2 (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_3 _inst_10)))) _inst_13 (SMulZeroClass.toHasSmul.{u1, u4} R M₂ (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) (SMulWithZero.toSmulZeroClass.{u1, u4} R M₂ (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) (MulActionWithZero.toSMulWithZero.{u1, u4} R M₂ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) (Module.toMulActionWithZero.{u1, u4} R M₂ _inst_1 _inst_5 _inst_11)))) _inst_14], Function.Injective.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u2, u2, u3, u4} S S _inst_2 _inst_2 (RingHom.id.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) M M₂ _inst_3 _inst_5 _inst_13 _inst_14) (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_5 _inst_10 _inst_11) (LinearMap.restrictScalars.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_10 _inst_11 _inst_13 _inst_14 _inst_15)
but is expected to have type
  forall (R : Type.{u1}) {S : Type.{u2}} {M : Type.{u4}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u4} M] [_inst_5 : AddCommMonoid.{u3} M₂] [_inst_10 : Module.{u1, u4} R M _inst_1 _inst_3] [_inst_11 : Module.{u1, u3} R M₂ _inst_1 _inst_5] [_inst_13 : Module.{u2, u4} S M _inst_2 _inst_3] [_inst_14 : Module.{u2, u3} S M₂ _inst_2 _inst_5] [_inst_15 : LinearMap.CompatibleSMul.{u4, u3, u1, u2} M M₂ _inst_3 _inst_5 R S _inst_2 (SMulZeroClass.toSMul.{u1, u4} R M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u1, u4} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u1, u4} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (Module.toMulActionWithZero.{u1, u4} R M _inst_1 _inst_3 _inst_10)))) _inst_13 (SMulZeroClass.toSMul.{u1, u3} R M₂ (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5)) (SMulWithZero.toSMulZeroClass.{u1, u3} R M₂ (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5)) (MulActionWithZero.toSMulWithZero.{u1, u3} R M₂ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5)) (Module.toMulActionWithZero.{u1, u3} R M₂ _inst_1 _inst_5 _inst_11)))) _inst_14], Function.Injective.{max (succ u4) (succ u3), max (succ u4) (succ u3)} (LinearMap.{u2, u2, u4, u3} S S _inst_2 _inst_2 (RingHom.id.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) M M₂ _inst_3 _inst_5 _inst_13 _inst_14) (LinearMap.{u1, u1, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_5 _inst_10 _inst_11) (LinearMap.restrictScalars.{u1, u2, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_10 _inst_11 _inst_13 _inst_14 _inst_15)
Case conversion may be inaccurate. Consider using '#align linear_map.restrict_scalars_injective LinearMap.restrictScalars_injectiveₓ'. -/
theorem restrictScalars_injective :
    Function.Injective (restrictScalars R : (M →ₗ[S] M₂) → M →ₗ[R] M₂) := fun fₗ gₗ h =>
  ext (LinearMap.congr_fun h : _)
#align linear_map.restrict_scalars_injective LinearMap.restrictScalars_injective

/- warning: linear_map.restrict_scalars_inj -> LinearMap.restrictScalars_inj is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_10 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_11 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_13 : Module.{u2, u3} S M _inst_2 _inst_3] [_inst_14 : Module.{u2, u4} S M₂ _inst_2 _inst_5] [_inst_15 : LinearMap.CompatibleSMul.{u3, u4, u1, u2} M M₂ _inst_3 _inst_5 R S _inst_2 (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_3 _inst_10)))) _inst_13 (SMulZeroClass.toHasSmul.{u1, u4} R M₂ (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) (SMulWithZero.toSmulZeroClass.{u1, u4} R M₂ (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) (MulActionWithZero.toSMulWithZero.{u1, u4} R M₂ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) (Module.toMulActionWithZero.{u1, u4} R M₂ _inst_1 _inst_5 _inst_11)))) _inst_14] (fₗ : LinearMap.{u2, u2, u3, u4} S S _inst_2 _inst_2 (RingHom.id.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) M M₂ _inst_3 _inst_5 _inst_13 _inst_14) (gₗ : LinearMap.{u2, u2, u3, u4} S S _inst_2 _inst_2 (RingHom.id.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) M M₂ _inst_3 _inst_5 _inst_13 _inst_14), Iff (Eq.{max (succ u3) (succ u4)} (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_5 _inst_10 _inst_11) (LinearMap.restrictScalars.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_10 _inst_11 _inst_13 _inst_14 _inst_15 fₗ) (LinearMap.restrictScalars.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_10 _inst_11 _inst_13 _inst_14 _inst_15 gₗ)) (Eq.{max (succ u3) (succ u4)} (LinearMap.{u2, u2, u3, u4} S S _inst_2 _inst_2 (RingHom.id.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) M M₂ _inst_3 _inst_5 _inst_13 _inst_14) fₗ gₗ)
but is expected to have type
  forall (R : Type.{u1}) {S : Type.{u4}} {M : Type.{u3}} {M₂ : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u4} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_5 : AddCommMonoid.{u2} M₂] [_inst_10 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_11 : Module.{u1, u2} R M₂ _inst_1 _inst_5] [_inst_13 : Module.{u4, u3} S M _inst_2 _inst_3] [_inst_14 : Module.{u4, u2} S M₂ _inst_2 _inst_5] [_inst_15 : LinearMap.CompatibleSMul.{u3, u2, u1, u4} M M₂ _inst_3 _inst_5 R S _inst_2 (SMulZeroClass.toSMul.{u1, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u1, u3} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_3 _inst_10)))) _inst_13 (SMulZeroClass.toSMul.{u1, u2} R M₂ (AddMonoid.toZero.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_5)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M₂ (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_5)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M₂ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_5)) (Module.toMulActionWithZero.{u1, u2} R M₂ _inst_1 _inst_5 _inst_11)))) _inst_14] (fₗ : LinearMap.{u4, u4, u3, u2} S S _inst_2 _inst_2 (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2)) M M₂ _inst_3 _inst_5 _inst_13 _inst_14) (gₗ : LinearMap.{u4, u4, u3, u2} S S _inst_2 _inst_2 (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2)) M M₂ _inst_3 _inst_5 _inst_13 _inst_14), Iff (Eq.{max (succ u3) (succ u2)} (LinearMap.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_5 _inst_10 _inst_11) (LinearMap.restrictScalars.{u1, u4, u3, u2} R S M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_10 _inst_11 _inst_13 _inst_14 _inst_15 fₗ) (LinearMap.restrictScalars.{u1, u4, u3, u2} R S M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_10 _inst_11 _inst_13 _inst_14 _inst_15 gₗ)) (Eq.{max (succ u3) (succ u2)} (LinearMap.{u4, u4, u3, u2} S S _inst_2 _inst_2 (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2)) M M₂ _inst_3 _inst_5 _inst_13 _inst_14) fₗ gₗ)
Case conversion may be inaccurate. Consider using '#align linear_map.restrict_scalars_inj LinearMap.restrictScalars_injₓ'. -/
@[simp]
theorem restrictScalars_inj (fₗ gₗ : M →ₗ[S] M₂) :
    fₗ.restrictScalars R = gₗ.restrictScalars R ↔ fₗ = gₗ :=
  (restrictScalars_injective R).eq_iff
#align linear_map.restrict_scalars_inj LinearMap.restrictScalars_inj

end RestrictScalars

variable {R}

/- warning: linear_map.to_add_monoid_hom_injective -> LinearMap.toAddMonoidHom_injective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_6 : AddCommMonoid.{u4} M₃] [_inst_10 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_12 : Module.{u2, u4} S M₃ _inst_2 _inst_6] {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)}, Function.Injective.{max (succ u3) (succ u4), max (succ u4) (succ u3)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (AddMonoidHom.{u3, u4} M M₃ (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6))) (LinearMap.toAddMonoidHom.{u1, u2, u3, u4} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u4}} {M₃ : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_3 : AddCommMonoid.{u4} M] [_inst_6 : AddCommMonoid.{u3} M₃] [_inst_10 : Module.{u2, u4} R M _inst_1 _inst_3] [_inst_12 : Module.{u1, u3} S M₃ _inst_2 _inst_6] {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)}, Function.Injective.{max (succ u4) (succ u3), max (succ u4) (succ u3)} (LinearMap.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ M M₃ _inst_3 _inst_6 _inst_10 _inst_12) (AddMonoidHom.{u4, u3} M M₃ (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (AddMonoid.toAddZeroClass.{u3} M₃ (AddCommMonoid.toAddMonoid.{u3} M₃ _inst_6))) (LinearMap.toAddMonoidHom.{u2, u1, u4, u3} R S M M₃ _inst_1 _inst_2 _inst_3 _inst_6 _inst_10 _inst_12 σ)
Case conversion may be inaccurate. Consider using '#align linear_map.to_add_monoid_hom_injective LinearMap.toAddMonoidHom_injectiveₓ'. -/
theorem toAddMonoidHom_injective : Function.Injective (toAddMonoidHom : (M →ₛₗ[σ] M₃) → M →+ M₃) :=
  fun f g h => ext <| AddMonoidHom.congr_fun h
#align linear_map.to_add_monoid_hom_injective LinearMap.toAddMonoidHom_injective

/- warning: linear_map.ext_ring -> LinearMap.ext_ring is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M₃ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M₃] [_inst_12 : Module.{u2, u3} S M₃ _inst_2 _inst_6] {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {f : LinearMap.{u1, u2, u1, u3} R S _inst_1 _inst_2 σ R M₃ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_6 (Semiring.toModule.{u1} R _inst_1) _inst_12} {g : LinearMap.{u1, u2, u1, u3} R S _inst_1 _inst_2 σ R M₃ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_6 (Semiring.toModule.{u1} R _inst_1) _inst_12}, (Eq.{succ u3} M₃ (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (LinearMap.{u1, u2, u1, u3} R S _inst_1 _inst_2 σ R M₃ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_6 (Semiring.toModule.{u1} R _inst_1) _inst_12) (fun (_x : LinearMap.{u1, u2, u1, u3} R S _inst_1 _inst_2 σ R M₃ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_6 (Semiring.toModule.{u1} R _inst_1) _inst_12) => R -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u1, u3} R S R M₃ _inst_1 _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_6 (Semiring.toModule.{u1} R _inst_1) _inst_12 σ) f (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (LinearMap.{u1, u2, u1, u3} R S _inst_1 _inst_2 σ R M₃ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_6 (Semiring.toModule.{u1} R _inst_1) _inst_12) (fun (_x : LinearMap.{u1, u2, u1, u3} R S _inst_1 _inst_2 σ R M₃ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_6 (Semiring.toModule.{u1} R _inst_1) _inst_12) => R -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u1, u3} R S R M₃ _inst_1 _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_6 (Semiring.toModule.{u1} R _inst_1) _inst_12 σ) g (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))))) -> (Eq.{max (succ u1) (succ u3)} (LinearMap.{u1, u2, u1, u3} R S _inst_1 _inst_2 σ R M₃ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_6 (Semiring.toModule.{u1} R _inst_1) _inst_12) f g)
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u2}} {M₃ : Type.{u1}} [_inst_1 : Semiring.{u3} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u1} M₃] [_inst_12 : Module.{u2, u1} S M₃ _inst_2 _inst_6] {σ : RingHom.{u3, u2} R S (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {f : LinearMap.{u3, u2, u3, u1} R S _inst_1 _inst_2 σ R M₃ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) _inst_6 (Semiring.toModule.{u3} R _inst_1) _inst_12} {g : LinearMap.{u3, u2, u3, u1} R S _inst_1 _inst_2 σ R M₃ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) _inst_6 (Semiring.toModule.{u3} R _inst_1) _inst_12}, (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : R) => M₃) (OfNat.ofNat.{u3} R 1 (One.toOfNat1.{u3} R (Semiring.toOne.{u3} R _inst_1)))) (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (LinearMap.{u3, u2, u3, u1} R S _inst_1 _inst_2 σ R M₃ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) _inst_6 (Semiring.toModule.{u3} R _inst_1) _inst_12) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : R) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u3, u2, u3, u1} R S R M₃ _inst_1 _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) _inst_6 (Semiring.toModule.{u3} R _inst_1) _inst_12 σ) f (OfNat.ofNat.{u3} R 1 (One.toOfNat1.{u3} R (Semiring.toOne.{u3} R _inst_1)))) (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (LinearMap.{u3, u2, u3, u1} R S _inst_1 _inst_2 σ R M₃ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) _inst_6 (Semiring.toModule.{u3} R _inst_1) _inst_12) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : R) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u3, u2, u3, u1} R S R M₃ _inst_1 _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) _inst_6 (Semiring.toModule.{u3} R _inst_1) _inst_12 σ) g (OfNat.ofNat.{u3} R 1 (One.toOfNat1.{u3} R (Semiring.toOne.{u3} R _inst_1))))) -> (Eq.{max (succ u3) (succ u1)} (LinearMap.{u3, u2, u3, u1} R S _inst_1 _inst_2 σ R M₃ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) _inst_6 (Semiring.toModule.{u3} R _inst_1) _inst_12) f g)
Case conversion may be inaccurate. Consider using '#align linear_map.ext_ring LinearMap.ext_ringₓ'. -/
/-- If two `σ`-linear maps from `R` are equal on `1`, then they are equal. -/
@[ext]
theorem ext_ring {f g : R →ₛₗ[σ] M₃} (h : f 1 = g 1) : f = g :=
  ext fun x => by rw [← mul_one x, ← smul_eq_mul, f.map_smulₛₗ, g.map_smulₛₗ, h]
#align linear_map.ext_ring LinearMap.ext_ring

/- warning: linear_map.ext_ring_iff -> LinearMap.ext_ring_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_10 : Module.{u1, u2} R M _inst_1 _inst_3] {σ : RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {f : LinearMap.{u1, u1, u1, u2} R R _inst_1 _inst_1 σ R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_3 (Semiring.toModule.{u1} R _inst_1) _inst_10} {g : LinearMap.{u1, u1, u1, u2} R R _inst_1 _inst_1 σ R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_3 (Semiring.toModule.{u1} R _inst_1) _inst_10}, Iff (Eq.{max (succ u1) (succ u2)} (LinearMap.{u1, u1, u1, u2} R R _inst_1 _inst_1 σ R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_3 (Semiring.toModule.{u1} R _inst_1) _inst_10) f g) (Eq.{succ u2} M (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{u1, u1, u1, u2} R R _inst_1 _inst_1 σ R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_3 (Semiring.toModule.{u1} R _inst_1) _inst_10) (fun (_x : LinearMap.{u1, u1, u1, u2} R R _inst_1 _inst_1 σ R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_3 (Semiring.toModule.{u1} R _inst_1) _inst_10) => R -> M) (LinearMap.hasCoeToFun.{u1, u1, u1, u2} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_3 (Semiring.toModule.{u1} R _inst_1) _inst_10 σ) f (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{u1, u1, u1, u2} R R _inst_1 _inst_1 σ R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_3 (Semiring.toModule.{u1} R _inst_1) _inst_10) (fun (_x : LinearMap.{u1, u1, u1, u2} R R _inst_1 _inst_1 σ R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_3 (Semiring.toModule.{u1} R _inst_1) _inst_10) => R -> M) (LinearMap.hasCoeToFun.{u1, u1, u1, u2} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_3 (Semiring.toModule.{u1} R _inst_1) _inst_10 σ) g (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_10 : Module.{u2, u1} R M _inst_1 _inst_3] {σ : RingHom.{u2, u2} R R (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u2} R _inst_1)} {f : LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 σ R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) _inst_3 (Semiring.toModule.{u2} R _inst_1) _inst_10} {g : LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 σ R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) _inst_3 (Semiring.toModule.{u2} R _inst_1) _inst_10}, Iff (Eq.{max (succ u2) (succ u1)} (LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 σ R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) _inst_3 (Semiring.toModule.{u2} R _inst_1) _inst_10) f g) (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : R) => M) (OfNat.ofNat.{u2} R 1 (One.toOfNat1.{u2} R (Semiring.toOne.{u2} R _inst_1)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 σ R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) _inst_3 (Semiring.toModule.{u2} R _inst_1) _inst_10) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : R) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, u2, u1} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) _inst_3 (Semiring.toModule.{u2} R _inst_1) _inst_10 σ) f (OfNat.ofNat.{u2} R 1 (One.toOfNat1.{u2} R (Semiring.toOne.{u2} R _inst_1)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 σ R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) _inst_3 (Semiring.toModule.{u2} R _inst_1) _inst_10) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : R) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, u2, u1} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) _inst_3 (Semiring.toModule.{u2} R _inst_1) _inst_10 σ) g (OfNat.ofNat.{u2} R 1 (One.toOfNat1.{u2} R (Semiring.toOne.{u2} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align linear_map.ext_ring_iff LinearMap.ext_ring_iffₓ'. -/
theorem ext_ring_iff {σ : R →+* R} {f g : R →ₛₗ[σ] M} : f = g ↔ f 1 = g 1 :=
  ⟨fun h => h ▸ rfl, ext_ring⟩
#align linear_map.ext_ring_iff LinearMap.ext_ring_iff

/- warning: linear_map.ext_ring_op -> LinearMap.ext_ring_op is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M₃ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M₃] [_inst_12 : Module.{u2, u3} S M₃ _inst_2 _inst_6] {σ : RingHom.{u1, u2} (MulOpposite.{u1} R) S (MulOpposite.nonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {f : LinearMap.{u1, u2, u1, u3} (MulOpposite.{u1} R) S (MulOpposite.semiring.{u1} R _inst_1) _inst_2 σ R M₃ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_6 (Semiring.toOppositeModule.{u1} R _inst_1) _inst_12} {g : LinearMap.{u1, u2, u1, u3} (MulOpposite.{u1} R) S (MulOpposite.semiring.{u1} R _inst_1) _inst_2 σ R M₃ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_6 (Semiring.toOppositeModule.{u1} R _inst_1) _inst_12}, (Eq.{succ u3} M₃ (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (LinearMap.{u1, u2, u1, u3} (MulOpposite.{u1} R) S (MulOpposite.semiring.{u1} R _inst_1) _inst_2 σ R M₃ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_6 (Semiring.toOppositeModule.{u1} R _inst_1) _inst_12) (fun (_x : LinearMap.{u1, u2, u1, u3} (MulOpposite.{u1} R) S (MulOpposite.semiring.{u1} R _inst_1) _inst_2 σ R M₃ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_6 (Semiring.toOppositeModule.{u1} R _inst_1) _inst_12) => R -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u1, u3} (MulOpposite.{u1} R) S R M₃ (MulOpposite.semiring.{u1} R _inst_1) _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_6 (Semiring.toOppositeModule.{u1} R _inst_1) _inst_12 σ) f (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (LinearMap.{u1, u2, u1, u3} (MulOpposite.{u1} R) S (MulOpposite.semiring.{u1} R _inst_1) _inst_2 σ R M₃ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_6 (Semiring.toOppositeModule.{u1} R _inst_1) _inst_12) (fun (_x : LinearMap.{u1, u2, u1, u3} (MulOpposite.{u1} R) S (MulOpposite.semiring.{u1} R _inst_1) _inst_2 σ R M₃ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_6 (Semiring.toOppositeModule.{u1} R _inst_1) _inst_12) => R -> M₃) (LinearMap.hasCoeToFun.{u1, u2, u1, u3} (MulOpposite.{u1} R) S R M₃ (MulOpposite.semiring.{u1} R _inst_1) _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_6 (Semiring.toOppositeModule.{u1} R _inst_1) _inst_12 σ) g (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))))) -> (Eq.{max (succ u1) (succ u3)} (LinearMap.{u1, u2, u1, u3} (MulOpposite.{u1} R) S (MulOpposite.semiring.{u1} R _inst_1) _inst_2 σ R M₃ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_6 (Semiring.toOppositeModule.{u1} R _inst_1) _inst_12) f g)
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u2}} {M₃ : Type.{u1}} [_inst_1 : Semiring.{u3} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u1} M₃] [_inst_12 : Module.{u2, u1} S M₃ _inst_2 _inst_6] {σ : RingHom.{u3, u2} (MulOpposite.{u3} R) S (MulOpposite.instNonAssocSemiringMulOpposite.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {f : LinearMap.{u3, u2, u3, u1} (MulOpposite.{u3} R) S (MulOpposite.instSemiringMulOpposite.{u3} R _inst_1) _inst_2 σ R M₃ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) _inst_6 (Semiring.toOppositeModule.{u3} R _inst_1) _inst_12} {g : LinearMap.{u3, u2, u3, u1} (MulOpposite.{u3} R) S (MulOpposite.instSemiringMulOpposite.{u3} R _inst_1) _inst_2 σ R M₃ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) _inst_6 (Semiring.toOppositeModule.{u3} R _inst_1) _inst_12}, (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : R) => M₃) (OfNat.ofNat.{u3} R 1 (One.toOfNat1.{u3} R (Semiring.toOne.{u3} R _inst_1)))) (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (LinearMap.{u3, u2, u3, u1} (MulOpposite.{u3} R) S (MulOpposite.instSemiringMulOpposite.{u3} R _inst_1) _inst_2 σ R M₃ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) _inst_6 (Semiring.toOppositeModule.{u3} R _inst_1) _inst_12) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : R) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u3, u2, u3, u1} (MulOpposite.{u3} R) S R M₃ (MulOpposite.instSemiringMulOpposite.{u3} R _inst_1) _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) _inst_6 (Semiring.toOppositeModule.{u3} R _inst_1) _inst_12 σ) f (OfNat.ofNat.{u3} R 1 (One.toOfNat1.{u3} R (Semiring.toOne.{u3} R _inst_1)))) (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (LinearMap.{u3, u2, u3, u1} (MulOpposite.{u3} R) S (MulOpposite.instSemiringMulOpposite.{u3} R _inst_1) _inst_2 σ R M₃ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) _inst_6 (Semiring.toOppositeModule.{u3} R _inst_1) _inst_12) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : R) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u3, u2, u3, u1} (MulOpposite.{u3} R) S R M₃ (MulOpposite.instSemiringMulOpposite.{u3} R _inst_1) _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) _inst_6 (Semiring.toOppositeModule.{u3} R _inst_1) _inst_12 σ) g (OfNat.ofNat.{u3} R 1 (One.toOfNat1.{u3} R (Semiring.toOne.{u3} R _inst_1))))) -> (Eq.{max (succ u3) (succ u1)} (LinearMap.{u3, u2, u3, u1} (MulOpposite.{u3} R) S (MulOpposite.instSemiringMulOpposite.{u3} R _inst_1) _inst_2 σ R M₃ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) _inst_6 (Semiring.toOppositeModule.{u3} R _inst_1) _inst_12) f g)
Case conversion may be inaccurate. Consider using '#align linear_map.ext_ring_op LinearMap.ext_ring_opₓ'. -/
@[ext]
theorem ext_ring_op {σ : Rᵐᵒᵖ →+* S} {f g : R →ₛₗ[σ] M₃} (h : f 1 = g 1) : f = g :=
  ext fun x => by rw [← one_mul x, ← op_smul_eq_mul, f.map_smulₛₗ, g.map_smulₛₗ, h]
#align linear_map.ext_ring_op LinearMap.ext_ring_op

end

#print RingHom.toSemilinearMap /-
/-- Interpret a `ring_hom` `f` as an `f`-semilinear map. -/
@[simps]
def RingHom.toSemilinearMap (f : R →+* S) : R →ₛₗ[f] S :=
  { f with
    toFun := f
    map_smul' := f.map_mul }
#align ring_hom.to_semilinear_map RingHom.toSemilinearMap
-/

section

variable [Semiring R₁] [Semiring R₂] [Semiring R₃]

variable [AddCommMonoid M] [AddCommMonoid M₁] [AddCommMonoid M₂] [AddCommMonoid M₃]

variable {module_M₁ : Module R₁ M₁} {module_M₂ : Module R₂ M₂} {module_M₃ : Module R₃ M₃}

variable {σ₁₂ : R₁ →+* R₂} {σ₂₃ : R₂ →+* R₃} {σ₁₃ : R₁ →+* R₃}

variable [RingHomCompTriple σ₁₂ σ₂₃ σ₁₃]

variable (f : M₂ →ₛₗ[σ₂₃] M₃) (g : M₁ →ₛₗ[σ₁₂] M₂)

include module_M₁ module_M₂ module_M₃

#print LinearMap.comp /-
/-- Composition of two linear maps is a linear map -/
def comp : M₁ →ₛₗ[σ₁₃] M₃ where
  toFun := f ∘ g
  map_add' := by simp only [map_add, forall_const, eq_self_iff_true, comp_app]
  map_smul' r x := by rw [comp_app, map_smulₛₗ, map_smulₛₗ, RingHomCompTriple.comp_apply]
#align linear_map.comp LinearMap.comp
-/

omit module_M₁ module_M₂ module_M₃

-- mathport name: «expr ∘ₗ »
infixr:80 " ∘ₗ " =>
  @LinearMap.comp _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ (RingHom.id _) (RingHom.id _) (RingHom.id _)
    RingHomCompTriple.ids

include σ₁₃

/- warning: linear_map.comp_apply -> LinearMap.comp_apply is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {R₃ : Type.{u3}} {M₁ : Type.{u4}} {M₂ : Type.{u5}} {M₃ : Type.{u6}} [_inst_3 : Semiring.{u1} R₁] [_inst_4 : Semiring.{u2} R₂] [_inst_5 : Semiring.{u3} R₃] [_inst_7 : AddCommMonoid.{u4} M₁] [_inst_8 : AddCommMonoid.{u5} M₂] [_inst_9 : AddCommMonoid.{u6} M₃] {module_M₁ : Module.{u1, u4} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u2, u5} R₂ M₂ _inst_4 _inst_8} {module_M₃ : Module.{u3, u6} R₃ M₃ _inst_5 _inst_9} {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₂₃ : RingHom.{u2, u3} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5)} {σ₁₃ : RingHom.{u1, u3} R₁ R₃ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5)} [_inst_10 : RingHomCompTriple.{u1, u2, u3} R₁ R₂ R₃ _inst_3 _inst_4 _inst_5 σ₁₂ σ₂₃ σ₁₃] (f : LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) (g : LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) (x : M₁), Eq.{succ u6} M₃ (coeFn.{max (succ u4) (succ u6), max (succ u4) (succ u6)} (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_3 _inst_5 σ₁₃ M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃) (fun (_x : LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_3 _inst_5 σ₁₃ M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃) => M₁ -> M₃) (LinearMap.hasCoeToFun.{u1, u3, u4, u6} R₁ R₃ M₁ M₃ _inst_3 _inst_5 _inst_7 _inst_9 module_M₁ module_M₃ σ₁₃) (LinearMap.comp.{u1, u2, u3, u4, u5, u6} R₁ R₂ R₃ M₁ M₂ M₃ _inst_3 _inst_4 _inst_5 _inst_7 _inst_8 _inst_9 module_M₁ module_M₂ module_M₃ σ₁₂ σ₂₃ σ₁₃ _inst_10 f g) x) (coeFn.{max (succ u5) (succ u6), max (succ u5) (succ u6)} (LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) (fun (_x : LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) => M₂ -> M₃) (LinearMap.hasCoeToFun.{u2, u3, u5, u6} R₂ R₃ M₂ M₃ _inst_4 _inst_5 _inst_8 _inst_9 module_M₂ module_M₃ σ₂₃) f (coeFn.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) (fun (_x : LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) => M₁ -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u4, u5} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂) g x))
but is expected to have type
  forall {R₁ : Type.{u4}} {R₂ : Type.{u2}} {R₃ : Type.{u3}} {M₁ : Type.{u5}} {M₂ : Type.{u1}} {M₃ : Type.{u6}} [_inst_3 : Semiring.{u4} R₁] [_inst_4 : Semiring.{u2} R₂] [_inst_5 : Semiring.{u3} R₃] [_inst_7 : AddCommMonoid.{u5} M₁] [_inst_8 : AddCommMonoid.{u1} M₂] [_inst_9 : AddCommMonoid.{u6} M₃] {module_M₁ : Module.{u4, u5} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u2, u1} R₂ M₂ _inst_4 _inst_8} {module_M₃ : Module.{u3, u6} R₃ M₃ _inst_5 _inst_9} {σ₁₂ : RingHom.{u4, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u4} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₂₃ : RingHom.{u2, u3} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5)} {σ₁₃ : RingHom.{u4, u3} R₁ R₃ (Semiring.toNonAssocSemiring.{u4} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5)} [_inst_10 : RingHomCompTriple.{u4, u2, u3} R₁ R₂ R₃ _inst_3 _inst_4 _inst_5 σ₁₂ σ₂₃ σ₁₃] (f : LinearMap.{u2, u3, u1, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) (g : LinearMap.{u4, u2, u5, u1} R₁ R₂ _inst_3 _inst_4 σ₁₂ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) (x : M₁), Eq.{succ u6} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M₁) => M₃) x) (FunLike.coe.{max (succ u5) (succ u6), succ u5, succ u6} (LinearMap.{u4, u3, u5, u6} R₁ R₃ _inst_3 _inst_5 σ₁₃ M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃) M₁ (fun (_x : M₁) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M₁) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u4, u3, u5, u6} R₁ R₃ M₁ M₃ _inst_3 _inst_5 _inst_7 _inst_9 module_M₁ module_M₃ σ₁₃) (LinearMap.comp.{u4, u2, u3, u5, u1, u6} R₁ R₂ R₃ M₁ M₂ M₃ _inst_3 _inst_4 _inst_5 _inst_7 _inst_8 _inst_9 module_M₁ module_M₂ module_M₃ σ₁₂ σ₂₃ σ₁₃ _inst_10 f g) x) (FunLike.coe.{max (succ u1) (succ u6), succ u1, succ u6} (LinearMap.{u2, u3, u1, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) M₂ (fun (_x : M₂) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M₂) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u2, u3, u1, u6} R₂ R₃ M₂ M₃ _inst_4 _inst_5 _inst_8 _inst_9 module_M₂ module_M₃ σ₂₃) f (FunLike.coe.{max (succ u5) (succ u1), succ u5, succ u1} (LinearMap.{u4, u2, u5, u1} R₁ R₂ _inst_3 _inst_4 σ₁₂ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) M₁ (fun (_x : M₁) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M₁) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u4, u2, u5, u1} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂) g x))
Case conversion may be inaccurate. Consider using '#align linear_map.comp_apply LinearMap.comp_applyₓ'. -/
theorem comp_apply (x : M₁) : f.comp g x = f (g x) :=
  rfl
#align linear_map.comp_apply LinearMap.comp_apply

omit σ₁₃

include σ₁₃

/- warning: linear_map.coe_comp -> LinearMap.coe_comp is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {R₃ : Type.{u3}} {M₁ : Type.{u4}} {M₂ : Type.{u5}} {M₃ : Type.{u6}} [_inst_3 : Semiring.{u1} R₁] [_inst_4 : Semiring.{u2} R₂] [_inst_5 : Semiring.{u3} R₃] [_inst_7 : AddCommMonoid.{u4} M₁] [_inst_8 : AddCommMonoid.{u5} M₂] [_inst_9 : AddCommMonoid.{u6} M₃] {module_M₁ : Module.{u1, u4} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u2, u5} R₂ M₂ _inst_4 _inst_8} {module_M₃ : Module.{u3, u6} R₃ M₃ _inst_5 _inst_9} {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₂₃ : RingHom.{u2, u3} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5)} {σ₁₃ : RingHom.{u1, u3} R₁ R₃ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5)} [_inst_10 : RingHomCompTriple.{u1, u2, u3} R₁ R₂ R₃ _inst_3 _inst_4 _inst_5 σ₁₂ σ₂₃ σ₁₃] (f : LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) (g : LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂), Eq.{max (succ u4) (succ u6)} ((fun (_x : LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_3 _inst_5 σ₁₃ M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃) => M₁ -> M₃) (LinearMap.comp.{u1, u2, u3, u4, u5, u6} R₁ R₂ R₃ M₁ M₂ M₃ _inst_3 _inst_4 _inst_5 _inst_7 _inst_8 _inst_9 module_M₁ module_M₂ module_M₃ σ₁₂ σ₂₃ σ₁₃ _inst_10 f g)) (coeFn.{max (succ u4) (succ u6), max (succ u4) (succ u6)} (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_3 _inst_5 σ₁₃ M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃) (fun (_x : LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_3 _inst_5 σ₁₃ M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃) => M₁ -> M₃) (LinearMap.hasCoeToFun.{u1, u3, u4, u6} R₁ R₃ M₁ M₃ _inst_3 _inst_5 _inst_7 _inst_9 module_M₁ module_M₃ σ₁₃) (LinearMap.comp.{u1, u2, u3, u4, u5, u6} R₁ R₂ R₃ M₁ M₂ M₃ _inst_3 _inst_4 _inst_5 _inst_7 _inst_8 _inst_9 module_M₁ module_M₂ module_M₃ σ₁₂ σ₂₃ σ₁₃ _inst_10 f g)) (Function.comp.{succ u4, succ u5, succ u6} M₁ M₂ M₃ (coeFn.{max (succ u5) (succ u6), max (succ u5) (succ u6)} (LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) (fun (_x : LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) => M₂ -> M₃) (LinearMap.hasCoeToFun.{u2, u3, u5, u6} R₂ R₃ M₂ M₃ _inst_4 _inst_5 _inst_8 _inst_9 module_M₂ module_M₃ σ₂₃) f) (coeFn.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) (fun (_x : LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) => M₁ -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u4, u5} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂) g))
but is expected to have type
  forall {R₁ : Type.{u4}} {R₂ : Type.{u2}} {R₃ : Type.{u3}} {M₁ : Type.{u6}} {M₂ : Type.{u1}} {M₃ : Type.{u5}} [_inst_3 : Semiring.{u4} R₁] [_inst_4 : Semiring.{u2} R₂] [_inst_5 : Semiring.{u3} R₃] [_inst_7 : AddCommMonoid.{u6} M₁] [_inst_8 : AddCommMonoid.{u1} M₂] [_inst_9 : AddCommMonoid.{u5} M₃] {module_M₁ : Module.{u4, u6} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u2, u1} R₂ M₂ _inst_4 _inst_8} {module_M₃ : Module.{u3, u5} R₃ M₃ _inst_5 _inst_9} {σ₁₂ : RingHom.{u4, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u4} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₂₃ : RingHom.{u2, u3} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5)} {σ₁₃ : RingHom.{u4, u3} R₁ R₃ (Semiring.toNonAssocSemiring.{u4} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5)} [_inst_10 : RingHomCompTriple.{u4, u2, u3} R₁ R₂ R₃ _inst_3 _inst_4 _inst_5 σ₁₂ σ₂₃ σ₁₃] (f : LinearMap.{u2, u3, u1, u5} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) (g : LinearMap.{u4, u2, u6, u1} R₁ R₂ _inst_3 _inst_4 σ₁₂ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂), Eq.{max (succ u6) (succ u5)} (forall (a : M₁), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M₁) => M₃) a) (FunLike.coe.{max (succ u6) (succ u5), succ u6, succ u5} (LinearMap.{u4, u3, u6, u5} R₁ R₃ _inst_3 _inst_5 σ₁₃ M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃) M₁ (fun (_x : M₁) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M₁) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u4, u3, u6, u5} R₁ R₃ M₁ M₃ _inst_3 _inst_5 _inst_7 _inst_9 module_M₁ module_M₃ σ₁₃) (LinearMap.comp.{u4, u2, u3, u6, u1, u5} R₁ R₂ R₃ M₁ M₂ M₃ _inst_3 _inst_4 _inst_5 _inst_7 _inst_8 _inst_9 module_M₁ module_M₂ module_M₃ σ₁₂ σ₂₃ σ₁₃ _inst_10 f g)) (Function.comp.{succ u6, succ u1, succ u5} M₁ M₂ M₃ (FunLike.coe.{max (succ u1) (succ u5), succ u1, succ u5} (LinearMap.{u2, u3, u1, u5} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) M₂ (fun (_x : M₂) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M₂) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u2, u3, u1, u5} R₂ R₃ M₂ M₃ _inst_4 _inst_5 _inst_8 _inst_9 module_M₂ module_M₃ σ₂₃) f) (FunLike.coe.{max (succ u6) (succ u1), succ u6, succ u1} (LinearMap.{u4, u2, u6, u1} R₁ R₂ _inst_3 _inst_4 σ₁₂ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) M₁ (fun (_x : M₁) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M₁) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u4, u2, u6, u1} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂) g))
Case conversion may be inaccurate. Consider using '#align linear_map.coe_comp LinearMap.coe_compₓ'. -/
@[simp, norm_cast]
theorem coe_comp : (f.comp g : M₁ → M₃) = f ∘ g :=
  rfl
#align linear_map.coe_comp LinearMap.coe_comp

omit σ₁₃

/- warning: linear_map.comp_id -> LinearMap.comp_id is a dubious translation:
lean 3 declaration is
  forall {R₂ : Type.{u1}} {R₃ : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} [_inst_4 : Semiring.{u1} R₂] [_inst_5 : Semiring.{u2} R₃] [_inst_8 : AddCommMonoid.{u3} M₂] [_inst_9 : AddCommMonoid.{u4} M₃] {module_M₂ : Module.{u1, u3} R₂ M₂ _inst_4 _inst_8} {module_M₃ : Module.{u2, u4} R₃ M₃ _inst_5 _inst_9} {σ₂₃ : RingHom.{u1, u2} R₂ R₃ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u2} R₃ _inst_5)} (f : LinearMap.{u1, u2, u3, u4} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃), Eq.{max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) (LinearMap.comp.{u1, u1, u2, u3, u3, u4} R₂ R₂ R₃ M₂ M₂ M₃ _inst_4 _inst_4 _inst_5 _inst_8 _inst_8 _inst_9 module_M₂ module_M₂ module_M₃ (RingHom.id.{u1} R₂ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_4)) σ₂₃ σ₂₃ (RingHomCompTriple.ids.{u1, u2} R₂ R₃ _inst_4 _inst_5 σ₂₃) f (LinearMap.id.{u1, u3} R₂ M₂ _inst_4 _inst_8 module_M₂)) f
but is expected to have type
  forall {R₂ : Type.{u2}} {R₃ : Type.{u1}} {M₂ : Type.{u4}} {M₃ : Type.{u3}} [_inst_4 : Semiring.{u2} R₂] [_inst_5 : Semiring.{u1} R₃] [_inst_8 : AddCommMonoid.{u4} M₂] [_inst_9 : AddCommMonoid.{u3} M₃] {module_M₂ : Module.{u2, u4} R₂ M₂ _inst_4 _inst_8} {module_M₃ : Module.{u1, u3} R₃ M₃ _inst_5 _inst_9} {σ₂₃ : RingHom.{u2, u1} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u1} R₃ _inst_5)} (f : LinearMap.{u2, u1, u4, u3} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃), Eq.{max (succ u4) (succ u3)} (LinearMap.{u2, u1, u4, u3} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) (LinearMap.comp.{u2, u2, u1, u4, u4, u3} R₂ R₂ R₃ M₂ M₂ M₃ _inst_4 _inst_4 _inst_5 _inst_8 _inst_8 _inst_9 module_M₂ module_M₂ module_M₃ (RingHom.id.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)) σ₂₃ σ₂₃ (RingHomCompTriple.ids.{u2, u1} R₂ R₃ _inst_4 _inst_5 σ₂₃) f (LinearMap.id.{u2, u4} R₂ M₂ _inst_4 _inst_8 module_M₂)) f
Case conversion may be inaccurate. Consider using '#align linear_map.comp_id LinearMap.comp_idₓ'. -/
@[simp]
theorem comp_id : f.comp id = f :=
  LinearMap.ext fun x => rfl
#align linear_map.comp_id LinearMap.comp_id

/- warning: linear_map.id_comp -> LinearMap.id_comp is a dubious translation:
lean 3 declaration is
  forall {R₂ : Type.{u1}} {R₃ : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} [_inst_4 : Semiring.{u1} R₂] [_inst_5 : Semiring.{u2} R₃] [_inst_8 : AddCommMonoid.{u3} M₂] [_inst_9 : AddCommMonoid.{u4} M₃] {module_M₂ : Module.{u1, u3} R₂ M₂ _inst_4 _inst_8} {module_M₃ : Module.{u2, u4} R₃ M₃ _inst_5 _inst_9} {σ₂₃ : RingHom.{u1, u2} R₂ R₃ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u2} R₃ _inst_5)} (f : LinearMap.{u1, u2, u3, u4} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃), Eq.{max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) (LinearMap.comp.{u1, u2, u2, u3, u4, u4} R₂ R₃ R₃ M₂ M₃ M₃ _inst_4 _inst_5 _inst_5 _inst_8 _inst_9 _inst_9 module_M₂ module_M₃ module_M₃ σ₂₃ (RingHom.id.{u2} R₃ (Semiring.toNonAssocSemiring.{u2} R₃ _inst_5)) σ₂₃ (RingHomCompTriple.right_ids.{u1, u2} R₂ R₃ _inst_4 _inst_5 σ₂₃) (LinearMap.id.{u2, u4} R₃ M₃ _inst_5 _inst_9 module_M₃) f) f
but is expected to have type
  forall {R₂ : Type.{u2}} {R₃ : Type.{u1}} {M₂ : Type.{u4}} {M₃ : Type.{u3}} [_inst_4 : Semiring.{u2} R₂] [_inst_5 : Semiring.{u1} R₃] [_inst_8 : AddCommMonoid.{u4} M₂] [_inst_9 : AddCommMonoid.{u3} M₃] {module_M₂ : Module.{u2, u4} R₂ M₂ _inst_4 _inst_8} {module_M₃ : Module.{u1, u3} R₃ M₃ _inst_5 _inst_9} {σ₂₃ : RingHom.{u2, u1} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u1} R₃ _inst_5)} (f : LinearMap.{u2, u1, u4, u3} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃), Eq.{max (succ u4) (succ u3)} (LinearMap.{u2, u1, u4, u3} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) (LinearMap.comp.{u2, u1, u1, u4, u3, u3} R₂ R₃ R₃ M₂ M₃ M₃ _inst_4 _inst_5 _inst_5 _inst_8 _inst_9 _inst_9 module_M₂ module_M₃ module_M₃ σ₂₃ (RingHom.id.{u1} R₃ (Semiring.toNonAssocSemiring.{u1} R₃ _inst_5)) σ₂₃ (RingHomCompTriple.right_ids.{u2, u1} R₂ R₃ _inst_4 _inst_5 σ₂₃) (LinearMap.id.{u1, u3} R₃ M₃ _inst_5 _inst_9 module_M₃) f) f
Case conversion may be inaccurate. Consider using '#align linear_map.id_comp LinearMap.id_compₓ'. -/
@[simp]
theorem id_comp : id.comp f = f :=
  LinearMap.ext fun x => rfl
#align linear_map.id_comp LinearMap.id_comp

variable {f g} {f' : M₂ →ₛₗ[σ₂₃] M₃} {g' : M₁ →ₛₗ[σ₁₂] M₂}

include σ₁₃

/- warning: linear_map.cancel_right -> LinearMap.cancel_right is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {R₃ : Type.{u3}} {M₁ : Type.{u4}} {M₂ : Type.{u5}} {M₃ : Type.{u6}} [_inst_3 : Semiring.{u1} R₁] [_inst_4 : Semiring.{u2} R₂] [_inst_5 : Semiring.{u3} R₃] [_inst_7 : AddCommMonoid.{u4} M₁] [_inst_8 : AddCommMonoid.{u5} M₂] [_inst_9 : AddCommMonoid.{u6} M₃] {module_M₁ : Module.{u1, u4} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u2, u5} R₂ M₂ _inst_4 _inst_8} {module_M₃ : Module.{u3, u6} R₃ M₃ _inst_5 _inst_9} {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₂₃ : RingHom.{u2, u3} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5)} {σ₁₃ : RingHom.{u1, u3} R₁ R₃ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5)} [_inst_10 : RingHomCompTriple.{u1, u2, u3} R₁ R₂ R₃ _inst_3 _inst_4 _inst_5 σ₁₂ σ₂₃ σ₁₃] {f : LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃} {g : LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂} {f' : LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃}, (Function.Surjective.{succ u4, succ u5} M₁ M₂ (coeFn.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) (fun (_x : LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) => M₁ -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u4, u5} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂) g)) -> (Iff (Eq.{max (succ u4) (succ u6)} (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_3 _inst_5 σ₁₃ M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃) (LinearMap.comp.{u1, u2, u3, u4, u5, u6} R₁ R₂ R₃ M₁ M₂ M₃ _inst_3 _inst_4 _inst_5 _inst_7 _inst_8 _inst_9 module_M₁ module_M₂ module_M₃ σ₁₂ σ₂₃ σ₁₃ _inst_10 f g) (LinearMap.comp.{u1, u2, u3, u4, u5, u6} R₁ R₂ R₃ M₁ M₂ M₃ _inst_3 _inst_4 _inst_5 _inst_7 _inst_8 _inst_9 module_M₁ module_M₂ module_M₃ σ₁₂ σ₂₃ σ₁₃ _inst_10 f' g)) (Eq.{max (succ u5) (succ u6)} (LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) f f'))
but is expected to have type
  forall {R₁ : Type.{u4}} {R₂ : Type.{u3}} {R₃ : Type.{u1}} {M₁ : Type.{u6}} {M₂ : Type.{u5}} {M₃ : Type.{u2}} [_inst_3 : Semiring.{u4} R₁] [_inst_4 : Semiring.{u3} R₂] [_inst_5 : Semiring.{u1} R₃] [_inst_7 : AddCommMonoid.{u6} M₁] [_inst_8 : AddCommMonoid.{u5} M₂] [_inst_9 : AddCommMonoid.{u2} M₃] {module_M₁ : Module.{u4, u6} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u3, u5} R₂ M₂ _inst_4 _inst_8} {module_M₃ : Module.{u1, u2} R₃ M₃ _inst_5 _inst_9} {σ₁₂ : RingHom.{u4, u3} R₁ R₂ (Semiring.toNonAssocSemiring.{u4} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u3} R₂ _inst_4)} {σ₂₃ : RingHom.{u3, u1} R₂ R₃ (Semiring.toNonAssocSemiring.{u3} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u1} R₃ _inst_5)} {σ₁₃ : RingHom.{u4, u1} R₁ R₃ (Semiring.toNonAssocSemiring.{u4} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u1} R₃ _inst_5)} [_inst_10 : RingHomCompTriple.{u4, u3, u1} R₁ R₂ R₃ _inst_3 _inst_4 _inst_5 σ₁₂ σ₂₃ σ₁₃] {f : LinearMap.{u3, u1, u5, u2} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃} {g : LinearMap.{u4, u3, u6, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂} {f' : LinearMap.{u3, u1, u5, u2} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃}, (Function.Surjective.{succ u6, succ u5} M₁ M₂ (FunLike.coe.{max (succ u6) (succ u5), succ u6, succ u5} (LinearMap.{u4, u3, u6, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) M₁ (fun (_x : M₁) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M₁) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u4, u3, u6, u5} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂) g)) -> (Iff (Eq.{max (succ u6) (succ u2)} (LinearMap.{u4, u1, u6, u2} R₁ R₃ _inst_3 _inst_5 σ₁₃ M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃) (LinearMap.comp.{u4, u3, u1, u6, u5, u2} R₁ R₂ R₃ M₁ M₂ M₃ _inst_3 _inst_4 _inst_5 _inst_7 _inst_8 _inst_9 module_M₁ module_M₂ module_M₃ σ₁₂ σ₂₃ σ₁₃ _inst_10 f g) (LinearMap.comp.{u4, u3, u1, u6, u5, u2} R₁ R₂ R₃ M₁ M₂ M₃ _inst_3 _inst_4 _inst_5 _inst_7 _inst_8 _inst_9 module_M₁ module_M₂ module_M₃ σ₁₂ σ₂₃ σ₁₃ _inst_10 f' g)) (Eq.{max (succ u5) (succ u2)} (LinearMap.{u3, u1, u5, u2} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) f f'))
Case conversion may be inaccurate. Consider using '#align linear_map.cancel_right LinearMap.cancel_rightₓ'. -/
theorem cancel_right (hg : Function.Surjective g) : f.comp g = f'.comp g ↔ f = f' :=
  ⟨fun h => ext <| hg.forall.2 (ext_iff.1 h), fun h => h ▸ rfl⟩
#align linear_map.cancel_right LinearMap.cancel_right

/- warning: linear_map.cancel_left -> LinearMap.cancel_left is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {R₃ : Type.{u3}} {M₁ : Type.{u4}} {M₂ : Type.{u5}} {M₃ : Type.{u6}} [_inst_3 : Semiring.{u1} R₁] [_inst_4 : Semiring.{u2} R₂] [_inst_5 : Semiring.{u3} R₃] [_inst_7 : AddCommMonoid.{u4} M₁] [_inst_8 : AddCommMonoid.{u5} M₂] [_inst_9 : AddCommMonoid.{u6} M₃] {module_M₁ : Module.{u1, u4} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u2, u5} R₂ M₂ _inst_4 _inst_8} {module_M₃ : Module.{u3, u6} R₃ M₃ _inst_5 _inst_9} {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₂₃ : RingHom.{u2, u3} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5)} {σ₁₃ : RingHom.{u1, u3} R₁ R₃ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5)} [_inst_10 : RingHomCompTriple.{u1, u2, u3} R₁ R₂ R₃ _inst_3 _inst_4 _inst_5 σ₁₂ σ₂₃ σ₁₃] {f : LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃} {g : LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂} {g' : LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂}, (Function.Injective.{succ u5, succ u6} M₂ M₃ (coeFn.{max (succ u5) (succ u6), max (succ u5) (succ u6)} (LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) (fun (_x : LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) => M₂ -> M₃) (LinearMap.hasCoeToFun.{u2, u3, u5, u6} R₂ R₃ M₂ M₃ _inst_4 _inst_5 _inst_8 _inst_9 module_M₂ module_M₃ σ₂₃) f)) -> (Iff (Eq.{max (succ u4) (succ u6)} (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_3 _inst_5 σ₁₃ M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃) (LinearMap.comp.{u1, u2, u3, u4, u5, u6} R₁ R₂ R₃ M₁ M₂ M₃ _inst_3 _inst_4 _inst_5 _inst_7 _inst_8 _inst_9 module_M₁ module_M₂ module_M₃ σ₁₂ σ₂₃ σ₁₃ _inst_10 f g) (LinearMap.comp.{u1, u2, u3, u4, u5, u6} R₁ R₂ R₃ M₁ M₂ M₃ _inst_3 _inst_4 _inst_5 _inst_7 _inst_8 _inst_9 module_M₁ module_M₂ module_M₃ σ₁₂ σ₂₃ σ₁₃ _inst_10 f g')) (Eq.{max (succ u4) (succ u5)} (LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) g g'))
but is expected to have type
  forall {R₁ : Type.{u1}} {R₂ : Type.{u4}} {R₃ : Type.{u3}} {M₁ : Type.{u2}} {M₂ : Type.{u6}} {M₃ : Type.{u5}} [_inst_3 : Semiring.{u1} R₁] [_inst_4 : Semiring.{u4} R₂] [_inst_5 : Semiring.{u3} R₃] [_inst_7 : AddCommMonoid.{u2} M₁] [_inst_8 : AddCommMonoid.{u6} M₂] [_inst_9 : AddCommMonoid.{u5} M₃] {module_M₁ : Module.{u1, u2} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u4, u6} R₂ M₂ _inst_4 _inst_8} {module_M₃ : Module.{u3, u5} R₃ M₃ _inst_5 _inst_9} {σ₁₂ : RingHom.{u1, u4} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u4} R₂ _inst_4)} {σ₂₃ : RingHom.{u4, u3} R₂ R₃ (Semiring.toNonAssocSemiring.{u4} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5)} {σ₁₃ : RingHom.{u1, u3} R₁ R₃ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5)} [_inst_10 : RingHomCompTriple.{u1, u4, u3} R₁ R₂ R₃ _inst_3 _inst_4 _inst_5 σ₁₂ σ₂₃ σ₁₃] {f : LinearMap.{u4, u3, u6, u5} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃} {g : LinearMap.{u1, u4, u2, u6} R₁ R₂ _inst_3 _inst_4 σ₁₂ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂} {g' : LinearMap.{u1, u4, u2, u6} R₁ R₂ _inst_3 _inst_4 σ₁₂ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂}, (Function.Injective.{succ u6, succ u5} M₂ M₃ (FunLike.coe.{max (succ u6) (succ u5), succ u6, succ u5} (LinearMap.{u4, u3, u6, u5} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) M₂ (fun (_x : M₂) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M₂) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u4, u3, u6, u5} R₂ R₃ M₂ M₃ _inst_4 _inst_5 _inst_8 _inst_9 module_M₂ module_M₃ σ₂₃) f)) -> (Iff (Eq.{max (succ u2) (succ u5)} (LinearMap.{u1, u3, u2, u5} R₁ R₃ _inst_3 _inst_5 σ₁₃ M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃) (LinearMap.comp.{u1, u4, u3, u2, u6, u5} R₁ R₂ R₃ M₁ M₂ M₃ _inst_3 _inst_4 _inst_5 _inst_7 _inst_8 _inst_9 module_M₁ module_M₂ module_M₃ σ₁₂ σ₂₃ σ₁₃ _inst_10 f g) (LinearMap.comp.{u1, u4, u3, u2, u6, u5} R₁ R₂ R₃ M₁ M₂ M₃ _inst_3 _inst_4 _inst_5 _inst_7 _inst_8 _inst_9 module_M₁ module_M₂ module_M₃ σ₁₂ σ₂₃ σ₁₃ _inst_10 f g')) (Eq.{max (succ u2) (succ u6)} (LinearMap.{u1, u4, u2, u6} R₁ R₂ _inst_3 _inst_4 σ₁₂ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) g g'))
Case conversion may be inaccurate. Consider using '#align linear_map.cancel_left LinearMap.cancel_leftₓ'. -/
theorem cancel_left (hf : Function.Injective f) : f.comp g = f.comp g' ↔ g = g' :=
  ⟨fun h => ext fun x => hf <| by rw [← comp_apply, h, comp_apply], fun h => h ▸ rfl⟩
#align linear_map.cancel_left LinearMap.cancel_left

omit σ₁₃

end

variable [AddCommMonoid M] [AddCommMonoid M₁] [AddCommMonoid M₂] [AddCommMonoid M₃]

/- warning: linear_map.inverse -> LinearMap.inverse is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_7 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_8 : Module.{u2, u4} S M₂ _inst_2 _inst_5] {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} [_inst_9 : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'] (f : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_3 _inst_5 _inst_7 _inst_8) (g : M₂ -> M), (Function.LeftInverse.{succ u3, succ u4} M M₂ g (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_3 _inst_5 _inst_7 _inst_8) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_3 _inst_5 _inst_7 _inst_8) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_7 _inst_8 σ) f)) -> (Function.RightInverse.{succ u3, succ u4} M M₂ g (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_3 _inst_5 _inst_7 _inst_8) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_3 _inst_5 _inst_7 _inst_8) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_7 _inst_8 σ) f)) -> (LinearMap.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' M₂ M _inst_5 _inst_3 _inst_8 _inst_7)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_7 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_8 : Module.{u2, u4} S M₂ _inst_2 _inst_5] {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} [_inst_9 : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'] (f : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_3 _inst_5 _inst_7 _inst_8) (g : M₂ -> M), (Function.LeftInverse.{succ u3, succ u4} M M₂ g (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_3 _inst_5 _inst_7 _inst_8) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_7 _inst_8 σ) f)) -> (Function.RightInverse.{succ u3, succ u4} M M₂ g (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_3 _inst_5 _inst_7 _inst_8) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_7 _inst_8 σ) f)) -> (LinearMap.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' M₂ M _inst_5 _inst_3 _inst_8 _inst_7)
Case conversion may be inaccurate. Consider using '#align linear_map.inverse LinearMap.inverseₓ'. -/
/-- If a function `g` is a left and right inverse of a linear map `f`, then `g` is linear itself. -/
def inverse [Module R M] [Module S M₂] {σ : R →+* S} {σ' : S →+* R} [RingHomInvPair σ σ']
    (f : M →ₛₗ[σ] M₂) (g : M₂ → M) (h₁ : LeftInverse g f) (h₂ : RightInverse g f) : M₂ →ₛₗ[σ'] M :=
  by
  dsimp [left_inverse, Function.RightInverse] at h₁ h₂ <;>
    exact
      { toFun := g
        map_add' := fun x y => by rw [← h₁ (g (x + y)), ← h₁ (g x + g y)] <;> simp [h₂]
        map_smul' := fun a b => by
          rw [← h₁ (g (a • b)), ← h₁ (σ' a • g b)]
          simp [h₂] }
#align linear_map.inverse LinearMap.inverse

end AddCommMonoid

section AddCommGroup

variable [Semiring R] [Semiring S] [AddCommGroup M] [AddCommGroup M₂]

variable {module_M : Module R M} {module_M₂ : Module S M₂} {σ : R →+* S}

variable (f : M →ₛₗ[σ] M₂)

/- warning: linear_map.map_neg -> LinearMap.map_neg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommGroup.{u3} M] [_inst_4 : AddCommGroup.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3)} {module_M₂ : Module.{u2, u4} S M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4)} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} (f : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) module_M module_M₂) (x : M), Eq.{succ u4} M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) module_M module_M₂) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) module_M module_M₂) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) module_M module_M₂ σ) f (Neg.neg.{u3} M (SubNegMonoid.toHasNeg.{u3} M (AddGroup.toSubNegMonoid.{u3} M (AddCommGroup.toAddGroup.{u3} M _inst_3))) x)) (Neg.neg.{u4} M₂ (SubNegMonoid.toHasNeg.{u4} M₂ (AddGroup.toSubNegMonoid.{u4} M₂ (AddCommGroup.toAddGroup.{u4} M₂ _inst_4))) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) module_M module_M₂) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) module_M module_M₂) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) module_M module_M₂ σ) f x))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_3 : AddCommGroup.{u3} M] [_inst_4 : AddCommGroup.{u4} M₂] {module_M : Module.{u2, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3)} {module_M₂ : Module.{u1, u4} S M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4)} {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} (f : LinearMap.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ M M₂ (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) module_M module_M₂) (x : M), Eq.{succ u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) (Neg.neg.{u3} M (NegZeroClass.toNeg.{u3} M (SubNegZeroMonoid.toNegZeroClass.{u3} M (SubtractionMonoid.toSubNegZeroMonoid.{u3} M (SubtractionCommMonoid.toSubtractionMonoid.{u3} M (AddCommGroup.toDivisionAddCommMonoid.{u3} M _inst_3))))) x)) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearMap.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ M M₂ (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) module_M module_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u2, u1, u3, u4} R S M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) module_M module_M₂ σ) f (Neg.neg.{u3} M (NegZeroClass.toNeg.{u3} M (SubNegZeroMonoid.toNegZeroClass.{u3} M (SubtractionMonoid.toSubNegZeroMonoid.{u3} M (SubtractionCommMonoid.toSubtractionMonoid.{u3} M (AddCommGroup.toDivisionAddCommMonoid.{u3} M _inst_3))))) x)) (Neg.neg.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (NegZeroClass.toNeg.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (SubNegZeroMonoid.toNegZeroClass.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (SubtractionMonoid.toSubNegZeroMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (SubtractionCommMonoid.toSubtractionMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (AddCommGroup.toDivisionAddCommMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) _inst_4))))) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearMap.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ M M₂ (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) module_M module_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u2, u1, u3, u4} R S M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) module_M module_M₂ σ) f x))
Case conversion may be inaccurate. Consider using '#align linear_map.map_neg LinearMap.map_negₓ'. -/
protected theorem map_neg (x : M) : f (-x) = -f x :=
  map_neg f x
#align linear_map.map_neg LinearMap.map_neg

/- warning: linear_map.map_sub -> LinearMap.map_sub is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommGroup.{u3} M] [_inst_4 : AddCommGroup.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3)} {module_M₂ : Module.{u2, u4} S M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4)} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} (f : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) module_M module_M₂) (x : M) (y : M), Eq.{succ u4} M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) module_M module_M₂) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) module_M module_M₂) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) module_M module_M₂ σ) f (HSub.hSub.{u3, u3, u3} M M M (instHSub.{u3} M (SubNegMonoid.toHasSub.{u3} M (AddGroup.toSubNegMonoid.{u3} M (AddCommGroup.toAddGroup.{u3} M _inst_3)))) x y)) (HSub.hSub.{u4, u4, u4} M₂ M₂ M₂ (instHSub.{u4} M₂ (SubNegMonoid.toHasSub.{u4} M₂ (AddGroup.toSubNegMonoid.{u4} M₂ (AddCommGroup.toAddGroup.{u4} M₂ _inst_4)))) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) module_M module_M₂) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) module_M module_M₂) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) module_M module_M₂ σ) f x) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) module_M module_M₂) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) module_M module_M₂) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) module_M module_M₂ σ) f y))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_3 : AddCommGroup.{u3} M] [_inst_4 : AddCommGroup.{u4} M₂] {module_M : Module.{u2, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3)} {module_M₂ : Module.{u1, u4} S M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4)} {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} (f : LinearMap.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ M M₂ (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) module_M module_M₂) (x : M) (y : M), Eq.{succ u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) (HSub.hSub.{u3, u3, u3} M M M (instHSub.{u3} M (SubNegMonoid.toSub.{u3} M (AddGroup.toSubNegMonoid.{u3} M (AddCommGroup.toAddGroup.{u3} M _inst_3)))) x y)) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearMap.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ M M₂ (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) module_M module_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u2, u1, u3, u4} R S M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) module_M module_M₂ σ) f (HSub.hSub.{u3, u3, u3} M M M (instHSub.{u3} M (SubNegMonoid.toSub.{u3} M (AddGroup.toSubNegMonoid.{u3} M (AddCommGroup.toAddGroup.{u3} M _inst_3)))) x y)) (HSub.hSub.{u4, u4, u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) y) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (instHSub.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (SubNegMonoid.toSub.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (AddGroup.toSubNegMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (AddCommGroup.toAddGroup.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) _inst_4)))) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearMap.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ M M₂ (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) module_M module_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u2, u1, u3, u4} R S M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) module_M module_M₂ σ) f x) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearMap.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ M M₂ (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) module_M module_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u2, u1, u3, u4} R S M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) module_M module_M₂ σ) f y))
Case conversion may be inaccurate. Consider using '#align linear_map.map_sub LinearMap.map_subₓ'. -/
protected theorem map_sub (x y : M) : f (x - y) = f x - f y :=
  map_sub f x y
#align linear_map.map_sub LinearMap.map_sub

#print LinearMap.CompatibleSMul.intModule /-
instance CompatibleSMul.intModule {S : Type _} [Semiring S] [Module S M] [Module S M₂] :
    CompatibleSMul M M₂ ℤ S :=
  ⟨fun fₗ c x => by
    induction c using Int.induction_on
    case hz => simp
    case hp n ih => simp [add_smul, ih]
    case hn n ih => simp [sub_smul, ih]⟩
#align linear_map.compatible_smul.int_module LinearMap.CompatibleSMul.intModule
-/

#print LinearMap.CompatibleSMul.units /-
instance CompatibleSMul.units {R S : Type _} [Monoid R] [MulAction R M] [MulAction R M₂]
    [Semiring S] [Module S M] [Module S M₂] [CompatibleSMul M M₂ R S] : CompatibleSMul M M₂ Rˣ S :=
  ⟨fun fₗ c x => (CompatibleSMul.map_smul fₗ (c : R) x : _)⟩
#align linear_map.compatible_smul.units LinearMap.CompatibleSMul.units
-/

end AddCommGroup

end LinearMap

namespace Module

#print Module.compHom.toLinearMap /-
/-- `g : R →+* S` is `R`-linear when the module structure on `S` is `module.comp_hom S g` . -/
@[simps]
def compHom.toLinearMap {R S : Type _} [Semiring R] [Semiring S] (g : R →+* S) :
    haveI := comp_hom S g
    R →ₗ[R] S
    where
  toFun := (g : R → S)
  map_add' := g.map_add
  map_smul' := g.map_mul
#align module.comp_hom.to_linear_map Module.compHom.toLinearMap
-/

end Module

namespace DistribMulActionHom

variable [Semiring R] [AddCommMonoid M] [AddCommMonoid M₂] [Module R M] [Module R M₂]

#print DistribMulActionHom.toLinearMap /-
/-- A `distrib_mul_action_hom` between two modules is a linear map. -/
def toLinearMap (fₗ : M →+[R] M₂) : M →ₗ[R] M₂ :=
  { fₗ with }
#align distrib_mul_action_hom.to_linear_map DistribMulActionHom.toLinearMap
-/

instance : Coe (M →+[R] M₂) (M →ₗ[R] M₂) :=
  ⟨toLinearMap⟩

/- warning: distrib_mul_action_hom.to_linear_map_eq_coe clashes with [anonymous] -> [anonymous]
warning: distrib_mul_action_hom.to_linear_map_eq_coe -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u_1}} {M : Type.{u_9}} {M₂ : Type.{u_11}} [_inst_1 : Semiring.{u_1} R] [_inst_2 : AddCommMonoid.{u_9} M] [_inst_3 : AddCommMonoid.{u_11} M₂] [_inst_4 : Module.{u_1, u_9} R M _inst_1 _inst_2] [_inst_5 : Module.{u_1, u_11} R M₂ _inst_1 _inst_3] (f : DistribMulActionHom.{u_1, u_9, u_11} R (MonoidWithZero.toMonoid.{u_1} R (Semiring.toMonoidWithZero.{u_1} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u_9} M _inst_2) (Module.toDistribMulAction.{u_1, u_9} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u_11} M₂ _inst_3) (Module.toDistribMulAction.{u_1, u_11} R M₂ _inst_1 _inst_3 _inst_5)), Eq.{max (succ u_9) (succ u_11)} (LinearMap.{u_1, u_1, u_9, u_11} R R _inst_1 _inst_1 (RingHom.id.{u_1} R (Semiring.toNonAssocSemiring.{u_1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_4 _inst_5) (DistribMulActionHom.toLinearMap.{u_1, u_9, u_11} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 f) ((fun (a : Sort.{max (succ u_9) (succ u_11)}) (b : Sort.{max (succ u_9) (succ u_11)}) [self : HasLiftT.{max (succ u_9) (succ u_11), max (succ u_9) (succ u_11)} a b] => self.0) (DistribMulActionHom.{u_1, u_9, u_11} R (MonoidWithZero.toMonoid.{u_1} R (Semiring.toMonoidWithZero.{u_1} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u_9} M _inst_2) (Module.toDistribMulAction.{u_1, u_9} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u_11} M₂ _inst_3) (Module.toDistribMulAction.{u_1, u_11} R M₂ _inst_1 _inst_3 _inst_5)) (LinearMap.{u_1, u_1, u_9, u_11} R R _inst_1 _inst_1 (RingHom.id.{u_1} R (Semiring.toNonAssocSemiring.{u_1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_4 _inst_5) (HasLiftT.mk.{max (succ u_9) (succ u_11), max (succ u_9) (succ u_11)} (DistribMulActionHom.{u_1, u_9, u_11} R (MonoidWithZero.toMonoid.{u_1} R (Semiring.toMonoidWithZero.{u_1} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u_9} M _inst_2) (Module.toDistribMulAction.{u_1, u_9} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u_11} M₂ _inst_3) (Module.toDistribMulAction.{u_1, u_11} R M₂ _inst_1 _inst_3 _inst_5)) (LinearMap.{u_1, u_1, u_9, u_11} R R _inst_1 _inst_1 (RingHom.id.{u_1} R (Semiring.toNonAssocSemiring.{u_1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_4 _inst_5) (CoeTCₓ.coe.{max (succ u_9) (succ u_11), max (succ u_9) (succ u_11)} (DistribMulActionHom.{u_1, u_9, u_11} R (MonoidWithZero.toMonoid.{u_1} R (Semiring.toMonoidWithZero.{u_1} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u_9} M _inst_2) (Module.toDistribMulAction.{u_1, u_9} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u_11} M₂ _inst_3) (Module.toDistribMulAction.{u_1, u_11} R M₂ _inst_1 _inst_3 _inst_5)) (LinearMap.{u_1, u_1, u_9, u_11} R R _inst_1 _inst_1 (RingHom.id.{u_1} R (Semiring.toNonAssocSemiring.{u_1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_4 _inst_5) (coeBase.{max (succ u_9) (succ u_11), max (succ u_9) (succ u_11)} (DistribMulActionHom.{u_1, u_9, u_11} R (MonoidWithZero.toMonoid.{u_1} R (Semiring.toMonoidWithZero.{u_1} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u_9} M _inst_2) (Module.toDistribMulAction.{u_1, u_9} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u_11} M₂ _inst_3) (Module.toDistribMulAction.{u_1, u_11} R M₂ _inst_1 _inst_3 _inst_5)) (LinearMap.{u_1, u_1, u_9, u_11} R R _inst_1 _inst_1 (RingHom.id.{u_1} R (Semiring.toNonAssocSemiring.{u_1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_4 _inst_5) (DistribMulActionHom.LinearMap.hasCoe.{u_1, u_9, u_11} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)))) f)
but is expected to have type
  forall {R : Type.{u}} {M : Type.{v}}, (Nat -> R -> M) -> Nat -> (List.{u} R) -> (List.{v} M)
Case conversion may be inaccurate. Consider using '#align distrib_mul_action_hom.to_linear_map_eq_coe [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] (f : M →+[R] M₂) : f.toLinearMap = ↑f :=
  rfl
#align distrib_mul_action_hom.to_linear_map_eq_coe [anonymous]

/- warning: distrib_mul_action_hom.coe_to_linear_map -> DistribMulActionHom.coe_toLinearMap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3] (f : DistribMulActionHom.{u1, u2, u3} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5)), Eq.{max (succ u2) (succ u3)} ((fun (_x : LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_4 _inst_5) => M -> M₂) ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u2) (succ u3)} a b] => self.0) (DistribMulActionHom.{u1, u2, u3} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5)) (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_4 _inst_5) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5)) (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_4 _inst_5) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5)) (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_4 _inst_5) (coeBase.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5)) (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_4 _inst_5) (DistribMulActionHom.LinearMap.hasCoe.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)))) f)) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_4 _inst_5) (fun (_x : LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_4 _inst_5) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u2) (succ u3)} a b] => self.0) (DistribMulActionHom.{u1, u2, u3} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5)) (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_4 _inst_5) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5)) (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_4 _inst_5) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5)) (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_4 _inst_5) (coeBase.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5)) (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_4 _inst_5) (DistribMulActionHom.LinearMap.hasCoe.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)))) f)) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5)) (fun (_x : DistribMulActionHom.{u1, u2, u3} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5)) => M -> M₂) ([anonymous].{u1, u2, u3} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5)) f)
but is expected to have type
  forall {R : Type.{u3}} {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u1} M₂] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u3, u1} R M₂ _inst_1 _inst_3] (f : DistribMulActionHom.{u3, u2, u1} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u3, u2} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_3) (Module.toDistribMulAction.{u3, u1} R M₂ _inst_1 _inst_3 _inst_5)), Eq.{max (succ u2) (succ u1)} (forall (a : M), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_4 _inst_5) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u2, u1} R R M M₂ _inst_1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (DistribMulActionHom.toLinearMap.{u3, u2, u1} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (DistribMulActionHom.{u3, u2, u1} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u3, u2} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_3) (Module.toDistribMulAction.{u3, u1} R M₂ _inst_1 _inst_3 _inst_5)) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M) => M₂) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u3, u2} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_3) (Module.toDistribMulAction.{u3, u1} R M₂ _inst_1 _inst_3 _inst_5)) R M M₂ (SMulZeroClass.toSMul.{u3, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribSMul.toSMulZeroClass.{u3, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u3, u2} R M (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u3, u2} R M _inst_1 _inst_2 _inst_4)))) (SMulZeroClass.toSMul.{u3, u1} R M₂ (AddMonoid.toZero.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_3)) (DistribSMul.toSMulZeroClass.{u3, u1} R M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_3)) (DistribMulAction.toDistribSMul.{u3, u1} R M₂ (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_3) (Module.toDistribMulAction.{u3, u1} R M₂ _inst_1 _inst_3 _inst_5)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u3, u2} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_3) (Module.toDistribMulAction.{u3, u1} R M₂ _inst_1 _inst_3 _inst_5)) R M M₂ (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_3) (Module.toDistribMulAction.{u3, u2} R M _inst_1 _inst_2 _inst_4) (Module.toDistribMulAction.{u3, u1} R M₂ _inst_1 _inst_3 _inst_5) (DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom.{u3, u2, u1} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u3, u2} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_3) (Module.toDistribMulAction.{u3, u1} R M₂ _inst_1 _inst_3 _inst_5)))) f)
Case conversion may be inaccurate. Consider using '#align distrib_mul_action_hom.coe_to_linear_map DistribMulActionHom.coe_toLinearMapₓ'. -/
@[simp, norm_cast]
theorem coe_toLinearMap (f : M →+[R] M₂) : ((f : M →ₗ[R] M₂) : M → M₂) = f :=
  rfl
#align distrib_mul_action_hom.coe_to_linear_map DistribMulActionHom.coe_toLinearMap

/- warning: distrib_mul_action_hom.to_linear_map_injective -> DistribMulActionHom.toLinearMap_injective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3] {f : DistribMulActionHom.{u1, u2, u3} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5)} {g : DistribMulActionHom.{u1, u2, u3} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5)}, (Eq.{max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_4 _inst_5) ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u2) (succ u3)} a b] => self.0) (DistribMulActionHom.{u1, u2, u3} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5)) (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_4 _inst_5) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5)) (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_4 _inst_5) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5)) (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_4 _inst_5) (coeBase.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5)) (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_4 _inst_5) (DistribMulActionHom.LinearMap.hasCoe.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)))) f) ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u2) (succ u3)} a b] => self.0) (DistribMulActionHom.{u1, u2, u3} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5)) (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_4 _inst_5) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5)) (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_4 _inst_5) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5)) (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_4 _inst_5) (coeBase.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5)) (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_4 _inst_5) (DistribMulActionHom.LinearMap.hasCoe.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)))) g)) -> (Eq.{max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5)) f g)
but is expected to have type
  forall {R : Type.{u3}} {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u1} M₂] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u3, u1} R M₂ _inst_1 _inst_3] {f : DistribMulActionHom.{u3, u2, u1} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u3, u2} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_3) (Module.toDistribMulAction.{u3, u1} R M₂ _inst_1 _inst_3 _inst_5)} {g : DistribMulActionHom.{u3, u2, u1} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u3, u2} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_3) (Module.toDistribMulAction.{u3, u1} R M₂ _inst_1 _inst_3 _inst_5)}, (Eq.{max (succ u2) (succ u1)} (LinearMap.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_4 _inst_5) (DistribMulActionHom.toLinearMap.{u3, u2, u1} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 f) (DistribMulActionHom.toLinearMap.{u3, u2, u1} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 g)) -> (Eq.{max (succ u2) (succ u1)} (DistribMulActionHom.{u3, u2, u1} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u3, u2} R M _inst_1 _inst_2 _inst_4) M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_3) (Module.toDistribMulAction.{u3, u1} R M₂ _inst_1 _inst_3 _inst_5)) f g)
Case conversion may be inaccurate. Consider using '#align distrib_mul_action_hom.to_linear_map_injective DistribMulActionHom.toLinearMap_injectiveₓ'. -/
theorem toLinearMap_injective {f g : M →+[R] M₂} (h : (f : M →ₗ[R] M₂) = (g : M →ₗ[R] M₂)) :
    f = g := by
  ext m
  exact LinearMap.congr_fun h m
#align distrib_mul_action_hom.to_linear_map_injective DistribMulActionHom.toLinearMap_injective

end DistribMulActionHom

namespace IsLinearMap

section AddCommMonoid

variable [Semiring R] [AddCommMonoid M] [AddCommMonoid M₂]

variable [Module R M] [Module R M₂]

include R

#print IsLinearMap.mk' /-
/-- Convert an `is_linear_map` predicate to a `linear_map` -/
def mk' (f : M → M₂) (H : IsLinearMap R f) : M →ₗ[R] M₂
    where
  toFun := f
  map_add' := H.1
  map_smul' := H.2
#align is_linear_map.mk' IsLinearMap.mk'
-/

/- warning: is_linear_map.mk'_apply -> IsLinearMap.mk'_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3] {f : M -> M₂} (H : IsLinearMap.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 f) (x : M), Eq.{succ u3} M₂ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_4 _inst_5) (fun (_x : LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_4 _inst_5) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (IsLinearMap.mk'.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 f H) x) (f x)
but is expected to have type
  forall {R : Type.{u3}} {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u1} M₂] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u3, u1} R M₂ _inst_1 _inst_3] {f : M -> M₂} (H : IsLinearMap.{u3, u2, u1} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 f) (x : M), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_4 _inst_5) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u2, u1} R R M M₂ _inst_1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (IsLinearMap.mk'.{u3, u2, u1} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 f H) x) (f x)
Case conversion may be inaccurate. Consider using '#align is_linear_map.mk'_apply IsLinearMap.mk'_applyₓ'. -/
@[simp]
theorem mk'_apply {f : M → M₂} (H : IsLinearMap R f) (x : M) : mk' f H x = f x :=
  rfl
#align is_linear_map.mk'_apply IsLinearMap.mk'_apply

/- warning: is_linear_map.is_linear_map_smul -> IsLinearMap.isLinearMap_smul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_6 : CommSemiring.{u1} R] [_inst_7 : AddCommMonoid.{u2} M] [_inst_8 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_6) _inst_7] (c : R), IsLinearMap.{u1, u2, u2} R M M (CommSemiring.toSemiring.{u1} R _inst_6) _inst_7 _inst_7 _inst_8 _inst_8 (fun (z : M) => SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_7))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_6))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_7))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_6)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_7))) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_6) _inst_7 _inst_8)))) c z)
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_6 : CommSemiring.{u2} R] [_inst_7 : AddCommMonoid.{u1} M] [_inst_8 : Module.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_6) _inst_7] (c : R), IsLinearMap.{u2, u1, u1} R M M (CommSemiring.toSemiring.{u2} R _inst_6) _inst_7 _inst_7 _inst_8 _inst_8 (fun (z : M) => HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_7)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R _inst_6)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_7)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_6)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_7)) (Module.toMulActionWithZero.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_6) _inst_7 _inst_8))))) c z)
Case conversion may be inaccurate. Consider using '#align is_linear_map.is_linear_map_smul IsLinearMap.isLinearMap_smulₓ'. -/
theorem isLinearMap_smul {R M : Type _} [CommSemiring R] [AddCommMonoid M] [Module R M] (c : R) :
    IsLinearMap R fun z : M => c • z :=
  by
  refine' IsLinearMap.mk (smul_add c) _
  intro _ _
  simp only [smul_smul, mul_comm]
#align is_linear_map.is_linear_map_smul IsLinearMap.isLinearMap_smul

/- warning: is_linear_map.is_linear_map_smul' -> IsLinearMap.isLinearMap_smul' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_6 : Semiring.{u1} R] [_inst_7 : AddCommMonoid.{u2} M] [_inst_8 : Module.{u1, u2} R M _inst_6 _inst_7] (a : M), IsLinearMap.{u1, u1, u2} R R M _inst_6 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_6))) _inst_7 (Semiring.toModule.{u1} R _inst_6) _inst_8 (fun (c : R) => SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_7))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_6)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_7))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_6) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_7))) (Module.toMulActionWithZero.{u1, u2} R M _inst_6 _inst_7 _inst_8)))) c a)
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_6 : Semiring.{u2} R] [_inst_7 : AddCommMonoid.{u1} M] [_inst_8 : Module.{u2, u1} R M _inst_6 _inst_7] (a : M), IsLinearMap.{u2, u2, u1} R R M _inst_6 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_6))) _inst_7 (Semiring.toModule.{u2} R _inst_6) _inst_8 (fun (c : R) => HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_7)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_6)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_7)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_6) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_7)) (Module.toMulActionWithZero.{u2, u1} R M _inst_6 _inst_7 _inst_8))))) c a)
Case conversion may be inaccurate. Consider using '#align is_linear_map.is_linear_map_smul' IsLinearMap.isLinearMap_smul'ₓ'. -/
theorem isLinearMap_smul' {R M : Type _} [Semiring R] [AddCommMonoid M] [Module R M] (a : M) :
    IsLinearMap R fun c : R => c • a :=
  IsLinearMap.mk (fun x y => add_smul x y a) fun x y => mul_smul x y a
#align is_linear_map.is_linear_map_smul' IsLinearMap.isLinearMap_smul'

variable {f : M → M₂} (lin : IsLinearMap R f)

include M M₂ lin

/- warning: is_linear_map.map_zero -> IsLinearMap.map_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3] {f : M -> M₂}, (IsLinearMap.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 f) -> (Eq.{succ u3} M₂ (f (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))))) (OfNat.ofNat.{u3} M₂ 0 (OfNat.mk.{u3} M₂ 0 (Zero.zero.{u3} M₂ (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))))))
but is expected to have type
  forall {R : Type.{u3}} {M : Type.{u1}} {M₂ : Type.{u2}} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : AddCommMonoid.{u2} M₂] [_inst_4 : Module.{u3, u1} R M _inst_1 _inst_2] [_inst_5 : Module.{u3, u2} R M₂ _inst_1 _inst_3] {f : M -> M₂}, (IsLinearMap.{u3, u1, u2} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 f) -> (Eq.{succ u2} M₂ (f (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))))) (OfNat.ofNat.{u2} M₂ 0 (Zero.toOfNat0.{u2} M₂ (AddMonoid.toZero.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_3)))))
Case conversion may be inaccurate. Consider using '#align is_linear_map.map_zero IsLinearMap.map_zeroₓ'. -/
theorem map_zero : f (0 : M) = (0 : M₂) :=
  (lin.mk' f).map_zero
#align is_linear_map.map_zero IsLinearMap.map_zero

end AddCommMonoid

section AddCommGroup

variable [Semiring R] [AddCommGroup M] [AddCommGroup M₂]

variable [Module R M] [Module R M₂]

include R

/- warning: is_linear_map.is_linear_map_neg -> IsLinearMap.isLinearMap_neg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)], IsLinearMap.{u1, u2, u2} R M M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_4 _inst_4 (fun (z : M) => Neg.neg.{u2} M (SubNegMonoid.toHasNeg.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))) z)
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)], IsLinearMap.{u2, u1, u1} R M M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_4 _inst_4 (fun (z : M) => Neg.neg.{u1} M (NegZeroClass.toNeg.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) z)
Case conversion may be inaccurate. Consider using '#align is_linear_map.is_linear_map_neg IsLinearMap.isLinearMap_negₓ'. -/
theorem isLinearMap_neg : IsLinearMap R fun z : M => -z :=
  IsLinearMap.mk neg_add fun x y => (smul_neg x y).symm
#align is_linear_map.is_linear_map_neg IsLinearMap.isLinearMap_neg

variable {f : M → M₂} (lin : IsLinearMap R f)

include M M₂ lin

/- warning: is_linear_map.map_neg -> IsLinearMap.map_neg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : AddCommGroup.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_3)] {f : M -> M₂}, (IsLinearMap.{u1, u2, u3} R M M₂ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_3) _inst_4 _inst_5 f) -> (forall (x : M), Eq.{succ u3} M₂ (f (Neg.neg.{u2} M (SubNegMonoid.toHasNeg.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))) x)) (Neg.neg.{u3} M₂ (SubNegMonoid.toHasNeg.{u3} M₂ (AddGroup.toSubNegMonoid.{u3} M₂ (AddCommGroup.toAddGroup.{u3} M₂ _inst_3))) (f x)))
but is expected to have type
  forall {R : Type.{u3}} {M : Type.{u1}} {M₂ : Type.{u2}} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_3 : AddCommGroup.{u2} M₂] [_inst_4 : Module.{u3, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] [_inst_5 : Module.{u3, u2} R M₂ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_3)] {f : M -> M₂}, (IsLinearMap.{u3, u1, u2} R M M₂ _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_3) _inst_4 _inst_5 f) -> (forall (x : M), Eq.{succ u2} M₂ (f (Neg.neg.{u1} M (NegZeroClass.toNeg.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) x)) (Neg.neg.{u2} M₂ (NegZeroClass.toNeg.{u2} M₂ (SubNegZeroMonoid.toNegZeroClass.{u2} M₂ (SubtractionMonoid.toSubNegZeroMonoid.{u2} M₂ (SubtractionCommMonoid.toSubtractionMonoid.{u2} M₂ (AddCommGroup.toDivisionAddCommMonoid.{u2} M₂ _inst_3))))) (f x)))
Case conversion may be inaccurate. Consider using '#align is_linear_map.map_neg IsLinearMap.map_negₓ'. -/
theorem map_neg (x : M) : f (-x) = -f x :=
  (lin.mk' f).map_neg x
#align is_linear_map.map_neg IsLinearMap.map_neg

/- warning: is_linear_map.map_sub -> IsLinearMap.map_sub is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : AddCommGroup.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_3)] {f : M -> M₂}, (IsLinearMap.{u1, u2, u3} R M M₂ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_3) _inst_4 _inst_5 f) -> (forall (x : M) (y : M), Eq.{succ u3} M₂ (f (HSub.hSub.{u2, u2, u2} M M M (instHSub.{u2} M (SubNegMonoid.toHasSub.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))) x y)) (HSub.hSub.{u3, u3, u3} M₂ M₂ M₂ (instHSub.{u3} M₂ (SubNegMonoid.toHasSub.{u3} M₂ (AddGroup.toSubNegMonoid.{u3} M₂ (AddCommGroup.toAddGroup.{u3} M₂ _inst_3)))) (f x) (f y)))
but is expected to have type
  forall {R : Type.{u3}} {M : Type.{u1}} {M₂ : Type.{u2}} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_3 : AddCommGroup.{u2} M₂] [_inst_4 : Module.{u3, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] [_inst_5 : Module.{u3, u2} R M₂ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_3)] {f : M -> M₂}, (IsLinearMap.{u3, u1, u2} R M M₂ _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_3) _inst_4 _inst_5 f) -> (forall (x : M) (y : M), Eq.{succ u2} M₂ (f (HSub.hSub.{u1, u1, u1} M M M (instHSub.{u1} M (SubNegMonoid.toSub.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2)))) x y)) (HSub.hSub.{u2, u2, u2} M₂ M₂ M₂ (instHSub.{u2} M₂ (SubNegMonoid.toSub.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_3)))) (f x) (f y)))
Case conversion may be inaccurate. Consider using '#align is_linear_map.map_sub IsLinearMap.map_subₓ'. -/
theorem map_sub (x y) : f (x - y) = f x - f y :=
  (lin.mk' f).map_sub x y
#align is_linear_map.map_sub IsLinearMap.map_sub

end AddCommGroup

end IsLinearMap

#print Module.End /-
/-- Linear endomorphisms of a module, with associated ring structure
`module.End.semiring` and algebra structure `module.End.algebra`. -/
abbrev Module.End (R : Type u) (M : Type v) [Semiring R] [AddCommMonoid M] [Module R M] :=
  M →ₗ[R] M
#align module.End Module.End
-/

#print AddMonoidHom.toNatLinearMap /-
/-- Reinterpret an additive homomorphism as a `ℕ`-linear map. -/
def AddMonoidHom.toNatLinearMap [AddCommMonoid M] [AddCommMonoid M₂] (f : M →+ M₂) : M →ₗ[ℕ] M₂
    where
  toFun := f
  map_add' := f.map_add
  map_smul' := map_nsmul f
#align add_monoid_hom.to_nat_linear_map AddMonoidHom.toNatLinearMap
-/

/- warning: add_monoid_hom.to_nat_linear_map_injective -> AddMonoidHom.toNatLinearMap_injective is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {M₂ : Type.{u2}} [_inst_1 : AddCommMonoid.{u1} M] [_inst_2 : AddCommMonoid.{u2} M₂], Function.Injective.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} M M₂ (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)) (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_2))) (LinearMap.{0, 0, u1, u2} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) M M₂ _inst_1 _inst_2 (AddCommMonoid.natModule.{u1} M _inst_1) (AddCommMonoid.natModule.{u2} M₂ _inst_2)) (AddMonoidHom.toNatLinearMap.{u1, u2} M M₂ _inst_1 _inst_2)
but is expected to have type
  forall {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_1 : AddCommMonoid.{u2} M] [_inst_2 : AddCommMonoid.{u1} M₂], Function.Injective.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (AddMonoidHom.{u2, u1} M M₂ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_2))) (LinearMap.{0, 0, u2, u1} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) M M₂ _inst_1 _inst_2 (AddCommMonoid.natModule.{u2} M _inst_1) (AddCommMonoid.natModule.{u1} M₂ _inst_2)) (AddMonoidHom.toNatLinearMap.{u2, u1} M M₂ _inst_1 _inst_2)
Case conversion may be inaccurate. Consider using '#align add_monoid_hom.to_nat_linear_map_injective AddMonoidHom.toNatLinearMap_injectiveₓ'. -/
theorem AddMonoidHom.toNatLinearMap_injective [AddCommMonoid M] [AddCommMonoid M₂] :
    Function.Injective (@AddMonoidHom.toNatLinearMap M M₂ _ _) :=
  by
  intro f g h
  ext
  exact LinearMap.congr_fun h x
#align add_monoid_hom.to_nat_linear_map_injective AddMonoidHom.toNatLinearMap_injective

/- warning: add_monoid_hom.to_int_linear_map -> AddMonoidHom.toIntLinearMap is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {M₂ : Type.{u2}} [_inst_1 : AddCommGroup.{u1} M] [_inst_2 : AddCommGroup.{u2} M₂], (AddMonoidHom.{u1, u2} M M₂ (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))) (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2))))) -> (LinearMap.{0, 0, u1, u2} Int Int Int.semiring Int.semiring (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) M M₂ (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2) (AddCommGroup.intModule.{u1} M _inst_1) (AddCommGroup.intModule.{u2} M₂ _inst_2))
but is expected to have type
  forall {M : Type.{u1}} {M₂ : Type.{u2}} [_inst_1 : AddCommGroup.{u1} M] [_inst_2 : AddCommGroup.{u2} M₂], (AddMonoidHom.{u1, u2} M M₂ (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))) (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2))))) -> (LinearMap.{0, 0, u1, u2} Int Int Int.instSemiringInt Int.instSemiringInt (RingHom.id.{0} Int (NonAssocRing.toNonAssocSemiring.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt))) M M₂ (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2) (AddCommGroup.intModule.{u1} M _inst_1) (AddCommGroup.intModule.{u2} M₂ _inst_2))
Case conversion may be inaccurate. Consider using '#align add_monoid_hom.to_int_linear_map AddMonoidHom.toIntLinearMapₓ'. -/
/-- Reinterpret an additive homomorphism as a `ℤ`-linear map. -/
def AddMonoidHom.toIntLinearMap [AddCommGroup M] [AddCommGroup M₂] (f : M →+ M₂) : M →ₗ[ℤ] M₂
    where
  toFun := f
  map_add' := f.map_add
  map_smul' := map_zsmul f
#align add_monoid_hom.to_int_linear_map AddMonoidHom.toIntLinearMap

/- warning: add_monoid_hom.to_int_linear_map_injective -> AddMonoidHom.toIntLinearMap_injective is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {M₂ : Type.{u2}} [_inst_1 : AddCommGroup.{u1} M] [_inst_2 : AddCommGroup.{u2} M₂], Function.Injective.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} M M₂ (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))) (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2))))) (LinearMap.{0, 0, u1, u2} Int Int Int.semiring Int.semiring (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) M M₂ (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2) (AddCommGroup.intModule.{u1} M _inst_1) (AddCommGroup.intModule.{u2} M₂ _inst_2)) (AddMonoidHom.toIntLinearMap.{u1, u2} M M₂ _inst_1 _inst_2)
but is expected to have type
  forall {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_1 : AddCommGroup.{u2} M] [_inst_2 : AddCommGroup.{u1} M₂], Function.Injective.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (AddMonoidHom.{u2, u1} M M₂ (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_1)))) (AddMonoid.toAddZeroClass.{u1} M₂ (SubNegMonoid.toAddMonoid.{u1} M₂ (AddGroup.toSubNegMonoid.{u1} M₂ (AddCommGroup.toAddGroup.{u1} M₂ _inst_2))))) (LinearMap.{0, 0, u2, u1} Int Int Int.instSemiringInt Int.instSemiringInt (RingHom.id.{0} Int (NonAssocRing.toNonAssocSemiring.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt))) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_2) (AddCommGroup.intModule.{u2} M _inst_1) (AddCommGroup.intModule.{u1} M₂ _inst_2)) (AddMonoidHom.toIntLinearMap.{u2, u1} M M₂ _inst_1 _inst_2)
Case conversion may be inaccurate. Consider using '#align add_monoid_hom.to_int_linear_map_injective AddMonoidHom.toIntLinearMap_injectiveₓ'. -/
theorem AddMonoidHom.toIntLinearMap_injective [AddCommGroup M] [AddCommGroup M₂] :
    Function.Injective (@AddMonoidHom.toIntLinearMap M M₂ _ _) :=
  by
  intro f g h
  ext
  exact LinearMap.congr_fun h x
#align add_monoid_hom.to_int_linear_map_injective AddMonoidHom.toIntLinearMap_injective

/- warning: add_monoid_hom.coe_to_int_linear_map -> AddMonoidHom.coe_toIntLinearMap is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {M₂ : Type.{u2}} [_inst_1 : AddCommGroup.{u1} M] [_inst_2 : AddCommGroup.{u2} M₂] (f : AddMonoidHom.{u1, u2} M M₂ (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))) (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2))))), Eq.{max (succ u1) (succ u2)} (M -> M₂) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{0, 0, u1, u2} Int Int Int.semiring Int.semiring (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) M M₂ (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2) (AddCommGroup.intModule.{u1} M _inst_1) (AddCommGroup.intModule.{u2} M₂ _inst_2)) (fun (_x : LinearMap.{0, 0, u1, u2} Int Int Int.semiring Int.semiring (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) M M₂ (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2) (AddCommGroup.intModule.{u1} M _inst_1) (AddCommGroup.intModule.{u2} M₂ _inst_2)) => M -> M₂) (LinearMap.hasCoeToFun.{0, 0, u1, u2} Int Int M M₂ Int.semiring Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2) (AddCommGroup.intModule.{u1} M _inst_1) (AddCommGroup.intModule.{u2} M₂ _inst_2) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring))) (AddMonoidHom.toIntLinearMap.{u1, u2} M M₂ _inst_1 _inst_2 f)) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} M M₂ (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))) (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2))))) (fun (_x : AddMonoidHom.{u1, u2} M M₂ (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))) (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2))))) => M -> M₂) (AddMonoidHom.hasCoeToFun.{u1, u2} M M₂ (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))) (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2))))) f)
but is expected to have type
  forall {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_1 : AddCommGroup.{u2} M] [_inst_2 : AddCommGroup.{u1} M₂] (f : AddMonoidHom.{u2, u1} M M₂ (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_1)))) (AddMonoid.toAddZeroClass.{u1} M₂ (SubNegMonoid.toAddMonoid.{u1} M₂ (AddGroup.toSubNegMonoid.{u1} M₂ (AddCommGroup.toAddGroup.{u1} M₂ _inst_2))))), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : M), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{0, 0, u2, u1} Int Int Int.instSemiringInt Int.instSemiringInt (RingHom.id.{0} Int (NonAssocRing.toNonAssocSemiring.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt))) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_2) (AddCommGroup.intModule.{u2} M _inst_1) (AddCommGroup.intModule.{u1} M₂ _inst_2)) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{0, 0, u2, u1} Int Int M M₂ Int.instSemiringInt Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_2) (AddCommGroup.intModule.{u2} M _inst_1) (AddCommGroup.intModule.{u1} M₂ _inst_2) (RingHom.id.{0} Int (NonAssocRing.toNonAssocSemiring.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt)))) (AddMonoidHom.toIntLinearMap.{u2, u1} M M₂ _inst_1 _inst_2 f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AddMonoidHom.{u2, u1} M M₂ (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_1)))) (AddMonoid.toAddZeroClass.{u1} M₂ (SubNegMonoid.toAddMonoid.{u1} M₂ (AddGroup.toSubNegMonoid.{u1} M₂ (AddCommGroup.toAddGroup.{u1} M₂ _inst_2))))) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) _x) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} M M₂ (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_1)))) (AddMonoid.toAddZeroClass.{u1} M₂ (SubNegMonoid.toAddMonoid.{u1} M₂ (AddGroup.toSubNegMonoid.{u1} M₂ (AddCommGroup.toAddGroup.{u1} M₂ _inst_2))))) M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_1))))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (SubNegMonoid.toAddMonoid.{u1} M₂ (AddGroup.toSubNegMonoid.{u1} M₂ (AddCommGroup.toAddGroup.{u1} M₂ _inst_2))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} M M₂ (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_1)))) (AddMonoid.toAddZeroClass.{u1} M₂ (SubNegMonoid.toAddMonoid.{u1} M₂ (AddGroup.toSubNegMonoid.{u1} M₂ (AddCommGroup.toAddGroup.{u1} M₂ _inst_2))))) M M₂ (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_1)))) (AddMonoid.toAddZeroClass.{u1} M₂ (SubNegMonoid.toAddMonoid.{u1} M₂ (AddGroup.toSubNegMonoid.{u1} M₂ (AddCommGroup.toAddGroup.{u1} M₂ _inst_2)))) (AddMonoidHom.addMonoidHomClass.{u2, u1} M M₂ (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_1)))) (AddMonoid.toAddZeroClass.{u1} M₂ (SubNegMonoid.toAddMonoid.{u1} M₂ (AddGroup.toSubNegMonoid.{u1} M₂ (AddCommGroup.toAddGroup.{u1} M₂ _inst_2))))))) f)
Case conversion may be inaccurate. Consider using '#align add_monoid_hom.coe_to_int_linear_map AddMonoidHom.coe_toIntLinearMapₓ'. -/
@[simp]
theorem AddMonoidHom.coe_toIntLinearMap [AddCommGroup M] [AddCommGroup M₂] (f : M →+ M₂) :
    ⇑f.toIntLinearMap = f :=
  rfl
#align add_monoid_hom.coe_to_int_linear_map AddMonoidHom.coe_toIntLinearMap

#print AddMonoidHom.toRatLinearMap /-
/-- Reinterpret an additive homomorphism as a `ℚ`-linear map. -/
def AddMonoidHom.toRatLinearMap [AddCommGroup M] [Module ℚ M] [AddCommGroup M₂] [Module ℚ M₂]
    (f : M →+ M₂) : M →ₗ[ℚ] M₂ :=
  { f with map_smul' := map_rat_smul f }
#align add_monoid_hom.to_rat_linear_map AddMonoidHom.toRatLinearMap
-/

/- warning: add_monoid_hom.to_rat_linear_map_injective -> AddMonoidHom.toRatLinearMap_injective is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {M₂ : Type.{u2}} [_inst_1 : AddCommGroup.{u1} M] [_inst_2 : Module.{0, u1} Rat M Rat.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1)] [_inst_3 : AddCommGroup.{u2} M₂] [_inst_4 : Module.{0, u2} Rat M₂ Rat.semiring (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_3)], Function.Injective.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} M M₂ (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))) (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_3))))) (LinearMap.{0, 0, u1, u2} Rat Rat Rat.semiring Rat.semiring (RingHom.id.{0} Rat (Semiring.toNonAssocSemiring.{0} Rat Rat.semiring)) M M₂ (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_3) _inst_2 _inst_4) (AddMonoidHom.toRatLinearMap.{u1, u2} M M₂ _inst_1 _inst_2 _inst_3 _inst_4)
but is expected to have type
  forall {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_1 : AddCommGroup.{u2} M] [_inst_2 : Module.{0, u2} Rat M Rat.semiring (AddCommGroup.toAddCommMonoid.{u2} M _inst_1)] [_inst_3 : AddCommGroup.{u1} M₂] [_inst_4 : Module.{0, u1} Rat M₂ Rat.semiring (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_3)], Function.Injective.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (AddMonoidHom.{u2, u1} M M₂ (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_1)))) (AddMonoid.toAddZeroClass.{u1} M₂ (SubNegMonoid.toAddMonoid.{u1} M₂ (AddGroup.toSubNegMonoid.{u1} M₂ (AddCommGroup.toAddGroup.{u1} M₂ _inst_3))))) (LinearMap.{0, 0, u2, u1} Rat Rat Rat.semiring Rat.semiring (RingHom.id.{0} Rat (NonAssocRing.toNonAssocSemiring.{0} Rat (Ring.toNonAssocRing.{0} Rat (StrictOrderedRing.toRing.{0} Rat (LinearOrderedRing.toStrictOrderedRing.{0} Rat Rat.instLinearOrderedRingRat))))) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_3) _inst_2 _inst_4) (AddMonoidHom.toRatLinearMap.{u2, u1} M M₂ _inst_1 _inst_2 _inst_3 _inst_4)
Case conversion may be inaccurate. Consider using '#align add_monoid_hom.to_rat_linear_map_injective AddMonoidHom.toRatLinearMap_injectiveₓ'. -/
theorem AddMonoidHom.toRatLinearMap_injective [AddCommGroup M] [Module ℚ M] [AddCommGroup M₂]
    [Module ℚ M₂] : Function.Injective (@AddMonoidHom.toRatLinearMap M M₂ _ _ _ _) :=
  by
  intro f g h
  ext
  exact LinearMap.congr_fun h x
#align add_monoid_hom.to_rat_linear_map_injective AddMonoidHom.toRatLinearMap_injective

/- warning: add_monoid_hom.coe_to_rat_linear_map -> AddMonoidHom.coe_toRatLinearMap is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {M₂ : Type.{u2}} [_inst_1 : AddCommGroup.{u1} M] [_inst_2 : Module.{0, u1} Rat M Rat.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1)] [_inst_3 : AddCommGroup.{u2} M₂] [_inst_4 : Module.{0, u2} Rat M₂ Rat.semiring (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_3)] (f : AddMonoidHom.{u1, u2} M M₂ (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))) (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_3))))), Eq.{max (succ u1) (succ u2)} (M -> M₂) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{0, 0, u1, u2} Rat Rat Rat.semiring Rat.semiring (RingHom.id.{0} Rat (Semiring.toNonAssocSemiring.{0} Rat Rat.semiring)) M M₂ (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_3) _inst_2 _inst_4) (fun (_x : LinearMap.{0, 0, u1, u2} Rat Rat Rat.semiring Rat.semiring (RingHom.id.{0} Rat (Semiring.toNonAssocSemiring.{0} Rat Rat.semiring)) M M₂ (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_3) _inst_2 _inst_4) => M -> M₂) (LinearMap.hasCoeToFun.{0, 0, u1, u2} Rat Rat M M₂ Rat.semiring Rat.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_3) _inst_2 _inst_4 (RingHom.id.{0} Rat (Semiring.toNonAssocSemiring.{0} Rat Rat.semiring))) (AddMonoidHom.toRatLinearMap.{u1, u2} M M₂ _inst_1 _inst_2 _inst_3 _inst_4 f)) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} M M₂ (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))) (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_3))))) (fun (_x : AddMonoidHom.{u1, u2} M M₂ (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))) (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_3))))) => M -> M₂) (AddMonoidHom.hasCoeToFun.{u1, u2} M M₂ (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))) (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_3))))) f)
but is expected to have type
  forall {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_1 : AddCommGroup.{u2} M] [_inst_2 : Module.{0, u2} Rat M Rat.semiring (AddCommGroup.toAddCommMonoid.{u2} M _inst_1)] [_inst_3 : AddCommGroup.{u1} M₂] [_inst_4 : Module.{0, u1} Rat M₂ Rat.semiring (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_3)] (f : AddMonoidHom.{u2, u1} M M₂ (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_1)))) (AddMonoid.toAddZeroClass.{u1} M₂ (SubNegMonoid.toAddMonoid.{u1} M₂ (AddGroup.toSubNegMonoid.{u1} M₂ (AddCommGroup.toAddGroup.{u1} M₂ _inst_3))))), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : M), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{0, 0, u2, u1} Rat Rat Rat.semiring Rat.semiring (RingHom.id.{0} Rat (NonAssocRing.toNonAssocSemiring.{0} Rat (Ring.toNonAssocRing.{0} Rat (StrictOrderedRing.toRing.{0} Rat (LinearOrderedRing.toStrictOrderedRing.{0} Rat Rat.instLinearOrderedRingRat))))) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_3) _inst_2 _inst_4) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{0, 0, u2, u1} Rat Rat M M₂ Rat.semiring Rat.semiring (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_3) _inst_2 _inst_4 (RingHom.id.{0} Rat (NonAssocRing.toNonAssocSemiring.{0} Rat (Ring.toNonAssocRing.{0} Rat (StrictOrderedRing.toRing.{0} Rat (LinearOrderedRing.toStrictOrderedRing.{0} Rat Rat.instLinearOrderedRingRat)))))) (AddMonoidHom.toRatLinearMap.{u2, u1} M M₂ _inst_1 _inst_2 _inst_3 _inst_4 f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AddMonoidHom.{u2, u1} M M₂ (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_1)))) (AddMonoid.toAddZeroClass.{u1} M₂ (SubNegMonoid.toAddMonoid.{u1} M₂ (AddGroup.toSubNegMonoid.{u1} M₂ (AddCommGroup.toAddGroup.{u1} M₂ _inst_3))))) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) _x) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} M M₂ (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_1)))) (AddMonoid.toAddZeroClass.{u1} M₂ (SubNegMonoid.toAddMonoid.{u1} M₂ (AddGroup.toSubNegMonoid.{u1} M₂ (AddCommGroup.toAddGroup.{u1} M₂ _inst_3))))) M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_1))))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (SubNegMonoid.toAddMonoid.{u1} M₂ (AddGroup.toSubNegMonoid.{u1} M₂ (AddCommGroup.toAddGroup.{u1} M₂ _inst_3))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} M M₂ (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_1)))) (AddMonoid.toAddZeroClass.{u1} M₂ (SubNegMonoid.toAddMonoid.{u1} M₂ (AddGroup.toSubNegMonoid.{u1} M₂ (AddCommGroup.toAddGroup.{u1} M₂ _inst_3))))) M M₂ (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_1)))) (AddMonoid.toAddZeroClass.{u1} M₂ (SubNegMonoid.toAddMonoid.{u1} M₂ (AddGroup.toSubNegMonoid.{u1} M₂ (AddCommGroup.toAddGroup.{u1} M₂ _inst_3)))) (AddMonoidHom.addMonoidHomClass.{u2, u1} M M₂ (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_1)))) (AddMonoid.toAddZeroClass.{u1} M₂ (SubNegMonoid.toAddMonoid.{u1} M₂ (AddGroup.toSubNegMonoid.{u1} M₂ (AddCommGroup.toAddGroup.{u1} M₂ _inst_3))))))) f)
Case conversion may be inaccurate. Consider using '#align add_monoid_hom.coe_to_rat_linear_map AddMonoidHom.coe_toRatLinearMapₓ'. -/
@[simp]
theorem AddMonoidHom.coe_toRatLinearMap [AddCommGroup M] [Module ℚ M] [AddCommGroup M₂]
    [Module ℚ M₂] (f : M →+ M₂) : ⇑f.toRatLinearMap = f :=
  rfl
#align add_monoid_hom.coe_to_rat_linear_map AddMonoidHom.coe_toRatLinearMap

namespace LinearMap

section SMul

variable [Semiring R] [Semiring R₂] [Semiring R₃]

variable [AddCommMonoid M] [AddCommMonoid M₂] [AddCommMonoid M₃]

variable [Module R M] [Module R₂ M₂] [Module R₃ M₃]

variable {σ₁₂ : R →+* R₂} {σ₂₃ : R₂ →+* R₃} {σ₁₃ : R →+* R₃} [RingHomCompTriple σ₁₂ σ₂₃ σ₁₃]

variable [Monoid S] [DistribMulAction S M₂] [SMulCommClass R₂ S M₂]

variable [Monoid S₃] [DistribMulAction S₃ M₃] [SMulCommClass R₃ S₃ M₃]

variable [Monoid T] [DistribMulAction T M₂] [SMulCommClass R₂ T M₂]

instance : SMul S (M →ₛₗ[σ₁₂] M₂) :=
  ⟨fun a f =>
    { toFun := a • f
      map_add' := fun x y => by simp only [Pi.smul_apply, f.map_add, smul_add]
      map_smul' := fun c x => by simp [Pi.smul_apply, smul_comm (σ₁₂ c)] }⟩

/- warning: linear_map.smul_apply -> LinearMap.smul_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {R₂ : Type.{u2}} {S : Type.{u3}} {M : Type.{u4}} {M₂ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} R₂] [_inst_4 : AddCommMonoid.{u4} M] [_inst_5 : AddCommMonoid.{u5} M₂] [_inst_7 : Module.{u1, u4} R M _inst_1 _inst_4] [_inst_8 : Module.{u2, u5} R₂ M₂ _inst_2 _inst_5] {σ₁₂ : RingHom.{u1, u2} R R₂ (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)} [_inst_11 : Monoid.{u3} S] [_inst_12 : DistribMulAction.{u3, u5} S M₂ _inst_11 (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5)] [_inst_13 : SMulCommClass.{u2, u3, u5} R₂ S M₂ (SMulZeroClass.toHasSmul.{u2, u5} R₂ M₂ (AddZeroClass.toHasZero.{u5} M₂ (AddMonoid.toAddZeroClass.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5))) (SMulWithZero.toSmulZeroClass.{u2, u5} R₂ M₂ (MulZeroClass.toHasZero.{u2} R₂ (MulZeroOneClass.toMulZeroClass.{u2} R₂ (MonoidWithZero.toMulZeroOneClass.{u2} R₂ (Semiring.toMonoidWithZero.{u2} R₂ _inst_2)))) (AddZeroClass.toHasZero.{u5} M₂ (AddMonoid.toAddZeroClass.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5))) (MulActionWithZero.toSMulWithZero.{u2, u5} R₂ M₂ (Semiring.toMonoidWithZero.{u2} R₂ _inst_2) (AddZeroClass.toHasZero.{u5} M₂ (AddMonoid.toAddZeroClass.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5))) (Module.toMulActionWithZero.{u2, u5} R₂ M₂ _inst_2 _inst_5 _inst_8)))) (SMulZeroClass.toHasSmul.{u3, u5} S M₂ (AddZeroClass.toHasZero.{u5} M₂ (AddMonoid.toAddZeroClass.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5))) (DistribSMul.toSmulZeroClass.{u3, u5} S M₂ (AddMonoid.toAddZeroClass.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5)) (DistribMulAction.toDistribSMul.{u3, u5} S M₂ _inst_11 (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5) _inst_12)))] (a : S) (f : LinearMap.{u1, u2, u4, u5} R R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_7 _inst_8) (x : M), Eq.{succ u5} M₂ (coeFn.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (LinearMap.{u1, u2, u4, u5} R R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_7 _inst_8) (fun (_x : LinearMap.{u1, u2, u4, u5} R R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_7 _inst_8) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u4, u5} R R₂ M M₂ _inst_1 _inst_2 _inst_4 _inst_5 _inst_7 _inst_8 σ₁₂) (SMul.smul.{u3, max u4 u5} S (LinearMap.{u1, u2, u4, u5} R R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_7 _inst_8) (LinearMap.hasSmul.{u1, u2, u3, u4, u5} R R₂ S M M₂ _inst_1 _inst_2 _inst_4 _inst_5 _inst_7 _inst_8 σ₁₂ _inst_11 _inst_12 _inst_13) a f) x) (SMul.smul.{u3, u5} S M₂ (SMulZeroClass.toHasSmul.{u3, u5} S M₂ (AddZeroClass.toHasZero.{u5} M₂ (AddMonoid.toAddZeroClass.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5))) (DistribSMul.toSmulZeroClass.{u3, u5} S M₂ (AddMonoid.toAddZeroClass.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5)) (DistribMulAction.toDistribSMul.{u3, u5} S M₂ _inst_11 (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5) _inst_12))) a (coeFn.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (LinearMap.{u1, u2, u4, u5} R R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_7 _inst_8) (fun (_x : LinearMap.{u1, u2, u4, u5} R R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_7 _inst_8) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u4, u5} R R₂ M M₂ _inst_1 _inst_2 _inst_4 _inst_5 _inst_7 _inst_8 σ₁₂) f x))
but is expected to have type
  forall {R : Type.{u5}} {R₂ : Type.{u4}} {S : Type.{u1}} {M : Type.{u3}} {M₂ : Type.{u2}} [_inst_1 : Semiring.{u5} R] [_inst_2 : Semiring.{u4} R₂] [_inst_4 : AddCommMonoid.{u3} M] [_inst_5 : AddCommMonoid.{u2} M₂] [_inst_7 : Module.{u5, u3} R M _inst_1 _inst_4] [_inst_8 : Module.{u4, u2} R₂ M₂ _inst_2 _inst_5] {σ₁₂ : RingHom.{u5, u4} R R₂ (Semiring.toNonAssocSemiring.{u5} R _inst_1) (Semiring.toNonAssocSemiring.{u4} R₂ _inst_2)} [_inst_11 : Monoid.{u1} S] [_inst_12 : DistribMulAction.{u1, u2} S M₂ _inst_11 (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_5)] [_inst_13 : SMulCommClass.{u4, u1, u2} R₂ S M₂ (SMulZeroClass.toSMul.{u4, u2} R₂ M₂ (AddMonoid.toZero.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_5)) (SMulWithZero.toSMulZeroClass.{u4, u2} R₂ M₂ (MonoidWithZero.toZero.{u4} R₂ (Semiring.toMonoidWithZero.{u4} R₂ _inst_2)) (AddMonoid.toZero.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_5)) (MulActionWithZero.toSMulWithZero.{u4, u2} R₂ M₂ (Semiring.toMonoidWithZero.{u4} R₂ _inst_2) (AddMonoid.toZero.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_5)) (Module.toMulActionWithZero.{u4, u2} R₂ M₂ _inst_2 _inst_5 _inst_8)))) (SMulZeroClass.toSMul.{u1, u2} S M₂ (AddMonoid.toZero.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_5)) (DistribSMul.toSMulZeroClass.{u1, u2} S M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_5)) (DistribMulAction.toDistribSMul.{u1, u2} S M₂ _inst_11 (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_5) _inst_12)))] (a : S) (f : LinearMap.{u5, u4, u3, u2} R R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_7 _inst_8) (x : M), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (LinearMap.{u5, u4, u3, u2} R R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_7 _inst_8) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u5, u4, u3, u2} R R₂ M M₂ _inst_1 _inst_2 _inst_4 _inst_5 _inst_7 _inst_8 σ₁₂) (HSMul.hSMul.{u1, max u3 u2, max u3 u2} S (LinearMap.{u5, u4, u3, u2} R R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_7 _inst_8) (LinearMap.{u5, u4, u3, u2} R R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_7 _inst_8) (instHSMul.{u1, max u3 u2} S (LinearMap.{u5, u4, u3, u2} R R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_7 _inst_8) (LinearMap.instSMulLinearMap.{u5, u4, u1, u3, u2} R R₂ S M M₂ _inst_1 _inst_2 _inst_4 _inst_5 _inst_7 _inst_8 σ₁₂ _inst_11 _inst_12 _inst_13)) a f) x) (HSMul.hSMul.{u1, u2, u2} S ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (instHSMul.{u1, u2} S ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (SMulZeroClass.toSMul.{u1, u2} S ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (AddMonoid.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (AddCommMonoid.toAddMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) _inst_5)) (DistribSMul.toSMulZeroClass.{u1, u2} S ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (AddMonoid.toAddZeroClass.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (AddCommMonoid.toAddMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) _inst_5)) (DistribMulAction.toDistribSMul.{u1, u2} S ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) _inst_11 (AddCommMonoid.toAddMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) _inst_5) _inst_12)))) a (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (LinearMap.{u5, u4, u3, u2} R R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_7 _inst_8) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u5, u4, u3, u2} R R₂ M M₂ _inst_1 _inst_2 _inst_4 _inst_5 _inst_7 _inst_8 σ₁₂) f x))
Case conversion may be inaccurate. Consider using '#align linear_map.smul_apply LinearMap.smul_applyₓ'. -/
@[simp]
theorem smul_apply (a : S) (f : M →ₛₗ[σ₁₂] M₂) (x : M) : (a • f) x = a • f x :=
  rfl
#align linear_map.smul_apply LinearMap.smul_apply

/- warning: linear_map.coe_smul -> LinearMap.coe_smul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {R₂ : Type.{u2}} {S : Type.{u3}} {M : Type.{u4}} {M₂ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} R₂] [_inst_4 : AddCommMonoid.{u4} M] [_inst_5 : AddCommMonoid.{u5} M₂] [_inst_7 : Module.{u1, u4} R M _inst_1 _inst_4] [_inst_8 : Module.{u2, u5} R₂ M₂ _inst_2 _inst_5] {σ₁₂ : RingHom.{u1, u2} R R₂ (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)} [_inst_11 : Monoid.{u3} S] [_inst_12 : DistribMulAction.{u3, u5} S M₂ _inst_11 (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5)] [_inst_13 : SMulCommClass.{u2, u3, u5} R₂ S M₂ (SMulZeroClass.toHasSmul.{u2, u5} R₂ M₂ (AddZeroClass.toHasZero.{u5} M₂ (AddMonoid.toAddZeroClass.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5))) (SMulWithZero.toSmulZeroClass.{u2, u5} R₂ M₂ (MulZeroClass.toHasZero.{u2} R₂ (MulZeroOneClass.toMulZeroClass.{u2} R₂ (MonoidWithZero.toMulZeroOneClass.{u2} R₂ (Semiring.toMonoidWithZero.{u2} R₂ _inst_2)))) (AddZeroClass.toHasZero.{u5} M₂ (AddMonoid.toAddZeroClass.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5))) (MulActionWithZero.toSMulWithZero.{u2, u5} R₂ M₂ (Semiring.toMonoidWithZero.{u2} R₂ _inst_2) (AddZeroClass.toHasZero.{u5} M₂ (AddMonoid.toAddZeroClass.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5))) (Module.toMulActionWithZero.{u2, u5} R₂ M₂ _inst_2 _inst_5 _inst_8)))) (SMulZeroClass.toHasSmul.{u3, u5} S M₂ (AddZeroClass.toHasZero.{u5} M₂ (AddMonoid.toAddZeroClass.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5))) (DistribSMul.toSmulZeroClass.{u3, u5} S M₂ (AddMonoid.toAddZeroClass.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5)) (DistribMulAction.toDistribSMul.{u3, u5} S M₂ _inst_11 (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5) _inst_12)))] (a : S) (f : LinearMap.{u1, u2, u4, u5} R R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_7 _inst_8), Eq.{succ (max u4 u5)} (M -> M₂) (coeFn.{succ (max u4 u5), succ (max u4 u5)} (LinearMap.{u1, u2, u4, u5} R R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_7 _inst_8) (fun (_x : LinearMap.{u1, u2, u4, u5} R R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_7 _inst_8) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u4, u5} R R₂ M M₂ _inst_1 _inst_2 _inst_4 _inst_5 _inst_7 _inst_8 σ₁₂) (SMul.smul.{u3, max u4 u5} S (LinearMap.{u1, u2, u4, u5} R R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_7 _inst_8) (LinearMap.hasSmul.{u1, u2, u3, u4, u5} R R₂ S M M₂ _inst_1 _inst_2 _inst_4 _inst_5 _inst_7 _inst_8 σ₁₂ _inst_11 _inst_12 _inst_13) a f)) (SMul.smul.{u3, max u4 u5} S (M -> M₂) (Function.hasSMul.{u4, u3, u5} M S M₂ (SMulZeroClass.toHasSmul.{u3, u5} S M₂ (AddZeroClass.toHasZero.{u5} M₂ (AddMonoid.toAddZeroClass.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5))) (DistribSMul.toSmulZeroClass.{u3, u5} S M₂ (AddMonoid.toAddZeroClass.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5)) (DistribMulAction.toDistribSMul.{u3, u5} S M₂ _inst_11 (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5) _inst_12)))) a (coeFn.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (LinearMap.{u1, u2, u4, u5} R R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_7 _inst_8) (fun (_x : LinearMap.{u1, u2, u4, u5} R R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_7 _inst_8) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u4, u5} R R₂ M M₂ _inst_1 _inst_2 _inst_4 _inst_5 _inst_7 _inst_8 σ₁₂) f))
but is expected to have type
  forall {R : Type.{u5}} {R₂ : Type.{u4}} {S : Type.{u1}} {M : Type.{u3}} {M₂ : Type.{u2}} [_inst_1 : Semiring.{u5} R] [_inst_2 : Semiring.{u4} R₂] [_inst_4 : AddCommMonoid.{u3} M] [_inst_5 : AddCommMonoid.{u2} M₂] [_inst_7 : Module.{u5, u3} R M _inst_1 _inst_4] [_inst_8 : Module.{u4, u2} R₂ M₂ _inst_2 _inst_5] {σ₁₂ : RingHom.{u5, u4} R R₂ (Semiring.toNonAssocSemiring.{u5} R _inst_1) (Semiring.toNonAssocSemiring.{u4} R₂ _inst_2)} [_inst_11 : Monoid.{u1} S] [_inst_12 : DistribMulAction.{u1, u2} S M₂ _inst_11 (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_5)] [_inst_13 : SMulCommClass.{u4, u1, u2} R₂ S M₂ (SMulZeroClass.toSMul.{u4, u2} R₂ M₂ (AddMonoid.toZero.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_5)) (SMulWithZero.toSMulZeroClass.{u4, u2} R₂ M₂ (MonoidWithZero.toZero.{u4} R₂ (Semiring.toMonoidWithZero.{u4} R₂ _inst_2)) (AddMonoid.toZero.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_5)) (MulActionWithZero.toSMulWithZero.{u4, u2} R₂ M₂ (Semiring.toMonoidWithZero.{u4} R₂ _inst_2) (AddMonoid.toZero.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_5)) (Module.toMulActionWithZero.{u4, u2} R₂ M₂ _inst_2 _inst_5 _inst_8)))) (SMulZeroClass.toSMul.{u1, u2} S M₂ (AddMonoid.toZero.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_5)) (DistribSMul.toSMulZeroClass.{u1, u2} S M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_5)) (DistribMulAction.toDistribSMul.{u1, u2} S M₂ _inst_11 (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_5) _inst_12)))] (a : S) (f : LinearMap.{u5, u4, u3, u2} R R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_7 _inst_8), Eq.{max (succ u3) (succ u2)} (forall (ᾰ : M), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) ᾰ) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (LinearMap.{u5, u4, u3, u2} R R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_7 _inst_8) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u5, u4, u3, u2} R R₂ M M₂ _inst_1 _inst_2 _inst_4 _inst_5 _inst_7 _inst_8 σ₁₂) (HSMul.hSMul.{u1, max u3 u2, max u3 u2} S (LinearMap.{u5, u4, u3, u2} R R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_7 _inst_8) (LinearMap.{u5, u4, u3, u2} R R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_7 _inst_8) (instHSMul.{u1, max u3 u2} S (LinearMap.{u5, u4, u3, u2} R R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_7 _inst_8) (LinearMap.instSMulLinearMap.{u5, u4, u1, u3, u2} R R₂ S M M₂ _inst_1 _inst_2 _inst_4 _inst_5 _inst_7 _inst_8 σ₁₂ _inst_11 _inst_12 _inst_13)) a f)) (HSMul.hSMul.{u1, max u3 u2, max u3 u2} S (forall (a : M), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) a) (forall (ᾰ : M), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) ᾰ) (instHSMul.{u1, max u3 u2} S (forall (a : M), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) a) (Pi.instSMul.{u3, u2, u1} M S (fun (a : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) a) (fun (i : M) => SMulZeroClass.toSMul.{u1, u2} S ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) i) (AddMonoid.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) i) _inst_5)) (DistribSMul.toSMulZeroClass.{u1, u2} S ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) i) (AddMonoid.toAddZeroClass.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) i) _inst_5)) (DistribMulAction.toDistribSMul.{u1, u2} S ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) i) _inst_11 (AddCommMonoid.toAddMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) i) _inst_5) _inst_12))))) a (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (LinearMap.{u5, u4, u3, u2} R R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_7 _inst_8) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u5, u4, u3, u2} R R₂ M M₂ _inst_1 _inst_2 _inst_4 _inst_5 _inst_7 _inst_8 σ₁₂) f))
Case conversion may be inaccurate. Consider using '#align linear_map.coe_smul LinearMap.coe_smulₓ'. -/
theorem coe_smul (a : S) (f : M →ₛₗ[σ₁₂] M₂) : ⇑(a • f) = a • f :=
  rfl
#align linear_map.coe_smul LinearMap.coe_smul

instance [SMulCommClass S T M₂] : SMulCommClass S T (M →ₛₗ[σ₁₂] M₂) :=
  ⟨fun a b f => ext fun x => smul_comm _ _ _⟩

-- example application of this instance: if S -> T -> R are homomorphisms of commutative rings and
-- M and M₂ are R-modules then the S-module and T-module structures on Hom_R(M,M₂) are compatible.
instance [SMul S T] [IsScalarTower S T M₂] : IsScalarTower S T (M →ₛₗ[σ₁₂] M₂)
    where smul_assoc _ _ _ := ext fun _ => smul_assoc _ _ _

instance [DistribMulAction Sᵐᵒᵖ M₂] [SMulCommClass R₂ Sᵐᵒᵖ M₂] [IsCentralScalar S M₂] :
    IsCentralScalar S (M →ₛₗ[σ₁₂] M₂) where op_smul_eq_smul a b := ext fun x => op_smul_eq_smul _ _

end SMul

/-! ### Arithmetic on the codomain -/


section Arithmetic

variable [Semiring R₁] [Semiring R₂] [Semiring R₃]

variable [AddCommMonoid M] [AddCommMonoid M₂] [AddCommMonoid M₃]

variable [AddCommGroup N₁] [AddCommGroup N₂] [AddCommGroup N₃]

variable [Module R₁ M] [Module R₂ M₂] [Module R₃ M₃]

variable [Module R₁ N₁] [Module R₂ N₂] [Module R₃ N₃]

variable {σ₁₂ : R₁ →+* R₂} {σ₂₃ : R₂ →+* R₃} {σ₁₃ : R₁ →+* R₃} [RingHomCompTriple σ₁₂ σ₂₃ σ₁₃]

/-- The constant 0 map is linear. -/
instance : Zero (M →ₛₗ[σ₁₂] M₂) :=
  ⟨{  toFun := 0
      map_add' := by simp
      map_smul' := by simp }⟩

/- warning: linear_map.zero_apply -> LinearMap.zero_apply is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R₁] [_inst_2 : Semiring.{u2} R₂] [_inst_4 : AddCommMonoid.{u3} M] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_10 : Module.{u1, u3} R₁ M _inst_1 _inst_4] [_inst_11 : Module.{u2, u4} R₂ M₂ _inst_2 _inst_5] {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)} (x : M), Eq.{succ u4} M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (fun (_x : LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R₁ R₂ M M₂ _inst_1 _inst_2 _inst_4 _inst_5 _inst_10 _inst_11 σ₁₂) (OfNat.ofNat.{max u3 u4} (LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) 0 (OfNat.mk.{max u3 u4} (LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) 0 (Zero.zero.{max u3 u4} (LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (LinearMap.hasZero.{u1, u2, u3, u4} R₁ R₂ M M₂ _inst_1 _inst_2 _inst_4 _inst_5 _inst_10 _inst_11 σ₁₂)))) x) (OfNat.ofNat.{u4} M₂ 0 (OfNat.mk.{u4} M₂ 0 (Zero.zero.{u4} M₂ (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))))))
but is expected to have type
  forall {R₁ : Type.{u2}} {R₂ : Type.{u1}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u2} R₁] [_inst_2 : Semiring.{u1} R₂] [_inst_4 : AddCommMonoid.{u3} M] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_10 : Module.{u2, u3} R₁ M _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R₂ M₂ _inst_2 _inst_5] {σ₁₂ : RingHom.{u2, u1} R₁ R₂ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2)} (x : M), Eq.{succ u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearMap.{u2, u1, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u2, u1, u3, u4} R₁ R₂ M M₂ _inst_1 _inst_2 _inst_4 _inst_5 _inst_10 _inst_11 σ₁₂) (OfNat.ofNat.{max u3 u4} (LinearMap.{u2, u1, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) 0 (Zero.toOfNat0.{max u3 u4} (LinearMap.{u2, u1, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (LinearMap.instZeroLinearMap.{u2, u1, u3, u4} R₁ R₂ M M₂ _inst_1 _inst_2 _inst_4 _inst_5 _inst_10 _inst_11 σ₁₂))) x) (OfNat.ofNat.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) 0 (Zero.toOfNat0.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (AddMonoid.toZero.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (AddCommMonoid.toAddMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) _inst_5))))
Case conversion may be inaccurate. Consider using '#align linear_map.zero_apply LinearMap.zero_applyₓ'. -/
@[simp]
theorem zero_apply (x : M) : (0 : M →ₛₗ[σ₁₂] M₂) x = 0 :=
  rfl
#align linear_map.zero_apply LinearMap.zero_apply

/- warning: linear_map.comp_zero -> LinearMap.comp_zero is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {R₃ : Type.{u3}} {M : Type.{u4}} {M₂ : Type.{u5}} {M₃ : Type.{u6}} [_inst_1 : Semiring.{u1} R₁] [_inst_2 : Semiring.{u2} R₂] [_inst_3 : Semiring.{u3} R₃] [_inst_4 : AddCommMonoid.{u4} M] [_inst_5 : AddCommMonoid.{u5} M₂] [_inst_6 : AddCommMonoid.{u6} M₃] [_inst_10 : Module.{u1, u4} R₁ M _inst_1 _inst_4] [_inst_11 : Module.{u2, u5} R₂ M₂ _inst_2 _inst_5] [_inst_12 : Module.{u3, u6} R₃ M₃ _inst_3 _inst_6] {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)} {σ₂₃ : RingHom.{u2, u3} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_3)} {σ₁₃ : RingHom.{u1, u3} R₁ R₃ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_3)} [_inst_16 : RingHomCompTriple.{u1, u2, u3} R₁ R₂ R₃ _inst_1 _inst_2 _inst_3 σ₁₂ σ₂₃ σ₁₃] (g : LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ M₃ _inst_5 _inst_6 _inst_11 _inst_12), Eq.{max (succ u4) (succ u6)} (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.comp.{u1, u2, u3, u4, u5, u6} R₁ R₂ R₃ M M₂ M₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_10 _inst_11 _inst_12 σ₁₂ σ₂₃ σ₁₃ _inst_16 g (OfNat.ofNat.{max u4 u5} (LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) 0 (OfNat.mk.{max u4 u5} (LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) 0 (Zero.zero.{max u4 u5} (LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (LinearMap.hasZero.{u1, u2, u4, u5} R₁ R₂ M M₂ _inst_1 _inst_2 _inst_4 _inst_5 _inst_10 _inst_11 σ₁₂))))) (OfNat.ofNat.{max u4 u6} (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_10 _inst_12) 0 (OfNat.mk.{max u4 u6} (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_10 _inst_12) 0 (Zero.zero.{max u4 u6} (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.hasZero.{u1, u3, u4, u6} R₁ R₃ M M₃ _inst_1 _inst_3 _inst_4 _inst_6 _inst_10 _inst_12 σ₁₃))))
but is expected to have type
  forall {R₁ : Type.{u1}} {R₂ : Type.{u6}} {R₃ : Type.{u5}} {M : Type.{u2}} {M₂ : Type.{u4}} {M₃ : Type.{u3}} [_inst_1 : Semiring.{u1} R₁] [_inst_2 : Semiring.{u6} R₂] [_inst_3 : Semiring.{u5} R₃] [_inst_4 : AddCommMonoid.{u2} M] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_6 : AddCommMonoid.{u3} M₃] [_inst_10 : Module.{u1, u2} R₁ M _inst_1 _inst_4] [_inst_11 : Module.{u6, u4} R₂ M₂ _inst_2 _inst_5] [_inst_12 : Module.{u5, u3} R₃ M₃ _inst_3 _inst_6] {σ₁₂ : RingHom.{u1, u6} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u6} R₂ _inst_2)} {σ₂₃ : RingHom.{u6, u5} R₂ R₃ (Semiring.toNonAssocSemiring.{u6} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u5} R₃ _inst_3)} {σ₁₃ : RingHom.{u1, u5} R₁ R₃ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u5} R₃ _inst_3)} [_inst_16 : RingHomCompTriple.{u1, u6, u5} R₁ R₂ R₃ _inst_1 _inst_2 _inst_3 σ₁₂ σ₂₃ σ₁₃] (g : LinearMap.{u6, u5, u4, u3} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ M₃ _inst_5 _inst_6 _inst_11 _inst_12), Eq.{max (succ u2) (succ u3)} (LinearMap.{u1, u5, u2, u3} R₁ R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.comp.{u1, u6, u5, u2, u4, u3} R₁ R₂ R₃ M M₂ M₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_10 _inst_11 _inst_12 σ₁₂ σ₂₃ σ₁₃ _inst_16 g (OfNat.ofNat.{max u2 u4} (LinearMap.{u1, u6, u2, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) 0 (Zero.toOfNat0.{max u2 u4} (LinearMap.{u1, u6, u2, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (LinearMap.instZeroLinearMap.{u1, u6, u2, u4} R₁ R₂ M M₂ _inst_1 _inst_2 _inst_4 _inst_5 _inst_10 _inst_11 σ₁₂)))) (OfNat.ofNat.{max u2 u3} (LinearMap.{u1, u5, u2, u3} R₁ R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_10 _inst_12) 0 (Zero.toOfNat0.{max u2 u3} (LinearMap.{u1, u5, u2, u3} R₁ R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.instZeroLinearMap.{u1, u5, u2, u3} R₁ R₃ M M₃ _inst_1 _inst_3 _inst_4 _inst_6 _inst_10 _inst_12 σ₁₃)))
Case conversion may be inaccurate. Consider using '#align linear_map.comp_zero LinearMap.comp_zeroₓ'. -/
@[simp]
theorem comp_zero (g : M₂ →ₛₗ[σ₂₃] M₃) : (g.comp (0 : M →ₛₗ[σ₁₂] M₂) : M →ₛₗ[σ₁₃] M₃) = 0 :=
  ext fun c => by rw [comp_apply, zero_apply, zero_apply, g.map_zero]
#align linear_map.comp_zero LinearMap.comp_zero

/- warning: linear_map.zero_comp -> LinearMap.zero_comp is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {R₃ : Type.{u3}} {M : Type.{u4}} {M₂ : Type.{u5}} {M₃ : Type.{u6}} [_inst_1 : Semiring.{u1} R₁] [_inst_2 : Semiring.{u2} R₂] [_inst_3 : Semiring.{u3} R₃] [_inst_4 : AddCommMonoid.{u4} M] [_inst_5 : AddCommMonoid.{u5} M₂] [_inst_6 : AddCommMonoid.{u6} M₃] [_inst_10 : Module.{u1, u4} R₁ M _inst_1 _inst_4] [_inst_11 : Module.{u2, u5} R₂ M₂ _inst_2 _inst_5] [_inst_12 : Module.{u3, u6} R₃ M₃ _inst_3 _inst_6] {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)} {σ₂₃ : RingHom.{u2, u3} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_3)} {σ₁₃ : RingHom.{u1, u3} R₁ R₃ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_3)} [_inst_16 : RingHomCompTriple.{u1, u2, u3} R₁ R₂ R₃ _inst_1 _inst_2 _inst_3 σ₁₂ σ₂₃ σ₁₃] (f : LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11), Eq.{max (succ u4) (succ u6)} (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.comp.{u1, u2, u3, u4, u5, u6} R₁ R₂ R₃ M M₂ M₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_10 _inst_11 _inst_12 σ₁₂ σ₂₃ σ₁₃ _inst_16 (OfNat.ofNat.{max u5 u6} (LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ M₃ _inst_5 _inst_6 _inst_11 _inst_12) 0 (OfNat.mk.{max u5 u6} (LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ M₃ _inst_5 _inst_6 _inst_11 _inst_12) 0 (Zero.zero.{max u5 u6} (LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ M₃ _inst_5 _inst_6 _inst_11 _inst_12) (LinearMap.hasZero.{u2, u3, u5, u6} R₂ R₃ M₂ M₃ _inst_2 _inst_3 _inst_5 _inst_6 _inst_11 _inst_12 σ₂₃)))) f) (OfNat.ofNat.{max u4 u6} (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_10 _inst_12) 0 (OfNat.mk.{max u4 u6} (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_10 _inst_12) 0 (Zero.zero.{max u4 u6} (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.hasZero.{u1, u3, u4, u6} R₁ R₃ M M₃ _inst_1 _inst_3 _inst_4 _inst_6 _inst_10 _inst_12 σ₁₃))))
but is expected to have type
  forall {R₁ : Type.{u6}} {R₂ : Type.{u5}} {R₃ : Type.{u1}} {M : Type.{u4}} {M₂ : Type.{u3}} {M₃ : Type.{u2}} [_inst_1 : Semiring.{u6} R₁] [_inst_2 : Semiring.{u5} R₂] [_inst_3 : Semiring.{u1} R₃] [_inst_4 : AddCommMonoid.{u4} M] [_inst_5 : AddCommMonoid.{u3} M₂] [_inst_6 : AddCommMonoid.{u2} M₃] [_inst_10 : Module.{u6, u4} R₁ M _inst_1 _inst_4] [_inst_11 : Module.{u5, u3} R₂ M₂ _inst_2 _inst_5] [_inst_12 : Module.{u1, u2} R₃ M₃ _inst_3 _inst_6] {σ₁₂ : RingHom.{u6, u5} R₁ R₂ (Semiring.toNonAssocSemiring.{u6} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u5} R₂ _inst_2)} {σ₂₃ : RingHom.{u5, u1} R₂ R₃ (Semiring.toNonAssocSemiring.{u5} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₃ _inst_3)} {σ₁₃ : RingHom.{u6, u1} R₁ R₃ (Semiring.toNonAssocSemiring.{u6} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u1} R₃ _inst_3)} [_inst_16 : RingHomCompTriple.{u6, u5, u1} R₁ R₂ R₃ _inst_1 _inst_2 _inst_3 σ₁₂ σ₂₃ σ₁₃] (f : LinearMap.{u6, u5, u4, u3} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11), Eq.{max (succ u4) (succ u2)} (LinearMap.{u6, u1, u4, u2} R₁ R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.comp.{u6, u5, u1, u4, u3, u2} R₁ R₂ R₃ M M₂ M₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_10 _inst_11 _inst_12 σ₁₂ σ₂₃ σ₁₃ _inst_16 (OfNat.ofNat.{max u3 u2} (LinearMap.{u5, u1, u3, u2} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ M₃ _inst_5 _inst_6 _inst_11 _inst_12) 0 (Zero.toOfNat0.{max u3 u2} (LinearMap.{u5, u1, u3, u2} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ M₃ _inst_5 _inst_6 _inst_11 _inst_12) (LinearMap.instZeroLinearMap.{u5, u1, u3, u2} R₂ R₃ M₂ M₃ _inst_2 _inst_3 _inst_5 _inst_6 _inst_11 _inst_12 σ₂₃))) f) (OfNat.ofNat.{max u4 u2} (LinearMap.{u6, u1, u4, u2} R₁ R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_10 _inst_12) 0 (Zero.toOfNat0.{max u4 u2} (LinearMap.{u6, u1, u4, u2} R₁ R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.instZeroLinearMap.{u6, u1, u4, u2} R₁ R₃ M M₃ _inst_1 _inst_3 _inst_4 _inst_6 _inst_10 _inst_12 σ₁₃)))
Case conversion may be inaccurate. Consider using '#align linear_map.zero_comp LinearMap.zero_compₓ'. -/
@[simp]
theorem zero_comp (f : M →ₛₗ[σ₁₂] M₂) : ((0 : M₂ →ₛₗ[σ₂₃] M₃).comp f : M →ₛₗ[σ₁₃] M₃) = 0 :=
  rfl
#align linear_map.zero_comp LinearMap.zero_comp

instance : Inhabited (M →ₛₗ[σ₁₂] M₂) :=
  ⟨0⟩

/- warning: linear_map.default_def -> LinearMap.default_def is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R₁] [_inst_2 : Semiring.{u2} R₂] [_inst_4 : AddCommMonoid.{u3} M] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_10 : Module.{u1, u3} R₁ M _inst_1 _inst_4] [_inst_11 : Module.{u2, u4} R₂ M₂ _inst_2 _inst_5] {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)}, Eq.{max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (Inhabited.default.{max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (LinearMap.inhabited.{u1, u2, u3, u4} R₁ R₂ M M₂ _inst_1 _inst_2 _inst_4 _inst_5 _inst_10 _inst_11 σ₁₂)) (OfNat.ofNat.{max u3 u4} (LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) 0 (OfNat.mk.{max u3 u4} (LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) 0 (Zero.zero.{max u3 u4} (LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (LinearMap.hasZero.{u1, u2, u3, u4} R₁ R₂ M M₂ _inst_1 _inst_2 _inst_4 _inst_5 _inst_10 _inst_11 σ₁₂))))
but is expected to have type
  forall {R₁ : Type.{u2}} {R₂ : Type.{u1}} {M : Type.{u4}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u2} R₁] [_inst_2 : Semiring.{u1} R₂] [_inst_4 : AddCommMonoid.{u4} M] [_inst_5 : AddCommMonoid.{u3} M₂] [_inst_10 : Module.{u2, u4} R₁ M _inst_1 _inst_4] [_inst_11 : Module.{u1, u3} R₂ M₂ _inst_2 _inst_5] {σ₁₂ : RingHom.{u2, u1} R₁ R₂ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2)}, Eq.{max (succ u4) (succ u3)} (LinearMap.{u2, u1, u4, u3} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (Inhabited.default.{max (succ u4) (succ u3)} (LinearMap.{u2, u1, u4, u3} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (LinearMap.instInhabitedLinearMap.{u2, u1, u4, u3} R₁ R₂ M M₂ _inst_1 _inst_2 _inst_4 _inst_5 _inst_10 _inst_11 σ₁₂)) (OfNat.ofNat.{max u4 u3} (LinearMap.{u2, u1, u4, u3} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) 0 (Zero.toOfNat0.{max u4 u3} (LinearMap.{u2, u1, u4, u3} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (LinearMap.instZeroLinearMap.{u2, u1, u4, u3} R₁ R₂ M M₂ _inst_1 _inst_2 _inst_4 _inst_5 _inst_10 _inst_11 σ₁₂)))
Case conversion may be inaccurate. Consider using '#align linear_map.default_def LinearMap.default_defₓ'. -/
@[simp]
theorem default_def : (default : M →ₛₗ[σ₁₂] M₂) = 0 :=
  rfl
#align linear_map.default_def LinearMap.default_def

/-- The sum of two linear maps is linear. -/
instance : Add (M →ₛₗ[σ₁₂] M₂) :=
  ⟨fun f g =>
    { toFun := f + g
      map_add' := by simp [add_comm, add_left_comm]
      map_smul' := by simp [smul_add] }⟩

/- warning: linear_map.add_apply -> LinearMap.add_apply is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R₁] [_inst_2 : Semiring.{u2} R₂] [_inst_4 : AddCommMonoid.{u3} M] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_10 : Module.{u1, u3} R₁ M _inst_1 _inst_4] [_inst_11 : Module.{u2, u4} R₂ M₂ _inst_2 _inst_5] {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)} (f : LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (g : LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (x : M), Eq.{succ u4} M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (fun (_x : LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R₁ R₂ M M₂ _inst_1 _inst_2 _inst_4 _inst_5 _inst_10 _inst_11 σ₁₂) (HAdd.hAdd.{max u3 u4, max u3 u4, max u3 u4} (LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (instHAdd.{max u3 u4} (LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (LinearMap.hasAdd.{u1, u2, u3, u4} R₁ R₂ M M₂ _inst_1 _inst_2 _inst_4 _inst_5 _inst_10 _inst_11 σ₁₂)) f g) x) (HAdd.hAdd.{u4, u4, u4} M₂ M₂ M₂ (instHAdd.{u4} M₂ (AddZeroClass.toHasAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5)))) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (fun (_x : LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R₁ R₂ M M₂ _inst_1 _inst_2 _inst_4 _inst_5 _inst_10 _inst_11 σ₁₂) f x) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (fun (_x : LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R₁ R₂ M M₂ _inst_1 _inst_2 _inst_4 _inst_5 _inst_10 _inst_11 σ₁₂) g x))
but is expected to have type
  forall {R₁ : Type.{u4}} {R₂ : Type.{u3}} {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_1 : Semiring.{u4} R₁] [_inst_2 : Semiring.{u3} R₂] [_inst_4 : AddCommMonoid.{u2} M] [_inst_5 : AddCommMonoid.{u1} M₂] [_inst_10 : Module.{u4, u2} R₁ M _inst_1 _inst_4] [_inst_11 : Module.{u3, u1} R₂ M₂ _inst_2 _inst_5] {σ₁₂ : RingHom.{u4, u3} R₁ R₂ (Semiring.toNonAssocSemiring.{u4} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u3} R₂ _inst_2)} (f : LinearMap.{u4, u3, u2, u1} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (g : LinearMap.{u4, u3, u2, u1} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (x : M), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u4, u3, u2, u1} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u4, u3, u2, u1} R₁ R₂ M M₂ _inst_1 _inst_2 _inst_4 _inst_5 _inst_10 _inst_11 σ₁₂) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (LinearMap.{u4, u3, u2, u1} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (LinearMap.{u4, u3, u2, u1} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (LinearMap.{u4, u3, u2, u1} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (instHAdd.{max u2 u1} (LinearMap.{u4, u3, u2, u1} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (LinearMap.instAddLinearMap.{u4, u3, u2, u1} R₁ R₂ M M₂ _inst_1 _inst_2 _inst_4 _inst_5 _inst_10 _inst_11 σ₁₂)) f g) x) (HAdd.hAdd.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (instHAdd.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (AddZeroClass.toAdd.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (AddMonoid.toAddZeroClass.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (AddCommMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) _inst_5)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u4, u3, u2, u1} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u4, u3, u2, u1} R₁ R₂ M M₂ _inst_1 _inst_2 _inst_4 _inst_5 _inst_10 _inst_11 σ₁₂) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u4, u3, u2, u1} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u4, u3, u2, u1} R₁ R₂ M M₂ _inst_1 _inst_2 _inst_4 _inst_5 _inst_10 _inst_11 σ₁₂) g x))
Case conversion may be inaccurate. Consider using '#align linear_map.add_apply LinearMap.add_applyₓ'. -/
@[simp]
theorem add_apply (f g : M →ₛₗ[σ₁₂] M₂) (x : M) : (f + g) x = f x + g x :=
  rfl
#align linear_map.add_apply LinearMap.add_apply

/- warning: linear_map.add_comp -> LinearMap.add_comp is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {R₃ : Type.{u3}} {M : Type.{u4}} {M₂ : Type.{u5}} {M₃ : Type.{u6}} [_inst_1 : Semiring.{u1} R₁] [_inst_2 : Semiring.{u2} R₂] [_inst_3 : Semiring.{u3} R₃] [_inst_4 : AddCommMonoid.{u4} M] [_inst_5 : AddCommMonoid.{u5} M₂] [_inst_6 : AddCommMonoid.{u6} M₃] [_inst_10 : Module.{u1, u4} R₁ M _inst_1 _inst_4] [_inst_11 : Module.{u2, u5} R₂ M₂ _inst_2 _inst_5] [_inst_12 : Module.{u3, u6} R₃ M₃ _inst_3 _inst_6] {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)} {σ₂₃ : RingHom.{u2, u3} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_3)} {σ₁₃ : RingHom.{u1, u3} R₁ R₃ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_3)} [_inst_16 : RingHomCompTriple.{u1, u2, u3} R₁ R₂ R₃ _inst_1 _inst_2 _inst_3 σ₁₂ σ₂₃ σ₁₃] (f : LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (g : LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ M₃ _inst_5 _inst_6 _inst_11 _inst_12) (h : LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ M₃ _inst_5 _inst_6 _inst_11 _inst_12), Eq.{max (succ u4) (succ u6)} (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.comp.{u1, u2, u3, u4, u5, u6} R₁ R₂ R₃ M M₂ M₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_10 _inst_11 _inst_12 σ₁₂ σ₂₃ σ₁₃ _inst_16 (HAdd.hAdd.{max u5 u6, max u5 u6, max u5 u6} (LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ M₃ _inst_5 _inst_6 _inst_11 _inst_12) (LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ M₃ _inst_5 _inst_6 _inst_11 _inst_12) (LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ M₃ _inst_5 _inst_6 _inst_11 _inst_12) (instHAdd.{max u5 u6} (LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ M₃ _inst_5 _inst_6 _inst_11 _inst_12) (LinearMap.hasAdd.{u2, u3, u5, u6} R₂ R₃ M₂ M₃ _inst_2 _inst_3 _inst_5 _inst_6 _inst_11 _inst_12 σ₂₃)) h g) f) (HAdd.hAdd.{max u4 u6, max u4 u6, max u4 u6} (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_10 _inst_12) (instHAdd.{max u4 u6} (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.hasAdd.{u1, u3, u4, u6} R₁ R₃ M M₃ _inst_1 _inst_3 _inst_4 _inst_6 _inst_10 _inst_12 σ₁₃)) (LinearMap.comp.{u1, u2, u3, u4, u5, u6} R₁ R₂ R₃ M M₂ M₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_10 _inst_11 _inst_12 σ₁₂ σ₂₃ σ₁₃ _inst_16 h f) (LinearMap.comp.{u1, u2, u3, u4, u5, u6} R₁ R₂ R₃ M M₂ M₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_10 _inst_11 _inst_12 σ₁₂ σ₂₃ σ₁₃ _inst_16 g f))
but is expected to have type
  forall {R₁ : Type.{u6}} {R₂ : Type.{u5}} {R₃ : Type.{u2}} {M : Type.{u4}} {M₂ : Type.{u3}} {M₃ : Type.{u1}} [_inst_1 : Semiring.{u6} R₁] [_inst_2 : Semiring.{u5} R₂] [_inst_3 : Semiring.{u2} R₃] [_inst_4 : AddCommMonoid.{u4} M] [_inst_5 : AddCommMonoid.{u3} M₂] [_inst_6 : AddCommMonoid.{u1} M₃] [_inst_10 : Module.{u6, u4} R₁ M _inst_1 _inst_4] [_inst_11 : Module.{u5, u3} R₂ M₂ _inst_2 _inst_5] [_inst_12 : Module.{u2, u1} R₃ M₃ _inst_3 _inst_6] {σ₁₂ : RingHom.{u6, u5} R₁ R₂ (Semiring.toNonAssocSemiring.{u6} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u5} R₂ _inst_2)} {σ₂₃ : RingHom.{u5, u2} R₂ R₃ (Semiring.toNonAssocSemiring.{u5} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u2} R₃ _inst_3)} {σ₁₃ : RingHom.{u6, u2} R₁ R₃ (Semiring.toNonAssocSemiring.{u6} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₃ _inst_3)} [_inst_16 : RingHomCompTriple.{u6, u5, u2} R₁ R₂ R₃ _inst_1 _inst_2 _inst_3 σ₁₂ σ₂₃ σ₁₃] (f : LinearMap.{u6, u5, u4, u3} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (g : LinearMap.{u5, u2, u3, u1} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ M₃ _inst_5 _inst_6 _inst_11 _inst_12) (h : LinearMap.{u5, u2, u3, u1} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ M₃ _inst_5 _inst_6 _inst_11 _inst_12), Eq.{max (succ u4) (succ u1)} (LinearMap.{u6, u2, u4, u1} R₁ R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.comp.{u6, u5, u2, u4, u3, u1} R₁ R₂ R₃ M M₂ M₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_10 _inst_11 _inst_12 σ₁₂ σ₂₃ σ₁₃ _inst_16 (HAdd.hAdd.{max u3 u1, max u3 u1, max u3 u1} (LinearMap.{u5, u2, u3, u1} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ M₃ _inst_5 _inst_6 _inst_11 _inst_12) (LinearMap.{u5, u2, u3, u1} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ M₃ _inst_5 _inst_6 _inst_11 _inst_12) (LinearMap.{u5, u2, u3, u1} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ M₃ _inst_5 _inst_6 _inst_11 _inst_12) (instHAdd.{max u3 u1} (LinearMap.{u5, u2, u3, u1} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ M₃ _inst_5 _inst_6 _inst_11 _inst_12) (LinearMap.instAddLinearMap.{u5, u2, u3, u1} R₂ R₃ M₂ M₃ _inst_2 _inst_3 _inst_5 _inst_6 _inst_11 _inst_12 σ₂₃)) h g) f) (HAdd.hAdd.{max u4 u1, max u4 u1, max u4 u1} (LinearMap.{u6, u2, u4, u1} R₁ R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.{u6, u2, u4, u1} R₁ R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.{u6, u2, u4, u1} R₁ R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_10 _inst_12) (instHAdd.{max u4 u1} (LinearMap.{u6, u2, u4, u1} R₁ R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.instAddLinearMap.{u6, u2, u4, u1} R₁ R₃ M M₃ _inst_1 _inst_3 _inst_4 _inst_6 _inst_10 _inst_12 σ₁₃)) (LinearMap.comp.{u6, u5, u2, u4, u3, u1} R₁ R₂ R₃ M M₂ M₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_10 _inst_11 _inst_12 σ₁₂ σ₂₃ σ₁₃ _inst_16 h f) (LinearMap.comp.{u6, u5, u2, u4, u3, u1} R₁ R₂ R₃ M M₂ M₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_10 _inst_11 _inst_12 σ₁₂ σ₂₃ σ₁₃ _inst_16 g f))
Case conversion may be inaccurate. Consider using '#align linear_map.add_comp LinearMap.add_compₓ'. -/
theorem add_comp (f : M →ₛₗ[σ₁₂] M₂) (g h : M₂ →ₛₗ[σ₂₃] M₃) :
    ((h + g).comp f : M →ₛₗ[σ₁₃] M₃) = h.comp f + g.comp f :=
  rfl
#align linear_map.add_comp LinearMap.add_comp

/- warning: linear_map.comp_add -> LinearMap.comp_add is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {R₃ : Type.{u3}} {M : Type.{u4}} {M₂ : Type.{u5}} {M₃ : Type.{u6}} [_inst_1 : Semiring.{u1} R₁] [_inst_2 : Semiring.{u2} R₂] [_inst_3 : Semiring.{u3} R₃] [_inst_4 : AddCommMonoid.{u4} M] [_inst_5 : AddCommMonoid.{u5} M₂] [_inst_6 : AddCommMonoid.{u6} M₃] [_inst_10 : Module.{u1, u4} R₁ M _inst_1 _inst_4] [_inst_11 : Module.{u2, u5} R₂ M₂ _inst_2 _inst_5] [_inst_12 : Module.{u3, u6} R₃ M₃ _inst_3 _inst_6] {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)} {σ₂₃ : RingHom.{u2, u3} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_3)} {σ₁₃ : RingHom.{u1, u3} R₁ R₃ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_3)} [_inst_16 : RingHomCompTriple.{u1, u2, u3} R₁ R₂ R₃ _inst_1 _inst_2 _inst_3 σ₁₂ σ₂₃ σ₁₃] (f : LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (g : LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (h : LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ M₃ _inst_5 _inst_6 _inst_11 _inst_12), Eq.{max (succ u4) (succ u6)} (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.comp.{u1, u2, u3, u4, u5, u6} R₁ R₂ R₃ M M₂ M₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_10 _inst_11 _inst_12 σ₁₂ σ₂₃ σ₁₃ _inst_16 h (HAdd.hAdd.{max u4 u5, max u4 u5, max u4 u5} (LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (instHAdd.{max u4 u5} (LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (LinearMap.hasAdd.{u1, u2, u4, u5} R₁ R₂ M M₂ _inst_1 _inst_2 _inst_4 _inst_5 _inst_10 _inst_11 σ₁₂)) f g)) (HAdd.hAdd.{max u4 u6, max u4 u6, max u4 u6} (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_10 _inst_12) (instHAdd.{max u4 u6} (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.hasAdd.{u1, u3, u4, u6} R₁ R₃ M M₃ _inst_1 _inst_3 _inst_4 _inst_6 _inst_10 _inst_12 σ₁₃)) (LinearMap.comp.{u1, u2, u3, u4, u5, u6} R₁ R₂ R₃ M M₂ M₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_10 _inst_11 _inst_12 σ₁₂ σ₂₃ σ₁₃ _inst_16 h f) (LinearMap.comp.{u1, u2, u3, u4, u5, u6} R₁ R₂ R₃ M M₂ M₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_10 _inst_11 _inst_12 σ₁₂ σ₂₃ σ₁₃ _inst_16 h g))
but is expected to have type
  forall {R₁ : Type.{u6}} {R₂ : Type.{u5}} {R₃ : Type.{u2}} {M : Type.{u4}} {M₂ : Type.{u3}} {M₃ : Type.{u1}} [_inst_1 : Semiring.{u6} R₁] [_inst_2 : Semiring.{u5} R₂] [_inst_3 : Semiring.{u2} R₃] [_inst_4 : AddCommMonoid.{u4} M] [_inst_5 : AddCommMonoid.{u3} M₂] [_inst_6 : AddCommMonoid.{u1} M₃] [_inst_10 : Module.{u6, u4} R₁ M _inst_1 _inst_4] [_inst_11 : Module.{u5, u3} R₂ M₂ _inst_2 _inst_5] [_inst_12 : Module.{u2, u1} R₃ M₃ _inst_3 _inst_6] {σ₁₂ : RingHom.{u6, u5} R₁ R₂ (Semiring.toNonAssocSemiring.{u6} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u5} R₂ _inst_2)} {σ₂₃ : RingHom.{u5, u2} R₂ R₃ (Semiring.toNonAssocSemiring.{u5} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u2} R₃ _inst_3)} {σ₁₃ : RingHom.{u6, u2} R₁ R₃ (Semiring.toNonAssocSemiring.{u6} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₃ _inst_3)} [_inst_16 : RingHomCompTriple.{u6, u5, u2} R₁ R₂ R₃ _inst_1 _inst_2 _inst_3 σ₁₂ σ₂₃ σ₁₃] (f : LinearMap.{u6, u5, u4, u3} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (g : LinearMap.{u6, u5, u4, u3} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (h : LinearMap.{u5, u2, u3, u1} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ M₃ _inst_5 _inst_6 _inst_11 _inst_12), Eq.{max (succ u4) (succ u1)} (LinearMap.{u6, u2, u4, u1} R₁ R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.comp.{u6, u5, u2, u4, u3, u1} R₁ R₂ R₃ M M₂ M₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_10 _inst_11 _inst_12 σ₁₂ σ₂₃ σ₁₃ _inst_16 h (HAdd.hAdd.{max u4 u3, max u4 u3, max u4 u3} (LinearMap.{u6, u5, u4, u3} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (LinearMap.{u6, u5, u4, u3} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (LinearMap.{u6, u5, u4, u3} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (instHAdd.{max u4 u3} (LinearMap.{u6, u5, u4, u3} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (LinearMap.instAddLinearMap.{u6, u5, u4, u3} R₁ R₂ M M₂ _inst_1 _inst_2 _inst_4 _inst_5 _inst_10 _inst_11 σ₁₂)) f g)) (HAdd.hAdd.{max u4 u1, max u4 u1, max u4 u1} (LinearMap.{u6, u2, u4, u1} R₁ R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.{u6, u2, u4, u1} R₁ R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.{u6, u2, u4, u1} R₁ R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_10 _inst_12) (instHAdd.{max u4 u1} (LinearMap.{u6, u2, u4, u1} R₁ R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.instAddLinearMap.{u6, u2, u4, u1} R₁ R₃ M M₃ _inst_1 _inst_3 _inst_4 _inst_6 _inst_10 _inst_12 σ₁₃)) (LinearMap.comp.{u6, u5, u2, u4, u3, u1} R₁ R₂ R₃ M M₂ M₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_10 _inst_11 _inst_12 σ₁₂ σ₂₃ σ₁₃ _inst_16 h f) (LinearMap.comp.{u6, u5, u2, u4, u3, u1} R₁ R₂ R₃ M M₂ M₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_10 _inst_11 _inst_12 σ₁₂ σ₂₃ σ₁₃ _inst_16 h g))
Case conversion may be inaccurate. Consider using '#align linear_map.comp_add LinearMap.comp_addₓ'. -/
theorem comp_add (f g : M →ₛₗ[σ₁₂] M₂) (h : M₂ →ₛₗ[σ₂₃] M₃) :
    (h.comp (f + g) : M →ₛₗ[σ₁₃] M₃) = h.comp f + h.comp g :=
  ext fun _ => h.map_add _ _
#align linear_map.comp_add LinearMap.comp_add

/-- The type of linear maps is an additive monoid. -/
instance : AddCommMonoid (M →ₛₗ[σ₁₂] M₂) :=
  FunLike.coe_injective.AddCommMonoid _ rfl (fun _ _ => rfl) fun _ _ => rfl

/-- The negation of a linear map is linear. -/
instance : Neg (M →ₛₗ[σ₁₂] N₂) :=
  ⟨fun f =>
    { toFun := -f
      map_add' := by simp [add_comm]
      map_smul' := by simp }⟩

/- warning: linear_map.neg_apply -> LinearMap.neg_apply is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {M : Type.{u3}} {N₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R₁] [_inst_2 : Semiring.{u2} R₂] [_inst_4 : AddCommMonoid.{u3} M] [_inst_8 : AddCommGroup.{u4} N₂] [_inst_10 : Module.{u1, u3} R₁ M _inst_1 _inst_4] [_inst_14 : Module.{u2, u4} R₂ N₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u4} N₂ _inst_8)] {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)} (f : LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u4} N₂ _inst_8) _inst_10 _inst_14) (x : M), Eq.{succ u4} N₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u4} N₂ _inst_8) _inst_10 _inst_14) (fun (_x : LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u4} N₂ _inst_8) _inst_10 _inst_14) => M -> N₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R₁ R₂ M N₂ _inst_1 _inst_2 _inst_4 (AddCommGroup.toAddCommMonoid.{u4} N₂ _inst_8) _inst_10 _inst_14 σ₁₂) (Neg.neg.{max u3 u4} (LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u4} N₂ _inst_8) _inst_10 _inst_14) (LinearMap.hasNeg.{u1, u2, u3, u4} R₁ R₂ M N₂ _inst_1 _inst_2 _inst_4 _inst_8 _inst_10 _inst_14 σ₁₂) f) x) (Neg.neg.{u4} N₂ (SubNegMonoid.toHasNeg.{u4} N₂ (AddGroup.toSubNegMonoid.{u4} N₂ (AddCommGroup.toAddGroup.{u4} N₂ _inst_8))) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u4} N₂ _inst_8) _inst_10 _inst_14) (fun (_x : LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u4} N₂ _inst_8) _inst_10 _inst_14) => M -> N₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R₁ R₂ M N₂ _inst_1 _inst_2 _inst_4 (AddCommGroup.toAddCommMonoid.{u4} N₂ _inst_8) _inst_10 _inst_14 σ₁₂) f x))
but is expected to have type
  forall {R₁ : Type.{u4}} {R₂ : Type.{u3}} {M : Type.{u2}} {N₂ : Type.{u1}} [_inst_1 : Semiring.{u4} R₁] [_inst_2 : Semiring.{u3} R₂] [_inst_4 : AddCommMonoid.{u2} M] [_inst_8 : AddCommGroup.{u1} N₂] [_inst_10 : Module.{u4, u2} R₁ M _inst_1 _inst_4] [_inst_14 : Module.{u3, u1} R₂ N₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u1} N₂ _inst_8)] {σ₁₂ : RingHom.{u4, u3} R₁ R₂ (Semiring.toNonAssocSemiring.{u4} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u3} R₂ _inst_2)} (f : LinearMap.{u4, u3, u2, u1} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u1} N₂ _inst_8) _inst_10 _inst_14) (x : M), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => N₂) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u4, u3, u2, u1} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u1} N₂ _inst_8) _inst_10 _inst_14) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => N₂) _x) (LinearMap.instFunLikeLinearMap.{u4, u3, u2, u1} R₁ R₂ M N₂ _inst_1 _inst_2 _inst_4 (AddCommGroup.toAddCommMonoid.{u1} N₂ _inst_8) _inst_10 _inst_14 σ₁₂) (Neg.neg.{max u2 u1} (LinearMap.{u4, u3, u2, u1} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u1} N₂ _inst_8) _inst_10 _inst_14) (LinearMap.instNegLinearMapToAddCommMonoid.{u4, u3, u2, u1} R₁ R₂ M N₂ _inst_1 _inst_2 _inst_4 _inst_8 _inst_10 _inst_14 σ₁₂) f) x) (Neg.neg.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => N₂) x) (NegZeroClass.toNeg.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => N₂) x) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => N₂) x) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => N₂) x) (SubtractionCommMonoid.toSubtractionMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => N₂) x) (AddCommGroup.toDivisionAddCommMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => N₂) x) _inst_8))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u4, u3, u2, u1} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u1} N₂ _inst_8) _inst_10 _inst_14) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => N₂) _x) (LinearMap.instFunLikeLinearMap.{u4, u3, u2, u1} R₁ R₂ M N₂ _inst_1 _inst_2 _inst_4 (AddCommGroup.toAddCommMonoid.{u1} N₂ _inst_8) _inst_10 _inst_14 σ₁₂) f x))
Case conversion may be inaccurate. Consider using '#align linear_map.neg_apply LinearMap.neg_applyₓ'. -/
@[simp]
theorem neg_apply (f : M →ₛₗ[σ₁₂] N₂) (x : M) : (-f) x = -f x :=
  rfl
#align linear_map.neg_apply LinearMap.neg_apply

include σ₁₃

/- warning: linear_map.neg_comp -> LinearMap.neg_comp is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {R₃ : Type.{u3}} {M : Type.{u4}} {M₂ : Type.{u5}} {N₃ : Type.{u6}} [_inst_1 : Semiring.{u1} R₁] [_inst_2 : Semiring.{u2} R₂] [_inst_3 : Semiring.{u3} R₃] [_inst_4 : AddCommMonoid.{u4} M] [_inst_5 : AddCommMonoid.{u5} M₂] [_inst_9 : AddCommGroup.{u6} N₃] [_inst_10 : Module.{u1, u4} R₁ M _inst_1 _inst_4] [_inst_11 : Module.{u2, u5} R₂ M₂ _inst_2 _inst_5] [_inst_15 : Module.{u3, u6} R₃ N₃ _inst_3 (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9)] {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)} {σ₂₃ : RingHom.{u2, u3} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_3)} {σ₁₃ : RingHom.{u1, u3} R₁ R₃ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_3)} [_inst_16 : RingHomCompTriple.{u1, u2, u3} R₁ R₂ R₃ _inst_1 _inst_2 _inst_3 σ₁₂ σ₂₃ σ₁₃] (f : LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (g : LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ N₃ _inst_5 (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9) _inst_11 _inst_15), Eq.{max (succ u4) (succ u6)} (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_1 _inst_3 σ₁₃ M N₃ _inst_4 (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9) _inst_10 _inst_15) (LinearMap.comp.{u1, u2, u3, u4, u5, u6} R₁ R₂ R₃ M M₂ N₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9) _inst_10 _inst_11 _inst_15 σ₁₂ σ₂₃ σ₁₃ _inst_16 (Neg.neg.{max u5 u6} (LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ N₃ _inst_5 (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9) _inst_11 _inst_15) (LinearMap.hasNeg.{u2, u3, u5, u6} R₂ R₃ M₂ N₃ _inst_2 _inst_3 _inst_5 _inst_9 _inst_11 _inst_15 σ₂₃) g) f) (Neg.neg.{max u4 u6} (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_1 _inst_3 σ₁₃ M N₃ _inst_4 (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9) _inst_10 _inst_15) (LinearMap.hasNeg.{u1, u3, u4, u6} R₁ R₃ M N₃ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10 _inst_15 σ₁₃) (LinearMap.comp.{u1, u2, u3, u4, u5, u6} R₁ R₂ R₃ M M₂ N₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9) _inst_10 _inst_11 _inst_15 σ₁₂ σ₂₃ σ₁₃ _inst_16 g f))
but is expected to have type
  forall {R₁ : Type.{u6}} {R₂ : Type.{u5}} {R₃ : Type.{u2}} {M : Type.{u4}} {M₂ : Type.{u3}} {N₃ : Type.{u1}} [_inst_1 : Semiring.{u6} R₁] [_inst_2 : Semiring.{u5} R₂] [_inst_3 : Semiring.{u2} R₃] [_inst_4 : AddCommMonoid.{u4} M] [_inst_5 : AddCommMonoid.{u3} M₂] [_inst_9 : AddCommGroup.{u1} N₃] [_inst_10 : Module.{u6, u4} R₁ M _inst_1 _inst_4] [_inst_11 : Module.{u5, u3} R₂ M₂ _inst_2 _inst_5] [_inst_15 : Module.{u2, u1} R₃ N₃ _inst_3 (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9)] {σ₁₂ : RingHom.{u6, u5} R₁ R₂ (Semiring.toNonAssocSemiring.{u6} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u5} R₂ _inst_2)} {σ₂₃ : RingHom.{u5, u2} R₂ R₃ (Semiring.toNonAssocSemiring.{u5} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u2} R₃ _inst_3)} {σ₁₃ : RingHom.{u6, u2} R₁ R₃ (Semiring.toNonAssocSemiring.{u6} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₃ _inst_3)} [_inst_16 : RingHomCompTriple.{u6, u5, u2} R₁ R₂ R₃ _inst_1 _inst_2 _inst_3 σ₁₂ σ₂₃ σ₁₃] (f : LinearMap.{u6, u5, u4, u3} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (g : LinearMap.{u5, u2, u3, u1} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ N₃ _inst_5 (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9) _inst_11 _inst_15), Eq.{max (succ u4) (succ u1)} (LinearMap.{u6, u2, u4, u1} R₁ R₃ _inst_1 _inst_3 σ₁₃ M N₃ _inst_4 (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9) _inst_10 _inst_15) (LinearMap.comp.{u6, u5, u2, u4, u3, u1} R₁ R₂ R₃ M M₂ N₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9) _inst_10 _inst_11 _inst_15 σ₁₂ σ₂₃ σ₁₃ _inst_16 (Neg.neg.{max u3 u1} (LinearMap.{u5, u2, u3, u1} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ N₃ _inst_5 (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9) _inst_11 _inst_15) (LinearMap.instNegLinearMapToAddCommMonoid.{u5, u2, u3, u1} R₂ R₃ M₂ N₃ _inst_2 _inst_3 _inst_5 _inst_9 _inst_11 _inst_15 σ₂₃) g) f) (Neg.neg.{max u4 u1} (LinearMap.{u6, u2, u4, u1} R₁ R₃ _inst_1 _inst_3 σ₁₃ M N₃ _inst_4 (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9) _inst_10 _inst_15) (LinearMap.instNegLinearMapToAddCommMonoid.{u6, u2, u4, u1} R₁ R₃ M N₃ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10 _inst_15 σ₁₃) (LinearMap.comp.{u6, u5, u2, u4, u3, u1} R₁ R₂ R₃ M M₂ N₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9) _inst_10 _inst_11 _inst_15 σ₁₂ σ₂₃ σ₁₃ _inst_16 g f))
Case conversion may be inaccurate. Consider using '#align linear_map.neg_comp LinearMap.neg_compₓ'. -/
@[simp]
theorem neg_comp (f : M →ₛₗ[σ₁₂] M₂) (g : M₂ →ₛₗ[σ₂₃] N₃) : (-g).comp f = -g.comp f :=
  rfl
#align linear_map.neg_comp LinearMap.neg_comp

/- warning: linear_map.comp_neg -> LinearMap.comp_neg is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {R₃ : Type.{u3}} {M : Type.{u4}} {N₂ : Type.{u5}} {N₃ : Type.{u6}} [_inst_1 : Semiring.{u1} R₁] [_inst_2 : Semiring.{u2} R₂] [_inst_3 : Semiring.{u3} R₃] [_inst_4 : AddCommMonoid.{u4} M] [_inst_8 : AddCommGroup.{u5} N₂] [_inst_9 : AddCommGroup.{u6} N₃] [_inst_10 : Module.{u1, u4} R₁ M _inst_1 _inst_4] [_inst_14 : Module.{u2, u5} R₂ N₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u5} N₂ _inst_8)] [_inst_15 : Module.{u3, u6} R₃ N₃ _inst_3 (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9)] {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)} {σ₂₃ : RingHom.{u2, u3} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_3)} {σ₁₃ : RingHom.{u1, u3} R₁ R₃ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_3)} [_inst_16 : RingHomCompTriple.{u1, u2, u3} R₁ R₂ R₃ _inst_1 _inst_2 _inst_3 σ₁₂ σ₂₃ σ₁₃] (f : LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u5} N₂ _inst_8) _inst_10 _inst_14) (g : LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_2 _inst_3 σ₂₃ N₂ N₃ (AddCommGroup.toAddCommMonoid.{u5} N₂ _inst_8) (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9) _inst_14 _inst_15), Eq.{max (succ u4) (succ u6)} (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_1 _inst_3 σ₁₃ M N₃ _inst_4 (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9) _inst_10 _inst_15) (LinearMap.comp.{u1, u2, u3, u4, u5, u6} R₁ R₂ R₃ M N₂ N₃ _inst_1 _inst_2 _inst_3 _inst_4 (AddCommGroup.toAddCommMonoid.{u5} N₂ _inst_8) (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9) _inst_10 _inst_14 _inst_15 σ₁₂ σ₂₃ σ₁₃ _inst_16 g (Neg.neg.{max u4 u5} (LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u5} N₂ _inst_8) _inst_10 _inst_14) (LinearMap.hasNeg.{u1, u2, u4, u5} R₁ R₂ M N₂ _inst_1 _inst_2 _inst_4 _inst_8 _inst_10 _inst_14 σ₁₂) f)) (Neg.neg.{max u4 u6} (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_1 _inst_3 σ₁₃ M N₃ _inst_4 (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9) _inst_10 _inst_15) (LinearMap.hasNeg.{u1, u3, u4, u6} R₁ R₃ M N₃ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10 _inst_15 σ₁₃) (LinearMap.comp.{u1, u2, u3, u4, u5, u6} R₁ R₂ R₃ M N₂ N₃ _inst_1 _inst_2 _inst_3 _inst_4 (AddCommGroup.toAddCommMonoid.{u5} N₂ _inst_8) (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9) _inst_10 _inst_14 _inst_15 σ₁₂ σ₂₃ σ₁₃ _inst_16 g f))
but is expected to have type
  forall {R₁ : Type.{u6}} {R₂ : Type.{u5}} {R₃ : Type.{u2}} {M : Type.{u4}} {N₂ : Type.{u3}} {N₃ : Type.{u1}} [_inst_1 : Semiring.{u6} R₁] [_inst_2 : Semiring.{u5} R₂] [_inst_3 : Semiring.{u2} R₃] [_inst_4 : AddCommMonoid.{u4} M] [_inst_8 : AddCommGroup.{u3} N₂] [_inst_9 : AddCommGroup.{u1} N₃] [_inst_10 : Module.{u6, u4} R₁ M _inst_1 _inst_4] [_inst_14 : Module.{u5, u3} R₂ N₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u3} N₂ _inst_8)] [_inst_15 : Module.{u2, u1} R₃ N₃ _inst_3 (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9)] {σ₁₂ : RingHom.{u6, u5} R₁ R₂ (Semiring.toNonAssocSemiring.{u6} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u5} R₂ _inst_2)} {σ₂₃ : RingHom.{u5, u2} R₂ R₃ (Semiring.toNonAssocSemiring.{u5} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u2} R₃ _inst_3)} {σ₁₃ : RingHom.{u6, u2} R₁ R₃ (Semiring.toNonAssocSemiring.{u6} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₃ _inst_3)} [_inst_16 : RingHomCompTriple.{u6, u5, u2} R₁ R₂ R₃ _inst_1 _inst_2 _inst_3 σ₁₂ σ₂₃ σ₁₃] (f : LinearMap.{u6, u5, u4, u3} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u3} N₂ _inst_8) _inst_10 _inst_14) (g : LinearMap.{u5, u2, u3, u1} R₂ R₃ _inst_2 _inst_3 σ₂₃ N₂ N₃ (AddCommGroup.toAddCommMonoid.{u3} N₂ _inst_8) (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9) _inst_14 _inst_15), Eq.{max (succ u4) (succ u1)} (LinearMap.{u6, u2, u4, u1} R₁ R₃ _inst_1 _inst_3 σ₁₃ M N₃ _inst_4 (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9) _inst_10 _inst_15) (LinearMap.comp.{u6, u5, u2, u4, u3, u1} R₁ R₂ R₃ M N₂ N₃ _inst_1 _inst_2 _inst_3 _inst_4 (AddCommGroup.toAddCommMonoid.{u3} N₂ _inst_8) (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9) _inst_10 _inst_14 _inst_15 σ₁₂ σ₂₃ σ₁₃ _inst_16 g (Neg.neg.{max u4 u3} (LinearMap.{u6, u5, u4, u3} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u3} N₂ _inst_8) _inst_10 _inst_14) (LinearMap.instNegLinearMapToAddCommMonoid.{u6, u5, u4, u3} R₁ R₂ M N₂ _inst_1 _inst_2 _inst_4 _inst_8 _inst_10 _inst_14 σ₁₂) f)) (Neg.neg.{max u4 u1} (LinearMap.{u6, u2, u4, u1} R₁ R₃ _inst_1 _inst_3 σ₁₃ M N₃ _inst_4 (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9) _inst_10 _inst_15) (LinearMap.instNegLinearMapToAddCommMonoid.{u6, u2, u4, u1} R₁ R₃ M N₃ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10 _inst_15 σ₁₃) (LinearMap.comp.{u6, u5, u2, u4, u3, u1} R₁ R₂ R₃ M N₂ N₃ _inst_1 _inst_2 _inst_3 _inst_4 (AddCommGroup.toAddCommMonoid.{u3} N₂ _inst_8) (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9) _inst_10 _inst_14 _inst_15 σ₁₂ σ₂₃ σ₁₃ _inst_16 g f))
Case conversion may be inaccurate. Consider using '#align linear_map.comp_neg LinearMap.comp_negₓ'. -/
@[simp]
theorem comp_neg (f : M →ₛₗ[σ₁₂] N₂) (g : N₂ →ₛₗ[σ₂₃] N₃) : g.comp (-f) = -g.comp f :=
  ext fun _ => g.map_neg _
#align linear_map.comp_neg LinearMap.comp_neg

omit σ₁₃

/-- The subtraction of two linear maps is linear. -/
instance : Sub (M →ₛₗ[σ₁₂] N₂) :=
  ⟨fun f g =>
    { toFun := f - g
      map_add' := fun x y => by simp only [Pi.sub_apply, map_add, add_sub_add_comm]
      map_smul' := fun r x => by simp [Pi.sub_apply, map_smul, smul_sub] }⟩

/- warning: linear_map.sub_apply -> LinearMap.sub_apply is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {M : Type.{u3}} {N₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R₁] [_inst_2 : Semiring.{u2} R₂] [_inst_4 : AddCommMonoid.{u3} M] [_inst_8 : AddCommGroup.{u4} N₂] [_inst_10 : Module.{u1, u3} R₁ M _inst_1 _inst_4] [_inst_14 : Module.{u2, u4} R₂ N₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u4} N₂ _inst_8)] {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)} (f : LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u4} N₂ _inst_8) _inst_10 _inst_14) (g : LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u4} N₂ _inst_8) _inst_10 _inst_14) (x : M), Eq.{succ u4} N₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u4} N₂ _inst_8) _inst_10 _inst_14) (fun (_x : LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u4} N₂ _inst_8) _inst_10 _inst_14) => M -> N₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R₁ R₂ M N₂ _inst_1 _inst_2 _inst_4 (AddCommGroup.toAddCommMonoid.{u4} N₂ _inst_8) _inst_10 _inst_14 σ₁₂) (HSub.hSub.{max u3 u4, max u3 u4, max u3 u4} (LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u4} N₂ _inst_8) _inst_10 _inst_14) (LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u4} N₂ _inst_8) _inst_10 _inst_14) (LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u4} N₂ _inst_8) _inst_10 _inst_14) (instHSub.{max u3 u4} (LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u4} N₂ _inst_8) _inst_10 _inst_14) (LinearMap.hasSub.{u1, u2, u3, u4} R₁ R₂ M N₂ _inst_1 _inst_2 _inst_4 _inst_8 _inst_10 _inst_14 σ₁₂)) f g) x) (HSub.hSub.{u4, u4, u4} N₂ N₂ N₂ (instHSub.{u4} N₂ (SubNegMonoid.toHasSub.{u4} N₂ (AddGroup.toSubNegMonoid.{u4} N₂ (AddCommGroup.toAddGroup.{u4} N₂ _inst_8)))) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u4} N₂ _inst_8) _inst_10 _inst_14) (fun (_x : LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u4} N₂ _inst_8) _inst_10 _inst_14) => M -> N₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R₁ R₂ M N₂ _inst_1 _inst_2 _inst_4 (AddCommGroup.toAddCommMonoid.{u4} N₂ _inst_8) _inst_10 _inst_14 σ₁₂) f x) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u4} N₂ _inst_8) _inst_10 _inst_14) (fun (_x : LinearMap.{u1, u2, u3, u4} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u4} N₂ _inst_8) _inst_10 _inst_14) => M -> N₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R₁ R₂ M N₂ _inst_1 _inst_2 _inst_4 (AddCommGroup.toAddCommMonoid.{u4} N₂ _inst_8) _inst_10 _inst_14 σ₁₂) g x))
but is expected to have type
  forall {R₁ : Type.{u4}} {R₂ : Type.{u3}} {M : Type.{u2}} {N₂ : Type.{u1}} [_inst_1 : Semiring.{u4} R₁] [_inst_2 : Semiring.{u3} R₂] [_inst_4 : AddCommMonoid.{u2} M] [_inst_8 : AddCommGroup.{u1} N₂] [_inst_10 : Module.{u4, u2} R₁ M _inst_1 _inst_4] [_inst_14 : Module.{u3, u1} R₂ N₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u1} N₂ _inst_8)] {σ₁₂ : RingHom.{u4, u3} R₁ R₂ (Semiring.toNonAssocSemiring.{u4} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u3} R₂ _inst_2)} (f : LinearMap.{u4, u3, u2, u1} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u1} N₂ _inst_8) _inst_10 _inst_14) (g : LinearMap.{u4, u3, u2, u1} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u1} N₂ _inst_8) _inst_10 _inst_14) (x : M), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => N₂) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u4, u3, u2, u1} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u1} N₂ _inst_8) _inst_10 _inst_14) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => N₂) _x) (LinearMap.instFunLikeLinearMap.{u4, u3, u2, u1} R₁ R₂ M N₂ _inst_1 _inst_2 _inst_4 (AddCommGroup.toAddCommMonoid.{u1} N₂ _inst_8) _inst_10 _inst_14 σ₁₂) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (LinearMap.{u4, u3, u2, u1} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u1} N₂ _inst_8) _inst_10 _inst_14) (LinearMap.{u4, u3, u2, u1} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u1} N₂ _inst_8) _inst_10 _inst_14) (LinearMap.{u4, u3, u2, u1} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u1} N₂ _inst_8) _inst_10 _inst_14) (instHSub.{max u2 u1} (LinearMap.{u4, u3, u2, u1} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u1} N₂ _inst_8) _inst_10 _inst_14) (LinearMap.instSubLinearMapToAddCommMonoid.{u4, u3, u2, u1} R₁ R₂ M N₂ _inst_1 _inst_2 _inst_4 _inst_8 _inst_10 _inst_14 σ₁₂)) f g) x) (HSub.hSub.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => N₂) x) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => N₂) x) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => N₂) x) (instHSub.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => N₂) x) (SubNegMonoid.toSub.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => N₂) x) (AddGroup.toSubNegMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => N₂) x) (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => N₂) x) _inst_8)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u4, u3, u2, u1} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u1} N₂ _inst_8) _inst_10 _inst_14) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => N₂) _x) (LinearMap.instFunLikeLinearMap.{u4, u3, u2, u1} R₁ R₂ M N₂ _inst_1 _inst_2 _inst_4 (AddCommGroup.toAddCommMonoid.{u1} N₂ _inst_8) _inst_10 _inst_14 σ₁₂) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u4, u3, u2, u1} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u1} N₂ _inst_8) _inst_10 _inst_14) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => N₂) _x) (LinearMap.instFunLikeLinearMap.{u4, u3, u2, u1} R₁ R₂ M N₂ _inst_1 _inst_2 _inst_4 (AddCommGroup.toAddCommMonoid.{u1} N₂ _inst_8) _inst_10 _inst_14 σ₁₂) g x))
Case conversion may be inaccurate. Consider using '#align linear_map.sub_apply LinearMap.sub_applyₓ'. -/
@[simp]
theorem sub_apply (f g : M →ₛₗ[σ₁₂] N₂) (x : M) : (f - g) x = f x - g x :=
  rfl
#align linear_map.sub_apply LinearMap.sub_apply

include σ₁₃

/- warning: linear_map.sub_comp -> LinearMap.sub_comp is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {R₃ : Type.{u3}} {M : Type.{u4}} {M₂ : Type.{u5}} {N₃ : Type.{u6}} [_inst_1 : Semiring.{u1} R₁] [_inst_2 : Semiring.{u2} R₂] [_inst_3 : Semiring.{u3} R₃] [_inst_4 : AddCommMonoid.{u4} M] [_inst_5 : AddCommMonoid.{u5} M₂] [_inst_9 : AddCommGroup.{u6} N₃] [_inst_10 : Module.{u1, u4} R₁ M _inst_1 _inst_4] [_inst_11 : Module.{u2, u5} R₂ M₂ _inst_2 _inst_5] [_inst_15 : Module.{u3, u6} R₃ N₃ _inst_3 (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9)] {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)} {σ₂₃ : RingHom.{u2, u3} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_3)} {σ₁₃ : RingHom.{u1, u3} R₁ R₃ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_3)} [_inst_16 : RingHomCompTriple.{u1, u2, u3} R₁ R₂ R₃ _inst_1 _inst_2 _inst_3 σ₁₂ σ₂₃ σ₁₃] (f : LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (g : LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ N₃ _inst_5 (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9) _inst_11 _inst_15) (h : LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ N₃ _inst_5 (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9) _inst_11 _inst_15), Eq.{max (succ u4) (succ u6)} (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_1 _inst_3 σ₁₃ M N₃ _inst_4 (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9) _inst_10 _inst_15) (LinearMap.comp.{u1, u2, u3, u4, u5, u6} R₁ R₂ R₃ M M₂ N₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9) _inst_10 _inst_11 _inst_15 σ₁₂ σ₂₃ σ₁₃ _inst_16 (HSub.hSub.{max u5 u6, max u5 u6, max u5 u6} (LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ N₃ _inst_5 (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9) _inst_11 _inst_15) (LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ N₃ _inst_5 (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9) _inst_11 _inst_15) (LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ N₃ _inst_5 (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9) _inst_11 _inst_15) (instHSub.{max u5 u6} (LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ N₃ _inst_5 (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9) _inst_11 _inst_15) (LinearMap.hasSub.{u2, u3, u5, u6} R₂ R₃ M₂ N₃ _inst_2 _inst_3 _inst_5 _inst_9 _inst_11 _inst_15 σ₂₃)) g h) f) (HSub.hSub.{max u4 u6, max u4 u6, max u4 u6} (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_1 _inst_3 σ₁₃ M N₃ _inst_4 (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9) _inst_10 _inst_15) (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_1 _inst_3 σ₁₃ M N₃ _inst_4 (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9) _inst_10 _inst_15) (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_1 _inst_3 σ₁₃ M N₃ _inst_4 (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9) _inst_10 _inst_15) (instHSub.{max u4 u6} (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_1 _inst_3 σ₁₃ M N₃ _inst_4 (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9) _inst_10 _inst_15) (LinearMap.hasSub.{u1, u3, u4, u6} R₁ R₃ M N₃ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10 _inst_15 σ₁₃)) (LinearMap.comp.{u1, u2, u3, u4, u5, u6} R₁ R₂ R₃ M M₂ N₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9) _inst_10 _inst_11 _inst_15 σ₁₂ σ₂₃ σ₁₃ _inst_16 g f) (LinearMap.comp.{u1, u2, u3, u4, u5, u6} R₁ R₂ R₃ M M₂ N₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9) _inst_10 _inst_11 _inst_15 σ₁₂ σ₂₃ σ₁₃ _inst_16 h f))
but is expected to have type
  forall {R₁ : Type.{u6}} {R₂ : Type.{u5}} {R₃ : Type.{u2}} {M : Type.{u4}} {M₂ : Type.{u3}} {N₃ : Type.{u1}} [_inst_1 : Semiring.{u6} R₁] [_inst_2 : Semiring.{u5} R₂] [_inst_3 : Semiring.{u2} R₃] [_inst_4 : AddCommMonoid.{u4} M] [_inst_5 : AddCommMonoid.{u3} M₂] [_inst_9 : AddCommGroup.{u1} N₃] [_inst_10 : Module.{u6, u4} R₁ M _inst_1 _inst_4] [_inst_11 : Module.{u5, u3} R₂ M₂ _inst_2 _inst_5] [_inst_15 : Module.{u2, u1} R₃ N₃ _inst_3 (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9)] {σ₁₂ : RingHom.{u6, u5} R₁ R₂ (Semiring.toNonAssocSemiring.{u6} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u5} R₂ _inst_2)} {σ₂₃ : RingHom.{u5, u2} R₂ R₃ (Semiring.toNonAssocSemiring.{u5} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u2} R₃ _inst_3)} {σ₁₃ : RingHom.{u6, u2} R₁ R₃ (Semiring.toNonAssocSemiring.{u6} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₃ _inst_3)} [_inst_16 : RingHomCompTriple.{u6, u5, u2} R₁ R₂ R₃ _inst_1 _inst_2 _inst_3 σ₁₂ σ₂₃ σ₁₃] (f : LinearMap.{u6, u5, u4, u3} R₁ R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_10 _inst_11) (g : LinearMap.{u5, u2, u3, u1} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ N₃ _inst_5 (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9) _inst_11 _inst_15) (h : LinearMap.{u5, u2, u3, u1} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ N₃ _inst_5 (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9) _inst_11 _inst_15), Eq.{max (succ u4) (succ u1)} (LinearMap.{u6, u2, u4, u1} R₁ R₃ _inst_1 _inst_3 σ₁₃ M N₃ _inst_4 (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9) _inst_10 _inst_15) (LinearMap.comp.{u6, u5, u2, u4, u3, u1} R₁ R₂ R₃ M M₂ N₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9) _inst_10 _inst_11 _inst_15 σ₁₂ σ₂₃ σ₁₃ _inst_16 (HSub.hSub.{max u3 u1, max u3 u1, max u3 u1} (LinearMap.{u5, u2, u3, u1} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ N₃ _inst_5 (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9) _inst_11 _inst_15) (LinearMap.{u5, u2, u3, u1} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ N₃ _inst_5 (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9) _inst_11 _inst_15) (LinearMap.{u5, u2, u3, u1} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ N₃ _inst_5 (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9) _inst_11 _inst_15) (instHSub.{max u3 u1} (LinearMap.{u5, u2, u3, u1} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ N₃ _inst_5 (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9) _inst_11 _inst_15) (LinearMap.instSubLinearMapToAddCommMonoid.{u5, u2, u3, u1} R₂ R₃ M₂ N₃ _inst_2 _inst_3 _inst_5 _inst_9 _inst_11 _inst_15 σ₂₃)) g h) f) (HSub.hSub.{max u4 u1, max u4 u1, max u4 u1} (LinearMap.{u6, u2, u4, u1} R₁ R₃ _inst_1 _inst_3 σ₁₃ M N₃ _inst_4 (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9) _inst_10 _inst_15) (LinearMap.{u6, u2, u4, u1} R₁ R₃ _inst_1 _inst_3 σ₁₃ M N₃ _inst_4 (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9) _inst_10 _inst_15) (LinearMap.{u6, u2, u4, u1} R₁ R₃ _inst_1 _inst_3 σ₁₃ M N₃ _inst_4 (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9) _inst_10 _inst_15) (instHSub.{max u4 u1} (LinearMap.{u6, u2, u4, u1} R₁ R₃ _inst_1 _inst_3 σ₁₃ M N₃ _inst_4 (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9) _inst_10 _inst_15) (LinearMap.instSubLinearMapToAddCommMonoid.{u6, u2, u4, u1} R₁ R₃ M N₃ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10 _inst_15 σ₁₃)) (LinearMap.comp.{u6, u5, u2, u4, u3, u1} R₁ R₂ R₃ M M₂ N₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9) _inst_10 _inst_11 _inst_15 σ₁₂ σ₂₃ σ₁₃ _inst_16 g f) (LinearMap.comp.{u6, u5, u2, u4, u3, u1} R₁ R₂ R₃ M M₂ N₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9) _inst_10 _inst_11 _inst_15 σ₁₂ σ₂₃ σ₁₃ _inst_16 h f))
Case conversion may be inaccurate. Consider using '#align linear_map.sub_comp LinearMap.sub_compₓ'. -/
theorem sub_comp (f : M →ₛₗ[σ₁₂] M₂) (g h : M₂ →ₛₗ[σ₂₃] N₃) :
    (g - h).comp f = g.comp f - h.comp f :=
  rfl
#align linear_map.sub_comp LinearMap.sub_comp

/- warning: linear_map.comp_sub -> LinearMap.comp_sub is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {R₃ : Type.{u3}} {M : Type.{u4}} {N₂ : Type.{u5}} {N₃ : Type.{u6}} [_inst_1 : Semiring.{u1} R₁] [_inst_2 : Semiring.{u2} R₂] [_inst_3 : Semiring.{u3} R₃] [_inst_4 : AddCommMonoid.{u4} M] [_inst_8 : AddCommGroup.{u5} N₂] [_inst_9 : AddCommGroup.{u6} N₃] [_inst_10 : Module.{u1, u4} R₁ M _inst_1 _inst_4] [_inst_14 : Module.{u2, u5} R₂ N₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u5} N₂ _inst_8)] [_inst_15 : Module.{u3, u6} R₃ N₃ _inst_3 (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9)] {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)} {σ₂₃ : RingHom.{u2, u3} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_3)} {σ₁₃ : RingHom.{u1, u3} R₁ R₃ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_3)} [_inst_16 : RingHomCompTriple.{u1, u2, u3} R₁ R₂ R₃ _inst_1 _inst_2 _inst_3 σ₁₂ σ₂₃ σ₁₃] (f : LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u5} N₂ _inst_8) _inst_10 _inst_14) (g : LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u5} N₂ _inst_8) _inst_10 _inst_14) (h : LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_2 _inst_3 σ₂₃ N₂ N₃ (AddCommGroup.toAddCommMonoid.{u5} N₂ _inst_8) (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9) _inst_14 _inst_15), Eq.{max (succ u4) (succ u6)} (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_1 _inst_3 σ₁₃ M N₃ _inst_4 (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9) _inst_10 _inst_15) (LinearMap.comp.{u1, u2, u3, u4, u5, u6} R₁ R₂ R₃ M N₂ N₃ _inst_1 _inst_2 _inst_3 _inst_4 (AddCommGroup.toAddCommMonoid.{u5} N₂ _inst_8) (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9) _inst_10 _inst_14 _inst_15 σ₁₂ σ₂₃ σ₁₃ _inst_16 h (HSub.hSub.{max u4 u5, max u4 u5, max u4 u5} (LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u5} N₂ _inst_8) _inst_10 _inst_14) (LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u5} N₂ _inst_8) _inst_10 _inst_14) (LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u5} N₂ _inst_8) _inst_10 _inst_14) (instHSub.{max u4 u5} (LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u5} N₂ _inst_8) _inst_10 _inst_14) (LinearMap.hasSub.{u1, u2, u4, u5} R₁ R₂ M N₂ _inst_1 _inst_2 _inst_4 _inst_8 _inst_10 _inst_14 σ₁₂)) g f)) (HSub.hSub.{max u4 u6, max u4 u6, max u4 u6} (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_1 _inst_3 σ₁₃ M N₃ _inst_4 (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9) _inst_10 _inst_15) (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_1 _inst_3 σ₁₃ M N₃ _inst_4 (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9) _inst_10 _inst_15) (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_1 _inst_3 σ₁₃ M N₃ _inst_4 (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9) _inst_10 _inst_15) (instHSub.{max u4 u6} (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_1 _inst_3 σ₁₃ M N₃ _inst_4 (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9) _inst_10 _inst_15) (LinearMap.hasSub.{u1, u3, u4, u6} R₁ R₃ M N₃ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10 _inst_15 σ₁₃)) (LinearMap.comp.{u1, u2, u3, u4, u5, u6} R₁ R₂ R₃ M N₂ N₃ _inst_1 _inst_2 _inst_3 _inst_4 (AddCommGroup.toAddCommMonoid.{u5} N₂ _inst_8) (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9) _inst_10 _inst_14 _inst_15 σ₁₂ σ₂₃ σ₁₃ _inst_16 h g) (LinearMap.comp.{u1, u2, u3, u4, u5, u6} R₁ R₂ R₃ M N₂ N₃ _inst_1 _inst_2 _inst_3 _inst_4 (AddCommGroup.toAddCommMonoid.{u5} N₂ _inst_8) (AddCommGroup.toAddCommMonoid.{u6} N₃ _inst_9) _inst_10 _inst_14 _inst_15 σ₁₂ σ₂₃ σ₁₃ _inst_16 h f))
but is expected to have type
  forall {R₁ : Type.{u6}} {R₂ : Type.{u5}} {R₃ : Type.{u2}} {M : Type.{u4}} {N₂ : Type.{u3}} {N₃ : Type.{u1}} [_inst_1 : Semiring.{u6} R₁] [_inst_2 : Semiring.{u5} R₂] [_inst_3 : Semiring.{u2} R₃] [_inst_4 : AddCommMonoid.{u4} M] [_inst_8 : AddCommGroup.{u3} N₂] [_inst_9 : AddCommGroup.{u1} N₃] [_inst_10 : Module.{u6, u4} R₁ M _inst_1 _inst_4] [_inst_14 : Module.{u5, u3} R₂ N₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u3} N₂ _inst_8)] [_inst_15 : Module.{u2, u1} R₃ N₃ _inst_3 (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9)] {σ₁₂ : RingHom.{u6, u5} R₁ R₂ (Semiring.toNonAssocSemiring.{u6} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u5} R₂ _inst_2)} {σ₂₃ : RingHom.{u5, u2} R₂ R₃ (Semiring.toNonAssocSemiring.{u5} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u2} R₃ _inst_3)} {σ₁₃ : RingHom.{u6, u2} R₁ R₃ (Semiring.toNonAssocSemiring.{u6} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₃ _inst_3)} [_inst_16 : RingHomCompTriple.{u6, u5, u2} R₁ R₂ R₃ _inst_1 _inst_2 _inst_3 σ₁₂ σ₂₃ σ₁₃] (f : LinearMap.{u6, u5, u4, u3} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u3} N₂ _inst_8) _inst_10 _inst_14) (g : LinearMap.{u6, u5, u4, u3} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u3} N₂ _inst_8) _inst_10 _inst_14) (h : LinearMap.{u5, u2, u3, u1} R₂ R₃ _inst_2 _inst_3 σ₂₃ N₂ N₃ (AddCommGroup.toAddCommMonoid.{u3} N₂ _inst_8) (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9) _inst_14 _inst_15), Eq.{max (succ u4) (succ u1)} (LinearMap.{u6, u2, u4, u1} R₁ R₃ _inst_1 _inst_3 σ₁₃ M N₃ _inst_4 (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9) _inst_10 _inst_15) (LinearMap.comp.{u6, u5, u2, u4, u3, u1} R₁ R₂ R₃ M N₂ N₃ _inst_1 _inst_2 _inst_3 _inst_4 (AddCommGroup.toAddCommMonoid.{u3} N₂ _inst_8) (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9) _inst_10 _inst_14 _inst_15 σ₁₂ σ₂₃ σ₁₃ _inst_16 h (HSub.hSub.{max u4 u3, max u4 u3, max u4 u3} (LinearMap.{u6, u5, u4, u3} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u3} N₂ _inst_8) _inst_10 _inst_14) (LinearMap.{u6, u5, u4, u3} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u3} N₂ _inst_8) _inst_10 _inst_14) (LinearMap.{u6, u5, u4, u3} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u3} N₂ _inst_8) _inst_10 _inst_14) (instHSub.{max u4 u3} (LinearMap.{u6, u5, u4, u3} R₁ R₂ _inst_1 _inst_2 σ₁₂ M N₂ _inst_4 (AddCommGroup.toAddCommMonoid.{u3} N₂ _inst_8) _inst_10 _inst_14) (LinearMap.instSubLinearMapToAddCommMonoid.{u6, u5, u4, u3} R₁ R₂ M N₂ _inst_1 _inst_2 _inst_4 _inst_8 _inst_10 _inst_14 σ₁₂)) g f)) (HSub.hSub.{max u4 u1, max u4 u1, max u4 u1} (LinearMap.{u6, u2, u4, u1} R₁ R₃ _inst_1 _inst_3 σ₁₃ M N₃ _inst_4 (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9) _inst_10 _inst_15) (LinearMap.{u6, u2, u4, u1} R₁ R₃ _inst_1 _inst_3 σ₁₃ M N₃ _inst_4 (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9) _inst_10 _inst_15) (LinearMap.{u6, u2, u4, u1} R₁ R₃ _inst_1 _inst_3 σ₁₃ M N₃ _inst_4 (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9) _inst_10 _inst_15) (instHSub.{max u4 u1} (LinearMap.{u6, u2, u4, u1} R₁ R₃ _inst_1 _inst_3 σ₁₃ M N₃ _inst_4 (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9) _inst_10 _inst_15) (LinearMap.instSubLinearMapToAddCommMonoid.{u6, u2, u4, u1} R₁ R₃ M N₃ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10 _inst_15 σ₁₃)) (LinearMap.comp.{u6, u5, u2, u4, u3, u1} R₁ R₂ R₃ M N₂ N₃ _inst_1 _inst_2 _inst_3 _inst_4 (AddCommGroup.toAddCommMonoid.{u3} N₂ _inst_8) (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9) _inst_10 _inst_14 _inst_15 σ₁₂ σ₂₃ σ₁₃ _inst_16 h g) (LinearMap.comp.{u6, u5, u2, u4, u3, u1} R₁ R₂ R₃ M N₂ N₃ _inst_1 _inst_2 _inst_3 _inst_4 (AddCommGroup.toAddCommMonoid.{u3} N₂ _inst_8) (AddCommGroup.toAddCommMonoid.{u1} N₃ _inst_9) _inst_10 _inst_14 _inst_15 σ₁₂ σ₂₃ σ₁₃ _inst_16 h f))
Case conversion may be inaccurate. Consider using '#align linear_map.comp_sub LinearMap.comp_subₓ'. -/
theorem comp_sub (f g : M →ₛₗ[σ₁₂] N₂) (h : N₂ →ₛₗ[σ₂₃] N₃) :
    h.comp (g - f) = h.comp g - h.comp f :=
  ext fun _ => h.map_sub _ _
#align linear_map.comp_sub LinearMap.comp_sub

omit σ₁₃

/-- The type of linear maps is an additive group. -/
instance : AddCommGroup (M →ₛₗ[σ₁₂] N₂) :=
  FunLike.coe_injective.AddCommGroup _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)
    (fun _ _ => rfl) fun _ _ => rfl

end Arithmetic

section Actions

variable [Semiring R] [Semiring R₂] [Semiring R₃]

variable [AddCommMonoid M] [AddCommMonoid M₂] [AddCommMonoid M₃]

variable [Module R M] [Module R₂ M₂] [Module R₃ M₃]

variable {σ₁₂ : R →+* R₂} {σ₂₃ : R₂ →+* R₃} {σ₁₃ : R →+* R₃} [RingHomCompTriple σ₁₂ σ₂₃ σ₁₃]

section SMul

variable [Monoid S] [DistribMulAction S M₂] [SMulCommClass R₂ S M₂]

variable [Monoid S₃] [DistribMulAction S₃ M₃] [SMulCommClass R₃ S₃ M₃]

variable [Monoid T] [DistribMulAction T M₂] [SMulCommClass R₂ T M₂]

instance : DistribMulAction S (M →ₛₗ[σ₁₂] M₂)
    where
  one_smul f := ext fun _ => one_smul _ _
  mul_smul c c' f := ext fun _ => mul_smul _ _ _
  smul_add c f g := ext fun x => smul_add _ _ _
  smul_zero c := ext fun x => smul_zero _

include σ₁₃

/- warning: linear_map.smul_comp -> LinearMap.smul_comp is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {R₂ : Type.{u2}} {R₃ : Type.{u3}} {S₃ : Type.{u4}} {M : Type.{u5}} {M₂ : Type.{u6}} {M₃ : Type.{u7}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} R₂] [_inst_3 : Semiring.{u3} R₃] [_inst_4 : AddCommMonoid.{u5} M] [_inst_5 : AddCommMonoid.{u6} M₂] [_inst_6 : AddCommMonoid.{u7} M₃] [_inst_7 : Module.{u1, u5} R M _inst_1 _inst_4] [_inst_8 : Module.{u2, u6} R₂ M₂ _inst_2 _inst_5] [_inst_9 : Module.{u3, u7} R₃ M₃ _inst_3 _inst_6] {σ₁₂ : RingHom.{u1, u2} R R₂ (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)} {σ₂₃ : RingHom.{u2, u3} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_3)} {σ₁₃ : RingHom.{u1, u3} R R₃ (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_3)} [_inst_10 : RingHomCompTriple.{u1, u2, u3} R R₂ R₃ _inst_1 _inst_2 _inst_3 σ₁₂ σ₂₃ σ₁₃] [_inst_14 : Monoid.{u4} S₃] [_inst_15 : DistribMulAction.{u4, u7} S₃ M₃ _inst_14 (AddCommMonoid.toAddMonoid.{u7} M₃ _inst_6)] [_inst_16 : SMulCommClass.{u3, u4, u7} R₃ S₃ M₃ (SMulZeroClass.toHasSmul.{u3, u7} R₃ M₃ (AddZeroClass.toHasZero.{u7} M₃ (AddMonoid.toAddZeroClass.{u7} M₃ (AddCommMonoid.toAddMonoid.{u7} M₃ _inst_6))) (SMulWithZero.toSmulZeroClass.{u3, u7} R₃ M₃ (MulZeroClass.toHasZero.{u3} R₃ (MulZeroOneClass.toMulZeroClass.{u3} R₃ (MonoidWithZero.toMulZeroOneClass.{u3} R₃ (Semiring.toMonoidWithZero.{u3} R₃ _inst_3)))) (AddZeroClass.toHasZero.{u7} M₃ (AddMonoid.toAddZeroClass.{u7} M₃ (AddCommMonoid.toAddMonoid.{u7} M₃ _inst_6))) (MulActionWithZero.toSMulWithZero.{u3, u7} R₃ M₃ (Semiring.toMonoidWithZero.{u3} R₃ _inst_3) (AddZeroClass.toHasZero.{u7} M₃ (AddMonoid.toAddZeroClass.{u7} M₃ (AddCommMonoid.toAddMonoid.{u7} M₃ _inst_6))) (Module.toMulActionWithZero.{u3, u7} R₃ M₃ _inst_3 _inst_6 _inst_9)))) (SMulZeroClass.toHasSmul.{u4, u7} S₃ M₃ (AddZeroClass.toHasZero.{u7} M₃ (AddMonoid.toAddZeroClass.{u7} M₃ (AddCommMonoid.toAddMonoid.{u7} M₃ _inst_6))) (DistribSMul.toSmulZeroClass.{u4, u7} S₃ M₃ (AddMonoid.toAddZeroClass.{u7} M₃ (AddCommMonoid.toAddMonoid.{u7} M₃ _inst_6)) (DistribMulAction.toDistribSMul.{u4, u7} S₃ M₃ _inst_14 (AddCommMonoid.toAddMonoid.{u7} M₃ _inst_6) _inst_15)))] (a : S₃) (g : LinearMap.{u2, u3, u6, u7} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ M₃ _inst_5 _inst_6 _inst_8 _inst_9) (f : LinearMap.{u1, u2, u5, u6} R R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_7 _inst_8), Eq.{max (succ u5) (succ u7)} (LinearMap.{u1, u3, u5, u7} R R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_7 _inst_9) (LinearMap.comp.{u1, u2, u3, u5, u6, u7} R R₂ R₃ M M₂ M₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 σ₁₂ σ₂₃ σ₁₃ _inst_10 (SMul.smul.{u4, max u6 u7} S₃ (LinearMap.{u2, u3, u6, u7} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ M₃ _inst_5 _inst_6 _inst_8 _inst_9) (LinearMap.hasSmul.{u2, u3, u4, u6, u7} R₂ R₃ S₃ M₂ M₃ _inst_2 _inst_3 _inst_5 _inst_6 _inst_8 _inst_9 σ₂₃ _inst_14 _inst_15 _inst_16) a g) f) (SMul.smul.{u4, max u5 u7} S₃ (LinearMap.{u1, u3, u5, u7} R R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_7 _inst_9) (LinearMap.hasSmul.{u1, u3, u4, u5, u7} R R₃ S₃ M M₃ _inst_1 _inst_3 _inst_4 _inst_6 _inst_7 _inst_9 σ₁₃ _inst_14 _inst_15 _inst_16) a (LinearMap.comp.{u1, u2, u3, u5, u6, u7} R R₂ R₃ M M₂ M₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 σ₁₂ σ₂₃ σ₁₃ _inst_10 g f))
but is expected to have type
  forall {R : Type.{u3}} {R₂ : Type.{u7}} {R₃ : Type.{u6}} {S₃ : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u5}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u3} R] [_inst_2 : Semiring.{u7} R₂] [_inst_3 : Semiring.{u6} R₃] [_inst_4 : AddCommMonoid.{u2} M] [_inst_5 : AddCommMonoid.{u5} M₂] [_inst_6 : AddCommMonoid.{u4} M₃] [_inst_7 : Module.{u3, u2} R M _inst_1 _inst_4] [_inst_8 : Module.{u7, u5} R₂ M₂ _inst_2 _inst_5] [_inst_9 : Module.{u6, u4} R₃ M₃ _inst_3 _inst_6] {σ₁₂ : RingHom.{u3, u7} R R₂ (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u7} R₂ _inst_2)} {σ₂₃ : RingHom.{u7, u6} R₂ R₃ (Semiring.toNonAssocSemiring.{u7} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u6} R₃ _inst_3)} {σ₁₃ : RingHom.{u3, u6} R R₃ (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u6} R₃ _inst_3)} [_inst_10 : RingHomCompTriple.{u3, u7, u6} R R₂ R₃ _inst_1 _inst_2 _inst_3 σ₁₂ σ₂₃ σ₁₃] [_inst_14 : Monoid.{u1} S₃] [_inst_15 : DistribMulAction.{u1, u4} S₃ M₃ _inst_14 (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6)] [_inst_16 : SMulCommClass.{u6, u1, u4} R₃ S₃ M₃ (SMulZeroClass.toSMul.{u6, u4} R₃ M₃ (AddMonoid.toZero.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6)) (SMulWithZero.toSMulZeroClass.{u6, u4} R₃ M₃ (MonoidWithZero.toZero.{u6} R₃ (Semiring.toMonoidWithZero.{u6} R₃ _inst_3)) (AddMonoid.toZero.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6)) (MulActionWithZero.toSMulWithZero.{u6, u4} R₃ M₃ (Semiring.toMonoidWithZero.{u6} R₃ _inst_3) (AddMonoid.toZero.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6)) (Module.toMulActionWithZero.{u6, u4} R₃ M₃ _inst_3 _inst_6 _inst_9)))) (SMulZeroClass.toSMul.{u1, u4} S₃ M₃ (AddMonoid.toZero.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6)) (DistribSMul.toSMulZeroClass.{u1, u4} S₃ M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6)) (DistribMulAction.toDistribSMul.{u1, u4} S₃ M₃ _inst_14 (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_6) _inst_15)))] (a : S₃) (g : LinearMap.{u7, u6, u5, u4} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ M₃ _inst_5 _inst_6 _inst_8 _inst_9) (f : LinearMap.{u3, u7, u2, u5} R R₂ _inst_1 _inst_2 σ₁₂ M M₂ _inst_4 _inst_5 _inst_7 _inst_8), Eq.{max (succ u2) (succ u4)} (LinearMap.{u3, u6, u2, u4} R R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_7 _inst_9) (LinearMap.comp.{u3, u7, u6, u2, u5, u4} R R₂ R₃ M M₂ M₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 σ₁₂ σ₂₃ σ₁₃ _inst_10 (HSMul.hSMul.{u1, max u5 u4, max u5 u4} S₃ (LinearMap.{u7, u6, u5, u4} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ M₃ _inst_5 _inst_6 _inst_8 _inst_9) (LinearMap.{u7, u6, u5, u4} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ M₃ _inst_5 _inst_6 _inst_8 _inst_9) (instHSMul.{u1, max u5 u4} S₃ (LinearMap.{u7, u6, u5, u4} R₂ R₃ _inst_2 _inst_3 σ₂₃ M₂ M₃ _inst_5 _inst_6 _inst_8 _inst_9) (LinearMap.instSMulLinearMap.{u7, u6, u1, u5, u4} R₂ R₃ S₃ M₂ M₃ _inst_2 _inst_3 _inst_5 _inst_6 _inst_8 _inst_9 σ₂₃ _inst_14 _inst_15 _inst_16)) a g) f) (HSMul.hSMul.{u1, max u4 u2, max u2 u4} S₃ (LinearMap.{u3, u6, u2, u4} R R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_7 _inst_9) (LinearMap.{u3, u6, u2, u4} R R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_7 _inst_9) (instHSMul.{u1, max u2 u4} S₃ (LinearMap.{u3, u6, u2, u4} R R₃ _inst_1 _inst_3 σ₁₃ M M₃ _inst_4 _inst_6 _inst_7 _inst_9) (LinearMap.instSMulLinearMap.{u3, u6, u1, u2, u4} R R₃ S₃ M M₃ _inst_1 _inst_3 _inst_4 _inst_6 _inst_7 _inst_9 σ₁₃ _inst_14 _inst_15 _inst_16)) a (LinearMap.comp.{u3, u7, u6, u2, u5, u4} R R₂ R₃ M M₂ M₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 σ₁₂ σ₂₃ σ₁₃ _inst_10 g f))
Case conversion may be inaccurate. Consider using '#align linear_map.smul_comp LinearMap.smul_compₓ'. -/
theorem smul_comp (a : S₃) (g : M₂ →ₛₗ[σ₂₃] M₃) (f : M →ₛₗ[σ₁₂] M₂) :
    (a • g).comp f = a • g.comp f :=
  rfl
#align linear_map.smul_comp LinearMap.smul_comp

omit σ₁₃

/- warning: linear_map.comp_smul -> LinearMap.comp_smul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} {M₃ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_4 : AddCommMonoid.{u3} M] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_6 : AddCommMonoid.{u5} M₃] [_inst_7 : Module.{u1, u3} R M _inst_1 _inst_4] [_inst_11 : Monoid.{u2} S] [_inst_12 : DistribMulAction.{u2, u4} S M₂ _inst_11 (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5)] [_inst_20 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_21 : Module.{u1, u5} R M₃ _inst_1 _inst_6] [_inst_22 : SMulCommClass.{u1, u2, u4} R S M₂ (SMulZeroClass.toHasSmul.{u1, u4} R M₂ (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) (SMulWithZero.toSmulZeroClass.{u1, u4} R M₂ (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) (MulActionWithZero.toSMulWithZero.{u1, u4} R M₂ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) (Module.toMulActionWithZero.{u1, u4} R M₂ _inst_1 _inst_5 _inst_20)))) (SMulZeroClass.toHasSmul.{u2, u4} S M₂ (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) (DistribSMul.toSmulZeroClass.{u2, u4} S M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5)) (DistribMulAction.toDistribSMul.{u2, u4} S M₂ _inst_11 (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5) _inst_12)))] [_inst_23 : DistribMulAction.{u2, u5} S M₃ _inst_11 (AddCommMonoid.toAddMonoid.{u5} M₃ _inst_6)] [_inst_24 : SMulCommClass.{u1, u2, u5} R S M₃ (SMulZeroClass.toHasSmul.{u1, u5} R M₃ (AddZeroClass.toHasZero.{u5} M₃ (AddMonoid.toAddZeroClass.{u5} M₃ (AddCommMonoid.toAddMonoid.{u5} M₃ _inst_6))) (SMulWithZero.toSmulZeroClass.{u1, u5} R M₃ (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u5} M₃ (AddMonoid.toAddZeroClass.{u5} M₃ (AddCommMonoid.toAddMonoid.{u5} M₃ _inst_6))) (MulActionWithZero.toSMulWithZero.{u1, u5} R M₃ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u5} M₃ (AddMonoid.toAddZeroClass.{u5} M₃ (AddCommMonoid.toAddMonoid.{u5} M₃ _inst_6))) (Module.toMulActionWithZero.{u1, u5} R M₃ _inst_1 _inst_6 _inst_21)))) (SMulZeroClass.toHasSmul.{u2, u5} S M₃ (AddZeroClass.toHasZero.{u5} M₃ (AddMonoid.toAddZeroClass.{u5} M₃ (AddCommMonoid.toAddMonoid.{u5} M₃ _inst_6))) (DistribSMul.toSmulZeroClass.{u2, u5} S M₃ (AddMonoid.toAddZeroClass.{u5} M₃ (AddCommMonoid.toAddMonoid.{u5} M₃ _inst_6)) (DistribMulAction.toDistribSMul.{u2, u5} S M₃ _inst_11 (AddCommMonoid.toAddMonoid.{u5} M₃ _inst_6) _inst_23)))] [_inst_25 : LinearMap.CompatibleSMul.{u5, u4, u2, u1} M₃ M₂ _inst_6 _inst_5 S R _inst_1 (SMulZeroClass.toHasSmul.{u2, u5} S M₃ (AddZeroClass.toHasZero.{u5} M₃ (AddMonoid.toAddZeroClass.{u5} M₃ (AddCommMonoid.toAddMonoid.{u5} M₃ _inst_6))) (DistribSMul.toSmulZeroClass.{u2, u5} S M₃ (AddMonoid.toAddZeroClass.{u5} M₃ (AddCommMonoid.toAddMonoid.{u5} M₃ _inst_6)) (DistribMulAction.toDistribSMul.{u2, u5} S M₃ _inst_11 (AddCommMonoid.toAddMonoid.{u5} M₃ _inst_6) _inst_23))) _inst_21 (SMulZeroClass.toHasSmul.{u2, u4} S M₂ (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) (DistribSMul.toSmulZeroClass.{u2, u4} S M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5)) (DistribMulAction.toDistribSMul.{u2, u4} S M₂ _inst_11 (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5) _inst_12))) _inst_20] (g : LinearMap.{u1, u1, u5, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₃ M₂ _inst_6 _inst_5 _inst_21 _inst_20) (a : S) (f : LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_4 _inst_6 _inst_7 _inst_21), Eq.{max (succ u3) (succ u4)} (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_4 _inst_5 _inst_7 _inst_20) (LinearMap.comp.{u1, u1, u1, u3, u5, u4} R R R M M₃ M₂ _inst_1 _inst_1 _inst_1 _inst_4 _inst_6 _inst_5 _inst_7 _inst_21 _inst_20 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.right_ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g (SMul.smul.{u2, max u3 u5} S (LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_4 _inst_6 _inst_7 _inst_21) (LinearMap.hasSmul.{u1, u1, u2, u3, u5} R R S M M₃ _inst_1 _inst_1 _inst_4 _inst_6 _inst_7 _inst_21 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_11 _inst_23 _inst_24) a f)) (SMul.smul.{u2, max u3 u4} S (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_4 _inst_5 _inst_7 _inst_20) (LinearMap.hasSmul.{u1, u1, u2, u3, u4} R R S M M₂ _inst_1 _inst_1 _inst_4 _inst_5 _inst_7 _inst_20 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_11 _inst_12 _inst_22) a (LinearMap.comp.{u1, u1, u1, u3, u5, u4} R R R M M₃ M₂ _inst_1 _inst_1 _inst_1 _inst_4 _inst_6 _inst_5 _inst_7 _inst_21 _inst_20 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.right_ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g f))
but is expected to have type
  forall {R : Type.{u5}} {S : Type.{u2}} {M : Type.{u1}} {M₂ : Type.{u4}} {M₃ : Type.{u3}} [_inst_1 : Semiring.{u5} R] [_inst_4 : AddCommMonoid.{u1} M] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_6 : AddCommMonoid.{u3} M₃] [_inst_7 : Module.{u5, u1} R M _inst_1 _inst_4] [_inst_11 : Monoid.{u2} S] [_inst_12 : DistribMulAction.{u2, u4} S M₂ _inst_11 (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5)] [_inst_20 : Module.{u5, u4} R M₂ _inst_1 _inst_5] [_inst_21 : Module.{u5, u3} R M₃ _inst_1 _inst_6] [_inst_22 : SMulCommClass.{u5, u2, u4} R S M₂ (SMulZeroClass.toSMul.{u5, u4} R M₂ (AddMonoid.toZero.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5)) (SMulWithZero.toSMulZeroClass.{u5, u4} R M₂ (MonoidWithZero.toZero.{u5} R (Semiring.toMonoidWithZero.{u5} R _inst_1)) (AddMonoid.toZero.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5)) (MulActionWithZero.toSMulWithZero.{u5, u4} R M₂ (Semiring.toMonoidWithZero.{u5} R _inst_1) (AddMonoid.toZero.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5)) (Module.toMulActionWithZero.{u5, u4} R M₂ _inst_1 _inst_5 _inst_20)))) (SMulZeroClass.toSMul.{u2, u4} S M₂ (AddMonoid.toZero.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5)) (DistribSMul.toSMulZeroClass.{u2, u4} S M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5)) (DistribMulAction.toDistribSMul.{u2, u4} S M₂ _inst_11 (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5) _inst_12)))] [_inst_23 : DistribMulAction.{u2, u3} S M₃ _inst_11 (AddCommMonoid.toAddMonoid.{u3} M₃ _inst_6)] [_inst_24 : SMulCommClass.{u5, u2, u3} R S M₃ (SMulZeroClass.toSMul.{u5, u3} R M₃ (AddMonoid.toZero.{u3} M₃ (AddCommMonoid.toAddMonoid.{u3} M₃ _inst_6)) (SMulWithZero.toSMulZeroClass.{u5, u3} R M₃ (MonoidWithZero.toZero.{u5} R (Semiring.toMonoidWithZero.{u5} R _inst_1)) (AddMonoid.toZero.{u3} M₃ (AddCommMonoid.toAddMonoid.{u3} M₃ _inst_6)) (MulActionWithZero.toSMulWithZero.{u5, u3} R M₃ (Semiring.toMonoidWithZero.{u5} R _inst_1) (AddMonoid.toZero.{u3} M₃ (AddCommMonoid.toAddMonoid.{u3} M₃ _inst_6)) (Module.toMulActionWithZero.{u5, u3} R M₃ _inst_1 _inst_6 _inst_21)))) (SMulZeroClass.toSMul.{u2, u3} S M₃ (AddMonoid.toZero.{u3} M₃ (AddCommMonoid.toAddMonoid.{u3} M₃ _inst_6)) (DistribSMul.toSMulZeroClass.{u2, u3} S M₃ (AddMonoid.toAddZeroClass.{u3} M₃ (AddCommMonoid.toAddMonoid.{u3} M₃ _inst_6)) (DistribMulAction.toDistribSMul.{u2, u3} S M₃ _inst_11 (AddCommMonoid.toAddMonoid.{u3} M₃ _inst_6) _inst_23)))] [_inst_25 : LinearMap.CompatibleSMul.{u3, u4, u2, u5} M₃ M₂ _inst_6 _inst_5 S R _inst_1 (SMulZeroClass.toSMul.{u2, u3} S M₃ (AddMonoid.toZero.{u3} M₃ (AddCommMonoid.toAddMonoid.{u3} M₃ _inst_6)) (DistribSMul.toSMulZeroClass.{u2, u3} S M₃ (AddMonoid.toAddZeroClass.{u3} M₃ (AddCommMonoid.toAddMonoid.{u3} M₃ _inst_6)) (DistribMulAction.toDistribSMul.{u2, u3} S M₃ _inst_11 (AddCommMonoid.toAddMonoid.{u3} M₃ _inst_6) _inst_23))) _inst_21 (SMulZeroClass.toSMul.{u2, u4} S M₂ (AddMonoid.toZero.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5)) (DistribSMul.toSMulZeroClass.{u2, u4} S M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5)) (DistribMulAction.toDistribSMul.{u2, u4} S M₂ _inst_11 (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5) _inst_12))) _inst_20] (g : LinearMap.{u5, u5, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M₃ M₂ _inst_6 _inst_5 _inst_21 _inst_20) (a : S) (f : LinearMap.{u5, u5, u1, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M M₃ _inst_4 _inst_6 _inst_7 _inst_21), Eq.{max (succ u1) (succ u4)} (LinearMap.{u5, u5, u1, u4} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M M₂ _inst_4 _inst_5 _inst_7 _inst_20) (LinearMap.comp.{u5, u5, u5, u1, u3, u4} R R R M M₃ M₂ _inst_1 _inst_1 _inst_1 _inst_4 _inst_6 _inst_5 _inst_7 _inst_21 _inst_20 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHomCompTriple.ids.{u5, u5} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) g (HSMul.hSMul.{u2, max u1 u3, max u1 u3} S (LinearMap.{u5, u5, u1, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M M₃ _inst_4 _inst_6 _inst_7 _inst_21) (LinearMap.{u5, u5, u1, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M M₃ _inst_4 _inst_6 _inst_7 _inst_21) (instHSMul.{u2, max u1 u3} S (LinearMap.{u5, u5, u1, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M M₃ _inst_4 _inst_6 _inst_7 _inst_21) (LinearMap.instSMulLinearMap.{u5, u5, u2, u1, u3} R R S M M₃ _inst_1 _inst_1 _inst_4 _inst_6 _inst_7 _inst_21 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_11 _inst_23 _inst_24)) a f)) (HSMul.hSMul.{u2, max u4 u1, max u1 u4} S (LinearMap.{u5, u5, u1, u4} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M M₂ _inst_4 _inst_5 _inst_7 _inst_20) (LinearMap.{u5, u5, u1, u4} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M M₂ _inst_4 _inst_5 _inst_7 _inst_20) (instHSMul.{u2, max u1 u4} S (LinearMap.{u5, u5, u1, u4} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M M₂ _inst_4 _inst_5 _inst_7 _inst_20) (LinearMap.instSMulLinearMap.{u5, u5, u2, u1, u4} R R S M M₂ _inst_1 _inst_1 _inst_4 _inst_5 _inst_7 _inst_20 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_11 _inst_12 _inst_22)) a (LinearMap.comp.{u5, u5, u5, u1, u3, u4} R R R M M₃ M₂ _inst_1 _inst_1 _inst_1 _inst_4 _inst_6 _inst_5 _inst_7 _inst_21 _inst_20 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHomCompTriple.ids.{u5, u5} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) g f))
Case conversion may be inaccurate. Consider using '#align linear_map.comp_smul LinearMap.comp_smulₓ'. -/
-- TODO: generalize this to semilinear maps
theorem comp_smul [Module R M₂] [Module R M₃] [SMulCommClass R S M₂] [DistribMulAction S M₃]
    [SMulCommClass R S M₃] [CompatibleSMul M₃ M₂ S R] (g : M₃ →ₗ[R] M₂) (a : S) (f : M →ₗ[R] M₃) :
    g.comp (a • f) = a • g.comp f :=
  ext fun x => g.map_smul_of_tower _ _
#align linear_map.comp_smul LinearMap.comp_smul

end SMul

section Module

variable [Semiring S] [Module S M₂] [SMulCommClass R₂ S M₂]

instance : Module S (M →ₛₗ[σ₁₂] M₂)
    where
  add_smul a b f := ext fun x => add_smul _ _ _
  zero_smul f := ext fun x => zero_smul _ _

instance [NoZeroSMulDivisors S M₂] : NoZeroSMulDivisors S (M →ₛₗ[σ₁₂] M₂) :=
  coe_injective.NoZeroSMulDivisors _ rfl coe_smul

end Module

end Actions

/-!
### Monoid structure of endomorphisms

Lemmas about `pow` such as `linear_map.pow_apply` appear in later files.
-/


section Endomorphisms

variable [Semiring R] [AddCommMonoid M] [AddCommGroup N₁] [Module R M] [Module R N₁]

instance : One (Module.End R M) :=
  ⟨LinearMap.id⟩

instance : Mul (Module.End R M) :=
  ⟨LinearMap.comp⟩

#print LinearMap.one_eq_id /-
theorem one_eq_id : (1 : Module.End R M) = id :=
  rfl
#align linear_map.one_eq_id LinearMap.one_eq_id
-/

/- warning: linear_map.mul_eq_comp -> LinearMap.mul_eq_comp is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] (f : Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (g : Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4), Eq.{succ u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (HMul.hMul.{u2, u2, u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (instHMul.{u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (LinearMap.module.End.hasMul.{u1, u2} R M _inst_1 _inst_2 _inst_4)) f g) (LinearMap.comp.{u1, u1, u1, u2, u2, u2} R R R M M M _inst_1 _inst_1 _inst_1 _inst_2 _inst_2 _inst_2 _inst_4 _inst_4 _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.right_ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f g)
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_2] (f : Module.End.{u2, u1} R M _inst_1 _inst_2 _inst_4) (g : Module.End.{u2, u1} R M _inst_1 _inst_2 _inst_4), Eq.{succ u1} (Module.End.{u2, u1} R M _inst_1 _inst_2 _inst_4) (HMul.hMul.{u1, u1, u1} (Module.End.{u2, u1} R M _inst_1 _inst_2 _inst_4) (Module.End.{u2, u1} R M _inst_1 _inst_2 _inst_4) (Module.End.{u2, u1} R M _inst_1 _inst_2 _inst_4) (instHMul.{u1} (Module.End.{u2, u1} R M _inst_1 _inst_2 _inst_4) (LinearMap.instMulEnd.{u2, u1} R M _inst_1 _inst_2 _inst_4)) f g) (LinearMap.comp.{u2, u2, u2, u1, u1, u1} R R R M M M _inst_1 _inst_1 _inst_1 _inst_2 _inst_2 _inst_2 _inst_4 _inst_4 _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomCompTriple.ids.{u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) f g)
Case conversion may be inaccurate. Consider using '#align linear_map.mul_eq_comp LinearMap.mul_eq_compₓ'. -/
theorem mul_eq_comp (f g : Module.End R M) : f * g = f.comp g :=
  rfl
#align linear_map.mul_eq_comp LinearMap.mul_eq_comp

/- warning: linear_map.one_apply -> LinearMap.one_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] (x : M), Eq.{succ u2} M (coeFn.{succ u2, succ u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (fun (_x : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_2 _inst_2 _inst_4 _inst_4) => M -> M) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (OfNat.ofNat.{u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) 1 (OfNat.mk.{u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) 1 (One.one.{u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (LinearMap.module.End.hasOne.{u1, u2} R M _inst_1 _inst_2 _inst_4)))) x) x
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] (x : M), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M) x) (FunLike.coe.{succ u2, succ u2, succ u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} R R M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (OfNat.ofNat.{u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) 1 (One.toOfNat1.{u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (LinearMap.instOneEnd.{u1, u2} R M _inst_1 _inst_2 _inst_4))) x) x
Case conversion may be inaccurate. Consider using '#align linear_map.one_apply LinearMap.one_applyₓ'. -/
@[simp]
theorem one_apply (x : M) : (1 : Module.End R M) x = x :=
  rfl
#align linear_map.one_apply LinearMap.one_apply

/- warning: linear_map.mul_apply -> LinearMap.mul_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] (f : Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (g : Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (x : M), Eq.{succ u2} M (coeFn.{succ u2, succ u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (fun (_x : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_2 _inst_2 _inst_4 _inst_4) => M -> M) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (HMul.hMul.{u2, u2, u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (instHMul.{u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (LinearMap.module.End.hasMul.{u1, u2} R M _inst_1 _inst_2 _inst_4)) f g) x) (coeFn.{succ u2, succ u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (fun (_x : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_2 _inst_2 _inst_4 _inst_4) => M -> M) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f (coeFn.{succ u2, succ u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (fun (_x : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_2 _inst_2 _inst_4 _inst_4) => M -> M) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g x))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_2] (f : Module.End.{u2, u1} R M _inst_1 _inst_2 _inst_4) (g : Module.End.{u2, u1} R M _inst_1 _inst_2 _inst_4) (x : M), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M) x) (FunLike.coe.{succ u1, succ u1, succ u1} (Module.End.{u2, u1} R M _inst_1 _inst_2 _inst_4) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, u1, u1} R R M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (HMul.hMul.{u1, u1, u1} (Module.End.{u2, u1} R M _inst_1 _inst_2 _inst_4) (Module.End.{u2, u1} R M _inst_1 _inst_2 _inst_4) (Module.End.{u2, u1} R M _inst_1 _inst_2 _inst_4) (instHMul.{u1} (Module.End.{u2, u1} R M _inst_1 _inst_2 _inst_4) (LinearMap.instMulEnd.{u2, u1} R M _inst_1 _inst_2 _inst_4)) f g) x) (FunLike.coe.{succ u1, succ u1, succ u1} (Module.End.{u2, u1} R M _inst_1 _inst_2 _inst_4) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, u1, u1} R R M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) f (FunLike.coe.{succ u1, succ u1, succ u1} (Module.End.{u2, u1} R M _inst_1 _inst_2 _inst_4) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, u1, u1} R R M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) g x))
Case conversion may be inaccurate. Consider using '#align linear_map.mul_apply LinearMap.mul_applyₓ'. -/
@[simp]
theorem mul_apply (f g : Module.End R M) (x : M) : (f * g) x = f (g x) :=
  rfl
#align linear_map.mul_apply LinearMap.mul_apply

/- warning: linear_map.coe_one -> LinearMap.coe_one is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2], Eq.{succ u2} (M -> M) (coeFn.{succ u2, succ u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (fun (_x : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_2 _inst_2 _inst_4 _inst_4) => M -> M) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (OfNat.ofNat.{u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) 1 (OfNat.mk.{u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) 1 (One.one.{u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (LinearMap.module.End.hasOne.{u1, u2} R M _inst_1 _inst_2 _inst_4))))) (id.{succ u2} M)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2], Eq.{succ u2} (forall (ᾰ : M), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M) ᾰ) (FunLike.coe.{succ u2, succ u2, succ u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} R R M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (OfNat.ofNat.{u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) 1 (One.toOfNat1.{u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (LinearMap.instOneEnd.{u1, u2} R M _inst_1 _inst_2 _inst_4)))) (id.{succ u2} M)
Case conversion may be inaccurate. Consider using '#align linear_map.coe_one LinearMap.coe_oneₓ'. -/
theorem coe_one : ⇑(1 : Module.End R M) = id :=
  rfl
#align linear_map.coe_one LinearMap.coe_one

/- warning: linear_map.coe_mul -> LinearMap.coe_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] (f : Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (g : Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4), Eq.{succ u2} (M -> M) (coeFn.{succ u2, succ u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (fun (_x : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_2 _inst_2 _inst_4 _inst_4) => M -> M) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (HMul.hMul.{u2, u2, u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (instHMul.{u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (LinearMap.module.End.hasMul.{u1, u2} R M _inst_1 _inst_2 _inst_4)) f g)) (Function.comp.{succ u2, succ u2, succ u2} M M M (coeFn.{succ u2, succ u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (fun (_x : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_2 _inst_2 _inst_4 _inst_4) => M -> M) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f) (coeFn.{succ u2, succ u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (fun (_x : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_2 _inst_2 _inst_4 _inst_4) => M -> M) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_2] (f : Module.End.{u2, u1} R M _inst_1 _inst_2 _inst_4) (g : Module.End.{u2, u1} R M _inst_1 _inst_2 _inst_4), Eq.{succ u1} (forall (ᾰ : M), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (Module.End.{u2, u1} R M _inst_1 _inst_2 _inst_4) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, u1, u1} R R M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (HMul.hMul.{u1, u1, u1} (Module.End.{u2, u1} R M _inst_1 _inst_2 _inst_4) (Module.End.{u2, u1} R M _inst_1 _inst_2 _inst_4) (Module.End.{u2, u1} R M _inst_1 _inst_2 _inst_4) (instHMul.{u1} (Module.End.{u2, u1} R M _inst_1 _inst_2 _inst_4) (LinearMap.instMulEnd.{u2, u1} R M _inst_1 _inst_2 _inst_4)) f g)) (Function.comp.{succ u1, succ u1, succ u1} M M M (FunLike.coe.{succ u1, succ u1, succ u1} (Module.End.{u2, u1} R M _inst_1 _inst_2 _inst_4) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, u1, u1} R R M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) f) (FunLike.coe.{succ u1, succ u1, succ u1} (Module.End.{u2, u1} R M _inst_1 _inst_2 _inst_4) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, u1, u1} R R M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) g))
Case conversion may be inaccurate. Consider using '#align linear_map.coe_mul LinearMap.coe_mulₓ'. -/
theorem coe_mul (f g : Module.End R M) : ⇑(f * g) = f ∘ g :=
  rfl
#align linear_map.coe_mul LinearMap.coe_mul

#print Module.End.monoid /-
instance Module.End.monoid : Monoid (Module.End R M)
    where
  mul := (· * ·)
  one := (1 : M →ₗ[R] M)
  mul_assoc f g h := LinearMap.ext fun x => rfl
  mul_one := comp_id
  one_mul := id_comp
#align module.End.monoid Module.End.monoid
-/

#print Module.End.semiring /-
instance Module.End.semiring : Semiring (Module.End R M) :=
  { AddMonoidWithOne.unary, Module.End.monoid,
    LinearMap.addCommMonoid with
    mul := (· * ·)
    one := (1 : M →ₗ[R] M)
    zero := 0
    add := (· + ·)
    mul_zero := comp_zero
    zero_mul := zero_comp
    left_distrib := fun f g h => comp_add _ _ _
    right_distrib := fun f g h => add_comp _ _ _
    natCast := fun n => n • 1
    natCast_zero := AddMonoid.nsmul_zero _
    natCast_succ := fun n => (AddMonoid.nsmul_succ n 1).trans (add_comm _ _) }
#align module.End.semiring Module.End.semiring
-/

/- warning: module.End.nat_cast_apply -> Module.End.natCast_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] (n : Nat) (m : M), Eq.{succ u2} M (coeFn.{succ u2, succ u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (fun (_x : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_2 _inst_2 _inst_4 _inst_4) => M -> M) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (HasLiftT.mk.{1, succ u2} Nat (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (CoeTCₓ.coe.{1, succ u2} Nat (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Nat.castCoe.{u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (AddMonoidWithOne.toNatCast.{u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (NonAssocSemiring.toAddCommMonoidWithOne.{u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Module.End.semiring.{u1, u2} R M _inst_1 _inst_2 _inst_4)))))))) n) m) (SMul.smul.{0, u2} Nat M (AddMonoid.SMul.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) n m)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] (n : Nat) (m : M), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M) m) (FunLike.coe.{succ u2, succ u2, succ u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} R R M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Nat.cast.{u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Semiring.toNatCast.{u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Module.End.semiring.{u1, u2} R M _inst_1 _inst_2 _inst_4)) n) m) (HSMul.hSMul.{0, u2, u2} Nat M M (instHSMul.{0, u2} Nat M (AddMonoid.SMul.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) n m)
Case conversion may be inaccurate. Consider using '#align module.End.nat_cast_apply Module.End.natCast_applyₓ'. -/
/-- See also `module.End.nat_cast_def`. -/
@[simp]
theorem Module.End.natCast_apply (n : ℕ) (m : M) : (↑n : Module.End R M) m = n • m :=
  rfl
#align module.End.nat_cast_apply Module.End.natCast_apply

#print Module.End.ring /-
instance Module.End.ring : Ring (Module.End R N₁) :=
  { Module.End.semiring,
    LinearMap.addCommGroup with
    intCast := fun z => z • 1
    intCast_ofNat := ofNat_zsmul _
    intCast_negSucc := negSucc_zsmul _ }
#align module.End.ring Module.End.ring
-/

/- warning: module.End.int_cast_apply -> Module.End.intCast_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {N₁ : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommGroup.{u2} N₁] [_inst_5 : Module.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_3)] (z : Int) (m : N₁), Eq.{succ u2} N₁ (coeFn.{succ u2, succ u2} (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_3) _inst_5) (fun (_x : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) N₁ N₁ (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_3) (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_3) _inst_5 _inst_5) => N₁ -> N₁) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R N₁ N₁ _inst_1 _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_3) (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_3) _inst_5 _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Int (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_3) _inst_5) (HasLiftT.mk.{1, succ u2} Int (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_3) _inst_5) (CoeTCₓ.coe.{1, succ u2} Int (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_3) _inst_5) (Int.castCoe.{u2} (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_3) _inst_5) (AddGroupWithOne.toHasIntCast.{u2} (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_3) _inst_5) (NonAssocRing.toAddGroupWithOne.{u2} (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_3) _inst_5) (Ring.toNonAssocRing.{u2} (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_3) _inst_5) (Module.End.ring.{u1, u2} R N₁ _inst_1 _inst_3 _inst_5))))))) z) m) (SMul.smul.{0, u2} Int N₁ (SubNegMonoid.SMulInt.{u2} N₁ (AddGroup.toSubNegMonoid.{u2} N₁ (AddCommGroup.toAddGroup.{u2} N₁ _inst_3))) z m)
but is expected to have type
  forall {R : Type.{u1}} {N₁ : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommGroup.{u2} N₁] [_inst_5 : Module.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_3)] (z : Int) (m : N₁), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : N₁) => N₁) m) (FunLike.coe.{succ u2, succ u2, succ u2} (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_3) _inst_5) N₁ (fun (_x : N₁) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : N₁) => N₁) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} R R N₁ N₁ _inst_1 _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_3) (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_3) _inst_5 _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Int.cast.{u2} (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_3) _inst_5) (Ring.toIntCast.{u2} (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_3) _inst_5) (Module.End.ring.{u1, u2} R N₁ _inst_1 _inst_3 _inst_5)) z) m) (HSMul.hSMul.{0, u2, u2} Int N₁ N₁ (instHSMul.{0, u2} Int N₁ (SubNegMonoid.SMulInt.{u2} N₁ (AddGroup.toSubNegMonoid.{u2} N₁ (AddCommGroup.toAddGroup.{u2} N₁ _inst_3)))) z m)
Case conversion may be inaccurate. Consider using '#align module.End.int_cast_apply Module.End.intCast_applyₓ'. -/
/-- See also `module.End.int_cast_def`. -/
@[simp]
theorem Module.End.intCast_apply (z : ℤ) (m : N₁) : (↑z : Module.End R N₁) m = z • m :=
  rfl
#align module.End.int_cast_apply Module.End.intCast_apply

section

variable [Monoid S] [DistribMulAction S M] [SMulCommClass R S M]

/- warning: module.End.is_scalar_tower -> Module.End.isScalarTower is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_4 : Module.{u1, u3} R M _inst_1 _inst_2] [_inst_6 : Monoid.{u2} S] [_inst_7 : DistribMulAction.{u2, u3} S M _inst_6 (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_8 : SMulCommClass.{u1, u2, u3} R S M (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_2 _inst_4)))) (SMulZeroClass.toHasSmul.{u2, u3} S M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (DistribSMul.toSmulZeroClass.{u2, u3} S M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u2, u3} S M _inst_6 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_7)))], IsScalarTower.{u2, u3, u3} S (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (LinearMap.hasSmul.{u1, u1, u2, u3, u3} R R S M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_6 _inst_7 _inst_8) (Mul.toSMul.{u3} (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (LinearMap.module.End.hasMul.{u1, u3} R M _inst_1 _inst_2 _inst_4)) (LinearMap.hasSmul.{u1, u1, u2, u3, u3} R R S M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_6 _inst_7 _inst_8)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_4 : Module.{u1, u3} R M _inst_1 _inst_2] [_inst_6 : Monoid.{u2} S] [_inst_7 : DistribMulAction.{u2, u3} S M _inst_6 (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_8 : SMulCommClass.{u1, u2, u3} R S M (SMulZeroClass.toSMul.{u1, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u3} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_2 _inst_4)))) (SMulZeroClass.toSMul.{u2, u3} S M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribSMul.toSMulZeroClass.{u2, u3} S M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u2, u3} S M _inst_6 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_7)))], IsScalarTower.{u2, u3, u3} S (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (LinearMap.instSMulLinearMap.{u1, u1, u2, u3, u3} R R S M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_6 _inst_7 _inst_8) (SMulZeroClass.toSMul.{u3, u3} (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (LinearMap.instZeroLinearMap.{u1, u1, u3, u3} R R M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (SMulWithZero.toSMulZeroClass.{u3, u3} (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (LinearMap.instZeroLinearMap.{u1, u1, u3, u3} R R M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.instZeroLinearMap.{u1, u1, u3, u3} R R M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (MulZeroClass.toSMulWithZero.{u3} (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (Semiring.toNonAssocSemiring.{u3} (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (Module.End.semiring.{u1, u3} R M _inst_1 _inst_2 _inst_4))))))) (LinearMap.instSMulLinearMap.{u1, u1, u2, u3, u3} R R S M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_6 _inst_7 _inst_8)
Case conversion may be inaccurate. Consider using '#align module.End.is_scalar_tower Module.End.isScalarTowerₓ'. -/
instance Module.End.isScalarTower : IsScalarTower S (Module.End R M) (Module.End R M) :=
  ⟨smul_comp⟩
#align module.End.is_scalar_tower Module.End.isScalarTower

/- warning: module.End.smul_comm_class -> Module.End.smulCommClass is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_4 : Module.{u1, u3} R M _inst_1 _inst_2] [_inst_6 : Monoid.{u2} S] [_inst_7 : DistribMulAction.{u2, u3} S M _inst_6 (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_8 : SMulCommClass.{u1, u2, u3} R S M (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_2 _inst_4)))) (SMulZeroClass.toHasSmul.{u2, u3} S M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (DistribSMul.toSmulZeroClass.{u2, u3} S M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u2, u3} S M _inst_6 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_7)))] [_inst_9 : SMul.{u2, u1} S R] [_inst_10 : IsScalarTower.{u2, u1, u3} S R M _inst_9 (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_2 _inst_4)))) (SMulZeroClass.toHasSmul.{u2, u3} S M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (DistribSMul.toSmulZeroClass.{u2, u3} S M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u2, u3} S M _inst_6 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_7)))], SMulCommClass.{u2, u3, u3} S (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (LinearMap.hasSmul.{u1, u1, u2, u3, u3} R R S M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_6 _inst_7 _inst_8) (Mul.toSMul.{u3} (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (LinearMap.module.End.hasMul.{u1, u3} R M _inst_1 _inst_2 _inst_4))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_4 : Module.{u1, u3} R M _inst_1 _inst_2] [_inst_6 : Monoid.{u2} S] [_inst_7 : DistribMulAction.{u2, u3} S M _inst_6 (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_8 : SMulCommClass.{u1, u2, u3} R S M (SMulZeroClass.toSMul.{u1, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u3} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_2 _inst_4)))) (SMulZeroClass.toSMul.{u2, u3} S M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribSMul.toSMulZeroClass.{u2, u3} S M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u2, u3} S M _inst_6 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_7)))] [_inst_9 : SMul.{u2, u1} S R] [_inst_10 : IsScalarTower.{u2, u1, u3} S R M _inst_9 (SMulZeroClass.toSMul.{u1, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u3} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_2 _inst_4)))) (SMulZeroClass.toSMul.{u2, u3} S M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribSMul.toSMulZeroClass.{u2, u3} S M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u2, u3} S M _inst_6 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_7)))], SMulCommClass.{u2, u3, u3} S (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (LinearMap.instSMulLinearMap.{u1, u1, u2, u3, u3} R R S M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_6 _inst_7 _inst_8) (SMulZeroClass.toSMul.{u3, u3} (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (LinearMap.instZeroLinearMap.{u1, u1, u3, u3} R R M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (SMulWithZero.toSMulZeroClass.{u3, u3} (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (LinearMap.instZeroLinearMap.{u1, u1, u3, u3} R R M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.instZeroLinearMap.{u1, u1, u3, u3} R R M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (MulZeroClass.toSMulWithZero.{u3} (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (Semiring.toNonAssocSemiring.{u3} (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (Module.End.semiring.{u1, u3} R M _inst_1 _inst_2 _inst_4)))))))
Case conversion may be inaccurate. Consider using '#align module.End.smul_comm_class Module.End.smulCommClassₓ'. -/
instance Module.End.smulCommClass [SMul S R] [IsScalarTower S R M] :
    SMulCommClass S (Module.End R M) (Module.End R M) :=
  ⟨fun s _ _ => (comp_smul _ s _).symm⟩
#align module.End.smul_comm_class Module.End.smulCommClass

/- warning: module.End.smul_comm_class' -> Module.End.smulCommClass' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_4 : Module.{u1, u3} R M _inst_1 _inst_2] [_inst_6 : Monoid.{u2} S] [_inst_7 : DistribMulAction.{u2, u3} S M _inst_6 (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_8 : SMulCommClass.{u1, u2, u3} R S M (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_2 _inst_4)))) (SMulZeroClass.toHasSmul.{u2, u3} S M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (DistribSMul.toSmulZeroClass.{u2, u3} S M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u2, u3} S M _inst_6 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_7)))] [_inst_9 : SMul.{u2, u1} S R] [_inst_10 : IsScalarTower.{u2, u1, u3} S R M _inst_9 (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_2 _inst_4)))) (SMulZeroClass.toHasSmul.{u2, u3} S M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (DistribSMul.toSmulZeroClass.{u2, u3} S M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u2, u3} S M _inst_6 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_7)))], SMulCommClass.{u3, u2, u3} (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) S (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (Mul.toSMul.{u3} (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (LinearMap.module.End.hasMul.{u1, u3} R M _inst_1 _inst_2 _inst_4)) (LinearMap.hasSmul.{u1, u1, u2, u3, u3} R R S M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_6 _inst_7 _inst_8)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_4 : Module.{u1, u3} R M _inst_1 _inst_2] [_inst_6 : Monoid.{u2} S] [_inst_7 : DistribMulAction.{u2, u3} S M _inst_6 (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_8 : SMulCommClass.{u1, u2, u3} R S M (SMulZeroClass.toSMul.{u1, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u3} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_2 _inst_4)))) (SMulZeroClass.toSMul.{u2, u3} S M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribSMul.toSMulZeroClass.{u2, u3} S M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u2, u3} S M _inst_6 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_7)))] [_inst_9 : SMul.{u2, u1} S R] [_inst_10 : IsScalarTower.{u2, u1, u3} S R M _inst_9 (SMulZeroClass.toSMul.{u1, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u3} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_2 _inst_4)))) (SMulZeroClass.toSMul.{u2, u3} S M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribSMul.toSMulZeroClass.{u2, u3} S M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u2, u3} S M _inst_6 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_7)))], SMulCommClass.{u3, u2, u3} (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) S (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (SMulZeroClass.toSMul.{u3, u3} (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (LinearMap.instZeroLinearMap.{u1, u1, u3, u3} R R M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (SMulWithZero.toSMulZeroClass.{u3, u3} (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (LinearMap.instZeroLinearMap.{u1, u1, u3, u3} R R M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.instZeroLinearMap.{u1, u1, u3, u3} R R M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (MulZeroClass.toSMulWithZero.{u3} (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (Semiring.toNonAssocSemiring.{u3} (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_4) (Module.End.semiring.{u1, u3} R M _inst_1 _inst_2 _inst_4))))))) (LinearMap.instSMulLinearMap.{u1, u1, u2, u3, u3} R R S M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_6 _inst_7 _inst_8)
Case conversion may be inaccurate. Consider using '#align module.End.smul_comm_class' Module.End.smulCommClass'ₓ'. -/
instance Module.End.smulCommClass' [SMul S R] [IsScalarTower S R M] :
    SMulCommClass (Module.End R M) S (Module.End R M) :=
  SMulCommClass.symm _ _ _
#align module.End.smul_comm_class' Module.End.smulCommClass'

end

/-! ### Action by a module endomorphism. -/


#print LinearMap.applyModule /-
/-- The tautological action by `module.End R M` (aka `M →ₗ[R] M`) on `M`.

This generalizes `function.End.apply_mul_action`. -/
instance applyModule : Module (Module.End R M) M
    where
  smul := (· <| ·)
  smul_zero := LinearMap.map_zero
  smul_add := LinearMap.map_add
  add_smul := LinearMap.add_apply
  zero_smul := (LinearMap.zero_apply : ∀ m, (0 : M →ₗ[R] M) m = 0)
  one_smul _ := rfl
  mul_smul _ _ _ := rfl
#align linear_map.apply_module LinearMap.applyModule
-/

/- warning: linear_map.smul_def -> LinearMap.smul_def is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] (f : Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (a : M), Eq.{succ u2} M (SMul.smul.{u2, u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (SMulZeroClass.toHasSmul.{u2, u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u2, u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (MulZeroClass.toHasZero.{u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (MulZeroOneClass.toMulZeroClass.{u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (MonoidWithZero.toMulZeroOneClass.{u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Semiring.toMonoidWithZero.{u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Module.End.semiring.{u1, u2} R M _inst_1 _inst_2 _inst_4))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Semiring.toMonoidWithZero.{u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Module.End.semiring.{u1, u2} R M _inst_1 _inst_2 _inst_4)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u2, u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Module.End.semiring.{u1, u2} R M _inst_1 _inst_2 _inst_4) _inst_2 (LinearMap.applyModule.{u1, u2} R M _inst_1 _inst_2 _inst_4))))) f a) (coeFn.{succ u2, succ u2} (Module.End.{u1, u2} R M _inst_1 _inst_2 _inst_4) (fun (_x : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_2 _inst_2 _inst_4 _inst_4) => M -> M) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f a)
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_2] (f : Module.End.{u2, u1} R M _inst_1 _inst_2 _inst_4) (a : M), Eq.{succ u1} M (HSMul.hSMul.{u1, u1, u1} (Module.End.{u2, u1} R M _inst_1 _inst_2 _inst_4) M M (instHSMul.{u1, u1} (Module.End.{u2, u1} R M _inst_1 _inst_2 _inst_4) M (SMulZeroClass.toSMul.{u1, u1} (Module.End.{u2, u1} R M _inst_1 _inst_2 _inst_4) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u1} (Module.End.{u2, u1} R M _inst_1 _inst_2 _inst_4) M (LinearMap.instZeroLinearMap.{u2, u2, u1, u1} R R M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u1} (Module.End.{u2, u1} R M _inst_1 _inst_2 _inst_4) M (Semiring.toMonoidWithZero.{u1} (Module.End.{u2, u1} R M _inst_1 _inst_2 _inst_4) (Module.End.semiring.{u2, u1} R M _inst_1 _inst_2 _inst_4)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u1, u1} (Module.End.{u2, u1} R M _inst_1 _inst_2 _inst_4) M (Module.End.semiring.{u2, u1} R M _inst_1 _inst_2 _inst_4) _inst_2 (LinearMap.applyModule.{u2, u1} R M _inst_1 _inst_2 _inst_4)))))) f a) (FunLike.coe.{succ u1, succ u1, succ u1} (Module.End.{u2, u1} R M _inst_1 _inst_2 _inst_4) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, u1, u1} R R M M _inst_1 _inst_1 _inst_2 _inst_2 _inst_4 _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) f a)
Case conversion may be inaccurate. Consider using '#align linear_map.smul_def LinearMap.smul_defₓ'. -/
@[simp]
protected theorem smul_def (f : Module.End R M) (a : M) : f • a = f a :=
  rfl
#align linear_map.smul_def LinearMap.smul_def

#print LinearMap.apply_faithfulSMul /-
/-- `linear_map.apply_module` is faithful. -/
instance apply_faithfulSMul : FaithfulSMul (Module.End R M) M :=
  ⟨fun _ _ => LinearMap.ext⟩
#align linear_map.apply_has_faithful_smul LinearMap.apply_faithfulSMul
-/

#print LinearMap.apply_smulCommClass /-
instance apply_smulCommClass : SMulCommClass R (Module.End R M) M
    where smul_comm r e m := (e.map_smul r m).symm
#align linear_map.apply_smul_comm_class LinearMap.apply_smulCommClass
-/

#print LinearMap.apply_smulCommClass' /-
instance apply_smulCommClass' : SMulCommClass (Module.End R M) R M
    where smul_comm := LinearMap.map_smul
#align linear_map.apply_smul_comm_class' LinearMap.apply_smulCommClass'
-/

#print LinearMap.apply_isScalarTower /-
instance apply_isScalarTower {R M : Type _} [CommSemiring R] [AddCommMonoid M] [Module R M] :
    IsScalarTower R (Module.End R M) M :=
  ⟨fun t f m => rfl⟩
#align linear_map.apply_is_scalar_tower LinearMap.apply_isScalarTower
-/

end Endomorphisms

end LinearMap

/-! ### Actions as module endomorphisms -/


namespace DistribMulAction

variable (R M) [Semiring R] [AddCommMonoid M] [Module R M]

variable [Monoid S] [DistribMulAction S M] [SMulCommClass S R M]

/- warning: distrib_mul_action.to_linear_map -> DistribMulAction.toLinearMap is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {S : Type.{u2}} (M : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] [_inst_4 : Monoid.{u2} S] [_inst_5 : DistribMulAction.{u2, u3} S M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_6 : SMulCommClass.{u2, u1, u3} S R M (SMulZeroClass.toHasSmul.{u2, u3} S M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (DistribSMul.toSmulZeroClass.{u2, u3} S M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u2, u3} S M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5))) (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_2 _inst_3))))], S -> (LinearMap.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_2 _inst_2 _inst_3 _inst_3)
but is expected to have type
  forall (R : Type.{u1}) {S : Type.{u2}} (M : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] [_inst_4 : Monoid.{u2} S] [_inst_5 : DistribMulAction.{u2, u3} S M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_6 : SMulCommClass.{u2, u1, u3} S R M (SMulZeroClass.toSMul.{u2, u3} S M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribSMul.toSMulZeroClass.{u2, u3} S M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u2, u3} S M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5))) (SMulZeroClass.toSMul.{u1, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u3} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_2 _inst_3))))], S -> (LinearMap.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_2 _inst_2 _inst_3 _inst_3)
Case conversion may be inaccurate. Consider using '#align distrib_mul_action.to_linear_map DistribMulAction.toLinearMapₓ'. -/
/-- Each element of the monoid defines a linear map.

This is a stronger version of `distrib_mul_action.to_add_monoid_hom`. -/
@[simps]
def toLinearMap (s : S) : M →ₗ[R] M where
  toFun := SMul.smul s
  map_add' := smul_add s
  map_smul' a b := smul_comm _ _ _
#align distrib_mul_action.to_linear_map DistribMulAction.toLinearMap

/- warning: distrib_mul_action.to_module_End -> DistribMulAction.toModuleEnd is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {S : Type.{u2}} (M : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] [_inst_4 : Monoid.{u2} S] [_inst_5 : DistribMulAction.{u2, u3} S M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_6 : SMulCommClass.{u2, u1, u3} S R M (SMulZeroClass.toHasSmul.{u2, u3} S M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (DistribSMul.toSmulZeroClass.{u2, u3} S M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u2, u3} S M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5))) (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_2 _inst_3))))], MonoidHom.{u2, u3} S (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Monoid.toMulOneClass.{u2} S _inst_4) (MulZeroOneClass.toMulOneClass.{u3} (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_3) (NonAssocSemiring.toMulZeroOneClass.{u3} (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u3} (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Module.End.semiring.{u1, u3} R M _inst_1 _inst_2 _inst_3))))
but is expected to have type
  forall (R : Type.{u1}) {S : Type.{u2}} (M : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] [_inst_4 : Monoid.{u2} S] [_inst_5 : DistribMulAction.{u2, u3} S M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_6 : SMulCommClass.{u2, u1, u3} S R M (SMulZeroClass.toSMul.{u2, u3} S M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribSMul.toSMulZeroClass.{u2, u3} S M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u2, u3} S M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5))) (SMulZeroClass.toSMul.{u1, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u3} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_2 _inst_3))))], MonoidHom.{u2, u3} S (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Monoid.toMulOneClass.{u2} S _inst_4) (MulZeroOneClass.toMulOneClass.{u3} (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_3) (NonAssocSemiring.toMulZeroOneClass.{u3} (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u3} (Module.End.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Module.End.semiring.{u1, u3} R M _inst_1 _inst_2 _inst_3))))
Case conversion may be inaccurate. Consider using '#align distrib_mul_action.to_module_End DistribMulAction.toModuleEndₓ'. -/
/-- Each element of the monoid defines a module endomorphism.

This is a stronger version of `distrib_mul_action.to_add_monoid_End`. -/
@[simps]
def toModuleEnd : S →* Module.End R M
    where
  toFun := toLinearMap R M
  map_one' := LinearMap.ext <| one_smul _
  map_mul' a b := LinearMap.ext <| mul_smul _ _
#align distrib_mul_action.to_module_End DistribMulAction.toModuleEnd

end DistribMulAction

namespace Module

variable (R M) [Semiring R] [AddCommMonoid M] [Module R M]

variable [Semiring S] [Module S M] [SMulCommClass S R M]

#print Module.toModuleEnd /-
/-- Each element of the semiring defines a module endomorphism.

This is a stronger version of `distrib_mul_action.to_module_End`. -/
@[simps]
def toModuleEnd : S →+* Module.End R M :=
  {
    DistribMulAction.toModuleEnd R
      M with
    toFun := DistribMulAction.toLinearMap R M
    map_zero' := LinearMap.ext <| zero_smul _
    map_add' := fun f g => LinearMap.ext <| add_smul _ _ }
#align module.to_module_End Module.toModuleEnd
-/

/- warning: module.module_End_self -> Module.moduleEndSelf is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R], RingEquiv.{u1, u1} (MulOpposite.{u1} R) (Module.End.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (MulOpposite.hasMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (MulOpposite.hasAdd.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (LinearMap.module.End.hasMul.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (LinearMap.hasAdd.{u1, u1, u1, u1} R R R R _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) (Semiring.toModule.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R], RingEquiv.{u1, u1} (MulOpposite.{u1} R) (Module.End.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (MulOpposite.instMulMulOpposite.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (LinearMap.instMulEnd.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (MulOpposite.instAddMulOpposite.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (LinearMap.instAddLinearMap.{u1, u1, u1, u1} R R R R _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) (Semiring.toModule.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))
Case conversion may be inaccurate. Consider using '#align module.module_End_self Module.moduleEndSelfₓ'. -/
/-- The canonical (semi)ring isomorphism from `Rᵐᵒᵖ` to `module.End R R` induced by the right
multiplication. -/
@[simps]
def moduleEndSelf : Rᵐᵒᵖ ≃+* Module.End R R :=
  { Module.toModuleEnd R R with
    toFun := DistribMulAction.toLinearMap R R
    invFun := fun f => MulOpposite.op (f 1)
    left_inv := mul_one
    right_inv := fun f => LinearMap.ext_ring <| one_mul _ }
#align module.module_End_self Module.moduleEndSelf

/- warning: module.module_End_self_op -> Module.moduleEndSelfOp is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R], RingEquiv.{u1, u1} R (Module.End.{u1, u1} (MulOpposite.{u1} R) R (MulOpposite.semiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toOppositeModule.{u1} R _inst_1)) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (LinearMap.module.End.hasMul.{u1, u1} (MulOpposite.{u1} R) R (MulOpposite.semiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toOppositeModule.{u1} R _inst_1)) (LinearMap.hasAdd.{u1, u1, u1, u1} (MulOpposite.{u1} R) (MulOpposite.{u1} R) R R (MulOpposite.semiring.{u1} R _inst_1) (MulOpposite.semiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toOppositeModule.{u1} R _inst_1) (Semiring.toOppositeModule.{u1} R _inst_1) (RingHom.id.{u1} (MulOpposite.{u1} R) (Semiring.toNonAssocSemiring.{u1} (MulOpposite.{u1} R) (MulOpposite.semiring.{u1} R _inst_1))))
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R], RingEquiv.{u1, u1} R (Module.End.{u1, u1} (MulOpposite.{u1} R) R (MulOpposite.instSemiringMulOpposite.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toOppositeModule.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.instMulEnd.{u1, u1} (MulOpposite.{u1} R) R (MulOpposite.instSemiringMulOpposite.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toOppositeModule.{u1} R _inst_1)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (LinearMap.instAddLinearMap.{u1, u1, u1, u1} (MulOpposite.{u1} R) (MulOpposite.{u1} R) R R (MulOpposite.instSemiringMulOpposite.{u1} R _inst_1) (MulOpposite.instSemiringMulOpposite.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toOppositeModule.{u1} R _inst_1) (Semiring.toOppositeModule.{u1} R _inst_1) (RingHom.id.{u1} (MulOpposite.{u1} R) (Semiring.toNonAssocSemiring.{u1} (MulOpposite.{u1} R) (MulOpposite.instSemiringMulOpposite.{u1} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align module.module_End_self_op Module.moduleEndSelfOpₓ'. -/
/-- The canonical (semi)ring isomorphism from `R` to `module.End Rᵐᵒᵖ R` induced by the left
multiplication. -/
@[simps]
def moduleEndSelfOp : R ≃+* Module.End Rᵐᵒᵖ R :=
  { Module.toModuleEnd _ _ with
    toFun := DistribMulAction.toLinearMap _ _
    invFun := fun f => f 1
    left_inv := mul_one
    right_inv := fun f => LinearMap.ext_ring_op <| mul_one _ }
#align module.module_End_self_op Module.moduleEndSelfOp

/- warning: module.End.nat_cast_def -> Module.End.natCast_def is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {N₁ : Type.{u2}} [_inst_1 : Semiring.{u1} R] (n : Nat) [_inst_7 : AddCommMonoid.{u2} N₁] [_inst_8 : Module.{u1, u2} R N₁ _inst_1 _inst_7], Eq.{succ u2} (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (HasLiftT.mk.{1, succ u2} Nat (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (CoeTCₓ.coe.{1, succ u2} Nat (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (Nat.castCoe.{u2} (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (AddMonoidWithOne.toNatCast.{u2} (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (NonAssocSemiring.toAddCommMonoidWithOne.{u2} (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (Module.End.semiring.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8)))))))) n) (coeFn.{succ u2, succ u2} (RingHom.{0, u2} Nat (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (Module.End.semiring.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8))) (fun (_x : RingHom.{0, u2} Nat (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (Module.End.semiring.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8))) => Nat -> (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8)) (RingHom.hasCoeToFun.{0, u2} Nat (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (Module.End.semiring.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8))) (Module.toModuleEnd.{u1, 0, u2} R Nat N₁ _inst_1 _inst_7 _inst_8 Nat.semiring (AddCommMonoid.natModule.{u2} N₁ _inst_7) (AddMonoid.nat_smulCommClass.{u1, u2} R N₁ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} N₁ _inst_7) (Module.toDistribMulAction.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8))) n)
but is expected to have type
  forall (R : Type.{u1}) {N₁ : Type.{u2}} [_inst_1 : Semiring.{u1} R] (n : Nat) [_inst_7 : AddCommMonoid.{u2} N₁] [_inst_8 : Module.{u1, u2} R N₁ _inst_1 _inst_7], Eq.{succ u2} (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (Nat.cast.{u2} (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (Semiring.toNatCast.{u2} (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (Module.End.semiring.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8)) n) (FunLike.coe.{succ u2, 1, succ u2} (RingHom.{0, u2} Nat (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (Module.End.semiring.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8))) Nat (fun (_x : Nat) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Nat) => Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) _x) (MulHomClass.toFunLike.{u2, 0, u2} (RingHom.{0, u2} Nat (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (Module.End.semiring.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8))) Nat (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (NonUnitalNonAssocSemiring.toMul.{0} Nat (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring))) (NonUnitalNonAssocSemiring.toMul.{u2} (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (Module.End.semiring.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8)))) (NonUnitalRingHomClass.toMulHomClass.{u2, 0, u2} (RingHom.{0, u2} Nat (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (Module.End.semiring.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8))) Nat (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (Module.End.semiring.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8))) (RingHomClass.toNonUnitalRingHomClass.{u2, 0, u2} (RingHom.{0, u2} Nat (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (Module.End.semiring.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8))) Nat (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (Module.End.semiring.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8)) (RingHom.instRingHomClassRingHom.{0, u2} Nat (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8) (Module.End.semiring.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8)))))) (Module.toModuleEnd.{u1, 0, u2} R Nat N₁ _inst_1 _inst_7 _inst_8 Nat.semiring (AddCommMonoid.natModule.{u2} N₁ _inst_7) (AddMonoid.nat_smulCommClass.{u1, u2} R N₁ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} N₁ _inst_7) (Module.toDistribMulAction.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8))) n)
Case conversion may be inaccurate. Consider using '#align module.End.nat_cast_def Module.End.natCast_defₓ'. -/
theorem End.natCast_def (n : ℕ) [AddCommMonoid N₁] [Module R N₁] :
    (↑n : Module.End R N₁) = Module.toModuleEnd R N₁ n :=
  rfl
#align module.End.nat_cast_def Module.End.natCast_def

/- warning: module.End.int_cast_def -> Module.End.intCast_def is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {N₁ : Type.{u2}} [_inst_1 : Semiring.{u1} R] (z : Int) [_inst_7 : AddCommGroup.{u2} N₁] [_inst_8 : Module.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7)], Eq.{succ u2} (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Int (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (HasLiftT.mk.{1, succ u2} Int (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (CoeTCₓ.coe.{1, succ u2} Int (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (Int.castCoe.{u2} (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (AddGroupWithOne.toHasIntCast.{u2} (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (NonAssocRing.toAddGroupWithOne.{u2} (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (Ring.toNonAssocRing.{u2} (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (Module.End.ring.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8))))))) z) (coeFn.{succ u2, succ u2} (RingHom.{0, u2} Int (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (Semiring.toNonAssocSemiring.{0} Int Int.semiring) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (Module.End.semiring.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8))) (fun (_x : RingHom.{0, u2} Int (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (Semiring.toNonAssocSemiring.{0} Int Int.semiring) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (Module.End.semiring.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8))) => Int -> (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8)) (RingHom.hasCoeToFun.{0, u2} Int (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (Semiring.toNonAssocSemiring.{0} Int Int.semiring) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (Module.End.semiring.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8))) (Module.toModuleEnd.{u1, 0, u2} R Int N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8 Int.semiring (AddCommGroup.intModule.{u2} N₁ _inst_7) (AddGroup.int_smulCommClass.{u1, u2} R N₁ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommGroup.toAddGroup.{u2} N₁ _inst_7) (Module.toDistribMulAction.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8))) z)
but is expected to have type
  forall (R : Type.{u1}) {N₁ : Type.{u2}} [_inst_1 : Semiring.{u1} R] (z : Int) [_inst_7 : AddCommGroup.{u2} N₁] [_inst_8 : Module.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7)], Eq.{succ u2} (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (Int.cast.{u2} (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (Ring.toIntCast.{u2} (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (Module.End.ring.{u1, u2} R N₁ _inst_1 _inst_7 _inst_8)) z) (FunLike.coe.{succ u2, 1, succ u2} (RingHom.{0, u2} Int (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (Module.End.semiring.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8))) Int (fun (_x : Int) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Int) => Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) _x) (MulHomClass.toFunLike.{u2, 0, u2} (RingHom.{0, u2} Int (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (Module.End.semiring.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8))) Int (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (NonUnitalNonAssocSemiring.toMul.{0} Int (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt))) (NonUnitalNonAssocSemiring.toMul.{u2} (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (Module.End.semiring.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8)))) (NonUnitalRingHomClass.toMulHomClass.{u2, 0, u2} (RingHom.{0, u2} Int (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (Module.End.semiring.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8))) Int (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (Module.End.semiring.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8))) (RingHomClass.toNonUnitalRingHomClass.{u2, 0, u2} (RingHom.{0, u2} Int (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (Module.End.semiring.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8))) Int (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (Module.End.semiring.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8)) (RingHom.instRingHomClassRingHom.{0, u2} Int (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8) (Module.End.semiring.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8)))))) (Module.toModuleEnd.{u1, 0, u2} R Int N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8 Int.instSemiringInt (AddCommGroup.intModule.{u2} N₁ _inst_7) (AddGroup.int_smulCommClass.{u1, u2} R N₁ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommGroup.toAddGroup.{u2} N₁ _inst_7) (Module.toDistribMulAction.{u1, u2} R N₁ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} N₁ _inst_7) _inst_8))) z)
Case conversion may be inaccurate. Consider using '#align module.End.int_cast_def Module.End.intCast_defₓ'. -/
theorem End.intCast_def (z : ℤ) [AddCommGroup N₁] [Module R N₁] :
    (↑z : Module.End R N₁) = Module.toModuleEnd R N₁ z :=
  rfl
#align module.End.int_cast_def Module.End.intCast_def

end Module

