/-
Copyright (c) 2020 Anne Baanen. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Nathaniel Thomas, Jeremy Avigad, Johannes Hölzl, Mario Carneiro, Anne Baanen,
  Frédéric Dupuis, Heather Macbeth

! This file was ported from Lean 3 source module algebra.module.equiv
! leanprover-community/mathlib commit fac369018417f980cec5fcdafc766a69f88d8cfe
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Module.LinearMap

/-!
# (Semi)linear equivalences

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file we define

* `linear_equiv σ M M₂`, `M ≃ₛₗ[σ] M₂`: an invertible semilinear map. Here, `σ` is a `ring_hom`
  from `R` to `R₂` and an `e : M ≃ₛₗ[σ] M₂` satisfies `e (c • x) = (σ c) • (e x)`. The plain
  linear version, with `σ` being `ring_hom.id R`, is denoted by `M ≃ₗ[R] M₂`, and the
  star-linear version (with `σ` being `star_ring_end`) is denoted by `M ≃ₗ⋆[R] M₂`.

## Implementation notes

To ensure that composition works smoothly for semilinear equivalences, we use the typeclasses
`ring_hom_comp_triple`, `ring_hom_inv_pair` and `ring_hom_surjective` from
`algebra/ring/comp_typeclasses`.

The group structure on automorphisms, `linear_equiv.automorphism_group`, is provided elsewhere.

## TODO

* Parts of this file have not yet been generalized to semilinear maps

## Tags

linear equiv, linear equivalences, linear isomorphism, linear isomorphic
-/


open Function

universe u u' v w x y z

variable {R : Type _} {R₁ : Type _} {R₂ : Type _} {R₃ : Type _}

variable {k : Type _} {S : Type _} {M : Type _} {M₁ : Type _} {M₂ : Type _} {M₃ : Type _}

variable {N₁ : Type _} {N₂ : Type _} {N₃ : Type _} {N₄ : Type _} {ι : Type _}

section

#print LinearEquiv /-
/-- A linear equivalence is an invertible linear map. -/
@[nolint has_nonempty_instance]
structure LinearEquiv {R : Type _} {S : Type _} [Semiring R] [Semiring S] (σ : R →+* S)
  {σ' : S →+* R} [RingHomInvPair σ σ'] [RingHomInvPair σ' σ] (M : Type _) (M₂ : Type _)
  [AddCommMonoid M] [AddCommMonoid M₂] [Module R M] [Module S M₂] extends LinearMap σ M M₂, M ≃+ M₂
#align linear_equiv LinearEquiv
-/

attribute [nolint doc_blame] LinearEquiv.toLinearMap

attribute [nolint doc_blame] LinearEquiv.toAddEquiv

-- mathport name: «expr ≃ₛₗ[ ] »
notation:50 M " ≃ₛₗ[" σ "] " M₂ => LinearEquiv σ M M₂

-- mathport name: «expr ≃ₗ[ ] »
notation:50 M " ≃ₗ[" R "] " M₂ => LinearEquiv (RingHom.id R) M M₂

-- mathport name: «expr ≃ₗ⋆[ ] »
notation:50 M " ≃ₗ⋆[" R "] " M₂ => LinearEquiv (starRingEnd R) M M₂

#print SemilinearEquivClass /-
/-- `semilinear_equiv_class F σ M M₂` asserts `F` is a type of bundled `σ`-semilinear equivs
`M → M₂`.

See also `linear_equiv_class F R M M₂` for the case where `σ` is the identity map on `R`.

A map `f` between an `R`-module and an `S`-module over a ring homomorphism `σ : R →+* S`
is semilinear if it satisfies the two properties `f (x + y) = f x + f y` and
`f (c • x) = (σ c) • f x`. -/
class SemilinearEquivClass (F : Type _) {R S : outParam (Type _)} [Semiring R] [Semiring S]
  (σ : outParam <| R →+* S) {σ' : outParam <| S →+* R} [RingHomInvPair σ σ'] [RingHomInvPair σ' σ]
  (M M₂ : outParam (Type _)) [AddCommMonoid M] [AddCommMonoid M₂] [Module R M] [Module S M₂] extends
  AddEquivClass F M M₂ where
  map_smulₛₗ : ∀ (f : F) (r : R) (x : M), f (r • x) = σ r • f x
#align semilinear_equiv_class SemilinearEquivClass
-/

-- `R, S, σ, σ'` become metavars, but it's OK since they are outparams.
attribute [nolint dangerous_instance] SemilinearEquivClass.toAddEquivClass

#print LinearEquivClass /-
/-- `linear_equiv_class F R M M₂` asserts `F` is a type of bundled `R`-linear equivs `M → M₂`.
This is an abbreviation for `semilinear_equiv_class F (ring_hom.id R) M M₂`.
-/
abbrev LinearEquivClass (F : Type _) (R M M₂ : outParam (Type _)) [Semiring R] [AddCommMonoid M]
    [AddCommMonoid M₂] [Module R M] [Module R M₂] :=
  SemilinearEquivClass F (RingHom.id R) M M₂
#align linear_equiv_class LinearEquivClass
-/

end

namespace SemilinearEquivClass

variable (F : Type _) [Semiring R] [Semiring S]

variable [AddCommMonoid M] [AddCommMonoid M₁] [AddCommMonoid M₂]

variable [Module R M] [Module S M₂] {σ : R →+* S} {σ' : S →+* R}

-- `σ'` becomes a metavariable, but it's OK since it's an outparam
@[nolint dangerous_instance]
instance (priority := 100) [RingHomInvPair σ σ'] [RingHomInvPair σ' σ]
    [s : SemilinearEquivClass F σ M M₂] : SemilinearMapClass F σ M M₂ :=
  { s with
    coe := (coe : F → M → M₂)
    coe_injective' := @FunLike.coe_injective F _ _ _ }

end SemilinearEquivClass

namespace LinearEquiv

section AddCommMonoid

variable {M₄ : Type _}

variable [Semiring R] [Semiring S]

section

variable [AddCommMonoid M] [AddCommMonoid M₁] [AddCommMonoid M₂]

variable [Module R M] [Module S M₂] {σ : R →+* S} {σ' : S →+* R}

variable [RingHomInvPair σ σ'] [RingHomInvPair σ' σ]

include R

include σ'

instance : Coe (M ≃ₛₗ[σ] M₂) (M →ₛₗ[σ] M₂) :=
  ⟨toLinearMap⟩

-- see Note [function coercion]
instance : CoeFun (M ≃ₛₗ[σ] M₂) fun _ => M → M₂ :=
  ⟨toFun⟩

/- warning: linear_equiv.coe_mk -> LinearEquiv.coe_mk is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_6 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_7 : Module.{u2, u4} S M₂ _inst_2 _inst_5] {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} [_inst_8 : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'] [_inst_9 : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ] {to_fun : M -> M₂} {inv_fun : M₂ -> M} {map_add : forall (x : M) (y : M), Eq.{succ u4} M₂ (to_fun (HAdd.hAdd.{u3, u3, u3} M M M (instHAdd.{u3} M (AddZeroClass.toHasAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)))) x y)) (HAdd.hAdd.{u4, u4, u4} M₂ M₂ M₂ (instHAdd.{u4} M₂ (AddZeroClass.toHasAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5)))) (to_fun x) (to_fun y))} {map_smul : forall (r : R) (x : M), Eq.{succ u4} M₂ (to_fun (SMul.smul.{u1, u3} R M (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_3 _inst_6)))) r x)) (SMul.smul.{u2, u4} S M₂ (SMulZeroClass.toHasSmul.{u2, u4} S M₂ (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) (SMulWithZero.toSmulZeroClass.{u2, u4} S M₂ (MulZeroClass.toHasZero.{u2} S (MulZeroOneClass.toMulZeroClass.{u2} S (MonoidWithZero.toMulZeroOneClass.{u2} S (Semiring.toMonoidWithZero.{u2} S _inst_2)))) (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) (MulActionWithZero.toSMulWithZero.{u2, u4} S M₂ (Semiring.toMonoidWithZero.{u2} S _inst_2) (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) (Module.toMulActionWithZero.{u2, u4} S M₂ _inst_2 _inst_5 _inst_7)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (fun (_x : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) σ r) (to_fun x))} {left_inv : Function.LeftInverse.{succ u3, succ u4} M M₂ inv_fun to_fun} {right_inv : Function.RightInverse.{succ u3, succ u4} M M₂ inv_fun to_fun}, Eq.{max (succ u3) (succ u4)} (M -> M₂) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 σ σ' _inst_8 _inst_9) (LinearEquiv.mk.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7 to_fun map_add map_smul inv_fun left_inv right_inv)) to_fun
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_6 : Module.{u2, u3} R M _inst_1 _inst_3] [_inst_7 : Module.{u1, u4} S M₂ _inst_2 _inst_5] {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} {σ' : RingHom.{u1, u2} S R (Semiring.toNonAssocSemiring.{u1} S _inst_2) (Semiring.toNonAssocSemiring.{u2} R _inst_1)} [_inst_8 : RingHomInvPair.{u2, u1} R S _inst_1 _inst_2 σ σ'] [_inst_9 : RingHomInvPair.{u1, u2} S R _inst_2 _inst_1 σ' σ] {to_fun : M -> M₂} {inv_fun : M₂ -> M} {map_add : forall (x : M) (y : M), Eq.{succ u4} M₂ (to_fun (HAdd.hAdd.{u3, u3, u3} M M M (instHAdd.{u3} M (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)))) x y)) (HAdd.hAdd.{u4, u4, u4} M₂ M₂ M₂ (instHAdd.{u4} M₂ (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5)))) (to_fun x) (to_fun y))} {map_smul : forall (r : R) (x : M), Eq.{succ u4} M₂ (AddHom.toFun.{u3, u4} M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) (AddHom.mk.{u3, u4} M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) to_fun map_add) (HSMul.hSMul.{u2, u3, u3} R M M (instHSMul.{u2, u3} R M (SMulZeroClass.toSMul.{u2, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u2, u3} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_3 _inst_6))))) r x)) (HSMul.hSMul.{u1, u4, u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) r) M₂ M₂ (instHSMul.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) r) M₂ (SMulZeroClass.toSMul.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) r) M₂ (AddMonoid.toZero.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5)) (SMulWithZero.toSMulZeroClass.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) r) M₂ (MonoidWithZero.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) r) (Semiring.toMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) r) _inst_2)) (AddMonoid.toZero.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5)) (MulActionWithZero.toSMulWithZero.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) r) M₂ (Semiring.toMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) r) _inst_2) (AddMonoid.toZero.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5)) (Module.toMulActionWithZero.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) r) M₂ _inst_2 _inst_5 _inst_7))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)) R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2) (RingHom.instRingHomClassRingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2))))) σ r) (AddHom.toFun.{u3, u4} M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) (AddHom.mk.{u3, u4} M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) to_fun map_add) x))} {left_inv : Function.LeftInverse.{succ u3, succ u4} M M₂ inv_fun (AddHom.toFun.{u3, u4} M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) (LinearMap.toAddHom.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_3 _inst_5 _inst_6 _inst_7 (LinearMap.mk.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_3 _inst_5 _inst_6 _inst_7 (AddHom.mk.{u3, u4} M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) to_fun map_add) map_smul)))} {right_inv : Function.RightInverse.{succ u3, succ u4} M M₂ inv_fun (AddHom.toFun.{u3, u4} M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) (LinearMap.toAddHom.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_3 _inst_5 _inst_6 _inst_7 (LinearMap.mk.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_3 _inst_5 _inst_6 _inst_7 (AddHom.mk.{u3, u4} M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) to_fun map_add) map_smul)))}, Eq.{max (succ u3) (succ u4)} (forall (ᾰ : M), (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) ᾰ) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) M M₂ (EquivLike.toEmbeddingLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) M M₂ (AddEquivClass.toEquivLike.{max u3 u4, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) (SemilinearEquivClass.toAddEquivClass.{max u3 u4, u2, u1, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7 (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 σ σ' _inst_8 _inst_9))))) (LinearEquiv.mk.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7 (LinearMap.mk.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_3 _inst_5 _inst_6 _inst_7 (AddHom.mk.{u3, u4} M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) to_fun map_add) map_smul) inv_fun left_inv right_inv)) to_fun
Case conversion may be inaccurate. Consider using '#align linear_equiv.coe_mk LinearEquiv.coe_mkₓ'. -/
@[simp]
theorem coe_mk {to_fun inv_fun map_add map_smul left_inv right_inv} :
    ⇑(⟨to_fun, map_add, map_smul, inv_fun, left_inv, right_inv⟩ : M ≃ₛₗ[σ] M₂) = to_fun :=
  rfl
#align linear_equiv.coe_mk LinearEquiv.coe_mk

#print LinearEquiv.toEquiv /-
-- This exists for compatibility, previously `≃ₗ[R]` extended `≃` instead of `≃+`.
@[nolint doc_blame]
def toEquiv : (M ≃ₛₗ[σ] M₂) → M ≃ M₂ := fun f => f.toAddEquiv.toEquiv
#align linear_equiv.to_equiv LinearEquiv.toEquiv
-/

/- warning: linear_equiv.to_equiv_injective -> LinearEquiv.toEquiv_injective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_6 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_7 : Module.{u2, u4} S M₂ _inst_2 _inst_5] {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} [_inst_8 : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'] [_inst_9 : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ], Function.Injective.{max (succ u3) (succ u4), max 1 (max (succ u3) (succ u4)) (succ u4) (succ u3)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (Equiv.{succ u3, succ u4} M M₂) (LinearEquiv.toEquiv.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 σ σ' _inst_8 _inst_9)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u4}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_3 : AddCommMonoid.{u4} M] [_inst_5 : AddCommMonoid.{u3} M₂] [_inst_6 : Module.{u2, u4} R M _inst_1 _inst_3] [_inst_7 : Module.{u1, u3} S M₂ _inst_2 _inst_5] {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} {σ' : RingHom.{u1, u2} S R (Semiring.toNonAssocSemiring.{u1} S _inst_2) (Semiring.toNonAssocSemiring.{u2} R _inst_1)} [_inst_8 : RingHomInvPair.{u2, u1} R S _inst_1 _inst_2 σ σ'] [_inst_9 : RingHomInvPair.{u1, u2} S R _inst_2 _inst_1 σ' σ], Function.Injective.{max (succ u4) (succ u3), max (succ u4) (succ u3)} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (Equiv.{succ u4, succ u3} M M₂) (LinearEquiv.toEquiv.{u2, u1, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 σ σ' _inst_8 _inst_9)
Case conversion may be inaccurate. Consider using '#align linear_equiv.to_equiv_injective LinearEquiv.toEquiv_injectiveₓ'. -/
theorem toEquiv_injective : Function.Injective (toEquiv : (M ≃ₛₗ[σ] M₂) → M ≃ M₂) :=
  fun ⟨_, _, _, _, _, _⟩ ⟨_, _, _, _, _, _⟩ h => LinearEquiv.mk.inj_eq.mpr (Equiv.mk.inj h)
#align linear_equiv.to_equiv_injective LinearEquiv.toEquiv_injective

/- warning: linear_equiv.to_equiv_inj -> LinearEquiv.toEquiv_inj is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_6 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_7 : Module.{u2, u4} S M₂ _inst_2 _inst_5] {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} [_inst_8 : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'] [_inst_9 : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ] {e₁ : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7} {e₂ : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7}, Iff (Eq.{max 1 (max (succ u3) (succ u4)) (succ u4) (succ u3)} (Equiv.{succ u3, succ u4} M M₂) (LinearEquiv.toEquiv.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 σ σ' _inst_8 _inst_9 e₁) (LinearEquiv.toEquiv.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 σ σ' _inst_8 _inst_9 e₂)) (Eq.{max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) e₁ e₂)
but is expected to have type
  forall {R : Type.{u4}} {S : Type.{u3}} {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_1 : Semiring.{u4} R] [_inst_2 : Semiring.{u3} S] [_inst_3 : AddCommMonoid.{u2} M] [_inst_5 : AddCommMonoid.{u1} M₂] [_inst_6 : Module.{u4, u2} R M _inst_1 _inst_3] [_inst_7 : Module.{u3, u1} S M₂ _inst_2 _inst_5] {σ : RingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)} {σ' : RingHom.{u3, u4} S R (Semiring.toNonAssocSemiring.{u3} S _inst_2) (Semiring.toNonAssocSemiring.{u4} R _inst_1)} [_inst_8 : RingHomInvPair.{u4, u3} R S _inst_1 _inst_2 σ σ'] [_inst_9 : RingHomInvPair.{u3, u4} S R _inst_2 _inst_1 σ' σ] {e₁ : LinearEquiv.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7} {e₂ : LinearEquiv.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7}, Iff (Eq.{max (succ u2) (succ u1)} (Equiv.{succ u2, succ u1} M M₂) (LinearEquiv.toEquiv.{u4, u3, u2, u1} R S M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 σ σ' _inst_8 _inst_9 e₁) (LinearEquiv.toEquiv.{u4, u3, u2, u1} R S M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 σ σ' _inst_8 _inst_9 e₂)) (Eq.{max (succ u2) (succ u1)} (LinearEquiv.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) e₁ e₂)
Case conversion may be inaccurate. Consider using '#align linear_equiv.to_equiv_inj LinearEquiv.toEquiv_injₓ'. -/
@[simp]
theorem toEquiv_inj {e₁ e₂ : M ≃ₛₗ[σ] M₂} : e₁.toEquiv = e₂.toEquiv ↔ e₁ = e₂ :=
  toEquiv_injective.eq_iff
#align linear_equiv.to_equiv_inj LinearEquiv.toEquiv_inj

/- warning: linear_equiv.to_linear_map_injective -> LinearEquiv.toLinearMap_injective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_6 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_7 : Module.{u2, u4} S M₂ _inst_2 _inst_5] {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} [_inst_8 : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'] [_inst_9 : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ], Function.Injective.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_3 _inst_5 _inst_6 _inst_7) ((fun (a : Sort.{max (succ u3) (succ u4)}) (b : Sort.{max (succ u3) (succ u4)}) [self : HasLiftT.{max (succ u3) (succ u4), max (succ u3) (succ u4)} a b] => self.0) (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (HasLiftT.mk.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (CoeTCₓ.coe.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (coeBase.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (LinearEquiv.LinearMap.hasCoe.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 σ σ' _inst_8 _inst_9)))))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u4}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_3 : AddCommMonoid.{u4} M] [_inst_5 : AddCommMonoid.{u3} M₂] [_inst_6 : Module.{u2, u4} R M _inst_1 _inst_3] [_inst_7 : Module.{u1, u3} S M₂ _inst_2 _inst_5] {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} {σ' : RingHom.{u1, u2} S R (Semiring.toNonAssocSemiring.{u1} S _inst_2) (Semiring.toNonAssocSemiring.{u2} R _inst_1)} [_inst_8 : RingHomInvPair.{u2, u1} R S _inst_1 _inst_2 σ σ'] [_inst_9 : RingHomInvPair.{u1, u2} S R _inst_2 _inst_1 σ' σ], Function.Injective.{max (succ u4) (succ u3), max (succ u4) (succ u3)} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (LinearMap.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (LinearEquiv.toLinearMap.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7)
Case conversion may be inaccurate. Consider using '#align linear_equiv.to_linear_map_injective LinearEquiv.toLinearMap_injectiveₓ'. -/
theorem toLinearMap_injective : Injective (coe : (M ≃ₛₗ[σ] M₂) → M →ₛₗ[σ] M₂) := fun e₁ e₂ H =>
  toEquiv_injective <| Equiv.ext <| LinearMap.congr_fun H
#align linear_equiv.to_linear_map_injective LinearEquiv.toLinearMap_injective

/- warning: linear_equiv.to_linear_map_inj -> LinearEquiv.toLinearMap_inj is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_6 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_7 : Module.{u2, u4} S M₂ _inst_2 _inst_5] {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} [_inst_8 : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'] [_inst_9 : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ] {e₁ : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7} {e₂ : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7}, Iff (Eq.{max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_3 _inst_5 _inst_6 _inst_7) ((fun (a : Sort.{max (succ u3) (succ u4)}) (b : Sort.{max (succ u3) (succ u4)}) [self : HasLiftT.{max (succ u3) (succ u4), max (succ u3) (succ u4)} a b] => self.0) (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (HasLiftT.mk.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (CoeTCₓ.coe.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (coeBase.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (LinearEquiv.LinearMap.hasCoe.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 σ σ' _inst_8 _inst_9)))) e₁) ((fun (a : Sort.{max (succ u3) (succ u4)}) (b : Sort.{max (succ u3) (succ u4)}) [self : HasLiftT.{max (succ u3) (succ u4), max (succ u3) (succ u4)} a b] => self.0) (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (HasLiftT.mk.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (CoeTCₓ.coe.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (coeBase.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (LinearEquiv.LinearMap.hasCoe.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 σ σ' _inst_8 _inst_9)))) e₂)) (Eq.{max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) e₁ e₂)
but is expected to have type
  forall {R : Type.{u4}} {S : Type.{u3}} {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_1 : Semiring.{u4} R] [_inst_2 : Semiring.{u3} S] [_inst_3 : AddCommMonoid.{u2} M] [_inst_5 : AddCommMonoid.{u1} M₂] [_inst_6 : Module.{u4, u2} R M _inst_1 _inst_3] [_inst_7 : Module.{u3, u1} S M₂ _inst_2 _inst_5] {σ : RingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)} {σ' : RingHom.{u3, u4} S R (Semiring.toNonAssocSemiring.{u3} S _inst_2) (Semiring.toNonAssocSemiring.{u4} R _inst_1)} [_inst_8 : RingHomInvPair.{u4, u3} R S _inst_1 _inst_2 σ σ'] [_inst_9 : RingHomInvPair.{u3, u4} S R _inst_2 _inst_1 σ' σ] {e₁ : LinearEquiv.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7} {e₂ : LinearEquiv.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7}, Iff (Eq.{max (succ u2) (succ u1)} (LinearMap.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (LinearEquiv.toLinearMap.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7 e₁) (LinearEquiv.toLinearMap.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7 e₂)) (Eq.{max (succ u2) (succ u1)} (LinearEquiv.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) e₁ e₂)
Case conversion may be inaccurate. Consider using '#align linear_equiv.to_linear_map_inj LinearEquiv.toLinearMap_injₓ'. -/
@[simp, norm_cast]
theorem toLinearMap_inj {e₁ e₂ : M ≃ₛₗ[σ] M₂} : (e₁ : M →ₛₗ[σ] M₂) = e₂ ↔ e₁ = e₂ :=
  toLinearMap_injective.eq_iff
#align linear_equiv.to_linear_map_inj LinearEquiv.toLinearMap_inj

instance : SemilinearEquivClass (M ≃ₛₗ[σ] M₂) σ M M₂
    where
  coe := LinearEquiv.toFun
  inv := LinearEquiv.invFun
  coe_injective' f g h₁ h₂ := by
    cases f
    cases g
    congr
  left_inv := LinearEquiv.left_inv
  right_inv := LinearEquiv.right_inv
  map_add := map_add'
  map_smulₛₗ := map_smul'

/- warning: linear_equiv.coe_injective -> LinearEquiv.coe_injective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_6 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_7 : Module.{u2, u4} S M₂ _inst_2 _inst_5] {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} [_inst_8 : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'] [_inst_9 : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ], Function.Injective.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (M -> M₂) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (fun (ᾰ : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 σ σ' _inst_8 _inst_9))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_6 : Module.{u2, u3} R M _inst_1 _inst_3] [_inst_7 : Module.{u1, u4} S M₂ _inst_2 _inst_5] {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} {σ' : RingHom.{u1, u2} S R (Semiring.toNonAssocSemiring.{u1} S _inst_2) (Semiring.toNonAssocSemiring.{u2} R _inst_1)} [_inst_8 : RingHomInvPair.{u2, u1} R S _inst_1 _inst_2 σ σ'] [_inst_9 : RingHomInvPair.{u1, u2} S R _inst_2 _inst_1 σ' σ], Function.Injective.{max (succ u4) (succ u3), max (succ u3) (succ u4)} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (M -> M₂) (CoeFun.coe.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) (fun (ᾰ : LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) => M -> M₂) (FunLike.hasCoeToFun.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) M (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) (EmbeddingLike.toFunLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) M M₂ (EquivLike.toEmbeddingLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) M M₂ (AddEquivClass.toEquivLike.{max u3 u4, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) (SemilinearEquivClass.toAddEquivClass.{max u3 u4, u2, u1, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7) R S _inst_1 _inst_2 σ σ' _inst_8 _inst_9 M M₂ _inst_3 _inst_5 _inst_6 _inst_7 (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 σ σ' _inst_8 _inst_9)))))))
Case conversion may be inaccurate. Consider using '#align linear_equiv.coe_injective LinearEquiv.coe_injectiveₓ'. -/
theorem coe_injective : @Injective (M ≃ₛₗ[σ] M₂) (M → M₂) coeFn :=
  FunLike.coe_injective
#align linear_equiv.coe_injective LinearEquiv.coe_injective

end

section

variable [Semiring R₁] [Semiring R₂] [Semiring R₃]

variable [AddCommMonoid M] [AddCommMonoid M₁] [AddCommMonoid M₂]

variable [AddCommMonoid M₃] [AddCommMonoid M₄]

variable [AddCommMonoid N₁] [AddCommMonoid N₂]

variable {module_M : Module R M} {module_S_M₂ : Module S M₂} {σ : R →+* S} {σ' : S →+* R}

variable {re₁ : RingHomInvPair σ σ'} {re₂ : RingHomInvPair σ' σ}

variable (e e' : M ≃ₛₗ[σ] M₂)

theorem toLinearMap_eq_coe : e.toLinearMap = (e : M →ₛₗ[σ] M₂) :=
  rfl
#align linear_equiv.to_linear_map_eq_coe LinearEquiv.toLinearMap_eq_coe

/- warning: linear_equiv.coe_coe -> LinearEquiv.coe_coe is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂), Eq.{max (succ u3) (succ u4)} (M -> M₂) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ) ((fun (a : Sort.{max (succ u3) (succ u4)}) (b : Sort.{max (succ u3) (succ u4)}) [self : HasLiftT.{max (succ u3) (succ u4), max (succ u3) (succ u4)} a b] => self.0) (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (HasLiftT.mk.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (CoeTCₓ.coe.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (coeBase.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (LinearEquiv.LinearMap.hasCoe.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂)))) e)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u4}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_6 : AddCommMonoid.{u4} M] [_inst_8 : AddCommMonoid.{u3} M₂] {module_M : Module.{u2, u4} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u1, u3} S M₂ _inst_2 _inst_8} {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} {σ' : RingHom.{u1, u2} S R (Semiring.toNonAssocSemiring.{u1} S _inst_2) (Semiring.toNonAssocSemiring.{u2} R _inst_1)} {re₁ : RingHomInvPair.{u2, u1} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u1, u2} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂), Eq.{max (succ u4) (succ u3)} (forall (ᾰ : M), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) ᾰ) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearMap.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u2, u1, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ) (LinearEquiv.toLinearMap.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ e)) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u4 u3, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u4 u3, u2, u1, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e)
Case conversion may be inaccurate. Consider using '#align linear_equiv.coe_coe LinearEquiv.coe_coeₓ'. -/
@[simp, norm_cast]
theorem coe_coe : ⇑(e : M →ₛₗ[σ] M₂) = e :=
  rfl
#align linear_equiv.coe_coe LinearEquiv.coe_coe

/- warning: linear_equiv.coe_to_equiv -> LinearEquiv.coe_toEquiv is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂), Eq.{max (succ u3) (succ u4)} (M -> M₂) (coeFn.{max 1 (max (succ u3) (succ u4)) (succ u4) (succ u3), max (succ u3) (succ u4)} (Equiv.{succ u3, succ u4} M M₂) (fun (_x : Equiv.{succ u3, succ u4} M M₂) => M -> M₂) (Equiv.hasCoeToFun.{succ u3, succ u4} M M₂) (LinearEquiv.toEquiv.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂ e)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u4}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_6 : AddCommMonoid.{u4} M] [_inst_8 : AddCommMonoid.{u3} M₂] {module_M : Module.{u2, u4} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u1, u3} S M₂ _inst_2 _inst_8} {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} {σ' : RingHom.{u1, u2} S R (Semiring.toNonAssocSemiring.{u1} S _inst_2) (Semiring.toNonAssocSemiring.{u2} R _inst_1)} {re₁ : RingHomInvPair.{u2, u1} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u1, u2} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂), Eq.{max (succ u4) (succ u3)} (forall (ᾰ : M), (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => M₂) ᾰ) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (Equiv.{succ u4, succ u3} M M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => M₂) _x) (Equiv.instFunLikeEquiv.{succ u4, succ u3} M M₂) (LinearEquiv.toEquiv.{u2, u1, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂ e)) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u4 u3, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u4 u3, u2, u1, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e)
Case conversion may be inaccurate. Consider using '#align linear_equiv.coe_to_equiv LinearEquiv.coe_toEquivₓ'. -/
@[simp]
theorem coe_toEquiv : ⇑e.toEquiv = e :=
  rfl
#align linear_equiv.coe_to_equiv LinearEquiv.coe_toEquiv

/- warning: linear_equiv.coe_to_linear_map -> LinearEquiv.coe_toLinearMap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂), Eq.{max (succ u3) (succ u4)} (M -> M₂) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ) (LinearEquiv.toLinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ e)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u4}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_6 : AddCommMonoid.{u4} M] [_inst_8 : AddCommMonoid.{u3} M₂] {module_M : Module.{u2, u4} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u1, u3} S M₂ _inst_2 _inst_8} {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} {σ' : RingHom.{u1, u2} S R (Semiring.toNonAssocSemiring.{u1} S _inst_2) (Semiring.toNonAssocSemiring.{u2} R _inst_1)} {re₁ : RingHomInvPair.{u2, u1} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u1, u2} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂), Eq.{max (succ u4) (succ u3)} (forall (ᾰ : M), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) ᾰ) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearMap.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u2, u1, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ) (LinearEquiv.toLinearMap.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ e)) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u4 u3, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u4 u3, u2, u1, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e)
Case conversion may be inaccurate. Consider using '#align linear_equiv.coe_to_linear_map LinearEquiv.coe_toLinearMapₓ'. -/
@[simp]
theorem coe_toLinearMap : ⇑e.toLinearMap = e :=
  rfl
#align linear_equiv.coe_to_linear_map LinearEquiv.coe_toLinearMap

/- warning: linear_equiv.to_fun_eq_coe -> LinearEquiv.toFun_eq_coe is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂), Eq.{max (succ u3) (succ u4)} (M -> M₂) (LinearEquiv.toFun.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ e) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u4}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_6 : AddCommMonoid.{u4} M] [_inst_8 : AddCommMonoid.{u3} M₂] {module_M : Module.{u2, u4} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u1, u3} S M₂ _inst_2 _inst_8} {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} {σ' : RingHom.{u1, u2} S R (Semiring.toNonAssocSemiring.{u1} S _inst_2) (Semiring.toNonAssocSemiring.{u2} R _inst_1)} {re₁ : RingHomInvPair.{u2, u1} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u1, u2} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂), Eq.{max (succ u4) (succ u3)} (M -> M₂) (AddHom.toFun.{u4, u3} M M₂ (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (LinearMap.toAddHom.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.toLinearMap.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ e))) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u4 u3, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u4 u3, u2, u1, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e)
Case conversion may be inaccurate. Consider using '#align linear_equiv.to_fun_eq_coe LinearEquiv.toFun_eq_coeₓ'. -/
@[simp]
theorem toFun_eq_coe : e.toFun = e :=
  rfl
#align linear_equiv.to_fun_eq_coe LinearEquiv.toFun_eq_coe

section

variable {e e'}

/- warning: linear_equiv.ext -> LinearEquiv.ext is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} {e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂} {e' : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂}, (forall (x : M), Eq.{succ u4} M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e x) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e' x)) -> (Eq.{max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) e e')
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u2, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u1, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} {σ' : RingHom.{u1, u2} S R (Semiring.toNonAssocSemiring.{u1} S _inst_2) (Semiring.toNonAssocSemiring.{u2} R _inst_1)} {re₁ : RingHomInvPair.{u2, u1} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u1, u2} S R _inst_2 _inst_1 σ' σ} {e : LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂} {e' : LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂}, (forall (x : M), Eq.{succ u4} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u3 u4, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u3 u4, u2, u1, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e x) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u3 u4, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u3 u4, u2, u1, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e' x)) -> (Eq.{max (succ u3) (succ u4)} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) e e')
Case conversion may be inaccurate. Consider using '#align linear_equiv.ext LinearEquiv.extₓ'. -/
@[ext]
theorem ext (h : ∀ x, e x = e' x) : e = e' :=
  FunLike.ext _ _ h
#align linear_equiv.ext LinearEquiv.ext

/- warning: linear_equiv.ext_iff -> LinearEquiv.ext_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} {e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂} {e' : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂}, Iff (Eq.{max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) e e') (forall (x : M), Eq.{succ u4} M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e x) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e' x))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u4}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_6 : AddCommMonoid.{u4} M] [_inst_8 : AddCommMonoid.{u3} M₂] {module_M : Module.{u2, u4} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u1, u3} S M₂ _inst_2 _inst_8} {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} {σ' : RingHom.{u1, u2} S R (Semiring.toNonAssocSemiring.{u1} S _inst_2) (Semiring.toNonAssocSemiring.{u2} R _inst_1)} {re₁ : RingHomInvPair.{u2, u1} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u1, u2} S R _inst_2 _inst_1 σ' σ} {e : LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂} {e' : LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂}, Iff (Eq.{max (succ u4) (succ u3)} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) e e') (forall (x : M), Eq.{succ u3} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u4 u3, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u4 u3, u2, u1, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e x) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u4 u3, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u4 u3, u2, u1, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e' x))
Case conversion may be inaccurate. Consider using '#align linear_equiv.ext_iff LinearEquiv.ext_iffₓ'. -/
theorem ext_iff : e = e' ↔ ∀ x, e x = e' x :=
  FunLike.ext_iff
#align linear_equiv.ext_iff LinearEquiv.ext_iff

/- warning: linear_equiv.congr_arg -> LinearEquiv.congr_arg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} {e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂} {x : M} {x' : M}, (Eq.{succ u3} M x x') -> (Eq.{succ u4} M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e x) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e x'))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u4}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_6 : AddCommMonoid.{u4} M] [_inst_8 : AddCommMonoid.{u3} M₂] {module_M : Module.{u2, u4} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u1, u3} S M₂ _inst_2 _inst_8} {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} {σ' : RingHom.{u1, u2} S R (Semiring.toNonAssocSemiring.{u1} S _inst_2) (Semiring.toNonAssocSemiring.{u2} R _inst_1)} {re₁ : RingHomInvPair.{u2, u1} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u1, u2} S R _inst_2 _inst_1 σ' σ} {e : LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂} {x : M} {x' : M}, (Eq.{succ u4} M x x') -> (Eq.{succ u3} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u4 u3, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u4 u3, u2, u1, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e x) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u4 u3, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u4 u3, u2, u1, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e x'))
Case conversion may be inaccurate. Consider using '#align linear_equiv.congr_arg LinearEquiv.congr_argₓ'. -/
protected theorem congr_arg {x x'} : x = x' → e x = e x' :=
  FunLike.congr_arg e
#align linear_equiv.congr_arg LinearEquiv.congr_arg

/- warning: linear_equiv.congr_fun -> LinearEquiv.congr_fun is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} {e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂} {e' : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂}, (Eq.{max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) e e') -> (forall (x : M), Eq.{succ u4} M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e x) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e' x))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u4}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_6 : AddCommMonoid.{u4} M] [_inst_8 : AddCommMonoid.{u3} M₂] {module_M : Module.{u2, u4} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u1, u3} S M₂ _inst_2 _inst_8} {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} {σ' : RingHom.{u1, u2} S R (Semiring.toNonAssocSemiring.{u1} S _inst_2) (Semiring.toNonAssocSemiring.{u2} R _inst_1)} {re₁ : RingHomInvPair.{u2, u1} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u1, u2} S R _inst_2 _inst_1 σ' σ} {e : LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂} {e' : LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂}, (Eq.{max (succ u4) (succ u3)} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) e e') -> (forall (x : M), Eq.{succ u3} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u4 u3, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u4 u3, u2, u1, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e x) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u4 u3, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u4 u3, u2, u1, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e' x))
Case conversion may be inaccurate. Consider using '#align linear_equiv.congr_fun LinearEquiv.congr_funₓ'. -/
protected theorem congr_fun (h : e = e') (x : M) : e x = e' x :=
  FunLike.congr_fun h x
#align linear_equiv.congr_fun LinearEquiv.congr_fun

end

section

variable (M R)

#print LinearEquiv.refl /-
/-- The identity map is a linear equivalence. -/
@[refl]
def refl [Module R M] : M ≃ₗ[R] M :=
  { LinearMap.id, Equiv.refl M with }
#align linear_equiv.refl LinearEquiv.refl
-/

end

/- warning: linear_equiv.refl_apply -> LinearEquiv.refl_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_6 : AddCommMonoid.{u2} M] [_inst_13 : Module.{u1, u2} R M _inst_1 _inst_6] (x : M), Eq.{succ u2} M (coeFn.{succ u2, succ u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_13 _inst_13) (fun (_x : LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_13 _inst_13) => M -> M) (LinearEquiv.hasCoeToFun.{u1, u1, u2, u2} R R M M _inst_1 _inst_1 _inst_6 _inst_6 _inst_13 _inst_13 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)) (LinearEquiv.refl.{u1, u2} R M _inst_1 _inst_6 _inst_13) x) x
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_6 : AddCommMonoid.{u1} M] [_inst_13 : Module.{u2, u1} R M _inst_1 _inst_6] (x : M), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M) => M) x) (FunLike.coe.{succ u1, succ u1, succ u1} (LinearEquiv.{u2, u2, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) M M _inst_6 _inst_6 _inst_13 _inst_13) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M) => M) _x) (SMulHomClass.toFunLike.{u1, u2, u1, u1} (LinearEquiv.{u2, u2, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) M M _inst_6 _inst_6 _inst_13 _inst_13) R M M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_6)) (DistribSMul.toSMulZeroClass.{u2, u1} R M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_6)) (DistribMulAction.toDistribSMul.{u2, u1} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M _inst_6) (Module.toDistribMulAction.{u2, u1} R M _inst_1 _inst_6 _inst_13)))) (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_6)) (DistribSMul.toSMulZeroClass.{u2, u1} R M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_6)) (DistribMulAction.toDistribSMul.{u2, u1} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M _inst_6) (Module.toDistribMulAction.{u2, u1} R M _inst_1 _inst_6 _inst_13)))) (DistribMulActionHomClass.toSMulHomClass.{u1, u2, u1, u1} (LinearEquiv.{u2, u2, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) M M _inst_6 _inst_6 _inst_13 _inst_13) R M M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M _inst_6) (AddCommMonoid.toAddMonoid.{u1} M _inst_6) (Module.toDistribMulAction.{u2, u1} R M _inst_1 _inst_6 _inst_13) (Module.toDistribMulAction.{u2, u1} R M _inst_1 _inst_6 _inst_13) (SemilinearMapClass.distribMulActionHomClass.{u2, u1, u1, u1} R M M (LinearEquiv.{u2, u2, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) M M _inst_6 _inst_6 _inst_13 _inst_13) _inst_1 _inst_6 _inst_6 _inst_13 _inst_13 (SemilinearEquivClass.instSemilinearMapClass.{u2, u2, u1, u1, u1} R R M M (LinearEquiv.{u2, u2, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) M M _inst_6 _inst_6 _inst_13 _inst_13) _inst_1 _inst_1 _inst_6 _inst_6 _inst_13 _inst_13 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u2, u1, u1} R R M M _inst_1 _inst_1 _inst_6 _inst_6 _inst_13 _inst_13 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1)))))) (LinearEquiv.refl.{u2, u1} R M _inst_1 _inst_6 _inst_13) x) x
Case conversion may be inaccurate. Consider using '#align linear_equiv.refl_apply LinearEquiv.refl_applyₓ'. -/
@[simp]
theorem refl_apply [Module R M] (x : M) : refl R M x = x :=
  rfl
#align linear_equiv.refl_apply LinearEquiv.refl_apply

include module_M module_S_M₂ re₁ re₂

#print LinearEquiv.symm /-
/-- Linear equivalences are symmetric. -/
@[symm]
def symm (e : M ≃ₛₗ[σ] M₂) : M₂ ≃ₛₗ[σ'] M :=
  { e.toLinearMap.inverse e.invFun e.left_inv e.right_inv,
    e.toEquiv.symm with
    toFun := e.toLinearMap.inverse e.invFun e.left_inv e.right_inv
    invFun := e.toEquiv.symm.invFun
    map_smul' := fun r x => by rw [map_smulₛₗ] }
#align linear_equiv.symm LinearEquiv.symm
-/

omit module_M module_S_M₂ re₁ re₂

#print LinearEquiv.Simps.symmApply /-
/-- See Note [custom simps projection] -/
def Simps.symmApply {R : Type _} {S : Type _} [Semiring R] [Semiring S] {σ : R →+* S} {σ' : S →+* R}
    [RingHomInvPair σ σ'] [RingHomInvPair σ' σ] {M : Type _} {M₂ : Type _} [AddCommMonoid M]
    [AddCommMonoid M₂] [Module R M] [Module S M₂] (e : M ≃ₛₗ[σ] M₂) : M₂ → M :=
  e.symm
#align linear_equiv.simps.symm_apply LinearEquiv.Simps.symmApply
-/

initialize_simps_projections LinearEquiv (toFun → apply, invFun → symm_apply)

include σ'

/- warning: linear_equiv.inv_fun_eq_symm -> LinearEquiv.invFun_eq_symm is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂), Eq.{max (succ u4) (succ u3)} (M₂ -> M) (LinearEquiv.invFun.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ e) (coeFn.{max (succ u4) (succ u3), max (succ u4) (succ u3)} (LinearEquiv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) (fun (_x : LinearEquiv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) => M₂ -> M) (LinearEquiv.hasCoeToFun.{u2, u1, u4, u3} S R M₂ M _inst_2 _inst_1 _inst_8 _inst_6 module_S_M₂ module_M σ' σ re₂ re₁) (LinearEquiv.symm.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂ e))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u4}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_6 : AddCommMonoid.{u4} M] [_inst_8 : AddCommMonoid.{u3} M₂] {module_M : Module.{u2, u4} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u1, u3} S M₂ _inst_2 _inst_8} {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} {σ' : RingHom.{u1, u2} S R (Semiring.toNonAssocSemiring.{u1} S _inst_2) (Semiring.toNonAssocSemiring.{u2} R _inst_1)} {re₁ : RingHomInvPair.{u2, u1} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u1, u2} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂), Eq.{max (succ u4) (succ u3)} (M₂ -> M) (LinearEquiv.invFun.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ e) (FunLike.coe.{max (succ u4) (succ u3), succ u3, succ u4} (LinearEquiv.{u1, u2, u3, u4} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) M₂ (fun (_x : M₂) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M₂) => M) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u3), succ u3, succ u4} (LinearEquiv.{u1, u2, u3, u4} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) M₂ M (EquivLike.toEmbeddingLike.{max (succ u4) (succ u3), succ u3, succ u4} (LinearEquiv.{u1, u2, u3, u4} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) M₂ M (AddEquivClass.toEquivLike.{max u4 u3, u3, u4} (LinearEquiv.{u1, u2, u3, u4} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) M₂ M (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (SemilinearEquivClass.toAddEquivClass.{max u4 u3, u1, u2, u3, u4} (LinearEquiv.{u1, u2, u3, u4} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u2, u3, u4} S R M₂ M _inst_2 _inst_1 _inst_8 _inst_6 module_S_M₂ module_M σ' σ re₂ re₁))))) (LinearEquiv.symm.{u2, u1, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂ e))
Case conversion may be inaccurate. Consider using '#align linear_equiv.inv_fun_eq_symm LinearEquiv.invFun_eq_symmₓ'. -/
@[simp]
theorem invFun_eq_symm : e.invFun = e.symm :=
  rfl
#align linear_equiv.inv_fun_eq_symm LinearEquiv.invFun_eq_symm

omit σ'

/- warning: linear_equiv.coe_to_equiv_symm -> LinearEquiv.coe_toEquiv_symm is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂), Eq.{max (succ u4) (succ u3)} (M₂ -> M) (coeFn.{max 1 (max (succ u4) (succ u3)) (succ u3) (succ u4), max (succ u4) (succ u3)} (Equiv.{succ u4, succ u3} M₂ M) (fun (_x : Equiv.{succ u4, succ u3} M₂ M) => M₂ -> M) (Equiv.hasCoeToFun.{succ u4, succ u3} M₂ M) (Equiv.symm.{succ u3, succ u4} M M₂ (LinearEquiv.toEquiv.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂ e))) (coeFn.{max (succ u4) (succ u3), max (succ u4) (succ u3)} (LinearEquiv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) (fun (_x : LinearEquiv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) => M₂ -> M) (LinearEquiv.hasCoeToFun.{u2, u1, u4, u3} S R M₂ M _inst_2 _inst_1 _inst_8 _inst_6 module_S_M₂ module_M σ' σ re₂ re₁) (LinearEquiv.symm.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂ e))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u4}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_6 : AddCommMonoid.{u4} M] [_inst_8 : AddCommMonoid.{u3} M₂] {module_M : Module.{u2, u4} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u1, u3} S M₂ _inst_2 _inst_8} {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} {σ' : RingHom.{u1, u2} S R (Semiring.toNonAssocSemiring.{u1} S _inst_2) (Semiring.toNonAssocSemiring.{u2} R _inst_1)} {re₁ : RingHomInvPair.{u2, u1} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u1, u2} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂), Eq.{max (succ u4) (succ u3)} (Equiv.{succ u3, succ u4} M₂ M) (Equiv.symm.{succ u4, succ u3} M M₂ (LinearEquiv.toEquiv.{u2, u1, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂ e)) (EquivLike.toEquiv.{succ u3, succ u4, max (succ u4) (succ u3)} M₂ M (LinearEquiv.{u1, u2, u3, u4} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) (AddEquivClass.toEquivLike.{max u4 u3, u3, u4} (LinearEquiv.{u1, u2, u3, u4} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) M₂ M (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (SemilinearEquivClass.toAddEquivClass.{max u4 u3, u1, u2, u3, u4} (LinearEquiv.{u1, u2, u3, u4} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u2, u3, u4} S R M₂ M _inst_2 _inst_1 _inst_8 _inst_6 module_S_M₂ module_M σ' σ re₂ re₁))) (LinearEquiv.symm.{u2, u1, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂ e))
Case conversion may be inaccurate. Consider using '#align linear_equiv.coe_to_equiv_symm LinearEquiv.coe_toEquiv_symmₓ'. -/
@[simp]
theorem coe_toEquiv_symm : ⇑e.toEquiv.symm = e.symm :=
  rfl
#align linear_equiv.coe_to_equiv_symm LinearEquiv.coe_toEquiv_symm

variable {module_M₁ : Module R₁ M₁} {module_M₂ : Module R₂ M₂} {module_M₃ : Module R₃ M₃}

variable {module_N₁ : Module R₁ N₁} {module_N₂ : Module R₁ N₂}

variable {σ₁₂ : R₁ →+* R₂} {σ₂₃ : R₂ →+* R₃} {σ₁₃ : R₁ →+* R₃}

variable {σ₂₁ : R₂ →+* R₁} {σ₃₂ : R₃ →+* R₂} {σ₃₁ : R₃ →+* R₁}

variable [RingHomCompTriple σ₁₂ σ₂₃ σ₁₃]

variable [RingHomCompTriple σ₃₂ σ₂₁ σ₃₁]

variable {re₁₂ : RingHomInvPair σ₁₂ σ₂₁} {re₂₃ : RingHomInvPair σ₂₃ σ₃₂}

variable [RingHomInvPair σ₁₃ σ₃₁] {re₂₁ : RingHomInvPair σ₂₁ σ₁₂}

variable {re₃₂ : RingHomInvPair σ₃₂ σ₂₃} [RingHomInvPair σ₃₁ σ₁₃]

variable (e₁₂ : M₁ ≃ₛₗ[σ₁₂] M₂) (e₂₃ : M₂ ≃ₛₗ[σ₂₃] M₃)

include σ₃₁

#print LinearEquiv.trans /-
-- Note: The linter thinks the `ring_hom_comp_triple` argument is doubled -- it is not.
/-- Linear equivalences are transitive. -/
@[trans, nolint unused_arguments]
def trans : M₁ ≃ₛₗ[σ₁₃] M₃ :=
  { e₂₃.toLinearMap.comp e₁₂.toLinearMap, e₁₂.toEquiv.trans e₂₃.toEquiv with }
#align linear_equiv.trans LinearEquiv.trans
-/

omit σ₃₁

-- mathport name: «expr ≪≫ₗ »
infixl:80 " ≪≫ₗ " =>
  @LinearEquiv.trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ (RingHom.id _) (RingHom.id _) (RingHom.id _)
    (RingHom.id _) (RingHom.id _) (RingHom.id _) RingHomCompTriple.ids RingHomCompTriple.ids
    RingHomInvPair.ids RingHomInvPair.ids RingHomInvPair.ids RingHomInvPair.ids RingHomInvPair.ids
    RingHomInvPair.ids

variable {e₁₂} {e₂₃}

/- warning: linear_equiv.coe_to_add_equiv -> LinearEquiv.coe_toAddEquiv is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂), Eq.{max (succ u3) (succ u4)} (M -> M₂) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (AddEquiv.{u3, u4} M M₂ (AddZeroClass.toHasAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (AddZeroClass.toHasAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8)))) (fun (_x : AddEquiv.{u3, u4} M M₂ (AddZeroClass.toHasAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (AddZeroClass.toHasAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8)))) => M -> M₂) (AddEquiv.hasCoeToFun.{u3, u4} M M₂ (AddZeroClass.toHasAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (AddZeroClass.toHasAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8)))) (LinearEquiv.toAddEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ e)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u4}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_6 : AddCommMonoid.{u4} M] [_inst_8 : AddCommMonoid.{u3} M₂] {module_M : Module.{u2, u4} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u1, u3} S M₂ _inst_2 _inst_8} {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} {σ' : RingHom.{u1, u2} S R (Semiring.toNonAssocSemiring.{u1} S _inst_2) (Semiring.toNonAssocSemiring.{u2} R _inst_1)} {re₁ : RingHomInvPair.{u2, u1} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u1, u2} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂), Eq.{max (succ u4) (succ u3)} (AddEquiv.{u4, u3} M M₂ (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8)))) (LinearEquiv.toAddEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ e) (AddEquivClass.toAddEquiv.{max u4 u3, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u4 u3, u2, u1, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂)) e)
Case conversion may be inaccurate. Consider using '#align linear_equiv.coe_to_add_equiv LinearEquiv.coe_toAddEquivₓ'. -/
@[simp]
theorem coe_toAddEquiv : ⇑e.toAddEquiv = e :=
  rfl
#align linear_equiv.coe_to_add_equiv LinearEquiv.coe_toAddEquiv

/- warning: linear_equiv.to_add_monoid_hom_commutes -> LinearEquiv.toAddMonoidHom_commutes is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂), Eq.{max (succ u4) (succ u3)} (AddMonoidHom.{u3, u4} M M₂ (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6)) (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (LinearMap.toAddMonoidHom.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ (LinearEquiv.toLinearMap.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ e)) (AddEquiv.toAddMonoidHom.{u3, u4} M M₂ (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6)) (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8)) (LinearEquiv.toAddEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ e))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u4}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_6 : AddCommMonoid.{u4} M] [_inst_8 : AddCommMonoid.{u3} M₂] {module_M : Module.{u2, u4} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u1, u3} S M₂ _inst_2 _inst_8} {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} {σ' : RingHom.{u1, u2} S R (Semiring.toNonAssocSemiring.{u1} S _inst_2) (Semiring.toNonAssocSemiring.{u2} R _inst_1)} {re₁ : RingHomInvPair.{u2, u1} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u1, u2} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂), Eq.{max (succ u4) (succ u3)} (AddMonoidHom.{u4, u3} M M₂ (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6)) (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (LinearMap.toAddMonoidHom.{u2, u1, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ (LinearEquiv.toLinearMap.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ e)) (AddEquiv.toAddMonoidHom.{u4, u3} M M₂ (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6)) (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8)) (LinearEquiv.toAddEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ e))
Case conversion may be inaccurate. Consider using '#align linear_equiv.to_add_monoid_hom_commutes LinearEquiv.toAddMonoidHom_commutesₓ'. -/
/-- The two paths coercion can take to an `add_monoid_hom` are equivalent -/
theorem toAddMonoidHom_commutes : e.toLinearMap.toAddMonoidHom = e.toAddEquiv.toAddMonoidHom :=
  rfl
#align linear_equiv.to_add_monoid_hom_commutes LinearEquiv.toAddMonoidHom_commutes

include σ₃₁

/- warning: linear_equiv.trans_apply -> LinearEquiv.trans_apply is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {R₃ : Type.{u3}} {M₁ : Type.{u4}} {M₂ : Type.{u5}} {M₃ : Type.{u6}} [_inst_3 : Semiring.{u1} R₁] [_inst_4 : Semiring.{u2} R₂] [_inst_5 : Semiring.{u3} R₃] [_inst_7 : AddCommMonoid.{u4} M₁] [_inst_8 : AddCommMonoid.{u5} M₂] [_inst_9 : AddCommMonoid.{u6} M₃] {module_M₁ : Module.{u1, u4} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u2, u5} R₂ M₂ _inst_4 _inst_8} {module_M₃ : Module.{u3, u6} R₃ M₃ _inst_5 _inst_9} {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₂₃ : RingHom.{u2, u3} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5)} {σ₁₃ : RingHom.{u1, u3} R₁ R₃ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5)} {σ₂₁ : RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)} {σ₃₂ : RingHom.{u3, u2} R₃ R₂ (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₃₁ : RingHom.{u3, u1} R₃ R₁ (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)} [_inst_13 : RingHomCompTriple.{u1, u2, u3} R₁ R₂ R₃ _inst_3 _inst_4 _inst_5 σ₁₂ σ₂₃ σ₁₃] [_inst_14 : RingHomCompTriple.{u3, u2, u1} R₃ R₂ R₁ _inst_5 _inst_4 _inst_3 σ₃₂ σ₂₁ σ₃₁] {re₁₂ : RingHomInvPair.{u1, u2} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁} {re₂₃ : RingHomInvPair.{u2, u3} R₂ R₃ _inst_4 _inst_5 σ₂₃ σ₃₂} [_inst_15 : RingHomInvPair.{u1, u3} R₁ R₃ _inst_3 _inst_5 σ₁₃ σ₃₁] {re₂₁ : RingHomInvPair.{u2, u1} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂} {re₃₂ : RingHomInvPair.{u3, u2} R₃ R₂ _inst_5 _inst_4 σ₃₂ σ₂₃} [_inst_16 : RingHomInvPair.{u3, u1} R₃ R₁ _inst_5 _inst_3 σ₃₁ σ₁₃] {e₁₂ : LinearEquiv.{u1, u2, u4, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂} {e₂₃ : LinearEquiv.{u2, u3, u5, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ σ₃₂ re₂₃ re₃₂ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃} (c : M₁), Eq.{succ u6} M₃ (coeFn.{max (succ u4) (succ u6), max (succ u4) (succ u6)} (LinearEquiv.{u1, u3, u4, u6} R₁ R₃ _inst_3 _inst_5 σ₁₃ σ₃₁ _inst_15 _inst_16 M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃) (fun (_x : LinearEquiv.{u1, u3, u4, u6} R₁ R₃ _inst_3 _inst_5 σ₁₃ σ₃₁ _inst_15 _inst_16 M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃) => M₁ -> M₃) (LinearEquiv.hasCoeToFun.{u1, u3, u4, u6} R₁ R₃ M₁ M₃ _inst_3 _inst_5 _inst_7 _inst_9 module_M₁ module_M₃ σ₁₃ σ₃₁ _inst_15 _inst_16) (LinearEquiv.trans.{u1, u2, u3, u4, u5, u6} R₁ R₂ R₃ M₁ M₂ M₃ _inst_3 _inst_4 _inst_5 _inst_7 _inst_8 _inst_9 module_M₁ module_M₂ module_M₃ σ₁₂ σ₂₃ σ₁₃ σ₂₁ σ₃₂ σ₃₁ _inst_13 _inst_14 re₁₂ re₂₃ _inst_15 re₂₁ re₃₂ _inst_16 e₁₂ e₂₃) c) (coeFn.{max (succ u5) (succ u6), max (succ u5) (succ u6)} (LinearEquiv.{u2, u3, u5, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ σ₃₂ re₂₃ re₃₂ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) (fun (_x : LinearEquiv.{u2, u3, u5, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ σ₃₂ re₂₃ re₃₂ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) => M₂ -> M₃) (LinearEquiv.hasCoeToFun.{u2, u3, u5, u6} R₂ R₃ M₂ M₃ _inst_4 _inst_5 _inst_8 _inst_9 module_M₂ module_M₃ σ₂₃ σ₃₂ re₂₃ re₃₂) e₂₃ (coeFn.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (LinearEquiv.{u1, u2, u4, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) (fun (_x : LinearEquiv.{u1, u2, u4, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) => M₁ -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u4, u5} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁) e₁₂ c))
but is expected to have type
  forall {R₁ : Type.{u4}} {R₂ : Type.{u2}} {R₃ : Type.{u3}} {M₁ : Type.{u5}} {M₂ : Type.{u1}} {M₃ : Type.{u6}} [_inst_3 : Semiring.{u4} R₁] [_inst_4 : Semiring.{u2} R₂] [_inst_5 : Semiring.{u3} R₃] [_inst_7 : AddCommMonoid.{u5} M₁] [_inst_8 : AddCommMonoid.{u1} M₂] [_inst_9 : AddCommMonoid.{u6} M₃] {module_M₁ : Module.{u4, u5} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u2, u1} R₂ M₂ _inst_4 _inst_8} {module_M₃ : Module.{u3, u6} R₃ M₃ _inst_5 _inst_9} {σ₁₂ : RingHom.{u4, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u4} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₂₃ : RingHom.{u2, u3} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5)} {σ₁₃ : RingHom.{u4, u3} R₁ R₃ (Semiring.toNonAssocSemiring.{u4} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5)} {σ₂₁ : RingHom.{u2, u4} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u4} R₁ _inst_3)} {σ₃₂ : RingHom.{u3, u2} R₃ R₂ (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₃₁ : RingHom.{u3, u4} R₃ R₁ (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5) (Semiring.toNonAssocSemiring.{u4} R₁ _inst_3)} [_inst_13 : RingHomCompTriple.{u4, u2, u3} R₁ R₂ R₃ _inst_3 _inst_4 _inst_5 σ₁₂ σ₂₃ σ₁₃] [_inst_14 : RingHomCompTriple.{u3, u2, u4} R₃ R₂ R₁ _inst_5 _inst_4 _inst_3 σ₃₂ σ₂₁ σ₃₁] {re₁₂ : RingHomInvPair.{u4, u2} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁} {re₂₃ : RingHomInvPair.{u2, u3} R₂ R₃ _inst_4 _inst_5 σ₂₃ σ₃₂} [_inst_15 : RingHomInvPair.{u4, u3} R₁ R₃ _inst_3 _inst_5 σ₁₃ σ₃₁] {re₂₁ : RingHomInvPair.{u2, u4} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂} {re₃₂ : RingHomInvPair.{u3, u2} R₃ R₂ _inst_5 _inst_4 σ₃₂ σ₂₃} [_inst_16 : RingHomInvPair.{u3, u4} R₃ R₁ _inst_5 _inst_3 σ₃₁ σ₁₃] {e₁₂ : LinearEquiv.{u4, u2, u5, u1} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂} {e₂₃ : LinearEquiv.{u2, u3, u1, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ σ₃₂ re₂₃ re₃₂ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃} (c : M₁), Eq.{succ u6} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M₁) => M₃) c) (FunLike.coe.{max (succ u5) (succ u6), succ u5, succ u6} (LinearEquiv.{u4, u3, u5, u6} R₁ R₃ _inst_3 _inst_5 σ₁₃ σ₃₁ _inst_15 _inst_16 M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃) M₁ (fun (_x : M₁) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M₁) => M₃) _x) (EmbeddingLike.toFunLike.{max (succ u5) (succ u6), succ u5, succ u6} (LinearEquiv.{u4, u3, u5, u6} R₁ R₃ _inst_3 _inst_5 σ₁₃ σ₃₁ _inst_15 _inst_16 M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃) M₁ M₃ (EquivLike.toEmbeddingLike.{max (succ u5) (succ u6), succ u5, succ u6} (LinearEquiv.{u4, u3, u5, u6} R₁ R₃ _inst_3 _inst_5 σ₁₃ σ₃₁ _inst_15 _inst_16 M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃) M₁ M₃ (AddEquivClass.toEquivLike.{max u5 u6, u5, u6} (LinearEquiv.{u4, u3, u5, u6} R₁ R₃ _inst_3 _inst_5 σ₁₃ σ₃₁ _inst_15 _inst_16 M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃) M₁ M₃ (AddZeroClass.toAdd.{u5} M₁ (AddMonoid.toAddZeroClass.{u5} M₁ (AddCommMonoid.toAddMonoid.{u5} M₁ _inst_7))) (AddZeroClass.toAdd.{u6} M₃ (AddMonoid.toAddZeroClass.{u6} M₃ (AddCommMonoid.toAddMonoid.{u6} M₃ _inst_9))) (SemilinearEquivClass.toAddEquivClass.{max u5 u6, u4, u3, u5, u6} (LinearEquiv.{u4, u3, u5, u6} R₁ R₃ _inst_3 _inst_5 σ₁₃ σ₃₁ _inst_15 _inst_16 M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃) R₁ R₃ _inst_3 _inst_5 σ₁₃ σ₃₁ _inst_15 _inst_16 M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u4, u3, u5, u6} R₁ R₃ M₁ M₃ _inst_3 _inst_5 _inst_7 _inst_9 module_M₁ module_M₃ σ₁₃ σ₃₁ _inst_15 _inst_16))))) (LinearEquiv.trans.{u4, u2, u3, u5, u1, u6} R₁ R₂ R₃ M₁ M₂ M₃ _inst_3 _inst_4 _inst_5 _inst_7 _inst_8 _inst_9 module_M₁ module_M₂ module_M₃ σ₁₂ σ₂₃ σ₁₃ σ₂₁ σ₃₂ σ₃₁ _inst_13 _inst_14 re₁₂ re₂₃ _inst_15 re₂₁ re₃₂ _inst_16 e₁₂ e₂₃) c) (FunLike.coe.{max (succ u1) (succ u6), succ u1, succ u6} (LinearEquiv.{u2, u3, u1, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ σ₃₂ re₂₃ re₃₂ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) M₂ (fun (_x : M₂) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M₂) => M₃) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u6), succ u1, succ u6} (LinearEquiv.{u2, u3, u1, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ σ₃₂ re₂₃ re₃₂ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) M₂ M₃ (EquivLike.toEmbeddingLike.{max (succ u1) (succ u6), succ u1, succ u6} (LinearEquiv.{u2, u3, u1, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ σ₃₂ re₂₃ re₃₂ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) M₂ M₃ (AddEquivClass.toEquivLike.{max u1 u6, u1, u6} (LinearEquiv.{u2, u3, u1, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ σ₃₂ re₂₃ re₃₂ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) M₂ M₃ (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_8))) (AddZeroClass.toAdd.{u6} M₃ (AddMonoid.toAddZeroClass.{u6} M₃ (AddCommMonoid.toAddMonoid.{u6} M₃ _inst_9))) (SemilinearEquivClass.toAddEquivClass.{max u1 u6, u2, u3, u1, u6} (LinearEquiv.{u2, u3, u1, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ σ₃₂ re₂₃ re₃₂ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) R₂ R₃ _inst_4 _inst_5 σ₂₃ σ₃₂ re₂₃ re₃₂ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u3, u1, u6} R₂ R₃ M₂ M₃ _inst_4 _inst_5 _inst_8 _inst_9 module_M₂ module_M₃ σ₂₃ σ₃₂ re₂₃ re₃₂))))) e₂₃ (FunLike.coe.{max (succ u5) (succ u1), succ u5, succ u1} (LinearEquiv.{u4, u2, u5, u1} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) M₁ (fun (_x : M₁) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M₁) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u5) (succ u1), succ u5, succ u1} (LinearEquiv.{u4, u2, u5, u1} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) M₁ M₂ (EquivLike.toEmbeddingLike.{max (succ u5) (succ u1), succ u5, succ u1} (LinearEquiv.{u4, u2, u5, u1} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) M₁ M₂ (AddEquivClass.toEquivLike.{max u5 u1, u5, u1} (LinearEquiv.{u4, u2, u5, u1} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) M₁ M₂ (AddZeroClass.toAdd.{u5} M₁ (AddMonoid.toAddZeroClass.{u5} M₁ (AddCommMonoid.toAddMonoid.{u5} M₁ _inst_7))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u5 u1, u4, u2, u5, u1} (LinearEquiv.{u4, u2, u5, u1} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u4, u2, u5, u1} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁))))) e₁₂ c))
Case conversion may be inaccurate. Consider using '#align linear_equiv.trans_apply LinearEquiv.trans_applyₓ'. -/
@[simp]
theorem trans_apply (c : M₁) : (e₁₂.trans e₂₃ : M₁ ≃ₛₗ[σ₁₃] M₃) c = e₂₃ (e₁₂ c) :=
  rfl
#align linear_equiv.trans_apply LinearEquiv.trans_apply

/- warning: linear_equiv.coe_trans -> LinearEquiv.coe_trans is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {R₃ : Type.{u3}} {M₁ : Type.{u4}} {M₂ : Type.{u5}} {M₃ : Type.{u6}} [_inst_3 : Semiring.{u1} R₁] [_inst_4 : Semiring.{u2} R₂] [_inst_5 : Semiring.{u3} R₃] [_inst_7 : AddCommMonoid.{u4} M₁] [_inst_8 : AddCommMonoid.{u5} M₂] [_inst_9 : AddCommMonoid.{u6} M₃] {module_M₁ : Module.{u1, u4} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u2, u5} R₂ M₂ _inst_4 _inst_8} {module_M₃ : Module.{u3, u6} R₃ M₃ _inst_5 _inst_9} {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₂₃ : RingHom.{u2, u3} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5)} {σ₁₃ : RingHom.{u1, u3} R₁ R₃ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5)} {σ₂₁ : RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)} {σ₃₂ : RingHom.{u3, u2} R₃ R₂ (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₃₁ : RingHom.{u3, u1} R₃ R₁ (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)} [_inst_13 : RingHomCompTriple.{u1, u2, u3} R₁ R₂ R₃ _inst_3 _inst_4 _inst_5 σ₁₂ σ₂₃ σ₁₃] [_inst_14 : RingHomCompTriple.{u3, u2, u1} R₃ R₂ R₁ _inst_5 _inst_4 _inst_3 σ₃₂ σ₂₁ σ₃₁] {re₁₂ : RingHomInvPair.{u1, u2} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁} {re₂₃ : RingHomInvPair.{u2, u3} R₂ R₃ _inst_4 _inst_5 σ₂₃ σ₃₂} [_inst_15 : RingHomInvPair.{u1, u3} R₁ R₃ _inst_3 _inst_5 σ₁₃ σ₃₁] {re₂₁ : RingHomInvPair.{u2, u1} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂} {re₃₂ : RingHomInvPair.{u3, u2} R₃ R₂ _inst_5 _inst_4 σ₃₂ σ₂₃} [_inst_16 : RingHomInvPair.{u3, u1} R₃ R₁ _inst_5 _inst_3 σ₃₁ σ₁₃] {e₁₂ : LinearEquiv.{u1, u2, u4, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂} {e₂₃ : LinearEquiv.{u2, u3, u5, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ σ₃₂ re₂₃ re₃₂ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃}, Eq.{max (succ u4) (succ u6)} (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_3 _inst_5 σ₁₃ M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃) ((fun (a : Sort.{max (succ u4) (succ u6)}) (b : Sort.{max (succ u4) (succ u6)}) [self : HasLiftT.{max (succ u4) (succ u6), max (succ u4) (succ u6)} a b] => self.0) (LinearEquiv.{u1, u3, u4, u6} R₁ R₃ _inst_3 _inst_5 σ₁₃ σ₃₁ _inst_15 _inst_16 M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃) (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_3 _inst_5 σ₁₃ M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃) (HasLiftT.mk.{max (succ u4) (succ u6), max (succ u4) (succ u6)} (LinearEquiv.{u1, u3, u4, u6} R₁ R₃ _inst_3 _inst_5 σ₁₃ σ₃₁ _inst_15 _inst_16 M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃) (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_3 _inst_5 σ₁₃ M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃) (CoeTCₓ.coe.{max (succ u4) (succ u6), max (succ u4) (succ u6)} (LinearEquiv.{u1, u3, u4, u6} R₁ R₃ _inst_3 _inst_5 σ₁₃ σ₃₁ _inst_15 _inst_16 M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃) (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_3 _inst_5 σ₁₃ M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃) (coeBase.{max (succ u4) (succ u6), max (succ u4) (succ u6)} (LinearEquiv.{u1, u3, u4, u6} R₁ R₃ _inst_3 _inst_5 σ₁₃ σ₃₁ _inst_15 _inst_16 M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃) (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_3 _inst_5 σ₁₃ M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃) (LinearEquiv.LinearMap.hasCoe.{u1, u3, u4, u6} R₁ R₃ M₁ M₃ _inst_3 _inst_5 _inst_7 _inst_9 module_M₁ module_M₃ σ₁₃ σ₃₁ _inst_15 _inst_16)))) (LinearEquiv.trans.{u1, u2, u3, u4, u5, u6} R₁ R₂ R₃ M₁ M₂ M₃ _inst_3 _inst_4 _inst_5 _inst_7 _inst_8 _inst_9 module_M₁ module_M₂ module_M₃ σ₁₂ σ₂₃ σ₁₃ σ₂₁ σ₃₂ σ₃₁ _inst_13 _inst_14 re₁₂ re₂₃ _inst_15 re₂₁ re₃₂ _inst_16 e₁₂ e₂₃)) (LinearMap.comp.{u1, u2, u3, u4, u5, u6} R₁ R₂ R₃ M₁ M₂ M₃ _inst_3 _inst_4 _inst_5 _inst_7 _inst_8 _inst_9 module_M₁ module_M₂ module_M₃ σ₁₂ σ₂₃ σ₁₃ _inst_13 ((fun (a : Sort.{max (succ u5) (succ u6)}) (b : Sort.{max (succ u5) (succ u6)}) [self : HasLiftT.{max (succ u5) (succ u6), max (succ u5) (succ u6)} a b] => self.0) (LinearEquiv.{u2, u3, u5, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ σ₃₂ re₂₃ re₃₂ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) (LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) (HasLiftT.mk.{max (succ u5) (succ u6), max (succ u5) (succ u6)} (LinearEquiv.{u2, u3, u5, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ σ₃₂ re₂₃ re₃₂ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) (LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) (CoeTCₓ.coe.{max (succ u5) (succ u6), max (succ u5) (succ u6)} (LinearEquiv.{u2, u3, u5, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ σ₃₂ re₂₃ re₃₂ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) (LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) (coeBase.{max (succ u5) (succ u6), max (succ u5) (succ u6)} (LinearEquiv.{u2, u3, u5, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ σ₃₂ re₂₃ re₃₂ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) (LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) (LinearEquiv.LinearMap.hasCoe.{u2, u3, u5, u6} R₂ R₃ M₂ M₃ _inst_4 _inst_5 _inst_8 _inst_9 module_M₂ module_M₃ σ₂₃ σ₃₂ re₂₃ re₃₂)))) e₂₃) ((fun (a : Sort.{max (succ u4) (succ u5)}) (b : Sort.{max (succ u4) (succ u5)}) [self : HasLiftT.{max (succ u4) (succ u5), max (succ u4) (succ u5)} a b] => self.0) (LinearEquiv.{u1, u2, u4, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) (LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) (HasLiftT.mk.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (LinearEquiv.{u1, u2, u4, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) (LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) (CoeTCₓ.coe.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (LinearEquiv.{u1, u2, u4, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) (LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) (coeBase.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (LinearEquiv.{u1, u2, u4, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) (LinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) (LinearEquiv.LinearMap.hasCoe.{u1, u2, u4, u5} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁)))) e₁₂))
but is expected to have type
  forall {R₁ : Type.{u4}} {R₂ : Type.{u2}} {R₃ : Type.{u3}} {M₁ : Type.{u6}} {M₂ : Type.{u1}} {M₃ : Type.{u5}} [_inst_3 : Semiring.{u4} R₁] [_inst_4 : Semiring.{u2} R₂] [_inst_5 : Semiring.{u3} R₃] [_inst_7 : AddCommMonoid.{u6} M₁] [_inst_8 : AddCommMonoid.{u1} M₂] [_inst_9 : AddCommMonoid.{u5} M₃] {module_M₁ : Module.{u4, u6} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u2, u1} R₂ M₂ _inst_4 _inst_8} {module_M₃ : Module.{u3, u5} R₃ M₃ _inst_5 _inst_9} {σ₁₂ : RingHom.{u4, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u4} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₂₃ : RingHom.{u2, u3} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5)} {σ₁₃ : RingHom.{u4, u3} R₁ R₃ (Semiring.toNonAssocSemiring.{u4} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5)} {σ₂₁ : RingHom.{u2, u4} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u4} R₁ _inst_3)} {σ₃₂ : RingHom.{u3, u2} R₃ R₂ (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₃₁ : RingHom.{u3, u4} R₃ R₁ (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5) (Semiring.toNonAssocSemiring.{u4} R₁ _inst_3)} [_inst_13 : RingHomCompTriple.{u4, u2, u3} R₁ R₂ R₃ _inst_3 _inst_4 _inst_5 σ₁₂ σ₂₃ σ₁₃] [_inst_14 : RingHomCompTriple.{u3, u2, u4} R₃ R₂ R₁ _inst_5 _inst_4 _inst_3 σ₃₂ σ₂₁ σ₃₁] {re₁₂ : RingHomInvPair.{u4, u2} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁} {re₂₃ : RingHomInvPair.{u2, u3} R₂ R₃ _inst_4 _inst_5 σ₂₃ σ₃₂} [_inst_15 : RingHomInvPair.{u4, u3} R₁ R₃ _inst_3 _inst_5 σ₁₃ σ₃₁] {re₂₁ : RingHomInvPair.{u2, u4} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂} {re₃₂ : RingHomInvPair.{u3, u2} R₃ R₂ _inst_5 _inst_4 σ₃₂ σ₂₃} [_inst_16 : RingHomInvPair.{u3, u4} R₃ R₁ _inst_5 _inst_3 σ₃₁ σ₁₃] {e₁₂ : LinearEquiv.{u4, u2, u6, u1} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂} {e₂₃ : LinearEquiv.{u2, u3, u1, u5} R₂ R₃ _inst_4 _inst_5 σ₂₃ σ₃₂ re₂₃ re₃₂ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃}, Eq.{max (succ u6) (succ u5)} (LinearMap.{u4, u3, u6, u5} R₁ R₃ _inst_3 _inst_5 σ₁₃ M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃) (LinearEquiv.toLinearMap.{u4, u3, u6, u5} R₁ R₃ _inst_3 _inst_5 σ₁₃ σ₃₁ _inst_15 _inst_16 M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃ (LinearEquiv.trans.{u4, u2, u3, u6, u1, u5} R₁ R₂ R₃ M₁ M₂ M₃ _inst_3 _inst_4 _inst_5 _inst_7 _inst_8 _inst_9 module_M₁ module_M₂ module_M₃ σ₁₂ σ₂₃ σ₁₃ σ₂₁ σ₃₂ σ₃₁ _inst_13 _inst_14 re₁₂ re₂₃ _inst_15 re₂₁ re₃₂ _inst_16 e₁₂ e₂₃)) (LinearMap.comp.{u4, u2, u3, u6, u1, u5} R₁ R₂ R₃ M₁ M₂ M₃ _inst_3 _inst_4 _inst_5 _inst_7 _inst_8 _inst_9 module_M₁ module_M₂ module_M₃ σ₁₂ σ₂₃ σ₁₃ _inst_13 (LinearEquiv.toLinearMap.{u2, u3, u1, u5} R₂ R₃ _inst_4 _inst_5 σ₂₃ σ₃₂ re₂₃ re₃₂ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃ e₂₃) (LinearEquiv.toLinearMap.{u4, u2, u6, u1} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂ e₁₂))
Case conversion may be inaccurate. Consider using '#align linear_equiv.coe_trans LinearEquiv.coe_transₓ'. -/
theorem coe_trans :
    (e₁₂.trans e₂₃ : M₁ →ₛₗ[σ₁₃] M₃) = (e₂₃ : M₂ →ₛₗ[σ₂₃] M₃).comp (e₁₂ : M₁ →ₛₗ[σ₁₂] M₂) :=
  rfl
#align linear_equiv.coe_trans LinearEquiv.coe_trans

omit σ₃₁

include σ'

/- warning: linear_equiv.apply_symm_apply -> LinearEquiv.apply_symm_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (c : M₂), Eq.{succ u4} M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e (coeFn.{max (succ u4) (succ u3), max (succ u4) (succ u3)} (LinearEquiv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) (fun (_x : LinearEquiv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) => M₂ -> M) (LinearEquiv.hasCoeToFun.{u2, u1, u4, u3} S R M₂ M _inst_2 _inst_1 _inst_8 _inst_6 module_S_M₂ module_M σ' σ re₂ re₁) (LinearEquiv.symm.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂ e) c)) c
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (c : M₂), Eq.{succ u4} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) (FunLike.coe.{max (succ u3) (succ u4), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) M₂ (fun (a : M₂) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M₂) => M) a) (EmbeddingLike.toFunLike.{max (succ u3) (succ u4), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) M₂ M (EquivLike.toEmbeddingLike.{max (succ u3) (succ u4), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) M₂ M (AddEquivClass.toEquivLike.{max u3 u4, u4, u3} (LinearEquiv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) M₂ M (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (SemilinearEquivClass.toAddEquivClass.{max u3 u4, u2, u1, u4, u3} (LinearEquiv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u4, u3} S R M₂ M _inst_2 _inst_1 _inst_8 _inst_6 module_S_M₂ module_M σ' σ re₂ re₁))))) (LinearEquiv.symm.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂ e) c)) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u3 u4, u3, u4} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u3 u4, u1, u2, u3, u4} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e (FunLike.coe.{max (succ u3) (succ u4), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) M₂ (fun (_x : M₂) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M₂) => M) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u4), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) M₂ M (EquivLike.toEmbeddingLike.{max (succ u3) (succ u4), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) M₂ M (AddEquivClass.toEquivLike.{max u3 u4, u4, u3} (LinearEquiv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) M₂ M (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (SemilinearEquivClass.toAddEquivClass.{max u3 u4, u2, u1, u4, u3} (LinearEquiv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u4, u3} S R M₂ M _inst_2 _inst_1 _inst_8 _inst_6 module_S_M₂ module_M σ' σ re₂ re₁))))) (LinearEquiv.symm.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂ e) c)) c
Case conversion may be inaccurate. Consider using '#align linear_equiv.apply_symm_apply LinearEquiv.apply_symm_applyₓ'. -/
@[simp]
theorem apply_symm_apply (c : M₂) : e (e.symm c) = c :=
  e.right_inv c
#align linear_equiv.apply_symm_apply LinearEquiv.apply_symm_apply

/- warning: linear_equiv.symm_apply_apply -> LinearEquiv.symm_apply_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (b : M), Eq.{succ u3} M (coeFn.{max (succ u4) (succ u3), max (succ u4) (succ u3)} (LinearEquiv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) (fun (_x : LinearEquiv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) => M₂ -> M) (LinearEquiv.hasCoeToFun.{u2, u1, u4, u3} S R M₂ M _inst_2 _inst_1 _inst_8 _inst_6 module_S_M₂ module_M σ' σ re₂ re₁) (LinearEquiv.symm.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂ e) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e b)) b
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u4}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_6 : AddCommMonoid.{u4} M] [_inst_8 : AddCommMonoid.{u3} M₂] {module_M : Module.{u2, u4} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u1, u3} S M₂ _inst_2 _inst_8} {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} {σ' : RingHom.{u1, u2} S R (Semiring.toNonAssocSemiring.{u1} S _inst_2) (Semiring.toNonAssocSemiring.{u2} R _inst_1)} {re₁ : RingHomInvPair.{u2, u1} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u1, u2} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (b : M), Eq.{succ u4} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M₂) => M) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (a : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) a) (EmbeddingLike.toFunLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u4 u3, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u4 u3, u2, u1, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e b)) (FunLike.coe.{max (succ u4) (succ u3), succ u3, succ u4} (LinearEquiv.{u1, u2, u3, u4} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) M₂ (fun (_x : M₂) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M₂) => M) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u3), succ u3, succ u4} (LinearEquiv.{u1, u2, u3, u4} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) M₂ M (EquivLike.toEmbeddingLike.{max (succ u4) (succ u3), succ u3, succ u4} (LinearEquiv.{u1, u2, u3, u4} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) M₂ M (AddEquivClass.toEquivLike.{max u4 u3, u3, u4} (LinearEquiv.{u1, u2, u3, u4} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) M₂ M (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (SemilinearEquivClass.toAddEquivClass.{max u4 u3, u1, u2, u3, u4} (LinearEquiv.{u1, u2, u3, u4} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u2, u3, u4} S R M₂ M _inst_2 _inst_1 _inst_8 _inst_6 module_S_M₂ module_M σ' σ re₂ re₁))))) (LinearEquiv.symm.{u2, u1, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂ e) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u4 u3, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u4 u3, u2, u1, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e b)) b
Case conversion may be inaccurate. Consider using '#align linear_equiv.symm_apply_apply LinearEquiv.symm_apply_applyₓ'. -/
@[simp]
theorem symm_apply_apply (b : M) : e.symm (e b) = b :=
  e.left_inv b
#align linear_equiv.symm_apply_apply LinearEquiv.symm_apply_apply

omit σ'

include σ₃₁ σ₂₁ σ₃₂

/- warning: linear_equiv.trans_symm -> LinearEquiv.trans_symm is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {R₃ : Type.{u3}} {M₁ : Type.{u4}} {M₂ : Type.{u5}} {M₃ : Type.{u6}} [_inst_3 : Semiring.{u1} R₁] [_inst_4 : Semiring.{u2} R₂] [_inst_5 : Semiring.{u3} R₃] [_inst_7 : AddCommMonoid.{u4} M₁] [_inst_8 : AddCommMonoid.{u5} M₂] [_inst_9 : AddCommMonoid.{u6} M₃] {module_M₁ : Module.{u1, u4} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u2, u5} R₂ M₂ _inst_4 _inst_8} {module_M₃ : Module.{u3, u6} R₃ M₃ _inst_5 _inst_9} {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₂₃ : RingHom.{u2, u3} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5)} {σ₁₃ : RingHom.{u1, u3} R₁ R₃ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5)} {σ₂₁ : RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)} {σ₃₂ : RingHom.{u3, u2} R₃ R₂ (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₃₁ : RingHom.{u3, u1} R₃ R₁ (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)} [_inst_13 : RingHomCompTriple.{u1, u2, u3} R₁ R₂ R₃ _inst_3 _inst_4 _inst_5 σ₁₂ σ₂₃ σ₁₃] [_inst_14 : RingHomCompTriple.{u3, u2, u1} R₃ R₂ R₁ _inst_5 _inst_4 _inst_3 σ₃₂ σ₂₁ σ₃₁] {re₁₂ : RingHomInvPair.{u1, u2} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁} {re₂₃ : RingHomInvPair.{u2, u3} R₂ R₃ _inst_4 _inst_5 σ₂₃ σ₃₂} [_inst_15 : RingHomInvPair.{u1, u3} R₁ R₃ _inst_3 _inst_5 σ₁₃ σ₃₁] {re₂₁ : RingHomInvPair.{u2, u1} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂} {re₃₂ : RingHomInvPair.{u3, u2} R₃ R₂ _inst_5 _inst_4 σ₃₂ σ₂₃} [_inst_16 : RingHomInvPair.{u3, u1} R₃ R₁ _inst_5 _inst_3 σ₃₁ σ₁₃] {e₁₂ : LinearEquiv.{u1, u2, u4, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂} {e₂₃ : LinearEquiv.{u2, u3, u5, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ σ₃₂ re₂₃ re₃₂ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃}, Eq.{max (succ u6) (succ u4)} (LinearEquiv.{u3, u1, u6, u4} R₃ R₁ _inst_5 _inst_3 σ₃₁ σ₁₃ _inst_16 _inst_15 M₃ M₁ _inst_9 _inst_7 module_M₃ module_M₁) (LinearEquiv.symm.{u1, u3, u4, u6} R₁ R₃ M₁ M₃ _inst_3 _inst_5 _inst_7 _inst_9 module_M₁ module_M₃ σ₁₃ σ₃₁ _inst_15 _inst_16 (LinearEquiv.trans.{u1, u2, u3, u4, u5, u6} R₁ R₂ R₃ M₁ M₂ M₃ _inst_3 _inst_4 _inst_5 _inst_7 _inst_8 _inst_9 module_M₁ module_M₂ module_M₃ σ₁₂ σ₂₃ σ₁₃ σ₂₁ σ₃₂ σ₃₁ _inst_13 _inst_14 re₁₂ re₂₃ _inst_15 re₂₁ re₃₂ _inst_16 e₁₂ e₂₃)) (LinearEquiv.trans.{u3, u2, u1, u6, u5, u4} R₃ R₂ R₁ M₃ M₂ M₁ _inst_5 _inst_4 _inst_3 _inst_9 _inst_8 _inst_7 module_M₃ module_M₂ module_M₁ σ₃₂ σ₂₁ σ₃₁ σ₂₃ σ₁₂ σ₁₃ _inst_14 _inst_13 re₃₂ re₂₁ _inst_16 re₂₃ re₁₂ _inst_15 (LinearEquiv.symm.{u2, u3, u5, u6} R₂ R₃ M₂ M₃ _inst_4 _inst_5 _inst_8 _inst_9 module_M₂ module_M₃ σ₂₃ σ₃₂ re₂₃ re₃₂ e₂₃) (LinearEquiv.symm.{u1, u2, u4, u5} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁ e₁₂))
but is expected to have type
  forall {R₁ : Type.{u3}} {R₂ : Type.{u2}} {R₃ : Type.{u4}} {M₁ : Type.{u6}} {M₂ : Type.{u1}} {M₃ : Type.{u5}} [_inst_3 : Semiring.{u3} R₁] [_inst_4 : Semiring.{u2} R₂] [_inst_5 : Semiring.{u4} R₃] [_inst_7 : AddCommMonoid.{u6} M₁] [_inst_8 : AddCommMonoid.{u1} M₂] [_inst_9 : AddCommMonoid.{u5} M₃] {module_M₁ : Module.{u3, u6} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u2, u1} R₂ M₂ _inst_4 _inst_8} {module_M₃ : Module.{u4, u5} R₃ M₃ _inst_5 _inst_9} {σ₁₂ : RingHom.{u3, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₂₃ : RingHom.{u2, u4} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u4} R₃ _inst_5)} {σ₁₃ : RingHom.{u3, u4} R₁ R₃ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u4} R₃ _inst_5)} {σ₂₁ : RingHom.{u2, u3} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3)} {σ₃₂ : RingHom.{u4, u2} R₃ R₂ (Semiring.toNonAssocSemiring.{u4} R₃ _inst_5) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₃₁ : RingHom.{u4, u3} R₃ R₁ (Semiring.toNonAssocSemiring.{u4} R₃ _inst_5) (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3)} [_inst_13 : RingHomCompTriple.{u3, u2, u4} R₁ R₂ R₃ _inst_3 _inst_4 _inst_5 σ₁₂ σ₂₃ σ₁₃] [_inst_14 : RingHomCompTriple.{u4, u2, u3} R₃ R₂ R₁ _inst_5 _inst_4 _inst_3 σ₃₂ σ₂₁ σ₃₁] {re₁₂ : RingHomInvPair.{u3, u2} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁} {re₂₃ : RingHomInvPair.{u2, u4} R₂ R₃ _inst_4 _inst_5 σ₂₃ σ₃₂} [_inst_15 : RingHomInvPair.{u3, u4} R₁ R₃ _inst_3 _inst_5 σ₁₃ σ₃₁] {re₂₁ : RingHomInvPair.{u2, u3} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂} {re₃₂ : RingHomInvPair.{u4, u2} R₃ R₂ _inst_5 _inst_4 σ₃₂ σ₂₃} [_inst_16 : RingHomInvPair.{u4, u3} R₃ R₁ _inst_5 _inst_3 σ₃₁ σ₁₃] {e₁₂ : LinearEquiv.{u3, u2, u6, u1} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂} {e₂₃ : LinearEquiv.{u2, u4, u1, u5} R₂ R₃ _inst_4 _inst_5 σ₂₃ σ₃₂ re₂₃ re₃₂ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃}, Eq.{max (succ u6) (succ u5)} (LinearEquiv.{u4, u3, u5, u6} R₃ R₁ _inst_5 _inst_3 σ₃₁ σ₁₃ _inst_16 _inst_15 M₃ M₁ _inst_9 _inst_7 module_M₃ module_M₁) (LinearEquiv.symm.{u3, u4, u6, u5} R₁ R₃ M₁ M₃ _inst_3 _inst_5 _inst_7 _inst_9 module_M₁ module_M₃ σ₁₃ σ₃₁ _inst_15 _inst_16 (LinearEquiv.trans.{u3, u2, u4, u6, u1, u5} R₁ R₂ R₃ M₁ M₂ M₃ _inst_3 _inst_4 _inst_5 _inst_7 _inst_8 _inst_9 module_M₁ module_M₂ module_M₃ σ₁₂ σ₂₃ σ₁₃ σ₂₁ σ₃₂ σ₃₁ _inst_13 _inst_14 re₁₂ re₂₃ _inst_15 re₂₁ re₃₂ _inst_16 e₁₂ e₂₃)) (LinearEquiv.trans.{u4, u2, u3, u5, u1, u6} R₃ R₂ R₁ M₃ M₂ M₁ _inst_5 _inst_4 _inst_3 _inst_9 _inst_8 _inst_7 module_M₃ module_M₂ module_M₁ σ₃₂ σ₂₁ σ₃₁ σ₂₃ σ₁₂ σ₁₃ _inst_14 _inst_13 re₃₂ re₂₁ _inst_16 re₂₃ re₁₂ _inst_15 (LinearEquiv.symm.{u2, u4, u1, u5} R₂ R₃ M₂ M₃ _inst_4 _inst_5 _inst_8 _inst_9 module_M₂ module_M₃ σ₂₃ σ₃₂ re₂₃ re₃₂ e₂₃) (LinearEquiv.symm.{u3, u2, u6, u1} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁ e₁₂))
Case conversion may be inaccurate. Consider using '#align linear_equiv.trans_symm LinearEquiv.trans_symmₓ'. -/
@[simp]
theorem trans_symm : (e₁₂.trans e₂₃ : M₁ ≃ₛₗ[σ₁₃] M₃).symm = e₂₃.symm.trans e₁₂.symm :=
  rfl
#align linear_equiv.trans_symm LinearEquiv.trans_symm

/- warning: linear_equiv.symm_trans_apply -> LinearEquiv.symm_trans_apply is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {R₃ : Type.{u3}} {M₁ : Type.{u4}} {M₂ : Type.{u5}} {M₃ : Type.{u6}} [_inst_3 : Semiring.{u1} R₁] [_inst_4 : Semiring.{u2} R₂] [_inst_5 : Semiring.{u3} R₃] [_inst_7 : AddCommMonoid.{u4} M₁] [_inst_8 : AddCommMonoid.{u5} M₂] [_inst_9 : AddCommMonoid.{u6} M₃] {module_M₁ : Module.{u1, u4} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u2, u5} R₂ M₂ _inst_4 _inst_8} {module_M₃ : Module.{u3, u6} R₃ M₃ _inst_5 _inst_9} {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₂₃ : RingHom.{u2, u3} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5)} {σ₁₃ : RingHom.{u1, u3} R₁ R₃ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5)} {σ₂₁ : RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)} {σ₃₂ : RingHom.{u3, u2} R₃ R₂ (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₃₁ : RingHom.{u3, u1} R₃ R₁ (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)} [_inst_13 : RingHomCompTriple.{u1, u2, u3} R₁ R₂ R₃ _inst_3 _inst_4 _inst_5 σ₁₂ σ₂₃ σ₁₃] [_inst_14 : RingHomCompTriple.{u3, u2, u1} R₃ R₂ R₁ _inst_5 _inst_4 _inst_3 σ₃₂ σ₂₁ σ₃₁] {re₁₂ : RingHomInvPair.{u1, u2} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁} {re₂₃ : RingHomInvPair.{u2, u3} R₂ R₃ _inst_4 _inst_5 σ₂₃ σ₃₂} [_inst_15 : RingHomInvPair.{u1, u3} R₁ R₃ _inst_3 _inst_5 σ₁₃ σ₃₁] {re₂₁ : RingHomInvPair.{u2, u1} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂} {re₃₂ : RingHomInvPair.{u3, u2} R₃ R₂ _inst_5 _inst_4 σ₃₂ σ₂₃} [_inst_16 : RingHomInvPair.{u3, u1} R₃ R₁ _inst_5 _inst_3 σ₃₁ σ₁₃] {e₁₂ : LinearEquiv.{u1, u2, u4, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂} {e₂₃ : LinearEquiv.{u2, u3, u5, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ σ₃₂ re₂₃ re₃₂ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃} (c : M₃), Eq.{succ u4} M₁ (coeFn.{max (succ u6) (succ u4), max (succ u6) (succ u4)} (LinearEquiv.{u3, u1, u6, u4} R₃ R₁ _inst_5 _inst_3 σ₃₁ σ₁₃ _inst_16 _inst_15 M₃ M₁ _inst_9 _inst_7 module_M₃ module_M₁) (fun (_x : LinearEquiv.{u3, u1, u6, u4} R₃ R₁ _inst_5 _inst_3 σ₃₁ σ₁₃ _inst_16 _inst_15 M₃ M₁ _inst_9 _inst_7 module_M₃ module_M₁) => M₃ -> M₁) (LinearEquiv.hasCoeToFun.{u3, u1, u6, u4} R₃ R₁ M₃ M₁ _inst_5 _inst_3 _inst_9 _inst_7 module_M₃ module_M₁ σ₃₁ σ₁₃ _inst_16 _inst_15) (LinearEquiv.symm.{u1, u3, u4, u6} R₁ R₃ M₁ M₃ _inst_3 _inst_5 _inst_7 _inst_9 module_M₁ module_M₃ σ₁₃ σ₃₁ _inst_15 _inst_16 (LinearEquiv.trans.{u1, u2, u3, u4, u5, u6} R₁ R₂ R₃ M₁ M₂ M₃ _inst_3 _inst_4 _inst_5 _inst_7 _inst_8 _inst_9 module_M₁ module_M₂ module_M₃ σ₁₂ σ₂₃ σ₁₃ σ₂₁ σ₃₂ σ₃₁ _inst_13 _inst_14 re₁₂ re₂₃ _inst_15 re₂₁ re₃₂ _inst_16 e₁₂ e₂₃)) c) (coeFn.{max (succ u5) (succ u4), max (succ u5) (succ u4)} (LinearEquiv.{u2, u1, u5, u4} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) (fun (_x : LinearEquiv.{u2, u1, u5, u4} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) => M₂ -> M₁) (LinearEquiv.hasCoeToFun.{u2, u1, u5, u4} R₂ R₁ M₂ M₁ _inst_4 _inst_3 _inst_8 _inst_7 module_M₂ module_M₁ σ₂₁ σ₁₂ re₂₁ re₁₂) (LinearEquiv.symm.{u1, u2, u4, u5} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁ e₁₂) (coeFn.{max (succ u6) (succ u5), max (succ u6) (succ u5)} (LinearEquiv.{u3, u2, u6, u5} R₃ R₂ _inst_5 _inst_4 σ₃₂ σ₂₃ re₃₂ re₂₃ M₃ M₂ _inst_9 _inst_8 module_M₃ module_M₂) (fun (_x : LinearEquiv.{u3, u2, u6, u5} R₃ R₂ _inst_5 _inst_4 σ₃₂ σ₂₃ re₃₂ re₂₃ M₃ M₂ _inst_9 _inst_8 module_M₃ module_M₂) => M₃ -> M₂) (LinearEquiv.hasCoeToFun.{u3, u2, u6, u5} R₃ R₂ M₃ M₂ _inst_5 _inst_4 _inst_9 _inst_8 module_M₃ module_M₂ σ₃₂ σ₂₃ re₃₂ re₂₃) (LinearEquiv.symm.{u2, u3, u5, u6} R₂ R₃ M₂ M₃ _inst_4 _inst_5 _inst_8 _inst_9 module_M₂ module_M₃ σ₂₃ σ₃₂ re₂₃ re₃₂ e₂₃) c))
but is expected to have type
  forall {R₁ : Type.{u3}} {R₂ : Type.{u2}} {R₃ : Type.{u4}} {M₁ : Type.{u6}} {M₂ : Type.{u1}} {M₃ : Type.{u5}} [_inst_3 : Semiring.{u3} R₁] [_inst_4 : Semiring.{u2} R₂] [_inst_5 : Semiring.{u4} R₃] [_inst_7 : AddCommMonoid.{u6} M₁] [_inst_8 : AddCommMonoid.{u1} M₂] [_inst_9 : AddCommMonoid.{u5} M₃] {module_M₁ : Module.{u3, u6} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u2, u1} R₂ M₂ _inst_4 _inst_8} {module_M₃ : Module.{u4, u5} R₃ M₃ _inst_5 _inst_9} {σ₁₂ : RingHom.{u3, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₂₃ : RingHom.{u2, u4} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u4} R₃ _inst_5)} {σ₁₃ : RingHom.{u3, u4} R₁ R₃ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u4} R₃ _inst_5)} {σ₂₁ : RingHom.{u2, u3} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3)} {σ₃₂ : RingHom.{u4, u2} R₃ R₂ (Semiring.toNonAssocSemiring.{u4} R₃ _inst_5) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₃₁ : RingHom.{u4, u3} R₃ R₁ (Semiring.toNonAssocSemiring.{u4} R₃ _inst_5) (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3)} [_inst_13 : RingHomCompTriple.{u3, u2, u4} R₁ R₂ R₃ _inst_3 _inst_4 _inst_5 σ₁₂ σ₂₃ σ₁₃] [_inst_14 : RingHomCompTriple.{u4, u2, u3} R₃ R₂ R₁ _inst_5 _inst_4 _inst_3 σ₃₂ σ₂₁ σ₃₁] {re₁₂ : RingHomInvPair.{u3, u2} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁} {re₂₃ : RingHomInvPair.{u2, u4} R₂ R₃ _inst_4 _inst_5 σ₂₃ σ₃₂} [_inst_15 : RingHomInvPair.{u3, u4} R₁ R₃ _inst_3 _inst_5 σ₁₃ σ₃₁] {re₂₁ : RingHomInvPair.{u2, u3} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂} {re₃₂ : RingHomInvPair.{u4, u2} R₃ R₂ _inst_5 _inst_4 σ₃₂ σ₂₃} [_inst_16 : RingHomInvPair.{u4, u3} R₃ R₁ _inst_5 _inst_3 σ₃₁ σ₁₃] {e₁₂ : LinearEquiv.{u3, u2, u6, u1} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂} {e₂₃ : LinearEquiv.{u2, u4, u1, u5} R₂ R₃ _inst_4 _inst_5 σ₂₃ σ₃₂ re₂₃ re₃₂ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃} (c : M₃), Eq.{succ u6} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M₃) => M₁) c) (FunLike.coe.{max (succ u6) (succ u5), succ u5, succ u6} (LinearEquiv.{u4, u3, u5, u6} R₃ R₁ _inst_5 _inst_3 σ₃₁ σ₁₃ _inst_16 _inst_15 M₃ M₁ _inst_9 _inst_7 module_M₃ module_M₁) M₃ (fun (_x : M₃) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M₃) => M₁) _x) (EmbeddingLike.toFunLike.{max (succ u6) (succ u5), succ u5, succ u6} (LinearEquiv.{u4, u3, u5, u6} R₃ R₁ _inst_5 _inst_3 σ₃₁ σ₁₃ _inst_16 _inst_15 M₃ M₁ _inst_9 _inst_7 module_M₃ module_M₁) M₃ M₁ (EquivLike.toEmbeddingLike.{max (succ u6) (succ u5), succ u5, succ u6} (LinearEquiv.{u4, u3, u5, u6} R₃ R₁ _inst_5 _inst_3 σ₃₁ σ₁₃ _inst_16 _inst_15 M₃ M₁ _inst_9 _inst_7 module_M₃ module_M₁) M₃ M₁ (AddEquivClass.toEquivLike.{max u6 u5, u5, u6} (LinearEquiv.{u4, u3, u5, u6} R₃ R₁ _inst_5 _inst_3 σ₃₁ σ₁₃ _inst_16 _inst_15 M₃ M₁ _inst_9 _inst_7 module_M₃ module_M₁) M₃ M₁ (AddZeroClass.toAdd.{u5} M₃ (AddMonoid.toAddZeroClass.{u5} M₃ (AddCommMonoid.toAddMonoid.{u5} M₃ _inst_9))) (AddZeroClass.toAdd.{u6} M₁ (AddMonoid.toAddZeroClass.{u6} M₁ (AddCommMonoid.toAddMonoid.{u6} M₁ _inst_7))) (SemilinearEquivClass.toAddEquivClass.{max u6 u5, u4, u3, u5, u6} (LinearEquiv.{u4, u3, u5, u6} R₃ R₁ _inst_5 _inst_3 σ₃₁ σ₁₃ _inst_16 _inst_15 M₃ M₁ _inst_9 _inst_7 module_M₃ module_M₁) R₃ R₁ _inst_5 _inst_3 σ₃₁ σ₁₃ _inst_16 _inst_15 M₃ M₁ _inst_9 _inst_7 module_M₃ module_M₁ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u4, u3, u5, u6} R₃ R₁ M₃ M₁ _inst_5 _inst_3 _inst_9 _inst_7 module_M₃ module_M₁ σ₃₁ σ₁₃ _inst_16 _inst_15))))) (LinearEquiv.symm.{u3, u4, u6, u5} R₁ R₃ M₁ M₃ _inst_3 _inst_5 _inst_7 _inst_9 module_M₁ module_M₃ σ₁₃ σ₃₁ _inst_15 _inst_16 (LinearEquiv.trans.{u3, u2, u4, u6, u1, u5} R₁ R₂ R₃ M₁ M₂ M₃ _inst_3 _inst_4 _inst_5 _inst_7 _inst_8 _inst_9 module_M₁ module_M₂ module_M₃ σ₁₂ σ₂₃ σ₁₃ σ₂₁ σ₃₂ σ₃₁ _inst_13 _inst_14 re₁₂ re₂₃ _inst_15 re₂₁ re₃₂ _inst_16 e₁₂ e₂₃)) c) (FunLike.coe.{max (succ u6) (succ u1), succ u1, succ u6} (LinearEquiv.{u2, u3, u1, u6} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) M₂ (fun (_x : M₂) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M₂) => M₁) _x) (EmbeddingLike.toFunLike.{max (succ u6) (succ u1), succ u1, succ u6} (LinearEquiv.{u2, u3, u1, u6} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) M₂ M₁ (EquivLike.toEmbeddingLike.{max (succ u6) (succ u1), succ u1, succ u6} (LinearEquiv.{u2, u3, u1, u6} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) M₂ M₁ (AddEquivClass.toEquivLike.{max u6 u1, u1, u6} (LinearEquiv.{u2, u3, u1, u6} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) M₂ M₁ (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_8))) (AddZeroClass.toAdd.{u6} M₁ (AddMonoid.toAddZeroClass.{u6} M₁ (AddCommMonoid.toAddMonoid.{u6} M₁ _inst_7))) (SemilinearEquivClass.toAddEquivClass.{max u6 u1, u2, u3, u1, u6} (LinearEquiv.{u2, u3, u1, u6} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u3, u1, u6} R₂ R₁ M₂ M₁ _inst_4 _inst_3 _inst_8 _inst_7 module_M₂ module_M₁ σ₂₁ σ₁₂ re₂₁ re₁₂))))) (LinearEquiv.symm.{u3, u2, u6, u1} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁ e₁₂) (FunLike.coe.{max (succ u1) (succ u5), succ u5, succ u1} (LinearEquiv.{u4, u2, u5, u1} R₃ R₂ _inst_5 _inst_4 σ₃₂ σ₂₃ re₃₂ re₂₃ M₃ M₂ _inst_9 _inst_8 module_M₃ module_M₂) M₃ (fun (_x : M₃) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M₃) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u5), succ u5, succ u1} (LinearEquiv.{u4, u2, u5, u1} R₃ R₂ _inst_5 _inst_4 σ₃₂ σ₂₃ re₃₂ re₂₃ M₃ M₂ _inst_9 _inst_8 module_M₃ module_M₂) M₃ M₂ (EquivLike.toEmbeddingLike.{max (succ u1) (succ u5), succ u5, succ u1} (LinearEquiv.{u4, u2, u5, u1} R₃ R₂ _inst_5 _inst_4 σ₃₂ σ₂₃ re₃₂ re₂₃ M₃ M₂ _inst_9 _inst_8 module_M₃ module_M₂) M₃ M₂ (AddEquivClass.toEquivLike.{max u1 u5, u5, u1} (LinearEquiv.{u4, u2, u5, u1} R₃ R₂ _inst_5 _inst_4 σ₃₂ σ₂₃ re₃₂ re₂₃ M₃ M₂ _inst_9 _inst_8 module_M₃ module_M₂) M₃ M₂ (AddZeroClass.toAdd.{u5} M₃ (AddMonoid.toAddZeroClass.{u5} M₃ (AddCommMonoid.toAddMonoid.{u5} M₃ _inst_9))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u1 u5, u4, u2, u5, u1} (LinearEquiv.{u4, u2, u5, u1} R₃ R₂ _inst_5 _inst_4 σ₃₂ σ₂₃ re₃₂ re₂₃ M₃ M₂ _inst_9 _inst_8 module_M₃ module_M₂) R₃ R₂ _inst_5 _inst_4 σ₃₂ σ₂₃ re₃₂ re₂₃ M₃ M₂ _inst_9 _inst_8 module_M₃ module_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u4, u2, u5, u1} R₃ R₂ M₃ M₂ _inst_5 _inst_4 _inst_9 _inst_8 module_M₃ module_M₂ σ₃₂ σ₂₃ re₃₂ re₂₃))))) (LinearEquiv.symm.{u2, u4, u1, u5} R₂ R₃ M₂ M₃ _inst_4 _inst_5 _inst_8 _inst_9 module_M₂ module_M₃ σ₂₃ σ₃₂ re₂₃ re₃₂ e₂₃) c))
Case conversion may be inaccurate. Consider using '#align linear_equiv.symm_trans_apply LinearEquiv.symm_trans_applyₓ'. -/
theorem symm_trans_apply (c : M₃) :
    (e₁₂.trans e₂₃ : M₁ ≃ₛₗ[σ₁₃] M₃).symm c = e₁₂.symm (e₂₃.symm c) :=
  rfl
#align linear_equiv.symm_trans_apply LinearEquiv.symm_trans_apply

omit σ₃₁ σ₂₁ σ₃₂

/- warning: linear_equiv.trans_refl -> LinearEquiv.trans_refl is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂), Eq.{max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (LinearEquiv.trans.{u1, u2, u2, u3, u4, u4} R S S M M₂ M₂ _inst_1 _inst_2 _inst_2 _inst_6 _inst_8 _inst_8 module_M module_S_M₂ module_S_M₂ σ (RingHom.id.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) σ σ' (RingHom.id.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) σ' (RingHomCompTriple.right_ids.{u1, u2} R S _inst_1 _inst_2 σ) (RingHomCompTriple.ids.{u2, u1} S R _inst_2 _inst_1 σ') re₁ (RingHomInvPair.ids.{u2} S _inst_2) re₁ re₂ (RingHomInvPair.ids.{u2} S _inst_2) re₂ e (LinearEquiv.refl.{u2, u4} S M₂ _inst_2 _inst_8 module_S_M₂)) e
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u4}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_6 : AddCommMonoid.{u4} M] [_inst_8 : AddCommMonoid.{u3} M₂] {module_M : Module.{u2, u4} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u1, u3} S M₂ _inst_2 _inst_8} {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} {σ' : RingHom.{u1, u2} S R (Semiring.toNonAssocSemiring.{u1} S _inst_2) (Semiring.toNonAssocSemiring.{u2} R _inst_1)} {re₁ : RingHomInvPair.{u2, u1} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u1, u2} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂), Eq.{max (succ u4) (succ u3)} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (LinearEquiv.trans.{u2, u1, u1, u4, u3, u3} R S S M M₂ M₂ _inst_1 _inst_2 _inst_2 _inst_6 _inst_8 _inst_8 module_M module_S_M₂ module_S_M₂ σ (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) σ σ' (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) σ' (RingHomCompTriple.right_ids.{u2, u1} R S _inst_1 _inst_2 σ) (RingHomCompTriple.ids.{u1, u2} S R _inst_2 _inst_1 σ') re₁ (RingHomInvPair.ids.{u1} S _inst_2) re₁ re₂ (RingHomInvPair.ids.{u1} S _inst_2) re₂ e (LinearEquiv.refl.{u1, u3} S M₂ _inst_2 _inst_8 module_S_M₂)) e
Case conversion may be inaccurate. Consider using '#align linear_equiv.trans_refl LinearEquiv.trans_reflₓ'. -/
@[simp]
theorem trans_refl : e.trans (refl S M₂) = e :=
  toEquiv_injective e.toEquiv.trans_refl
#align linear_equiv.trans_refl LinearEquiv.trans_refl

/- warning: linear_equiv.refl_trans -> LinearEquiv.refl_trans is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂), Eq.{max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (LinearEquiv.trans.{u1, u1, u2, u3, u3, u4} R R S M M M₂ _inst_1 _inst_1 _inst_2 _inst_6 _inst_6 _inst_8 module_M module_M module_S_M₂ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) σ σ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) σ' σ' (RingHomCompTriple.ids.{u1, u2} R S _inst_1 _inst_2 σ) (RingHomCompTriple.right_ids.{u2, u1} S R _inst_2 _inst_1 σ') (RingHomInvPair.ids.{u1} R _inst_1) re₁ re₁ (RingHomInvPair.ids.{u1} R _inst_1) re₂ re₂ (LinearEquiv.refl.{u1, u3} R M _inst_1 _inst_6 module_M) e) e
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u4}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_6 : AddCommMonoid.{u4} M] [_inst_8 : AddCommMonoid.{u3} M₂] {module_M : Module.{u2, u4} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u1, u3} S M₂ _inst_2 _inst_8} {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} {σ' : RingHom.{u1, u2} S R (Semiring.toNonAssocSemiring.{u1} S _inst_2) (Semiring.toNonAssocSemiring.{u2} R _inst_1)} {re₁ : RingHomInvPair.{u2, u1} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u1, u2} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂), Eq.{max (succ u4) (succ u3)} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (LinearEquiv.trans.{u2, u2, u1, u4, u4, u3} R R S M M M₂ _inst_1 _inst_1 _inst_2 _inst_6 _inst_6 _inst_8 module_M module_M module_S_M₂ (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) σ σ (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) σ' σ' (RingHomCompTriple.ids.{u2, u1} R S _inst_1 _inst_2 σ) (RingHomCompTriple.right_ids.{u1, u2} S R _inst_2 _inst_1 σ') (RingHomInvPair.ids.{u2} R _inst_1) re₁ re₁ (RingHomInvPair.ids.{u2} R _inst_1) re₂ re₂ (LinearEquiv.refl.{u2, u4} R M _inst_1 _inst_6 module_M) e) e
Case conversion may be inaccurate. Consider using '#align linear_equiv.refl_trans LinearEquiv.refl_transₓ'. -/
@[simp]
theorem refl_trans : (refl R M).trans e = e :=
  toEquiv_injective e.toEquiv.refl_trans
#align linear_equiv.refl_trans LinearEquiv.refl_trans

include σ'

/- warning: linear_equiv.symm_apply_eq -> LinearEquiv.symm_apply_eq is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) {x : M₂} {y : M}, Iff (Eq.{succ u3} M (coeFn.{max (succ u4) (succ u3), max (succ u4) (succ u3)} (LinearEquiv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) (fun (_x : LinearEquiv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) => M₂ -> M) (LinearEquiv.hasCoeToFun.{u2, u1, u4, u3} S R M₂ M _inst_2 _inst_1 _inst_8 _inst_6 module_S_M₂ module_M σ' σ re₂ re₁) (LinearEquiv.symm.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂ e) x) y) (Eq.{succ u4} M₂ x (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e y))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u4}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u4} M] [_inst_8 : AddCommMonoid.{u3} M₂] {module_M : Module.{u1, u4} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u3} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u1, u2, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) {x : M₂} {y : (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M₂) => M) x}, Iff (Eq.{succ u4} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M₂) => M) x) (FunLike.coe.{max (succ u4) (succ u3), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) M₂ (fun (_x : M₂) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M₂) => M) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u3), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) M₂ M (EquivLike.toEmbeddingLike.{max (succ u4) (succ u3), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) M₂ M (AddEquivClass.toEquivLike.{max u4 u3, u3, u4} (LinearEquiv.{u2, u1, u3, u4} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) M₂ M (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (SemilinearEquivClass.toAddEquivClass.{max u4 u3, u2, u1, u3, u4} (LinearEquiv.{u2, u1, u3, u4} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u3, u4} S R M₂ M _inst_2 _inst_1 _inst_8 _inst_6 module_S_M₂ module_M σ' σ re₂ re₁))))) (LinearEquiv.symm.{u1, u2, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂ e) x) y) (Eq.{succ u3} M₂ x (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u1, u2, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u1, u2, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u1, u2, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u4 u3, u4, u3} (LinearEquiv.{u1, u2, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u4 u3, u1, u2, u4, u3} (LinearEquiv.{u1, u2, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u2, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e y))
Case conversion may be inaccurate. Consider using '#align linear_equiv.symm_apply_eq LinearEquiv.symm_apply_eqₓ'. -/
theorem symm_apply_eq {x y} : e.symm x = y ↔ x = e y :=
  e.toEquiv.symm_apply_eq
#align linear_equiv.symm_apply_eq LinearEquiv.symm_apply_eq

/- warning: linear_equiv.eq_symm_apply -> LinearEquiv.eq_symm_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) {x : M₂} {y : M}, Iff (Eq.{succ u3} M y (coeFn.{max (succ u4) (succ u3), max (succ u4) (succ u3)} (LinearEquiv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) (fun (_x : LinearEquiv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) => M₂ -> M) (LinearEquiv.hasCoeToFun.{u2, u1, u4, u3} S R M₂ M _inst_2 _inst_1 _inst_8 _inst_6 module_S_M₂ module_M σ' σ re₂ re₁) (LinearEquiv.symm.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂ e) x)) (Eq.{succ u4} M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e y) x)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u4}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u4} M] [_inst_8 : AddCommMonoid.{u3} M₂] {module_M : Module.{u1, u4} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u3} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u1, u2, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) {x : M₂} {y : (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M₂) => M) x}, Iff (Eq.{succ u4} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M₂) => M) x) y (FunLike.coe.{max (succ u4) (succ u3), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) M₂ (fun (_x : M₂) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M₂) => M) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u3), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) M₂ M (EquivLike.toEmbeddingLike.{max (succ u4) (succ u3), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) M₂ M (AddEquivClass.toEquivLike.{max u4 u3, u3, u4} (LinearEquiv.{u2, u1, u3, u4} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) M₂ M (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (SemilinearEquivClass.toAddEquivClass.{max u4 u3, u2, u1, u3, u4} (LinearEquiv.{u2, u1, u3, u4} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u3, u4} S R M₂ M _inst_2 _inst_1 _inst_8 _inst_6 module_S_M₂ module_M σ' σ re₂ re₁))))) (LinearEquiv.symm.{u1, u2, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂ e) x)) (Eq.{succ u3} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) y) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u1, u2, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u1, u2, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u1, u2, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u4 u3, u4, u3} (LinearEquiv.{u1, u2, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u4 u3, u1, u2, u4, u3} (LinearEquiv.{u1, u2, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u2, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e y) x)
Case conversion may be inaccurate. Consider using '#align linear_equiv.eq_symm_apply LinearEquiv.eq_symm_applyₓ'. -/
theorem eq_symm_apply {x y} : y = e.symm x ↔ e y = x :=
  e.toEquiv.eq_symm_apply
#align linear_equiv.eq_symm_apply LinearEquiv.eq_symm_apply

omit σ'

/- warning: linear_equiv.eq_comp_symm -> LinearEquiv.eq_comp_symm is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {M₁ : Type.{u3}} {M₂ : Type.{u4}} [_inst_3 : Semiring.{u1} R₁] [_inst_4 : Semiring.{u2} R₂] [_inst_7 : AddCommMonoid.{u3} M₁] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M₁ : Module.{u1, u3} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u2, u4} R₂ M₂ _inst_4 _inst_8} {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₂₁ : RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)} {re₁₂ : RingHomInvPair.{u1, u2} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁} {re₂₁ : RingHomInvPair.{u2, u1} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂} {e₁₂ : LinearEquiv.{u1, u2, u3, u4} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂} {α : Type.{u5}} (f : M₂ -> α) (g : M₁ -> α), Iff (Eq.{max (succ u4) (succ u5)} (M₂ -> α) f (Function.comp.{succ u4, succ u3, succ u5} M₂ M₁ α g (coeFn.{max (succ u4) (succ u3), max (succ u4) (succ u3)} (LinearEquiv.{u2, u1, u4, u3} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) (fun (_x : LinearEquiv.{u2, u1, u4, u3} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) => M₂ -> M₁) (LinearEquiv.hasCoeToFun.{u2, u1, u4, u3} R₂ R₁ M₂ M₁ _inst_4 _inst_3 _inst_8 _inst_7 module_M₂ module_M₁ σ₂₁ σ₁₂ re₂₁ re₁₂) (LinearEquiv.symm.{u1, u2, u3, u4} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁ e₁₂)))) (Eq.{max (succ u3) (succ u5)} (M₁ -> α) (Function.comp.{succ u3, succ u4, succ u5} M₁ M₂ α f (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) => M₁ -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁) e₁₂)) g)
but is expected to have type
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {M₁ : Type.{u3}} {M₂ : Type.{u4}} [_inst_3 : Semiring.{u1} R₁] [_inst_4 : Semiring.{u2} R₂] [_inst_7 : AddCommMonoid.{u3} M₁] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M₁ : Module.{u1, u3} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u2, u4} R₂ M₂ _inst_4 _inst_8} {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₂₁ : RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)} {re₁₂ : RingHomInvPair.{u1, u2} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁} {re₂₁ : RingHomInvPair.{u2, u1} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂} {e₁₂ : LinearEquiv.{u1, u2, u3, u4} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂} {α : Type.{u5}} (f : M₂ -> α) (g : M₁ -> α), Iff (Eq.{max (succ u4) (succ u5)} (M₂ -> α) f (Function.comp.{succ u4, succ u3, succ u5} M₂ M₁ α g (FunLike.coe.{max (succ u3) (succ u4), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) M₂ (fun (_x : M₂) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M₂) => M₁) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u4), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) M₂ M₁ (EquivLike.toEmbeddingLike.{max (succ u3) (succ u4), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) M₂ M₁ (AddEquivClass.toEquivLike.{max u3 u4, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) M₂ M₁ (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (AddZeroClass.toAdd.{u3} M₁ (AddMonoid.toAddZeroClass.{u3} M₁ (AddCommMonoid.toAddMonoid.{u3} M₁ _inst_7))) (SemilinearEquivClass.toAddEquivClass.{max u3 u4, u2, u1, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u4, u3} R₂ R₁ M₂ M₁ _inst_4 _inst_3 _inst_8 _inst_7 module_M₂ module_M₁ σ₂₁ σ₁₂ re₂₁ re₁₂))))) (LinearEquiv.symm.{u1, u2, u3, u4} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁ e₁₂)))) (Eq.{max (succ u3) (succ u5)} (M₁ -> α) (Function.comp.{succ u3, succ u4, succ u5} M₁ M₂ α f (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u1, u2, u3, u4} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) M₁ (fun (_x : M₁) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M₁) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u1, u2, u3, u4} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) M₁ M₂ (EquivLike.toEmbeddingLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u1, u2, u3, u4} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) M₁ M₂ (AddEquivClass.toEquivLike.{max u3 u4, u3, u4} (LinearEquiv.{u1, u2, u3, u4} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) M₁ M₂ (AddZeroClass.toAdd.{u3} M₁ (AddMonoid.toAddZeroClass.{u3} M₁ (AddCommMonoid.toAddMonoid.{u3} M₁ _inst_7))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u3 u4, u1, u2, u3, u4} (LinearEquiv.{u1, u2, u3, u4} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u2, u3, u4} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁))))) e₁₂)) g)
Case conversion may be inaccurate. Consider using '#align linear_equiv.eq_comp_symm LinearEquiv.eq_comp_symmₓ'. -/
theorem eq_comp_symm {α : Type _} (f : M₂ → α) (g : M₁ → α) : f = g ∘ e₁₂.symm ↔ f ∘ e₁₂ = g :=
  e₁₂.toEquiv.eq_comp_symm f g
#align linear_equiv.eq_comp_symm LinearEquiv.eq_comp_symm

/- warning: linear_equiv.comp_symm_eq -> LinearEquiv.comp_symm_eq is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {M₁ : Type.{u3}} {M₂ : Type.{u4}} [_inst_3 : Semiring.{u1} R₁] [_inst_4 : Semiring.{u2} R₂] [_inst_7 : AddCommMonoid.{u3} M₁] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M₁ : Module.{u1, u3} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u2, u4} R₂ M₂ _inst_4 _inst_8} {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₂₁ : RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)} {re₁₂ : RingHomInvPair.{u1, u2} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁} {re₂₁ : RingHomInvPair.{u2, u1} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂} {e₁₂ : LinearEquiv.{u1, u2, u3, u4} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂} {α : Type.{u5}} (f : M₂ -> α) (g : M₁ -> α), Iff (Eq.{max (succ u4) (succ u5)} (M₂ -> α) (Function.comp.{succ u4, succ u3, succ u5} M₂ M₁ α g (coeFn.{max (succ u4) (succ u3), max (succ u4) (succ u3)} (LinearEquiv.{u2, u1, u4, u3} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) (fun (_x : LinearEquiv.{u2, u1, u4, u3} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) => M₂ -> M₁) (LinearEquiv.hasCoeToFun.{u2, u1, u4, u3} R₂ R₁ M₂ M₁ _inst_4 _inst_3 _inst_8 _inst_7 module_M₂ module_M₁ σ₂₁ σ₁₂ re₂₁ re₁₂) (LinearEquiv.symm.{u1, u2, u3, u4} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁ e₁₂))) f) (Eq.{max (succ u3) (succ u5)} (M₁ -> α) g (Function.comp.{succ u3, succ u4, succ u5} M₁ M₂ α f (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) => M₁ -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁) e₁₂)))
but is expected to have type
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {M₁ : Type.{u3}} {M₂ : Type.{u4}} [_inst_3 : Semiring.{u1} R₁] [_inst_4 : Semiring.{u2} R₂] [_inst_7 : AddCommMonoid.{u3} M₁] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M₁ : Module.{u1, u3} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u2, u4} R₂ M₂ _inst_4 _inst_8} {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₂₁ : RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)} {re₁₂ : RingHomInvPair.{u1, u2} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁} {re₂₁ : RingHomInvPair.{u2, u1} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂} {e₁₂ : LinearEquiv.{u1, u2, u3, u4} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂} {α : Type.{u5}} (f : M₂ -> α) (g : M₁ -> α), Iff (Eq.{max (succ u4) (succ u5)} (M₂ -> α) (Function.comp.{succ u4, succ u3, succ u5} M₂ M₁ α g (FunLike.coe.{max (succ u3) (succ u4), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) M₂ (fun (_x : M₂) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M₂) => M₁) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u4), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) M₂ M₁ (EquivLike.toEmbeddingLike.{max (succ u3) (succ u4), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) M₂ M₁ (AddEquivClass.toEquivLike.{max u3 u4, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) M₂ M₁ (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (AddZeroClass.toAdd.{u3} M₁ (AddMonoid.toAddZeroClass.{u3} M₁ (AddCommMonoid.toAddMonoid.{u3} M₁ _inst_7))) (SemilinearEquivClass.toAddEquivClass.{max u3 u4, u2, u1, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u4, u3} R₂ R₁ M₂ M₁ _inst_4 _inst_3 _inst_8 _inst_7 module_M₂ module_M₁ σ₂₁ σ₁₂ re₂₁ re₁₂))))) (LinearEquiv.symm.{u1, u2, u3, u4} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁ e₁₂))) f) (Eq.{max (succ u3) (succ u5)} (M₁ -> α) g (Function.comp.{succ u3, succ u4, succ u5} M₁ M₂ α f (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u1, u2, u3, u4} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) M₁ (fun (_x : M₁) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M₁) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u1, u2, u3, u4} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) M₁ M₂ (EquivLike.toEmbeddingLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u1, u2, u3, u4} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) M₁ M₂ (AddEquivClass.toEquivLike.{max u3 u4, u3, u4} (LinearEquiv.{u1, u2, u3, u4} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) M₁ M₂ (AddZeroClass.toAdd.{u3} M₁ (AddMonoid.toAddZeroClass.{u3} M₁ (AddCommMonoid.toAddMonoid.{u3} M₁ _inst_7))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u3 u4, u1, u2, u3, u4} (LinearEquiv.{u1, u2, u3, u4} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u2, u3, u4} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁))))) e₁₂)))
Case conversion may be inaccurate. Consider using '#align linear_equiv.comp_symm_eq LinearEquiv.comp_symm_eqₓ'. -/
theorem comp_symm_eq {α : Type _} (f : M₂ → α) (g : M₁ → α) : g ∘ e₁₂.symm = f ↔ g = f ∘ e₁₂ :=
  e₁₂.toEquiv.comp_symm_eq f g
#align linear_equiv.comp_symm_eq LinearEquiv.comp_symm_eq

/- warning: linear_equiv.eq_symm_comp -> LinearEquiv.eq_symm_comp is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {M₁ : Type.{u3}} {M₂ : Type.{u4}} [_inst_3 : Semiring.{u1} R₁] [_inst_4 : Semiring.{u2} R₂] [_inst_7 : AddCommMonoid.{u3} M₁] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M₁ : Module.{u1, u3} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u2, u4} R₂ M₂ _inst_4 _inst_8} {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₂₁ : RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)} {re₁₂ : RingHomInvPair.{u1, u2} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁} {re₂₁ : RingHomInvPair.{u2, u1} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂} {e₁₂ : LinearEquiv.{u1, u2, u3, u4} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂} {α : Type.{u5}} (f : α -> M₁) (g : α -> M₂), Iff (Eq.{max (succ u5) (succ u3)} (α -> M₁) f (Function.comp.{succ u5, succ u4, succ u3} α M₂ M₁ (coeFn.{max (succ u4) (succ u3), max (succ u4) (succ u3)} (LinearEquiv.{u2, u1, u4, u3} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) (fun (_x : LinearEquiv.{u2, u1, u4, u3} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) => M₂ -> M₁) (LinearEquiv.hasCoeToFun.{u2, u1, u4, u3} R₂ R₁ M₂ M₁ _inst_4 _inst_3 _inst_8 _inst_7 module_M₂ module_M₁ σ₂₁ σ₁₂ re₂₁ re₁₂) (LinearEquiv.symm.{u1, u2, u3, u4} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁ e₁₂)) g)) (Eq.{max (succ u5) (succ u4)} (α -> M₂) (Function.comp.{succ u5, succ u3, succ u4} α M₁ M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) => M₁ -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁) e₁₂) f) g)
but is expected to have type
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {M₁ : Type.{u4}} {M₂ : Type.{u3}} [_inst_3 : Semiring.{u1} R₁] [_inst_4 : Semiring.{u2} R₂] [_inst_7 : AddCommMonoid.{u4} M₁] [_inst_8 : AddCommMonoid.{u3} M₂] {module_M₁ : Module.{u1, u4} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u2, u3} R₂ M₂ _inst_4 _inst_8} {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₂₁ : RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)} {re₁₂ : RingHomInvPair.{u1, u2} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁} {re₂₁ : RingHomInvPair.{u2, u1} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂} {e₁₂ : LinearEquiv.{u1, u2, u4, u3} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂} {α : Type.{u5}} (f : α -> M₁) (g : α -> M₂), Iff (Eq.{max (succ u4) (succ u5)} (α -> M₁) f (Function.comp.{succ u5, succ u3, succ u4} α M₂ M₁ (FunLike.coe.{max (succ u4) (succ u3), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) M₂ (fun (_x : M₂) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M₂) => M₁) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u3), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) M₂ M₁ (EquivLike.toEmbeddingLike.{max (succ u4) (succ u3), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) M₂ M₁ (AddEquivClass.toEquivLike.{max u4 u3, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) M₂ M₁ (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (AddZeroClass.toAdd.{u4} M₁ (AddMonoid.toAddZeroClass.{u4} M₁ (AddCommMonoid.toAddMonoid.{u4} M₁ _inst_7))) (SemilinearEquivClass.toAddEquivClass.{max u4 u3, u2, u1, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u3, u4} R₂ R₁ M₂ M₁ _inst_4 _inst_3 _inst_8 _inst_7 module_M₂ module_M₁ σ₂₁ σ₁₂ re₂₁ re₁₂))))) (LinearEquiv.symm.{u1, u2, u4, u3} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁ e₁₂)) g)) (Eq.{max (succ u3) (succ u5)} (α -> M₂) (Function.comp.{succ u5, succ u4, succ u3} α M₁ M₂ (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u1, u2, u4, u3} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) M₁ (fun (_x : M₁) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M₁) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u1, u2, u4, u3} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) M₁ M₂ (EquivLike.toEmbeddingLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u1, u2, u4, u3} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) M₁ M₂ (AddEquivClass.toEquivLike.{max u4 u3, u4, u3} (LinearEquiv.{u1, u2, u4, u3} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) M₁ M₂ (AddZeroClass.toAdd.{u4} M₁ (AddMonoid.toAddZeroClass.{u4} M₁ (AddCommMonoid.toAddMonoid.{u4} M₁ _inst_7))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u4 u3, u1, u2, u4, u3} (LinearEquiv.{u1, u2, u4, u3} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u2, u4, u3} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁))))) e₁₂) f) g)
Case conversion may be inaccurate. Consider using '#align linear_equiv.eq_symm_comp LinearEquiv.eq_symm_compₓ'. -/
theorem eq_symm_comp {α : Type _} (f : α → M₁) (g : α → M₂) : f = e₁₂.symm ∘ g ↔ e₁₂ ∘ f = g :=
  e₁₂.toEquiv.eq_symm_comp f g
#align linear_equiv.eq_symm_comp LinearEquiv.eq_symm_comp

/- warning: linear_equiv.symm_comp_eq -> LinearEquiv.symm_comp_eq is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {M₁ : Type.{u3}} {M₂ : Type.{u4}} [_inst_3 : Semiring.{u1} R₁] [_inst_4 : Semiring.{u2} R₂] [_inst_7 : AddCommMonoid.{u3} M₁] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M₁ : Module.{u1, u3} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u2, u4} R₂ M₂ _inst_4 _inst_8} {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₂₁ : RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)} {re₁₂ : RingHomInvPair.{u1, u2} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁} {re₂₁ : RingHomInvPair.{u2, u1} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂} {e₁₂ : LinearEquiv.{u1, u2, u3, u4} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂} {α : Type.{u5}} (f : α -> M₁) (g : α -> M₂), Iff (Eq.{max (succ u5) (succ u3)} (α -> M₁) (Function.comp.{succ u5, succ u4, succ u3} α M₂ M₁ (coeFn.{max (succ u4) (succ u3), max (succ u4) (succ u3)} (LinearEquiv.{u2, u1, u4, u3} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) (fun (_x : LinearEquiv.{u2, u1, u4, u3} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) => M₂ -> M₁) (LinearEquiv.hasCoeToFun.{u2, u1, u4, u3} R₂ R₁ M₂ M₁ _inst_4 _inst_3 _inst_8 _inst_7 module_M₂ module_M₁ σ₂₁ σ₁₂ re₂₁ re₁₂) (LinearEquiv.symm.{u1, u2, u3, u4} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁ e₁₂)) g) f) (Eq.{max (succ u5) (succ u4)} (α -> M₂) g (Function.comp.{succ u5, succ u3, succ u4} α M₁ M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) => M₁ -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁) e₁₂) f))
but is expected to have type
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {M₁ : Type.{u4}} {M₂ : Type.{u3}} [_inst_3 : Semiring.{u1} R₁] [_inst_4 : Semiring.{u2} R₂] [_inst_7 : AddCommMonoid.{u4} M₁] [_inst_8 : AddCommMonoid.{u3} M₂] {module_M₁ : Module.{u1, u4} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u2, u3} R₂ M₂ _inst_4 _inst_8} {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₂₁ : RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)} {re₁₂ : RingHomInvPair.{u1, u2} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁} {re₂₁ : RingHomInvPair.{u2, u1} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂} {e₁₂ : LinearEquiv.{u1, u2, u4, u3} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂} {α : Type.{u5}} (f : α -> M₁) (g : α -> M₂), Iff (Eq.{max (succ u4) (succ u5)} (α -> M₁) (Function.comp.{succ u5, succ u3, succ u4} α M₂ M₁ (FunLike.coe.{max (succ u4) (succ u3), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) M₂ (fun (_x : M₂) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M₂) => M₁) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u3), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) M₂ M₁ (EquivLike.toEmbeddingLike.{max (succ u4) (succ u3), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) M₂ M₁ (AddEquivClass.toEquivLike.{max u4 u3, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) M₂ M₁ (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (AddZeroClass.toAdd.{u4} M₁ (AddMonoid.toAddZeroClass.{u4} M₁ (AddCommMonoid.toAddMonoid.{u4} M₁ _inst_7))) (SemilinearEquivClass.toAddEquivClass.{max u4 u3, u2, u1, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁) R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u3, u4} R₂ R₁ M₂ M₁ _inst_4 _inst_3 _inst_8 _inst_7 module_M₂ module_M₁ σ₂₁ σ₁₂ re₂₁ re₁₂))))) (LinearEquiv.symm.{u1, u2, u4, u3} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁ e₁₂)) g) f) (Eq.{max (succ u3) (succ u5)} (α -> M₂) g (Function.comp.{succ u5, succ u4, succ u3} α M₁ M₂ (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u1, u2, u4, u3} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) M₁ (fun (_x : M₁) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M₁) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u1, u2, u4, u3} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) M₁ M₂ (EquivLike.toEmbeddingLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u1, u2, u4, u3} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) M₁ M₂ (AddEquivClass.toEquivLike.{max u4 u3, u4, u3} (LinearEquiv.{u1, u2, u4, u3} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) M₁ M₂ (AddZeroClass.toAdd.{u4} M₁ (AddMonoid.toAddZeroClass.{u4} M₁ (AddCommMonoid.toAddMonoid.{u4} M₁ _inst_7))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u4 u3, u1, u2, u4, u3} (LinearEquiv.{u1, u2, u4, u3} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂) R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u2, u4, u3} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁))))) e₁₂) f))
Case conversion may be inaccurate. Consider using '#align linear_equiv.symm_comp_eq LinearEquiv.symm_comp_eqₓ'. -/
theorem symm_comp_eq {α : Type _} (f : α → M₁) (g : α → M₂) : e₁₂.symm ∘ g = f ↔ g = e₁₂ ∘ f :=
  e₁₂.toEquiv.symm_comp_eq f g
#align linear_equiv.symm_comp_eq LinearEquiv.symm_comp_eq

variable [RingHomCompTriple σ₂₁ σ₁₃ σ₂₃] [RingHomCompTriple σ₃₁ σ₁₂ σ₃₂]

include module_M₃

/- warning: linear_equiv.eq_comp_to_linear_map_symm -> LinearEquiv.eq_comp_toLinearMap_symm is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {R₃ : Type.{u3}} {M₁ : Type.{u4}} {M₂ : Type.{u5}} {M₃ : Type.{u6}} [_inst_3 : Semiring.{u1} R₁] [_inst_4 : Semiring.{u2} R₂] [_inst_5 : Semiring.{u3} R₃] [_inst_7 : AddCommMonoid.{u4} M₁] [_inst_8 : AddCommMonoid.{u5} M₂] [_inst_9 : AddCommMonoid.{u6} M₃] {module_M₁ : Module.{u1, u4} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u2, u5} R₂ M₂ _inst_4 _inst_8} {module_M₃ : Module.{u3, u6} R₃ M₃ _inst_5 _inst_9} {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₂₃ : RingHom.{u2, u3} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5)} {σ₁₃ : RingHom.{u1, u3} R₁ R₃ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5)} {σ₂₁ : RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)} [_inst_13 : RingHomCompTriple.{u1, u2, u3} R₁ R₂ R₃ _inst_3 _inst_4 _inst_5 σ₁₂ σ₂₃ σ₁₃] {re₁₂ : RingHomInvPair.{u1, u2} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁} {re₂₁ : RingHomInvPair.{u2, u1} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂} {e₁₂ : LinearEquiv.{u1, u2, u4, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂} [_inst_17 : RingHomCompTriple.{u2, u1, u3} R₂ R₁ R₃ _inst_4 _inst_3 _inst_5 σ₂₁ σ₁₃ σ₂₃] (f : LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) (g : LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_3 _inst_5 σ₁₃ M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃), Iff (Eq.{max (succ u5) (succ u6)} (LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) f (LinearMap.comp.{u2, u1, u3, u5, u4, u6} R₂ R₁ R₃ M₂ M₁ M₃ _inst_4 _inst_3 _inst_5 _inst_8 _inst_7 _inst_9 module_M₂ module_M₁ module_M₃ σ₂₁ σ₁₃ σ₂₃ _inst_17 g (LinearEquiv.toLinearMap.{u2, u1, u5, u4} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁ (LinearEquiv.symm.{u1, u2, u4, u5} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁ e₁₂)))) (Eq.{max (succ u4) (succ u6)} (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_3 _inst_5 σ₁₃ M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃) (LinearMap.comp.{u1, u2, u3, u4, u5, u6} R₁ R₂ R₃ M₁ M₂ M₃ _inst_3 _inst_4 _inst_5 _inst_7 _inst_8 _inst_9 module_M₁ module_M₂ module_M₃ σ₁₂ σ₂₃ σ₁₃ _inst_13 f (LinearEquiv.toLinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂ e₁₂)) g)
but is expected to have type
  forall {R₁ : Type.{u2}} {R₂ : Type.{u6}} {R₃ : Type.{u5}} {M₁ : Type.{u1}} {M₂ : Type.{u4}} {M₃ : Type.{u3}} [_inst_3 : Semiring.{u2} R₁] [_inst_4 : Semiring.{u6} R₂] [_inst_5 : Semiring.{u5} R₃] [_inst_7 : AddCommMonoid.{u1} M₁] [_inst_8 : AddCommMonoid.{u4} M₂] [_inst_9 : AddCommMonoid.{u3} M₃] {module_M₁ : Module.{u2, u1} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u6, u4} R₂ M₂ _inst_4 _inst_8} {module_M₃ : Module.{u5, u3} R₃ M₃ _inst_5 _inst_9} {σ₁₂ : RingHom.{u2, u6} R₁ R₂ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u6} R₂ _inst_4)} {σ₂₃ : RingHom.{u6, u5} R₂ R₃ (Semiring.toNonAssocSemiring.{u6} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u5} R₃ _inst_5)} {σ₁₃ : RingHom.{u2, u5} R₁ R₃ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u5} R₃ _inst_5)} {σ₂₁ : RingHom.{u6, u2} R₂ R₁ (Semiring.toNonAssocSemiring.{u6} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u2} R₁ _inst_3)} [_inst_13 : RingHomCompTriple.{u2, u6, u5} R₁ R₂ R₃ _inst_3 _inst_4 _inst_5 σ₁₂ σ₂₃ σ₁₃] {re₁₂ : RingHomInvPair.{u2, u6} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁} {re₂₁ : RingHomInvPair.{u6, u2} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂} {e₁₂ : LinearEquiv.{u2, u6, u1, u4} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂} [_inst_17 : RingHomCompTriple.{u6, u2, u5} R₂ R₁ R₃ _inst_4 _inst_3 _inst_5 σ₂₁ σ₁₃ σ₂₃] (f : LinearMap.{u6, u5, u4, u3} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) (g : LinearMap.{u2, u5, u1, u3} R₁ R₃ _inst_3 _inst_5 σ₁₃ M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃), Iff (Eq.{max (succ u4) (succ u3)} (LinearMap.{u6, u5, u4, u3} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) f (LinearMap.comp.{u6, u2, u5, u4, u1, u3} R₂ R₁ R₃ M₂ M₁ M₃ _inst_4 _inst_3 _inst_5 _inst_8 _inst_7 _inst_9 module_M₂ module_M₁ module_M₃ σ₂₁ σ₁₃ σ₂₃ _inst_17 g (LinearEquiv.toLinearMap.{u6, u2, u4, u1} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁ (LinearEquiv.symm.{u2, u6, u1, u4} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁ e₁₂)))) (Eq.{max (succ u1) (succ u3)} (LinearMap.{u2, u5, u1, u3} R₁ R₃ _inst_3 _inst_5 σ₁₃ M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃) (LinearMap.comp.{u2, u6, u5, u1, u4, u3} R₁ R₂ R₃ M₁ M₂ M₃ _inst_3 _inst_4 _inst_5 _inst_7 _inst_8 _inst_9 module_M₁ module_M₂ module_M₃ σ₁₂ σ₂₃ σ₁₃ _inst_13 f (LinearEquiv.toLinearMap.{u2, u6, u1, u4} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂ e₁₂)) g)
Case conversion may be inaccurate. Consider using '#align linear_equiv.eq_comp_to_linear_map_symm LinearEquiv.eq_comp_toLinearMap_symmₓ'. -/
theorem eq_comp_toLinearMap_symm (f : M₂ →ₛₗ[σ₂₃] M₃) (g : M₁ →ₛₗ[σ₁₃] M₃) :
    f = g.comp e₁₂.symm.toLinearMap ↔ f.comp e₁₂.toLinearMap = g :=
  by
  constructor <;> intro H <;> ext
  · simp [H, e₁₂.to_equiv.eq_comp_symm f g]
  · simp [← H, ← e₁₂.to_equiv.eq_comp_symm f g]
#align linear_equiv.eq_comp_to_linear_map_symm LinearEquiv.eq_comp_toLinearMap_symm

/- warning: linear_equiv.comp_to_linear_map_symm_eq -> LinearEquiv.comp_toLinearMap_symm_eq is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {R₃ : Type.{u3}} {M₁ : Type.{u4}} {M₂ : Type.{u5}} {M₃ : Type.{u6}} [_inst_3 : Semiring.{u1} R₁] [_inst_4 : Semiring.{u2} R₂] [_inst_5 : Semiring.{u3} R₃] [_inst_7 : AddCommMonoid.{u4} M₁] [_inst_8 : AddCommMonoid.{u5} M₂] [_inst_9 : AddCommMonoid.{u6} M₃] {module_M₁ : Module.{u1, u4} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u2, u5} R₂ M₂ _inst_4 _inst_8} {module_M₃ : Module.{u3, u6} R₃ M₃ _inst_5 _inst_9} {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₂₃ : RingHom.{u2, u3} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5)} {σ₁₃ : RingHom.{u1, u3} R₁ R₃ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5)} {σ₂₁ : RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)} [_inst_13 : RingHomCompTriple.{u1, u2, u3} R₁ R₂ R₃ _inst_3 _inst_4 _inst_5 σ₁₂ σ₂₃ σ₁₃] {re₁₂ : RingHomInvPair.{u1, u2} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁} {re₂₁ : RingHomInvPair.{u2, u1} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂} {e₁₂ : LinearEquiv.{u1, u2, u4, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂} [_inst_17 : RingHomCompTriple.{u2, u1, u3} R₂ R₁ R₃ _inst_4 _inst_3 _inst_5 σ₂₁ σ₁₃ σ₂₃] (f : LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) (g : LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_3 _inst_5 σ₁₃ M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃), Iff (Eq.{max (succ u5) (succ u6)} (LinearMap.{u2, u3, u5, u6} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) (LinearMap.comp.{u2, u1, u3, u5, u4, u6} R₂ R₁ R₃ M₂ M₁ M₃ _inst_4 _inst_3 _inst_5 _inst_8 _inst_7 _inst_9 module_M₂ module_M₁ module_M₃ σ₂₁ σ₁₃ σ₂₃ _inst_17 g (LinearEquiv.toLinearMap.{u2, u1, u5, u4} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁ (LinearEquiv.symm.{u1, u2, u4, u5} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁ e₁₂))) f) (Eq.{max (succ u4) (succ u6)} (LinearMap.{u1, u3, u4, u6} R₁ R₃ _inst_3 _inst_5 σ₁₃ M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃) g (LinearMap.comp.{u1, u2, u3, u4, u5, u6} R₁ R₂ R₃ M₁ M₂ M₃ _inst_3 _inst_4 _inst_5 _inst_7 _inst_8 _inst_9 module_M₁ module_M₂ module_M₃ σ₁₂ σ₂₃ σ₁₃ _inst_13 f (LinearEquiv.toLinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂ e₁₂)))
but is expected to have type
  forall {R₁ : Type.{u2}} {R₂ : Type.{u6}} {R₃ : Type.{u5}} {M₁ : Type.{u1}} {M₂ : Type.{u4}} {M₃ : Type.{u3}} [_inst_3 : Semiring.{u2} R₁] [_inst_4 : Semiring.{u6} R₂] [_inst_5 : Semiring.{u5} R₃] [_inst_7 : AddCommMonoid.{u1} M₁] [_inst_8 : AddCommMonoid.{u4} M₂] [_inst_9 : AddCommMonoid.{u3} M₃] {module_M₁ : Module.{u2, u1} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u6, u4} R₂ M₂ _inst_4 _inst_8} {module_M₃ : Module.{u5, u3} R₃ M₃ _inst_5 _inst_9} {σ₁₂ : RingHom.{u2, u6} R₁ R₂ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u6} R₂ _inst_4)} {σ₂₃ : RingHom.{u6, u5} R₂ R₃ (Semiring.toNonAssocSemiring.{u6} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u5} R₃ _inst_5)} {σ₁₃ : RingHom.{u2, u5} R₁ R₃ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u5} R₃ _inst_5)} {σ₂₁ : RingHom.{u6, u2} R₂ R₁ (Semiring.toNonAssocSemiring.{u6} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u2} R₁ _inst_3)} [_inst_13 : RingHomCompTriple.{u2, u6, u5} R₁ R₂ R₃ _inst_3 _inst_4 _inst_5 σ₁₂ σ₂₃ σ₁₃] {re₁₂ : RingHomInvPair.{u2, u6} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁} {re₂₁ : RingHomInvPair.{u6, u2} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂} {e₁₂ : LinearEquiv.{u2, u6, u1, u4} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂} [_inst_17 : RingHomCompTriple.{u6, u2, u5} R₂ R₁ R₃ _inst_4 _inst_3 _inst_5 σ₂₁ σ₁₃ σ₂₃] (f : LinearMap.{u6, u5, u4, u3} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) (g : LinearMap.{u2, u5, u1, u3} R₁ R₃ _inst_3 _inst_5 σ₁₃ M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃), Iff (Eq.{max (succ u4) (succ u3)} (LinearMap.{u6, u5, u4, u3} R₂ R₃ _inst_4 _inst_5 σ₂₃ M₂ M₃ _inst_8 _inst_9 module_M₂ module_M₃) (LinearMap.comp.{u6, u2, u5, u4, u1, u3} R₂ R₁ R₃ M₂ M₁ M₃ _inst_4 _inst_3 _inst_5 _inst_8 _inst_7 _inst_9 module_M₂ module_M₁ module_M₃ σ₂₁ σ₁₃ σ₂₃ _inst_17 g (LinearEquiv.toLinearMap.{u6, u2, u4, u1} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁ (LinearEquiv.symm.{u2, u6, u1, u4} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁ e₁₂))) f) (Eq.{max (succ u1) (succ u3)} (LinearMap.{u2, u5, u1, u3} R₁ R₃ _inst_3 _inst_5 σ₁₃ M₁ M₃ _inst_7 _inst_9 module_M₁ module_M₃) g (LinearMap.comp.{u2, u6, u5, u1, u4, u3} R₁ R₂ R₃ M₁ M₂ M₃ _inst_3 _inst_4 _inst_5 _inst_7 _inst_8 _inst_9 module_M₁ module_M₂ module_M₃ σ₁₂ σ₂₃ σ₁₃ _inst_13 f (LinearEquiv.toLinearMap.{u2, u6, u1, u4} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂ e₁₂)))
Case conversion may be inaccurate. Consider using '#align linear_equiv.comp_to_linear_map_symm_eq LinearEquiv.comp_toLinearMap_symm_eqₓ'. -/
theorem comp_toLinearMap_symm_eq (f : M₂ →ₛₗ[σ₂₃] M₃) (g : M₁ →ₛₗ[σ₁₃] M₃) :
    g.comp e₁₂.symm.toLinearMap = f ↔ g = f.comp e₁₂.toLinearMap :=
  by
  constructor <;> intro H <;> ext
  · simp [← H, ← e₁₂.to_equiv.comp_symm_eq f g]
  · simp [H, e₁₂.to_equiv.comp_symm_eq f g]
#align linear_equiv.comp_to_linear_map_symm_eq LinearEquiv.comp_toLinearMap_symm_eq

/- warning: linear_equiv.eq_to_linear_map_symm_comp -> LinearEquiv.eq_toLinearMap_symm_comp is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {R₃ : Type.{u3}} {M₁ : Type.{u4}} {M₂ : Type.{u5}} {M₃ : Type.{u6}} [_inst_3 : Semiring.{u1} R₁] [_inst_4 : Semiring.{u2} R₂] [_inst_5 : Semiring.{u3} R₃] [_inst_7 : AddCommMonoid.{u4} M₁] [_inst_8 : AddCommMonoid.{u5} M₂] [_inst_9 : AddCommMonoid.{u6} M₃] {module_M₁ : Module.{u1, u4} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u2, u5} R₂ M₂ _inst_4 _inst_8} {module_M₃ : Module.{u3, u6} R₃ M₃ _inst_5 _inst_9} {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₂₁ : RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)} {σ₃₂ : RingHom.{u3, u2} R₃ R₂ (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₃₁ : RingHom.{u3, u1} R₃ R₁ (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)} [_inst_14 : RingHomCompTriple.{u3, u2, u1} R₃ R₂ R₁ _inst_5 _inst_4 _inst_3 σ₃₂ σ₂₁ σ₃₁] {re₁₂ : RingHomInvPair.{u1, u2} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁} {re₂₁ : RingHomInvPair.{u2, u1} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂} {e₁₂ : LinearEquiv.{u1, u2, u4, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂} [_inst_18 : RingHomCompTriple.{u3, u1, u2} R₃ R₁ R₂ _inst_5 _inst_3 _inst_4 σ₃₁ σ₁₂ σ₃₂] (f : LinearMap.{u3, u1, u6, u4} R₃ R₁ _inst_5 _inst_3 σ₃₁ M₃ M₁ _inst_9 _inst_7 module_M₃ module_M₁) (g : LinearMap.{u3, u2, u6, u5} R₃ R₂ _inst_5 _inst_4 σ₃₂ M₃ M₂ _inst_9 _inst_8 module_M₃ module_M₂), Iff (Eq.{max (succ u6) (succ u4)} (LinearMap.{u3, u1, u6, u4} R₃ R₁ _inst_5 _inst_3 σ₃₁ M₃ M₁ _inst_9 _inst_7 module_M₃ module_M₁) f (LinearMap.comp.{u3, u2, u1, u6, u5, u4} R₃ R₂ R₁ M₃ M₂ M₁ _inst_5 _inst_4 _inst_3 _inst_9 _inst_8 _inst_7 module_M₃ module_M₂ module_M₁ σ₃₂ σ₂₁ σ₃₁ _inst_14 (LinearEquiv.toLinearMap.{u2, u1, u5, u4} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁ (LinearEquiv.symm.{u1, u2, u4, u5} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁ e₁₂)) g)) (Eq.{max (succ u6) (succ u5)} (LinearMap.{u3, u2, u6, u5} R₃ R₂ _inst_5 _inst_4 σ₃₂ M₃ M₂ _inst_9 _inst_8 module_M₃ module_M₂) (LinearMap.comp.{u3, u1, u2, u6, u4, u5} R₃ R₁ R₂ M₃ M₁ M₂ _inst_5 _inst_3 _inst_4 _inst_9 _inst_7 _inst_8 module_M₃ module_M₁ module_M₂ σ₃₁ σ₁₂ σ₃₂ _inst_18 (LinearEquiv.toLinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂ e₁₂) f) g)
but is expected to have type
  forall {R₁ : Type.{u5}} {R₂ : Type.{u2}} {R₃ : Type.{u6}} {M₁ : Type.{u3}} {M₂ : Type.{u1}} {M₃ : Type.{u4}} [_inst_3 : Semiring.{u5} R₁] [_inst_4 : Semiring.{u2} R₂] [_inst_5 : Semiring.{u6} R₃] [_inst_7 : AddCommMonoid.{u3} M₁] [_inst_8 : AddCommMonoid.{u1} M₂] [_inst_9 : AddCommMonoid.{u4} M₃] {module_M₁ : Module.{u5, u3} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u2, u1} R₂ M₂ _inst_4 _inst_8} {module_M₃ : Module.{u6, u4} R₃ M₃ _inst_5 _inst_9} {σ₁₂ : RingHom.{u5, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u5} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₂₁ : RingHom.{u2, u5} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u5} R₁ _inst_3)} {σ₃₂ : RingHom.{u6, u2} R₃ R₂ (Semiring.toNonAssocSemiring.{u6} R₃ _inst_5) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₃₁ : RingHom.{u6, u5} R₃ R₁ (Semiring.toNonAssocSemiring.{u6} R₃ _inst_5) (Semiring.toNonAssocSemiring.{u5} R₁ _inst_3)} [_inst_14 : RingHomCompTriple.{u6, u2, u5} R₃ R₂ R₁ _inst_5 _inst_4 _inst_3 σ₃₂ σ₂₁ σ₃₁] {re₁₂ : RingHomInvPair.{u5, u2} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁} {re₂₁ : RingHomInvPair.{u2, u5} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂} {e₁₂ : LinearEquiv.{u5, u2, u3, u1} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂} [_inst_18 : RingHomCompTriple.{u6, u5, u2} R₃ R₁ R₂ _inst_5 _inst_3 _inst_4 σ₃₁ σ₁₂ σ₃₂] (f : LinearMap.{u6, u5, u4, u3} R₃ R₁ _inst_5 _inst_3 σ₃₁ M₃ M₁ _inst_9 _inst_7 module_M₃ module_M₁) (g : LinearMap.{u6, u2, u4, u1} R₃ R₂ _inst_5 _inst_4 σ₃₂ M₃ M₂ _inst_9 _inst_8 module_M₃ module_M₂), Iff (Eq.{max (succ u3) (succ u4)} (LinearMap.{u6, u5, u4, u3} R₃ R₁ _inst_5 _inst_3 σ₃₁ M₃ M₁ _inst_9 _inst_7 module_M₃ module_M₁) f (LinearMap.comp.{u6, u2, u5, u4, u1, u3} R₃ R₂ R₁ M₃ M₂ M₁ _inst_5 _inst_4 _inst_3 _inst_9 _inst_8 _inst_7 module_M₃ module_M₂ module_M₁ σ₃₂ σ₂₁ σ₃₁ _inst_14 (LinearEquiv.toLinearMap.{u2, u5, u1, u3} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁ (LinearEquiv.symm.{u5, u2, u3, u1} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁ e₁₂)) g)) (Eq.{max (succ u1) (succ u4)} (LinearMap.{u6, u2, u4, u1} R₃ R₂ _inst_5 _inst_4 σ₃₂ M₃ M₂ _inst_9 _inst_8 module_M₃ module_M₂) (LinearMap.comp.{u6, u5, u2, u4, u3, u1} R₃ R₁ R₂ M₃ M₁ M₂ _inst_5 _inst_3 _inst_4 _inst_9 _inst_7 _inst_8 module_M₃ module_M₁ module_M₂ σ₃₁ σ₁₂ σ₃₂ _inst_18 (LinearEquiv.toLinearMap.{u5, u2, u3, u1} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂ e₁₂) f) g)
Case conversion may be inaccurate. Consider using '#align linear_equiv.eq_to_linear_map_symm_comp LinearEquiv.eq_toLinearMap_symm_compₓ'. -/
theorem eq_toLinearMap_symm_comp (f : M₃ →ₛₗ[σ₃₁] M₁) (g : M₃ →ₛₗ[σ₃₂] M₂) :
    f = e₁₂.symm.toLinearMap.comp g ↔ e₁₂.toLinearMap.comp f = g :=
  by
  constructor <;> intro H <;> ext
  · simp [H, e₁₂.to_equiv.eq_symm_comp f g]
  · simp [← H, ← e₁₂.to_equiv.eq_symm_comp f g]
#align linear_equiv.eq_to_linear_map_symm_comp LinearEquiv.eq_toLinearMap_symm_comp

/- warning: linear_equiv.to_linear_map_symm_comp_eq -> LinearEquiv.toLinearMap_symm_comp_eq is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {R₃ : Type.{u3}} {M₁ : Type.{u4}} {M₂ : Type.{u5}} {M₃ : Type.{u6}} [_inst_3 : Semiring.{u1} R₁] [_inst_4 : Semiring.{u2} R₂] [_inst_5 : Semiring.{u3} R₃] [_inst_7 : AddCommMonoid.{u4} M₁] [_inst_8 : AddCommMonoid.{u5} M₂] [_inst_9 : AddCommMonoid.{u6} M₃] {module_M₁ : Module.{u1, u4} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u2, u5} R₂ M₂ _inst_4 _inst_8} {module_M₃ : Module.{u3, u6} R₃ M₃ _inst_5 _inst_9} {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₂₁ : RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)} {σ₃₂ : RingHom.{u3, u2} R₃ R₂ (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₃₁ : RingHom.{u3, u1} R₃ R₁ (Semiring.toNonAssocSemiring.{u3} R₃ _inst_5) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)} [_inst_14 : RingHomCompTriple.{u3, u2, u1} R₃ R₂ R₁ _inst_5 _inst_4 _inst_3 σ₃₂ σ₂₁ σ₃₁] {re₁₂ : RingHomInvPair.{u1, u2} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁} {re₂₁ : RingHomInvPair.{u2, u1} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂} {e₁₂ : LinearEquiv.{u1, u2, u4, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂} [_inst_18 : RingHomCompTriple.{u3, u1, u2} R₃ R₁ R₂ _inst_5 _inst_3 _inst_4 σ₃₁ σ₁₂ σ₃₂] (f : LinearMap.{u3, u1, u6, u4} R₃ R₁ _inst_5 _inst_3 σ₃₁ M₃ M₁ _inst_9 _inst_7 module_M₃ module_M₁) (g : LinearMap.{u3, u2, u6, u5} R₃ R₂ _inst_5 _inst_4 σ₃₂ M₃ M₂ _inst_9 _inst_8 module_M₃ module_M₂), Iff (Eq.{max (succ u6) (succ u4)} (LinearMap.{u3, u1, u6, u4} R₃ R₁ _inst_5 _inst_3 σ₃₁ M₃ M₁ _inst_9 _inst_7 module_M₃ module_M₁) (LinearMap.comp.{u3, u2, u1, u6, u5, u4} R₃ R₂ R₁ M₃ M₂ M₁ _inst_5 _inst_4 _inst_3 _inst_9 _inst_8 _inst_7 module_M₃ module_M₂ module_M₁ σ₃₂ σ₂₁ σ₃₁ _inst_14 (LinearEquiv.toLinearMap.{u2, u1, u5, u4} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁ (LinearEquiv.symm.{u1, u2, u4, u5} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁ e₁₂)) g) f) (Eq.{max (succ u6) (succ u5)} (LinearMap.{u3, u2, u6, u5} R₃ R₂ _inst_5 _inst_4 σ₃₂ M₃ M₂ _inst_9 _inst_8 module_M₃ module_M₂) g (LinearMap.comp.{u3, u1, u2, u6, u4, u5} R₃ R₁ R₂ M₃ M₁ M₂ _inst_5 _inst_3 _inst_4 _inst_9 _inst_7 _inst_8 module_M₃ module_M₁ module_M₂ σ₃₁ σ₁₂ σ₃₂ _inst_18 (LinearEquiv.toLinearMap.{u1, u2, u4, u5} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂ e₁₂) f))
but is expected to have type
  forall {R₁ : Type.{u5}} {R₂ : Type.{u2}} {R₃ : Type.{u6}} {M₁ : Type.{u3}} {M₂ : Type.{u1}} {M₃ : Type.{u4}} [_inst_3 : Semiring.{u5} R₁] [_inst_4 : Semiring.{u2} R₂] [_inst_5 : Semiring.{u6} R₃] [_inst_7 : AddCommMonoid.{u3} M₁] [_inst_8 : AddCommMonoid.{u1} M₂] [_inst_9 : AddCommMonoid.{u4} M₃] {module_M₁ : Module.{u5, u3} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u2, u1} R₂ M₂ _inst_4 _inst_8} {module_M₃ : Module.{u6, u4} R₃ M₃ _inst_5 _inst_9} {σ₁₂ : RingHom.{u5, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u5} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₂₁ : RingHom.{u2, u5} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u5} R₁ _inst_3)} {σ₃₂ : RingHom.{u6, u2} R₃ R₂ (Semiring.toNonAssocSemiring.{u6} R₃ _inst_5) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₃₁ : RingHom.{u6, u5} R₃ R₁ (Semiring.toNonAssocSemiring.{u6} R₃ _inst_5) (Semiring.toNonAssocSemiring.{u5} R₁ _inst_3)} [_inst_14 : RingHomCompTriple.{u6, u2, u5} R₃ R₂ R₁ _inst_5 _inst_4 _inst_3 σ₃₂ σ₂₁ σ₃₁] {re₁₂ : RingHomInvPair.{u5, u2} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁} {re₂₁ : RingHomInvPair.{u2, u5} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂} {e₁₂ : LinearEquiv.{u5, u2, u3, u1} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂} [_inst_18 : RingHomCompTriple.{u6, u5, u2} R₃ R₁ R₂ _inst_5 _inst_3 _inst_4 σ₃₁ σ₁₂ σ₃₂] (f : LinearMap.{u6, u5, u4, u3} R₃ R₁ _inst_5 _inst_3 σ₃₁ M₃ M₁ _inst_9 _inst_7 module_M₃ module_M₁) (g : LinearMap.{u6, u2, u4, u1} R₃ R₂ _inst_5 _inst_4 σ₃₂ M₃ M₂ _inst_9 _inst_8 module_M₃ module_M₂), Iff (Eq.{max (succ u3) (succ u4)} (LinearMap.{u6, u5, u4, u3} R₃ R₁ _inst_5 _inst_3 σ₃₁ M₃ M₁ _inst_9 _inst_7 module_M₃ module_M₁) (LinearMap.comp.{u6, u2, u5, u4, u1, u3} R₃ R₂ R₁ M₃ M₂ M₁ _inst_5 _inst_4 _inst_3 _inst_9 _inst_8 _inst_7 module_M₃ module_M₂ module_M₁ σ₃₂ σ₂₁ σ₃₁ _inst_14 (LinearEquiv.toLinearMap.{u2, u5, u1, u3} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁ re₁₂ M₂ M₁ _inst_8 _inst_7 module_M₂ module_M₁ (LinearEquiv.symm.{u5, u2, u3, u1} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁ e₁₂)) g) f) (Eq.{max (succ u1) (succ u4)} (LinearMap.{u6, u2, u4, u1} R₃ R₂ _inst_5 _inst_4 σ₃₂ M₃ M₂ _inst_9 _inst_8 module_M₃ module_M₂) g (LinearMap.comp.{u6, u5, u2, u4, u3, u1} R₃ R₁ R₂ M₃ M₁ M₂ _inst_5 _inst_3 _inst_4 _inst_9 _inst_7 _inst_8 module_M₃ module_M₁ module_M₂ σ₃₁ σ₁₂ σ₃₂ _inst_18 (LinearEquiv.toLinearMap.{u5, u2, u3, u1} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂ e₁₂) f))
Case conversion may be inaccurate. Consider using '#align linear_equiv.to_linear_map_symm_comp_eq LinearEquiv.toLinearMap_symm_comp_eqₓ'. -/
theorem toLinearMap_symm_comp_eq (f : M₃ →ₛₗ[σ₃₁] M₁) (g : M₃ →ₛₗ[σ₃₂] M₂) :
    e₁₂.symm.toLinearMap.comp g = f ↔ g = e₁₂.toLinearMap.comp f :=
  by
  constructor <;> intro H <;> ext
  · simp [← H, ← e₁₂.to_equiv.symm_comp_eq f g]
  · simp [H, e₁₂.to_equiv.symm_comp_eq f g]
#align linear_equiv.to_linear_map_symm_comp_eq LinearEquiv.toLinearMap_symm_comp_eq

omit module_M₃

/- warning: linear_equiv.refl_symm -> LinearEquiv.refl_symm is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_6 : AddCommMonoid.{u2} M] [_inst_19 : Module.{u1, u2} R M _inst_1 _inst_6], Eq.{succ u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_19 _inst_19) (LinearEquiv.symm.{u1, u1, u2, u2} R R M M _inst_1 _inst_1 _inst_6 _inst_6 _inst_19 _inst_19 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (LinearEquiv.refl.{u1, u2} R M _inst_1 _inst_6 _inst_19)) (LinearEquiv.refl.{u1, u2} R M _inst_1 _inst_6 _inst_19)
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_6 : AddCommMonoid.{u1} M] [_inst_19 : Module.{u2, u1} R M _inst_1 _inst_6], Eq.{succ u1} (LinearEquiv.{u2, u2, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) M M _inst_6 _inst_6 _inst_19 _inst_19) (LinearEquiv.symm.{u2, u2, u1, u1} R R M M _inst_1 _inst_1 _inst_6 _inst_6 _inst_19 _inst_19 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (LinearEquiv.refl.{u2, u1} R M _inst_1 _inst_6 _inst_19)) (LinearEquiv.refl.{u2, u1} R M _inst_1 _inst_6 _inst_19)
Case conversion may be inaccurate. Consider using '#align linear_equiv.refl_symm LinearEquiv.refl_symmₓ'. -/
@[simp]
theorem refl_symm [Module R M] : (refl R M).symm = LinearEquiv.refl R M :=
  rfl
#align linear_equiv.refl_symm LinearEquiv.refl_symm

include re₁₂ re₂₁ module_M₁ module_M₂

/- warning: linear_equiv.self_trans_symm -> LinearEquiv.self_trans_symm is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {M₁ : Type.{u3}} {M₂ : Type.{u4}} [_inst_3 : Semiring.{u1} R₁] [_inst_4 : Semiring.{u2} R₂] [_inst_7 : AddCommMonoid.{u3} M₁] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M₁ : Module.{u1, u3} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u2, u4} R₂ M₂ _inst_4 _inst_8} {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₂₁ : RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)} {re₁₂ : RingHomInvPair.{u1, u2} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁} {re₂₁ : RingHomInvPair.{u2, u1} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂} (f : LinearEquiv.{u1, u2, u3, u4} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂), Eq.{succ u3} (LinearEquiv.{u1, u1, u3, u3} R₁ R₁ _inst_3 _inst_3 (RingHom.id.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)) (RingHom.id.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)) (RingHomInvPair.ids.{u1} R₁ _inst_3) (RingHomInvPair.ids.{u1} R₁ _inst_3) M₁ M₁ _inst_7 _inst_7 module_M₁ module_M₁) (LinearEquiv.trans.{u1, u2, u1, u3, u4, u3} R₁ R₂ R₁ M₁ M₂ M₁ _inst_3 _inst_4 _inst_3 _inst_7 _inst_8 _inst_7 module_M₁ module_M₂ module_M₁ σ₁₂ σ₂₁ (RingHom.id.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)) σ₂₁ σ₁₂ (RingHom.id.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)) (RingHomInvPair.triples₂.{u2, u1} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁) (RingHomInvPair.triples₂.{u2, u1} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁) re₁₂ re₂₁ (RingHomInvPair.ids.{u1} R₁ _inst_3) re₂₁ re₁₂ (RingHomInvPair.ids.{u1} R₁ _inst_3) f (LinearEquiv.symm.{u1, u2, u3, u4} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁ f)) (LinearEquiv.refl.{u1, u3} R₁ M₁ _inst_3 _inst_7 module_M₁)
but is expected to have type
  forall {R₁ : Type.{u4}} {R₂ : Type.{u3}} {M₁ : Type.{u2}} {M₂ : Type.{u1}} [_inst_3 : Semiring.{u4} R₁] [_inst_4 : Semiring.{u3} R₂] [_inst_7 : AddCommMonoid.{u2} M₁] [_inst_8 : AddCommMonoid.{u1} M₂] {module_M₁ : Module.{u4, u2} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u3, u1} R₂ M₂ _inst_4 _inst_8} {σ₁₂ : RingHom.{u4, u3} R₁ R₂ (Semiring.toNonAssocSemiring.{u4} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u3} R₂ _inst_4)} {σ₂₁ : RingHom.{u3, u4} R₂ R₁ (Semiring.toNonAssocSemiring.{u3} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u4} R₁ _inst_3)} {re₁₂ : RingHomInvPair.{u4, u3} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁} {re₂₁ : RingHomInvPair.{u3, u4} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂} (f : LinearEquiv.{u4, u3, u2, u1} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂), Eq.{succ u2} (LinearEquiv.{u4, u4, u2, u2} R₁ R₁ _inst_3 _inst_3 (RingHom.id.{u4} R₁ (Semiring.toNonAssocSemiring.{u4} R₁ _inst_3)) (RingHom.id.{u4} R₁ (Semiring.toNonAssocSemiring.{u4} R₁ _inst_3)) (RingHomInvPair.ids.{u4} R₁ _inst_3) (RingHomInvPair.ids.{u4} R₁ _inst_3) M₁ M₁ _inst_7 _inst_7 module_M₁ module_M₁) (LinearEquiv.trans.{u4, u3, u4, u2, u1, u2} R₁ R₂ R₁ M₁ M₂ M₁ _inst_3 _inst_4 _inst_3 _inst_7 _inst_8 _inst_7 module_M₁ module_M₂ module_M₁ σ₁₂ σ₂₁ (RingHom.id.{u4} R₁ (Semiring.toNonAssocSemiring.{u4} R₁ _inst_3)) σ₂₁ σ₁₂ (RingHom.id.{u4} R₁ (Semiring.toNonAssocSemiring.{u4} R₁ _inst_3)) (RingHomInvPair.triples₂.{u3, u4} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁) (RingHomInvPair.triples₂.{u3, u4} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂ re₂₁) re₁₂ re₂₁ (RingHomInvPair.ids.{u4} R₁ _inst_3) re₂₁ re₁₂ (RingHomInvPair.ids.{u4} R₁ _inst_3) f (LinearEquiv.symm.{u4, u3, u2, u1} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁ f)) (LinearEquiv.refl.{u4, u2} R₁ M₁ _inst_3 _inst_7 module_M₁)
Case conversion may be inaccurate. Consider using '#align linear_equiv.self_trans_symm LinearEquiv.self_trans_symmₓ'. -/
@[simp]
theorem self_trans_symm (f : M₁ ≃ₛₗ[σ₁₂] M₂) : f.trans f.symm = LinearEquiv.refl R₁ M₁ :=
  by
  ext x
  simp
#align linear_equiv.self_trans_symm LinearEquiv.self_trans_symm

/- warning: linear_equiv.symm_trans_self -> LinearEquiv.symm_trans_self is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {M₁ : Type.{u3}} {M₂ : Type.{u4}} [_inst_3 : Semiring.{u1} R₁] [_inst_4 : Semiring.{u2} R₂] [_inst_7 : AddCommMonoid.{u3} M₁] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M₁ : Module.{u1, u3} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u2, u4} R₂ M₂ _inst_4 _inst_8} {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {σ₂₁ : RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)} {re₁₂ : RingHomInvPair.{u1, u2} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁} {re₂₁ : RingHomInvPair.{u2, u1} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂} (f : LinearEquiv.{u1, u2, u3, u4} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂), Eq.{succ u4} (LinearEquiv.{u2, u2, u4, u4} R₂ R₂ _inst_4 _inst_4 (RingHom.id.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)) (RingHom.id.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)) (RingHomInvPair.ids.{u2} R₂ _inst_4) (RingHomInvPair.ids.{u2} R₂ _inst_4) M₂ M₂ _inst_8 _inst_8 module_M₂ module_M₂) (LinearEquiv.trans.{u2, u1, u2, u4, u3, u4} R₂ R₁ R₂ M₂ M₁ M₂ _inst_4 _inst_3 _inst_4 _inst_8 _inst_7 _inst_8 module_M₂ module_M₁ module_M₂ σ₂₁ σ₁₂ (RingHom.id.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)) σ₁₂ σ₂₁ (RingHom.id.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)) (RingHomInvPair.triples₂.{u1, u2} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂) (RingHomInvPair.triples₂.{u1, u2} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂) re₂₁ re₁₂ (RingHomInvPair.ids.{u2} R₂ _inst_4) re₁₂ re₂₁ (RingHomInvPair.ids.{u2} R₂ _inst_4) (LinearEquiv.symm.{u1, u2, u3, u4} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁ f) f) (LinearEquiv.refl.{u2, u4} R₂ M₂ _inst_4 _inst_8 module_M₂)
but is expected to have type
  forall {R₁ : Type.{u4}} {R₂ : Type.{u3}} {M₁ : Type.{u2}} {M₂ : Type.{u1}} [_inst_3 : Semiring.{u4} R₁] [_inst_4 : Semiring.{u3} R₂] [_inst_7 : AddCommMonoid.{u2} M₁] [_inst_8 : AddCommMonoid.{u1} M₂] {module_M₁ : Module.{u4, u2} R₁ M₁ _inst_3 _inst_7} {module_M₂ : Module.{u3, u1} R₂ M₂ _inst_4 _inst_8} {σ₁₂ : RingHom.{u4, u3} R₁ R₂ (Semiring.toNonAssocSemiring.{u4} R₁ _inst_3) (Semiring.toNonAssocSemiring.{u3} R₂ _inst_4)} {σ₂₁ : RingHom.{u3, u4} R₂ R₁ (Semiring.toNonAssocSemiring.{u3} R₂ _inst_4) (Semiring.toNonAssocSemiring.{u4} R₁ _inst_3)} {re₁₂ : RingHomInvPair.{u4, u3} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁} {re₂₁ : RingHomInvPair.{u3, u4} R₂ R₁ _inst_4 _inst_3 σ₂₁ σ₁₂} (f : LinearEquiv.{u4, u3, u2, u1} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂ re₂₁ M₁ M₂ _inst_7 _inst_8 module_M₁ module_M₂), Eq.{succ u1} (LinearEquiv.{u3, u3, u1, u1} R₂ R₂ _inst_4 _inst_4 (RingHom.id.{u3} R₂ (Semiring.toNonAssocSemiring.{u3} R₂ _inst_4)) (RingHom.id.{u3} R₂ (Semiring.toNonAssocSemiring.{u3} R₂ _inst_4)) (RingHomInvPair.ids.{u3} R₂ _inst_4) (RingHomInvPair.ids.{u3} R₂ _inst_4) M₂ M₂ _inst_8 _inst_8 module_M₂ module_M₂) (LinearEquiv.trans.{u3, u4, u3, u1, u2, u1} R₂ R₁ R₂ M₂ M₁ M₂ _inst_4 _inst_3 _inst_4 _inst_8 _inst_7 _inst_8 module_M₂ module_M₁ module_M₂ σ₂₁ σ₁₂ (RingHom.id.{u3} R₂ (Semiring.toNonAssocSemiring.{u3} R₂ _inst_4)) σ₁₂ σ₂₁ (RingHom.id.{u3} R₂ (Semiring.toNonAssocSemiring.{u3} R₂ _inst_4)) (RingHomInvPair.triples₂.{u4, u3} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂) (RingHomInvPair.triples₂.{u4, u3} R₁ R₂ _inst_3 _inst_4 σ₁₂ σ₂₁ re₁₂) re₂₁ re₁₂ (RingHomInvPair.ids.{u3} R₂ _inst_4) re₁₂ re₂₁ (RingHomInvPair.ids.{u3} R₂ _inst_4) (LinearEquiv.symm.{u4, u3, u2, u1} R₁ R₂ M₁ M₂ _inst_3 _inst_4 _inst_7 _inst_8 module_M₁ module_M₂ σ₁₂ σ₂₁ re₁₂ re₂₁ f) f) (LinearEquiv.refl.{u3, u1} R₂ M₂ _inst_4 _inst_8 module_M₂)
Case conversion may be inaccurate. Consider using '#align linear_equiv.symm_trans_self LinearEquiv.symm_trans_selfₓ'. -/
@[simp]
theorem symm_trans_self (f : M₁ ≃ₛₗ[σ₁₂] M₂) : f.symm.trans f = LinearEquiv.refl R₂ M₂ :=
  by
  ext x
  simp
#align linear_equiv.symm_trans_self LinearEquiv.symm_trans_self

omit re₁₂ re₂₁ module_M₁ module_M₂

/- warning: linear_equiv.refl_to_linear_map -> LinearEquiv.refl_toLinearMap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_6 : AddCommMonoid.{u2} M] [_inst_19 : Module.{u1, u2} R M _inst_1 _inst_6], Eq.{succ u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_6 _inst_6 _inst_19 _inst_19) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_19 _inst_19) (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_6 _inst_6 _inst_19 _inst_19) (HasLiftT.mk.{succ u2, succ u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_19 _inst_19) (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_6 _inst_6 _inst_19 _inst_19) (CoeTCₓ.coe.{succ u2, succ u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_19 _inst_19) (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_6 _inst_6 _inst_19 _inst_19) (coeBase.{succ u2, succ u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_19 _inst_19) (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_6 _inst_6 _inst_19 _inst_19) (LinearEquiv.LinearMap.hasCoe.{u1, u1, u2, u2} R R M M _inst_1 _inst_1 _inst_6 _inst_6 _inst_19 _inst_19 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1))))) (LinearEquiv.refl.{u1, u2} R M _inst_1 _inst_6 _inst_19)) (LinearMap.id.{u1, u2} R M _inst_1 _inst_6 _inst_19)
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_6 : AddCommMonoid.{u1} M] [_inst_19 : Module.{u2, u1} R M _inst_1 _inst_6], Eq.{succ u1} (LinearMap.{u2, u2, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M M _inst_6 _inst_6 _inst_19 _inst_19) (LinearEquiv.toLinearMap.{u2, u2, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) M M _inst_6 _inst_6 _inst_19 _inst_19 (LinearEquiv.refl.{u2, u1} R M _inst_1 _inst_6 _inst_19)) (LinearMap.id.{u2, u1} R M _inst_1 _inst_6 _inst_19)
Case conversion may be inaccurate. Consider using '#align linear_equiv.refl_to_linear_map LinearEquiv.refl_toLinearMapₓ'. -/
@[simp, norm_cast]
theorem refl_toLinearMap [Module R M] : (LinearEquiv.refl R M : M →ₗ[R] M) = LinearMap.id :=
  rfl
#align linear_equiv.refl_to_linear_map LinearEquiv.refl_toLinearMap

/- warning: linear_equiv.comp_coe -> LinearEquiv.comp_coe is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_6 : AddCommMonoid.{u2} M] [_inst_8 : AddCommMonoid.{u3} M₂] [_inst_9 : AddCommMonoid.{u4} M₃] [_inst_19 : Module.{u1, u2} R M _inst_1 _inst_6] [_inst_20 : Module.{u1, u3} R M₂ _inst_1 _inst_8] [_inst_21 : Module.{u1, u4} R M₃ _inst_1 _inst_9] (f : LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_6 _inst_8 _inst_19 _inst_20) (f' : LinearEquiv.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M₃ _inst_8 _inst_9 _inst_20 _inst_21), Eq.{max (succ u2) (succ u4)} (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_6 _inst_9 _inst_19 _inst_21) (LinearMap.comp.{u1, u1, u1, u2, u3, u4} R R R M M₂ M₃ _inst_1 _inst_1 _inst_1 _inst_6 _inst_8 _inst_9 _inst_19 _inst_20 _inst_21 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.right_ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) ((fun (a : Sort.{max (succ u3) (succ u4)}) (b : Sort.{max (succ u3) (succ u4)}) [self : HasLiftT.{max (succ u3) (succ u4), max (succ u3) (succ u4)} a b] => self.0) (LinearEquiv.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M₃ _inst_8 _inst_9 _inst_20 _inst_21) (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_8 _inst_9 _inst_20 _inst_21) (HasLiftT.mk.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M₃ _inst_8 _inst_9 _inst_20 _inst_21) (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_8 _inst_9 _inst_20 _inst_21) (CoeTCₓ.coe.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M₃ _inst_8 _inst_9 _inst_20 _inst_21) (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_8 _inst_9 _inst_20 _inst_21) (coeBase.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M₃ _inst_8 _inst_9 _inst_20 _inst_21) (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_8 _inst_9 _inst_20 _inst_21) (LinearEquiv.LinearMap.hasCoe.{u1, u1, u3, u4} R R M₂ M₃ _inst_1 _inst_1 _inst_8 _inst_9 _inst_20 _inst_21 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1))))) f') ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u2) (succ u3)} a b] => self.0) (LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_6 _inst_8 _inst_19 _inst_20) (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_6 _inst_8 _inst_19 _inst_20) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_6 _inst_8 _inst_19 _inst_20) (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_6 _inst_8 _inst_19 _inst_20) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_6 _inst_8 _inst_19 _inst_20) (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_6 _inst_8 _inst_19 _inst_20) (coeBase.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_6 _inst_8 _inst_19 _inst_20) (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_6 _inst_8 _inst_19 _inst_20) (LinearEquiv.LinearMap.hasCoe.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_6 _inst_8 _inst_19 _inst_20 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1))))) f)) ((fun (a : Sort.{max (succ u2) (succ u4)}) (b : Sort.{max (succ u2) (succ u4)}) [self : HasLiftT.{max (succ u2) (succ u4), max (succ u2) (succ u4)} a b] => self.0) (LinearEquiv.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₃ _inst_6 _inst_9 _inst_19 _inst_21) (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_6 _inst_9 _inst_19 _inst_21) (HasLiftT.mk.{max (succ u2) (succ u4), max (succ u2) (succ u4)} (LinearEquiv.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₃ _inst_6 _inst_9 _inst_19 _inst_21) (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_6 _inst_9 _inst_19 _inst_21) (CoeTCₓ.coe.{max (succ u2) (succ u4), max (succ u2) (succ u4)} (LinearEquiv.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₃ _inst_6 _inst_9 _inst_19 _inst_21) (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_6 _inst_9 _inst_19 _inst_21) (coeBase.{max (succ u2) (succ u4), max (succ u2) (succ u4)} (LinearEquiv.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₃ _inst_6 _inst_9 _inst_19 _inst_21) (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_6 _inst_9 _inst_19 _inst_21) (LinearEquiv.LinearMap.hasCoe.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_6 _inst_9 _inst_19 _inst_21 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1))))) (LinearEquiv.trans.{u1, u1, u1, u2, u3, u4} R R R M M₂ M₃ _inst_1 _inst_1 _inst_1 _inst_6 _inst_8 _inst_9 _inst_19 _inst_20 _inst_21 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.right_ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomCompTriple.right_ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) f f'))
but is expected to have type
  forall {R : Type.{u4}} {M : Type.{u3}} {M₂ : Type.{u2}} {M₃ : Type.{u1}} [_inst_1 : Semiring.{u4} R] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u2} M₂] [_inst_9 : AddCommMonoid.{u1} M₃] [_inst_19 : Module.{u4, u3} R M _inst_1 _inst_6] [_inst_20 : Module.{u4, u2} R M₂ _inst_1 _inst_8] [_inst_21 : Module.{u4, u1} R M₃ _inst_1 _inst_9] (f : LinearEquiv.{u4, u4, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomInvPair.ids.{u4} R _inst_1) (RingHomInvPair.ids.{u4} R _inst_1) M M₂ _inst_6 _inst_8 _inst_19 _inst_20) (f' : LinearEquiv.{u4, u4, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomInvPair.ids.{u4} R _inst_1) (RingHomInvPair.ids.{u4} R _inst_1) M₂ M₃ _inst_8 _inst_9 _inst_20 _inst_21), Eq.{max (succ u3) (succ u1)} (LinearMap.{u4, u4, u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M M₃ _inst_6 _inst_9 _inst_19 _inst_21) (LinearMap.comp.{u4, u4, u4, u3, u2, u1} R R R M M₂ M₃ _inst_1 _inst_1 _inst_1 _inst_6 _inst_8 _inst_9 _inst_19 _inst_20 _inst_21 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomCompTriple.ids.{u4, u4} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (LinearEquiv.toLinearMap.{u4, u4, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomInvPair.ids.{u4} R _inst_1) (RingHomInvPair.ids.{u4} R _inst_1) M₂ M₃ _inst_8 _inst_9 _inst_20 _inst_21 f') (LinearEquiv.toLinearMap.{u4, u4, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomInvPair.ids.{u4} R _inst_1) (RingHomInvPair.ids.{u4} R _inst_1) M M₂ _inst_6 _inst_8 _inst_19 _inst_20 f)) (LinearEquiv.toLinearMap.{u4, u4, u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomInvPair.ids.{u4} R _inst_1) (RingHomInvPair.ids.{u4} R _inst_1) M M₃ _inst_6 _inst_9 _inst_19 _inst_21 (LinearEquiv.trans.{u4, u4, u4, u3, u2, u1} R R R M M₂ M₃ _inst_1 _inst_1 _inst_1 _inst_6 _inst_8 _inst_9 _inst_19 _inst_20 _inst_21 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomCompTriple.ids.{u4, u4} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (RingHomCompTriple.ids.{u4, u4} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (RingHomInvPair.ids.{u4} R _inst_1) (RingHomInvPair.ids.{u4} R _inst_1) (RingHomInvPair.ids.{u4} R _inst_1) (RingHomInvPair.ids.{u4} R _inst_1) (RingHomInvPair.ids.{u4} R _inst_1) (RingHomInvPair.ids.{u4} R _inst_1) f f'))
Case conversion may be inaccurate. Consider using '#align linear_equiv.comp_coe LinearEquiv.comp_coeₓ'. -/
@[simp, norm_cast]
theorem comp_coe [Module R M] [Module R M₂] [Module R M₃] (f : M ≃ₗ[R] M₂) (f' : M₂ ≃ₗ[R] M₃) :
    (f' : M₂ →ₗ[R] M₃).comp (f : M →ₗ[R] M₂) = (f.trans f' : M ≃ₗ[R] M₃) :=
  rfl
#align linear_equiv.comp_coe LinearEquiv.comp_coe

/- warning: linear_equiv.mk_coe -> LinearEquiv.mk_coe is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (h₁ : forall (x : M) (y : M), Eq.{succ u4} M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e (HAdd.hAdd.{u3, u3, u3} M M M (instHAdd.{u3} M (AddZeroClass.toHasAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6)))) x y)) (HAdd.hAdd.{u4, u4, u4} M₂ M₂ M₂ (instHAdd.{u4} M₂ (AddZeroClass.toHasAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8)))) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e x) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e y))) (h₂ : forall (r : R) (x : M), Eq.{succ u4} M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e (SMul.smul.{u1, u3} R M (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_6 module_M)))) r x)) (SMul.smul.{u2, u4} S M₂ (SMulZeroClass.toHasSmul.{u2, u4} S M₂ (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (SMulWithZero.toSmulZeroClass.{u2, u4} S M₂ (MulZeroClass.toHasZero.{u2} S (MulZeroOneClass.toMulZeroClass.{u2} S (MonoidWithZero.toMulZeroOneClass.{u2} S (Semiring.toMonoidWithZero.{u2} S _inst_2)))) (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (MulActionWithZero.toSMulWithZero.{u2, u4} S M₂ (Semiring.toMonoidWithZero.{u2} S _inst_2) (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (Module.toMulActionWithZero.{u2, u4} S M₂ _inst_2 _inst_8 module_S_M₂)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (fun (_x : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) σ r) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e x))) (f : M₂ -> M) (h₃ : Function.LeftInverse.{succ u3, succ u4} M M₂ f (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e)) (h₄ : Function.RightInverse.{succ u3, succ u4} M M₂ f (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e)), Eq.{max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (LinearEquiv.mk.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e) h₁ h₂ f h₃ h₄) e
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u4}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_6 : AddCommMonoid.{u4} M] [_inst_8 : AddCommMonoid.{u3} M₂] {module_M : Module.{u2, u4} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u1, u3} S M₂ _inst_2 _inst_8} {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} {σ' : RingHom.{u1, u2} S R (Semiring.toNonAssocSemiring.{u1} S _inst_2) (Semiring.toNonAssocSemiring.{u2} R _inst_1)} {re₁ : RingHomInvPair.{u2, u1} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u1, u2} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (h₁ : M₂ -> M) (h₂ : Function.LeftInverse.{succ u4, succ u3} M M₂ h₁ (AddHom.toFun.{u4, u3} M M₂ (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (LinearMap.toAddHom.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.toLinearMap.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ e)))) (f : Function.RightInverse.{succ u4, succ u3} M M₂ h₁ (AddHom.toFun.{u4, u3} M M₂ (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (LinearMap.toAddHom.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.toLinearMap.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ e)))), Eq.{max (succ u4) (succ u3)} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (LinearEquiv.mk.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.toLinearMap.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ e) h₁ h₂ f) e
Case conversion may be inaccurate. Consider using '#align linear_equiv.mk_coe LinearEquiv.mk_coeₓ'. -/
@[simp]
theorem mk_coe (h₁ h₂ f h₃ h₄) : (LinearEquiv.mk e h₁ h₂ f h₃ h₄ : M ≃ₛₗ[σ] M₂) = e :=
  ext fun _ => rfl
#align linear_equiv.mk_coe LinearEquiv.mk_coe

/- warning: linear_equiv.map_add -> LinearEquiv.map_add is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (a : M) (b : M), Eq.{succ u4} M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e (HAdd.hAdd.{u3, u3, u3} M M M (instHAdd.{u3} M (AddZeroClass.toHasAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6)))) a b)) (HAdd.hAdd.{u4, u4, u4} M₂ M₂ M₂ (instHAdd.{u4} M₂ (AddZeroClass.toHasAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8)))) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e a) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e b))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u2, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u1, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} {σ' : RingHom.{u1, u2} S R (Semiring.toNonAssocSemiring.{u1} S _inst_2) (Semiring.toNonAssocSemiring.{u2} R _inst_1)} {re₁ : RingHomInvPair.{u2, u1} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u1, u2} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (a : M) (b : M), Eq.{succ u4} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) (HAdd.hAdd.{u3, u3, u3} M M M (instHAdd.{u3} M (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6)))) a b)) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u3 u4, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u3 u4, u2, u1, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e (HAdd.hAdd.{u3, u3, u3} M M M (instHAdd.{u3} M (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6)))) a b)) (HAdd.hAdd.{u4, u4, u4} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) a) ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) b) ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) a) (instHAdd.{u4} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) a) (AddZeroClass.toAdd.{u4} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) a) (AddMonoid.toAddZeroClass.{u4} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) a) (AddCommMonoid.toAddMonoid.{u4} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) a) _inst_8)))) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u3 u4, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u3 u4, u2, u1, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e a) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u3 u4, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u3 u4, u2, u1, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e b))
Case conversion may be inaccurate. Consider using '#align linear_equiv.map_add LinearEquiv.map_addₓ'. -/
protected theorem map_add (a b : M) : e (a + b) = e a + e b :=
  map_add e a b
#align linear_equiv.map_add LinearEquiv.map_add

/- warning: linear_equiv.map_zero -> LinearEquiv.map_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂), Eq.{succ u4} M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e (OfNat.ofNat.{u3} M 0 (OfNat.mk.{u3} M 0 (Zero.zero.{u3} M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))))))) (OfNat.ofNat.{u4} M₂ 0 (OfNat.mk.{u4} M₂ 0 (Zero.zero.{u4} M₂ (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))))))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u2, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u1, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} {σ' : RingHom.{u1, u2} S R (Semiring.toNonAssocSemiring.{u1} S _inst_2) (Semiring.toNonAssocSemiring.{u2} R _inst_1)} {re₁ : RingHomInvPair.{u2, u1} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u1, u2} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂), Eq.{succ u4} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))))) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u3 u4, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u3 u4, u2, u1, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))))) (OfNat.ofNat.{u4} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))))) 0 (Zero.toOfNat0.{u4} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))))) (AddMonoid.toZero.{u4} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))))) (AddCommMonoid.toAddMonoid.{u4} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))))) _inst_8))))
Case conversion may be inaccurate. Consider using '#align linear_equiv.map_zero LinearEquiv.map_zeroₓ'. -/
protected theorem map_zero : e 0 = 0 :=
  map_zero e
#align linear_equiv.map_zero LinearEquiv.map_zero

/- warning: linear_equiv.map_smulₛₗ -> LinearEquiv.map_smulₛₗ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (c : R) (x : M), Eq.{succ u4} M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e (SMul.smul.{u1, u3} R M (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_6 module_M)))) c x)) (SMul.smul.{u2, u4} S M₂ (SMulZeroClass.toHasSmul.{u2, u4} S M₂ (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (SMulWithZero.toSmulZeroClass.{u2, u4} S M₂ (MulZeroClass.toHasZero.{u2} S (MulZeroOneClass.toMulZeroClass.{u2} S (MonoidWithZero.toMulZeroOneClass.{u2} S (Semiring.toMonoidWithZero.{u2} S _inst_2)))) (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (MulActionWithZero.toSMulWithZero.{u2, u4} S M₂ (Semiring.toMonoidWithZero.{u2} S _inst_2) (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (Module.toMulActionWithZero.{u2, u4} S M₂ _inst_2 _inst_8 module_S_M₂)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (fun (_x : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) σ c) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e x))
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u3} R] [_inst_2 : Semiring.{u1} S] [_inst_6 : AddCommMonoid.{u2} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u3, u2} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u1, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u3, u1} R S (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} {σ' : RingHom.{u1, u3} S R (Semiring.toNonAssocSemiring.{u1} S _inst_2) (Semiring.toNonAssocSemiring.{u3} R _inst_1)} {re₁ : RingHomInvPair.{u3, u1} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u1, u3} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u3, u1, u2, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (c : R) (x : M), Eq.{succ u4} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) (HSMul.hSMul.{u3, u2, u2} R M M (instHSMul.{u3, u2} R M (SMulZeroClass.toSMul.{u3, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6)) (SMulWithZero.toSMulZeroClass.{u3, u2} R M (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6)) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6)) (Module.toMulActionWithZero.{u3, u2} R M _inst_1 _inst_6 module_M))))) c x)) (FunLike.coe.{max (succ u2) (succ u4), succ u2, succ u4} (LinearEquiv.{u3, u1, u2, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u4), succ u2, succ u4} (LinearEquiv.{u3, u1, u2, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u2) (succ u4), succ u2, succ u4} (LinearEquiv.{u3, u1, u2, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u2 u4, u2, u4} (LinearEquiv.{u3, u1, u2, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u2 u4, u3, u1, u2, u4} (LinearEquiv.{u3, u1, u2, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u3, u1, u2, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e (HSMul.hSMul.{u3, u2, u2} R M M (instHSMul.{u3, u2} R M (SMulZeroClass.toSMul.{u3, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6)) (SMulWithZero.toSMulZeroClass.{u3, u2} R M (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6)) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6)) (Module.toMulActionWithZero.{u3, u2} R M _inst_1 _inst_6 module_M))))) c x)) (HSMul.hSMul.{u1, u4, u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (instHSMul.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (SMulZeroClass.toSMul.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (AddMonoid.toZero.{u4} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (AddCommMonoid.toAddMonoid.{u4} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) _inst_8)) (SMulWithZero.toSMulZeroClass.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (MonoidWithZero.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) (Semiring.toMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) _inst_2)) (AddMonoid.toZero.{u4} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (AddCommMonoid.toAddMonoid.{u4} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) _inst_8)) (MulActionWithZero.toSMulWithZero.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (Semiring.toMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) _inst_2) (AddMonoid.toZero.{u4} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (AddCommMonoid.toAddMonoid.{u4} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) _inst_8)) (Module.toMulActionWithZero.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) _inst_2 _inst_8 module_S_M₂))))) (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (RingHom.{u3, u1} R S (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) _x) (MulHomClass.toFunLike.{max u3 u1, u3, u1} (RingHom.{u3, u1} R S (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)) R S (NonUnitalNonAssocSemiring.toMul.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u3 u1, u3, u1} (RingHom.{u3, u1} R S (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u3 u1, u3, u1} (RingHom.{u3, u1} R S (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)) R S (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2) (RingHom.instRingHomClassRingHom.{u3, u1} R S (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2))))) σ c) (FunLike.coe.{max (succ u2) (succ u4), succ u2, succ u4} (LinearEquiv.{u3, u1, u2, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u4), succ u2, succ u4} (LinearEquiv.{u3, u1, u2, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u2) (succ u4), succ u2, succ u4} (LinearEquiv.{u3, u1, u2, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u2 u4, u2, u4} (LinearEquiv.{u3, u1, u2, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u2 u4, u3, u1, u2, u4} (LinearEquiv.{u3, u1, u2, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u3, u1, u2, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e x))
Case conversion may be inaccurate. Consider using '#align linear_equiv.map_smulₛₗ LinearEquiv.map_smulₛₗₓ'. -/
-- TODO: `simp` isn't picking up `map_smulₛₗ` for `linear_equiv`s without specifying `map_smulₛₗ f`
@[simp]
protected theorem map_smulₛₗ (c : R) (x : M) : e (c • x) = σ c • e x :=
  e.map_smul' c x
#align linear_equiv.map_smulₛₗ LinearEquiv.map_smulₛₗ

include module_N₁ module_N₂

/- warning: linear_equiv.map_smul -> LinearEquiv.map_smul is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {N₁ : Type.{u2}} {N₂ : Type.{u3}} [_inst_3 : Semiring.{u1} R₁] [_inst_11 : AddCommMonoid.{u2} N₁] [_inst_12 : AddCommMonoid.{u3} N₂] {module_N₁ : Module.{u1, u2} R₁ N₁ _inst_3 _inst_11} {module_N₂ : Module.{u1, u3} R₁ N₂ _inst_3 _inst_12} (e : LinearEquiv.{u1, u1, u2, u3} R₁ R₁ _inst_3 _inst_3 (RingHom.id.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)) (RingHom.id.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)) (RingHomInvPair.ids.{u1} R₁ _inst_3) (RingHomInvPair.ids.{u1} R₁ _inst_3) N₁ N₂ _inst_11 _inst_12 module_N₁ module_N₂) (c : R₁) (x : N₁), Eq.{succ u3} N₂ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearEquiv.{u1, u1, u2, u3} R₁ R₁ _inst_3 _inst_3 (RingHom.id.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)) (RingHom.id.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)) (RingHomInvPair.ids.{u1} R₁ _inst_3) (RingHomInvPair.ids.{u1} R₁ _inst_3) N₁ N₂ _inst_11 _inst_12 module_N₁ module_N₂) (fun (_x : LinearEquiv.{u1, u1, u2, u3} R₁ R₁ _inst_3 _inst_3 (RingHom.id.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)) (RingHom.id.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)) (RingHomInvPair.ids.{u1} R₁ _inst_3) (RingHomInvPair.ids.{u1} R₁ _inst_3) N₁ N₂ _inst_11 _inst_12 module_N₁ module_N₂) => N₁ -> N₂) (LinearEquiv.hasCoeToFun.{u1, u1, u2, u3} R₁ R₁ N₁ N₂ _inst_3 _inst_3 _inst_11 _inst_12 module_N₁ module_N₂ (RingHom.id.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)) (RingHom.id.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)) (RingHomInvPair.ids.{u1} R₁ _inst_3) (RingHomInvPair.ids.{u1} R₁ _inst_3)) e (SMul.smul.{u1, u2} R₁ N₁ (SMulZeroClass.toHasSmul.{u1, u2} R₁ N₁ (AddZeroClass.toHasZero.{u2} N₁ (AddMonoid.toAddZeroClass.{u2} N₁ (AddCommMonoid.toAddMonoid.{u2} N₁ _inst_11))) (SMulWithZero.toSmulZeroClass.{u1, u2} R₁ N₁ (MulZeroClass.toHasZero.{u1} R₁ (MulZeroOneClass.toMulZeroClass.{u1} R₁ (MonoidWithZero.toMulZeroOneClass.{u1} R₁ (Semiring.toMonoidWithZero.{u1} R₁ _inst_3)))) (AddZeroClass.toHasZero.{u2} N₁ (AddMonoid.toAddZeroClass.{u2} N₁ (AddCommMonoid.toAddMonoid.{u2} N₁ _inst_11))) (MulActionWithZero.toSMulWithZero.{u1, u2} R₁ N₁ (Semiring.toMonoidWithZero.{u1} R₁ _inst_3) (AddZeroClass.toHasZero.{u2} N₁ (AddMonoid.toAddZeroClass.{u2} N₁ (AddCommMonoid.toAddMonoid.{u2} N₁ _inst_11))) (Module.toMulActionWithZero.{u1, u2} R₁ N₁ _inst_3 _inst_11 module_N₁)))) c x)) (SMul.smul.{u1, u3} R₁ N₂ (SMulZeroClass.toHasSmul.{u1, u3} R₁ N₂ (AddZeroClass.toHasZero.{u3} N₂ (AddMonoid.toAddZeroClass.{u3} N₂ (AddCommMonoid.toAddMonoid.{u3} N₂ _inst_12))) (SMulWithZero.toSmulZeroClass.{u1, u3} R₁ N₂ (MulZeroClass.toHasZero.{u1} R₁ (MulZeroOneClass.toMulZeroClass.{u1} R₁ (MonoidWithZero.toMulZeroOneClass.{u1} R₁ (Semiring.toMonoidWithZero.{u1} R₁ _inst_3)))) (AddZeroClass.toHasZero.{u3} N₂ (AddMonoid.toAddZeroClass.{u3} N₂ (AddCommMonoid.toAddMonoid.{u3} N₂ _inst_12))) (MulActionWithZero.toSMulWithZero.{u1, u3} R₁ N₂ (Semiring.toMonoidWithZero.{u1} R₁ _inst_3) (AddZeroClass.toHasZero.{u3} N₂ (AddMonoid.toAddZeroClass.{u3} N₂ (AddCommMonoid.toAddMonoid.{u3} N₂ _inst_12))) (Module.toMulActionWithZero.{u1, u3} R₁ N₂ _inst_3 _inst_12 module_N₂)))) c (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearEquiv.{u1, u1, u2, u3} R₁ R₁ _inst_3 _inst_3 (RingHom.id.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)) (RingHom.id.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)) (RingHomInvPair.ids.{u1} R₁ _inst_3) (RingHomInvPair.ids.{u1} R₁ _inst_3) N₁ N₂ _inst_11 _inst_12 module_N₁ module_N₂) (fun (_x : LinearEquiv.{u1, u1, u2, u3} R₁ R₁ _inst_3 _inst_3 (RingHom.id.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)) (RingHom.id.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)) (RingHomInvPair.ids.{u1} R₁ _inst_3) (RingHomInvPair.ids.{u1} R₁ _inst_3) N₁ N₂ _inst_11 _inst_12 module_N₁ module_N₂) => N₁ -> N₂) (LinearEquiv.hasCoeToFun.{u1, u1, u2, u3} R₁ R₁ N₁ N₂ _inst_3 _inst_3 _inst_11 _inst_12 module_N₁ module_N₂ (RingHom.id.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)) (RingHom.id.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_3)) (RingHomInvPair.ids.{u1} R₁ _inst_3) (RingHomInvPair.ids.{u1} R₁ _inst_3)) e x))
but is expected to have type
  forall {R₁ : Type.{u3}} {N₁ : Type.{u2}} {N₂ : Type.{u1}} [_inst_3 : Semiring.{u3} R₁] [_inst_11 : AddCommMonoid.{u2} N₁] [_inst_12 : AddCommMonoid.{u1} N₂] {module_N₁ : Module.{u3, u2} R₁ N₁ _inst_3 _inst_11} {module_N₂ : Module.{u3, u1} R₁ N₂ _inst_3 _inst_12} (e : LinearEquiv.{u3, u3, u2, u1} R₁ R₁ _inst_3 _inst_3 (RingHom.id.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3)) (RingHom.id.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3)) (RingHomInvPair.ids.{u3} R₁ _inst_3) (RingHomInvPair.ids.{u3} R₁ _inst_3) N₁ N₂ _inst_11 _inst_12 module_N₁ module_N₂) (c : R₁) (x : N₁), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : N₁) => N₂) (HSMul.hSMul.{u3, u2, u2} R₁ N₁ N₁ (instHSMul.{u3, u2} R₁ N₁ (SMulZeroClass.toSMul.{u3, u2} R₁ N₁ (AddMonoid.toZero.{u2} N₁ (AddCommMonoid.toAddMonoid.{u2} N₁ _inst_11)) (SMulWithZero.toSMulZeroClass.{u3, u2} R₁ N₁ (MonoidWithZero.toZero.{u3} R₁ (Semiring.toMonoidWithZero.{u3} R₁ _inst_3)) (AddMonoid.toZero.{u2} N₁ (AddCommMonoid.toAddMonoid.{u2} N₁ _inst_11)) (MulActionWithZero.toSMulWithZero.{u3, u2} R₁ N₁ (Semiring.toMonoidWithZero.{u3} R₁ _inst_3) (AddMonoid.toZero.{u2} N₁ (AddCommMonoid.toAddMonoid.{u2} N₁ _inst_11)) (Module.toMulActionWithZero.{u3, u2} R₁ N₁ _inst_3 _inst_11 module_N₁))))) c x)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearEquiv.{u3, u3, u2, u1} R₁ R₁ _inst_3 _inst_3 (RingHom.id.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3)) (RingHom.id.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3)) (RingHomInvPair.ids.{u3} R₁ _inst_3) (RingHomInvPair.ids.{u3} R₁ _inst_3) N₁ N₂ _inst_11 _inst_12 module_N₁ module_N₂) N₁ (fun (_x : N₁) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : N₁) => N₂) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (LinearEquiv.{u3, u3, u2, u1} R₁ R₁ _inst_3 _inst_3 (RingHom.id.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3)) (RingHom.id.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3)) (RingHomInvPair.ids.{u3} R₁ _inst_3) (RingHomInvPair.ids.{u3} R₁ _inst_3) N₁ N₂ _inst_11 _inst_12 module_N₁ module_N₂) R₁ N₁ N₂ (SMulZeroClass.toSMul.{u3, u2} R₁ N₁ (AddMonoid.toZero.{u2} N₁ (AddCommMonoid.toAddMonoid.{u2} N₁ _inst_11)) (DistribSMul.toSMulZeroClass.{u3, u2} R₁ N₁ (AddMonoid.toAddZeroClass.{u2} N₁ (AddCommMonoid.toAddMonoid.{u2} N₁ _inst_11)) (DistribMulAction.toDistribSMul.{u3, u2} R₁ N₁ (MonoidWithZero.toMonoid.{u3} R₁ (Semiring.toMonoidWithZero.{u3} R₁ _inst_3)) (AddCommMonoid.toAddMonoid.{u2} N₁ _inst_11) (Module.toDistribMulAction.{u3, u2} R₁ N₁ _inst_3 _inst_11 module_N₁)))) (SMulZeroClass.toSMul.{u3, u1} R₁ N₂ (AddMonoid.toZero.{u1} N₂ (AddCommMonoid.toAddMonoid.{u1} N₂ _inst_12)) (DistribSMul.toSMulZeroClass.{u3, u1} R₁ N₂ (AddMonoid.toAddZeroClass.{u1} N₂ (AddCommMonoid.toAddMonoid.{u1} N₂ _inst_12)) (DistribMulAction.toDistribSMul.{u3, u1} R₁ N₂ (MonoidWithZero.toMonoid.{u3} R₁ (Semiring.toMonoidWithZero.{u3} R₁ _inst_3)) (AddCommMonoid.toAddMonoid.{u1} N₂ _inst_12) (Module.toDistribMulAction.{u3, u1} R₁ N₂ _inst_3 _inst_12 module_N₂)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (LinearEquiv.{u3, u3, u2, u1} R₁ R₁ _inst_3 _inst_3 (RingHom.id.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3)) (RingHom.id.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3)) (RingHomInvPair.ids.{u3} R₁ _inst_3) (RingHomInvPair.ids.{u3} R₁ _inst_3) N₁ N₂ _inst_11 _inst_12 module_N₁ module_N₂) R₁ N₁ N₂ (MonoidWithZero.toMonoid.{u3} R₁ (Semiring.toMonoidWithZero.{u3} R₁ _inst_3)) (AddCommMonoid.toAddMonoid.{u2} N₁ _inst_11) (AddCommMonoid.toAddMonoid.{u1} N₂ _inst_12) (Module.toDistribMulAction.{u3, u2} R₁ N₁ _inst_3 _inst_11 module_N₁) (Module.toDistribMulAction.{u3, u1} R₁ N₂ _inst_3 _inst_12 module_N₂) (SemilinearMapClass.distribMulActionHomClass.{u3, u2, u1, max u2 u1} R₁ N₁ N₂ (LinearEquiv.{u3, u3, u2, u1} R₁ R₁ _inst_3 _inst_3 (RingHom.id.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3)) (RingHom.id.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3)) (RingHomInvPair.ids.{u3} R₁ _inst_3) (RingHomInvPair.ids.{u3} R₁ _inst_3) N₁ N₂ _inst_11 _inst_12 module_N₁ module_N₂) _inst_3 _inst_11 _inst_12 module_N₁ module_N₂ (SemilinearEquivClass.instSemilinearMapClass.{u3, u3, u2, u1, max u2 u1} R₁ R₁ N₁ N₂ (LinearEquiv.{u3, u3, u2, u1} R₁ R₁ _inst_3 _inst_3 (RingHom.id.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3)) (RingHom.id.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3)) (RingHomInvPair.ids.{u3} R₁ _inst_3) (RingHomInvPair.ids.{u3} R₁ _inst_3) N₁ N₂ _inst_11 _inst_12 module_N₁ module_N₂) _inst_3 _inst_3 _inst_11 _inst_12 module_N₁ module_N₂ (RingHom.id.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3)) (RingHom.id.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3)) (RingHomInvPair.ids.{u3} R₁ _inst_3) (RingHomInvPair.ids.{u3} R₁ _inst_3) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u3, u3, u2, u1} R₁ R₁ N₁ N₂ _inst_3 _inst_3 _inst_11 _inst_12 module_N₁ module_N₂ (RingHom.id.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3)) (RingHom.id.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3)) (RingHomInvPair.ids.{u3} R₁ _inst_3) (RingHomInvPair.ids.{u3} R₁ _inst_3)))))) e (HSMul.hSMul.{u3, u2, u2} R₁ N₁ N₁ (instHSMul.{u3, u2} R₁ N₁ (SMulZeroClass.toSMul.{u3, u2} R₁ N₁ (AddMonoid.toZero.{u2} N₁ (AddCommMonoid.toAddMonoid.{u2} N₁ _inst_11)) (SMulWithZero.toSMulZeroClass.{u3, u2} R₁ N₁ (MonoidWithZero.toZero.{u3} R₁ (Semiring.toMonoidWithZero.{u3} R₁ _inst_3)) (AddMonoid.toZero.{u2} N₁ (AddCommMonoid.toAddMonoid.{u2} N₁ _inst_11)) (MulActionWithZero.toSMulWithZero.{u3, u2} R₁ N₁ (Semiring.toMonoidWithZero.{u3} R₁ _inst_3) (AddMonoid.toZero.{u2} N₁ (AddCommMonoid.toAddMonoid.{u2} N₁ _inst_11)) (Module.toMulActionWithZero.{u3, u2} R₁ N₁ _inst_3 _inst_11 module_N₁))))) c x)) (HSMul.hSMul.{u3, u1, u1} R₁ ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : N₁) => N₂) x) ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : N₁) => N₂) x) (instHSMul.{u3, u1} R₁ ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : N₁) => N₂) x) (SMulZeroClass.toSMul.{u3, u1} R₁ ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : N₁) => N₂) x) (AddMonoid.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : N₁) => N₂) x) (AddCommMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : N₁) => N₂) x) _inst_12)) (SMulWithZero.toSMulZeroClass.{u3, u1} R₁ ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : N₁) => N₂) x) (MonoidWithZero.toZero.{u3} R₁ (Semiring.toMonoidWithZero.{u3} R₁ _inst_3)) (AddMonoid.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : N₁) => N₂) x) (AddCommMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : N₁) => N₂) x) _inst_12)) (MulActionWithZero.toSMulWithZero.{u3, u1} R₁ ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : N₁) => N₂) x) (Semiring.toMonoidWithZero.{u3} R₁ _inst_3) (AddMonoid.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : N₁) => N₂) x) (AddCommMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : N₁) => N₂) x) _inst_12)) (Module.toMulActionWithZero.{u3, u1} R₁ ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : N₁) => N₂) x) _inst_3 _inst_12 module_N₂))))) c (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearEquiv.{u3, u3, u2, u1} R₁ R₁ _inst_3 _inst_3 (RingHom.id.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3)) (RingHom.id.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3)) (RingHomInvPair.ids.{u3} R₁ _inst_3) (RingHomInvPair.ids.{u3} R₁ _inst_3) N₁ N₂ _inst_11 _inst_12 module_N₁ module_N₂) N₁ (fun (_x : N₁) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : N₁) => N₂) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (LinearEquiv.{u3, u3, u2, u1} R₁ R₁ _inst_3 _inst_3 (RingHom.id.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3)) (RingHom.id.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3)) (RingHomInvPair.ids.{u3} R₁ _inst_3) (RingHomInvPair.ids.{u3} R₁ _inst_3) N₁ N₂ _inst_11 _inst_12 module_N₁ module_N₂) R₁ N₁ N₂ (SMulZeroClass.toSMul.{u3, u2} R₁ N₁ (AddMonoid.toZero.{u2} N₁ (AddCommMonoid.toAddMonoid.{u2} N₁ _inst_11)) (DistribSMul.toSMulZeroClass.{u3, u2} R₁ N₁ (AddMonoid.toAddZeroClass.{u2} N₁ (AddCommMonoid.toAddMonoid.{u2} N₁ _inst_11)) (DistribMulAction.toDistribSMul.{u3, u2} R₁ N₁ (MonoidWithZero.toMonoid.{u3} R₁ (Semiring.toMonoidWithZero.{u3} R₁ _inst_3)) (AddCommMonoid.toAddMonoid.{u2} N₁ _inst_11) (Module.toDistribMulAction.{u3, u2} R₁ N₁ _inst_3 _inst_11 module_N₁)))) (SMulZeroClass.toSMul.{u3, u1} R₁ N₂ (AddMonoid.toZero.{u1} N₂ (AddCommMonoid.toAddMonoid.{u1} N₂ _inst_12)) (DistribSMul.toSMulZeroClass.{u3, u1} R₁ N₂ (AddMonoid.toAddZeroClass.{u1} N₂ (AddCommMonoid.toAddMonoid.{u1} N₂ _inst_12)) (DistribMulAction.toDistribSMul.{u3, u1} R₁ N₂ (MonoidWithZero.toMonoid.{u3} R₁ (Semiring.toMonoidWithZero.{u3} R₁ _inst_3)) (AddCommMonoid.toAddMonoid.{u1} N₂ _inst_12) (Module.toDistribMulAction.{u3, u1} R₁ N₂ _inst_3 _inst_12 module_N₂)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (LinearEquiv.{u3, u3, u2, u1} R₁ R₁ _inst_3 _inst_3 (RingHom.id.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3)) (RingHom.id.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3)) (RingHomInvPair.ids.{u3} R₁ _inst_3) (RingHomInvPair.ids.{u3} R₁ _inst_3) N₁ N₂ _inst_11 _inst_12 module_N₁ module_N₂) R₁ N₁ N₂ (MonoidWithZero.toMonoid.{u3} R₁ (Semiring.toMonoidWithZero.{u3} R₁ _inst_3)) (AddCommMonoid.toAddMonoid.{u2} N₁ _inst_11) (AddCommMonoid.toAddMonoid.{u1} N₂ _inst_12) (Module.toDistribMulAction.{u3, u2} R₁ N₁ _inst_3 _inst_11 module_N₁) (Module.toDistribMulAction.{u3, u1} R₁ N₂ _inst_3 _inst_12 module_N₂) (SemilinearMapClass.distribMulActionHomClass.{u3, u2, u1, max u2 u1} R₁ N₁ N₂ (LinearEquiv.{u3, u3, u2, u1} R₁ R₁ _inst_3 _inst_3 (RingHom.id.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3)) (RingHom.id.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3)) (RingHomInvPair.ids.{u3} R₁ _inst_3) (RingHomInvPair.ids.{u3} R₁ _inst_3) N₁ N₂ _inst_11 _inst_12 module_N₁ module_N₂) _inst_3 _inst_11 _inst_12 module_N₁ module_N₂ (SemilinearEquivClass.instSemilinearMapClass.{u3, u3, u2, u1, max u2 u1} R₁ R₁ N₁ N₂ (LinearEquiv.{u3, u3, u2, u1} R₁ R₁ _inst_3 _inst_3 (RingHom.id.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3)) (RingHom.id.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3)) (RingHomInvPair.ids.{u3} R₁ _inst_3) (RingHomInvPair.ids.{u3} R₁ _inst_3) N₁ N₂ _inst_11 _inst_12 module_N₁ module_N₂) _inst_3 _inst_3 _inst_11 _inst_12 module_N₁ module_N₂ (RingHom.id.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3)) (RingHom.id.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3)) (RingHomInvPair.ids.{u3} R₁ _inst_3) (RingHomInvPair.ids.{u3} R₁ _inst_3) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u3, u3, u2, u1} R₁ R₁ N₁ N₂ _inst_3 _inst_3 _inst_11 _inst_12 module_N₁ module_N₂ (RingHom.id.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3)) (RingHom.id.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_3)) (RingHomInvPair.ids.{u3} R₁ _inst_3) (RingHomInvPair.ids.{u3} R₁ _inst_3)))))) e x))
Case conversion may be inaccurate. Consider using '#align linear_equiv.map_smul LinearEquiv.map_smulₓ'. -/
theorem map_smul (e : N₁ ≃ₗ[R₁] N₂) (c : R₁) (x : N₁) : e (c • x) = c • e x :=
  map_smulₛₗ e c x
#align linear_equiv.map_smul LinearEquiv.map_smul

omit module_N₁ module_N₂

/- warning: linear_equiv.map_eq_zero_iff -> LinearEquiv.map_eq_zero_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) {x : M}, Iff (Eq.{succ u4} M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e x) (OfNat.ofNat.{u4} M₂ 0 (OfNat.mk.{u4} M₂ 0 (Zero.zero.{u4} M₂ (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))))))) (Eq.{succ u3} M x (OfNat.ofNat.{u3} M 0 (OfNat.mk.{u3} M 0 (Zero.zero.{u3} M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6)))))))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u2, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u1, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} {σ' : RingHom.{u1, u2} S R (Semiring.toNonAssocSemiring.{u1} S _inst_2) (Semiring.toNonAssocSemiring.{u2} R _inst_1)} {re₁ : RingHomInvPair.{u2, u1} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u1, u2} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) {x : M}, Iff (Eq.{succ u4} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u3 u4, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u3 u4, u2, u1, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e x) (OfNat.ofNat.{u4} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) 0 (Zero.toOfNat0.{u4} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (AddMonoid.toZero.{u4} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (AddCommMonoid.toAddMonoid.{u4} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) _inst_8))))) (Eq.{succ u3} M x (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6)))))
Case conversion may be inaccurate. Consider using '#align linear_equiv.map_eq_zero_iff LinearEquiv.map_eq_zero_iffₓ'. -/
@[simp]
theorem map_eq_zero_iff {x : M} : e x = 0 ↔ x = 0 :=
  e.toAddEquiv.map_eq_zero_iff
#align linear_equiv.map_eq_zero_iff LinearEquiv.map_eq_zero_iff

/- warning: linear_equiv.map_ne_zero_iff -> LinearEquiv.map_ne_zero_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) {x : M}, Iff (Ne.{succ u4} M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e x) (OfNat.ofNat.{u4} M₂ 0 (OfNat.mk.{u4} M₂ 0 (Zero.zero.{u4} M₂ (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))))))) (Ne.{succ u3} M x (OfNat.ofNat.{u3} M 0 (OfNat.mk.{u3} M 0 (Zero.zero.{u3} M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6)))))))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u2, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u1, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} {σ' : RingHom.{u1, u2} S R (Semiring.toNonAssocSemiring.{u1} S _inst_2) (Semiring.toNonAssocSemiring.{u2} R _inst_1)} {re₁ : RingHomInvPair.{u2, u1} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u1, u2} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) {x : M}, Iff (Ne.{succ u4} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u3 u4, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u3 u4, u2, u1, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e x) (OfNat.ofNat.{u4} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) 0 (Zero.toOfNat0.{u4} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (AddMonoid.toZero.{u4} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (AddCommMonoid.toAddMonoid.{u4} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) _inst_8))))) (Ne.{succ u3} M x (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6)))))
Case conversion may be inaccurate. Consider using '#align linear_equiv.map_ne_zero_iff LinearEquiv.map_ne_zero_iffₓ'. -/
theorem map_ne_zero_iff {x : M} : e x ≠ 0 ↔ x ≠ 0 :=
  e.toAddEquiv.map_ne_zero_iff
#align linear_equiv.map_ne_zero_iff LinearEquiv.map_ne_zero_iff

include module_M module_S_M₂ re₁ re₂

/- warning: linear_equiv.symm_symm -> LinearEquiv.symm_symm is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂), Eq.{max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (LinearEquiv.symm.{u2, u1, u4, u3} S R M₂ M _inst_2 _inst_1 _inst_8 _inst_6 module_S_M₂ module_M σ' σ re₂ re₁ (LinearEquiv.symm.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂ e)) e
but is expected to have type
  forall {R : Type.{u4}} {S : Type.{u3}} {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_1 : Semiring.{u4} R] [_inst_2 : Semiring.{u3} S] [_inst_6 : AddCommMonoid.{u2} M] [_inst_8 : AddCommMonoid.{u1} M₂] {module_M : Module.{u4, u2} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u3, u1} S M₂ _inst_2 _inst_8} {σ : RingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)} {σ' : RingHom.{u3, u4} S R (Semiring.toNonAssocSemiring.{u3} S _inst_2) (Semiring.toNonAssocSemiring.{u4} R _inst_1)} {re₁ : RingHomInvPair.{u4, u3} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u3, u4} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂), Eq.{max (succ u2) (succ u1)} (LinearEquiv.{u4, u3, u2, u1} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (LinearEquiv.symm.{u3, u4, u1, u2} S R M₂ M _inst_2 _inst_1 _inst_8 _inst_6 module_S_M₂ module_M σ' σ re₂ re₁ (LinearEquiv.symm.{u4, u3, u2, u1} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂ e)) e
Case conversion may be inaccurate. Consider using '#align linear_equiv.symm_symm LinearEquiv.symm_symmₓ'. -/
@[simp]
theorem symm_symm (e : M ≃ₛₗ[σ] M₂) : e.symm.symm = e :=
  by
  cases e
  rfl
#align linear_equiv.symm_symm LinearEquiv.symm_symm

omit module_M module_S_M₂ re₁ re₂

/- warning: linear_equiv.symm_bijective -> LinearEquiv.symm_bijective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} [_inst_19 : Module.{u1, u3} R M _inst_1 _inst_6] [_inst_20 : Module.{u2, u4} S M₂ _inst_2 _inst_8] [_inst_21 : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ] [_inst_22 : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'], Function.Bijective.{max (succ u3) (succ u4), max (succ u4) (succ u3)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' _inst_22 _inst_21 M M₂ _inst_6 _inst_8 _inst_19 _inst_20) (LinearEquiv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ _inst_21 _inst_22 M₂ M _inst_8 _inst_6 _inst_20 _inst_19) (LinearEquiv.symm.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 _inst_19 _inst_20 σ σ' _inst_22 _inst_21)
but is expected to have type
  forall {R : Type.{u4}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u1}} [_inst_1 : Semiring.{u4} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u1} M₂] {σ : RingHom.{u4, u2} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u4} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u4} R _inst_1)} [_inst_19 : Module.{u4, u3} R M _inst_1 _inst_6] [_inst_20 : Module.{u2, u1} S M₂ _inst_2 _inst_8] [_inst_21 : RingHomInvPair.{u2, u4} S R _inst_2 _inst_1 σ' σ] [_inst_22 : RingHomInvPair.{u4, u2} R S _inst_1 _inst_2 σ σ'], Function.Bijective.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (LinearEquiv.{u4, u2, u3, u1} R S _inst_1 _inst_2 σ σ' _inst_22 _inst_21 M M₂ _inst_6 _inst_8 _inst_19 _inst_20) (LinearEquiv.{u2, u4, u1, u3} S R _inst_2 _inst_1 σ' σ _inst_21 _inst_22 M₂ M _inst_8 _inst_6 _inst_20 _inst_19) (LinearEquiv.symm.{u4, u2, u3, u1} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 _inst_19 _inst_20 σ σ' _inst_22 _inst_21)
Case conversion may be inaccurate. Consider using '#align linear_equiv.symm_bijective LinearEquiv.symm_bijectiveₓ'. -/
theorem symm_bijective [Module R M] [Module S M₂] [RingHomInvPair σ' σ] [RingHomInvPair σ σ'] :
    Function.Bijective (symm : (M ≃ₛₗ[σ] M₂) → M₂ ≃ₛₗ[σ'] M) :=
  Equiv.bijective
    ⟨(symm : (M ≃ₛₗ[σ] M₂) → M₂ ≃ₛₗ[σ'] M), (symm : (M₂ ≃ₛₗ[σ'] M) → M ≃ₛₗ[σ] M₂), symm_symm,
      symm_symm⟩
#align linear_equiv.symm_bijective LinearEquiv.symm_bijective

/- warning: linear_equiv.mk_coe' -> LinearEquiv.mk_coe' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (f : M₂ -> M) (h₁ : forall (x : M₂) (y : M₂), Eq.{succ u3} M (f (HAdd.hAdd.{u4, u4, u4} M₂ M₂ M₂ (instHAdd.{u4} M₂ (AddZeroClass.toHasAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8)))) x y)) (HAdd.hAdd.{u3, u3, u3} M M M (instHAdd.{u3} M (AddZeroClass.toHasAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6)))) (f x) (f y))) (h₂ : forall (r : S) (x : M₂), Eq.{succ u3} M (f (SMul.smul.{u2, u4} S M₂ (SMulZeroClass.toHasSmul.{u2, u4} S M₂ (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (SMulWithZero.toSmulZeroClass.{u2, u4} S M₂ (MulZeroClass.toHasZero.{u2} S (MulZeroOneClass.toMulZeroClass.{u2} S (MonoidWithZero.toMulZeroOneClass.{u2} S (Semiring.toMonoidWithZero.{u2} S _inst_2)))) (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (MulActionWithZero.toSMulWithZero.{u2, u4} S M₂ (Semiring.toMonoidWithZero.{u2} S _inst_2) (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (Module.toMulActionWithZero.{u2, u4} S M₂ _inst_2 _inst_8 module_S_M₂)))) r x)) (SMul.smul.{u1, u3} R M (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_6 module_M)))) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (fun (_x : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) => S -> R) (RingHom.hasCoeToFun.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) σ' r) (f x))) (h₃ : Function.LeftInverse.{succ u4, succ u3} M₂ M (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e) f) (h₄ : Function.RightInverse.{succ u4, succ u3} M₂ M (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e) f), Eq.{max (succ u4) (succ u3)} (LinearEquiv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) (LinearEquiv.mk.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M f h₁ h₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e) h₃ h₄) (LinearEquiv.symm.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂ e)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u4}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u4} M] [_inst_8 : AddCommMonoid.{u3} M₂] {module_M : Module.{u1, u4} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u3} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u1, u2, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (f : M₂ -> M) (h₁ : forall (x : M₂) (y : M₂), Eq.{succ u4} M (f (HAdd.hAdd.{u3, u3, u3} M₂ M₂ M₂ (instHAdd.{u3} M₂ (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8)))) x y)) (HAdd.hAdd.{u4, u4, u4} M M M (instHAdd.{u4} M (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6)))) (f x) (f y))) (h₂ : forall (r : S) (x : M₂), Eq.{succ u4} M (AddHom.toFun.{u3, u4} M₂ M (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (AddHom.mk.{u3, u4} M₂ M (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) f h₁) (HSMul.hSMul.{u2, u3, u3} S M₂ M₂ (instHSMul.{u2, u3} S M₂ (SMulZeroClass.toSMul.{u2, u3} S M₂ (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8)) (SMulWithZero.toSMulZeroClass.{u2, u3} S M₂ (MonoidWithZero.toZero.{u2} S (Semiring.toMonoidWithZero.{u2} S _inst_2)) (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8)) (MulActionWithZero.toSMulWithZero.{u2, u3} S M₂ (Semiring.toMonoidWithZero.{u2} S _inst_2) (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8)) (Module.toMulActionWithZero.{u2, u3} S M₂ _inst_2 _inst_8 module_S_M₂))))) r x)) (HSMul.hSMul.{u1, u4, u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : S) => R) r) M M (instHSMul.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : S) => R) r) M (SMulZeroClass.toSMul.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : S) => R) r) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6)) (SMulWithZero.toSMulZeroClass.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : S) => R) r) M (MonoidWithZero.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : S) => R) r) (Semiring.toMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : S) => R) r) _inst_1)) (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6)) (MulActionWithZero.toSMulWithZero.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : S) => R) r) M (Semiring.toMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : S) => R) r) _inst_1) (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6)) (Module.toMulActionWithZero.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : S) => R) r) M _inst_1 _inst_6 module_M))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) S (fun (_x : S) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : S) => R) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) S R (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) S R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (RingHom.instRingHomClassRingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) σ' r) (AddHom.toFun.{u3, u4} M₂ M (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (AddHom.mk.{u3, u4} M₂ M (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) f h₁) x))) (h₃ : Function.LeftInverse.{succ u3, succ u4} M₂ M (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u1, u2, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (e : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) e) (EmbeddingLike.toFunLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u1, u2, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u1, u2, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u4 u3, u4, u3} (LinearEquiv.{u1, u2, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u4 u3, u1, u2, u4, u3} (LinearEquiv.{u1, u2, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u2, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e) (AddHom.toFun.{u3, u4} M₂ M (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (LinearMap.toAddHom.{u2, u1, u3, u4} S R _inst_2 _inst_1 σ' M₂ M _inst_8 _inst_6 module_S_M₂ module_M (LinearMap.mk.{u2, u1, u3, u4} S R _inst_2 _inst_1 σ' M₂ M _inst_8 _inst_6 module_S_M₂ module_M (AddHom.mk.{u3, u4} M₂ M (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) f h₁) h₂)))) (h₄ : Function.RightInverse.{succ u3, succ u4} M₂ M (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u1, u2, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (e : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) e) (EmbeddingLike.toFunLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u1, u2, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u1, u2, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u4 u3, u4, u3} (LinearEquiv.{u1, u2, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u4 u3, u1, u2, u4, u3} (LinearEquiv.{u1, u2, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u2, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e) (AddHom.toFun.{u3, u4} M₂ M (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (LinearMap.toAddHom.{u2, u1, u3, u4} S R _inst_2 _inst_1 σ' M₂ M _inst_8 _inst_6 module_S_M₂ module_M (LinearMap.mk.{u2, u1, u3, u4} S R _inst_2 _inst_1 σ' M₂ M _inst_8 _inst_6 module_S_M₂ module_M (AddHom.mk.{u3, u4} M₂ M (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) f h₁) h₂)))), Eq.{max (succ u4) (succ u3)} (LinearEquiv.{u2, u1, u3, u4} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) (LinearEquiv.mk.{u2, u1, u3, u4} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M (LinearMap.mk.{u2, u1, u3, u4} S R _inst_2 _inst_1 σ' M₂ M _inst_8 _inst_6 module_S_M₂ module_M (AddHom.mk.{u3, u4} M₂ M (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) f h₁) h₂) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u1, u2, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (e : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) e) (EmbeddingLike.toFunLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u1, u2, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u1, u2, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u4 u3, u4, u3} (LinearEquiv.{u1, u2, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u4 u3, u1, u2, u4, u3} (LinearEquiv.{u1, u2, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u2, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e) h₃ h₄) (LinearEquiv.symm.{u1, u2, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂ e)
Case conversion may be inaccurate. Consider using '#align linear_equiv.mk_coe' LinearEquiv.mk_coe'ₓ'. -/
@[simp]
theorem mk_coe' (f h₁ h₂ h₃ h₄) : (LinearEquiv.mk f h₁ h₂ (⇑e) h₃ h₄ : M₂ ≃ₛₗ[σ'] M) = e.symm :=
  symm_bijective.Injective <| ext fun x => rfl
#align linear_equiv.mk_coe' LinearEquiv.mk_coe'

/- warning: linear_equiv.symm_mk -> LinearEquiv.symm_mk is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (f : M₂ -> M) (h₁ : forall (x : M) (y : M), Eq.{succ u4} M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e (HAdd.hAdd.{u3, u3, u3} M M M (instHAdd.{u3} M (AddZeroClass.toHasAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6)))) x y)) (HAdd.hAdd.{u4, u4, u4} M₂ M₂ M₂ (instHAdd.{u4} M₂ (AddZeroClass.toHasAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8)))) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e x) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e y))) (h₂ : forall (r : R) (x : M), Eq.{succ u4} M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e (SMul.smul.{u1, u3} R M (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_6 module_M)))) r x)) (SMul.smul.{u2, u4} S M₂ (SMulZeroClass.toHasSmul.{u2, u4} S M₂ (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (SMulWithZero.toSmulZeroClass.{u2, u4} S M₂ (MulZeroClass.toHasZero.{u2} S (MulZeroOneClass.toMulZeroClass.{u2} S (MonoidWithZero.toMulZeroOneClass.{u2} S (Semiring.toMonoidWithZero.{u2} S _inst_2)))) (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (MulActionWithZero.toSMulWithZero.{u2, u4} S M₂ (Semiring.toMonoidWithZero.{u2} S _inst_2) (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (Module.toMulActionWithZero.{u2, u4} S M₂ _inst_2 _inst_8 module_S_M₂)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (fun (_x : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) σ r) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e x))) (h₃ : Function.LeftInverse.{succ u3, succ u4} M M₂ f (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e)) (h₄ : Function.RightInverse.{succ u3, succ u4} M M₂ f (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e)), Eq.{max (succ u4) (succ u3)} (LinearEquiv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) (LinearEquiv.symm.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂ (LinearEquiv.mk.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e) h₁ h₂ f h₃ h₄)) (LinearEquiv.mk.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M f (LinearEquiv.map_add'.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M (LinearEquiv.symm.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂ (LinearEquiv.mk.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e) h₁ h₂ f h₃ h₄))) (LinearEquiv.map_smul'.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M (LinearEquiv.symm.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂ (LinearEquiv.mk.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e) h₁ h₂ f h₃ h₄))) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e) (LinearEquiv.left_inv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M (LinearEquiv.symm.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂ (LinearEquiv.mk.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e) h₁ h₂ f h₃ h₄))) (LinearEquiv.right_inv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M (LinearEquiv.symm.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂ (LinearEquiv.mk.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e) h₁ h₂ f h₃ h₄))))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u2, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u1, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} {σ' : RingHom.{u1, u2} S R (Semiring.toNonAssocSemiring.{u1} S _inst_2) (Semiring.toNonAssocSemiring.{u2} R _inst_1)} {re₁ : RingHomInvPair.{u2, u1} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u1, u2} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (f : M₂ -> M) (h₁ : forall (x : M) (y : M), Eq.{succ u4} M₂ (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u3 u4, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u3 u4, u2, u1, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e (HAdd.hAdd.{u3, u3, u3} M M M (instHAdd.{u3} M (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6)))) x y)) (HAdd.hAdd.{u4, u4, u4} M₂ M₂ M₂ (instHAdd.{u4} M₂ (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8)))) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u3 u4, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u3 u4, u2, u1, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e x) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u3 u4, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u3 u4, u2, u1, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e y))) (h₂ : forall (r : R) (x : M), Eq.{succ u4} M₂ (AddHom.toFun.{u3, u4} M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (AddHom.mk.{u3, u4} M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (a : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) a) (EmbeddingLike.toFunLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u3 u4, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u3 u4, u2, u1, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e) h₁) (HSMul.hSMul.{u2, u3, u3} R M M (instHSMul.{u2, u3} R M (SMulZeroClass.toSMul.{u2, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6)) (SMulWithZero.toSMulZeroClass.{u2, u3} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6)) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6)) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_6 module_M))))) r x)) (HSMul.hSMul.{u1, u4, u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) r) M₂ M₂ (instHSMul.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) r) M₂ (SMulZeroClass.toSMul.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) r) M₂ (AddMonoid.toZero.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8)) (SMulWithZero.toSMulZeroClass.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) r) M₂ (MonoidWithZero.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) r) (Semiring.toMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) r) _inst_2)) (AddMonoid.toZero.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8)) (MulActionWithZero.toSMulWithZero.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) r) M₂ (Semiring.toMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) r) _inst_2) (AddMonoid.toZero.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8)) (Module.toMulActionWithZero.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) r) M₂ _inst_2 _inst_8 module_S_M₂))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)) R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2) (RingHom.instRingHomClassRingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2))))) σ r) (AddHom.toFun.{u3, u4} M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (AddHom.mk.{u3, u4} M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (a : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) a) (EmbeddingLike.toFunLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u3 u4, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u3 u4, u2, u1, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e) h₁) x))) (h₃ : Function.LeftInverse.{succ u3, succ u4} M M₂ f (AddHom.toFun.{u3, u4} M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (LinearMap.toAddHom.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearMap.mk.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (AddHom.mk.{u3, u4} M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (a : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) a) (EmbeddingLike.toFunLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u3 u4, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u3 u4, u2, u1, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e) h₁) h₂)))) (h₄ : Function.RightInverse.{succ u3, succ u4} M M₂ f (AddHom.toFun.{u3, u4} M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (LinearMap.toAddHom.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearMap.mk.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (AddHom.mk.{u3, u4} M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (a : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) a) (EmbeddingLike.toFunLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u3 u4, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u3 u4, u2, u1, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e) h₁) h₂)))), Eq.{max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) (LinearEquiv.symm.{u2, u1, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂ (LinearEquiv.mk.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearMap.mk.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (AddHom.mk.{u3, u4} M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (a : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) a) (EmbeddingLike.toFunLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u3 u4, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u3 u4, u2, u1, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e) h₁) h₂) f h₃ h₄)) (let src._@.Mathlib.Algebra.Module.Equiv._hyg.19189 : LinearEquiv.{u1, u2, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M := LinearEquiv.symm.{u2, u1, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂ (LinearEquiv.mk.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearMap.mk.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (AddHom.mk.{u3, u4} M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (a : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) a) (EmbeddingLike.toFunLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u3 u4, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u3 u4, u2, u1, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e) h₁) h₂) f h₃ h₄); LinearEquiv.mk.{u1, u2, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M (LinearMap.mk.{u1, u2, u4, u3} S R _inst_2 _inst_1 σ' M₂ M _inst_8 _inst_6 module_S_M₂ module_M (AddHom.mk.{u4, u3} M₂ M (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) f (AddHom.map_add'.{u4, u3} M₂ M (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (LinearMap.toAddHom.{u1, u2, u4, u3} S R _inst_2 _inst_1 σ' M₂ M _inst_8 _inst_6 module_S_M₂ module_M (LinearEquiv.toLinearMap.{u1, u2, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M src._@.Mathlib.Algebra.Module.Equiv._hyg.19189)))) (LinearMap.map_smul'.{u1, u2, u4, u3} S R _inst_2 _inst_1 σ' M₂ M _inst_8 _inst_6 module_S_M₂ module_M (LinearEquiv.toLinearMap.{u1, u2, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M src._@.Mathlib.Algebra.Module.Equiv._hyg.19189))) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (a : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) a) (EmbeddingLike.toFunLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u3 u4, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u3 u4, u2, u1, u3, u4} (LinearEquiv.{u2, u1, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e) (LinearEquiv.left_inv.{u1, u2, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M src._@.Mathlib.Algebra.Module.Equiv._hyg.19189) (LinearEquiv.right_inv.{u1, u2, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M src._@.Mathlib.Algebra.Module.Equiv._hyg.19189))
Case conversion may be inaccurate. Consider using '#align linear_equiv.symm_mk LinearEquiv.symm_mkₓ'. -/
@[simp]
theorem symm_mk (f h₁ h₂ h₃ h₄) :
    (⟨e, h₁, h₂, f, h₃, h₄⟩ : M ≃ₛₗ[σ] M₂).symm =
      {
        (⟨e, h₁, h₂, f, h₃, h₄⟩ : M ≃ₛₗ[σ]
              M₂).symm with
        toFun := f
        invFun := e } :=
  rfl
#align linear_equiv.symm_mk LinearEquiv.symm_mk

/- warning: linear_equiv.coe_symm_mk -> LinearEquiv.coe_symm_mk is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_6 : AddCommMonoid.{u2} M] [_inst_8 : AddCommMonoid.{u3} M₂] [_inst_19 : Module.{u1, u2} R M _inst_1 _inst_6] [_inst_20 : Module.{u1, u3} R M₂ _inst_1 _inst_8] {to_fun : M -> M₂} {inv_fun : M₂ -> M} {map_add : forall (x : M) (y : M), Eq.{succ u3} M₂ (to_fun (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6)))) x y)) (HAdd.hAdd.{u3, u3, u3} M₂ M₂ M₂ (instHAdd.{u3} M₂ (AddZeroClass.toHasAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8)))) (to_fun x) (to_fun y))} {map_smul : forall (r : R) (x : M), Eq.{succ u3} M₂ (to_fun (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_6 _inst_19)))) r x)) (SMul.smul.{u1, u3} R M₂ (SMulZeroClass.toHasSmul.{u1, u3} R M₂ (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M₂ (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M₂ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (Module.toMulActionWithZero.{u1, u3} R M₂ _inst_1 _inst_8 _inst_20)))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (fun (_x : RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) => R -> R) (RingHom.hasCoeToFun.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) r) (to_fun x))} {left_inv : Function.LeftInverse.{succ u2, succ u3} M M₂ inv_fun to_fun} {right_inv : Function.RightInverse.{succ u2, succ u3} M M₂ inv_fun to_fun}, Eq.{max (succ u3) (succ u2)} (M₂ -> M) (coeFn.{max (succ u3) (succ u2), max (succ u3) (succ u2)} (LinearEquiv.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M _inst_8 _inst_6 _inst_20 _inst_19) (fun (_x : LinearEquiv.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M _inst_8 _inst_6 _inst_20 _inst_19) => M₂ -> M) (LinearEquiv.hasCoeToFun.{u1, u1, u3, u2} R R M₂ M _inst_1 _inst_1 _inst_8 _inst_6 _inst_20 _inst_19 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)) (LinearEquiv.symm.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_6 _inst_8 _inst_19 _inst_20 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (LinearEquiv.mk.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_6 _inst_8 _inst_19 _inst_20 to_fun map_add map_smul inv_fun left_inv right_inv))) inv_fun
but is expected to have type
  forall {R : Type.{u3}} {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_1 : Semiring.{u3} R] [_inst_6 : AddCommMonoid.{u2} M] [_inst_8 : AddCommMonoid.{u1} M₂] [_inst_19 : Module.{u3, u2} R M _inst_1 _inst_6] [_inst_20 : Module.{u3, u1} R M₂ _inst_1 _inst_8] {to_fun : M -> M₂} {inv_fun : M₂ -> M} {map_add : forall (x : M) (y : M), Eq.{succ u1} M₂ (to_fun (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6)))) x y)) (HAdd.hAdd.{u1, u1, u1} M₂ M₂ M₂ (instHAdd.{u1} M₂ (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_8)))) (to_fun x) (to_fun y))} {map_smul : forall (r : R) (x : M), Eq.{succ u1} M₂ (AddHom.toFun.{u2, u1} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_8))) (AddHom.mk.{u2, u1} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_8))) to_fun map_add) (HSMul.hSMul.{u3, u2, u2} R M M (instHSMul.{u3, u2} R M (SMulZeroClass.toSMul.{u3, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6)) (SMulWithZero.toSMulZeroClass.{u3, u2} R M (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6)) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6)) (Module.toMulActionWithZero.{u3, u2} R M _inst_1 _inst_6 _inst_19))))) r x)) (HSMul.hSMul.{u3, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => R) r) M₂ M₂ (instHSMul.{u3, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => R) r) M₂ (SMulZeroClass.toSMul.{u3, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => R) r) M₂ (AddMonoid.toZero.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_8)) (SMulWithZero.toSMulZeroClass.{u3, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => R) r) M₂ (MonoidWithZero.toZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => R) r) (Semiring.toMonoidWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => R) r) _inst_1)) (AddMonoid.toZero.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_8)) (MulActionWithZero.toSMulWithZero.{u3, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => R) r) M₂ (Semiring.toMonoidWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => R) r) _inst_1) (AddMonoid.toZero.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_8)) (Module.toMulActionWithZero.{u3, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => R) r) M₂ _inst_1 _inst_8 _inst_20))))) (FunLike.coe.{succ u3, succ u3, succ u3} (RingHom.{u3, u3} R R (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u3} R _inst_1)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => R) _x) (MulHomClass.toFunLike.{u3, u3, u3} (RingHom.{u3, u3} R R (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u3} R _inst_1)) R R (NonUnitalNonAssocSemiring.toMul.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (NonUnitalRingHomClass.toMulHomClass.{u3, u3, u3} (RingHom.{u3, u3} R R (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u3} R _inst_1)) R R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomClass.toNonUnitalRingHomClass.{u3, u3, u3} (RingHom.{u3, u3} R R (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u3} R _inst_1)) R R (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u3} R _inst_1) (RingHom.instRingHomClassRingHom.{u3, u3} R R (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) r) (AddHom.toFun.{u2, u1} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_8))) (AddHom.mk.{u2, u1} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_8))) to_fun map_add) x))} {left_inv : Function.LeftInverse.{succ u2, succ u1} M M₂ inv_fun (AddHom.toFun.{u2, u1} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_8))) (LinearMap.toAddHom.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M₂ _inst_6 _inst_8 _inst_19 _inst_20 (LinearMap.mk.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M₂ _inst_6 _inst_8 _inst_19 _inst_20 (AddHom.mk.{u2, u1} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_8))) to_fun map_add) map_smul)))} {right_inv : Function.RightInverse.{succ u2, succ u1} M M₂ inv_fun (AddHom.toFun.{u2, u1} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_8))) (LinearMap.toAddHom.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M₂ _inst_6 _inst_8 _inst_19 _inst_20 (LinearMap.mk.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M₂ _inst_6 _inst_8 _inst_19 _inst_20 (AddHom.mk.{u2, u1} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_8))) to_fun map_add) map_smul)))}, Eq.{max (succ u2) (succ u1)} (forall (ᾰ : M₂), (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M₂) => M) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (LinearEquiv.{u3, u3, u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) M₂ M _inst_8 _inst_6 _inst_20 _inst_19) M₂ (fun (_x : M₂) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M₂) => M) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u1, u2} (LinearEquiv.{u3, u3, u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) M₂ M _inst_8 _inst_6 _inst_20 _inst_19) R M₂ M (SMulZeroClass.toSMul.{u3, u1} R M₂ (AddMonoid.toZero.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_8)) (DistribSMul.toSMulZeroClass.{u3, u1} R M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_8)) (DistribMulAction.toDistribSMul.{u3, u1} R M₂ (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_8) (Module.toDistribMulAction.{u3, u1} R M₂ _inst_1 _inst_8 _inst_20)))) (SMulZeroClass.toSMul.{u3, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6)) (DistribSMul.toSMulZeroClass.{u3, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6)) (DistribMulAction.toDistribSMul.{u3, u2} R M (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_6) (Module.toDistribMulAction.{u3, u2} R M _inst_1 _inst_6 _inst_19)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u1, u2} (LinearEquiv.{u3, u3, u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) M₂ M _inst_8 _inst_6 _inst_20 _inst_19) R M₂ M (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_8) (AddCommMonoid.toAddMonoid.{u2} M _inst_6) (Module.toDistribMulAction.{u3, u1} R M₂ _inst_1 _inst_8 _inst_20) (Module.toDistribMulAction.{u3, u2} R M _inst_1 _inst_6 _inst_19) (SemilinearMapClass.distribMulActionHomClass.{u3, u1, u2, max u2 u1} R M₂ M (LinearEquiv.{u3, u3, u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) M₂ M _inst_8 _inst_6 _inst_20 _inst_19) _inst_1 _inst_8 _inst_6 _inst_20 _inst_19 (SemilinearEquivClass.instSemilinearMapClass.{u3, u3, u1, u2, max u2 u1} R R M₂ M (LinearEquiv.{u3, u3, u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) M₂ M _inst_8 _inst_6 _inst_20 _inst_19) _inst_1 _inst_1 _inst_8 _inst_6 _inst_20 _inst_19 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u3, u3, u1, u2} R R M₂ M _inst_1 _inst_1 _inst_8 _inst_6 _inst_20 _inst_19 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1)))))) (LinearEquiv.symm.{u3, u3, u2, u1} R R M M₂ _inst_1 _inst_1 _inst_6 _inst_8 _inst_19 _inst_20 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (LinearEquiv.mk.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) M M₂ _inst_6 _inst_8 _inst_19 _inst_20 (LinearMap.mk.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M₂ _inst_6 _inst_8 _inst_19 _inst_20 (AddHom.mk.{u2, u1} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_8))) to_fun map_add) map_smul) inv_fun left_inv right_inv))) inv_fun
Case conversion may be inaccurate. Consider using '#align linear_equiv.coe_symm_mk LinearEquiv.coe_symm_mkₓ'. -/
@[simp]
theorem coe_symm_mk [Module R M] [Module R M₂]
    {to_fun inv_fun map_add map_smul left_inv right_inv} :
    ⇑(⟨to_fun, map_add, map_smul, inv_fun, left_inv, right_inv⟩ : M ≃ₗ[R] M₂).symm = inv_fun :=
  rfl
#align linear_equiv.coe_symm_mk LinearEquiv.coe_symm_mk

/- warning: linear_equiv.bijective -> LinearEquiv.bijective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂), Function.Bijective.{succ u3, succ u4} M M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u4}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_6 : AddCommMonoid.{u4} M] [_inst_8 : AddCommMonoid.{u3} M₂] {module_M : Module.{u2, u4} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u1, u3} S M₂ _inst_2 _inst_8} {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} {σ' : RingHom.{u1, u2} S R (Semiring.toNonAssocSemiring.{u1} S _inst_2) (Semiring.toNonAssocSemiring.{u2} R _inst_1)} {re₁ : RingHomInvPair.{u2, u1} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u1, u2} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂), Function.Bijective.{succ u4, succ u3} M M₂ (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u4 u3, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u4 u3, u2, u1, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e)
Case conversion may be inaccurate. Consider using '#align linear_equiv.bijective LinearEquiv.bijectiveₓ'. -/
protected theorem bijective : Function.Bijective e :=
  e.toEquiv.Bijective
#align linear_equiv.bijective LinearEquiv.bijective

/- warning: linear_equiv.injective -> LinearEquiv.injective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂), Function.Injective.{succ u3, succ u4} M M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u4}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_6 : AddCommMonoid.{u4} M] [_inst_8 : AddCommMonoid.{u3} M₂] {module_M : Module.{u2, u4} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u1, u3} S M₂ _inst_2 _inst_8} {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} {σ' : RingHom.{u1, u2} S R (Semiring.toNonAssocSemiring.{u1} S _inst_2) (Semiring.toNonAssocSemiring.{u2} R _inst_1)} {re₁ : RingHomInvPair.{u2, u1} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u1, u2} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂), Function.Injective.{succ u4, succ u3} M M₂ (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u4 u3, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u4 u3, u2, u1, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e)
Case conversion may be inaccurate. Consider using '#align linear_equiv.injective LinearEquiv.injectiveₓ'. -/
protected theorem injective : Function.Injective e :=
  e.toEquiv.Injective
#align linear_equiv.injective LinearEquiv.injective

/- warning: linear_equiv.surjective -> LinearEquiv.surjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂), Function.Surjective.{succ u3, succ u4} M M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u4}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_6 : AddCommMonoid.{u4} M] [_inst_8 : AddCommMonoid.{u3} M₂] {module_M : Module.{u2, u4} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u1, u3} S M₂ _inst_2 _inst_8} {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} {σ' : RingHom.{u1, u2} S R (Semiring.toNonAssocSemiring.{u1} S _inst_2) (Semiring.toNonAssocSemiring.{u2} R _inst_1)} {re₁ : RingHomInvPair.{u2, u1} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u1, u2} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂), Function.Surjective.{succ u4, succ u3} M M₂ (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u4 u3, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u4 u3, u2, u1, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e)
Case conversion may be inaccurate. Consider using '#align linear_equiv.surjective LinearEquiv.surjectiveₓ'. -/
protected theorem surjective : Function.Surjective e :=
  e.toEquiv.Surjective
#align linear_equiv.surjective LinearEquiv.surjective

/- warning: linear_equiv.image_eq_preimage -> LinearEquiv.image_eq_preimage is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (s : Set.{u3} M), Eq.{succ u4} (Set.{u4} M₂) (Set.image.{u3, u4} M M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e) s) (Set.preimage.{u4, u3} M₂ M (coeFn.{max (succ u4) (succ u3), max (succ u4) (succ u3)} (LinearEquiv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) (fun (_x : LinearEquiv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) => M₂ -> M) (LinearEquiv.hasCoeToFun.{u2, u1, u4, u3} S R M₂ M _inst_2 _inst_1 _inst_8 _inst_6 module_S_M₂ module_M σ' σ re₂ re₁) (LinearEquiv.symm.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂ e)) s)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {M : Type.{u4}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_6 : AddCommMonoid.{u4} M] [_inst_8 : AddCommMonoid.{u3} M₂] {module_M : Module.{u2, u4} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u1, u3} S M₂ _inst_2 _inst_8} {σ : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)} {σ' : RingHom.{u1, u2} S R (Semiring.toNonAssocSemiring.{u1} S _inst_2) (Semiring.toNonAssocSemiring.{u2} R _inst_1)} {re₁ : RingHomInvPair.{u2, u1} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u1, u2} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (s : Set.{u4} M), Eq.{succ u3} (Set.{u3} M₂) (Set.image.{u4, u3} M M₂ (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u4) (succ u3), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u4 u3, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u4 u3, u2, u1, u4, u3} (LinearEquiv.{u2, u1, u4, u3} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e) s) (Set.preimage.{u3, u4} M₂ M (FunLike.coe.{max (succ u4) (succ u3), succ u3, succ u4} (LinearEquiv.{u1, u2, u3, u4} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) M₂ (fun (_x : M₂) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M₂) => M) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u3), succ u3, succ u4} (LinearEquiv.{u1, u2, u3, u4} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) M₂ M (EquivLike.toEmbeddingLike.{max (succ u4) (succ u3), succ u3, succ u4} (LinearEquiv.{u1, u2, u3, u4} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) M₂ M (AddEquivClass.toEquivLike.{max u4 u3, u3, u4} (LinearEquiv.{u1, u2, u3, u4} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) M₂ M (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8))) (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6))) (SemilinearEquivClass.toAddEquivClass.{max u4 u3, u1, u2, u3, u4} (LinearEquiv.{u1, u2, u3, u4} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u2, u3, u4} S R M₂ M _inst_2 _inst_1 _inst_8 _inst_6 module_S_M₂ module_M σ' σ re₂ re₁))))) (LinearEquiv.symm.{u2, u1, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂ e)) s)
Case conversion may be inaccurate. Consider using '#align linear_equiv.image_eq_preimage LinearEquiv.image_eq_preimageₓ'. -/
protected theorem image_eq_preimage (s : Set M) : e '' s = e.symm ⁻¹' s :=
  e.toEquiv.image_eq_preimage s
#align linear_equiv.image_eq_preimage LinearEquiv.image_eq_preimage

/- warning: linear_equiv.image_symm_eq_preimage -> LinearEquiv.image_symm_eq_preimage is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (s : Set.{u4} M₂), Eq.{succ u3} (Set.{u3} M) (Set.image.{u4, u3} M₂ M (coeFn.{max (succ u4) (succ u3), max (succ u4) (succ u3)} (LinearEquiv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) (fun (_x : LinearEquiv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) => M₂ -> M) (LinearEquiv.hasCoeToFun.{u2, u1, u4, u3} S R M₂ M _inst_2 _inst_1 _inst_8 _inst_6 module_S_M₂ module_M σ' σ re₂ re₁) (LinearEquiv.symm.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂ e)) s) (Set.preimage.{u3, u4} M M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (fun (_x : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂) e) s)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] {module_M : Module.{u1, u3} R M _inst_1 _inst_6} {module_S_M₂ : Module.{u2, u4} S M₂ _inst_2 _inst_8} {σ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)} {σ' : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {re₁ : RingHomInvPair.{u1, u2} R S _inst_1 _inst_2 σ σ'} {re₂ : RingHomInvPair.{u2, u1} S R _inst_2 _inst_1 σ' σ} (e : LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) (s : Set.{u4} M₂), Eq.{succ u3} (Set.{u3} M) (Set.image.{u4, u3} M₂ M (FunLike.coe.{max (succ u3) (succ u4), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) M₂ (fun (_x : M₂) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M₂) => M) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u4), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) M₂ M (EquivLike.toEmbeddingLike.{max (succ u3) (succ u4), succ u4, succ u3} (LinearEquiv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) M₂ M (AddEquivClass.toEquivLike.{max u3 u4, u4, u3} (LinearEquiv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) M₂ M (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (SemilinearEquivClass.toAddEquivClass.{max u3 u4, u2, u1, u4, u3} (LinearEquiv.{u2, u1, u4, u3} S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M) S R _inst_2 _inst_1 σ' σ re₂ re₁ M₂ M _inst_8 _inst_6 module_S_M₂ module_M (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u1, u4, u3} S R M₂ M _inst_2 _inst_1 _inst_8 _inst_6 module_S_M₂ module_M σ' σ re₂ re₁))))) (LinearEquiv.symm.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂ e)) s) (Set.preimage.{u3, u4} M M₂ (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (EquivLike.toEmbeddingLike.{max (succ u3) (succ u4), succ u3, succ u4} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddEquivClass.toEquivLike.{max u3 u4, u3, u4} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (SemilinearEquivClass.toAddEquivClass.{max u3 u4, u1, u2, u3, u4} (LinearEquiv.{u1, u2, u3, u4} R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂) R S _inst_1 _inst_2 σ σ' re₁ re₂ M M₂ _inst_6 _inst_8 module_M module_S_M₂ (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 module_M module_S_M₂ σ σ' re₁ re₂))))) e) s)
Case conversion may be inaccurate. Consider using '#align linear_equiv.image_symm_eq_preimage LinearEquiv.image_symm_eq_preimageₓ'. -/
protected theorem image_symm_eq_preimage (s : Set M₂) : e.symm '' s = e ⁻¹' s :=
  e.toEquiv.symm.image_eq_preimage s
#align linear_equiv.image_symm_eq_preimage LinearEquiv.image_symm_eq_preimage

end

/- warning: ring_equiv.to_semilinear_equiv -> RingEquiv.toSemilinearEquiv is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] (f : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))), LinearEquiv.{u1, u2, u1, u2} R S _inst_1 _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))) (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))) (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))) (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHom.hasCoeT.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))) R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) (RingEquivClass.toRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))) R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) (RingEquiv.ringEquivClass.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))))))) f) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u2) (succ u1), max (succ u2) (succ u1)} a b] => self.0) (RingEquiv.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (outParam.{max (succ u2) (succ u1)} (RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (HasLiftT.mk.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingEquiv.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (outParam.{max (succ u2) (succ u1)} (RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (CoeTCₓ.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingEquiv.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (outParam.{max (succ u2) (succ u1)} (RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHom.hasCoeT.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (RingEquivClass.toRingHomClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (RingEquiv.ringEquivClass.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))))) (RingEquiv.symm.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) f)) (RingHomInvPair.of_ringEquiv.{u1, u2} R S _inst_1 _inst_2 f) (RingEquiv.toSemilinearEquiv._proof_1.{u1, u2} R S _inst_1 _inst_2 f) R S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u1} R _inst_1) (Semiring.toModule.{u2} S _inst_2)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] (f : RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))), LinearEquiv.{u1, u2, u1, u2} R S _inst_1 _inst_2 (RingHomClass.toRingHom.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))) R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) (RingEquivClass.toRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))) R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) (RingEquiv.instRingEquivClassRingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))))) f) (RingHomClass.toRingHom.{max u1 u2, u2, u1} (RingEquiv.{u2, u1} S R (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (RingEquivClass.toRingHomClass.{max u1 u2, u2, u1} (RingEquiv.{u2, u1} S R (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} S R (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (RingEquiv.symm.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) f)) (RingHomInvPair.of_ringEquiv.{u2, u1} R S _inst_1 _inst_2 f) (RingHomInvPair.symm.{u2, u1} R S _inst_1 _inst_2 (RingHomClass.toRingHom.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))) R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) (RingEquivClass.toRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))) R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) (RingEquiv.instRingEquivClassRingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))))) f) (RingHomClass.toRingHom.{max u1 u2, u2, u1} (RingEquiv.{u2, u1} S R (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (RingEquivClass.toRingHomClass.{max u1 u2, u2, u1} (RingEquiv.{u2, u1} S R (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} S R (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (RingEquiv.symm.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) f)) (RingHomInvPair.of_ringEquiv.{u2, u1} R S _inst_1 _inst_2 f)) R S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u1} R _inst_1) (Semiring.toModule.{u2} S _inst_2)
Case conversion may be inaccurate. Consider using '#align ring_equiv.to_semilinear_equiv RingEquiv.toSemilinearEquivₓ'. -/
/-- Interpret a `ring_equiv` `f` as an `f`-semilinear equiv. -/
@[simps]
def RingEquiv.toSemilinearEquiv (f : R ≃+* S) : by
    haveI := RingHomInvPair.of_ringEquiv f <;>
        haveI := RingHomInvPair.symm (↑f : R →+* S) (f.symm : S →+* R) <;>
      exact R ≃ₛₗ[(↑f : R →+* S)] S :=
  { f with
    toFun := f
    map_smul' := f.map_mul }
#align ring_equiv.to_semilinear_equiv RingEquiv.toSemilinearEquiv

variable [Semiring R₁] [Semiring R₂] [Semiring R₃]

variable [AddCommMonoid M] [AddCommMonoid M₁] [AddCommMonoid M₂]

/- warning: linear_equiv.of_involutive -> LinearEquiv.ofInvolutive is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_6 : AddCommMonoid.{u2} M] {σ : RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {σ' : RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} [_inst_9 : RingHomInvPair.{u1, u1} R R _inst_1 _inst_1 σ σ'] [_inst_10 : RingHomInvPair.{u1, u1} R R _inst_1 _inst_1 σ' σ] {module_M : Module.{u1, u2} R M _inst_1 _inst_6} (f : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 σ M M _inst_6 _inst_6 module_M module_M), (Function.Involutive.{succ u2} M (coeFn.{succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 σ M M _inst_6 _inst_6 module_M module_M) (fun (_x : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 σ M M _inst_6 _inst_6 module_M module_M) => M -> M) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R M M _inst_1 _inst_1 _inst_6 _inst_6 module_M module_M σ) f)) -> (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 σ σ' _inst_9 _inst_10 M M _inst_6 _inst_6 module_M module_M)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_6 : AddCommMonoid.{u2} M] {σ : RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {σ' : RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} [_inst_9 : RingHomInvPair.{u1, u1} R R _inst_1 _inst_1 σ σ'] [_inst_10 : RingHomInvPair.{u1, u1} R R _inst_1 _inst_1 σ' σ] {module_M : Module.{u1, u2} R M _inst_1 _inst_6} (f : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 σ M M _inst_6 _inst_6 module_M module_M), (Function.Involutive.{succ u2} M (FunLike.coe.{succ u2, succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 σ M M _inst_6 _inst_6 module_M module_M) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} R R M M _inst_1 _inst_1 _inst_6 _inst_6 module_M module_M σ) f)) -> (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 σ σ' _inst_9 _inst_10 M M _inst_6 _inst_6 module_M module_M)
Case conversion may be inaccurate. Consider using '#align linear_equiv.of_involutive LinearEquiv.ofInvolutiveₓ'. -/
/-- An involutive linear map is a linear equivalence. -/
def ofInvolutive {σ σ' : R →+* R} [RingHomInvPair σ σ'] [RingHomInvPair σ' σ]
    {module_M : Module R M} (f : M →ₛₗ[σ] M) (hf : Involutive f) : M ≃ₛₗ[σ] M :=
  { f, hf.toPerm f with }
#align linear_equiv.of_involutive LinearEquiv.ofInvolutive

/- warning: linear_equiv.coe_of_involutive -> LinearEquiv.coe_ofInvolutive is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_6 : AddCommMonoid.{u2} M] {σ : RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} {σ' : RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)} [_inst_9 : RingHomInvPair.{u1, u1} R R _inst_1 _inst_1 σ σ'] [_inst_10 : RingHomInvPair.{u1, u1} R R _inst_1 _inst_1 σ' σ] {module_M : Module.{u1, u2} R M _inst_1 _inst_6} (f : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 σ M M _inst_6 _inst_6 module_M module_M) (hf : Function.Involutive.{succ u2} M (coeFn.{succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 σ M M _inst_6 _inst_6 module_M module_M) (fun (_x : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 σ M M _inst_6 _inst_6 module_M module_M) => M -> M) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R M M _inst_1 _inst_1 _inst_6 _inst_6 module_M module_M σ) f)), Eq.{succ u2} (M -> M) (coeFn.{succ u2, succ u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 σ σ' _inst_9 _inst_10 M M _inst_6 _inst_6 module_M module_M) (fun (_x : LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 σ σ' _inst_9 _inst_10 M M _inst_6 _inst_6 module_M module_M) => M -> M) (LinearEquiv.hasCoeToFun.{u1, u1, u2, u2} R R M M _inst_1 _inst_1 _inst_6 _inst_6 module_M module_M σ σ' _inst_9 _inst_10) (LinearEquiv.ofInvolutive.{u1, u2} R M _inst_1 _inst_6 σ σ' _inst_9 _inst_10 module_M f hf)) (coeFn.{succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 σ M M _inst_6 _inst_6 module_M module_M) (fun (_x : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 σ M M _inst_6 _inst_6 module_M module_M) => M -> M) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R M M _inst_1 _inst_1 _inst_6 _inst_6 module_M module_M σ) f)
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_6 : AddCommMonoid.{u1} M] {σ : RingHom.{u2, u2} R R (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u2} R _inst_1)} {σ' : RingHom.{u2, u2} R R (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u2} R _inst_1)} [_inst_9 : RingHomInvPair.{u2, u2} R R _inst_1 _inst_1 σ σ'] [_inst_10 : RingHomInvPair.{u2, u2} R R _inst_1 _inst_1 σ' σ] {module_M : Module.{u2, u1} R M _inst_1 _inst_6} (f : LinearMap.{u2, u2, u1, u1} R R _inst_1 _inst_1 σ M M _inst_6 _inst_6 module_M module_M) (hf : Function.Involutive.{succ u1} M (FunLike.coe.{succ u1, succ u1, succ u1} (LinearMap.{u2, u2, u1, u1} R R _inst_1 _inst_1 σ M M _inst_6 _inst_6 module_M module_M) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, u1, u1} R R M M _inst_1 _inst_1 _inst_6 _inst_6 module_M module_M σ) f)), Eq.{succ u1} (forall (ᾰ : M), (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (LinearEquiv.{u2, u2, u1, u1} R R _inst_1 _inst_1 σ σ' _inst_9 _inst_10 M M _inst_6 _inst_6 module_M module_M) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (LinearEquiv.{u2, u2, u1, u1} R R _inst_1 _inst_1 σ σ' _inst_9 _inst_10 M M _inst_6 _inst_6 module_M module_M) M M (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (LinearEquiv.{u2, u2, u1, u1} R R _inst_1 _inst_1 σ σ' _inst_9 _inst_10 M M _inst_6 _inst_6 module_M module_M) M M (AddEquivClass.toEquivLike.{u1, u1, u1} (LinearEquiv.{u2, u2, u1, u1} R R _inst_1 _inst_1 σ σ' _inst_9 _inst_10 M M _inst_6 _inst_6 module_M module_M) M M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_6))) (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_6))) (SemilinearEquivClass.toAddEquivClass.{u1, u2, u2, u1, u1} (LinearEquiv.{u2, u2, u1, u1} R R _inst_1 _inst_1 σ σ' _inst_9 _inst_10 M M _inst_6 _inst_6 module_M module_M) R R _inst_1 _inst_1 σ σ' _inst_9 _inst_10 M M _inst_6 _inst_6 module_M module_M (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u2, u1, u1} R R M M _inst_1 _inst_1 _inst_6 _inst_6 module_M module_M σ σ' _inst_9 _inst_10))))) (LinearEquiv.ofInvolutive.{u2, u1} R M _inst_1 _inst_6 σ σ' _inst_9 _inst_10 module_M f hf)) (FunLike.coe.{succ u1, succ u1, succ u1} (LinearMap.{u2, u2, u1, u1} R R _inst_1 _inst_1 σ M M _inst_6 _inst_6 module_M module_M) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, u1, u1} R R M M _inst_1 _inst_1 _inst_6 _inst_6 module_M module_M σ) f)
Case conversion may be inaccurate. Consider using '#align linear_equiv.coe_of_involutive LinearEquiv.coe_ofInvolutiveₓ'. -/
@[simp]
theorem coe_ofInvolutive {σ σ' : R →+* R} [RingHomInvPair σ σ'] [RingHomInvPair σ' σ]
    {module_M : Module R M} (f : M →ₛₗ[σ] M) (hf : Involutive f) : ⇑(ofInvolutive f hf) = f :=
  rfl
#align linear_equiv.coe_of_involutive LinearEquiv.coe_ofInvolutive

section RestrictScalars

variable (R) [Module R M] [Module R M₂] [Module S M] [Module S M₂]
  [LinearMap.CompatibleSMul M M₂ R S]

#print LinearEquiv.restrictScalars /-
/-- If `M` and `M₂` are both `R`-semimodules and `S`-semimodules and `R`-semimodule structures
are defined by an action of `R` on `S` (formally, we have two scalar towers), then any `S`-linear
equivalence from `M` to `M₂` is also an `R`-linear equivalence.

See also `linear_map.restrict_scalars`. -/
@[simps]
def restrictScalars (f : M ≃ₗ[S] M₂) : M ≃ₗ[R] M₂ :=
  { f.toLinearMap.restrictScalars R with
    toFun := f
    invFun := f.symm
    left_inv := f.left_inv
    right_inv := f.right_inv }
#align linear_equiv.restrict_scalars LinearEquiv.restrictScalars
-/

/- warning: linear_equiv.restrict_scalars_injective -> LinearEquiv.restrictScalars_injective is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] [_inst_9 : Module.{u1, u3} R M _inst_1 _inst_6] [_inst_10 : Module.{u1, u4} R M₂ _inst_1 _inst_8] [_inst_11 : Module.{u2, u3} S M _inst_2 _inst_6] [_inst_12 : Module.{u2, u4} S M₂ _inst_2 _inst_8] [_inst_13 : LinearMap.CompatibleSMul.{u3, u4, u1, u2} M M₂ _inst_6 _inst_8 R S _inst_2 (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_6 _inst_9)))) _inst_11 (SMulZeroClass.toHasSmul.{u1, u4} R M₂ (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (SMulWithZero.toSmulZeroClass.{u1, u4} R M₂ (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (MulActionWithZero.toSMulWithZero.{u1, u4} R M₂ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (Module.toMulActionWithZero.{u1, u4} R M₂ _inst_1 _inst_8 _inst_10)))) _inst_12], Function.Injective.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearEquiv.{u2, u2, u3, u4} S S _inst_2 _inst_2 (RingHom.id.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHom.id.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomInvPair.ids.{u2} S _inst_2) (RingHomInvPair.ids.{u2} S _inst_2) M M₂ _inst_6 _inst_8 _inst_11 _inst_12) (LinearEquiv.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_6 _inst_8 _inst_9 _inst_10) (LinearEquiv.restrictScalars.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 _inst_9 _inst_10 _inst_11 _inst_12 _inst_13)
but is expected to have type
  forall (R : Type.{u1}) {S : Type.{u2}} {M : Type.{u4}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u4} M] [_inst_8 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u4} R M _inst_1 _inst_6] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_8] [_inst_11 : Module.{u2, u4} S M _inst_2 _inst_6] [_inst_12 : Module.{u2, u3} S M₂ _inst_2 _inst_8] [_inst_13 : LinearMap.CompatibleSMul.{u4, u3, u1, u2} M M₂ _inst_6 _inst_8 R S _inst_2 (SMulZeroClass.toSMul.{u1, u4} R M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6)) (SMulWithZero.toSMulZeroClass.{u1, u4} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6)) (MulActionWithZero.toSMulWithZero.{u1, u4} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_6)) (Module.toMulActionWithZero.{u1, u4} R M _inst_1 _inst_6 _inst_9)))) _inst_11 (SMulZeroClass.toSMul.{u1, u3} R M₂ (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8)) (SMulWithZero.toSMulZeroClass.{u1, u3} R M₂ (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8)) (MulActionWithZero.toSMulWithZero.{u1, u3} R M₂ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_8)) (Module.toMulActionWithZero.{u1, u3} R M₂ _inst_1 _inst_8 _inst_10)))) _inst_12], Function.Injective.{max (succ u4) (succ u3), max (succ u4) (succ u3)} (LinearEquiv.{u2, u2, u4, u3} S S _inst_2 _inst_2 (RingHom.id.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHom.id.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomInvPair.ids.{u2} S _inst_2) (RingHomInvPair.ids.{u2} S _inst_2) M M₂ _inst_6 _inst_8 _inst_11 _inst_12) (LinearEquiv.{u1, u1, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_6 _inst_8 _inst_9 _inst_10) (LinearEquiv.restrictScalars.{u1, u2, u4, u3} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 _inst_9 _inst_10 _inst_11 _inst_12 _inst_13)
Case conversion may be inaccurate. Consider using '#align linear_equiv.restrict_scalars_injective LinearEquiv.restrictScalars_injectiveₓ'. -/
theorem restrictScalars_injective :
    Function.Injective (restrictScalars R : (M ≃ₗ[S] M₂) → M ≃ₗ[R] M₂) := fun f g h =>
  ext (LinearEquiv.congr_fun h : _)
#align linear_equiv.restrict_scalars_injective LinearEquiv.restrictScalars_injective

/- warning: linear_equiv.restrict_scalars_inj -> LinearEquiv.restrictScalars_inj is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {S : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u4} M₂] [_inst_9 : Module.{u1, u3} R M _inst_1 _inst_6] [_inst_10 : Module.{u1, u4} R M₂ _inst_1 _inst_8] [_inst_11 : Module.{u2, u3} S M _inst_2 _inst_6] [_inst_12 : Module.{u2, u4} S M₂ _inst_2 _inst_8] [_inst_13 : LinearMap.CompatibleSMul.{u3, u4, u1, u2} M M₂ _inst_6 _inst_8 R S _inst_2 (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6))) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_6 _inst_9)))) _inst_11 (SMulZeroClass.toHasSmul.{u1, u4} R M₂ (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (SMulWithZero.toSmulZeroClass.{u1, u4} R M₂ (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (MulActionWithZero.toSMulWithZero.{u1, u4} R M₂ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_8))) (Module.toMulActionWithZero.{u1, u4} R M₂ _inst_1 _inst_8 _inst_10)))) _inst_12] (f : LinearEquiv.{u2, u2, u3, u4} S S _inst_2 _inst_2 (RingHom.id.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHom.id.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomInvPair.ids.{u2} S _inst_2) (RingHomInvPair.ids.{u2} S _inst_2) M M₂ _inst_6 _inst_8 _inst_11 _inst_12) (g : LinearEquiv.{u2, u2, u3, u4} S S _inst_2 _inst_2 (RingHom.id.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHom.id.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomInvPair.ids.{u2} S _inst_2) (RingHomInvPair.ids.{u2} S _inst_2) M M₂ _inst_6 _inst_8 _inst_11 _inst_12), Iff (Eq.{max (succ u3) (succ u4)} (LinearEquiv.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_6 _inst_8 _inst_9 _inst_10) (LinearEquiv.restrictScalars.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 _inst_9 _inst_10 _inst_11 _inst_12 _inst_13 f) (LinearEquiv.restrictScalars.{u1, u2, u3, u4} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 _inst_9 _inst_10 _inst_11 _inst_12 _inst_13 g)) (Eq.{max (succ u3) (succ u4)} (LinearEquiv.{u2, u2, u3, u4} S S _inst_2 _inst_2 (RingHom.id.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHom.id.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomInvPair.ids.{u2} S _inst_2) (RingHomInvPair.ids.{u2} S _inst_2) M M₂ _inst_6 _inst_8 _inst_11 _inst_12) f g)
but is expected to have type
  forall (R : Type.{u1}) {S : Type.{u4}} {M : Type.{u3}} {M₂ : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u4} S] [_inst_6 : AddCommMonoid.{u3} M] [_inst_8 : AddCommMonoid.{u2} M₂] [_inst_9 : Module.{u1, u3} R M _inst_1 _inst_6] [_inst_10 : Module.{u1, u2} R M₂ _inst_1 _inst_8] [_inst_11 : Module.{u4, u3} S M _inst_2 _inst_6] [_inst_12 : Module.{u4, u2} S M₂ _inst_2 _inst_8] [_inst_13 : LinearMap.CompatibleSMul.{u3, u2, u1, u4} M M₂ _inst_6 _inst_8 R S _inst_2 (SMulZeroClass.toSMul.{u1, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6)) (SMulWithZero.toSMulZeroClass.{u1, u3} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6)) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_6)) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_6 _inst_9)))) _inst_11 (SMulZeroClass.toSMul.{u1, u2} R M₂ (AddMonoid.toZero.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_8)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M₂ (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_8)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M₂ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_8)) (Module.toMulActionWithZero.{u1, u2} R M₂ _inst_1 _inst_8 _inst_10)))) _inst_12] (f : LinearEquiv.{u4, u4, u3, u2} S S _inst_2 _inst_2 (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2)) (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2)) (RingHomInvPair.ids.{u4} S _inst_2) (RingHomInvPair.ids.{u4} S _inst_2) M M₂ _inst_6 _inst_8 _inst_11 _inst_12) (g : LinearEquiv.{u4, u4, u3, u2} S S _inst_2 _inst_2 (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2)) (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2)) (RingHomInvPair.ids.{u4} S _inst_2) (RingHomInvPair.ids.{u4} S _inst_2) M M₂ _inst_6 _inst_8 _inst_11 _inst_12), Iff (Eq.{max (succ u3) (succ u2)} (LinearEquiv.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_6 _inst_8 _inst_9 _inst_10) (LinearEquiv.restrictScalars.{u1, u4, u3, u2} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 _inst_9 _inst_10 _inst_11 _inst_12 _inst_13 f) (LinearEquiv.restrictScalars.{u1, u4, u3, u2} R S M M₂ _inst_1 _inst_2 _inst_6 _inst_8 _inst_9 _inst_10 _inst_11 _inst_12 _inst_13 g)) (Eq.{max (succ u3) (succ u2)} (LinearEquiv.{u4, u4, u3, u2} S S _inst_2 _inst_2 (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2)) (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2)) (RingHomInvPair.ids.{u4} S _inst_2) (RingHomInvPair.ids.{u4} S _inst_2) M M₂ _inst_6 _inst_8 _inst_11 _inst_12) f g)
Case conversion may be inaccurate. Consider using '#align linear_equiv.restrict_scalars_inj LinearEquiv.restrictScalars_injₓ'. -/
@[simp]
theorem restrictScalars_inj (f g : M ≃ₗ[S] M₂) :
    f.restrictScalars R = g.restrictScalars R ↔ f = g :=
  (restrictScalars_injective R).eq_iff
#align linear_equiv.restrict_scalars_inj LinearEquiv.restrictScalars_inj

end RestrictScalars

section Automorphisms

variable [Module R M]

#print LinearEquiv.automorphismGroup /-
instance automorphismGroup : Group (M ≃ₗ[R] M)
    where
  mul f g := g.trans f
  one := LinearEquiv.refl R M
  inv f := f.symm
  mul_assoc f g h := rfl
  mul_one f := ext fun x => rfl
  one_mul f := ext fun x => rfl
  mul_left_inv f := ext <| f.left_inv
#align linear_equiv.automorphism_group LinearEquiv.automorphismGroup
-/

#print LinearEquiv.automorphismGroup.toLinearMapMonoidHom /-
/-- Restriction from `R`-linear automorphisms of `M` to `R`-linear endomorphisms of `M`,
promoted to a monoid hom. -/
@[simps]
def automorphismGroup.toLinearMapMonoidHom : (M ≃ₗ[R] M) →* M →ₗ[R] M
    where
  toFun := coe
  map_one' := rfl
  map_mul' _ _ := rfl
#align linear_equiv.automorphism_group.to_linear_map_monoid_hom LinearEquiv.automorphismGroup.toLinearMapMonoidHom
-/

#print LinearEquiv.applyDistribMulAction /-
/-- The tautological action by `M ≃ₗ[R] M` on `M`.

This generalizes `function.End.apply_mul_action`. -/
instance applyDistribMulAction : DistribMulAction (M ≃ₗ[R] M) M
    where
  smul := (· <| ·)
  smul_zero := LinearEquiv.map_zero
  smul_add := LinearEquiv.map_add
  one_smul _ := rfl
  mul_smul _ _ _ := rfl
#align linear_equiv.apply_distrib_mul_action LinearEquiv.applyDistribMulAction
-/

/- warning: linear_equiv.smul_def -> LinearEquiv.smul_def is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_6 : AddCommMonoid.{u2} M] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_6] (f : LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) (a : M), Eq.{succ u2} M (SMul.smul.{u2, u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) M (SMulZeroClass.toHasSmul.{u2, u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6))) (DistribSMul.toSmulZeroClass.{u2, u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6)) (DistribMulAction.toDistribSMul.{u2, u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) M (DivInvMonoid.toMonoid.{u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) (Group.toDivInvMonoid.{u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) (LinearEquiv.automorphismGroup.{u1, u2} R M _inst_1 _inst_6 _inst_9))) (AddCommMonoid.toAddMonoid.{u2} M _inst_6) (LinearEquiv.applyDistribMulAction.{u1, u2} R M _inst_1 _inst_6 _inst_9)))) f a) (coeFn.{succ u2, succ u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) (fun (_x : LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) => M -> M) (LinearEquiv.hasCoeToFun.{u1, u1, u2, u2} R R M M _inst_1 _inst_1 _inst_6 _inst_6 _inst_9 _inst_9 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)) f a)
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_6 : AddCommMonoid.{u1} M] [_inst_9 : Module.{u2, u1} R M _inst_1 _inst_6] (f : LinearEquiv.{u2, u2, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) (a : M), Eq.{succ u1} M (HSMul.hSMul.{u1, u1, u1} (LinearEquiv.{u2, u2, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) M M (instHSMul.{u1, u1} (LinearEquiv.{u2, u2, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) M (SMulZeroClass.toSMul.{u1, u1} (LinearEquiv.{u2, u2, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_6)) (DistribSMul.toSMulZeroClass.{u1, u1} (LinearEquiv.{u2, u2, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_6)) (DistribMulAction.toDistribSMul.{u1, u1} (LinearEquiv.{u2, u2, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) M (DivInvMonoid.toMonoid.{u1} (LinearEquiv.{u2, u2, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) (Group.toDivInvMonoid.{u1} (LinearEquiv.{u2, u2, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) (LinearEquiv.automorphismGroup.{u2, u1} R M _inst_1 _inst_6 _inst_9))) (AddCommMonoid.toAddMonoid.{u1} M _inst_6) (LinearEquiv.applyDistribMulAction.{u2, u1} R M _inst_1 _inst_6 _inst_9))))) f a) (FunLike.coe.{succ u1, succ u1, succ u1} (LinearEquiv.{u2, u2, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M) => M) _x) (SMulHomClass.toFunLike.{u1, u2, u1, u1} (LinearEquiv.{u2, u2, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) R M M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_6)) (DistribSMul.toSMulZeroClass.{u2, u1} R M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_6)) (DistribMulAction.toDistribSMul.{u2, u1} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M _inst_6) (Module.toDistribMulAction.{u2, u1} R M _inst_1 _inst_6 _inst_9)))) (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_6)) (DistribSMul.toSMulZeroClass.{u2, u1} R M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_6)) (DistribMulAction.toDistribSMul.{u2, u1} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M _inst_6) (Module.toDistribMulAction.{u2, u1} R M _inst_1 _inst_6 _inst_9)))) (DistribMulActionHomClass.toSMulHomClass.{u1, u2, u1, u1} (LinearEquiv.{u2, u2, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) R M M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M _inst_6) (AddCommMonoid.toAddMonoid.{u1} M _inst_6) (Module.toDistribMulAction.{u2, u1} R M _inst_1 _inst_6 _inst_9) (Module.toDistribMulAction.{u2, u1} R M _inst_1 _inst_6 _inst_9) (SemilinearMapClass.distribMulActionHomClass.{u2, u1, u1, u1} R M M (LinearEquiv.{u2, u2, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) _inst_1 _inst_6 _inst_6 _inst_9 _inst_9 (SemilinearEquivClass.instSemilinearMapClass.{u2, u2, u1, u1, u1} R R M M (LinearEquiv.{u2, u2, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) _inst_1 _inst_1 _inst_6 _inst_6 _inst_9 _inst_9 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u2, u1, u1} R R M M _inst_1 _inst_1 _inst_6 _inst_6 _inst_9 _inst_9 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1)))))) f a)
Case conversion may be inaccurate. Consider using '#align linear_equiv.smul_def LinearEquiv.smul_defₓ'. -/
@[simp]
protected theorem smul_def (f : M ≃ₗ[R] M) (a : M) : f • a = f a :=
  rfl
#align linear_equiv.smul_def LinearEquiv.smul_def

/- warning: linear_equiv.apply_has_faithful_smul -> LinearEquiv.apply_faithfulSMul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_6 : AddCommMonoid.{u2} M] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_6], FaithfulSMul.{u2, u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) M (SMulZeroClass.toHasSmul.{u2, u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6))) (DistribSMul.toSmulZeroClass.{u2, u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6)) (DistribMulAction.toDistribSMul.{u2, u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) M (DivInvMonoid.toMonoid.{u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) (Group.toDivInvMonoid.{u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) (LinearEquiv.automorphismGroup.{u1, u2} R M _inst_1 _inst_6 _inst_9))) (AddCommMonoid.toAddMonoid.{u2} M _inst_6) (LinearEquiv.applyDistribMulAction.{u1, u2} R M _inst_1 _inst_6 _inst_9))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_6 : AddCommMonoid.{u2} M] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_6], FaithfulSMul.{u2, u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) M (SMulZeroClass.toSMul.{u2, u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6)) (DistribSMul.toSMulZeroClass.{u2, u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6)) (DistribMulAction.toDistribSMul.{u2, u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) M (DivInvMonoid.toMonoid.{u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) (Group.toDivInvMonoid.{u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) (LinearEquiv.automorphismGroup.{u1, u2} R M _inst_1 _inst_6 _inst_9))) (AddCommMonoid.toAddMonoid.{u2} M _inst_6) (LinearEquiv.applyDistribMulAction.{u1, u2} R M _inst_1 _inst_6 _inst_9))))
Case conversion may be inaccurate. Consider using '#align linear_equiv.apply_has_faithful_smul LinearEquiv.apply_faithfulSMulₓ'. -/
/-- `linear_equiv.apply_distrib_mul_action` is faithful. -/
instance apply_faithfulSMul : FaithfulSMul (M ≃ₗ[R] M) M :=
  ⟨fun _ _ => LinearEquiv.ext⟩
#align linear_equiv.apply_has_faithful_smul LinearEquiv.apply_faithfulSMul

/- warning: linear_equiv.apply_smul_comm_class -> LinearEquiv.apply_sMulCommClass is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_6 : AddCommMonoid.{u2} M] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_6], SMulCommClass.{u1, u2, u2} R (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_6 _inst_9)))) (SMulZeroClass.toHasSmul.{u2, u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6))) (DistribSMul.toSmulZeroClass.{u2, u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6)) (DistribMulAction.toDistribSMul.{u2, u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) M (DivInvMonoid.toMonoid.{u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) (Group.toDivInvMonoid.{u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) (LinearEquiv.automorphismGroup.{u1, u2} R M _inst_1 _inst_6 _inst_9))) (AddCommMonoid.toAddMonoid.{u2} M _inst_6) (LinearEquiv.applyDistribMulAction.{u1, u2} R M _inst_1 _inst_6 _inst_9))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_6 : AddCommMonoid.{u2} M] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_6], SMulCommClass.{u1, u2, u2} R (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_6 _inst_9)))) (SMulZeroClass.toSMul.{u2, u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6)) (DistribSMul.toSMulZeroClass.{u2, u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6)) (DistribMulAction.toDistribSMul.{u2, u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) M (DivInvMonoid.toMonoid.{u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) (Group.toDivInvMonoid.{u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) (LinearEquiv.automorphismGroup.{u1, u2} R M _inst_1 _inst_6 _inst_9))) (AddCommMonoid.toAddMonoid.{u2} M _inst_6) (LinearEquiv.applyDistribMulAction.{u1, u2} R M _inst_1 _inst_6 _inst_9))))
Case conversion may be inaccurate. Consider using '#align linear_equiv.apply_smul_comm_class LinearEquiv.apply_sMulCommClassₓ'. -/
instance apply_sMulCommClass : SMulCommClass R (M ≃ₗ[R] M) M
    where smul_comm r e m := (e.map_smul r m).symm
#align linear_equiv.apply_smul_comm_class LinearEquiv.apply_sMulCommClass

/- warning: linear_equiv.apply_smul_comm_class' -> LinearEquiv.apply_sMulCommClass' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_6 : AddCommMonoid.{u2} M] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_6], SMulCommClass.{u2, u1, u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) R M (SMulZeroClass.toHasSmul.{u2, u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6))) (DistribSMul.toSmulZeroClass.{u2, u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6)) (DistribMulAction.toDistribSMul.{u2, u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) M (DivInvMonoid.toMonoid.{u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) (Group.toDivInvMonoid.{u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) (LinearEquiv.automorphismGroup.{u1, u2} R M _inst_1 _inst_6 _inst_9))) (AddCommMonoid.toAddMonoid.{u2} M _inst_6) (LinearEquiv.applyDistribMulAction.{u1, u2} R M _inst_1 _inst_6 _inst_9)))) (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_6 _inst_9))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_6 : AddCommMonoid.{u2} M] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_6], SMulCommClass.{u2, u1, u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) R M (SMulZeroClass.toSMul.{u2, u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6)) (DistribSMul.toSMulZeroClass.{u2, u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6)) (DistribMulAction.toDistribSMul.{u2, u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) M (DivInvMonoid.toMonoid.{u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) (Group.toDivInvMonoid.{u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_6 _inst_6 _inst_9 _inst_9) (LinearEquiv.automorphismGroup.{u1, u2} R M _inst_1 _inst_6 _inst_9))) (AddCommMonoid.toAddMonoid.{u2} M _inst_6) (LinearEquiv.applyDistribMulAction.{u1, u2} R M _inst_1 _inst_6 _inst_9)))) (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_6)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_6 _inst_9))))
Case conversion may be inaccurate. Consider using '#align linear_equiv.apply_smul_comm_class' LinearEquiv.apply_sMulCommClass'ₓ'. -/
instance apply_sMulCommClass' : SMulCommClass (M ≃ₗ[R] M) R M
    where smul_comm := LinearEquiv.map_smul
#align linear_equiv.apply_smul_comm_class' LinearEquiv.apply_sMulCommClass'

end Automorphisms

section OfSubsingleton

variable (M M₂) [Module R M] [Module R M₂] [Subsingleton M] [Subsingleton M₂]

#print LinearEquiv.ofSubsingleton /-
/-- Any two modules that are subsingletons are isomorphic. -/
@[simps]
def ofSubsingleton : M ≃ₗ[R] M₂ :=
  { (0 : M →ₗ[R] M₂) with
    toFun := fun _ => 0
    invFun := fun _ => 0
    left_inv := fun x => Subsingleton.elim _ _
    right_inv := fun x => Subsingleton.elim _ _ }
#align linear_equiv.of_subsingleton LinearEquiv.ofSubsingleton
-/

#print LinearEquiv.ofSubsingleton_self /-
@[simp]
theorem ofSubsingleton_self : ofSubsingleton M M = refl R M :=
  by
  ext
  simp
#align linear_equiv.of_subsingleton_self LinearEquiv.ofSubsingleton_self
-/

end OfSubsingleton

end AddCommMonoid

end LinearEquiv

namespace Module

/- warning: module.comp_hom.to_linear_equiv -> Module.compHom.toLinearEquiv is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] (g : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))), LinearEquiv.{u1, u1, u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) R S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u1} R _inst_1) (Module.compHom.{u2, u1, u2} S R S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2) _inst_1 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))) (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))) (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))) (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHom.hasCoeT.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))) R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) (RingEquivClass.toRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))) R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) (RingEquiv.ringEquivClass.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))))))) g))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] (g : RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))), LinearEquiv.{u1, u1, u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) R S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u1} R _inst_1) (Module.compHom.{u2, u1, u2} S R S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2) _inst_1 (RingHomClass.toRingHom.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))) R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) (RingEquivClass.toRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))) R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) (RingEquiv.instRingEquivClassRingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))))) g))
Case conversion may be inaccurate. Consider using '#align module.comp_hom.to_linear_equiv Module.compHom.toLinearEquivₓ'. -/
/-- `g : R ≃+* S` is `R`-linear when the module structure on `S` is `module.comp_hom S g` . -/
@[simps]
def compHom.toLinearEquiv {R S : Type _} [Semiring R] [Semiring S] (g : R ≃+* S) :
    haveI := comp_hom S (↑g : R →+* S)
    R ≃ₗ[R] S :=
  { g with
    toFun := (g : R → S)
    invFun := (g.symm : S → R)
    map_smul' := g.map_mul }
#align module.comp_hom.to_linear_equiv Module.compHom.toLinearEquiv

end Module

namespace DistribMulAction

variable (R M) [Semiring R] [AddCommMonoid M] [Module R M]

variable [Group S] [DistribMulAction S M] [SMulCommClass S R M]

/- warning: distrib_mul_action.to_linear_equiv -> DistribMulAction.toLinearEquiv is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {S : Type.{u2}} (M : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] [_inst_4 : Group.{u2} S] [_inst_5 : DistribMulAction.{u2, u3} S M (DivInvMonoid.toMonoid.{u2} S (Group.toDivInvMonoid.{u2} S _inst_4)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_6 : SMulCommClass.{u2, u1, u3} S R M (SMulZeroClass.toHasSmul.{u2, u3} S M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (DistribSMul.toSmulZeroClass.{u2, u3} S M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u2, u3} S M (DivInvMonoid.toMonoid.{u2} S (Group.toDivInvMonoid.{u2} S _inst_4)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5))) (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_2 _inst_3))))], S -> (LinearEquiv.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_2 _inst_2 _inst_3 _inst_3)
but is expected to have type
  forall (R : Type.{u1}) {S : Type.{u2}} (M : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] [_inst_4 : Group.{u2} S] [_inst_5 : DistribMulAction.{u2, u3} S M (DivInvMonoid.toMonoid.{u2} S (Group.toDivInvMonoid.{u2} S _inst_4)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_6 : SMulCommClass.{u2, u1, u3} S R M (SMulZeroClass.toSMul.{u2, u3} S M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribSMul.toSMulZeroClass.{u2, u3} S M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u2, u3} S M (DivInvMonoid.toMonoid.{u2} S (Group.toDivInvMonoid.{u2} S _inst_4)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5))) (SMulZeroClass.toSMul.{u1, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u3} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_2 _inst_3))))], S -> (LinearEquiv.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_2 _inst_2 _inst_3 _inst_3)
Case conversion may be inaccurate. Consider using '#align distrib_mul_action.to_linear_equiv DistribMulAction.toLinearEquivₓ'. -/
/-- Each element of the group defines a linear equivalence.

This is a stronger version of `distrib_mul_action.to_add_equiv`. -/
@[simps]
def toLinearEquiv (s : S) : M ≃ₗ[R] M :=
  { toAddEquiv M s, toLinearMap R M s with }
#align distrib_mul_action.to_linear_equiv DistribMulAction.toLinearEquiv

/- warning: distrib_mul_action.to_module_aut -> DistribMulAction.toModuleAut is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {S : Type.{u2}} (M : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] [_inst_4 : Group.{u2} S] [_inst_5 : DistribMulAction.{u2, u3} S M (DivInvMonoid.toMonoid.{u2} S (Group.toDivInvMonoid.{u2} S _inst_4)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_6 : SMulCommClass.{u2, u1, u3} S R M (SMulZeroClass.toHasSmul.{u2, u3} S M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (DistribSMul.toSmulZeroClass.{u2, u3} S M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u2, u3} S M (DivInvMonoid.toMonoid.{u2} S (Group.toDivInvMonoid.{u2} S _inst_4)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5))) (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_2 _inst_3))))], MonoidHom.{u2, u3} S (LinearEquiv.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_2 _inst_2 _inst_3 _inst_3) (Monoid.toMulOneClass.{u2} S (DivInvMonoid.toMonoid.{u2} S (Group.toDivInvMonoid.{u2} S _inst_4))) (Monoid.toMulOneClass.{u3} (LinearEquiv.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_2 _inst_2 _inst_3 _inst_3) (DivInvMonoid.toMonoid.{u3} (LinearEquiv.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_2 _inst_2 _inst_3 _inst_3) (Group.toDivInvMonoid.{u3} (LinearEquiv.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_2 _inst_2 _inst_3 _inst_3) (LinearEquiv.automorphismGroup.{u1, u3} R M _inst_1 _inst_2 _inst_3))))
but is expected to have type
  forall (R : Type.{u1}) {S : Type.{u2}} (M : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] [_inst_4 : Group.{u2} S] [_inst_5 : DistribMulAction.{u2, u3} S M (DivInvMonoid.toMonoid.{u2} S (Group.toDivInvMonoid.{u2} S _inst_4)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_6 : SMulCommClass.{u2, u1, u3} S R M (SMulZeroClass.toSMul.{u2, u3} S M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribSMul.toSMulZeroClass.{u2, u3} S M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u2, u3} S M (DivInvMonoid.toMonoid.{u2} S (Group.toDivInvMonoid.{u2} S _inst_4)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5))) (SMulZeroClass.toSMul.{u1, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u3} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_2 _inst_3))))], MonoidHom.{u2, u3} S (LinearEquiv.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_2 _inst_2 _inst_3 _inst_3) (Monoid.toMulOneClass.{u2} S (DivInvMonoid.toMonoid.{u2} S (Group.toDivInvMonoid.{u2} S _inst_4))) (Monoid.toMulOneClass.{u3} (LinearEquiv.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_2 _inst_2 _inst_3 _inst_3) (DivInvMonoid.toMonoid.{u3} (LinearEquiv.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_2 _inst_2 _inst_3 _inst_3) (Group.toDivInvMonoid.{u3} (LinearEquiv.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M _inst_2 _inst_2 _inst_3 _inst_3) (LinearEquiv.automorphismGroup.{u1, u3} R M _inst_1 _inst_2 _inst_3))))
Case conversion may be inaccurate. Consider using '#align distrib_mul_action.to_module_aut DistribMulAction.toModuleAutₓ'. -/
/-- Each element of the group defines a module automorphism.

This is a stronger version of `distrib_mul_action.to_add_aut`. -/
@[simps]
def toModuleAut : S →* M ≃ₗ[R] M where
  toFun := toLinearEquiv R M
  map_one' := LinearEquiv.ext <| one_smul _
  map_mul' a b := LinearEquiv.ext <| mul_smul _ _
#align distrib_mul_action.to_module_aut DistribMulAction.toModuleAut

end DistribMulAction

namespace AddEquiv

section AddCommMonoid

variable [Semiring R] [AddCommMonoid M] [AddCommMonoid M₂] [AddCommMonoid M₃]

variable [Module R M] [Module R M₂]

variable (e : M ≃+ M₂)

/- warning: add_equiv.to_linear_equiv -> AddEquiv.toLinearEquiv is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_5 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_6 : Module.{u1, u3} R M₂ _inst_1 _inst_3] (e : AddEquiv.{u2, u3} M M₂ (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toHasAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))), (forall (c : R) (x : M), Eq.{succ u3} M₂ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AddEquiv.{u2, u3} M M₂ (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toHasAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) (fun (_x : AddEquiv.{u2, u3} M M₂ (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toHasAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) => M -> M₂) (AddEquiv.hasCoeToFun.{u2, u3} M M₂ (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toHasAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) e (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_5)))) c x)) (SMul.smul.{u1, u3} R M₂ (SMulZeroClass.toHasSmul.{u1, u3} R M₂ (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M₂ (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M₂ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))) (Module.toMulActionWithZero.{u1, u3} R M₂ _inst_1 _inst_3 _inst_6)))) c (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AddEquiv.{u2, u3} M M₂ (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toHasAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) (fun (_x : AddEquiv.{u2, u3} M M₂ (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toHasAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) => M -> M₂) (AddEquiv.hasCoeToFun.{u2, u3} M M₂ (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toHasAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) e x))) -> (LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 _inst_5 _inst_6)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_5 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_6 : Module.{u1, u3} R M₂ _inst_1 _inst_3] (e : AddEquiv.{u2, u3} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))), (forall (c : R) (x : M), Eq.{succ u3} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_5))))) c x)) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (AddEquiv.{u2, u3} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u3), succ u2, succ u3} (AddEquiv.{u2, u3} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) M M₂ (EquivLike.toEmbeddingLike.{max (succ u2) (succ u3), succ u2, succ u3} (AddEquiv.{u2, u3} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) M M₂ (AddEquivClass.toEquivLike.{max u2 u3, u2, u3} (AddEquiv.{u2, u3} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))) (AddEquiv.instAddEquivClassAddEquiv.{u2, u3} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))))))) e (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_5))))) c x)) (HSMul.hSMul.{u1, u3, u3} R ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (instHSMul.{u1, u3} R ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (SMulZeroClass.toSMul.{u1, u3} R ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (AddMonoid.toZero.{u3} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (AddCommMonoid.toAddMonoid.{u3} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) _inst_3)) (SMulWithZero.toSMulZeroClass.{u1, u3} R ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u3} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (AddCommMonoid.toAddMonoid.{u3} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) _inst_3)) (MulActionWithZero.toSMulWithZero.{u1, u3} R ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u3} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (AddCommMonoid.toAddMonoid.{u3} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) _inst_3)) (Module.toMulActionWithZero.{u1, u3} R ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) _inst_1 _inst_3 _inst_6))))) c (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (AddEquiv.{u2, u3} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u3), succ u2, succ u3} (AddEquiv.{u2, u3} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) M M₂ (EquivLike.toEmbeddingLike.{max (succ u2) (succ u3), succ u2, succ u3} (AddEquiv.{u2, u3} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) M M₂ (AddEquivClass.toEquivLike.{max u2 u3, u2, u3} (AddEquiv.{u2, u3} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))) (AddEquiv.instAddEquivClassAddEquiv.{u2, u3} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))))))) e x))) -> (LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 _inst_5 _inst_6)
Case conversion may be inaccurate. Consider using '#align add_equiv.to_linear_equiv AddEquiv.toLinearEquivₓ'. -/
/-- An additive equivalence whose underlying function preserves `smul` is a linear equivalence. -/
def toLinearEquiv (h : ∀ (c : R) (x), e (c • x) = c • e x) : M ≃ₗ[R] M₂ :=
  { e with map_smul' := h }
#align add_equiv.to_linear_equiv AddEquiv.toLinearEquiv

/- warning: add_equiv.coe_to_linear_equiv -> AddEquiv.coe_toLinearEquiv is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_5 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_6 : Module.{u1, u3} R M₂ _inst_1 _inst_3] (e : AddEquiv.{u2, u3} M M₂ (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toHasAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) (h : forall (c : R) (x : M), Eq.{succ u3} M₂ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AddEquiv.{u2, u3} M M₂ (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toHasAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) (fun (_x : AddEquiv.{u2, u3} M M₂ (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toHasAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) => M -> M₂) (AddEquiv.hasCoeToFun.{u2, u3} M M₂ (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toHasAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) e (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_5)))) c x)) (SMul.smul.{u1, u3} R M₂ (SMulZeroClass.toHasSmul.{u1, u3} R M₂ (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M₂ (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M₂ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))) (Module.toMulActionWithZero.{u1, u3} R M₂ _inst_1 _inst_3 _inst_6)))) c (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AddEquiv.{u2, u3} M M₂ (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toHasAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) (fun (_x : AddEquiv.{u2, u3} M M₂ (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toHasAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) => M -> M₂) (AddEquiv.hasCoeToFun.{u2, u3} M M₂ (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toHasAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) e x))), Eq.{max (succ u2) (succ u3)} (M -> M₂) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 _inst_5 _inst_6) (fun (_x : LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 _inst_5 _inst_6) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)) (AddEquiv.toLinearEquiv.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 e h)) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AddEquiv.{u2, u3} M M₂ (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toHasAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) (fun (_x : AddEquiv.{u2, u3} M M₂ (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toHasAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) => M -> M₂) (AddEquiv.hasCoeToFun.{u2, u3} M M₂ (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toHasAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) e)
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_5 : Module.{u2, u1} R M _inst_1 _inst_2] [_inst_6 : Module.{u2, u3} R M₂ _inst_1 _inst_3] (e : AddEquiv.{u1, u3} M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) (h : forall (c : R) (x : M), Eq.{succ u3} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 _inst_5))))) c x)) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (AddEquiv.{u1, u3} M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u3), succ u1, succ u3} (AddEquiv.{u1, u3} M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) M M₂ (EquivLike.toEmbeddingLike.{max (succ u1) (succ u3), succ u1, succ u3} (AddEquiv.{u1, u3} M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) M M₂ (AddEquivClass.toEquivLike.{max u1 u3, u1, u3} (AddEquiv.{u1, u3} M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))) (AddEquiv.instAddEquivClassAddEquiv.{u1, u3} M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))))))) e (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 _inst_5))))) c x)) (HSMul.hSMul.{u2, u3, u3} R ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (instHSMul.{u2, u3} R ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (SMulZeroClass.toSMul.{u2, u3} R ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (AddMonoid.toZero.{u3} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (AddCommMonoid.toAddMonoid.{u3} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) _inst_3)) (SMulWithZero.toSMulZeroClass.{u2, u3} R ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u3} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (AddCommMonoid.toAddMonoid.{u3} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) _inst_3)) (MulActionWithZero.toSMulWithZero.{u2, u3} R ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u3} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (AddCommMonoid.toAddMonoid.{u3} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) _inst_3)) (Module.toMulActionWithZero.{u2, u3} R ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) _inst_1 _inst_3 _inst_6))))) c (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (AddEquiv.{u1, u3} M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u3), succ u1, succ u3} (AddEquiv.{u1, u3} M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) M M₂ (EquivLike.toEmbeddingLike.{max (succ u1) (succ u3), succ u1, succ u3} (AddEquiv.{u1, u3} M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) M M₂ (AddEquivClass.toEquivLike.{max u1 u3, u1, u3} (AddEquiv.{u1, u3} M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))) (AddEquiv.instAddEquivClassAddEquiv.{u1, u3} M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))))))) e x))), Eq.{max (succ u1) (succ u3)} (forall (ᾰ : M), (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M) => M₂) ᾰ) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (LinearEquiv.{u2, u2, u1, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) M M₂ _inst_2 _inst_3 _inst_5 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M) => M₂) _x) (SMulHomClass.toFunLike.{max u1 u3, u2, u1, u3} (LinearEquiv.{u2, u2, u1, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) M M₂ _inst_2 _inst_3 _inst_5 _inst_6) R M M₂ (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (DistribSMul.toSMulZeroClass.{u2, u1} R M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (DistribMulAction.toDistribSMul.{u2, u1} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M _inst_2) (Module.toDistribMulAction.{u2, u1} R M _inst_1 _inst_2 _inst_5)))) (SMulZeroClass.toSMul.{u2, u3} R M₂ (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)) (DistribSMul.toSMulZeroClass.{u2, u3} R M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)) (DistribMulAction.toDistribSMul.{u2, u3} R M₂ (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u2, u3} R M₂ _inst_1 _inst_3 _inst_6)))) (DistribMulActionHomClass.toSMulHomClass.{max u1 u3, u2, u1, u3} (LinearEquiv.{u2, u2, u1, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) M M₂ _inst_2 _inst_3 _inst_5 _inst_6) R M M₂ (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M _inst_2) (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u2, u1} R M _inst_1 _inst_2 _inst_5) (Module.toDistribMulAction.{u2, u3} R M₂ _inst_1 _inst_3 _inst_6) (SemilinearMapClass.distribMulActionHomClass.{u2, u1, u3, max u1 u3} R M M₂ (LinearEquiv.{u2, u2, u1, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) M M₂ _inst_2 _inst_3 _inst_5 _inst_6) _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 (SemilinearEquivClass.instSemilinearMapClass.{u2, u2, u1, u3, max u1 u3} R R M M₂ (LinearEquiv.{u2, u2, u1, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) M M₂ _inst_2 _inst_3 _inst_5 _inst_6) _inst_1 _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u2, u1, u3} R R M M₂ _inst_1 _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1)))))) (AddEquiv.toLinearEquiv.{u2, u1, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 e h)) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (AddEquiv.{u1, u3} M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u3), succ u1, succ u3} (AddEquiv.{u1, u3} M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) M M₂ (EquivLike.toEmbeddingLike.{max (succ u1) (succ u3), succ u1, succ u3} (AddEquiv.{u1, u3} M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) M M₂ (AddEquivClass.toEquivLike.{max u1 u3, u1, u3} (AddEquiv.{u1, u3} M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))) (AddEquiv.instAddEquivClassAddEquiv.{u1, u3} M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))))))) e)
Case conversion may be inaccurate. Consider using '#align add_equiv.coe_to_linear_equiv AddEquiv.coe_toLinearEquivₓ'. -/
@[simp]
theorem coe_toLinearEquiv (h : ∀ (c : R) (x), e (c • x) = c • e x) : ⇑(e.toLinearEquiv h) = e :=
  rfl
#align add_equiv.coe_to_linear_equiv AddEquiv.coe_toLinearEquiv

/- warning: add_equiv.coe_to_linear_equiv_symm -> AddEquiv.coe_toLinearEquiv_symm is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_5 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_6 : Module.{u1, u3} R M₂ _inst_1 _inst_3] (e : AddEquiv.{u2, u3} M M₂ (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toHasAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) (h : forall (c : R) (x : M), Eq.{succ u3} M₂ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AddEquiv.{u2, u3} M M₂ (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toHasAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) (fun (_x : AddEquiv.{u2, u3} M M₂ (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toHasAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) => M -> M₂) (AddEquiv.hasCoeToFun.{u2, u3} M M₂ (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toHasAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) e (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_5)))) c x)) (SMul.smul.{u1, u3} R M₂ (SMulZeroClass.toHasSmul.{u1, u3} R M₂ (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M₂ (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M₂ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))) (Module.toMulActionWithZero.{u1, u3} R M₂ _inst_1 _inst_3 _inst_6)))) c (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AddEquiv.{u2, u3} M M₂ (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toHasAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) (fun (_x : AddEquiv.{u2, u3} M M₂ (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toHasAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) => M -> M₂) (AddEquiv.hasCoeToFun.{u2, u3} M M₂ (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toHasAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) e x))), Eq.{max (succ u3) (succ u2)} (M₂ -> M) (coeFn.{max (succ u3) (succ u2), max (succ u3) (succ u2)} (LinearEquiv.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M _inst_3 _inst_2 _inst_6 _inst_5) (fun (_x : LinearEquiv.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M _inst_3 _inst_2 _inst_6 _inst_5) => M₂ -> M) (LinearEquiv.hasCoeToFun.{u1, u1, u3, u2} R R M₂ M _inst_1 _inst_1 _inst_3 _inst_2 _inst_6 _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)) (LinearEquiv.symm.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (AddEquiv.toLinearEquiv.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 e h))) (coeFn.{max (succ u3) (succ u2), max (succ u3) (succ u2)} (AddEquiv.{u3, u2} M₂ M (AddZeroClass.toHasAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))) (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (fun (_x : AddEquiv.{u3, u2} M₂ M (AddZeroClass.toHasAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))) (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) => M₂ -> M) (AddEquiv.hasCoeToFun.{u3, u2} M₂ M (AddZeroClass.toHasAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))) (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (AddEquiv.symm.{u2, u3} M M₂ (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toHasAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))) e))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_5 : Module.{u2, u1} R M _inst_1 _inst_2] [_inst_6 : Module.{u2, u3} R M₂ _inst_1 _inst_3] (e : AddEquiv.{u1, u3} M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) (h : forall (c : R) (x : M), Eq.{succ u3} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 _inst_5))))) c x)) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (AddEquiv.{u1, u3} M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u3), succ u1, succ u3} (AddEquiv.{u1, u3} M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) M M₂ (EquivLike.toEmbeddingLike.{max (succ u1) (succ u3), succ u1, succ u3} (AddEquiv.{u1, u3} M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) M M₂ (AddEquivClass.toEquivLike.{max u1 u3, u1, u3} (AddEquiv.{u1, u3} M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))) (AddEquiv.instAddEquivClassAddEquiv.{u1, u3} M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))))))) e (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 _inst_5))))) c x)) (HSMul.hSMul.{u2, u3, u3} R ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (instHSMul.{u2, u3} R ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (SMulZeroClass.toSMul.{u2, u3} R ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (AddMonoid.toZero.{u3} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (AddCommMonoid.toAddMonoid.{u3} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) _inst_3)) (SMulWithZero.toSMulZeroClass.{u2, u3} R ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u3} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (AddCommMonoid.toAddMonoid.{u3} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) _inst_3)) (MulActionWithZero.toSMulWithZero.{u2, u3} R ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u3} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) (AddCommMonoid.toAddMonoid.{u3} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) _inst_3)) (Module.toMulActionWithZero.{u2, u3} R ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) x) _inst_1 _inst_3 _inst_6))))) c (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (AddEquiv.{u1, u3} M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u3), succ u1, succ u3} (AddEquiv.{u1, u3} M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) M M₂ (EquivLike.toEmbeddingLike.{max (succ u1) (succ u3), succ u1, succ u3} (AddEquiv.{u1, u3} M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) M M₂ (AddEquivClass.toEquivLike.{max u1 u3, u1, u3} (AddEquiv.{u1, u3} M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))) (AddEquiv.instAddEquivClassAddEquiv.{u1, u3} M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))))))) e x))), Eq.{max (succ u1) (succ u3)} (forall (ᾰ : M₂), (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M₂) => M) ᾰ) (FunLike.coe.{max (succ u1) (succ u3), succ u3, succ u1} (LinearEquiv.{u2, u2, u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) M₂ M _inst_3 _inst_2 _inst_6 _inst_5) M₂ (fun (_x : M₂) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M₂) => M) _x) (SMulHomClass.toFunLike.{max u1 u3, u2, u3, u1} (LinearEquiv.{u2, u2, u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) M₂ M _inst_3 _inst_2 _inst_6 _inst_5) R M₂ M (SMulZeroClass.toSMul.{u2, u3} R M₂ (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)) (DistribSMul.toSMulZeroClass.{u2, u3} R M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)) (DistribMulAction.toDistribSMul.{u2, u3} R M₂ (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u2, u3} R M₂ _inst_1 _inst_3 _inst_6)))) (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (DistribSMul.toSMulZeroClass.{u2, u1} R M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (DistribMulAction.toDistribSMul.{u2, u1} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M _inst_2) (Module.toDistribMulAction.{u2, u1} R M _inst_1 _inst_2 _inst_5)))) (DistribMulActionHomClass.toSMulHomClass.{max u1 u3, u2, u3, u1} (LinearEquiv.{u2, u2, u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) M₂ M _inst_3 _inst_2 _inst_6 _inst_5) R M₂ M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (AddCommMonoid.toAddMonoid.{u1} M _inst_2) (Module.toDistribMulAction.{u2, u3} R M₂ _inst_1 _inst_3 _inst_6) (Module.toDistribMulAction.{u2, u1} R M _inst_1 _inst_2 _inst_5) (SemilinearMapClass.distribMulActionHomClass.{u2, u3, u1, max u1 u3} R M₂ M (LinearEquiv.{u2, u2, u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) M₂ M _inst_3 _inst_2 _inst_6 _inst_5) _inst_1 _inst_3 _inst_2 _inst_6 _inst_5 (SemilinearEquivClass.instSemilinearMapClass.{u2, u2, u3, u1, max u1 u3} R R M₂ M (LinearEquiv.{u2, u2, u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) M₂ M _inst_3 _inst_2 _inst_6 _inst_5) _inst_1 _inst_1 _inst_3 _inst_2 _inst_6 _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u2, u3, u1} R R M₂ M _inst_1 _inst_1 _inst_3 _inst_2 _inst_6 _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1)))))) (LinearEquiv.symm.{u2, u2, u1, u3} R R M M₂ _inst_1 _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (AddEquiv.toLinearEquiv.{u2, u1, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 e h))) (FunLike.coe.{max (succ u1) (succ u3), succ u3, succ u1} (AddEquiv.{u3, u1} M₂ M (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))) (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)))) M₂ (fun (_x : M₂) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M₂) => M) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u3), succ u3, succ u1} (AddEquiv.{u3, u1} M₂ M (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))) (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)))) M₂ M (EquivLike.toEmbeddingLike.{max (succ u1) (succ u3), succ u3, succ u1} (AddEquiv.{u3, u1} M₂ M (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))) (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)))) M₂ M (AddEquivClass.toEquivLike.{max u1 u3, u3, u1} (AddEquiv.{u3, u1} M₂ M (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))) (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)))) M₂ M (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))) (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddEquiv.instAddEquivClassAddEquiv.{u3, u1} M₂ M (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))) (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))))))) (AddEquiv.symm.{u1, u3} M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))) e))
Case conversion may be inaccurate. Consider using '#align add_equiv.coe_to_linear_equiv_symm AddEquiv.coe_toLinearEquiv_symmₓ'. -/
@[simp]
theorem coe_toLinearEquiv_symm (h : ∀ (c : R) (x), e (c • x) = c • e x) :
    ⇑(e.toLinearEquiv h).symm = e.symm :=
  rfl
#align add_equiv.coe_to_linear_equiv_symm AddEquiv.coe_toLinearEquiv_symm

/- warning: add_equiv.to_nat_linear_equiv -> AddEquiv.toNatLinearEquiv is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {M₂ : Type.{u2}} [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : AddCommMonoid.{u2} M₂], (AddEquiv.{u1, u2} M M₂ (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_3)))) -> (LinearEquiv.{0, 0, u1, u2} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) M M₂ _inst_2 _inst_3 (AddCommMonoid.natModule.{u1} M _inst_2) (AddCommMonoid.natModule.{u2} M₂ _inst_3))
but is expected to have type
  forall {M : Type.{u1}} {M₂ : Type.{u2}} [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : AddCommMonoid.{u2} M₂], (AddEquiv.{u1, u2} M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_3)))) -> (LinearEquiv.{0, 0, u1, u2} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) M M₂ _inst_2 _inst_3 (AddCommMonoid.natModule.{u1} M _inst_2) (AddCommMonoid.natModule.{u2} M₂ _inst_3))
Case conversion may be inaccurate. Consider using '#align add_equiv.to_nat_linear_equiv AddEquiv.toNatLinearEquivₓ'. -/
/-- An additive equivalence between commutative additive monoids is a linear equivalence between
ℕ-modules -/
def toNatLinearEquiv : M ≃ₗ[ℕ] M₂ :=
  e.toLinearEquiv fun c a => by
    erw [e.to_add_monoid_hom.map_nsmul]
    rfl
#align add_equiv.to_nat_linear_equiv AddEquiv.toNatLinearEquiv

/- warning: add_equiv.coe_to_nat_linear_equiv -> AddEquiv.coe_toNatLinearEquiv is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {M₂ : Type.{u2}} [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : AddCommMonoid.{u2} M₂] (e : AddEquiv.{u1, u2} M M₂ (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_3)))), Eq.{max (succ u1) (succ u2)} (M -> M₂) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearEquiv.{0, 0, u1, u2} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) M M₂ _inst_2 _inst_3 (AddCommMonoid.natModule.{u1} M _inst_2) (AddCommMonoid.natModule.{u2} M₂ _inst_3)) (fun (_x : LinearEquiv.{0, 0, u1, u2} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) M M₂ _inst_2 _inst_3 (AddCommMonoid.natModule.{u1} M _inst_2) (AddCommMonoid.natModule.{u2} M₂ _inst_3)) => M -> M₂) (LinearEquiv.hasCoeToFun.{0, 0, u1, u2} Nat Nat M M₂ Nat.semiring Nat.semiring _inst_2 _inst_3 (AddCommMonoid.natModule.{u1} M _inst_2) (AddCommMonoid.natModule.{u2} M₂ _inst_3) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring)) (AddEquiv.toNatLinearEquiv.{u1, u2} M M₂ _inst_2 _inst_3 e)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddEquiv.{u1, u2} M M₂ (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_3)))) (fun (_x : AddEquiv.{u1, u2} M M₂ (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_3)))) => M -> M₂) (AddEquiv.hasCoeToFun.{u1, u2} M M₂ (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_3)))) e)
but is expected to have type
  forall {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u1} M₂] (e : AddEquiv.{u2, u1} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_3)))), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : M), (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M) => M₂) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearEquiv.{0, 0, u2, u1} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) M M₂ _inst_2 _inst_3 (AddCommMonoid.natModule.{u2} M _inst_2) (AddCommMonoid.natModule.{u1} M₂ _inst_3)) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M) => M₂) _x) (SMulHomClass.toFunLike.{max u2 u1, 0, u2, u1} (LinearEquiv.{0, 0, u2, u1} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) M M₂ _inst_2 _inst_3 (AddCommMonoid.natModule.{u2} M _inst_2) (AddCommMonoid.natModule.{u1} M₂ _inst_3)) Nat M M₂ (SMulZeroClass.toSMul.{0, u2} Nat M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribSMul.toSMulZeroClass.{0, u2} Nat M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{0, u2} Nat M (MonoidWithZero.toMonoid.{0} Nat (Semiring.toMonoidWithZero.{0} Nat Nat.semiring)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{0, u2} Nat M Nat.semiring _inst_2 (AddCommMonoid.natModule.{u2} M _inst_2))))) (SMulZeroClass.toSMul.{0, u1} Nat M₂ (AddMonoid.toZero.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_3)) (DistribSMul.toSMulZeroClass.{0, u1} Nat M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_3)) (DistribMulAction.toDistribSMul.{0, u1} Nat M₂ (MonoidWithZero.toMonoid.{0} Nat (Semiring.toMonoidWithZero.{0} Nat Nat.semiring)) (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_3) (Module.toDistribMulAction.{0, u1} Nat M₂ Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M₂ _inst_3))))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, 0, u2, u1} (LinearEquiv.{0, 0, u2, u1} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) M M₂ _inst_2 _inst_3 (AddCommMonoid.natModule.{u2} M _inst_2) (AddCommMonoid.natModule.{u1} M₂ _inst_3)) Nat M M₂ (MonoidWithZero.toMonoid.{0} Nat (Semiring.toMonoidWithZero.{0} Nat Nat.semiring)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_3) (Module.toDistribMulAction.{0, u2} Nat M Nat.semiring _inst_2 (AddCommMonoid.natModule.{u2} M _inst_2)) (Module.toDistribMulAction.{0, u1} Nat M₂ Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M₂ _inst_3)) (SemilinearMapClass.distribMulActionHomClass.{0, u2, u1, max u2 u1} Nat M M₂ (LinearEquiv.{0, 0, u2, u1} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) M M₂ _inst_2 _inst_3 (AddCommMonoid.natModule.{u2} M _inst_2) (AddCommMonoid.natModule.{u1} M₂ _inst_3)) Nat.semiring _inst_2 _inst_3 (AddCommMonoid.natModule.{u2} M _inst_2) (AddCommMonoid.natModule.{u1} M₂ _inst_3) (SemilinearEquivClass.instSemilinearMapClass.{0, 0, u2, u1, max u2 u1} Nat Nat M M₂ (LinearEquiv.{0, 0, u2, u1} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) M M₂ _inst_2 _inst_3 (AddCommMonoid.natModule.{u2} M _inst_2) (AddCommMonoid.natModule.{u1} M₂ _inst_3)) Nat.semiring Nat.semiring _inst_2 _inst_3 (AddCommMonoid.natModule.{u2} M _inst_2) (AddCommMonoid.natModule.{u1} M₂ _inst_3) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{0, 0, u2, u1} Nat Nat M M₂ Nat.semiring Nat.semiring _inst_2 _inst_3 (AddCommMonoid.natModule.{u2} M _inst_2) (AddCommMonoid.natModule.{u1} M₂ _inst_3) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring)))))) (AddEquiv.toNatLinearEquiv.{u2, u1} M M₂ _inst_2 _inst_3 e)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AddEquiv.{u2, u1} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_3)))) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (AddEquiv.{u2, u1} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_3)))) M M₂ (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (AddEquiv.{u2, u1} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_3)))) M M₂ (AddEquivClass.toEquivLike.{max u2 u1, u2, u1} (AddEquiv.{u2, u1} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_3)))) M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_3))) (AddEquiv.instAddEquivClassAddEquiv.{u2, u1} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_3))))))) e)
Case conversion may be inaccurate. Consider using '#align add_equiv.coe_to_nat_linear_equiv AddEquiv.coe_toNatLinearEquivₓ'. -/
@[simp]
theorem coe_toNatLinearEquiv : ⇑e.toNatLinearEquiv = e :=
  rfl
#align add_equiv.coe_to_nat_linear_equiv AddEquiv.coe_toNatLinearEquiv

/- warning: add_equiv.to_nat_linear_equiv_to_add_equiv -> AddEquiv.toNatLinearEquiv_toAddEquiv is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {M₂ : Type.{u2}} [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : AddCommMonoid.{u2} M₂] (e : AddEquiv.{u1, u2} M M₂ (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_3)))), Eq.{max (succ u1) (succ u2)} (AddEquiv.{u1, u2} M M₂ (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_3)))) (LinearEquiv.toAddEquiv.{0, 0, u1, u2} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) M M₂ _inst_2 _inst_3 (AddCommMonoid.natModule.{u1} M _inst_2) (AddCommMonoid.natModule.{u2} M₂ _inst_3) (AddEquiv.toNatLinearEquiv.{u1, u2} M M₂ _inst_2 _inst_3 e)) e
but is expected to have type
  forall {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u1} M₂] (e : AddEquiv.{u2, u1} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_3)))), Eq.{max (succ u2) (succ u1)} (AddEquiv.{u2, u1} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_3)))) (AddEquivClass.toAddEquiv.{max u2 u1, u2, u1} (LinearEquiv.{0, 0, u2, u1} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) M M₂ _inst_2 _inst_3 (AddCommMonoid.natModule.{u2} M _inst_2) (AddCommMonoid.natModule.{u1} M₂ _inst_3)) M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_3))) (SemilinearEquivClass.toAddEquivClass.{max u2 u1, 0, 0, u2, u1} (LinearEquiv.{0, 0, u2, u1} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) M M₂ _inst_2 _inst_3 (AddCommMonoid.natModule.{u2} M _inst_2) (AddCommMonoid.natModule.{u1} M₂ _inst_3)) Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) M M₂ _inst_2 _inst_3 (AddCommMonoid.natModule.{u2} M _inst_2) (AddCommMonoid.natModule.{u1} M₂ _inst_3) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{0, 0, u2, u1} Nat Nat M M₂ Nat.semiring Nat.semiring _inst_2 _inst_3 (AddCommMonoid.natModule.{u2} M _inst_2) (AddCommMonoid.natModule.{u1} M₂ _inst_3) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring))) (AddEquiv.toNatLinearEquiv.{u2, u1} M M₂ _inst_2 _inst_3 e)) e
Case conversion may be inaccurate. Consider using '#align add_equiv.to_nat_linear_equiv_to_add_equiv AddEquiv.toNatLinearEquiv_toAddEquivₓ'. -/
@[simp]
theorem toNatLinearEquiv_toAddEquiv : e.toNatLinearEquiv.toAddEquiv = e :=
  by
  ext
  rfl
#align add_equiv.to_nat_linear_equiv_to_add_equiv AddEquiv.toNatLinearEquiv_toAddEquiv

/- warning: linear_equiv.to_add_equiv_to_nat_linear_equiv -> LinearEquiv.toAddEquiv_toNatLinearEquiv is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {M₂ : Type.{u2}} [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : AddCommMonoid.{u2} M₂] (e : LinearEquiv.{0, 0, u1, u2} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) M M₂ _inst_2 _inst_3 (AddCommMonoid.natModule.{u1} M _inst_2) (AddCommMonoid.natModule.{u2} M₂ _inst_3)), Eq.{max (succ u1) (succ u2)} (LinearEquiv.{0, 0, u1, u2} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) M M₂ _inst_2 _inst_3 (AddCommMonoid.natModule.{u1} M _inst_2) (AddCommMonoid.natModule.{u2} M₂ _inst_3)) (AddEquiv.toNatLinearEquiv.{u1, u2} M M₂ _inst_2 _inst_3 (LinearEquiv.toAddEquiv.{0, 0, u1, u2} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) M M₂ _inst_2 _inst_3 (AddCommMonoid.natModule.{u1} M _inst_2) (AddCommMonoid.natModule.{u2} M₂ _inst_3) e)) e
but is expected to have type
  forall {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u1} M₂] (e : LinearEquiv.{0, 0, u2, u1} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) M M₂ _inst_2 _inst_3 (AddCommMonoid.natModule.{u2} M _inst_2) (AddCommMonoid.natModule.{u1} M₂ _inst_3)), Eq.{max (succ u2) (succ u1)} (LinearEquiv.{0, 0, u2, u1} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) M M₂ _inst_2 _inst_3 (AddCommMonoid.natModule.{u2} M _inst_2) (AddCommMonoid.natModule.{u1} M₂ _inst_3)) (AddEquiv.toNatLinearEquiv.{u2, u1} M M₂ _inst_2 _inst_3 (AddEquivClass.toAddEquiv.{max u2 u1, u2, u1} (LinearEquiv.{0, 0, u2, u1} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) M M₂ _inst_2 _inst_3 (AddCommMonoid.natModule.{u2} M _inst_2) (AddCommMonoid.natModule.{u1} M₂ _inst_3)) M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_3))) (SemilinearEquivClass.toAddEquivClass.{max u2 u1, 0, 0, u2, u1} (LinearEquiv.{0, 0, u2, u1} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) M M₂ _inst_2 _inst_3 (AddCommMonoid.natModule.{u2} M _inst_2) (AddCommMonoid.natModule.{u1} M₂ _inst_3)) Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) M M₂ _inst_2 _inst_3 (AddCommMonoid.natModule.{u2} M _inst_2) (AddCommMonoid.natModule.{u1} M₂ _inst_3) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{0, 0, u2, u1} Nat Nat M M₂ Nat.semiring Nat.semiring _inst_2 _inst_3 (AddCommMonoid.natModule.{u2} M _inst_2) (AddCommMonoid.natModule.{u1} M₂ _inst_3) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring))) e)) e
Case conversion may be inaccurate. Consider using '#align linear_equiv.to_add_equiv_to_nat_linear_equiv LinearEquiv.toAddEquiv_toNatLinearEquivₓ'. -/
@[simp]
theorem LinearEquiv.toAddEquiv_toNatLinearEquiv (e : M ≃ₗ[ℕ] M₂) :
    e.toAddEquiv.toNatLinearEquiv = e :=
  FunLike.coe_injective rfl
#align linear_equiv.to_add_equiv_to_nat_linear_equiv LinearEquiv.toAddEquiv_toNatLinearEquiv

/- warning: add_equiv.to_nat_linear_equiv_symm -> AddEquiv.toNatLinearEquiv_symm is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {M₂ : Type.{u2}} [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : AddCommMonoid.{u2} M₂] (e : AddEquiv.{u1, u2} M M₂ (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_3)))), Eq.{max (succ u2) (succ u1)} (LinearEquiv.{0, 0, u2, u1} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) M₂ M _inst_3 _inst_2 (AddCommMonoid.natModule.{u2} M₂ _inst_3) (AddCommMonoid.natModule.{u1} M _inst_2)) (LinearEquiv.symm.{0, 0, u1, u2} Nat Nat M M₂ Nat.semiring Nat.semiring _inst_2 _inst_3 (AddCommMonoid.natModule.{u1} M _inst_2) (AddCommMonoid.natModule.{u2} M₂ _inst_3) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) (AddEquiv.toNatLinearEquiv.{u1, u2} M M₂ _inst_2 _inst_3 e)) (AddEquiv.toNatLinearEquiv.{u2, u1} M₂ M _inst_3 _inst_2 (AddEquiv.symm.{u1, u2} M M₂ (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_3))) e))
but is expected to have type
  forall {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u1} M₂] (e : AddEquiv.{u2, u1} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_3)))), Eq.{max (succ u2) (succ u1)} (LinearEquiv.{0, 0, u1, u2} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) M₂ M _inst_3 _inst_2 (AddCommMonoid.natModule.{u1} M₂ _inst_3) (AddCommMonoid.natModule.{u2} M _inst_2)) (LinearEquiv.symm.{0, 0, u2, u1} Nat Nat M M₂ Nat.semiring Nat.semiring _inst_2 _inst_3 (AddCommMonoid.natModule.{u2} M _inst_2) (AddCommMonoid.natModule.{u1} M₂ _inst_3) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) (AddEquiv.toNatLinearEquiv.{u2, u1} M M₂ _inst_2 _inst_3 e)) (AddEquiv.toNatLinearEquiv.{u1, u2} M₂ M _inst_3 _inst_2 (AddEquiv.symm.{u2, u1} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ _inst_3))) e))
Case conversion may be inaccurate. Consider using '#align add_equiv.to_nat_linear_equiv_symm AddEquiv.toNatLinearEquiv_symmₓ'. -/
@[simp]
theorem toNatLinearEquiv_symm : e.toNatLinearEquiv.symm = e.symm.toNatLinearEquiv :=
  rfl
#align add_equiv.to_nat_linear_equiv_symm AddEquiv.toNatLinearEquiv_symm

#print AddEquiv.toNatLinearEquiv_refl /-
@[simp]
theorem toNatLinearEquiv_refl : (AddEquiv.refl M).toNatLinearEquiv = LinearEquiv.refl ℕ M :=
  rfl
#align add_equiv.to_nat_linear_equiv_refl AddEquiv.toNatLinearEquiv_refl
-/

/- warning: add_equiv.to_nat_linear_equiv_trans -> AddEquiv.toNatLinearEquiv_trans is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {M₂ : Type.{u2}} {M₃ : Type.{u3}} [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : AddCommMonoid.{u2} M₂] [_inst_4 : AddCommMonoid.{u3} M₃] (e : AddEquiv.{u1, u2} M M₂ (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_3)))) (e₂ : AddEquiv.{u2, u3} M₂ M₃ (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_3))) (AddZeroClass.toHasAdd.{u3} M₃ (AddMonoid.toAddZeroClass.{u3} M₃ (AddCommMonoid.toAddMonoid.{u3} M₃ _inst_4)))), Eq.{max (succ u1) (succ u3)} (LinearEquiv.{0, 0, u1, u3} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) M M₃ _inst_2 _inst_4 (AddCommMonoid.natModule.{u1} M _inst_2) (AddCommMonoid.natModule.{u3} M₃ _inst_4)) (LinearEquiv.trans.{0, 0, 0, u1, u2, u3} Nat Nat Nat M M₂ M₃ Nat.semiring Nat.semiring Nat.semiring _inst_2 _inst_3 _inst_4 (AddCommMonoid.natModule.{u1} M _inst_2) (AddCommMonoid.natModule.{u2} M₂ _inst_3) (AddCommMonoid.natModule.{u3} M₃ _inst_4) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomCompTriple.right_ids.{0, 0} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring))) (RingHomCompTriple.right_ids.{0, 0} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring))) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) (AddEquiv.toNatLinearEquiv.{u1, u2} M M₂ _inst_2 _inst_3 e) (AddEquiv.toNatLinearEquiv.{u2, u3} M₂ M₃ _inst_3 _inst_4 e₂)) (AddEquiv.toNatLinearEquiv.{u1, u3} M M₃ _inst_2 _inst_4 (AddEquiv.trans.{u1, u2, u3} M M₂ M₃ (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_3))) (AddZeroClass.toHasAdd.{u3} M₃ (AddMonoid.toAddZeroClass.{u3} M₃ (AddCommMonoid.toAddMonoid.{u3} M₃ _inst_4))) e e₂))
but is expected to have type
  forall {M : Type.{u1}} {M₂ : Type.{u3}} {M₃ : Type.{u2}} [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : AddCommMonoid.{u2} M₃] (e : AddEquiv.{u1, u3} M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)))) (e₂ : AddEquiv.{u3, u2} M₂ M₃ (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))) (AddZeroClass.toAdd.{u2} M₃ (AddMonoid.toAddZeroClass.{u2} M₃ (AddCommMonoid.toAddMonoid.{u2} M₃ _inst_4)))), Eq.{max (succ u1) (succ u2)} (LinearEquiv.{0, 0, u1, u2} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) M M₃ _inst_2 _inst_4 (AddCommMonoid.natModule.{u1} M _inst_2) (AddCommMonoid.natModule.{u2} M₃ _inst_4)) (LinearEquiv.trans.{0, 0, 0, u1, u3, u2} Nat Nat Nat M M₂ M₃ Nat.semiring Nat.semiring Nat.semiring _inst_2 _inst_3 _inst_4 (AddCommMonoid.natModule.{u1} M _inst_2) (AddCommMonoid.natModule.{u3} M₂ _inst_3) (AddCommMonoid.natModule.{u2} M₃ _inst_4) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomCompTriple.ids.{0, 0} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring))) (RingHomCompTriple.ids.{0, 0} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring))) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) (AddEquiv.toNatLinearEquiv.{u1, u3} M M₂ _inst_2 _inst_3 e) (AddEquiv.toNatLinearEquiv.{u3, u2} M₂ M₃ _inst_3 _inst_4 e₂)) (AddEquiv.toNatLinearEquiv.{u1, u2} M M₃ _inst_2 _inst_4 (AddEquiv.trans.{u1, u3, u2} M M₂ M₃ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3))) (AddZeroClass.toAdd.{u2} M₃ (AddMonoid.toAddZeroClass.{u2} M₃ (AddCommMonoid.toAddMonoid.{u2} M₃ _inst_4))) e e₂))
Case conversion may be inaccurate. Consider using '#align add_equiv.to_nat_linear_equiv_trans AddEquiv.toNatLinearEquiv_transₓ'. -/
@[simp]
theorem toNatLinearEquiv_trans (e₂ : M₂ ≃+ M₃) :
    e.toNatLinearEquiv.trans e₂.toNatLinearEquiv = (e.trans e₂).toNatLinearEquiv :=
  rfl
#align add_equiv.to_nat_linear_equiv_trans AddEquiv.toNatLinearEquiv_trans

end AddCommMonoid

section AddCommGroup

variable [AddCommGroup M] [AddCommGroup M₂] [AddCommGroup M₃]

variable (e : M ≃+ M₂)

/- warning: add_equiv.to_int_linear_equiv -> AddEquiv.toIntLinearEquiv is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {M₂ : Type.{u2}} [_inst_1 : AddCommGroup.{u1} M] [_inst_2 : AddCommGroup.{u2} M₂], (AddEquiv.{u1, u2} M M₂ (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))))) (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2)))))) -> (LinearEquiv.{0, 0, u1, u2} Int Int Int.semiring Int.semiring (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) (RingHomInvPair.ids.{0} Int Int.semiring) (RingHomInvPair.ids.{0} Int Int.semiring) M M₂ (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2) (AddCommGroup.intModule.{u1} M _inst_1) (AddCommGroup.intModule.{u2} M₂ _inst_2))
but is expected to have type
  forall {M : Type.{u1}} {M₂ : Type.{u2}} [_inst_1 : AddCommGroup.{u1} M] [_inst_2 : AddCommGroup.{u2} M₂], (AddEquiv.{u1, u2} M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))))) (AddZeroClass.toAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2)))))) -> (LinearEquiv.{0, 0, u1, u2} Int Int Int.instSemiringInt Int.instSemiringInt (RingHom.id.{0} Int (NonAssocRing.toNonAssocSemiring.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt))) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt)) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) M M₂ (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2) (AddCommGroup.intModule.{u1} M _inst_1) (AddCommGroup.intModule.{u2} M₂ _inst_2))
Case conversion may be inaccurate. Consider using '#align add_equiv.to_int_linear_equiv AddEquiv.toIntLinearEquivₓ'. -/
/-- An additive equivalence between commutative additive groups is a linear
equivalence between ℤ-modules -/
def toIntLinearEquiv : M ≃ₗ[ℤ] M₂ :=
  e.toLinearEquiv fun c a => e.toAddMonoidHom.map_zsmul a c
#align add_equiv.to_int_linear_equiv AddEquiv.toIntLinearEquiv

/- warning: add_equiv.coe_to_int_linear_equiv -> AddEquiv.coe_toIntLinearEquiv is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {M₂ : Type.{u2}} [_inst_1 : AddCommGroup.{u1} M] [_inst_2 : AddCommGroup.{u2} M₂] (e : AddEquiv.{u1, u2} M M₂ (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))))) (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2)))))), Eq.{max (succ u1) (succ u2)} (M -> M₂) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearEquiv.{0, 0, u1, u2} Int Int Int.semiring Int.semiring (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) (RingHomInvPair.ids.{0} Int Int.semiring) (RingHomInvPair.ids.{0} Int Int.semiring) M M₂ (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2) (AddCommGroup.intModule.{u1} M _inst_1) (AddCommGroup.intModule.{u2} M₂ _inst_2)) (fun (_x : LinearEquiv.{0, 0, u1, u2} Int Int Int.semiring Int.semiring (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) (RingHomInvPair.ids.{0} Int Int.semiring) (RingHomInvPair.ids.{0} Int Int.semiring) M M₂ (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2) (AddCommGroup.intModule.{u1} M _inst_1) (AddCommGroup.intModule.{u2} M₂ _inst_2)) => M -> M₂) (LinearEquiv.hasCoeToFun.{0, 0, u1, u2} Int Int M M₂ Int.semiring Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2) (AddCommGroup.intModule.{u1} M _inst_1) (AddCommGroup.intModule.{u2} M₂ _inst_2) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) (RingHomInvPair.ids.{0} Int Int.semiring) (RingHomInvPair.ids.{0} Int Int.semiring)) (AddEquiv.toIntLinearEquiv.{u1, u2} M M₂ _inst_1 _inst_2 e)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddEquiv.{u1, u2} M M₂ (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))))) (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2)))))) (fun (_x : AddEquiv.{u1, u2} M M₂ (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))))) (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2)))))) => M -> M₂) (AddEquiv.hasCoeToFun.{u1, u2} M M₂ (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))))) (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2)))))) e)
but is expected to have type
  forall {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_1 : AddCommGroup.{u2} M] [_inst_2 : AddCommGroup.{u1} M₂] (e : AddEquiv.{u2, u1} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_1))))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (SubNegMonoid.toAddMonoid.{u1} M₂ (AddGroup.toSubNegMonoid.{u1} M₂ (AddCommGroup.toAddGroup.{u1} M₂ _inst_2)))))), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : M), (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M) => M₂) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearEquiv.{0, 0, u2, u1} Int Int Int.instSemiringInt Int.instSemiringInt (RingHom.id.{0} Int (NonAssocRing.toNonAssocSemiring.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt))) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt)) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_2) (AddCommGroup.intModule.{u2} M _inst_1) (AddCommGroup.intModule.{u1} M₂ _inst_2)) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M) => M₂) _x) (SMulHomClass.toFunLike.{max u2 u1, 0, u2, u1} (LinearEquiv.{0, 0, u2, u1} Int Int Int.instSemiringInt Int.instSemiringInt (RingHom.id.{0} Int (NonAssocRing.toNonAssocSemiring.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt))) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt)) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_2) (AddCommGroup.intModule.{u2} M _inst_1) (AddCommGroup.intModule.{u1} M₂ _inst_2)) Int M M₂ (SMulZeroClass.toSMul.{0, u2} Int M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_1))) (DistribSMul.toSMulZeroClass.{0, u2} Int M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_1))) (DistribMulAction.toDistribSMul.{0, u2} Int M (MonoidWithZero.toMonoid.{0} Int (Semiring.toMonoidWithZero.{0} Int Int.instSemiringInt)) (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_1)) (Module.toDistribMulAction.{0, u2} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (AddCommGroup.intModule.{u2} M _inst_1))))) (SMulZeroClass.toSMul.{0, u1} Int M₂ (AddMonoid.toZero.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_2))) (DistribSMul.toSMulZeroClass.{0, u1} Int M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (AddCommMonoid.toAddMonoid.{u1} M₂ (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_2))) (DistribMulAction.toDistribSMul.{0, u1} Int M₂ (MonoidWithZero.toMonoid.{0} Int (Semiring.toMonoidWithZero.{0} Int Int.instSemiringInt)) (AddCommMonoid.toAddMonoid.{u1} M₂ (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_2)) (Module.toDistribMulAction.{0, u1} Int M₂ Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_2) (AddCommGroup.intModule.{u1} M₂ _inst_2))))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, 0, u2, u1} (LinearEquiv.{0, 0, u2, u1} Int Int Int.instSemiringInt Int.instSemiringInt (RingHom.id.{0} Int (NonAssocRing.toNonAssocSemiring.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt))) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt)) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_2) (AddCommGroup.intModule.{u2} M _inst_1) (AddCommGroup.intModule.{u1} M₂ _inst_2)) Int M M₂ (MonoidWithZero.toMonoid.{0} Int (Semiring.toMonoidWithZero.{0} Int Int.instSemiringInt)) (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M₂ (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_2)) (Module.toDistribMulAction.{0, u2} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (AddCommGroup.intModule.{u2} M _inst_1)) (Module.toDistribMulAction.{0, u1} Int M₂ Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_2) (AddCommGroup.intModule.{u1} M₂ _inst_2)) (SemilinearMapClass.distribMulActionHomClass.{0, u2, u1, max u2 u1} Int M M₂ (LinearEquiv.{0, 0, u2, u1} Int Int Int.instSemiringInt Int.instSemiringInt (RingHom.id.{0} Int (NonAssocRing.toNonAssocSemiring.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt))) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt)) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_2) (AddCommGroup.intModule.{u2} M _inst_1) (AddCommGroup.intModule.{u1} M₂ _inst_2)) Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_2) (AddCommGroup.intModule.{u2} M _inst_1) (AddCommGroup.intModule.{u1} M₂ _inst_2) (SemilinearEquivClass.instSemilinearMapClass.{0, 0, u2, u1, max u2 u1} Int Int M M₂ (LinearEquiv.{0, 0, u2, u1} Int Int Int.instSemiringInt Int.instSemiringInt (RingHom.id.{0} Int (NonAssocRing.toNonAssocSemiring.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt))) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt)) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_2) (AddCommGroup.intModule.{u2} M _inst_1) (AddCommGroup.intModule.{u1} M₂ _inst_2)) Int.instSemiringInt Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_2) (AddCommGroup.intModule.{u2} M _inst_1) (AddCommGroup.intModule.{u1} M₂ _inst_2) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt)) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt)) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{0, 0, u2, u1} Int Int M M₂ Int.instSemiringInt Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_2) (AddCommGroup.intModule.{u2} M _inst_1) (AddCommGroup.intModule.{u1} M₂ _inst_2) (RingHom.id.{0} Int (NonAssocRing.toNonAssocSemiring.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt))) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt)) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) (RingHomInvPair.ids.{0} Int Int.instSemiringInt)))))) (AddEquiv.toIntLinearEquiv.{u2, u1} M M₂ _inst_1 _inst_2 e)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AddEquiv.{u2, u1} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_1))))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (SubNegMonoid.toAddMonoid.{u1} M₂ (AddGroup.toSubNegMonoid.{u1} M₂ (AddCommGroup.toAddGroup.{u1} M₂ _inst_2)))))) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M₂) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (AddEquiv.{u2, u1} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_1))))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (SubNegMonoid.toAddMonoid.{u1} M₂ (AddGroup.toSubNegMonoid.{u1} M₂ (AddCommGroup.toAddGroup.{u1} M₂ _inst_2)))))) M M₂ (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (AddEquiv.{u2, u1} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_1))))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (SubNegMonoid.toAddMonoid.{u1} M₂ (AddGroup.toSubNegMonoid.{u1} M₂ (AddCommGroup.toAddGroup.{u1} M₂ _inst_2)))))) M M₂ (AddEquivClass.toEquivLike.{max u2 u1, u2, u1} (AddEquiv.{u2, u1} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_1))))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (SubNegMonoid.toAddMonoid.{u1} M₂ (AddGroup.toSubNegMonoid.{u1} M₂ (AddCommGroup.toAddGroup.{u1} M₂ _inst_2)))))) M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_1))))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (SubNegMonoid.toAddMonoid.{u1} M₂ (AddGroup.toSubNegMonoid.{u1} M₂ (AddCommGroup.toAddGroup.{u1} M₂ _inst_2))))) (AddEquiv.instAddEquivClassAddEquiv.{u2, u1} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_1))))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (SubNegMonoid.toAddMonoid.{u1} M₂ (AddGroup.toSubNegMonoid.{u1} M₂ (AddCommGroup.toAddGroup.{u1} M₂ _inst_2))))))))) e)
Case conversion may be inaccurate. Consider using '#align add_equiv.coe_to_int_linear_equiv AddEquiv.coe_toIntLinearEquivₓ'. -/
@[simp]
theorem coe_toIntLinearEquiv : ⇑e.toIntLinearEquiv = e :=
  rfl
#align add_equiv.coe_to_int_linear_equiv AddEquiv.coe_toIntLinearEquiv

/- warning: add_equiv.to_int_linear_equiv_to_add_equiv -> AddEquiv.toIntLinearEquiv_toAddEquiv is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {M₂ : Type.{u2}} [_inst_1 : AddCommGroup.{u1} M] [_inst_2 : AddCommGroup.{u2} M₂] (e : AddEquiv.{u1, u2} M M₂ (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))))) (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2)))))), Eq.{max (succ u1) (succ u2)} (AddEquiv.{u1, u2} M M₂ (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (AddCommGroup.toAddCommMonoid.{u1} M _inst_1)))) (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2))))) (LinearEquiv.toAddEquiv.{0, 0, u1, u2} Int Int Int.semiring Int.semiring (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) (RingHomInvPair.ids.{0} Int Int.semiring) (RingHomInvPair.ids.{0} Int Int.semiring) M M₂ (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2) (AddCommGroup.intModule.{u1} M _inst_1) (AddCommGroup.intModule.{u2} M₂ _inst_2) (AddEquiv.toIntLinearEquiv.{u1, u2} M M₂ _inst_1 _inst_2 e)) e
but is expected to have type
  forall {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_1 : AddCommGroup.{u2} M] [_inst_2 : AddCommGroup.{u1} M₂] (e : AddEquiv.{u2, u1} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_1))))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (SubNegMonoid.toAddMonoid.{u1} M₂ (AddGroup.toSubNegMonoid.{u1} M₂ (AddCommGroup.toAddGroup.{u1} M₂ _inst_2)))))), Eq.{max (succ u2) (succ u1)} (AddEquiv.{u2, u1} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_1))))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (SubNegMonoid.toAddMonoid.{u1} M₂ (AddGroup.toSubNegMonoid.{u1} M₂ (AddCommGroup.toAddGroup.{u1} M₂ _inst_2)))))) (AddEquivClass.toAddEquiv.{max u2 u1, u2, u1} (LinearEquiv.{0, 0, u2, u1} Int Int Int.instSemiringInt Int.instSemiringInt (RingHom.id.{0} Int (NonAssocRing.toNonAssocSemiring.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt))) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt)) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_2) (AddCommGroup.intModule.{u2} M _inst_1) (AddCommGroup.intModule.{u1} M₂ _inst_2)) M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_1))))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (SubNegMonoid.toAddMonoid.{u1} M₂ (AddGroup.toSubNegMonoid.{u1} M₂ (AddCommGroup.toAddGroup.{u1} M₂ _inst_2))))) (SemilinearEquivClass.toAddEquivClass.{max u2 u1, 0, 0, u2, u1} (LinearEquiv.{0, 0, u2, u1} Int Int Int.instSemiringInt Int.instSemiringInt (RingHom.id.{0} Int (NonAssocRing.toNonAssocSemiring.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt))) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt)) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_2) (AddCommGroup.intModule.{u2} M _inst_1) (AddCommGroup.intModule.{u1} M₂ _inst_2)) Int Int Int.instSemiringInt Int.instSemiringInt (RingHom.id.{0} Int (NonAssocRing.toNonAssocSemiring.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt))) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt)) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_2) (AddCommGroup.intModule.{u2} M _inst_1) (AddCommGroup.intModule.{u1} M₂ _inst_2) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{0, 0, u2, u1} Int Int M M₂ Int.instSemiringInt Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_2) (AddCommGroup.intModule.{u2} M _inst_1) (AddCommGroup.intModule.{u1} M₂ _inst_2) (RingHom.id.{0} Int (NonAssocRing.toNonAssocSemiring.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt))) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt)) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) (RingHomInvPair.ids.{0} Int Int.instSemiringInt))) (AddEquiv.toIntLinearEquiv.{u2, u1} M M₂ _inst_1 _inst_2 e)) e
Case conversion may be inaccurate. Consider using '#align add_equiv.to_int_linear_equiv_to_add_equiv AddEquiv.toIntLinearEquiv_toAddEquivₓ'. -/
@[simp]
theorem toIntLinearEquiv_toAddEquiv : e.toIntLinearEquiv.toAddEquiv = e :=
  by
  ext
  rfl
#align add_equiv.to_int_linear_equiv_to_add_equiv AddEquiv.toIntLinearEquiv_toAddEquiv

/- warning: linear_equiv.to_add_equiv_to_int_linear_equiv -> LinearEquiv.toAddEquiv_toIntLinearEquiv is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {M₂ : Type.{u2}} [_inst_1 : AddCommGroup.{u1} M] [_inst_2 : AddCommGroup.{u2} M₂] (e : LinearEquiv.{0, 0, u1, u2} Int Int Int.semiring Int.semiring (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) (RingHomInvPair.ids.{0} Int Int.semiring) (RingHomInvPair.ids.{0} Int Int.semiring) M M₂ (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2) (AddCommGroup.intModule.{u1} M _inst_1) (AddCommGroup.intModule.{u2} M₂ _inst_2)), Eq.{max (succ u1) (succ u2)} (LinearEquiv.{0, 0, u1, u2} Int Int Int.semiring Int.semiring (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) (RingHomInvPair.ids.{0} Int Int.semiring) (RingHomInvPair.ids.{0} Int Int.semiring) M M₂ (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2) (AddCommGroup.intModule.{u1} M _inst_1) (AddCommGroup.intModule.{u2} M₂ _inst_2)) (AddEquiv.toIntLinearEquiv.{u1, u2} M M₂ _inst_1 _inst_2 (LinearEquiv.toAddEquiv.{0, 0, u1, u2} Int Int Int.semiring Int.semiring (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) (RingHomInvPair.ids.{0} Int Int.semiring) (RingHomInvPair.ids.{0} Int Int.semiring) M M₂ (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2) (AddCommGroup.intModule.{u1} M _inst_1) (AddCommGroup.intModule.{u2} M₂ _inst_2) e)) e
but is expected to have type
  forall {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_1 : AddCommGroup.{u2} M] [_inst_2 : AddCommGroup.{u1} M₂] (e : LinearEquiv.{0, 0, u2, u1} Int Int Int.instSemiringInt Int.instSemiringInt (RingHom.id.{0} Int (NonAssocRing.toNonAssocSemiring.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt))) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt)) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_2) (AddCommGroup.intModule.{u2} M _inst_1) (AddCommGroup.intModule.{u1} M₂ _inst_2)), Eq.{max (succ u2) (succ u1)} (LinearEquiv.{0, 0, u2, u1} Int Int Int.instSemiringInt Int.instSemiringInt (RingHom.id.{0} Int (NonAssocRing.toNonAssocSemiring.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt))) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt)) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_2) (AddCommGroup.intModule.{u2} M _inst_1) (AddCommGroup.intModule.{u1} M₂ _inst_2)) (AddEquiv.toIntLinearEquiv.{u2, u1} M M₂ _inst_1 _inst_2 (AddEquivClass.toAddEquiv.{max u2 u1, u2, u1} (LinearEquiv.{0, 0, u2, u1} Int Int Int.instSemiringInt Int.instSemiringInt (RingHom.id.{0} Int (NonAssocRing.toNonAssocSemiring.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt))) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt)) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_2) (AddCommGroup.intModule.{u2} M _inst_1) (AddCommGroup.intModule.{u1} M₂ _inst_2)) M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_1))))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (SubNegMonoid.toAddMonoid.{u1} M₂ (AddGroup.toSubNegMonoid.{u1} M₂ (AddCommGroup.toAddGroup.{u1} M₂ _inst_2))))) (SemilinearEquivClass.toAddEquivClass.{max u2 u1, 0, 0, u2, u1} (LinearEquiv.{0, 0, u2, u1} Int Int Int.instSemiringInt Int.instSemiringInt (RingHom.id.{0} Int (NonAssocRing.toNonAssocSemiring.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt))) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt)) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_2) (AddCommGroup.intModule.{u2} M _inst_1) (AddCommGroup.intModule.{u1} M₂ _inst_2)) Int Int Int.instSemiringInt Int.instSemiringInt (RingHom.id.{0} Int (NonAssocRing.toNonAssocSemiring.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt))) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt)) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_2) (AddCommGroup.intModule.{u2} M _inst_1) (AddCommGroup.intModule.{u1} M₂ _inst_2) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{0, 0, u2, u1} Int Int M M₂ Int.instSemiringInt Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_2) (AddCommGroup.intModule.{u2} M _inst_1) (AddCommGroup.intModule.{u1} M₂ _inst_2) (RingHom.id.{0} Int (NonAssocRing.toNonAssocSemiring.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt))) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt)) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) (RingHomInvPair.ids.{0} Int Int.instSemiringInt))) e)) e
Case conversion may be inaccurate. Consider using '#align linear_equiv.to_add_equiv_to_int_linear_equiv LinearEquiv.toAddEquiv_toIntLinearEquivₓ'. -/
@[simp]
theorem LinearEquiv.toAddEquiv_toIntLinearEquiv (e : M ≃ₗ[ℤ] M₂) :
    e.toAddEquiv.toIntLinearEquiv = e :=
  FunLike.coe_injective rfl
#align linear_equiv.to_add_equiv_to_int_linear_equiv LinearEquiv.toAddEquiv_toIntLinearEquiv

/- warning: add_equiv.to_int_linear_equiv_symm -> AddEquiv.toIntLinearEquiv_symm is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {M₂ : Type.{u2}} [_inst_1 : AddCommGroup.{u1} M] [_inst_2 : AddCommGroup.{u2} M₂] (e : AddEquiv.{u1, u2} M M₂ (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))))) (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2)))))), Eq.{max (succ u2) (succ u1)} (LinearEquiv.{0, 0, u2, u1} Int Int Int.semiring Int.semiring (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) (RingHomInvPair.ids.{0} Int Int.semiring) (RingHomInvPair.ids.{0} Int Int.semiring) M₂ M (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u2} M₂ _inst_2) (AddCommGroup.intModule.{u1} M _inst_1)) (LinearEquiv.symm.{0, 0, u1, u2} Int Int M M₂ Int.semiring Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2) (AddCommGroup.intModule.{u1} M _inst_1) (AddCommGroup.intModule.{u2} M₂ _inst_2) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) (RingHomInvPair.ids.{0} Int Int.semiring) (RingHomInvPair.ids.{0} Int Int.semiring) (AddEquiv.toIntLinearEquiv.{u1, u2} M M₂ _inst_1 _inst_2 e)) (AddEquiv.toIntLinearEquiv.{u2, u1} M₂ M _inst_2 _inst_1 (AddEquiv.symm.{u1, u2} M M₂ (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))))) (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2))))) e))
but is expected to have type
  forall {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_1 : AddCommGroup.{u2} M] [_inst_2 : AddCommGroup.{u1} M₂] (e : AddEquiv.{u2, u1} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_1))))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (SubNegMonoid.toAddMonoid.{u1} M₂ (AddGroup.toSubNegMonoid.{u1} M₂ (AddCommGroup.toAddGroup.{u1} M₂ _inst_2)))))), Eq.{max (succ u2) (succ u1)} (LinearEquiv.{0, 0, u1, u2} Int Int Int.instSemiringInt Int.instSemiringInt (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt)) (RingHom.id.{0} Int (NonAssocRing.toNonAssocSemiring.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt))) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) M₂ M (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (AddCommGroup.intModule.{u1} M₂ _inst_2) (AddCommGroup.intModule.{u2} M _inst_1)) (LinearEquiv.symm.{0, 0, u2, u1} Int Int M M₂ Int.instSemiringInt Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_2) (AddCommGroup.intModule.{u2} M _inst_1) (AddCommGroup.intModule.{u1} M₂ _inst_2) (RingHom.id.{0} Int (NonAssocRing.toNonAssocSemiring.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt))) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt)) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) (AddEquiv.toIntLinearEquiv.{u2, u1} M M₂ _inst_1 _inst_2 e)) (AddEquiv.toIntLinearEquiv.{u1, u2} M₂ M _inst_2 _inst_1 (AddEquiv.symm.{u2, u1} M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_1))))) (AddZeroClass.toAdd.{u1} M₂ (AddMonoid.toAddZeroClass.{u1} M₂ (SubNegMonoid.toAddMonoid.{u1} M₂ (AddGroup.toSubNegMonoid.{u1} M₂ (AddCommGroup.toAddGroup.{u1} M₂ _inst_2))))) e))
Case conversion may be inaccurate. Consider using '#align add_equiv.to_int_linear_equiv_symm AddEquiv.toIntLinearEquiv_symmₓ'. -/
@[simp]
theorem toIntLinearEquiv_symm : e.toIntLinearEquiv.symm = e.symm.toIntLinearEquiv :=
  rfl
#align add_equiv.to_int_linear_equiv_symm AddEquiv.toIntLinearEquiv_symm

/- warning: add_equiv.to_int_linear_equiv_refl -> AddEquiv.toIntLinearEquiv_refl is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : AddCommGroup.{u1} M], Eq.{succ u1} (LinearEquiv.{0, 0, u1, u1} Int Int Int.semiring Int.semiring (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) (RingHomInvPair.ids.{0} Int Int.semiring) (RingHomInvPair.ids.{0} Int Int.semiring) M M (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (AddEquiv.toIntLinearEquiv.{u1, u1} M M _inst_1 _inst_1 (AddEquiv.refl.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))))))) (LinearEquiv.refl.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : AddCommGroup.{u1} M], Eq.{succ u1} (LinearEquiv.{0, 0, u1, u1} Int Int Int.instSemiringInt Int.instSemiringInt (RingHom.id.{0} Int (NonAssocRing.toNonAssocSemiring.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt))) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt)) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) M M (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (AddEquiv.toIntLinearEquiv.{u1, u1} M M _inst_1 _inst_1 (AddEquiv.refl.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))))))) (LinearEquiv.refl.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1))
Case conversion may be inaccurate. Consider using '#align add_equiv.to_int_linear_equiv_refl AddEquiv.toIntLinearEquiv_reflₓ'. -/
@[simp]
theorem toIntLinearEquiv_refl : (AddEquiv.refl M).toIntLinearEquiv = LinearEquiv.refl ℤ M :=
  rfl
#align add_equiv.to_int_linear_equiv_refl AddEquiv.toIntLinearEquiv_refl

/- warning: add_equiv.to_int_linear_equiv_trans -> AddEquiv.toIntLinearEquiv_trans is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {M₂ : Type.{u2}} {M₃ : Type.{u3}} [_inst_1 : AddCommGroup.{u1} M] [_inst_2 : AddCommGroup.{u2} M₂] [_inst_3 : AddCommGroup.{u3} M₃] (e : AddEquiv.{u1, u2} M M₂ (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))))) (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2)))))) (e₂ : AddEquiv.{u2, u3} M₂ M₃ (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2))))) (AddZeroClass.toHasAdd.{u3} M₃ (AddMonoid.toAddZeroClass.{u3} M₃ (SubNegMonoid.toAddMonoid.{u3} M₃ (AddGroup.toSubNegMonoid.{u3} M₃ (AddCommGroup.toAddGroup.{u3} M₃ _inst_3)))))), Eq.{max (succ u1) (succ u3)} (LinearEquiv.{0, 0, u1, u3} Int Int Int.semiring Int.semiring (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) (RingHomInvPair.ids.{0} Int Int.semiring) (RingHomInvPair.ids.{0} Int Int.semiring) M M₃ (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M₃ _inst_3) (AddCommGroup.intModule.{u1} M _inst_1) (AddCommGroup.intModule.{u3} M₃ _inst_3)) (LinearEquiv.trans.{0, 0, 0, u1, u2, u3} Int Int Int M M₂ M₃ Int.semiring Int.semiring Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M₃ _inst_3) (AddCommGroup.intModule.{u1} M _inst_1) (AddCommGroup.intModule.{u2} M₂ _inst_2) (AddCommGroup.intModule.{u3} M₃ _inst_3) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) (RingHomCompTriple.right_ids.{0, 0} Int Int Int.semiring Int.semiring (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring))) (RingHomCompTriple.right_ids.{0, 0} Int Int Int.semiring Int.semiring (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring))) (RingHomInvPair.ids.{0} Int Int.semiring) (RingHomInvPair.ids.{0} Int Int.semiring) (RingHomInvPair.ids.{0} Int Int.semiring) (RingHomInvPair.ids.{0} Int Int.semiring) (RingHomInvPair.ids.{0} Int Int.semiring) (RingHomInvPair.ids.{0} Int Int.semiring) (AddEquiv.toIntLinearEquiv.{u1, u2} M M₂ _inst_1 _inst_2 e) (AddEquiv.toIntLinearEquiv.{u2, u3} M₂ M₃ _inst_2 _inst_3 e₂)) (AddEquiv.toIntLinearEquiv.{u1, u3} M M₃ _inst_1 _inst_3 (AddEquiv.trans.{u1, u2, u3} M M₂ M₃ (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))))) (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2))))) (AddZeroClass.toHasAdd.{u3} M₃ (AddMonoid.toAddZeroClass.{u3} M₃ (SubNegMonoid.toAddMonoid.{u3} M₃ (AddGroup.toSubNegMonoid.{u3} M₃ (AddCommGroup.toAddGroup.{u3} M₃ _inst_3))))) e e₂))
but is expected to have type
  forall {M : Type.{u1}} {M₂ : Type.{u3}} {M₃ : Type.{u2}} [_inst_1 : AddCommGroup.{u1} M] [_inst_2 : AddCommGroup.{u3} M₂] [_inst_3 : AddCommGroup.{u2} M₃] (e : AddEquiv.{u1, u3} M M₂ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (SubNegMonoid.toAddMonoid.{u3} M₂ (AddGroup.toSubNegMonoid.{u3} M₂ (AddCommGroup.toAddGroup.{u3} M₂ _inst_2)))))) (e₂ : AddEquiv.{u3, u2} M₂ M₃ (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (SubNegMonoid.toAddMonoid.{u3} M₂ (AddGroup.toSubNegMonoid.{u3} M₂ (AddCommGroup.toAddGroup.{u3} M₂ _inst_2))))) (AddZeroClass.toAdd.{u2} M₃ (AddMonoid.toAddZeroClass.{u2} M₃ (SubNegMonoid.toAddMonoid.{u2} M₃ (AddGroup.toSubNegMonoid.{u2} M₃ (AddCommGroup.toAddGroup.{u2} M₃ _inst_3)))))), Eq.{max (succ u1) (succ u2)} (LinearEquiv.{0, 0, u1, u2} Int Int Int.instSemiringInt Int.instSemiringInt (RingHom.id.{0} Int (NonAssocRing.toNonAssocSemiring.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt))) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt)) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) M M₃ (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M₃ _inst_3) (AddCommGroup.intModule.{u1} M _inst_1) (AddCommGroup.intModule.{u2} M₃ _inst_3)) (LinearEquiv.trans.{0, 0, 0, u1, u3, u2} Int Int Int M M₂ M₃ Int.instSemiringInt Int.instSemiringInt Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M₃ _inst_3) (AddCommGroup.intModule.{u1} M _inst_1) (AddCommGroup.intModule.{u3} M₂ _inst_2) (AddCommGroup.intModule.{u2} M₃ _inst_3) (RingHom.id.{0} Int (NonAssocRing.toNonAssocSemiring.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt))) (RingHom.id.{0} Int (NonAssocRing.toNonAssocSemiring.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt))) (RingHom.id.{0} Int (NonAssocRing.toNonAssocSemiring.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt))) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt)) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt)) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt)) (RingHomCompTriple.ids.{0, 0} Int Int Int.instSemiringInt Int.instSemiringInt (RingHom.id.{0} Int (NonAssocRing.toNonAssocSemiring.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt)))) (RingHomCompTriple.ids.{0, 0} Int Int Int.instSemiringInt Int.instSemiringInt (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt))) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) (AddEquiv.toIntLinearEquiv.{u1, u3} M M₂ _inst_1 _inst_2 e) (AddEquiv.toIntLinearEquiv.{u3, u2} M₂ M₃ _inst_2 _inst_3 e₂)) (AddEquiv.toIntLinearEquiv.{u1, u2} M M₃ _inst_1 _inst_3 (AddEquiv.trans.{u1, u3, u2} M M₂ M₃ (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (SubNegMonoid.toAddMonoid.{u3} M₂ (AddGroup.toSubNegMonoid.{u3} M₂ (AddCommGroup.toAddGroup.{u3} M₂ _inst_2))))) (AddZeroClass.toAdd.{u2} M₃ (AddMonoid.toAddZeroClass.{u2} M₃ (SubNegMonoid.toAddMonoid.{u2} M₃ (AddGroup.toSubNegMonoid.{u2} M₃ (AddCommGroup.toAddGroup.{u2} M₃ _inst_3))))) e e₂))
Case conversion may be inaccurate. Consider using '#align add_equiv.to_int_linear_equiv_trans AddEquiv.toIntLinearEquiv_transₓ'. -/
@[simp]
theorem toIntLinearEquiv_trans (e₂ : M₂ ≃+ M₃) :
    e.toIntLinearEquiv.trans e₂.toIntLinearEquiv = (e.trans e₂).toIntLinearEquiv :=
  rfl
#align add_equiv.to_int_linear_equiv_trans AddEquiv.toIntLinearEquiv_trans

end AddCommGroup

end AddEquiv

