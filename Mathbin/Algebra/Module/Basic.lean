/-
Copyright (c) 2015 Nathaniel Thomas. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Nathaniel Thomas, Jeremy Avigad, Johannes Hölzl, Mario Carneiro

! This file was ported from Lean 3 source module algebra.module.basic
! leanprover-community/mathlib commit 2705404e701abc6b3127da906f40bae062a169c9
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.SmulWithZero
import Mathbin.GroupTheory.GroupAction.Group
import Mathbin.Tactic.Abel

/-!
# Modules over a ring

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file we define

* `module R M` : an additive commutative monoid `M` is a `module` over a
  `semiring R` if for `r : R` and `x : M` their "scalar multiplication `r • x : M` is defined, and
  the operation `•` satisfies some natural associativity and distributivity axioms similar to those
  on a ring.

## Implementation notes

In typical mathematical usage, our definition of `module` corresponds to "semimodule", and the
word "module" is reserved for `module R M` where `R` is a `ring` and `M` an `add_comm_group`.
If `R` is a `field` and `M` an `add_comm_group`, `M` would be called an `R`-vector space.
Since those assumptions can be made by changing the typeclasses applied to `R` and `M`,
without changing the axioms in `module`, mathlib calls everything a `module`.

In older versions of mathlib, we had separate `semimodule` and `vector_space` abbreviations.
This caused inference issues in some cases, while not providing any real advantages, so we decided
to use a canonical `module` typeclass throughout.

## Tags

semimodule, module, vector space
-/


open Function

universe u v

variable {α R k S M M₂ M₃ ι : Type _}

#print Module /-
/-- A module is a generalization of vector spaces to a scalar semiring.
  It consists of a scalar semiring `R` and an additive monoid of "vectors" `M`,
  connected by a "scalar multiplication" operation `r • x : M`
  (where `r : R` and `x : M`) with some natural associativity and
  distributivity axioms similar to those on a ring. -/
@[ext, protect_proj]
class Module (R : Type u) (M : Type v) [Semiring R] [AddCommMonoid M] extends
  DistribMulAction R M where
  add_smul : ∀ (r s : R) (x : M), (r + s) • x = r • x + s • x
  zero_smul : ∀ x : M, (0 : R) • x = 0
#align module Module
-/

section AddCommMonoid

variable [Semiring R] [AddCommMonoid M] [Module R M] (r s : R) (x y : M)

/- warning: module.to_mul_action_with_zero -> Module.toMulActionWithZero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], MulActionWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], MulActionWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))
Case conversion may be inaccurate. Consider using '#align module.to_mul_action_with_zero Module.toMulActionWithZeroₓ'. -/
-- see Note [lower instance priority]
/-- A module over a semiring automatically inherits a `mul_action_with_zero` structure. -/
instance (priority := 100) Module.toMulActionWithZero : MulActionWithZero R M :=
  { (inferInstance : MulAction R M) with
    smul_zero := smul_zero
    zero_smul := Module.zero_smul }
#align module.to_mul_action_with_zero Module.toMulActionWithZero

#print AddCommMonoid.natModule /-
instance AddCommMonoid.natModule : Module ℕ M
    where
  one_smul := one_nsmul
  mul_smul m n a := mul_nsmul' a m n
  smul_add n a b := nsmul_add a b n
  smul_zero := nsmul_zero
  zero_smul := zero_nsmul
  add_smul r s x := add_nsmul x r s
#align add_comm_monoid.nat_module AddCommMonoid.natModule
-/

/- warning: add_monoid.End.nat_cast_def -> AddMonoid.End.nat_cast_def is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_2 : AddCommMonoid.{u1} M] (n : Nat), Eq.{succ u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (HasLiftT.mk.{1, succ u1} Nat (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (CoeTCₓ.coe.{1, succ u1} Nat (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Nat.castCoe.{u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddMonoidWithOne.toNatCast.{u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Semiring.toNonAssocSemiring.{u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddMonoid.End.semiring.{u1} M _inst_2)))))))) n) (coeFn.{succ u1, succ u1} (MonoidHom.{0, u1} Nat (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Monoid.toMulOneClass.{0} Nat Nat.monoid) (Monoid.toMulOneClass.{u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddMonoid.End.monoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))))) (fun (_x : MonoidHom.{0, u1} Nat (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Monoid.toMulOneClass.{0} Nat Nat.monoid) (Monoid.toMulOneClass.{u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddMonoid.End.monoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))))) => Nat -> (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)))) (MonoidHom.hasCoeToFun.{0, u1} Nat (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Monoid.toMulOneClass.{0} Nat Nat.monoid) (Monoid.toMulOneClass.{u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddMonoid.End.monoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))))) (DistribMulAction.toAddMonoidEnd.{0, u1} Nat M Nat.monoid (AddCommMonoid.toAddMonoid.{u1} M _inst_2) (Module.toDistribMulAction.{0, u1} Nat M Nat.semiring _inst_2 (AddCommMonoid.natModule.{u1} M _inst_2))) n)
but is expected to have type
  forall {M : Type.{u1}} [_inst_2 : AddCommMonoid.{u1} M] (n : Nat), Eq.{succ u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Nat.cast.{u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Semiring.toNatCast.{u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddMonoid.End.semiring.{u1} M _inst_2)) n) (FunLike.coe.{succ u1, 1, succ u1} (MonoidHom.{0, u1} Nat (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Monoid.toMulOneClass.{0} Nat Nat.monoid) (Monoid.toMulOneClass.{u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddMonoid.End.monoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))))) Nat (fun (_x : Nat) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Nat) => AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) _x) (MulHomClass.toFunLike.{u1, 0, u1} (MonoidHom.{0, u1} Nat (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Monoid.toMulOneClass.{0} Nat Nat.monoid) (Monoid.toMulOneClass.{u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddMonoid.End.monoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))))) Nat (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (MulOneClass.toMul.{0} Nat (Monoid.toMulOneClass.{0} Nat Nat.monoid)) (MulOneClass.toMul.{u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Monoid.toMulOneClass.{u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddMonoid.End.monoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))))) (MonoidHomClass.toMulHomClass.{u1, 0, u1} (MonoidHom.{0, u1} Nat (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Monoid.toMulOneClass.{0} Nat Nat.monoid) (Monoid.toMulOneClass.{u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddMonoid.End.monoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))))) Nat (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Monoid.toMulOneClass.{0} Nat Nat.monoid) (Monoid.toMulOneClass.{u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddMonoid.End.monoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)))) (MonoidHom.monoidHomClass.{0, u1} Nat (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Monoid.toMulOneClass.{0} Nat Nat.monoid) (Monoid.toMulOneClass.{u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddMonoid.End.monoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))))))) (DistribMulAction.toAddMonoidEnd.{0, u1} Nat M Nat.monoid (AddCommMonoid.toAddMonoid.{u1} M _inst_2) (Module.toDistribMulAction.{0, u1} Nat M (CommSemiring.toSemiring.{0} Nat Nat.commSemiring) _inst_2 (AddCommMonoid.natModule.{u1} M _inst_2))) n)
Case conversion may be inaccurate. Consider using '#align add_monoid.End.nat_cast_def AddMonoid.End.nat_cast_defₓ'. -/
theorem AddMonoid.End.nat_cast_def (n : ℕ) :
    (↑n : AddMonoid.End M) = DistribMulAction.toAddMonoidEnd ℕ M n :=
  rfl
#align add_monoid.End.nat_cast_def AddMonoid.End.nat_cast_def

/- warning: add_smul -> add_smul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (r : R) (s : R) (x : M), Eq.{succ u2} M (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) r s) x) (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) r x) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) s x))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (r : R) (s : R) (x : M), Eq.{succ u2} M (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) r s) x) (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) r x) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) s x))
Case conversion may be inaccurate. Consider using '#align add_smul add_smulₓ'. -/
theorem add_smul : (r + s) • x = r • x + s • x :=
  Module.add_smul r s x
#align add_smul add_smul

/- warning: convex.combo_self -> Convex.combo_self is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {a : R} {b : R}, (Eq.{succ u1} R (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) a b) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (forall (x : M), Eq.{succ u2} M (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) a x) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) b x)) x)
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] {a : R} {b : R}, (Eq.{succ u2} R (HAdd.hAdd.{u2, u2, u2} R R R (instHAdd.{u2} R (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) a b) (OfNat.ofNat.{u2} R 1 (One.toOfNat1.{u2} R (Semiring.toOne.{u2} R _inst_1)))) -> (forall (x : M), Eq.{succ u1} M (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)))) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 _inst_3))))) a x) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 _inst_3))))) b x)) x)
Case conversion may be inaccurate. Consider using '#align convex.combo_self Convex.combo_selfₓ'. -/
theorem Convex.combo_self {a b : R} (h : a + b = 1) (x : M) : a • x + b • x = x := by
  rw [← add_smul, h, one_smul]
#align convex.combo_self Convex.combo_self

variable (R)

/- warning: two_smul -> two_smul is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (x : M), Eq.{succ u2} M (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) x) (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) x x)
but is expected to have type
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (x : M), Eq.{succ u2} M (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R _inst_1) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) x) (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) x x)
Case conversion may be inaccurate. Consider using '#align two_smul two_smulₓ'. -/
theorem two_smul : (2 : R) • x = x + x := by rw [bit0, add_smul, one_smul]
#align two_smul two_smul

/- warning: two_smul' -> two_smul' is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (x : M), Eq.{succ u2} M (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) x) (bit0.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) x)
but is expected to have type
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (x : M), Eq.{succ u2} M (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R _inst_1) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) x) (bit0.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) x)
Case conversion may be inaccurate. Consider using '#align two_smul' two_smul'ₓ'. -/
theorem two_smul' : (2 : R) • x = bit0 x :=
  two_smul R x
#align two_smul' two_smul'

/- warning: inv_of_two_smul_add_inv_of_two_smul -> inv_of_two_smul_add_inv_of_two_smul is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_4 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))))] (x : M), Eq.{succ u2} M (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (Invertible.invOf.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) _inst_4) x) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (Invertible.invOf.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) _inst_4) x)) x
but is expected to have type
  forall (R : Type.{u2}) {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] [_inst_4 : Invertible.{u2} R (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toOne.{u2} R _inst_1) (OfNat.ofNat.{u2} R 2 (instOfNat.{u2} R 2 (Semiring.toNatCast.{u2} R _inst_1) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] (x : M), Eq.{succ u1} M (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)))) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 _inst_3))))) (Invertible.invOf.{u2} R (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toOne.{u2} R _inst_1) (OfNat.ofNat.{u2} R 2 (instOfNat.{u2} R 2 (Semiring.toNatCast.{u2} R _inst_1) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) _inst_4) x) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 _inst_3))))) (Invertible.invOf.{u2} R (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toOne.{u2} R _inst_1) (OfNat.ofNat.{u2} R 2 (instOfNat.{u2} R 2 (Semiring.toNatCast.{u2} R _inst_1) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) _inst_4) x)) x
Case conversion may be inaccurate. Consider using '#align inv_of_two_smul_add_inv_of_two_smul inv_of_two_smul_add_inv_of_two_smulₓ'. -/
@[simp]
theorem inv_of_two_smul_add_inv_of_two_smul [Invertible (2 : R)] (x : M) :
    (⅟ 2 : R) • x + (⅟ 2 : R) • x = x :=
  Convex.combo_self invOf_two_add_invOf_two _
#align inv_of_two_smul_add_inv_of_two_smul inv_of_two_smul_add_inv_of_two_smul

/- warning: function.injective.module -> Function.Injective.module is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : SMul.{u1, u3} R M₂] (f : AddMonoidHom.{u3, u2} M₂ M (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))), (Function.Injective.{succ u3, succ u2} M₂ M (coeFn.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (AddMonoidHom.{u3, u2} M₂ M (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (fun (_x : AddMonoidHom.{u3, u2} M₂ M (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) => M₂ -> M) (AddMonoidHom.hasCoeToFun.{u3, u2} M₂ M (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) f)) -> (forall (c : R) (x : M₂), Eq.{succ u2} M (coeFn.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (AddMonoidHom.{u3, u2} M₂ M (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (fun (_x : AddMonoidHom.{u3, u2} M₂ M (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) => M₂ -> M) (AddMonoidHom.hasCoeToFun.{u3, u2} M₂ M (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) f (SMul.smul.{u1, u3} R M₂ _inst_5 c x)) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) c (coeFn.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (AddMonoidHom.{u3, u2} M₂ M (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (fun (_x : AddMonoidHom.{u3, u2} M₂ M (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) => M₂ -> M) (AddMonoidHom.hasCoeToFun.{u3, u2} M₂ M (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) f x))) -> (Module.{u1, u3} R M₂ _inst_1 _inst_4)
but is expected to have type
  forall (R : Type.{u1}) {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : SMul.{u1, u3} R M₂] (f : AddMonoidHom.{u3, u2} M₂ M (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))), (Function.Injective.{succ u3, succ u2} M₂ M (FunLike.coe.{max (succ u2) (succ u3), succ u3, succ u2} (AddMonoidHom.{u3, u2} M₂ M (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) M₂ (fun (_x : M₂) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M₂) => M) _x) (AddHomClass.toFunLike.{max u2 u3, u3, u2} (AddMonoidHom.{u3, u2} M₂ M (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) M₂ M (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddMonoidHomClass.toAddHomClass.{max u2 u3, u3, u2} (AddMonoidHom.{u3, u2} M₂ M (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) M₂ M (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoidHom.addMonoidHomClass.{u3, u2} M₂ M (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))) f)) -> (forall (c : R) (x : M₂), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M₂) => M) (HSMul.hSMul.{u1, u3, u3} R M₂ M₂ (instHSMul.{u1, u3} R M₂ _inst_5) c x)) (FunLike.coe.{max (succ u2) (succ u3), succ u3, succ u2} (AddMonoidHom.{u3, u2} M₂ M (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) M₂ (fun (_x : M₂) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M₂) => M) _x) (AddHomClass.toFunLike.{max u2 u3, u3, u2} (AddMonoidHom.{u3, u2} M₂ M (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) M₂ M (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddMonoidHomClass.toAddHomClass.{max u2 u3, u3, u2} (AddMonoidHom.{u3, u2} M₂ M (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) M₂ M (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoidHom.addMonoidHomClass.{u3, u2} M₂ M (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))) f (HSMul.hSMul.{u1, u3, u3} R M₂ M₂ (instHSMul.{u1, u3} R M₂ _inst_5) c x)) (HSMul.hSMul.{u1, u2, u2} R ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M₂) => M) x) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M₂) => M) x) (instHSMul.{u1, u2} R ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M₂) => M) x) (SMulZeroClass.toSMul.{u1, u2} R ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M₂) => M) x) (AddMonoid.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M₂) => M) x) (AddCommMonoid.toAddMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M₂) => M) x) _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M₂) => M) x) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M₂) => M) x) (AddCommMonoid.toAddMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M₂) => M) x) _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M₂) => M) x) (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M₂) => M) x) (AddCommMonoid.toAddMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M₂) => M) x) _inst_2)) (Module.toMulActionWithZero.{u1, u2} R ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M₂) => M) x) _inst_1 _inst_2 _inst_3))))) c (FunLike.coe.{max (succ u2) (succ u3), succ u3, succ u2} (AddMonoidHom.{u3, u2} M₂ M (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) M₂ (fun (_x : M₂) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M₂) => M) _x) (AddHomClass.toFunLike.{max u2 u3, u3, u2} (AddMonoidHom.{u3, u2} M₂ M (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) M₂ M (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddMonoidHomClass.toAddHomClass.{max u2 u3, u3, u2} (AddMonoidHom.{u3, u2} M₂ M (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) M₂ M (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoidHom.addMonoidHomClass.{u3, u2} M₂ M (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))) f x))) -> (Module.{u1, u3} R M₂ _inst_1 _inst_4)
Case conversion may be inaccurate. Consider using '#align function.injective.module Function.Injective.moduleₓ'. -/
/-- Pullback a `module` structure along an injective additive monoid homomorphism.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.module [AddCommMonoid M₂] [SMul R M₂] (f : M₂ →+ M)
    (hf : Injective f) (smul : ∀ (c : R) (x), f (c • x) = c • f x) : Module R M₂ :=
  { hf.DistribMulAction f smul with
    smul := (· • ·)
    add_smul := fun c₁ c₂ x => hf <| by simp only [smul, f.map_add, add_smul]
    zero_smul := fun x => hf <| by simp only [smul, zero_smul, f.map_zero] }
#align function.injective.module Function.Injective.module

/- warning: function.surjective.module -> Function.Surjective.module is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : SMul.{u1, u3} R M₂] (f : AddMonoidHom.{u2, u3} M M₂ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))), (Function.Surjective.{succ u2, succ u3} M M₂ (coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (AddMonoidHom.{u2, u3} M M₂ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) (fun (_x : AddMonoidHom.{u2, u3} M M₂ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) => M -> M₂) (AddMonoidHom.hasCoeToFun.{u2, u3} M M₂ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) f)) -> (forall (c : R) (x : M), Eq.{succ u3} M₂ (coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (AddMonoidHom.{u2, u3} M M₂ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) (fun (_x : AddMonoidHom.{u2, u3} M M₂ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) => M -> M₂) (AddMonoidHom.hasCoeToFun.{u2, u3} M M₂ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) f (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) c x)) (SMul.smul.{u1, u3} R M₂ _inst_5 c (coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (AddMonoidHom.{u2, u3} M M₂ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) (fun (_x : AddMonoidHom.{u2, u3} M M₂ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) => M -> M₂) (AddMonoidHom.hasCoeToFun.{u2, u3} M M₂ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) f x))) -> (Module.{u1, u3} R M₂ _inst_1 _inst_4)
but is expected to have type
  forall (R : Type.{u1}) {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : SMul.{u1, u3} R M₂] (f : AddMonoidHom.{u2, u3} M M₂ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))), (Function.Surjective.{succ u2, succ u3} M M₂ (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (AddMonoidHom.{u2, u3} M M₂ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) _x) (AddHomClass.toFunLike.{max u2 u3, u2, u3} (AddMonoidHom.{u2, u3} M M₂ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) (AddMonoidHomClass.toAddHomClass.{max u2 u3, u2, u3} (AddMonoidHom.{u2, u3} M M₂ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) M M₂ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (AddMonoidHom.addMonoidHomClass.{u2, u3} M M₂ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))))) f)) -> (forall (c : R) (x : M), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) c x)) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (AddMonoidHom.{u2, u3} M M₂ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) _x) (AddHomClass.toFunLike.{max u2 u3, u2, u3} (AddMonoidHom.{u2, u3} M M₂ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) (AddMonoidHomClass.toAddHomClass.{max u2 u3, u2, u3} (AddMonoidHom.{u2, u3} M M₂ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) M M₂ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (AddMonoidHom.addMonoidHomClass.{u2, u3} M M₂ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))))) f (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) c x)) (HSMul.hSMul.{u1, u3, u3} R ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (instHSMul.{u1, u3} R ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) _inst_5) c (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (AddMonoidHom.{u2, u3} M M₂ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) _x) (AddHomClass.toFunLike.{max u2 u3, u2, u3} (AddMonoidHom.{u2, u3} M M₂ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) M M₂ (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) (AddMonoidHomClass.toAddHomClass.{max u2 u3, u2, u3} (AddMonoidHom.{u2, u3} M M₂ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) M M₂ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (AddMonoidHom.addMonoidHomClass.{u2, u3} M M₂ (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))))) f x))) -> (Module.{u1, u3} R M₂ _inst_1 _inst_4)
Case conversion may be inaccurate. Consider using '#align function.surjective.module Function.Surjective.moduleₓ'. -/
/-- Pushforward a `module` structure along a surjective additive monoid homomorphism. -/
protected def Function.Surjective.module [AddCommMonoid M₂] [SMul R M₂] (f : M →+ M₂)
    (hf : Surjective f) (smul : ∀ (c : R) (x), f (c • x) = c • f x) : Module R M₂ :=
  { hf.DistribMulAction f smul with
    smul := (· • ·)
    add_smul := fun c₁ c₂ x => by
      rcases hf x with ⟨x, rfl⟩
      simp only [add_smul, ← smul, ← f.map_add]
    zero_smul := fun x => by
      rcases hf x with ⟨x, rfl⟩
      simp only [← f.map_zero, ← smul, zero_smul] }
#align function.surjective.module Function.Surjective.module

/- warning: function.surjective.module_left -> Function.Surjective.moduleLeft is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} [_inst_4 : Semiring.{u1} R] [_inst_5 : AddCommMonoid.{u3} M] [_inst_6 : Module.{u1, u3} R M _inst_4 _inst_5] [_inst_7 : Semiring.{u2} S] [_inst_8 : SMul.{u2, u3} S M] (f : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_4) (Semiring.toNonAssocSemiring.{u2} S _inst_7)), (Function.Surjective.{succ u1, succ u2} R S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_4) (Semiring.toNonAssocSemiring.{u2} S _inst_7)) (fun (_x : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_4) (Semiring.toNonAssocSemiring.{u2} S _inst_7)) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_4) (Semiring.toNonAssocSemiring.{u2} S _inst_7)) f)) -> (forall (c : R) (x : M), Eq.{succ u3} M (SMul.smul.{u2, u3} S M _inst_8 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_4) (Semiring.toNonAssocSemiring.{u2} S _inst_7)) (fun (_x : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_4) (Semiring.toNonAssocSemiring.{u2} S _inst_7)) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_4) (Semiring.toNonAssocSemiring.{u2} S _inst_7)) f c) x) (SMul.smul.{u1, u3} R M (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_5))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_4)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_5))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_4) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_5))) (Module.toMulActionWithZero.{u1, u3} R M _inst_4 _inst_5 _inst_6)))) c x)) -> (Module.{u2, u3} S M _inst_7 _inst_5)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} [_inst_4 : Semiring.{u1} R] [_inst_5 : AddCommMonoid.{u3} M] [_inst_6 : Module.{u1, u3} R M _inst_4 _inst_5] [_inst_7 : Semiring.{u2} S] [_inst_8 : SMul.{u2, u3} S M] (f : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_4) (Semiring.toNonAssocSemiring.{u2} S _inst_7)), (Function.Surjective.{succ u1, succ u2} R S (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_4) (Semiring.toNonAssocSemiring.{u2} S _inst_7)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_4) (Semiring.toNonAssocSemiring.{u2} S _inst_7)) R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_4))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_7))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_4) (Semiring.toNonAssocSemiring.{u2} S _inst_7)) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_4)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_7)) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_4) (Semiring.toNonAssocSemiring.{u2} S _inst_7)) R S (Semiring.toNonAssocSemiring.{u1} R _inst_4) (Semiring.toNonAssocSemiring.{u2} S _inst_7) (RingHom.instRingHomClassRingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_4) (Semiring.toNonAssocSemiring.{u2} S _inst_7))))) f)) -> (forall (c : R) (x : M), Eq.{succ u3} M (HSMul.hSMul.{u2, u3, u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) M M (instHSMul.{u2, u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) c) M _inst_8) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_4) (Semiring.toNonAssocSemiring.{u2} S _inst_7)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_4) (Semiring.toNonAssocSemiring.{u2} S _inst_7)) R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_4))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_7))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_4) (Semiring.toNonAssocSemiring.{u2} S _inst_7)) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_4)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_7)) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_4) (Semiring.toNonAssocSemiring.{u2} S _inst_7)) R S (Semiring.toNonAssocSemiring.{u1} R _inst_4) (Semiring.toNonAssocSemiring.{u2} S _inst_7) (RingHom.instRingHomClassRingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_4) (Semiring.toNonAssocSemiring.{u2} S _inst_7))))) f c) x) (HSMul.hSMul.{u1, u3, u3} R M M (instHSMul.{u1, u3} R M (SMulZeroClass.toSMul.{u1, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_5)) (SMulWithZero.toSMulZeroClass.{u1, u3} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_4)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_5)) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_4) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_5)) (Module.toMulActionWithZero.{u1, u3} R M _inst_4 _inst_5 _inst_6))))) c x)) -> (Module.{u2, u3} S M _inst_7 _inst_5)
Case conversion may be inaccurate. Consider using '#align function.surjective.module_left Function.Surjective.moduleLeftₓ'. -/
/-- Push forward the action of `R` on `M` along a compatible surjective map `f : R →+* S`.

See also `function.surjective.mul_action_left` and `function.surjective.distrib_mul_action_left`.
-/
@[reducible]
def Function.Surjective.moduleLeft {R S M : Type _} [Semiring R] [AddCommMonoid M] [Module R M]
    [Semiring S] [SMul S M] (f : R →+* S) (hf : Function.Surjective f)
    (hsmul : ∀ (c) (x : M), f c • x = c • x) : Module S M :=
  {
    hf.distribMulActionLeft f.toMonoidHom
      hsmul with
    smul := (· • ·)
    zero_smul := fun x => by rw [← f.map_zero, hsmul, zero_smul]
    add_smul := hf.Forall₂.mpr fun a b x => by simp only [← f.map_add, hsmul, add_smul] }
#align function.surjective.module_left Function.Surjective.moduleLeft

variable {R} (M)

#print Module.compHom /-
/-- Compose a `module` with a `ring_hom`, with action `f s • m`.

See note [reducible non-instances]. -/
@[reducible]
def Module.compHom [Semiring S] (f : S →+* R) : Module S M :=
  { MulActionWithZero.compHom M f.toMonoidWithZeroHom,
    DistribMulAction.compHom M
      (f : S →* R) with
    smul := SMul.comp.smul f
    add_smul := fun r s x => by simp [add_smul] }
#align module.comp_hom Module.compHom
-/

variable (R) (M)

#print Module.toAddMonoidEnd /-
/-- `(•)` as an `add_monoid_hom`.

This is a stronger version of `distrib_mul_action.to_add_monoid_End` -/
@[simps apply_apply]
def Module.toAddMonoidEnd : R →+* AddMonoid.End M :=
  {
    DistribMulAction.toAddMonoidEnd R
      M with
    map_zero' := AddMonoidHom.ext fun r => by simp
    map_add' := fun x y => AddMonoidHom.ext fun r => by simp [add_smul] }
#align module.to_add_monoid_End Module.toAddMonoidEnd
-/

#print smulAddHom /-
/-- A convenience alias for `module.to_add_monoid_End` as an `add_monoid_hom`, usually to allow the
use of `add_monoid_hom.flip`. -/
def smulAddHom : R →+ M →+ M :=
  (Module.toAddMonoidEnd R M).toAddMonoidHom
#align smul_add_hom smulAddHom
-/

variable {R M}

/- warning: smul_add_hom_apply -> smulAddHom_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (r : R) (x : M), Eq.{succ u2} M (coeFn.{succ u2, succ u2} (AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (fun (_x : AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) => M -> M) (AddMonoidHom.hasCoeToFun.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} R (AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (AddMonoid.toAddZeroClass.{u2} (AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddCommMonoid.toAddMonoid.{u2} (AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddMonoidHom.addCommMonoid.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_2)))) (fun (_x : AddMonoidHom.{u1, u2} R (AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (AddMonoid.toAddZeroClass.{u2} (AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddCommMonoid.toAddMonoid.{u2} (AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddMonoidHom.addCommMonoid.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_2)))) => R -> (AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (AddMonoidHom.hasCoeToFun.{u1, u2} R (AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (AddMonoid.toAddZeroClass.{u2} (AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddCommMonoid.toAddMonoid.{u2} (AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddMonoidHom.addCommMonoid.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_2)))) (smulAddHom.{u1, u2} R M _inst_1 _inst_2 _inst_3) r) x) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) r x)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (r : R) (x : M), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M) x) (FunLike.coe.{succ u2, succ u2, succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : R) => AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) r) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M) _x) (AddHomClass.toFunLike.{u2, u2, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : R) => AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) r) M M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddMonoidHomClass.toAddHomClass.{u2, u2, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : R) => AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) r) M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoidHom.addMonoidHomClass.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AddMonoidHom.{u1, u2} R (AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (AddMonoid.toAddZeroClass.{u2} (AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddCommMonoid.toAddMonoid.{u2} (AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddMonoidHom.addCommMonoid.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : R) => AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) _x) (AddHomClass.toFunLike.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} R (AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (AddMonoid.toAddZeroClass.{u2} (AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddCommMonoid.toAddMonoid.{u2} (AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddMonoidHom.addCommMonoid.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_2)))) R (AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toAdd.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (AddZeroClass.toAdd.{u2} (AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddMonoid.toAddZeroClass.{u2} (AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddCommMonoid.toAddMonoid.{u2} (AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddMonoidHom.addCommMonoid.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_2)))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} R (AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (AddMonoid.toAddZeroClass.{u2} (AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddCommMonoid.toAddMonoid.{u2} (AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddMonoidHom.addCommMonoid.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_2)))) R (AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (AddMonoid.toAddZeroClass.{u2} (AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddCommMonoid.toAddMonoid.{u2} (AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddMonoidHom.addCommMonoid.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_2))) (AddMonoidHom.addMonoidHomClass.{u1, u2} R (AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (AddMonoid.toAddZeroClass.{u2} (AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddCommMonoid.toAddMonoid.{u2} (AddMonoidHom.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddMonoidHom.addCommMonoid.{u2, u2} M M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_2)))))) (smulAddHom.{u1, u2} R M _inst_1 _inst_2 _inst_3) r) x) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) r x)
Case conversion may be inaccurate. Consider using '#align smul_add_hom_apply smulAddHom_applyₓ'. -/
@[simp]
theorem smulAddHom_apply (r : R) (x : M) : smulAddHom R M r x = r • x :=
  rfl
#align smul_add_hom_apply smulAddHom_apply

/- warning: module.eq_zero_of_zero_eq_one -> Module.eq_zero_of_zero_eq_one is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (x : M), (Eq.{succ u1} R (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u2} M x (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] (x : M), (Eq.{succ u2} R (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) (OfNat.ofNat.{u2} R 1 (One.toOfNat1.{u2} R (Semiring.toOne.{u2} R _inst_1)))) -> (Eq.{succ u1} M x (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)))))
Case conversion may be inaccurate. Consider using '#align module.eq_zero_of_zero_eq_one Module.eq_zero_of_zero_eq_oneₓ'. -/
theorem Module.eq_zero_of_zero_eq_one (zero_eq_one : (0 : R) = 1) : x = 0 := by
  rw [← one_smul R x, ← zero_eq_one, zero_smul]
#align module.eq_zero_of_zero_eq_one Module.eq_zero_of_zero_eq_one

/- warning: smul_add_one_sub_smul -> smul_add_one_sub_smul is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_2 : AddCommMonoid.{u1} M] {R : Type.{u2}} [_inst_4 : Ring.{u2} R] [_inst_5 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_4) _inst_2] {r : R} {m : M}, Eq.{succ u1} M (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)))) (SMul.smul.{u2, u1} R M (SMulZeroClass.toHasSmul.{u2, u1} R M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u2, u1} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_4))))) (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_4)) (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Module.toMulActionWithZero.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_4) _inst_2 _inst_5)))) r m) (SMul.smul.{u2, u1} R M (SMulZeroClass.toHasSmul.{u2, u1} R M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u2, u1} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_4))))) (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_4)) (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Module.toMulActionWithZero.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_4) _inst_2 _inst_5)))) (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (SubNegMonoid.toHasSub.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddGroupWithOne.toAddGroup.{u2} R (NonAssocRing.toAddGroupWithOne.{u2} R (Ring.toNonAssocRing.{u2} R _inst_4)))))) (OfNat.ofNat.{u2} R 1 (OfNat.mk.{u2} R 1 (One.one.{u2} R (AddMonoidWithOne.toOne.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (NonAssocRing.toAddGroupWithOne.{u2} R (Ring.toNonAssocRing.{u2} R _inst_4))))))) r) m)) m
but is expected to have type
  forall {M : Type.{u1}} [_inst_2 : AddCommMonoid.{u1} M] {R : Type.{u2}} [_inst_4 : Ring.{u2} R] [_inst_5 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_4) _inst_2] {r : R} {m : M}, Eq.{succ u1} M (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)))) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_4))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_4)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_4) _inst_2 _inst_5))))) r m) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_4))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_4)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_4) _inst_2 _inst_5))))) (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (Ring.toSub.{u2} R _inst_4)) (OfNat.ofNat.{u2} R 1 (One.toOfNat1.{u2} R (NonAssocRing.toOne.{u2} R (Ring.toNonAssocRing.{u2} R _inst_4)))) r) m)) m
Case conversion may be inaccurate. Consider using '#align smul_add_one_sub_smul smul_add_one_sub_smulₓ'. -/
@[simp]
theorem smul_add_one_sub_smul {R : Type _} [Ring R] [Module R M] {r : R} {m : M} :
    r • m + (1 - r) • m = m := by rw [← add_smul, add_sub_cancel'_right, one_smul]
#align smul_add_one_sub_smul smul_add_one_sub_smul

end AddCommMonoid

variable (R)

#print Module.addCommMonoidToAddCommGroup /-
/-- An `add_comm_monoid` that is a `module` over a `ring` carries a natural `add_comm_group`
structure.
See note [reducible non-instances]. -/
@[reducible]
def Module.addCommMonoidToAddCommGroup [Ring R] [AddCommMonoid M] [Module R M] : AddCommGroup M :=
  {
    (inferInstance : AddCommMonoid
        M) with
    neg := fun a => (-1 : R) • a
    add_left_neg := fun a =>
      show (-1 : R) • a + a = 0 by
        nth_rw 2 [← one_smul _ a]
        rw [← add_smul, add_left_neg, zero_smul] }
#align module.add_comm_monoid_to_add_comm_group Module.addCommMonoidToAddCommGroup
-/

variable {R}

section AddCommGroup

variable (R M) [Semiring R] [AddCommGroup M]

/- warning: add_comm_group.int_module -> AddCommGroup.intModule is a dubious translation:
lean 3 declaration is
  forall (M : Type.{u1}) [_inst_2 : AddCommGroup.{u1} M], Module.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)
but is expected to have type
  forall (M : Type.{u1}) [_inst_2 : AddCommGroup.{u1} M], Module.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)
Case conversion may be inaccurate. Consider using '#align add_comm_group.int_module AddCommGroup.intModuleₓ'. -/
instance AddCommGroup.intModule : Module ℤ M
    where
  one_smul := one_zsmul
  mul_smul m n a := mul_zsmul a m n
  smul_add n a b := zsmul_add a b n
  smul_zero := zsmul_zero
  zero_smul := zero_zsmul
  add_smul r s x := add_zsmul x r s
#align add_comm_group.int_module AddCommGroup.intModule

/- warning: add_monoid.End.int_cast_def -> AddMonoid.End.int_cast_def is a dubious translation:
lean 3 declaration is
  forall (M : Type.{u1}) [_inst_2 : AddCommGroup.{u1} M] (z : Int), Eq.{succ u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))) (HasLiftT.mk.{1, succ u1} Int (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))) (CoeTCₓ.coe.{1, succ u1} Int (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))) (Int.castCoe.{u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))) (AddGroupWithOne.toHasIntCast.{u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))) (NonAssocRing.toAddGroupWithOne.{u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))) (Ring.toNonAssocRing.{u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))) (AddMonoid.End.ring.{u1} M _inst_2))))))) z) (coeFn.{succ u1, succ u1} (MonoidHom.{0, u1} Int (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))) (Monoid.toMulOneClass.{0} Int Int.monoid) (Monoid.toMulOneClass.{u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))) (AddMonoid.End.monoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))))) (fun (_x : MonoidHom.{0, u1} Int (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))) (Monoid.toMulOneClass.{0} Int Int.monoid) (Monoid.toMulOneClass.{u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))) (AddMonoid.End.monoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))))) => Int -> (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2)))))) (MonoidHom.hasCoeToFun.{0, u1} Int (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))) (Monoid.toMulOneClass.{0} Int Int.monoid) (Monoid.toMulOneClass.{u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))) (AddMonoid.End.monoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))))) (DistribMulAction.toAddMonoidEnd.{0, u1} Int M Int.monoid (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))) (Module.toDistribMulAction.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) (AddCommGroup.intModule.{u1} M _inst_2))) z)
but is expected to have type
  forall (M : Type.{u1}) [_inst_2 : AddCommGroup.{u1} M] (z : Int), Eq.{succ u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))) (Int.cast.{u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))) (Ring.toIntCast.{u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))) (instRingEndToAddZeroClassToAddMonoidToSubNegMonoidToAddGroup.{u1} M _inst_2)) z) (FunLike.coe.{succ u1, 1, succ u1} (MonoidHom.{0, u1} Int (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))) (Monoid.toMulOneClass.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))) (AddMonoid.End.monoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))))) Int (fun (_x : Int) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Int) => AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))) _x) (MulHomClass.toFunLike.{u1, 0, u1} (MonoidHom.{0, u1} Int (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))) (Monoid.toMulOneClass.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))) (AddMonoid.End.monoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))))) Int (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))) (MulOneClass.toMul.{0} Int (Monoid.toMulOneClass.{0} Int Int.instMonoidInt)) (MulOneClass.toMul.{u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))) (Monoid.toMulOneClass.{u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))) (AddMonoid.End.monoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))))) (MonoidHomClass.toMulHomClass.{u1, 0, u1} (MonoidHom.{0, u1} Int (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))) (Monoid.toMulOneClass.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))) (AddMonoid.End.monoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))))) Int (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))) (Monoid.toMulOneClass.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))) (AddMonoid.End.monoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2)))))) (MonoidHom.monoidHomClass.{0, u1} Int (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))) (Monoid.toMulOneClass.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (AddMonoid.End.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))) (AddMonoid.End.monoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))))))))) (DistribMulAction.toAddMonoidEnd.{0, u1} Int M Int.instMonoidInt (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))) (Module.toDistribMulAction.{0, u1} Int M (Ring.toSemiring.{0} Int (CommRing.toRing.{0} Int Int.instCommRingInt)) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) (AddCommGroup.intModule.{u1} M _inst_2))) z)
Case conversion may be inaccurate. Consider using '#align add_monoid.End.int_cast_def AddMonoid.End.int_cast_defₓ'. -/
theorem AddMonoid.End.int_cast_def (z : ℤ) :
    (↑z : AddMonoid.End M) = DistribMulAction.toAddMonoidEnd ℤ M z :=
  rfl
#align add_monoid.End.int_cast_def AddMonoid.End.int_cast_def

#print Module.Core /-
/-- A structure containing most informations as in a module, except the fields `zero_smul`
and `smul_zero`. As these fields can be deduced from the other ones when `M` is an `add_comm_group`,
this provides a way to construct a module structure by checking less properties, in
`module.of_core`. -/
@[nolint has_nonempty_instance]
structure Module.Core extends SMul R M where
  smul_add : ∀ (r : R) (x y : M), r • (x + y) = r • x + r • y
  add_smul : ∀ (r s : R) (x : M), (r + s) • x = r • x + s • x
  mul_smul : ∀ (r s : R) (x : M), (r * s) • x = r • s • x
  one_smul : ∀ x : M, (1 : R) • x = x
#align module.core Module.Core
-/

variable {R M}

#print Module.ofCore /-
/-- Define `module` without proving `zero_smul` and `smul_zero` by using an auxiliary
structure `module.core`, when the underlying space is an `add_comm_group`. -/
def Module.ofCore (H : Module.Core R M) : Module R M :=
  letI := H.to_has_smul
  {
    H with
    zero_smul := fun x =>
      (AddMonoidHom.mk' (fun r : R => r • x) fun r s => H.add_smul r s x).map_zero
    smul_zero := fun r => (AddMonoidHom.mk' ((· • ·) r) (H.smul_add r)).map_zero }
#align module.of_core Module.ofCore
-/

/- warning: convex.combo_eq_smul_sub_add -> Convex.combo_eq_smul_sub_add is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] {x : M} {y : M} {a : R} {b : R}, (Eq.{succ u1} R (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) a b) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u2} M (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))))) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)))) a x) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)))) b y)) (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))))) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)))) b (HSub.hSub.{u2, u2, u2} M M M (instHSub.{u2} M (SubNegMonoid.toHasSub.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))) y x)) x))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] {x : M} {y : M} {a : R} {b : R}, (Eq.{succ u2} R (HAdd.hAdd.{u2, u2, u2} R R R (instHAdd.{u2} R (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) a b) (OfNat.ofNat.{u2} R 1 (One.toOfNat1.{u2} R (Semiring.toOne.{u2} R _inst_1)))) -> (Eq.{succ u1} M (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2)))))) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))))) a x) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))))) b y)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2)))))) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))))) b (HSub.hSub.{u1, u1, u1} M M M (instHSub.{u1} M (SubNegMonoid.toSub.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2)))) y x)) x))
Case conversion may be inaccurate. Consider using '#align convex.combo_eq_smul_sub_add Convex.combo_eq_smul_sub_addₓ'. -/
theorem Convex.combo_eq_smul_sub_add [Module R M] {x y : M} {a b : R} (h : a + b = 1) :
    a • x + b • y = b • (y - x) + x :=
  calc
    a • x + b • y = b • y - b • x + (a • x + b • x) := by abel
    _ = b • (y - x) + x := by rw [smul_sub, Convex.combo_self h]
    
#align convex.combo_eq_smul_sub_add Convex.combo_eq_smul_sub_add

end AddCommGroup

/- warning: module.ext' -> Module.ext' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {M : Type.{u2}} [_inst_2 : AddCommMonoid.{u2} M] (P : Module.{u1, u2} R M _inst_1 _inst_2) (Q : Module.{u1, u2} R M _inst_1 _inst_2), (forall (r : R) (m : M), Eq.{succ u2} M (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 P)))) r m) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 Q)))) r m)) -> (Eq.{max (succ u1) (succ u2)} (Module.{u1, u2} R M _inst_1 _inst_2) P Q)
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : Semiring.{u2} R] {M : Type.{u1}} [_inst_2 : AddCommMonoid.{u1} M] (P : Module.{u2, u1} R M _inst_1 _inst_2) (Q : Module.{u2, u1} R M _inst_1 _inst_2), (forall (r : R) (m : M), Eq.{succ u1} M (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 P))))) r m) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 Q))))) r m)) -> (Eq.{max (succ u2) (succ u1)} (Module.{u2, u1} R M _inst_1 _inst_2) P Q)
Case conversion may be inaccurate. Consider using '#align module.ext' Module.ext'ₓ'. -/
-- We'll later use this to show `module ℕ M` and `module ℤ M` are subsingletons.
/-- A variant of `module.ext` that's convenient for term-mode. -/
theorem Module.ext' {R : Type _} [Semiring R] {M : Type _} [AddCommMonoid M] (P Q : Module R M)
    (w :
      ∀ (r : R) (m : M),
        (haveI := P
          r • m) =
          haveI := Q
          r • m) :
    P = Q := by
  ext
  exact w _ _
#align module.ext' Module.ext'

section Module

variable [Ring R] [AddCommGroup M] [Module R M] (r s : R) (x y : M)

/- warning: neg_smul -> neg_smul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] (r : R) (x : M), Eq.{succ u2} M (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)))) (Neg.neg.{u1} R (SubNegMonoid.toHasNeg.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) r) x) (Neg.neg.{u2} M (SubNegMonoid.toHasNeg.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)))) r x))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] (r : R) (x : M), Eq.{succ u2} M (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))))) (Neg.neg.{u1} R (Ring.toNeg.{u1} R _inst_1) r) x) (Neg.neg.{u2} M (NegZeroClass.toNeg.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))))) r x))
Case conversion may be inaccurate. Consider using '#align neg_smul neg_smulₓ'. -/
@[simp]
theorem neg_smul : -r • x = -(r • x) :=
  eq_neg_of_add_eq_zero_left <| by rw [← add_smul, add_left_neg, zero_smul]
#align neg_smul neg_smul

/- warning: neg_smul_neg -> neg_smul_neg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] (r : R) (x : M), Eq.{succ u2} M (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)))) (Neg.neg.{u1} R (SubNegMonoid.toHasNeg.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) r) (Neg.neg.{u2} M (SubNegMonoid.toHasNeg.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))) x)) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)))) r x)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] (r : R) (x : M), Eq.{succ u2} M (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))))) (Neg.neg.{u1} R (Ring.toNeg.{u1} R _inst_1) r) (Neg.neg.{u2} M (NegZeroClass.toNeg.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) x)) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))))) r x)
Case conversion may be inaccurate. Consider using '#align neg_smul_neg neg_smul_negₓ'. -/
@[simp]
theorem neg_smul_neg : -r • -x = r • x := by rw [neg_smul, smul_neg, neg_neg]
#align neg_smul_neg neg_smul_neg

/- warning: units.neg_smul -> Units.neg_smul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] (u : Units.{u1} R (Ring.toMonoid.{u1} R _inst_1)) (x : M), Eq.{succ u2} M (SMul.smul.{u1, u2} (Units.{u1} R (Ring.toMonoid.{u1} R _inst_1)) M (Units.hasSmul.{u1, u2} R M (Ring.toMonoid.{u1} R _inst_1) (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))))) (Neg.neg.{u1} (Units.{u1} R (Ring.toMonoid.{u1} R _inst_1)) (Units.hasNeg.{u1} R (Ring.toMonoid.{u1} R _inst_1) (NonUnitalNonAssocRing.toHasDistribNeg.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))) u) x) (Neg.neg.{u2} M (SubNegMonoid.toHasNeg.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))) (SMul.smul.{u1, u2} (Units.{u1} R (Ring.toMonoid.{u1} R _inst_1)) M (Units.hasSmul.{u1, u2} R M (Ring.toMonoid.{u1} R _inst_1) (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))))) u x))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_3 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] (u : Units.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (x : M), Eq.{succ u1} M (HSMul.hSMul.{u2, u1, u1} (Units.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) M M (instHSMul.{u2, u1} (Units.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) M (Units.instSMulUnits.{u2, u1} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (Module.toMulActionWithZero.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3)))))) (Neg.neg.{u2} (Units.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Units.instNegUnits.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (NonUnitalNonAssocRing.toHasDistribNeg.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))) u) x) (Neg.neg.{u1} M (NegZeroClass.toNeg.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (HSMul.hSMul.{u2, u1, u1} (Units.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) M M (instHSMul.{u2, u1} (Units.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) M (Units.instSMulUnits.{u2, u1} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (Module.toMulActionWithZero.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3)))))) u x))
Case conversion may be inaccurate. Consider using '#align units.neg_smul Units.neg_smulₓ'. -/
@[simp]
theorem Units.neg_smul (u : Rˣ) (x : M) : -u • x = -(u • x) := by
  rw [Units.smul_def, Units.val_neg, neg_smul, Units.smul_def]
#align units.neg_smul Units.neg_smul

variable (R)

/- warning: neg_one_smul -> neg_one_smul is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] (x : M), Eq.{succ u2} M (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)))) (Neg.neg.{u1} R (SubNegMonoid.toHasNeg.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))))))) x) (Neg.neg.{u2} M (SubNegMonoid.toHasNeg.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))) x)
but is expected to have type
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] (x : M), Eq.{succ u2} M (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))))) (Neg.neg.{u1} R (Ring.toNeg.{u1} R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) x) (Neg.neg.{u2} M (NegZeroClass.toNeg.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) x)
Case conversion may be inaccurate. Consider using '#align neg_one_smul neg_one_smulₓ'. -/
theorem neg_one_smul (x : M) : (-1 : R) • x = -x := by simp
#align neg_one_smul neg_one_smul

variable {R}

/- warning: sub_smul -> sub_smul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] (r : R) (s : R) (y : M), Eq.{succ u2} M (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)))) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (SubNegMonoid.toHasSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))))) r s) y) (HSub.hSub.{u2, u2, u2} M M M (instHSub.{u2} M (SubNegMonoid.toHasSub.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)))) r y) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)))) s y))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] (r : R) (s : R) (y : M), Eq.{succ u2} M (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))))) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_1)) r s) y) (HSub.hSub.{u2, u2, u2} M M M (instHSub.{u2} M (SubNegMonoid.toSub.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))))) r y) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))))) s y))
Case conversion may be inaccurate. Consider using '#align sub_smul sub_smulₓ'. -/
theorem sub_smul (r s : R) (y : M) : (r - s) • y = r • y - s • y := by
  simp [add_smul, sub_eq_add_neg]
#align sub_smul sub_smul

end Module

/- warning: module.subsingleton -> Module.subsingleton is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) [_inst_1 : Semiring.{u1} R] [_inst_2 : Subsingleton.{succ u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3], Subsingleton.{succ u2} M
but is expected to have type
  forall (R : Type.{u2}) (M : Type.{u1}) [_inst_1 : Semiring.{u2} R] [_inst_2 : Subsingleton.{succ u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3], Subsingleton.{succ u1} M
Case conversion may be inaccurate. Consider using '#align module.subsingleton Module.subsingletonₓ'. -/
/-- A module over a `subsingleton` semiring is a `subsingleton`. We cannot register this
as an instance because Lean has no way to guess `R`. -/
protected theorem Module.subsingleton (R M : Type _) [Semiring R] [Subsingleton R] [AddCommMonoid M]
    [Module R M] : Subsingleton M :=
  MulActionWithZero.subsingleton R M
#align module.subsingleton Module.subsingleton

/- warning: module.nontrivial -> Module.nontrivial is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) [_inst_1 : Semiring.{u1} R] [_inst_2 : Nontrivial.{u2} M] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3], Nontrivial.{u1} R
but is expected to have type
  forall (R : Type.{u2}) (M : Type.{u1}) [_inst_1 : Semiring.{u2} R] [_inst_2 : Nontrivial.{u1} M] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3], Nontrivial.{u2} R
Case conversion may be inaccurate. Consider using '#align module.nontrivial Module.nontrivialₓ'. -/
/-- A semiring is `nontrivial` provided that there exists a nontrivial module over this semiring. -/
protected theorem Module.nontrivial (R M : Type _) [Semiring R] [Nontrivial M] [AddCommMonoid M]
    [Module R M] : Nontrivial R :=
  MulActionWithZero.nontrivial R M
#align module.nontrivial Module.nontrivial

#print Semiring.toModule /-
-- see Note [lower instance priority]
instance (priority := 910) Semiring.toModule [Semiring R] : Module R R
    where
  smul_add := mul_add
  add_smul := add_mul
  zero_smul := zero_mul
  smul_zero := mul_zero
#align semiring.to_module Semiring.toModule
-/

/- warning: semiring.to_opposite_module -> Semiring.toOppositeModule is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R], Module.{u1, u1} (MulOpposite.{u1} R) R (MulOpposite.semiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R], Module.{u1, u1} (MulOpposite.{u1} R) R (MulOpposite.instSemiringMulOpposite.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))
Case conversion may be inaccurate. Consider using '#align semiring.to_opposite_module Semiring.toOppositeModuleₓ'. -/
-- see Note [lower instance priority]
/-- Like `semiring.to_module`, but multiplies on the right. -/
instance (priority := 910) Semiring.toOppositeModule [Semiring R] : Module Rᵐᵒᵖ R :=
  {
    MonoidWithZero.toOppositeMulActionWithZero
      R with
    smul_add := fun r x y => add_mul _ _ _
    add_smul := fun r x y => mul_add _ _ _ }
#align semiring.to_opposite_module Semiring.toOppositeModule

#print RingHom.toModule /-
/-- A ring homomorphism `f : R →+* M` defines a module structure by `r • x = f r * x`. -/
def RingHom.toModule [Semiring R] [Semiring S] (f : R →+* S) : Module R S :=
  Module.compHom S f
#align ring_hom.to_module RingHom.toModule
-/

/- warning: ring_hom.apply_distrib_mul_action -> RingHom.applyDistribMulAction is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R], DistribMulAction.{u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (RingHom.monoid.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R], DistribMulAction.{u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (RingHom.instMonoidRingHom.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align ring_hom.apply_distrib_mul_action RingHom.applyDistribMulActionₓ'. -/
/-- The tautological action by `R →+* R` on `R`.

This generalizes `function.End.apply_mul_action`. -/
instance RingHom.applyDistribMulAction [Semiring R] : DistribMulAction (R →+* R) R
    where
  smul := (· <| ·)
  smul_zero := RingHom.map_zero
  smul_add := RingHom.map_add
  one_smul _ := rfl
  mul_smul _ _ _ := rfl
#align ring_hom.apply_distrib_mul_action RingHom.applyDistribMulAction

/- warning: ring_hom.smul_def -> RingHom.smul_def is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] (f : RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (a : R), Eq.{succ u1} R (SMul.smul.{u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (SMulZeroClass.toHasSmul.{u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (DistribSMul.toSmulZeroClass.{u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (DistribMulAction.toDistribSMul.{u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (RingHom.monoid.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (RingHom.applyDistribMulAction.{u1} R _inst_1)))) f a) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (fun (_x : RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) => R -> R) (RingHom.hasCoeToFun.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) f a)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] (f : RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (a : R), Eq.{succ u1} R (HSMul.hSMul.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R R (instHSMul.{u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (SMulZeroClass.toSMul.{u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (DistribSMul.toSMulZeroClass.{u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (DistribMulAction.toDistribSMul.{u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (RingHom.instMonoidRingHom.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (RingHom.applyDistribMulAction.{u1} R _inst_1))))) f a) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => R) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (RingHom.instRingHomClassRingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) f a)
Case conversion may be inaccurate. Consider using '#align ring_hom.smul_def RingHom.smul_defₓ'. -/
@[simp]
protected theorem RingHom.smul_def [Semiring R] (f : R →+* R) (a : R) : f • a = f a :=
  rfl
#align ring_hom.smul_def RingHom.smul_def

/- warning: ring_hom.apply_has_faithful_smul -> RingHom.applyFaithfulSMul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R], FaithfulSMul.{u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (SMulZeroClass.toHasSmul.{u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (DistribSMul.toSmulZeroClass.{u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (DistribMulAction.toDistribSMul.{u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (RingHom.monoid.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (RingHom.applyDistribMulAction.{u1} R _inst_1))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R], FaithfulSMul.{u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (SMulZeroClass.toSMul.{u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (DistribSMul.toSMulZeroClass.{u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (DistribMulAction.toDistribSMul.{u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (RingHom.instMonoidRingHom.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (RingHom.applyDistribMulAction.{u1} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align ring_hom.apply_has_faithful_smul RingHom.applyFaithfulSMulₓ'. -/
/-- `ring_hom.apply_distrib_mul_action` is faithful. -/
instance RingHom.applyFaithfulSMul [Semiring R] : FaithfulSMul (R →+* R) R :=
  ⟨RingHom.ext⟩
#align ring_hom.apply_has_faithful_smul RingHom.applyFaithfulSMul

section AddCommMonoid

variable [Semiring R] [AddCommMonoid M] [Module R M]

section

variable (R)

#print nsmul_eq_smul_cast /-
/-- `nsmul` is equal to any other module structure via a cast. -/
theorem nsmul_eq_smul_cast (n : ℕ) (b : M) : n • b = (n : R) • b :=
  by
  induction' n with n ih
  · rw [Nat.cast_zero, zero_smul, zero_smul]
  · rw [Nat.succ_eq_add_one, Nat.cast_succ, add_smul, add_smul, one_smul, ih, one_smul]
#align nsmul_eq_smul_cast nsmul_eq_smul_cast
-/

end

#print nat_smul_eq_nsmul /-
/-- Convert back any exotic `ℕ`-smul to the canonical instance. This should not be needed since in
mathlib all `add_comm_monoid`s should normally have exactly one `ℕ`-module structure by design.
-/
theorem nat_smul_eq_nsmul (h : Module ℕ M) (n : ℕ) (x : M) : @SMul.smul ℕ M h.toSMul n x = n • x :=
  by rw [nsmul_eq_smul_cast ℕ n x, Nat.cast_id]
#align nat_smul_eq_nsmul nat_smul_eq_nsmul
-/

#print AddCommMonoid.natModule.unique /-
/-- All `ℕ`-module structures are equal. Not an instance since in mathlib all `add_comm_monoid`
should normally have exactly one `ℕ`-module structure by design. -/
def AddCommMonoid.natModule.unique : Unique (Module ℕ M)
    where
  default := by infer_instance
  uniq P := Module.ext' P _ fun n => nat_smul_eq_nsmul P n
#align add_comm_monoid.nat_module.unique AddCommMonoid.natModule.unique
-/

#print AddCommMonoid.nat_is_scalar_tower /-
instance AddCommMonoid.nat_is_scalar_tower : IsScalarTower ℕ R M
    where smul_assoc n x y :=
    Nat.recOn n (by simp only [zero_smul]) fun n ih => by
      simp only [Nat.succ_eq_add_one, add_smul, one_smul, ih]
#align add_comm_monoid.nat_is_scalar_tower AddCommMonoid.nat_is_scalar_tower
-/

end AddCommMonoid

section AddCommGroup

variable [Semiring S] [Ring R] [AddCommGroup M] [Module S M] [Module R M]

section

variable (R)

/- warning: zsmul_eq_smul_cast -> zsmul_eq_smul_cast is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_2 : Ring.{u1} R] [_inst_3 : AddCommGroup.{u2} M] [_inst_5 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)] (n : Int) (b : M), Eq.{succ u2} M (SMul.smul.{0, u2} Int M (SubNegMonoid.SMulInt.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_3))) n b) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_2))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_5)))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int R (HasLiftT.mk.{1, succ u1} Int R (CoeTCₓ.coe.{1, succ u1} Int R (Int.castCoe.{u1} R (AddGroupWithOne.toHasIntCast.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))))) n) b)
but is expected to have type
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_2 : Ring.{u1} R] [_inst_3 : AddCommGroup.{u2} M] [_inst_5 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)] (n : Int) (b : M), Eq.{succ u2} M (HSMul.hSMul.{0, u2, u2} Int M M (instHSMul.{0, u2} Int M (SubNegMonoid.SMulInt.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_3)))) n b) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_3))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_2))) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_3))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_3))))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_5))))) (Int.cast.{u1} R (Ring.toIntCast.{u1} R _inst_2) n) b)
Case conversion may be inaccurate. Consider using '#align zsmul_eq_smul_cast zsmul_eq_smul_castₓ'. -/
/-- `zsmul` is equal to any other module structure via a cast. -/
theorem zsmul_eq_smul_cast (n : ℤ) (b : M) : n • b = (n : R) • b :=
  have : (smulAddHom ℤ M).flip b = ((smulAddHom R M).flip b).comp (Int.castAddHom R) :=
    by
    ext
    simp
  AddMonoidHom.congr_fun this n
#align zsmul_eq_smul_cast zsmul_eq_smul_cast

end

/- warning: int_smul_eq_zsmul -> int_smul_eq_zsmul is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_3 : AddCommGroup.{u1} M] (h : Module.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_3)) (n : Int) (x : M), Eq.{succ u1} M (SMul.smul.{0, u1} Int M (MulAction.toHasSmul.{0, u1} Int M (MonoidWithZero.toMonoid.{0} Int (Semiring.toMonoidWithZero.{0} Int Int.semiring)) (DistribMulAction.toMulAction.{0, u1} Int M (MonoidWithZero.toMonoid.{0} Int (Semiring.toMonoidWithZero.{0} Int Int.semiring)) (AddCommMonoid.toAddMonoid.{u1} M (AddCommGroup.toAddCommMonoid.{u1} M _inst_3)) (Module.toDistribMulAction.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_3) h))) n x) (SMul.smul.{0, u1} Int M (SubNegMonoid.SMulInt.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_3))) n x)
but is expected to have type
  forall {M : Type.{u1}} [_inst_3 : AddCommGroup.{u1} M] (h : Module.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_3)) (n : Int) (x : M), Eq.{succ u1} M (SMul.smul.{0, u1} Int M (MulAction.toSMul.{0, u1} Int M (MonoidWithZero.toMonoid.{0} Int (Semiring.toMonoidWithZero.{0} Int Int.instSemiringInt)) (DistribMulAction.toMulAction.{0, u1} Int M (MonoidWithZero.toMonoid.{0} Int (Semiring.toMonoidWithZero.{0} Int Int.instSemiringInt)) (AddCommMonoid.toAddMonoid.{u1} M (AddCommGroup.toAddCommMonoid.{u1} M _inst_3)) (Module.toDistribMulAction.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_3) h))) n x) (HSMul.hSMul.{0, u1, u1} Int M M (instHSMul.{0, u1} Int M (SubNegMonoid.SMulInt.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_3)))) n x)
Case conversion may be inaccurate. Consider using '#align int_smul_eq_zsmul int_smul_eq_zsmulₓ'. -/
/-- Convert back any exotic `ℤ`-smul to the canonical instance. This should not be needed since in
mathlib all `add_comm_group`s should normally have exactly one `ℤ`-module structure by design. -/
theorem int_smul_eq_zsmul (h : Module ℤ M) (n : ℤ) (x : M) : @SMul.smul ℤ M h.toSMul n x = n • x :=
  by rw [zsmul_eq_smul_cast ℤ n x, Int.cast_id]
#align int_smul_eq_zsmul int_smul_eq_zsmul

/- warning: add_comm_group.int_module.unique -> AddCommGroup.intModule.unique is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_3 : AddCommGroup.{u1} M], Unique.{succ u1} (Module.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_3))
but is expected to have type
  forall {M : Type.{u1}} [_inst_3 : AddCommGroup.{u1} M], Unique.{succ u1} (Module.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_3))
Case conversion may be inaccurate. Consider using '#align add_comm_group.int_module.unique AddCommGroup.intModule.uniqueₓ'. -/
/-- All `ℤ`-module structures are equal. Not an instance since in mathlib all `add_comm_group`
should normally have exactly one `ℤ`-module structure by design. -/
def AddCommGroup.intModule.unique : Unique (Module ℤ M)
    where
  default := by infer_instance
  uniq P := Module.ext' P _ fun n => int_smul_eq_zsmul P n
#align add_comm_group.int_module.unique AddCommGroup.intModule.unique

end AddCommGroup

/- warning: map_int_cast_smul -> map_int_cast_smul is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {M₂ : Type.{u2}} [_inst_1 : AddCommGroup.{u1} M] [_inst_2 : AddCommGroup.{u2} M₂] {F : Type.{u3}} [_inst_3 : AddMonoidHomClass.{u3, u1, u2} F M M₂ (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))) (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2))))] (f : F) (R : Type.{u4}) (S : Type.{u5}) [_inst_4 : Ring.{u4} R] [_inst_5 : Ring.{u5} S] [_inst_6 : Module.{u4, u1} R M (Ring.toSemiring.{u4} R _inst_4) (AddCommGroup.toAddCommMonoid.{u1} M _inst_1)] [_inst_7 : Module.{u5, u2} S M₂ (Ring.toSemiring.{u5} S _inst_5) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2)] (x : Int) (a : M), Eq.{succ u2} M₂ (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => M -> M₂) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F M (fun (_x : M) => M₂) (AddHomClass.toFunLike.{u3, u1, u2} F M M₂ (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))))) (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2))))) (AddMonoidHomClass.toAddHomClass.{u3, u1, u2} F M M₂ (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))) (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2)))) _inst_3))) f (SMul.smul.{u4, u1} R M (SMulZeroClass.toHasSmul.{u4, u1} R M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (AddCommGroup.toAddCommMonoid.{u1} M _inst_1)))) (SMulWithZero.toSmulZeroClass.{u4, u1} R M (MulZeroClass.toHasZero.{u4} R (MulZeroOneClass.toMulZeroClass.{u4} R (MonoidWithZero.toMulZeroOneClass.{u4} R (Semiring.toMonoidWithZero.{u4} R (Ring.toSemiring.{u4} R _inst_4))))) (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (AddCommGroup.toAddCommMonoid.{u1} M _inst_1)))) (MulActionWithZero.toSMulWithZero.{u4, u1} R M (Semiring.toMonoidWithZero.{u4} R (Ring.toSemiring.{u4} R _inst_4)) (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (AddCommGroup.toAddCommMonoid.{u1} M _inst_1)))) (Module.toMulActionWithZero.{u4, u1} R M (Ring.toSemiring.{u4} R _inst_4) (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) _inst_6)))) ((fun (a : Type) (b : Type.{u4}) [self : HasLiftT.{1, succ u4} a b] => self.0) Int R (HasLiftT.mk.{1, succ u4} Int R (CoeTCₓ.coe.{1, succ u4} Int R (Int.castCoe.{u4} R (AddGroupWithOne.toHasIntCast.{u4} R (NonAssocRing.toAddGroupWithOne.{u4} R (Ring.toNonAssocRing.{u4} R _inst_4)))))) x) a)) (SMul.smul.{u5, u2} S M₂ (SMulZeroClass.toHasSmul.{u5, u2} S M₂ (AddZeroClass.toHasZero.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2)))) (SMulWithZero.toSmulZeroClass.{u5, u2} S M₂ (MulZeroClass.toHasZero.{u5} S (MulZeroOneClass.toMulZeroClass.{u5} S (MonoidWithZero.toMulZeroOneClass.{u5} S (Semiring.toMonoidWithZero.{u5} S (Ring.toSemiring.{u5} S _inst_5))))) (AddZeroClass.toHasZero.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2)))) (MulActionWithZero.toSMulWithZero.{u5, u2} S M₂ (Semiring.toMonoidWithZero.{u5} S (Ring.toSemiring.{u5} S _inst_5)) (AddZeroClass.toHasZero.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2)))) (Module.toMulActionWithZero.{u5, u2} S M₂ (Ring.toSemiring.{u5} S _inst_5) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2) _inst_7)))) ((fun (a : Type) (b : Type.{u5}) [self : HasLiftT.{1, succ u5} a b] => self.0) Int S (HasLiftT.mk.{1, succ u5} Int S (CoeTCₓ.coe.{1, succ u5} Int S (Int.castCoe.{u5} S (AddGroupWithOne.toHasIntCast.{u5} S (NonAssocRing.toAddGroupWithOne.{u5} S (Ring.toNonAssocRing.{u5} S _inst_5)))))) x) (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => M -> M₂) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F M (fun (_x : M) => M₂) (AddHomClass.toFunLike.{u3, u1, u2} F M M₂ (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))))) (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2))))) (AddMonoidHomClass.toAddHomClass.{u3, u1, u2} F M M₂ (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))) (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2)))) _inst_3))) f a))
but is expected to have type
  forall {M : Type.{u5}} {M₂ : Type.{u4}} [_inst_1 : AddCommGroup.{u5} M] [_inst_2 : AddCommGroup.{u4} M₂] {F : Type.{u3}} [_inst_3 : AddMonoidHomClass.{u3, u5, u4} F M M₂ (AddMonoid.toAddZeroClass.{u5} M (SubNegMonoid.toAddMonoid.{u5} M (AddGroup.toSubNegMonoid.{u5} M (AddCommGroup.toAddGroup.{u5} M _inst_1)))) (AddMonoid.toAddZeroClass.{u4} M₂ (SubNegMonoid.toAddMonoid.{u4} M₂ (AddGroup.toSubNegMonoid.{u4} M₂ (AddCommGroup.toAddGroup.{u4} M₂ _inst_2))))] (f : F) (R : Type.{u2}) (S : Type.{u1}) [_inst_4 : Ring.{u2} R] [_inst_5 : Ring.{u1} S] [_inst_6 : Module.{u2, u5} R M (Ring.toSemiring.{u2} R _inst_4) (AddCommGroup.toAddCommMonoid.{u5} M _inst_1)] [_inst_7 : Module.{u1, u4} S M₂ (Ring.toSemiring.{u1} S _inst_5) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_2)] (x : Int) (a : M), Eq.{succ u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) (HSMul.hSMul.{u2, u5, u5} R M M (instHSMul.{u2, u5} R M (SMulZeroClass.toSMul.{u2, u5} R M (NegZeroClass.toZero.{u5} M (SubNegZeroMonoid.toNegZeroClass.{u5} M (SubtractionMonoid.toSubNegZeroMonoid.{u5} M (SubtractionCommMonoid.toSubtractionMonoid.{u5} M (AddCommGroup.toDivisionAddCommMonoid.{u5} M _inst_1))))) (SMulWithZero.toSMulZeroClass.{u2, u5} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_4))) (NegZeroClass.toZero.{u5} M (SubNegZeroMonoid.toNegZeroClass.{u5} M (SubtractionMonoid.toSubNegZeroMonoid.{u5} M (SubtractionCommMonoid.toSubtractionMonoid.{u5} M (AddCommGroup.toDivisionAddCommMonoid.{u5} M _inst_1))))) (MulActionWithZero.toSMulWithZero.{u2, u5} R M (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_4)) (NegZeroClass.toZero.{u5} M (SubNegZeroMonoid.toNegZeroClass.{u5} M (SubtractionMonoid.toSubNegZeroMonoid.{u5} M (SubtractionCommMonoid.toSubtractionMonoid.{u5} M (AddCommGroup.toDivisionAddCommMonoid.{u5} M _inst_1))))) (Module.toMulActionWithZero.{u2, u5} R M (Ring.toSemiring.{u2} R _inst_4) (AddCommGroup.toAddCommMonoid.{u5} M _inst_1) _inst_6))))) (Int.cast.{u2} R (Ring.toIntCast.{u2} R _inst_4) x) a)) (FunLike.coe.{succ u3, succ u5, succ u4} F M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) _x) (AddHomClass.toFunLike.{u3, u5, u4} F M M₂ (AddZeroClass.toAdd.{u5} M (AddMonoid.toAddZeroClass.{u5} M (SubNegMonoid.toAddMonoid.{u5} M (AddGroup.toSubNegMonoid.{u5} M (AddCommGroup.toAddGroup.{u5} M _inst_1))))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (SubNegMonoid.toAddMonoid.{u4} M₂ (AddGroup.toSubNegMonoid.{u4} M₂ (AddCommGroup.toAddGroup.{u4} M₂ _inst_2))))) (AddMonoidHomClass.toAddHomClass.{u3, u5, u4} F M M₂ (AddMonoid.toAddZeroClass.{u5} M (SubNegMonoid.toAddMonoid.{u5} M (AddGroup.toSubNegMonoid.{u5} M (AddCommGroup.toAddGroup.{u5} M _inst_1)))) (AddMonoid.toAddZeroClass.{u4} M₂ (SubNegMonoid.toAddMonoid.{u4} M₂ (AddGroup.toSubNegMonoid.{u4} M₂ (AddCommGroup.toAddGroup.{u4} M₂ _inst_2)))) _inst_3)) f (HSMul.hSMul.{u2, u5, u5} R M M (instHSMul.{u2, u5} R M (SMulZeroClass.toSMul.{u2, u5} R M (NegZeroClass.toZero.{u5} M (SubNegZeroMonoid.toNegZeroClass.{u5} M (SubtractionMonoid.toSubNegZeroMonoid.{u5} M (SubtractionCommMonoid.toSubtractionMonoid.{u5} M (AddCommGroup.toDivisionAddCommMonoid.{u5} M _inst_1))))) (SMulWithZero.toSMulZeroClass.{u2, u5} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_4))) (NegZeroClass.toZero.{u5} M (SubNegZeroMonoid.toNegZeroClass.{u5} M (SubtractionMonoid.toSubNegZeroMonoid.{u5} M (SubtractionCommMonoid.toSubtractionMonoid.{u5} M (AddCommGroup.toDivisionAddCommMonoid.{u5} M _inst_1))))) (MulActionWithZero.toSMulWithZero.{u2, u5} R M (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_4)) (NegZeroClass.toZero.{u5} M (SubNegZeroMonoid.toNegZeroClass.{u5} M (SubtractionMonoid.toSubNegZeroMonoid.{u5} M (SubtractionCommMonoid.toSubtractionMonoid.{u5} M (AddCommGroup.toDivisionAddCommMonoid.{u5} M _inst_1))))) (Module.toMulActionWithZero.{u2, u5} R M (Ring.toSemiring.{u2} R _inst_4) (AddCommGroup.toAddCommMonoid.{u5} M _inst_1) _inst_6))))) (Int.cast.{u2} R (Ring.toIntCast.{u2} R _inst_4) x) a)) (HSMul.hSMul.{u1, u4, u4} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) (instHSMul.{u1, u4} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) (SMulZeroClass.toSMul.{u1, u4} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) (NegZeroClass.toZero.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) (SubNegZeroMonoid.toNegZeroClass.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) (SubtractionMonoid.toSubNegZeroMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) (SubtractionCommMonoid.toSubtractionMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) (AddCommGroup.toDivisionAddCommMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u4} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) (MonoidWithZero.toZero.{u1} S (Semiring.toMonoidWithZero.{u1} S (Ring.toSemiring.{u1} S _inst_5))) (NegZeroClass.toZero.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) (SubNegZeroMonoid.toNegZeroClass.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) (SubtractionMonoid.toSubNegZeroMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) (SubtractionCommMonoid.toSubtractionMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) (AddCommGroup.toDivisionAddCommMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u4} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) (Semiring.toMonoidWithZero.{u1} S (Ring.toSemiring.{u1} S _inst_5)) (NegZeroClass.toZero.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) (SubNegZeroMonoid.toNegZeroClass.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) (SubtractionMonoid.toSubNegZeroMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) (SubtractionCommMonoid.toSubtractionMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) (AddCommGroup.toDivisionAddCommMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) _inst_2))))) (Module.toMulActionWithZero.{u1, u4} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) (Ring.toSemiring.{u1} S _inst_5) (AddCommGroup.toAddCommMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) _inst_2) _inst_7))))) (Int.cast.{u1} S (Ring.toIntCast.{u1} S _inst_5) x) (FunLike.coe.{succ u3, succ u5, succ u4} F M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) _x) (AddHomClass.toFunLike.{u3, u5, u4} F M M₂ (AddZeroClass.toAdd.{u5} M (AddMonoid.toAddZeroClass.{u5} M (SubNegMonoid.toAddMonoid.{u5} M (AddGroup.toSubNegMonoid.{u5} M (AddCommGroup.toAddGroup.{u5} M _inst_1))))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (SubNegMonoid.toAddMonoid.{u4} M₂ (AddGroup.toSubNegMonoid.{u4} M₂ (AddCommGroup.toAddGroup.{u4} M₂ _inst_2))))) (AddMonoidHomClass.toAddHomClass.{u3, u5, u4} F M M₂ (AddMonoid.toAddZeroClass.{u5} M (SubNegMonoid.toAddMonoid.{u5} M (AddGroup.toSubNegMonoid.{u5} M (AddCommGroup.toAddGroup.{u5} M _inst_1)))) (AddMonoid.toAddZeroClass.{u4} M₂ (SubNegMonoid.toAddMonoid.{u4} M₂ (AddGroup.toSubNegMonoid.{u4} M₂ (AddCommGroup.toAddGroup.{u4} M₂ _inst_2)))) _inst_3)) f a))
Case conversion may be inaccurate. Consider using '#align map_int_cast_smul map_int_cast_smulₓ'. -/
theorem map_int_cast_smul [AddCommGroup M] [AddCommGroup M₂] {F : Type _} [AddMonoidHomClass F M M₂]
    (f : F) (R S : Type _) [Ring R] [Ring S] [Module R M] [Module S M₂] (x : ℤ) (a : M) :
    f ((x : R) • a) = (x : S) • f a := by simp only [← zsmul_eq_smul_cast, map_zsmul]
#align map_int_cast_smul map_int_cast_smul

/- warning: map_nat_cast_smul -> map_nat_cast_smul is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {M₂ : Type.{u2}} [_inst_1 : AddCommMonoid.{u1} M] [_inst_2 : AddCommMonoid.{u2} M₂] {F : Type.{u3}} [_inst_3 : AddMonoidHomClass.{u3, u1, u2} F M M₂ (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)) (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_2))] (f : F) (R : Type.{u4}) (S : Type.{u5}) [_inst_4 : Semiring.{u4} R] [_inst_5 : Semiring.{u5} S] [_inst_6 : Module.{u4, u1} R M _inst_4 _inst_1] [_inst_7 : Module.{u5, u2} S M₂ _inst_5 _inst_2] (x : Nat) (a : M), Eq.{succ u2} M₂ (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => M -> M₂) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F M (fun (_x : M) => M₂) (AddHomClass.toFunLike.{u3, u1, u2} F M M₂ (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_2))) (AddMonoidHomClass.toAddHomClass.{u3, u1, u2} F M M₂ (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)) (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_2)) _inst_3))) f (SMul.smul.{u4, u1} R M (SMulZeroClass.toHasSmul.{u4, u1} R M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (SMulWithZero.toSmulZeroClass.{u4, u1} R M (MulZeroClass.toHasZero.{u4} R (MulZeroOneClass.toMulZeroClass.{u4} R (MonoidWithZero.toMulZeroOneClass.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_4)))) (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (MulActionWithZero.toSMulWithZero.{u4, u1} R M (Semiring.toMonoidWithZero.{u4} R _inst_4) (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (Module.toMulActionWithZero.{u4, u1} R M _inst_4 _inst_1 _inst_6)))) ((fun (a : Type) (b : Type.{u4}) [self : HasLiftT.{1, succ u4} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u4} Nat R (CoeTCₓ.coe.{1, succ u4} Nat R (Nat.castCoe.{u4} R (AddMonoidWithOne.toNatCast.{u4} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u4} R (NonAssocSemiring.toAddCommMonoidWithOne.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_4))))))) x) a)) (SMul.smul.{u5, u2} S M₂ (SMulZeroClass.toHasSmul.{u5, u2} S M₂ (AddZeroClass.toHasZero.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_2))) (SMulWithZero.toSmulZeroClass.{u5, u2} S M₂ (MulZeroClass.toHasZero.{u5} S (MulZeroOneClass.toMulZeroClass.{u5} S (MonoidWithZero.toMulZeroOneClass.{u5} S (Semiring.toMonoidWithZero.{u5} S _inst_5)))) (AddZeroClass.toHasZero.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_2))) (MulActionWithZero.toSMulWithZero.{u5, u2} S M₂ (Semiring.toMonoidWithZero.{u5} S _inst_5) (AddZeroClass.toHasZero.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_2))) (Module.toMulActionWithZero.{u5, u2} S M₂ _inst_5 _inst_2 _inst_7)))) ((fun (a : Type) (b : Type.{u5}) [self : HasLiftT.{1, succ u5} a b] => self.0) Nat S (HasLiftT.mk.{1, succ u5} Nat S (CoeTCₓ.coe.{1, succ u5} Nat S (Nat.castCoe.{u5} S (AddMonoidWithOne.toNatCast.{u5} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u5} S (NonAssocSemiring.toAddCommMonoidWithOne.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_5))))))) x) (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => M -> M₂) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F M (fun (_x : M) => M₂) (AddHomClass.toFunLike.{u3, u1, u2} F M M₂ (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_2))) (AddMonoidHomClass.toAddHomClass.{u3, u1, u2} F M M₂ (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)) (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ _inst_2)) _inst_3))) f a))
but is expected to have type
  forall {M : Type.{u5}} {M₂ : Type.{u4}} [_inst_1 : AddCommMonoid.{u5} M] [_inst_2 : AddCommMonoid.{u4} M₂] {F : Type.{u3}} [_inst_3 : AddMonoidHomClass.{u3, u5, u4} F M M₂ (AddMonoid.toAddZeroClass.{u5} M (AddCommMonoid.toAddMonoid.{u5} M _inst_1)) (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_2))] (f : F) (R : Type.{u2}) (S : Type.{u1}) [_inst_4 : Semiring.{u2} R] [_inst_5 : Semiring.{u1} S] [_inst_6 : Module.{u2, u5} R M _inst_4 _inst_1] [_inst_7 : Module.{u1, u4} S M₂ _inst_5 _inst_2] (x : Nat) (a : M), Eq.{succ u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) (HSMul.hSMul.{u2, u5, u5} R M M (instHSMul.{u2, u5} R M (SMulZeroClass.toSMul.{u2, u5} R M (AddMonoid.toZero.{u5} M (AddCommMonoid.toAddMonoid.{u5} M _inst_1)) (SMulWithZero.toSMulZeroClass.{u2, u5} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_4)) (AddMonoid.toZero.{u5} M (AddCommMonoid.toAddMonoid.{u5} M _inst_1)) (MulActionWithZero.toSMulWithZero.{u2, u5} R M (Semiring.toMonoidWithZero.{u2} R _inst_4) (AddMonoid.toZero.{u5} M (AddCommMonoid.toAddMonoid.{u5} M _inst_1)) (Module.toMulActionWithZero.{u2, u5} R M _inst_4 _inst_1 _inst_6))))) (Nat.cast.{u2} R (Semiring.toNatCast.{u2} R _inst_4) x) a)) (FunLike.coe.{succ u3, succ u5, succ u4} F M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) _x) (AddHomClass.toFunLike.{u3, u5, u4} F M M₂ (AddZeroClass.toAdd.{u5} M (AddMonoid.toAddZeroClass.{u5} M (AddCommMonoid.toAddMonoid.{u5} M _inst_1))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_2))) (AddMonoidHomClass.toAddHomClass.{u3, u5, u4} F M M₂ (AddMonoid.toAddZeroClass.{u5} M (AddCommMonoid.toAddMonoid.{u5} M _inst_1)) (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_2)) _inst_3)) f (HSMul.hSMul.{u2, u5, u5} R M M (instHSMul.{u2, u5} R M (SMulZeroClass.toSMul.{u2, u5} R M (AddMonoid.toZero.{u5} M (AddCommMonoid.toAddMonoid.{u5} M _inst_1)) (SMulWithZero.toSMulZeroClass.{u2, u5} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_4)) (AddMonoid.toZero.{u5} M (AddCommMonoid.toAddMonoid.{u5} M _inst_1)) (MulActionWithZero.toSMulWithZero.{u2, u5} R M (Semiring.toMonoidWithZero.{u2} R _inst_4) (AddMonoid.toZero.{u5} M (AddCommMonoid.toAddMonoid.{u5} M _inst_1)) (Module.toMulActionWithZero.{u2, u5} R M _inst_4 _inst_1 _inst_6))))) (Nat.cast.{u2} R (Semiring.toNatCast.{u2} R _inst_4) x) a)) (HSMul.hSMul.{u1, u4, u4} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) (instHSMul.{u1, u4} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) (SMulZeroClass.toSMul.{u1, u4} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) (AddMonoid.toZero.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) (AddCommMonoid.toAddMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u4} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) (MonoidWithZero.toZero.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_5)) (AddMonoid.toZero.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) (AddCommMonoid.toAddMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u4} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) (Semiring.toMonoidWithZero.{u1} S _inst_5) (AddMonoid.toZero.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) (AddCommMonoid.toAddMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) _inst_2)) (Module.toMulActionWithZero.{u1, u4} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) a) _inst_5 _inst_2 _inst_7))))) (Nat.cast.{u1} S (Semiring.toNatCast.{u1} S _inst_5) x) (FunLike.coe.{succ u3, succ u5, succ u4} F M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) _x) (AddHomClass.toFunLike.{u3, u5, u4} F M M₂ (AddZeroClass.toAdd.{u5} M (AddMonoid.toAddZeroClass.{u5} M (AddCommMonoid.toAddMonoid.{u5} M _inst_1))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_2))) (AddMonoidHomClass.toAddHomClass.{u3, u5, u4} F M M₂ (AddMonoid.toAddZeroClass.{u5} M (AddCommMonoid.toAddMonoid.{u5} M _inst_1)) (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_2)) _inst_3)) f a))
Case conversion may be inaccurate. Consider using '#align map_nat_cast_smul map_nat_cast_smulₓ'. -/
theorem map_nat_cast_smul [AddCommMonoid M] [AddCommMonoid M₂] {F : Type _}
    [AddMonoidHomClass F M M₂] (f : F) (R S : Type _) [Semiring R] [Semiring S] [Module R M]
    [Module S M₂] (x : ℕ) (a : M) : f ((x : R) • a) = (x : S) • f a := by
  simp only [← nsmul_eq_smul_cast, map_nsmul]
#align map_nat_cast_smul map_nat_cast_smul

/- warning: map_inv_int_cast_smul -> map_inv_int_cast_smul is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {M₂ : Type.{u2}} [_inst_1 : AddCommGroup.{u1} M] [_inst_2 : AddCommGroup.{u2} M₂] {F : Type.{u3}} [_inst_3 : AddMonoidHomClass.{u3, u1, u2} F M M₂ (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))) (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2))))] (f : F) (R : Type.{u4}) (S : Type.{u5}) [_inst_4 : DivisionRing.{u4} R] [_inst_5 : DivisionRing.{u5} S] [_inst_6 : Module.{u4, u1} R M (Ring.toSemiring.{u4} R (DivisionRing.toRing.{u4} R _inst_4)) (AddCommGroup.toAddCommMonoid.{u1} M _inst_1)] [_inst_7 : Module.{u5, u2} S M₂ (Ring.toSemiring.{u5} S (DivisionRing.toRing.{u5} S _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2)] (n : Int) (x : M), Eq.{succ u2} M₂ (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => M -> M₂) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F M (fun (_x : M) => M₂) (AddHomClass.toFunLike.{u3, u1, u2} F M M₂ (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))))) (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2))))) (AddMonoidHomClass.toAddHomClass.{u3, u1, u2} F M M₂ (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))) (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2)))) _inst_3))) f (SMul.smul.{u4, u1} R M (SMulZeroClass.toHasSmul.{u4, u1} R M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (AddCommGroup.toAddCommMonoid.{u1} M _inst_1)))) (SMulWithZero.toSmulZeroClass.{u4, u1} R M (MulZeroClass.toHasZero.{u4} R (MulZeroOneClass.toMulZeroClass.{u4} R (MonoidWithZero.toMulZeroOneClass.{u4} R (Semiring.toMonoidWithZero.{u4} R (Ring.toSemiring.{u4} R (DivisionRing.toRing.{u4} R _inst_4)))))) (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (AddCommGroup.toAddCommMonoid.{u1} M _inst_1)))) (MulActionWithZero.toSMulWithZero.{u4, u1} R M (Semiring.toMonoidWithZero.{u4} R (Ring.toSemiring.{u4} R (DivisionRing.toRing.{u4} R _inst_4))) (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (AddCommGroup.toAddCommMonoid.{u1} M _inst_1)))) (Module.toMulActionWithZero.{u4, u1} R M (Ring.toSemiring.{u4} R (DivisionRing.toRing.{u4} R _inst_4)) (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) _inst_6)))) (Inv.inv.{u4} R (DivInvMonoid.toHasInv.{u4} R (DivisionRing.toDivInvMonoid.{u4} R _inst_4)) ((fun (a : Type) (b : Type.{u4}) [self : HasLiftT.{1, succ u4} a b] => self.0) Int R (HasLiftT.mk.{1, succ u4} Int R (CoeTCₓ.coe.{1, succ u4} Int R (Int.castCoe.{u4} R (AddGroupWithOne.toHasIntCast.{u4} R (NonAssocRing.toAddGroupWithOne.{u4} R (Ring.toNonAssocRing.{u4} R (DivisionRing.toRing.{u4} R _inst_4))))))) n)) x)) (SMul.smul.{u5, u2} S M₂ (SMulZeroClass.toHasSmul.{u5, u2} S M₂ (AddZeroClass.toHasZero.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2)))) (SMulWithZero.toSmulZeroClass.{u5, u2} S M₂ (MulZeroClass.toHasZero.{u5} S (MulZeroOneClass.toMulZeroClass.{u5} S (MonoidWithZero.toMulZeroOneClass.{u5} S (Semiring.toMonoidWithZero.{u5} S (Ring.toSemiring.{u5} S (DivisionRing.toRing.{u5} S _inst_5)))))) (AddZeroClass.toHasZero.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2)))) (MulActionWithZero.toSMulWithZero.{u5, u2} S M₂ (Semiring.toMonoidWithZero.{u5} S (Ring.toSemiring.{u5} S (DivisionRing.toRing.{u5} S _inst_5))) (AddZeroClass.toHasZero.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2)))) (Module.toMulActionWithZero.{u5, u2} S M₂ (Ring.toSemiring.{u5} S (DivisionRing.toRing.{u5} S _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2) _inst_7)))) (Inv.inv.{u5} S (DivInvMonoid.toHasInv.{u5} S (DivisionRing.toDivInvMonoid.{u5} S _inst_5)) ((fun (a : Type) (b : Type.{u5}) [self : HasLiftT.{1, succ u5} a b] => self.0) Int S (HasLiftT.mk.{1, succ u5} Int S (CoeTCₓ.coe.{1, succ u5} Int S (Int.castCoe.{u5} S (AddGroupWithOne.toHasIntCast.{u5} S (NonAssocRing.toAddGroupWithOne.{u5} S (Ring.toNonAssocRing.{u5} S (DivisionRing.toRing.{u5} S _inst_5))))))) n)) (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => M -> M₂) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F M (fun (_x : M) => M₂) (AddHomClass.toFunLike.{u3, u1, u2} F M M₂ (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))))) (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2))))) (AddMonoidHomClass.toAddHomClass.{u3, u1, u2} F M M₂ (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))) (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2)))) _inst_3))) f x))
but is expected to have type
  forall {M : Type.{u5}} {M₂ : Type.{u4}} [_inst_1 : AddCommGroup.{u5} M] [_inst_2 : AddCommGroup.{u4} M₂] {F : Type.{u3}} [_inst_3 : AddMonoidHomClass.{u3, u5, u4} F M M₂ (AddMonoid.toAddZeroClass.{u5} M (SubNegMonoid.toAddMonoid.{u5} M (AddGroup.toSubNegMonoid.{u5} M (AddCommGroup.toAddGroup.{u5} M _inst_1)))) (AddMonoid.toAddZeroClass.{u4} M₂ (SubNegMonoid.toAddMonoid.{u4} M₂ (AddGroup.toSubNegMonoid.{u4} M₂ (AddCommGroup.toAddGroup.{u4} M₂ _inst_2))))] (f : F) (R : Type.{u2}) (S : Type.{u1}) [_inst_4 : DivisionRing.{u2} R] [_inst_5 : DivisionRing.{u1} S] [_inst_6 : Module.{u2, u5} R M (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_4)) (AddCommGroup.toAddCommMonoid.{u5} M _inst_1)] [_inst_7 : Module.{u1, u4} S M₂ (DivisionSemiring.toSemiring.{u1} S (DivisionRing.toDivisionSemiring.{u1} S _inst_5)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_2)] (n : Int) (x : M), Eq.{succ u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) (HSMul.hSMul.{u2, u5, u5} R M M (instHSMul.{u2, u5} R M (SMulZeroClass.toSMul.{u2, u5} R M (NegZeroClass.toZero.{u5} M (SubNegZeroMonoid.toNegZeroClass.{u5} M (SubtractionMonoid.toSubNegZeroMonoid.{u5} M (SubtractionCommMonoid.toSubtractionMonoid.{u5} M (AddCommGroup.toDivisionAddCommMonoid.{u5} M _inst_1))))) (SMulWithZero.toSMulZeroClass.{u2, u5} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_4)))) (NegZeroClass.toZero.{u5} M (SubNegZeroMonoid.toNegZeroClass.{u5} M (SubtractionMonoid.toSubNegZeroMonoid.{u5} M (SubtractionCommMonoid.toSubtractionMonoid.{u5} M (AddCommGroup.toDivisionAddCommMonoid.{u5} M _inst_1))))) (MulActionWithZero.toSMulWithZero.{u2, u5} R M (Semiring.toMonoidWithZero.{u2} R (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_4))) (NegZeroClass.toZero.{u5} M (SubNegZeroMonoid.toNegZeroClass.{u5} M (SubtractionMonoid.toSubNegZeroMonoid.{u5} M (SubtractionCommMonoid.toSubtractionMonoid.{u5} M (AddCommGroup.toDivisionAddCommMonoid.{u5} M _inst_1))))) (Module.toMulActionWithZero.{u2, u5} R M (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_4)) (AddCommGroup.toAddCommMonoid.{u5} M _inst_1) _inst_6))))) (Inv.inv.{u2} R (DivisionRing.toInv.{u2} R _inst_4) (Int.cast.{u2} R (Ring.toIntCast.{u2} R (DivisionRing.toRing.{u2} R _inst_4)) n)) x)) (FunLike.coe.{succ u3, succ u5, succ u4} F M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) _x) (AddHomClass.toFunLike.{u3, u5, u4} F M M₂ (AddZeroClass.toAdd.{u5} M (AddMonoid.toAddZeroClass.{u5} M (SubNegMonoid.toAddMonoid.{u5} M (AddGroup.toSubNegMonoid.{u5} M (AddCommGroup.toAddGroup.{u5} M _inst_1))))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (SubNegMonoid.toAddMonoid.{u4} M₂ (AddGroup.toSubNegMonoid.{u4} M₂ (AddCommGroup.toAddGroup.{u4} M₂ _inst_2))))) (AddMonoidHomClass.toAddHomClass.{u3, u5, u4} F M M₂ (AddMonoid.toAddZeroClass.{u5} M (SubNegMonoid.toAddMonoid.{u5} M (AddGroup.toSubNegMonoid.{u5} M (AddCommGroup.toAddGroup.{u5} M _inst_1)))) (AddMonoid.toAddZeroClass.{u4} M₂ (SubNegMonoid.toAddMonoid.{u4} M₂ (AddGroup.toSubNegMonoid.{u4} M₂ (AddCommGroup.toAddGroup.{u4} M₂ _inst_2)))) _inst_3)) f (HSMul.hSMul.{u2, u5, u5} R M M (instHSMul.{u2, u5} R M (SMulZeroClass.toSMul.{u2, u5} R M (NegZeroClass.toZero.{u5} M (SubNegZeroMonoid.toNegZeroClass.{u5} M (SubtractionMonoid.toSubNegZeroMonoid.{u5} M (SubtractionCommMonoid.toSubtractionMonoid.{u5} M (AddCommGroup.toDivisionAddCommMonoid.{u5} M _inst_1))))) (SMulWithZero.toSMulZeroClass.{u2, u5} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_4)))) (NegZeroClass.toZero.{u5} M (SubNegZeroMonoid.toNegZeroClass.{u5} M (SubtractionMonoid.toSubNegZeroMonoid.{u5} M (SubtractionCommMonoid.toSubtractionMonoid.{u5} M (AddCommGroup.toDivisionAddCommMonoid.{u5} M _inst_1))))) (MulActionWithZero.toSMulWithZero.{u2, u5} R M (Semiring.toMonoidWithZero.{u2} R (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_4))) (NegZeroClass.toZero.{u5} M (SubNegZeroMonoid.toNegZeroClass.{u5} M (SubtractionMonoid.toSubNegZeroMonoid.{u5} M (SubtractionCommMonoid.toSubtractionMonoid.{u5} M (AddCommGroup.toDivisionAddCommMonoid.{u5} M _inst_1))))) (Module.toMulActionWithZero.{u2, u5} R M (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_4)) (AddCommGroup.toAddCommMonoid.{u5} M _inst_1) _inst_6))))) (Inv.inv.{u2} R (DivisionRing.toInv.{u2} R _inst_4) (Int.cast.{u2} R (Ring.toIntCast.{u2} R (DivisionRing.toRing.{u2} R _inst_4)) n)) x)) (HSMul.hSMul.{u1, u4, u4} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (instHSMul.{u1, u4} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SMulZeroClass.toSMul.{u1, u4} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (NegZeroClass.toZero.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubNegZeroMonoid.toNegZeroClass.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubtractionMonoid.toSubNegZeroMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubtractionCommMonoid.toSubtractionMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (AddCommGroup.toDivisionAddCommMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u4} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (MonoidWithZero.toZero.{u1} S (Semiring.toMonoidWithZero.{u1} S (DivisionSemiring.toSemiring.{u1} S (DivisionRing.toDivisionSemiring.{u1} S _inst_5)))) (NegZeroClass.toZero.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubNegZeroMonoid.toNegZeroClass.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubtractionMonoid.toSubNegZeroMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubtractionCommMonoid.toSubtractionMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (AddCommGroup.toDivisionAddCommMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u4} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (Semiring.toMonoidWithZero.{u1} S (DivisionSemiring.toSemiring.{u1} S (DivisionRing.toDivisionSemiring.{u1} S _inst_5))) (NegZeroClass.toZero.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubNegZeroMonoid.toNegZeroClass.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubtractionMonoid.toSubNegZeroMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubtractionCommMonoid.toSubtractionMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (AddCommGroup.toDivisionAddCommMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) _inst_2))))) (Module.toMulActionWithZero.{u1, u4} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (DivisionSemiring.toSemiring.{u1} S (DivisionRing.toDivisionSemiring.{u1} S _inst_5)) (AddCommGroup.toAddCommMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) _inst_2) _inst_7))))) (Inv.inv.{u1} S (DivisionRing.toInv.{u1} S _inst_5) (Int.cast.{u1} S (Ring.toIntCast.{u1} S (DivisionRing.toRing.{u1} S _inst_5)) n)) (FunLike.coe.{succ u3, succ u5, succ u4} F M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) _x) (AddHomClass.toFunLike.{u3, u5, u4} F M M₂ (AddZeroClass.toAdd.{u5} M (AddMonoid.toAddZeroClass.{u5} M (SubNegMonoid.toAddMonoid.{u5} M (AddGroup.toSubNegMonoid.{u5} M (AddCommGroup.toAddGroup.{u5} M _inst_1))))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (SubNegMonoid.toAddMonoid.{u4} M₂ (AddGroup.toSubNegMonoid.{u4} M₂ (AddCommGroup.toAddGroup.{u4} M₂ _inst_2))))) (AddMonoidHomClass.toAddHomClass.{u3, u5, u4} F M M₂ (AddMonoid.toAddZeroClass.{u5} M (SubNegMonoid.toAddMonoid.{u5} M (AddGroup.toSubNegMonoid.{u5} M (AddCommGroup.toAddGroup.{u5} M _inst_1)))) (AddMonoid.toAddZeroClass.{u4} M₂ (SubNegMonoid.toAddMonoid.{u4} M₂ (AddGroup.toSubNegMonoid.{u4} M₂ (AddCommGroup.toAddGroup.{u4} M₂ _inst_2)))) _inst_3)) f x))
Case conversion may be inaccurate. Consider using '#align map_inv_int_cast_smul map_inv_int_cast_smulₓ'. -/
theorem map_inv_int_cast_smul [AddCommGroup M] [AddCommGroup M₂] {F : Type _}
    [AddMonoidHomClass F M M₂] (f : F) (R S : Type _) [DivisionRing R] [DivisionRing S] [Module R M]
    [Module S M₂] (n : ℤ) (x : M) : f ((n⁻¹ : R) • x) = (n⁻¹ : S) • f x :=
  by
  by_cases hR : (n : R) = 0 <;> by_cases hS : (n : S) = 0
  · simp [hR, hS]
  · suffices ∀ y, f y = 0 by simp [this]
    clear x
    intro x
    rw [← inv_smul_smul₀ hS (f x), ← map_int_cast_smul f R S]
    simp [hR]
  · suffices ∀ y, f y = 0 by simp [this]
    clear x
    intro x
    rw [← smul_inv_smul₀ hR x, map_int_cast_smul f R S, hS, zero_smul]
  · rw [← inv_smul_smul₀ hS (f _), ← map_int_cast_smul f R S, smul_inv_smul₀ hR]
#align map_inv_int_cast_smul map_inv_int_cast_smul

/- warning: map_inv_nat_cast_smul -> map_inv_nat_cast_smul is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {M₂ : Type.{u2}} [_inst_1 : AddCommGroup.{u1} M] [_inst_2 : AddCommGroup.{u2} M₂] {F : Type.{u3}} [_inst_3 : AddMonoidHomClass.{u3, u1, u2} F M M₂ (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))) (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2))))] (f : F) (R : Type.{u4}) (S : Type.{u5}) [_inst_4 : DivisionRing.{u4} R] [_inst_5 : DivisionRing.{u5} S] [_inst_6 : Module.{u4, u1} R M (Ring.toSemiring.{u4} R (DivisionRing.toRing.{u4} R _inst_4)) (AddCommGroup.toAddCommMonoid.{u1} M _inst_1)] [_inst_7 : Module.{u5, u2} S M₂ (Ring.toSemiring.{u5} S (DivisionRing.toRing.{u5} S _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2)] (n : Nat) (x : M), Eq.{succ u2} M₂ (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => M -> M₂) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F M (fun (_x : M) => M₂) (AddHomClass.toFunLike.{u3, u1, u2} F M M₂ (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))))) (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2))))) (AddMonoidHomClass.toAddHomClass.{u3, u1, u2} F M M₂ (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))) (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2)))) _inst_3))) f (SMul.smul.{u4, u1} R M (SMulZeroClass.toHasSmul.{u4, u1} R M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (AddCommGroup.toAddCommMonoid.{u1} M _inst_1)))) (SMulWithZero.toSmulZeroClass.{u4, u1} R M (MulZeroClass.toHasZero.{u4} R (MulZeroOneClass.toMulZeroClass.{u4} R (MonoidWithZero.toMulZeroOneClass.{u4} R (Semiring.toMonoidWithZero.{u4} R (Ring.toSemiring.{u4} R (DivisionRing.toRing.{u4} R _inst_4)))))) (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (AddCommGroup.toAddCommMonoid.{u1} M _inst_1)))) (MulActionWithZero.toSMulWithZero.{u4, u1} R M (Semiring.toMonoidWithZero.{u4} R (Ring.toSemiring.{u4} R (DivisionRing.toRing.{u4} R _inst_4))) (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (AddCommGroup.toAddCommMonoid.{u1} M _inst_1)))) (Module.toMulActionWithZero.{u4, u1} R M (Ring.toSemiring.{u4} R (DivisionRing.toRing.{u4} R _inst_4)) (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) _inst_6)))) (Inv.inv.{u4} R (DivInvMonoid.toHasInv.{u4} R (DivisionRing.toDivInvMonoid.{u4} R _inst_4)) ((fun (a : Type) (b : Type.{u4}) [self : HasLiftT.{1, succ u4} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u4} Nat R (CoeTCₓ.coe.{1, succ u4} Nat R (Nat.castCoe.{u4} R (AddMonoidWithOne.toNatCast.{u4} R (AddGroupWithOne.toAddMonoidWithOne.{u4} R (NonAssocRing.toAddGroupWithOne.{u4} R (Ring.toNonAssocRing.{u4} R (DivisionRing.toRing.{u4} R _inst_4)))))))) n)) x)) (SMul.smul.{u5, u2} S M₂ (SMulZeroClass.toHasSmul.{u5, u2} S M₂ (AddZeroClass.toHasZero.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2)))) (SMulWithZero.toSmulZeroClass.{u5, u2} S M₂ (MulZeroClass.toHasZero.{u5} S (MulZeroOneClass.toMulZeroClass.{u5} S (MonoidWithZero.toMulZeroOneClass.{u5} S (Semiring.toMonoidWithZero.{u5} S (Ring.toSemiring.{u5} S (DivisionRing.toRing.{u5} S _inst_5)))))) (AddZeroClass.toHasZero.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2)))) (MulActionWithZero.toSMulWithZero.{u5, u2} S M₂ (Semiring.toMonoidWithZero.{u5} S (Ring.toSemiring.{u5} S (DivisionRing.toRing.{u5} S _inst_5))) (AddZeroClass.toHasZero.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2)))) (Module.toMulActionWithZero.{u5, u2} S M₂ (Ring.toSemiring.{u5} S (DivisionRing.toRing.{u5} S _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2) _inst_7)))) (Inv.inv.{u5} S (DivInvMonoid.toHasInv.{u5} S (DivisionRing.toDivInvMonoid.{u5} S _inst_5)) ((fun (a : Type) (b : Type.{u5}) [self : HasLiftT.{1, succ u5} a b] => self.0) Nat S (HasLiftT.mk.{1, succ u5} Nat S (CoeTCₓ.coe.{1, succ u5} Nat S (Nat.castCoe.{u5} S (AddMonoidWithOne.toNatCast.{u5} S (AddGroupWithOne.toAddMonoidWithOne.{u5} S (NonAssocRing.toAddGroupWithOne.{u5} S (Ring.toNonAssocRing.{u5} S (DivisionRing.toRing.{u5} S _inst_5)))))))) n)) (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => M -> M₂) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F M (fun (_x : M) => M₂) (AddHomClass.toFunLike.{u3, u1, u2} F M M₂ (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))))) (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2))))) (AddMonoidHomClass.toAddHomClass.{u3, u1, u2} F M M₂ (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))) (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2)))) _inst_3))) f x))
but is expected to have type
  forall {M : Type.{u5}} {M₂ : Type.{u4}} [_inst_1 : AddCommGroup.{u5} M] [_inst_2 : AddCommGroup.{u4} M₂] {F : Type.{u3}} [_inst_3 : AddMonoidHomClass.{u3, u5, u4} F M M₂ (AddMonoid.toAddZeroClass.{u5} M (SubNegMonoid.toAddMonoid.{u5} M (AddGroup.toSubNegMonoid.{u5} M (AddCommGroup.toAddGroup.{u5} M _inst_1)))) (AddMonoid.toAddZeroClass.{u4} M₂ (SubNegMonoid.toAddMonoid.{u4} M₂ (AddGroup.toSubNegMonoid.{u4} M₂ (AddCommGroup.toAddGroup.{u4} M₂ _inst_2))))] (f : F) (R : Type.{u2}) (S : Type.{u1}) [_inst_4 : DivisionRing.{u2} R] [_inst_5 : DivisionRing.{u1} S] [_inst_6 : Module.{u2, u5} R M (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_4)) (AddCommGroup.toAddCommMonoid.{u5} M _inst_1)] [_inst_7 : Module.{u1, u4} S M₂ (DivisionSemiring.toSemiring.{u1} S (DivisionRing.toDivisionSemiring.{u1} S _inst_5)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_2)] (n : Nat) (x : M), Eq.{succ u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) (HSMul.hSMul.{u2, u5, u5} R M M (instHSMul.{u2, u5} R M (SMulZeroClass.toSMul.{u2, u5} R M (NegZeroClass.toZero.{u5} M (SubNegZeroMonoid.toNegZeroClass.{u5} M (SubtractionMonoid.toSubNegZeroMonoid.{u5} M (SubtractionCommMonoid.toSubtractionMonoid.{u5} M (AddCommGroup.toDivisionAddCommMonoid.{u5} M _inst_1))))) (SMulWithZero.toSMulZeroClass.{u2, u5} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_4)))) (NegZeroClass.toZero.{u5} M (SubNegZeroMonoid.toNegZeroClass.{u5} M (SubtractionMonoid.toSubNegZeroMonoid.{u5} M (SubtractionCommMonoid.toSubtractionMonoid.{u5} M (AddCommGroup.toDivisionAddCommMonoid.{u5} M _inst_1))))) (MulActionWithZero.toSMulWithZero.{u2, u5} R M (Semiring.toMonoidWithZero.{u2} R (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_4))) (NegZeroClass.toZero.{u5} M (SubNegZeroMonoid.toNegZeroClass.{u5} M (SubtractionMonoid.toSubNegZeroMonoid.{u5} M (SubtractionCommMonoid.toSubtractionMonoid.{u5} M (AddCommGroup.toDivisionAddCommMonoid.{u5} M _inst_1))))) (Module.toMulActionWithZero.{u2, u5} R M (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_4)) (AddCommGroup.toAddCommMonoid.{u5} M _inst_1) _inst_6))))) (Inv.inv.{u2} R (DivisionRing.toInv.{u2} R _inst_4) (Nat.cast.{u2} R (NonAssocRing.toNatCast.{u2} R (Ring.toNonAssocRing.{u2} R (DivisionRing.toRing.{u2} R _inst_4))) n)) x)) (FunLike.coe.{succ u3, succ u5, succ u4} F M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) _x) (AddHomClass.toFunLike.{u3, u5, u4} F M M₂ (AddZeroClass.toAdd.{u5} M (AddMonoid.toAddZeroClass.{u5} M (SubNegMonoid.toAddMonoid.{u5} M (AddGroup.toSubNegMonoid.{u5} M (AddCommGroup.toAddGroup.{u5} M _inst_1))))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (SubNegMonoid.toAddMonoid.{u4} M₂ (AddGroup.toSubNegMonoid.{u4} M₂ (AddCommGroup.toAddGroup.{u4} M₂ _inst_2))))) (AddMonoidHomClass.toAddHomClass.{u3, u5, u4} F M M₂ (AddMonoid.toAddZeroClass.{u5} M (SubNegMonoid.toAddMonoid.{u5} M (AddGroup.toSubNegMonoid.{u5} M (AddCommGroup.toAddGroup.{u5} M _inst_1)))) (AddMonoid.toAddZeroClass.{u4} M₂ (SubNegMonoid.toAddMonoid.{u4} M₂ (AddGroup.toSubNegMonoid.{u4} M₂ (AddCommGroup.toAddGroup.{u4} M₂ _inst_2)))) _inst_3)) f (HSMul.hSMul.{u2, u5, u5} R M M (instHSMul.{u2, u5} R M (SMulZeroClass.toSMul.{u2, u5} R M (NegZeroClass.toZero.{u5} M (SubNegZeroMonoid.toNegZeroClass.{u5} M (SubtractionMonoid.toSubNegZeroMonoid.{u5} M (SubtractionCommMonoid.toSubtractionMonoid.{u5} M (AddCommGroup.toDivisionAddCommMonoid.{u5} M _inst_1))))) (SMulWithZero.toSMulZeroClass.{u2, u5} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_4)))) (NegZeroClass.toZero.{u5} M (SubNegZeroMonoid.toNegZeroClass.{u5} M (SubtractionMonoid.toSubNegZeroMonoid.{u5} M (SubtractionCommMonoid.toSubtractionMonoid.{u5} M (AddCommGroup.toDivisionAddCommMonoid.{u5} M _inst_1))))) (MulActionWithZero.toSMulWithZero.{u2, u5} R M (Semiring.toMonoidWithZero.{u2} R (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_4))) (NegZeroClass.toZero.{u5} M (SubNegZeroMonoid.toNegZeroClass.{u5} M (SubtractionMonoid.toSubNegZeroMonoid.{u5} M (SubtractionCommMonoid.toSubtractionMonoid.{u5} M (AddCommGroup.toDivisionAddCommMonoid.{u5} M _inst_1))))) (Module.toMulActionWithZero.{u2, u5} R M (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_4)) (AddCommGroup.toAddCommMonoid.{u5} M _inst_1) _inst_6))))) (Inv.inv.{u2} R (DivisionRing.toInv.{u2} R _inst_4) (Nat.cast.{u2} R (NonAssocRing.toNatCast.{u2} R (Ring.toNonAssocRing.{u2} R (DivisionRing.toRing.{u2} R _inst_4))) n)) x)) (HSMul.hSMul.{u1, u4, u4} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (instHSMul.{u1, u4} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SMulZeroClass.toSMul.{u1, u4} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (NegZeroClass.toZero.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubNegZeroMonoid.toNegZeroClass.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubtractionMonoid.toSubNegZeroMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubtractionCommMonoid.toSubtractionMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (AddCommGroup.toDivisionAddCommMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u4} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (MonoidWithZero.toZero.{u1} S (Semiring.toMonoidWithZero.{u1} S (DivisionSemiring.toSemiring.{u1} S (DivisionRing.toDivisionSemiring.{u1} S _inst_5)))) (NegZeroClass.toZero.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubNegZeroMonoid.toNegZeroClass.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubtractionMonoid.toSubNegZeroMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubtractionCommMonoid.toSubtractionMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (AddCommGroup.toDivisionAddCommMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u4} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (Semiring.toMonoidWithZero.{u1} S (DivisionSemiring.toSemiring.{u1} S (DivisionRing.toDivisionSemiring.{u1} S _inst_5))) (NegZeroClass.toZero.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubNegZeroMonoid.toNegZeroClass.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubtractionMonoid.toSubNegZeroMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubtractionCommMonoid.toSubtractionMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (AddCommGroup.toDivisionAddCommMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) _inst_2))))) (Module.toMulActionWithZero.{u1, u4} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (DivisionSemiring.toSemiring.{u1} S (DivisionRing.toDivisionSemiring.{u1} S _inst_5)) (AddCommGroup.toAddCommMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) _inst_2) _inst_7))))) (Inv.inv.{u1} S (DivisionRing.toInv.{u1} S _inst_5) (Nat.cast.{u1} S (NonAssocRing.toNatCast.{u1} S (Ring.toNonAssocRing.{u1} S (DivisionRing.toRing.{u1} S _inst_5))) n)) (FunLike.coe.{succ u3, succ u5, succ u4} F M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) _x) (AddHomClass.toFunLike.{u3, u5, u4} F M M₂ (AddZeroClass.toAdd.{u5} M (AddMonoid.toAddZeroClass.{u5} M (SubNegMonoid.toAddMonoid.{u5} M (AddGroup.toSubNegMonoid.{u5} M (AddCommGroup.toAddGroup.{u5} M _inst_1))))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (SubNegMonoid.toAddMonoid.{u4} M₂ (AddGroup.toSubNegMonoid.{u4} M₂ (AddCommGroup.toAddGroup.{u4} M₂ _inst_2))))) (AddMonoidHomClass.toAddHomClass.{u3, u5, u4} F M M₂ (AddMonoid.toAddZeroClass.{u5} M (SubNegMonoid.toAddMonoid.{u5} M (AddGroup.toSubNegMonoid.{u5} M (AddCommGroup.toAddGroup.{u5} M _inst_1)))) (AddMonoid.toAddZeroClass.{u4} M₂ (SubNegMonoid.toAddMonoid.{u4} M₂ (AddGroup.toSubNegMonoid.{u4} M₂ (AddCommGroup.toAddGroup.{u4} M₂ _inst_2)))) _inst_3)) f x))
Case conversion may be inaccurate. Consider using '#align map_inv_nat_cast_smul map_inv_nat_cast_smulₓ'. -/
theorem map_inv_nat_cast_smul [AddCommGroup M] [AddCommGroup M₂] {F : Type _}
    [AddMonoidHomClass F M M₂] (f : F) (R S : Type _) [DivisionRing R] [DivisionRing S] [Module R M]
    [Module S M₂] (n : ℕ) (x : M) : f ((n⁻¹ : R) • x) = (n⁻¹ : S) • f x := by
  exact_mod_cast map_inv_int_cast_smul f R S n x
#align map_inv_nat_cast_smul map_inv_nat_cast_smul

/- warning: map_rat_cast_smul -> map_rat_cast_smul is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {M₂ : Type.{u2}} [_inst_1 : AddCommGroup.{u1} M] [_inst_2 : AddCommGroup.{u2} M₂] {F : Type.{u3}} [_inst_3 : AddMonoidHomClass.{u3, u1, u2} F M M₂ (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))) (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2))))] (f : F) (R : Type.{u4}) (S : Type.{u5}) [_inst_4 : DivisionRing.{u4} R] [_inst_5 : DivisionRing.{u5} S] [_inst_6 : Module.{u4, u1} R M (Ring.toSemiring.{u4} R (DivisionRing.toRing.{u4} R _inst_4)) (AddCommGroup.toAddCommMonoid.{u1} M _inst_1)] [_inst_7 : Module.{u5, u2} S M₂ (Ring.toSemiring.{u5} S (DivisionRing.toRing.{u5} S _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2)] (c : Rat) (x : M), Eq.{succ u2} M₂ (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => M -> M₂) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F M (fun (_x : M) => M₂) (AddHomClass.toFunLike.{u3, u1, u2} F M M₂ (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))))) (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2))))) (AddMonoidHomClass.toAddHomClass.{u3, u1, u2} F M M₂ (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))) (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2)))) _inst_3))) f (SMul.smul.{u4, u1} R M (SMulZeroClass.toHasSmul.{u4, u1} R M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (AddCommGroup.toAddCommMonoid.{u1} M _inst_1)))) (SMulWithZero.toSmulZeroClass.{u4, u1} R M (MulZeroClass.toHasZero.{u4} R (MulZeroOneClass.toMulZeroClass.{u4} R (MonoidWithZero.toMulZeroOneClass.{u4} R (Semiring.toMonoidWithZero.{u4} R (Ring.toSemiring.{u4} R (DivisionRing.toRing.{u4} R _inst_4)))))) (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (AddCommGroup.toAddCommMonoid.{u1} M _inst_1)))) (MulActionWithZero.toSMulWithZero.{u4, u1} R M (Semiring.toMonoidWithZero.{u4} R (Ring.toSemiring.{u4} R (DivisionRing.toRing.{u4} R _inst_4))) (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (AddCommGroup.toAddCommMonoid.{u1} M _inst_1)))) (Module.toMulActionWithZero.{u4, u1} R M (Ring.toSemiring.{u4} R (DivisionRing.toRing.{u4} R _inst_4)) (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) _inst_6)))) ((fun (a : Type) (b : Type.{u4}) [self : HasLiftT.{1, succ u4} a b] => self.0) Rat R (HasLiftT.mk.{1, succ u4} Rat R (CoeTCₓ.coe.{1, succ u4} Rat R (Rat.castCoe.{u4} R (DivisionRing.toHasRatCast.{u4} R _inst_4)))) c) x)) (SMul.smul.{u5, u2} S M₂ (SMulZeroClass.toHasSmul.{u5, u2} S M₂ (AddZeroClass.toHasZero.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2)))) (SMulWithZero.toSmulZeroClass.{u5, u2} S M₂ (MulZeroClass.toHasZero.{u5} S (MulZeroOneClass.toMulZeroClass.{u5} S (MonoidWithZero.toMulZeroOneClass.{u5} S (Semiring.toMonoidWithZero.{u5} S (Ring.toSemiring.{u5} S (DivisionRing.toRing.{u5} S _inst_5)))))) (AddZeroClass.toHasZero.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2)))) (MulActionWithZero.toSMulWithZero.{u5, u2} S M₂ (Semiring.toMonoidWithZero.{u5} S (Ring.toSemiring.{u5} S (DivisionRing.toRing.{u5} S _inst_5))) (AddZeroClass.toHasZero.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2)))) (Module.toMulActionWithZero.{u5, u2} S M₂ (Ring.toSemiring.{u5} S (DivisionRing.toRing.{u5} S _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2) _inst_7)))) ((fun (a : Type) (b : Type.{u5}) [self : HasLiftT.{1, succ u5} a b] => self.0) Rat S (HasLiftT.mk.{1, succ u5} Rat S (CoeTCₓ.coe.{1, succ u5} Rat S (Rat.castCoe.{u5} S (DivisionRing.toHasRatCast.{u5} S _inst_5)))) c) (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => M -> M₂) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F M (fun (_x : M) => M₂) (AddHomClass.toFunLike.{u3, u1, u2} F M M₂ (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))))) (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2))))) (AddMonoidHomClass.toAddHomClass.{u3, u1, u2} F M M₂ (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))) (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2)))) _inst_3))) f x))
but is expected to have type
  forall {M : Type.{u5}} {M₂ : Type.{u4}} [_inst_1 : AddCommGroup.{u5} M] [_inst_2 : AddCommGroup.{u4} M₂] {F : Type.{u3}} [_inst_3 : AddMonoidHomClass.{u3, u5, u4} F M M₂ (AddMonoid.toAddZeroClass.{u5} M (SubNegMonoid.toAddMonoid.{u5} M (AddGroup.toSubNegMonoid.{u5} M (AddCommGroup.toAddGroup.{u5} M _inst_1)))) (AddMonoid.toAddZeroClass.{u4} M₂ (SubNegMonoid.toAddMonoid.{u4} M₂ (AddGroup.toSubNegMonoid.{u4} M₂ (AddCommGroup.toAddGroup.{u4} M₂ _inst_2))))] (f : F) (R : Type.{u2}) (S : Type.{u1}) [_inst_4 : DivisionRing.{u2} R] [_inst_5 : DivisionRing.{u1} S] [_inst_6 : Module.{u2, u5} R M (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_4)) (AddCommGroup.toAddCommMonoid.{u5} M _inst_1)] [_inst_7 : Module.{u1, u4} S M₂ (DivisionSemiring.toSemiring.{u1} S (DivisionRing.toDivisionSemiring.{u1} S _inst_5)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_2)] (c : Rat) (x : M), Eq.{succ u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) (HSMul.hSMul.{u2, u5, u5} R M M (instHSMul.{u2, u5} R M (SMulZeroClass.toSMul.{u2, u5} R M (NegZeroClass.toZero.{u5} M (SubNegZeroMonoid.toNegZeroClass.{u5} M (SubtractionMonoid.toSubNegZeroMonoid.{u5} M (SubtractionCommMonoid.toSubtractionMonoid.{u5} M (AddCommGroup.toDivisionAddCommMonoid.{u5} M _inst_1))))) (SMulWithZero.toSMulZeroClass.{u2, u5} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_4)))) (NegZeroClass.toZero.{u5} M (SubNegZeroMonoid.toNegZeroClass.{u5} M (SubtractionMonoid.toSubNegZeroMonoid.{u5} M (SubtractionCommMonoid.toSubtractionMonoid.{u5} M (AddCommGroup.toDivisionAddCommMonoid.{u5} M _inst_1))))) (MulActionWithZero.toSMulWithZero.{u2, u5} R M (Semiring.toMonoidWithZero.{u2} R (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_4))) (NegZeroClass.toZero.{u5} M (SubNegZeroMonoid.toNegZeroClass.{u5} M (SubtractionMonoid.toSubNegZeroMonoid.{u5} M (SubtractionCommMonoid.toSubtractionMonoid.{u5} M (AddCommGroup.toDivisionAddCommMonoid.{u5} M _inst_1))))) (Module.toMulActionWithZero.{u2, u5} R M (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_4)) (AddCommGroup.toAddCommMonoid.{u5} M _inst_1) _inst_6))))) (RatCast.ratCast.{u2} R (DivisionRing.toRatCast.{u2} R _inst_4) c) x)) (FunLike.coe.{succ u3, succ u5, succ u4} F M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) _x) (AddHomClass.toFunLike.{u3, u5, u4} F M M₂ (AddZeroClass.toAdd.{u5} M (AddMonoid.toAddZeroClass.{u5} M (SubNegMonoid.toAddMonoid.{u5} M (AddGroup.toSubNegMonoid.{u5} M (AddCommGroup.toAddGroup.{u5} M _inst_1))))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (SubNegMonoid.toAddMonoid.{u4} M₂ (AddGroup.toSubNegMonoid.{u4} M₂ (AddCommGroup.toAddGroup.{u4} M₂ _inst_2))))) (AddMonoidHomClass.toAddHomClass.{u3, u5, u4} F M M₂ (AddMonoid.toAddZeroClass.{u5} M (SubNegMonoid.toAddMonoid.{u5} M (AddGroup.toSubNegMonoid.{u5} M (AddCommGroup.toAddGroup.{u5} M _inst_1)))) (AddMonoid.toAddZeroClass.{u4} M₂ (SubNegMonoid.toAddMonoid.{u4} M₂ (AddGroup.toSubNegMonoid.{u4} M₂ (AddCommGroup.toAddGroup.{u4} M₂ _inst_2)))) _inst_3)) f (HSMul.hSMul.{u2, u5, u5} R M M (instHSMul.{u2, u5} R M (SMulZeroClass.toSMul.{u2, u5} R M (NegZeroClass.toZero.{u5} M (SubNegZeroMonoid.toNegZeroClass.{u5} M (SubtractionMonoid.toSubNegZeroMonoid.{u5} M (SubtractionCommMonoid.toSubtractionMonoid.{u5} M (AddCommGroup.toDivisionAddCommMonoid.{u5} M _inst_1))))) (SMulWithZero.toSMulZeroClass.{u2, u5} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_4)))) (NegZeroClass.toZero.{u5} M (SubNegZeroMonoid.toNegZeroClass.{u5} M (SubtractionMonoid.toSubNegZeroMonoid.{u5} M (SubtractionCommMonoid.toSubtractionMonoid.{u5} M (AddCommGroup.toDivisionAddCommMonoid.{u5} M _inst_1))))) (MulActionWithZero.toSMulWithZero.{u2, u5} R M (Semiring.toMonoidWithZero.{u2} R (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_4))) (NegZeroClass.toZero.{u5} M (SubNegZeroMonoid.toNegZeroClass.{u5} M (SubtractionMonoid.toSubNegZeroMonoid.{u5} M (SubtractionCommMonoid.toSubtractionMonoid.{u5} M (AddCommGroup.toDivisionAddCommMonoid.{u5} M _inst_1))))) (Module.toMulActionWithZero.{u2, u5} R M (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_4)) (AddCommGroup.toAddCommMonoid.{u5} M _inst_1) _inst_6))))) (RatCast.ratCast.{u2} R (DivisionRing.toRatCast.{u2} R _inst_4) c) x)) (HSMul.hSMul.{u1, u4, u4} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (instHSMul.{u1, u4} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SMulZeroClass.toSMul.{u1, u4} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (NegZeroClass.toZero.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubNegZeroMonoid.toNegZeroClass.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubtractionMonoid.toSubNegZeroMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubtractionCommMonoid.toSubtractionMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (AddCommGroup.toDivisionAddCommMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u4} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (MonoidWithZero.toZero.{u1} S (Semiring.toMonoidWithZero.{u1} S (DivisionSemiring.toSemiring.{u1} S (DivisionRing.toDivisionSemiring.{u1} S _inst_5)))) (NegZeroClass.toZero.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubNegZeroMonoid.toNegZeroClass.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubtractionMonoid.toSubNegZeroMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubtractionCommMonoid.toSubtractionMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (AddCommGroup.toDivisionAddCommMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u4} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (Semiring.toMonoidWithZero.{u1} S (DivisionSemiring.toSemiring.{u1} S (DivisionRing.toDivisionSemiring.{u1} S _inst_5))) (NegZeroClass.toZero.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubNegZeroMonoid.toNegZeroClass.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubtractionMonoid.toSubNegZeroMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubtractionCommMonoid.toSubtractionMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (AddCommGroup.toDivisionAddCommMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) _inst_2))))) (Module.toMulActionWithZero.{u1, u4} S ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (DivisionSemiring.toSemiring.{u1} S (DivisionRing.toDivisionSemiring.{u1} S _inst_5)) (AddCommGroup.toAddCommMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) _inst_2) _inst_7))))) (RatCast.ratCast.{u1} S (DivisionRing.toRatCast.{u1} S _inst_5) c) (FunLike.coe.{succ u3, succ u5, succ u4} F M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) _x) (AddHomClass.toFunLike.{u3, u5, u4} F M M₂ (AddZeroClass.toAdd.{u5} M (AddMonoid.toAddZeroClass.{u5} M (SubNegMonoid.toAddMonoid.{u5} M (AddGroup.toSubNegMonoid.{u5} M (AddCommGroup.toAddGroup.{u5} M _inst_1))))) (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (SubNegMonoid.toAddMonoid.{u4} M₂ (AddGroup.toSubNegMonoid.{u4} M₂ (AddCommGroup.toAddGroup.{u4} M₂ _inst_2))))) (AddMonoidHomClass.toAddHomClass.{u3, u5, u4} F M M₂ (AddMonoid.toAddZeroClass.{u5} M (SubNegMonoid.toAddMonoid.{u5} M (AddGroup.toSubNegMonoid.{u5} M (AddCommGroup.toAddGroup.{u5} M _inst_1)))) (AddMonoid.toAddZeroClass.{u4} M₂ (SubNegMonoid.toAddMonoid.{u4} M₂ (AddGroup.toSubNegMonoid.{u4} M₂ (AddCommGroup.toAddGroup.{u4} M₂ _inst_2)))) _inst_3)) f x))
Case conversion may be inaccurate. Consider using '#align map_rat_cast_smul map_rat_cast_smulₓ'. -/
theorem map_rat_cast_smul [AddCommGroup M] [AddCommGroup M₂] {F : Type _} [AddMonoidHomClass F M M₂]
    (f : F) (R S : Type _) [DivisionRing R] [DivisionRing S] [Module R M] [Module S M₂] (c : ℚ)
    (x : M) : f ((c : R) • x) = (c : S) • f x := by
  rw [Rat.cast_def, Rat.cast_def, div_eq_mul_inv, div_eq_mul_inv, mul_smul, mul_smul,
    map_int_cast_smul f R S, map_inv_nat_cast_smul f R S]
#align map_rat_cast_smul map_rat_cast_smul

/- warning: map_rat_smul -> map_rat_smul is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {M₂ : Type.{u2}} [_inst_1 : AddCommGroup.{u1} M] [_inst_2 : AddCommGroup.{u2} M₂] [_inst_3 : Module.{0, u1} Rat M Rat.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1)] [_inst_4 : Module.{0, u2} Rat M₂ Rat.semiring (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2)] {F : Type.{u3}} [_inst_5 : AddMonoidHomClass.{u3, u1, u2} F M M₂ (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))) (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2))))] (f : F) (c : Rat) (x : M), Eq.{succ u2} M₂ (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => M -> M₂) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F M (fun (_x : M) => M₂) (AddHomClass.toFunLike.{u3, u1, u2} F M M₂ (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))))) (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2))))) (AddMonoidHomClass.toAddHomClass.{u3, u1, u2} F M M₂ (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))) (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2)))) _inst_5))) f (SMul.smul.{0, u1} Rat M (SMulZeroClass.toHasSmul.{0, u1} Rat M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (AddCommGroup.toAddCommMonoid.{u1} M _inst_1)))) (SMulWithZero.toSmulZeroClass.{0, u1} Rat M (MulZeroClass.toHasZero.{0} Rat (MulZeroOneClass.toMulZeroClass.{0} Rat (MonoidWithZero.toMulZeroOneClass.{0} Rat (Semiring.toMonoidWithZero.{0} Rat Rat.semiring)))) (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (AddCommGroup.toAddCommMonoid.{u1} M _inst_1)))) (MulActionWithZero.toSMulWithZero.{0, u1} Rat M (Semiring.toMonoidWithZero.{0} Rat Rat.semiring) (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (AddCommGroup.toAddCommMonoid.{u1} M _inst_1)))) (Module.toMulActionWithZero.{0, u1} Rat M Rat.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) _inst_3)))) c x)) (SMul.smul.{0, u2} Rat M₂ (SMulZeroClass.toHasSmul.{0, u2} Rat M₂ (AddZeroClass.toHasZero.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2)))) (SMulWithZero.toSmulZeroClass.{0, u2} Rat M₂ (MulZeroClass.toHasZero.{0} Rat (MulZeroOneClass.toMulZeroClass.{0} Rat (MonoidWithZero.toMulZeroOneClass.{0} Rat (Semiring.toMonoidWithZero.{0} Rat Rat.semiring)))) (AddZeroClass.toHasZero.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2)))) (MulActionWithZero.toSMulWithZero.{0, u2} Rat M₂ (Semiring.toMonoidWithZero.{0} Rat Rat.semiring) (AddZeroClass.toHasZero.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (AddCommMonoid.toAddMonoid.{u2} M₂ (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2)))) (Module.toMulActionWithZero.{0, u2} Rat M₂ Rat.semiring (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2) _inst_4)))) c (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => M -> M₂) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F M (fun (_x : M) => M₂) (AddHomClass.toFunLike.{u3, u1, u2} F M M₂ (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))))) (AddZeroClass.toHasAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2))))) (AddMonoidHomClass.toAddHomClass.{u3, u1, u2} F M M₂ (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))) (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2)))) _inst_5))) f x))
but is expected to have type
  forall {M : Type.{u3}} {M₂ : Type.{u2}} [_inst_1 : AddCommGroup.{u3} M] [_inst_2 : AddCommGroup.{u2} M₂] [_inst_3 : Module.{0, u3} Rat M Rat.semiring (AddCommGroup.toAddCommMonoid.{u3} M _inst_1)] [_inst_4 : Module.{0, u2} Rat M₂ Rat.semiring (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_2)] {F : Type.{u1}} [_inst_5 : AddMonoidHomClass.{u1, u3, u2} F M M₂ (AddMonoid.toAddZeroClass.{u3} M (SubNegMonoid.toAddMonoid.{u3} M (AddGroup.toSubNegMonoid.{u3} M (AddCommGroup.toAddGroup.{u3} M _inst_1)))) (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2))))] (f : F) (c : Rat) (x : M), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) (HSMul.hSMul.{0, u3, u3} Rat M M (instHSMul.{0, u3} Rat M (SMulZeroClass.toSMul.{0, u3} Rat M (NegZeroClass.toZero.{u3} M (SubNegZeroMonoid.toNegZeroClass.{u3} M (SubtractionMonoid.toSubNegZeroMonoid.{u3} M (SubtractionCommMonoid.toSubtractionMonoid.{u3} M (AddCommGroup.toDivisionAddCommMonoid.{u3} M _inst_1))))) (SMulWithZero.toSMulZeroClass.{0, u3} Rat M (CommMonoidWithZero.toZero.{0} Rat (CommGroupWithZero.toCommMonoidWithZero.{0} Rat Rat.commGroupWithZero)) (NegZeroClass.toZero.{u3} M (SubNegZeroMonoid.toNegZeroClass.{u3} M (SubtractionMonoid.toSubNegZeroMonoid.{u3} M (SubtractionCommMonoid.toSubtractionMonoid.{u3} M (AddCommGroup.toDivisionAddCommMonoid.{u3} M _inst_1))))) (MulActionWithZero.toSMulWithZero.{0, u3} Rat M (Semiring.toMonoidWithZero.{0} Rat Rat.semiring) (NegZeroClass.toZero.{u3} M (SubNegZeroMonoid.toNegZeroClass.{u3} M (SubtractionMonoid.toSubNegZeroMonoid.{u3} M (SubtractionCommMonoid.toSubtractionMonoid.{u3} M (AddCommGroup.toDivisionAddCommMonoid.{u3} M _inst_1))))) (Module.toMulActionWithZero.{0, u3} Rat M Rat.semiring (AddCommGroup.toAddCommMonoid.{u3} M _inst_1) _inst_3))))) c x)) (FunLike.coe.{succ u1, succ u3, succ u2} F M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) _x) (AddHomClass.toFunLike.{u1, u3, u2} F M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (SubNegMonoid.toAddMonoid.{u3} M (AddGroup.toSubNegMonoid.{u3} M (AddCommGroup.toAddGroup.{u3} M _inst_1))))) (AddZeroClass.toAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2))))) (AddMonoidHomClass.toAddHomClass.{u1, u3, u2} F M M₂ (AddMonoid.toAddZeroClass.{u3} M (SubNegMonoid.toAddMonoid.{u3} M (AddGroup.toSubNegMonoid.{u3} M (AddCommGroup.toAddGroup.{u3} M _inst_1)))) (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2)))) _inst_5)) f (HSMul.hSMul.{0, u3, u3} Rat M M (instHSMul.{0, u3} Rat M (SMulZeroClass.toSMul.{0, u3} Rat M (NegZeroClass.toZero.{u3} M (SubNegZeroMonoid.toNegZeroClass.{u3} M (SubtractionMonoid.toSubNegZeroMonoid.{u3} M (SubtractionCommMonoid.toSubtractionMonoid.{u3} M (AddCommGroup.toDivisionAddCommMonoid.{u3} M _inst_1))))) (SMulWithZero.toSMulZeroClass.{0, u3} Rat M (CommMonoidWithZero.toZero.{0} Rat (CommGroupWithZero.toCommMonoidWithZero.{0} Rat Rat.commGroupWithZero)) (NegZeroClass.toZero.{u3} M (SubNegZeroMonoid.toNegZeroClass.{u3} M (SubtractionMonoid.toSubNegZeroMonoid.{u3} M (SubtractionCommMonoid.toSubtractionMonoid.{u3} M (AddCommGroup.toDivisionAddCommMonoid.{u3} M _inst_1))))) (MulActionWithZero.toSMulWithZero.{0, u3} Rat M (Semiring.toMonoidWithZero.{0} Rat Rat.semiring) (NegZeroClass.toZero.{u3} M (SubNegZeroMonoid.toNegZeroClass.{u3} M (SubtractionMonoid.toSubNegZeroMonoid.{u3} M (SubtractionCommMonoid.toSubtractionMonoid.{u3} M (AddCommGroup.toDivisionAddCommMonoid.{u3} M _inst_1))))) (Module.toMulActionWithZero.{0, u3} Rat M Rat.semiring (AddCommGroup.toAddCommMonoid.{u3} M _inst_1) _inst_3))))) c x)) (HSMul.hSMul.{0, u2, u2} Rat ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (instHSMul.{0, u2} Rat ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SMulZeroClass.toSMul.{0, u2} Rat ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (NegZeroClass.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubtractionCommMonoid.toSubtractionMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (AddCommGroup.toDivisionAddCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) _inst_2))))) (SMulWithZero.toSMulZeroClass.{0, u2} Rat ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (CommMonoidWithZero.toZero.{0} Rat (CommGroupWithZero.toCommMonoidWithZero.{0} Rat Rat.commGroupWithZero)) (NegZeroClass.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubtractionCommMonoid.toSubtractionMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (AddCommGroup.toDivisionAddCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) _inst_2))))) (MulActionWithZero.toSMulWithZero.{0, u2} Rat ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (Semiring.toMonoidWithZero.{0} Rat Rat.semiring) (NegZeroClass.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (SubtractionCommMonoid.toSubtractionMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) (AddCommGroup.toDivisionAddCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) _inst_2))))) (Module.toMulActionWithZero.{0, u2} Rat ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) Rat.semiring (AddCommGroup.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) x) _inst_2) _inst_4))))) c (FunLike.coe.{succ u1, succ u3, succ u2} F M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => M₂) _x) (AddHomClass.toFunLike.{u1, u3, u2} F M M₂ (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (SubNegMonoid.toAddMonoid.{u3} M (AddGroup.toSubNegMonoid.{u3} M (AddCommGroup.toAddGroup.{u3} M _inst_1))))) (AddZeroClass.toAdd.{u2} M₂ (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2))))) (AddMonoidHomClass.toAddHomClass.{u1, u3, u2} F M M₂ (AddMonoid.toAddZeroClass.{u3} M (SubNegMonoid.toAddMonoid.{u3} M (AddGroup.toSubNegMonoid.{u3} M (AddCommGroup.toAddGroup.{u3} M _inst_1)))) (AddMonoid.toAddZeroClass.{u2} M₂ (SubNegMonoid.toAddMonoid.{u2} M₂ (AddGroup.toSubNegMonoid.{u2} M₂ (AddCommGroup.toAddGroup.{u2} M₂ _inst_2)))) _inst_5)) f x))
Case conversion may be inaccurate. Consider using '#align map_rat_smul map_rat_smulₓ'. -/
theorem map_rat_smul [AddCommGroup M] [AddCommGroup M₂] [Module ℚ M] [Module ℚ M₂] {F : Type _}
    [AddMonoidHomClass F M M₂] (f : F) (c : ℚ) (x : M) : f (c • x) = c • f x :=
  Rat.cast_id c ▸ map_rat_cast_smul f ℚ ℚ c x
#align map_rat_smul map_rat_smul

#print subsingleton_rat_module /-
/-- There can be at most one `module ℚ E` structure on an additive commutative group. -/
instance subsingleton_rat_module (E : Type _) [AddCommGroup E] : Subsingleton (Module ℚ E) :=
  ⟨fun P Q => Module.ext' P Q fun r x => @map_rat_smul _ _ _ _ P Q _ _ (AddMonoidHom.id E) r x⟩
#align subsingleton_rat_module subsingleton_rat_module
-/

/- warning: inv_int_cast_smul_eq -> inv_int_cast_smul_eq is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} (R : Type.{u2}) (S : Type.{u3}) [_inst_1 : AddCommGroup.{u1} E] [_inst_2 : DivisionRing.{u2} R] [_inst_3 : DivisionRing.{u3} S] [_inst_4 : Module.{u2, u1} R E (Ring.toSemiring.{u2} R (DivisionRing.toRing.{u2} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_1)] [_inst_5 : Module.{u3, u1} S E (Ring.toSemiring.{u3} S (DivisionRing.toRing.{u3} S _inst_3)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_1)] (n : Int) (x : E), Eq.{succ u1} E (SMul.smul.{u2, u1} R E (SMulZeroClass.toHasSmul.{u2, u1} R E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_1)))) (SMulWithZero.toSmulZeroClass.{u2, u1} R E (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R (DivisionRing.toRing.{u2} R _inst_2)))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_1)))) (MulActionWithZero.toSMulWithZero.{u2, u1} R E (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R (DivisionRing.toRing.{u2} R _inst_2))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_1)))) (Module.toMulActionWithZero.{u2, u1} R E (Ring.toSemiring.{u2} R (DivisionRing.toRing.{u2} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_1) _inst_4)))) (Inv.inv.{u2} R (DivInvMonoid.toHasInv.{u2} R (DivisionRing.toDivInvMonoid.{u2} R _inst_2)) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Int R (HasLiftT.mk.{1, succ u2} Int R (CoeTCₓ.coe.{1, succ u2} Int R (Int.castCoe.{u2} R (AddGroupWithOne.toHasIntCast.{u2} R (NonAssocRing.toAddGroupWithOne.{u2} R (Ring.toNonAssocRing.{u2} R (DivisionRing.toRing.{u2} R _inst_2))))))) n)) x) (SMul.smul.{u3, u1} S E (SMulZeroClass.toHasSmul.{u3, u1} S E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_1)))) (SMulWithZero.toSmulZeroClass.{u3, u1} S E (MulZeroClass.toHasZero.{u3} S (MulZeroOneClass.toMulZeroClass.{u3} S (MonoidWithZero.toMulZeroOneClass.{u3} S (Semiring.toMonoidWithZero.{u3} S (Ring.toSemiring.{u3} S (DivisionRing.toRing.{u3} S _inst_3)))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_1)))) (MulActionWithZero.toSMulWithZero.{u3, u1} S E (Semiring.toMonoidWithZero.{u3} S (Ring.toSemiring.{u3} S (DivisionRing.toRing.{u3} S _inst_3))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_1)))) (Module.toMulActionWithZero.{u3, u1} S E (Ring.toSemiring.{u3} S (DivisionRing.toRing.{u3} S _inst_3)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_1) _inst_5)))) (Inv.inv.{u3} S (DivInvMonoid.toHasInv.{u3} S (DivisionRing.toDivInvMonoid.{u3} S _inst_3)) ((fun (a : Type) (b : Type.{u3}) [self : HasLiftT.{1, succ u3} a b] => self.0) Int S (HasLiftT.mk.{1, succ u3} Int S (CoeTCₓ.coe.{1, succ u3} Int S (Int.castCoe.{u3} S (AddGroupWithOne.toHasIntCast.{u3} S (NonAssocRing.toAddGroupWithOne.{u3} S (Ring.toNonAssocRing.{u3} S (DivisionRing.toRing.{u3} S _inst_3))))))) n)) x)
but is expected to have type
  forall {E : Type.{u3}} (R : Type.{u2}) (S : Type.{u1}) [_inst_1 : AddCommGroup.{u3} E] [_inst_2 : DivisionRing.{u2} R] [_inst_3 : DivisionRing.{u1} S] [_inst_4 : Module.{u2, u3} R E (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u3} E _inst_1)] [_inst_5 : Module.{u1, u3} S E (DivisionSemiring.toSemiring.{u1} S (DivisionRing.toDivisionSemiring.{u1} S _inst_3)) (AddCommGroup.toAddCommMonoid.{u3} E _inst_1)] (n : Int) (x : E), Eq.{succ u3} E (HSMul.hSMul.{u2, u3, u3} R E E (instHSMul.{u2, u3} R E (SMulZeroClass.toSMul.{u2, u3} R E (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_1))))) (SMulWithZero.toSMulZeroClass.{u2, u3} R E (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_2)))) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_1))))) (MulActionWithZero.toSMulWithZero.{u2, u3} R E (Semiring.toMonoidWithZero.{u2} R (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_2))) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_1))))) (Module.toMulActionWithZero.{u2, u3} R E (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u3} E _inst_1) _inst_4))))) (Inv.inv.{u2} R (DivisionRing.toInv.{u2} R _inst_2) (Int.cast.{u2} R (Ring.toIntCast.{u2} R (DivisionRing.toRing.{u2} R _inst_2)) n)) x) (HSMul.hSMul.{u1, u3, u3} S E E (instHSMul.{u1, u3} S E (SMulZeroClass.toSMul.{u1, u3} S E (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_1))))) (SMulWithZero.toSMulZeroClass.{u1, u3} S E (MonoidWithZero.toZero.{u1} S (Semiring.toMonoidWithZero.{u1} S (DivisionSemiring.toSemiring.{u1} S (DivisionRing.toDivisionSemiring.{u1} S _inst_3)))) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_1))))) (MulActionWithZero.toSMulWithZero.{u1, u3} S E (Semiring.toMonoidWithZero.{u1} S (DivisionSemiring.toSemiring.{u1} S (DivisionRing.toDivisionSemiring.{u1} S _inst_3))) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_1))))) (Module.toMulActionWithZero.{u1, u3} S E (DivisionSemiring.toSemiring.{u1} S (DivisionRing.toDivisionSemiring.{u1} S _inst_3)) (AddCommGroup.toAddCommMonoid.{u3} E _inst_1) _inst_5))))) (Inv.inv.{u1} S (DivisionRing.toInv.{u1} S _inst_3) (Int.cast.{u1} S (Ring.toIntCast.{u1} S (DivisionRing.toRing.{u1} S _inst_3)) n)) x)
Case conversion may be inaccurate. Consider using '#align inv_int_cast_smul_eq inv_int_cast_smul_eqₓ'. -/
/-- If `E` is a vector space over two division rings `R` and `S`, then scalar multiplications
agree on inverses of integer numbers in `R` and `S`. -/
theorem inv_int_cast_smul_eq {E : Type _} (R S : Type _) [AddCommGroup E] [DivisionRing R]
    [DivisionRing S] [Module R E] [Module S E] (n : ℤ) (x : E) : (n⁻¹ : R) • x = (n⁻¹ : S) • x :=
  map_inv_int_cast_smul (AddMonoidHom.id E) R S n x
#align inv_int_cast_smul_eq inv_int_cast_smul_eq

/- warning: inv_nat_cast_smul_eq -> inv_nat_cast_smul_eq is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} (R : Type.{u2}) (S : Type.{u3}) [_inst_1 : AddCommGroup.{u1} E] [_inst_2 : DivisionRing.{u2} R] [_inst_3 : DivisionRing.{u3} S] [_inst_4 : Module.{u2, u1} R E (Ring.toSemiring.{u2} R (DivisionRing.toRing.{u2} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_1)] [_inst_5 : Module.{u3, u1} S E (Ring.toSemiring.{u3} S (DivisionRing.toRing.{u3} S _inst_3)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_1)] (n : Nat) (x : E), Eq.{succ u1} E (SMul.smul.{u2, u1} R E (SMulZeroClass.toHasSmul.{u2, u1} R E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_1)))) (SMulWithZero.toSmulZeroClass.{u2, u1} R E (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R (DivisionRing.toRing.{u2} R _inst_2)))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_1)))) (MulActionWithZero.toSMulWithZero.{u2, u1} R E (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R (DivisionRing.toRing.{u2} R _inst_2))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_1)))) (Module.toMulActionWithZero.{u2, u1} R E (Ring.toSemiring.{u2} R (DivisionRing.toRing.{u2} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_1) _inst_4)))) (Inv.inv.{u2} R (DivInvMonoid.toHasInv.{u2} R (DivisionRing.toDivInvMonoid.{u2} R _inst_2)) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u2} Nat R (CoeTCₓ.coe.{1, succ u2} Nat R (Nat.castCoe.{u2} R (AddMonoidWithOne.toNatCast.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (NonAssocRing.toAddGroupWithOne.{u2} R (Ring.toNonAssocRing.{u2} R (DivisionRing.toRing.{u2} R _inst_2)))))))) n)) x) (SMul.smul.{u3, u1} S E (SMulZeroClass.toHasSmul.{u3, u1} S E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_1)))) (SMulWithZero.toSmulZeroClass.{u3, u1} S E (MulZeroClass.toHasZero.{u3} S (MulZeroOneClass.toMulZeroClass.{u3} S (MonoidWithZero.toMulZeroOneClass.{u3} S (Semiring.toMonoidWithZero.{u3} S (Ring.toSemiring.{u3} S (DivisionRing.toRing.{u3} S _inst_3)))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_1)))) (MulActionWithZero.toSMulWithZero.{u3, u1} S E (Semiring.toMonoidWithZero.{u3} S (Ring.toSemiring.{u3} S (DivisionRing.toRing.{u3} S _inst_3))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_1)))) (Module.toMulActionWithZero.{u3, u1} S E (Ring.toSemiring.{u3} S (DivisionRing.toRing.{u3} S _inst_3)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_1) _inst_5)))) (Inv.inv.{u3} S (DivInvMonoid.toHasInv.{u3} S (DivisionRing.toDivInvMonoid.{u3} S _inst_3)) ((fun (a : Type) (b : Type.{u3}) [self : HasLiftT.{1, succ u3} a b] => self.0) Nat S (HasLiftT.mk.{1, succ u3} Nat S (CoeTCₓ.coe.{1, succ u3} Nat S (Nat.castCoe.{u3} S (AddMonoidWithOne.toNatCast.{u3} S (AddGroupWithOne.toAddMonoidWithOne.{u3} S (NonAssocRing.toAddGroupWithOne.{u3} S (Ring.toNonAssocRing.{u3} S (DivisionRing.toRing.{u3} S _inst_3)))))))) n)) x)
but is expected to have type
  forall {E : Type.{u3}} (R : Type.{u2}) (S : Type.{u1}) [_inst_1 : AddCommGroup.{u3} E] [_inst_2 : DivisionRing.{u2} R] [_inst_3 : DivisionRing.{u1} S] [_inst_4 : Module.{u2, u3} R E (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u3} E _inst_1)] [_inst_5 : Module.{u1, u3} S E (DivisionSemiring.toSemiring.{u1} S (DivisionRing.toDivisionSemiring.{u1} S _inst_3)) (AddCommGroup.toAddCommMonoid.{u3} E _inst_1)] (n : Nat) (x : E), Eq.{succ u3} E (HSMul.hSMul.{u2, u3, u3} R E E (instHSMul.{u2, u3} R E (SMulZeroClass.toSMul.{u2, u3} R E (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_1))))) (SMulWithZero.toSMulZeroClass.{u2, u3} R E (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_2)))) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_1))))) (MulActionWithZero.toSMulWithZero.{u2, u3} R E (Semiring.toMonoidWithZero.{u2} R (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_2))) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_1))))) (Module.toMulActionWithZero.{u2, u3} R E (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u3} E _inst_1) _inst_4))))) (Inv.inv.{u2} R (DivisionRing.toInv.{u2} R _inst_2) (Nat.cast.{u2} R (NonAssocRing.toNatCast.{u2} R (Ring.toNonAssocRing.{u2} R (DivisionRing.toRing.{u2} R _inst_2))) n)) x) (HSMul.hSMul.{u1, u3, u3} S E E (instHSMul.{u1, u3} S E (SMulZeroClass.toSMul.{u1, u3} S E (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_1))))) (SMulWithZero.toSMulZeroClass.{u1, u3} S E (MonoidWithZero.toZero.{u1} S (Semiring.toMonoidWithZero.{u1} S (DivisionSemiring.toSemiring.{u1} S (DivisionRing.toDivisionSemiring.{u1} S _inst_3)))) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_1))))) (MulActionWithZero.toSMulWithZero.{u1, u3} S E (Semiring.toMonoidWithZero.{u1} S (DivisionSemiring.toSemiring.{u1} S (DivisionRing.toDivisionSemiring.{u1} S _inst_3))) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_1))))) (Module.toMulActionWithZero.{u1, u3} S E (DivisionSemiring.toSemiring.{u1} S (DivisionRing.toDivisionSemiring.{u1} S _inst_3)) (AddCommGroup.toAddCommMonoid.{u3} E _inst_1) _inst_5))))) (Inv.inv.{u1} S (DivisionRing.toInv.{u1} S _inst_3) (Nat.cast.{u1} S (NonAssocRing.toNatCast.{u1} S (Ring.toNonAssocRing.{u1} S (DivisionRing.toRing.{u1} S _inst_3))) n)) x)
Case conversion may be inaccurate. Consider using '#align inv_nat_cast_smul_eq inv_nat_cast_smul_eqₓ'. -/
/-- If `E` is a vector space over two division rings `R` and `S`, then scalar multiplications
agree on inverses of natural numbers in `R` and `S`. -/
theorem inv_nat_cast_smul_eq {E : Type _} (R S : Type _) [AddCommGroup E] [DivisionRing R]
    [DivisionRing S] [Module R E] [Module S E] (n : ℕ) (x : E) : (n⁻¹ : R) • x = (n⁻¹ : S) • x :=
  map_inv_nat_cast_smul (AddMonoidHom.id E) R S n x
#align inv_nat_cast_smul_eq inv_nat_cast_smul_eq

/- warning: inv_int_cast_smul_comm -> inv_int_cast_smul_comm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {E : Type.{u2}} (R : Type.{u3}) [_inst_1 : AddCommGroup.{u2} E] [_inst_2 : DivisionRing.{u3} R] [_inst_3 : Monoid.{u1} α] [_inst_4 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R (DivisionRing.toRing.{u3} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_1)] [_inst_5 : DistribMulAction.{u1, u2} α E _inst_3 (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_1)))] (n : Int) (s : α) (x : E), Eq.{succ u2} E (SMul.smul.{u3, u2} R E (SMulZeroClass.toHasSmul.{u3, u2} R E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_1)))) (SMulWithZero.toSmulZeroClass.{u3, u2} R E (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (DivisionRing.toRing.{u3} R _inst_2)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_1)))) (MulActionWithZero.toSMulWithZero.{u3, u2} R E (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (DivisionRing.toRing.{u3} R _inst_2))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_1)))) (Module.toMulActionWithZero.{u3, u2} R E (Ring.toSemiring.{u3} R (DivisionRing.toRing.{u3} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_1) _inst_4)))) (Inv.inv.{u3} R (DivInvMonoid.toHasInv.{u3} R (DivisionRing.toDivInvMonoid.{u3} R _inst_2)) ((fun (a : Type) (b : Type.{u3}) [self : HasLiftT.{1, succ u3} a b] => self.0) Int R (HasLiftT.mk.{1, succ u3} Int R (CoeTCₓ.coe.{1, succ u3} Int R (Int.castCoe.{u3} R (AddGroupWithOne.toHasIntCast.{u3} R (NonAssocRing.toAddGroupWithOne.{u3} R (Ring.toNonAssocRing.{u3} R (DivisionRing.toRing.{u3} R _inst_2))))))) n)) (SMul.smul.{u1, u2} α E (SMulZeroClass.toHasSmul.{u1, u2} α E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_1))))) (DistribSMul.toSmulZeroClass.{u1, u2} α E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_1)))) (DistribMulAction.toDistribSMul.{u1, u2} α E _inst_3 (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_1))) _inst_5))) s x)) (SMul.smul.{u1, u2} α E (SMulZeroClass.toHasSmul.{u1, u2} α E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_1))))) (DistribSMul.toSmulZeroClass.{u1, u2} α E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_1)))) (DistribMulAction.toDistribSMul.{u1, u2} α E _inst_3 (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_1))) _inst_5))) s (SMul.smul.{u3, u2} R E (SMulZeroClass.toHasSmul.{u3, u2} R E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_1)))) (SMulWithZero.toSmulZeroClass.{u3, u2} R E (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (DivisionRing.toRing.{u3} R _inst_2)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_1)))) (MulActionWithZero.toSMulWithZero.{u3, u2} R E (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (DivisionRing.toRing.{u3} R _inst_2))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_1)))) (Module.toMulActionWithZero.{u3, u2} R E (Ring.toSemiring.{u3} R (DivisionRing.toRing.{u3} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_1) _inst_4)))) (Inv.inv.{u3} R (DivInvMonoid.toHasInv.{u3} R (DivisionRing.toDivInvMonoid.{u3} R _inst_2)) ((fun (a : Type) (b : Type.{u3}) [self : HasLiftT.{1, succ u3} a b] => self.0) Int R (HasLiftT.mk.{1, succ u3} Int R (CoeTCₓ.coe.{1, succ u3} Int R (Int.castCoe.{u3} R (AddGroupWithOne.toHasIntCast.{u3} R (NonAssocRing.toAddGroupWithOne.{u3} R (Ring.toNonAssocRing.{u3} R (DivisionRing.toRing.{u3} R _inst_2))))))) n)) x))
but is expected to have type
  forall {α : Type.{u3}} {E : Type.{u2}} (R : Type.{u1}) [_inst_1 : AddCommGroup.{u2} E] [_inst_2 : DivisionRing.{u1} R] [_inst_3 : Monoid.{u3} α] [_inst_4 : Module.{u1, u2} R E (DivisionSemiring.toSemiring.{u1} R (DivisionRing.toDivisionSemiring.{u1} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_1)] [_inst_5 : DistribMulAction.{u3, u2} α E _inst_3 (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_1)))] (n : Int) (s : α) (x : E), Eq.{succ u2} E (HSMul.hSMul.{u1, u2, u2} R E E (instHSMul.{u1, u2} R E (SMulZeroClass.toSMul.{u1, u2} R E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_1))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R E (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (DivisionSemiring.toSemiring.{u1} R (DivisionRing.toDivisionSemiring.{u1} R _inst_2)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_1))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R E (Semiring.toMonoidWithZero.{u1} R (DivisionSemiring.toSemiring.{u1} R (DivisionRing.toDivisionSemiring.{u1} R _inst_2))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_1))))) (Module.toMulActionWithZero.{u1, u2} R E (DivisionSemiring.toSemiring.{u1} R (DivisionRing.toDivisionSemiring.{u1} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_1) _inst_4))))) (Inv.inv.{u1} R (DivisionRing.toInv.{u1} R _inst_2) (Int.cast.{u1} R (Ring.toIntCast.{u1} R (DivisionRing.toRing.{u1} R _inst_2)) n)) (HSMul.hSMul.{u3, u2, u2} α E E (instHSMul.{u3, u2} α E (SMulZeroClass.toSMul.{u3, u2} α E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_1))))) (DistribSMul.toSMulZeroClass.{u3, u2} α E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_1)))) (DistribMulAction.toDistribSMul.{u3, u2} α E _inst_3 (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_1))) _inst_5)))) s x)) (HSMul.hSMul.{u3, u2, u2} α E E (instHSMul.{u3, u2} α E (SMulZeroClass.toSMul.{u3, u2} α E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_1))))) (DistribSMul.toSMulZeroClass.{u3, u2} α E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_1)))) (DistribMulAction.toDistribSMul.{u3, u2} α E _inst_3 (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_1))) _inst_5)))) s (HSMul.hSMul.{u1, u2, u2} R E E (instHSMul.{u1, u2} R E (SMulZeroClass.toSMul.{u1, u2} R E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_1))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R E (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (DivisionSemiring.toSemiring.{u1} R (DivisionRing.toDivisionSemiring.{u1} R _inst_2)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_1))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R E (Semiring.toMonoidWithZero.{u1} R (DivisionSemiring.toSemiring.{u1} R (DivisionRing.toDivisionSemiring.{u1} R _inst_2))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_1))))) (Module.toMulActionWithZero.{u1, u2} R E (DivisionSemiring.toSemiring.{u1} R (DivisionRing.toDivisionSemiring.{u1} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_1) _inst_4))))) (Inv.inv.{u1} R (DivisionRing.toInv.{u1} R _inst_2) (Int.cast.{u1} R (Ring.toIntCast.{u1} R (DivisionRing.toRing.{u1} R _inst_2)) n)) x))
Case conversion may be inaccurate. Consider using '#align inv_int_cast_smul_comm inv_int_cast_smul_commₓ'. -/
/-- If `E` is a vector space over a division rings `R` and has a monoid action by `α`, then that
action commutes by scalar multiplication of inverses of integers in `R` -/
theorem inv_int_cast_smul_comm {α E : Type _} (R : Type _) [AddCommGroup E] [DivisionRing R]
    [Monoid α] [Module R E] [DistribMulAction α E] (n : ℤ) (s : α) (x : E) :
    (n⁻¹ : R) • s • x = s • (n⁻¹ : R) • x :=
  (map_inv_int_cast_smul (DistribMulAction.toAddMonoidHom E s) R R n x).symm
#align inv_int_cast_smul_comm inv_int_cast_smul_comm

/- warning: inv_nat_cast_smul_comm -> inv_nat_cast_smul_comm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {E : Type.{u2}} (R : Type.{u3}) [_inst_1 : AddCommGroup.{u2} E] [_inst_2 : DivisionRing.{u3} R] [_inst_3 : Monoid.{u1} α] [_inst_4 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R (DivisionRing.toRing.{u3} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_1)] [_inst_5 : DistribMulAction.{u1, u2} α E _inst_3 (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_1)))] (n : Nat) (s : α) (x : E), Eq.{succ u2} E (SMul.smul.{u3, u2} R E (SMulZeroClass.toHasSmul.{u3, u2} R E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_1)))) (SMulWithZero.toSmulZeroClass.{u3, u2} R E (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (DivisionRing.toRing.{u3} R _inst_2)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_1)))) (MulActionWithZero.toSMulWithZero.{u3, u2} R E (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (DivisionRing.toRing.{u3} R _inst_2))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_1)))) (Module.toMulActionWithZero.{u3, u2} R E (Ring.toSemiring.{u3} R (DivisionRing.toRing.{u3} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_1) _inst_4)))) (Inv.inv.{u3} R (DivInvMonoid.toHasInv.{u3} R (DivisionRing.toDivInvMonoid.{u3} R _inst_2)) ((fun (a : Type) (b : Type.{u3}) [self : HasLiftT.{1, succ u3} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u3} Nat R (CoeTCₓ.coe.{1, succ u3} Nat R (Nat.castCoe.{u3} R (AddMonoidWithOne.toNatCast.{u3} R (AddGroupWithOne.toAddMonoidWithOne.{u3} R (NonAssocRing.toAddGroupWithOne.{u3} R (Ring.toNonAssocRing.{u3} R (DivisionRing.toRing.{u3} R _inst_2)))))))) n)) (SMul.smul.{u1, u2} α E (SMulZeroClass.toHasSmul.{u1, u2} α E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_1))))) (DistribSMul.toSmulZeroClass.{u1, u2} α E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_1)))) (DistribMulAction.toDistribSMul.{u1, u2} α E _inst_3 (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_1))) _inst_5))) s x)) (SMul.smul.{u1, u2} α E (SMulZeroClass.toHasSmul.{u1, u2} α E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_1))))) (DistribSMul.toSmulZeroClass.{u1, u2} α E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_1)))) (DistribMulAction.toDistribSMul.{u1, u2} α E _inst_3 (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_1))) _inst_5))) s (SMul.smul.{u3, u2} R E (SMulZeroClass.toHasSmul.{u3, u2} R E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_1)))) (SMulWithZero.toSmulZeroClass.{u3, u2} R E (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (DivisionRing.toRing.{u3} R _inst_2)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_1)))) (MulActionWithZero.toSMulWithZero.{u3, u2} R E (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (DivisionRing.toRing.{u3} R _inst_2))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_1)))) (Module.toMulActionWithZero.{u3, u2} R E (Ring.toSemiring.{u3} R (DivisionRing.toRing.{u3} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_1) _inst_4)))) (Inv.inv.{u3} R (DivInvMonoid.toHasInv.{u3} R (DivisionRing.toDivInvMonoid.{u3} R _inst_2)) ((fun (a : Type) (b : Type.{u3}) [self : HasLiftT.{1, succ u3} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u3} Nat R (CoeTCₓ.coe.{1, succ u3} Nat R (Nat.castCoe.{u3} R (AddMonoidWithOne.toNatCast.{u3} R (AddGroupWithOne.toAddMonoidWithOne.{u3} R (NonAssocRing.toAddGroupWithOne.{u3} R (Ring.toNonAssocRing.{u3} R (DivisionRing.toRing.{u3} R _inst_2)))))))) n)) x))
but is expected to have type
  forall {α : Type.{u3}} {E : Type.{u2}} (R : Type.{u1}) [_inst_1 : AddCommGroup.{u2} E] [_inst_2 : DivisionRing.{u1} R] [_inst_3 : Monoid.{u3} α] [_inst_4 : Module.{u1, u2} R E (DivisionSemiring.toSemiring.{u1} R (DivisionRing.toDivisionSemiring.{u1} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_1)] [_inst_5 : DistribMulAction.{u3, u2} α E _inst_3 (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_1)))] (n : Nat) (s : α) (x : E), Eq.{succ u2} E (HSMul.hSMul.{u1, u2, u2} R E E (instHSMul.{u1, u2} R E (SMulZeroClass.toSMul.{u1, u2} R E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_1))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R E (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (DivisionSemiring.toSemiring.{u1} R (DivisionRing.toDivisionSemiring.{u1} R _inst_2)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_1))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R E (Semiring.toMonoidWithZero.{u1} R (DivisionSemiring.toSemiring.{u1} R (DivisionRing.toDivisionSemiring.{u1} R _inst_2))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_1))))) (Module.toMulActionWithZero.{u1, u2} R E (DivisionSemiring.toSemiring.{u1} R (DivisionRing.toDivisionSemiring.{u1} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_1) _inst_4))))) (Inv.inv.{u1} R (DivisionRing.toInv.{u1} R _inst_2) (Nat.cast.{u1} R (NonAssocRing.toNatCast.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R _inst_2))) n)) (HSMul.hSMul.{u3, u2, u2} α E E (instHSMul.{u3, u2} α E (SMulZeroClass.toSMul.{u3, u2} α E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_1))))) (DistribSMul.toSMulZeroClass.{u3, u2} α E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_1)))) (DistribMulAction.toDistribSMul.{u3, u2} α E _inst_3 (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_1))) _inst_5)))) s x)) (HSMul.hSMul.{u3, u2, u2} α E E (instHSMul.{u3, u2} α E (SMulZeroClass.toSMul.{u3, u2} α E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_1))))) (DistribSMul.toSMulZeroClass.{u3, u2} α E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_1)))) (DistribMulAction.toDistribSMul.{u3, u2} α E _inst_3 (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_1))) _inst_5)))) s (HSMul.hSMul.{u1, u2, u2} R E E (instHSMul.{u1, u2} R E (SMulZeroClass.toSMul.{u1, u2} R E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_1))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R E (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (DivisionSemiring.toSemiring.{u1} R (DivisionRing.toDivisionSemiring.{u1} R _inst_2)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_1))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R E (Semiring.toMonoidWithZero.{u1} R (DivisionSemiring.toSemiring.{u1} R (DivisionRing.toDivisionSemiring.{u1} R _inst_2))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_1))))) (Module.toMulActionWithZero.{u1, u2} R E (DivisionSemiring.toSemiring.{u1} R (DivisionRing.toDivisionSemiring.{u1} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_1) _inst_4))))) (Inv.inv.{u1} R (DivisionRing.toInv.{u1} R _inst_2) (Nat.cast.{u1} R (NonAssocRing.toNatCast.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R _inst_2))) n)) x))
Case conversion may be inaccurate. Consider using '#align inv_nat_cast_smul_comm inv_nat_cast_smul_commₓ'. -/
/-- If `E` is a vector space over a division rings `R` and has a monoid action by `α`, then that
action commutes by scalar multiplication of inverses of natural numbers in `R`. -/
theorem inv_nat_cast_smul_comm {α E : Type _} (R : Type _) [AddCommGroup E] [DivisionRing R]
    [Monoid α] [Module R E] [DistribMulAction α E] (n : ℕ) (s : α) (x : E) :
    (n⁻¹ : R) • s • x = s • (n⁻¹ : R) • x :=
  (map_inv_nat_cast_smul (DistribMulAction.toAddMonoidHom E s) R R n x).symm
#align inv_nat_cast_smul_comm inv_nat_cast_smul_comm

/- warning: rat_cast_smul_eq -> rat_cast_smul_eq is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} (R : Type.{u2}) (S : Type.{u3}) [_inst_1 : AddCommGroup.{u1} E] [_inst_2 : DivisionRing.{u2} R] [_inst_3 : DivisionRing.{u3} S] [_inst_4 : Module.{u2, u1} R E (Ring.toSemiring.{u2} R (DivisionRing.toRing.{u2} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_1)] [_inst_5 : Module.{u3, u1} S E (Ring.toSemiring.{u3} S (DivisionRing.toRing.{u3} S _inst_3)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_1)] (r : Rat) (x : E), Eq.{succ u1} E (SMul.smul.{u2, u1} R E (SMulZeroClass.toHasSmul.{u2, u1} R E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_1)))) (SMulWithZero.toSmulZeroClass.{u2, u1} R E (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R (DivisionRing.toRing.{u2} R _inst_2)))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_1)))) (MulActionWithZero.toSMulWithZero.{u2, u1} R E (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R (DivisionRing.toRing.{u2} R _inst_2))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_1)))) (Module.toMulActionWithZero.{u2, u1} R E (Ring.toSemiring.{u2} R (DivisionRing.toRing.{u2} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_1) _inst_4)))) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Rat R (HasLiftT.mk.{1, succ u2} Rat R (CoeTCₓ.coe.{1, succ u2} Rat R (Rat.castCoe.{u2} R (DivisionRing.toHasRatCast.{u2} R _inst_2)))) r) x) (SMul.smul.{u3, u1} S E (SMulZeroClass.toHasSmul.{u3, u1} S E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_1)))) (SMulWithZero.toSmulZeroClass.{u3, u1} S E (MulZeroClass.toHasZero.{u3} S (MulZeroOneClass.toMulZeroClass.{u3} S (MonoidWithZero.toMulZeroOneClass.{u3} S (Semiring.toMonoidWithZero.{u3} S (Ring.toSemiring.{u3} S (DivisionRing.toRing.{u3} S _inst_3)))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_1)))) (MulActionWithZero.toSMulWithZero.{u3, u1} S E (Semiring.toMonoidWithZero.{u3} S (Ring.toSemiring.{u3} S (DivisionRing.toRing.{u3} S _inst_3))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_1)))) (Module.toMulActionWithZero.{u3, u1} S E (Ring.toSemiring.{u3} S (DivisionRing.toRing.{u3} S _inst_3)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_1) _inst_5)))) ((fun (a : Type) (b : Type.{u3}) [self : HasLiftT.{1, succ u3} a b] => self.0) Rat S (HasLiftT.mk.{1, succ u3} Rat S (CoeTCₓ.coe.{1, succ u3} Rat S (Rat.castCoe.{u3} S (DivisionRing.toHasRatCast.{u3} S _inst_3)))) r) x)
but is expected to have type
  forall {E : Type.{u3}} (R : Type.{u2}) (S : Type.{u1}) [_inst_1 : AddCommGroup.{u3} E] [_inst_2 : DivisionRing.{u2} R] [_inst_3 : DivisionRing.{u1} S] [_inst_4 : Module.{u2, u3} R E (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u3} E _inst_1)] [_inst_5 : Module.{u1, u3} S E (DivisionSemiring.toSemiring.{u1} S (DivisionRing.toDivisionSemiring.{u1} S _inst_3)) (AddCommGroup.toAddCommMonoid.{u3} E _inst_1)] (r : Rat) (x : E), Eq.{succ u3} E (HSMul.hSMul.{u2, u3, u3} R E E (instHSMul.{u2, u3} R E (SMulZeroClass.toSMul.{u2, u3} R E (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_1))))) (SMulWithZero.toSMulZeroClass.{u2, u3} R E (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_2)))) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_1))))) (MulActionWithZero.toSMulWithZero.{u2, u3} R E (Semiring.toMonoidWithZero.{u2} R (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_2))) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_1))))) (Module.toMulActionWithZero.{u2, u3} R E (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u3} E _inst_1) _inst_4))))) (RatCast.ratCast.{u2} R (DivisionRing.toRatCast.{u2} R _inst_2) r) x) (HSMul.hSMul.{u1, u3, u3} S E E (instHSMul.{u1, u3} S E (SMulZeroClass.toSMul.{u1, u3} S E (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_1))))) (SMulWithZero.toSMulZeroClass.{u1, u3} S E (MonoidWithZero.toZero.{u1} S (Semiring.toMonoidWithZero.{u1} S (DivisionSemiring.toSemiring.{u1} S (DivisionRing.toDivisionSemiring.{u1} S _inst_3)))) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_1))))) (MulActionWithZero.toSMulWithZero.{u1, u3} S E (Semiring.toMonoidWithZero.{u1} S (DivisionSemiring.toSemiring.{u1} S (DivisionRing.toDivisionSemiring.{u1} S _inst_3))) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_1))))) (Module.toMulActionWithZero.{u1, u3} S E (DivisionSemiring.toSemiring.{u1} S (DivisionRing.toDivisionSemiring.{u1} S _inst_3)) (AddCommGroup.toAddCommMonoid.{u3} E _inst_1) _inst_5))))) (RatCast.ratCast.{u1} S (DivisionRing.toRatCast.{u1} S _inst_3) r) x)
Case conversion may be inaccurate. Consider using '#align rat_cast_smul_eq rat_cast_smul_eqₓ'. -/
/-- If `E` is a vector space over two division rings `R` and `S`, then scalar multiplications
agree on rational numbers in `R` and `S`. -/
theorem rat_cast_smul_eq {E : Type _} (R S : Type _) [AddCommGroup E] [DivisionRing R]
    [DivisionRing S] [Module R E] [Module S E] (r : ℚ) (x : E) : (r : R) • x = (r : S) • x :=
  map_rat_cast_smul (AddMonoidHom.id E) R S r x
#align rat_cast_smul_eq rat_cast_smul_eq

#print AddCommGroup.intIsScalarTower /-
instance AddCommGroup.intIsScalarTower {R : Type u} {M : Type v} [Ring R] [AddCommGroup M]
    [Module R M] : IsScalarTower ℤ R M
    where smul_assoc n x y := ((smulAddHom R M).flip y).map_zsmul x n
#align add_comm_group.int_is_scalar_tower AddCommGroup.intIsScalarTower
-/

#print IsScalarTower.rat /-
instance IsScalarTower.rat {R : Type u} {M : Type v} [Ring R] [AddCommGroup M] [Module R M]
    [Module ℚ R] [Module ℚ M] : IsScalarTower ℚ R M
    where smul_assoc r x y := map_rat_smul ((smulAddHom R M).flip y) r x
#align is_scalar_tower.rat IsScalarTower.rat
-/

#print SMulCommClass.rat /-
instance SMulCommClass.rat {R : Type u} {M : Type v} [Semiring R] [AddCommGroup M] [Module R M]
    [Module ℚ M] : SMulCommClass ℚ R M
    where smul_comm r x y := (map_rat_smul (smulAddHom R M x) r y).symm
#align smul_comm_class.rat SMulCommClass.rat
-/

#print SMulCommClass.rat' /-
instance SMulCommClass.rat' {R : Type u} {M : Type v} [Semiring R] [AddCommGroup M] [Module R M]
    [Module ℚ M] : SMulCommClass R ℚ M :=
  SMulCommClass.symm _ _ _
#align smul_comm_class.rat' SMulCommClass.rat'
-/

section NoZeroSMulDivisors

/-! ### `no_zero_smul_divisors`

This section defines the `no_zero_smul_divisors` class, and includes some tests
for the vanishing of elements (especially in modules over division rings).
-/


#print NoZeroSMulDivisors /-
/-- `no_zero_smul_divisors R M` states that a scalar multiple is `0` only if either argument is `0`.
This a version of saying that `M` is torsion free, without assuming `R` is zero-divisor free.

The main application of `no_zero_smul_divisors R M`, when `M` is a module,
is the result `smul_eq_zero`: a scalar multiple is `0` iff either argument is `0`.

It is a generalization of the `no_zero_divisors` class to heterogeneous multiplication.
-/
class NoZeroSMulDivisors (R M : Type _) [Zero R] [Zero M] [SMul R M] : Prop where
  eq_zero_or_eq_zero_of_smul_eq_zero : ∀ {c : R} {x : M}, c • x = 0 → c = 0 ∨ x = 0
#align no_zero_smul_divisors NoZeroSMulDivisors
-/

export NoZeroSMulDivisors (eq_zero_or_eq_zero_of_smul_eq_zero)

/- warning: function.injective.no_zero_smul_divisors -> Function.Injective.noZeroSMulDivisors is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_1 : Zero.{u1} R] [_inst_2 : Zero.{u2} M] [_inst_3 : Zero.{u3} N] [_inst_4 : SMul.{u1, u2} R M] [_inst_5 : SMul.{u1, u3} R N] [_inst_6 : NoZeroSMulDivisors.{u1, u3} R N _inst_1 _inst_3 _inst_5] (f : M -> N), (Function.Injective.{succ u2, succ u3} M N f) -> (Eq.{succ u3} N (f (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_2)))) (OfNat.ofNat.{u3} N 0 (OfNat.mk.{u3} N 0 (Zero.zero.{u3} N _inst_3)))) -> (forall (c : R) (x : M), Eq.{succ u3} N (f (SMul.smul.{u1, u2} R M _inst_4 c x)) (SMul.smul.{u1, u3} R N _inst_5 c (f x))) -> (NoZeroSMulDivisors.{u1, u2} R M _inst_1 _inst_2 _inst_4)
but is expected to have type
  forall {R : Type.{u3}} {M : Type.{u2}} {N : Type.{u1}} [_inst_1 : Zero.{u3} R] [_inst_2 : Zero.{u2} M] [_inst_3 : Zero.{u1} N] [_inst_4 : SMul.{u3, u2} R M] [_inst_5 : SMul.{u3, u1} R N] [_inst_6 : NoZeroSMulDivisors.{u3, u1} R N _inst_1 _inst_3 _inst_5] (f : M -> N), (Function.Injective.{succ u2, succ u1} M N f) -> (Eq.{succ u1} N (f (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M _inst_2))) (OfNat.ofNat.{u1} N 0 (Zero.toOfNat0.{u1} N _inst_3))) -> (forall (c : R) (x : M), Eq.{succ u1} N (f (HSMul.hSMul.{u3, u2, u2} R M M (instHSMul.{u3, u2} R M _inst_4) c x)) (HSMul.hSMul.{u3, u1, u1} R N N (instHSMul.{u3, u1} R N _inst_5) c (f x))) -> (NoZeroSMulDivisors.{u3, u2} R M _inst_1 _inst_2 _inst_4)
Case conversion may be inaccurate. Consider using '#align function.injective.no_zero_smul_divisors Function.Injective.noZeroSMulDivisorsₓ'. -/
/-- Pullback a `no_zero_smul_divisors` instance along an injective function. -/
theorem Function.Injective.noZeroSMulDivisors {R M N : Type _} [Zero R] [Zero M] [Zero N] [SMul R M]
    [SMul R N] [NoZeroSMulDivisors R N] (f : M → N) (hf : Function.Injective f) (h0 : f 0 = 0)
    (hs : ∀ (c : R) (x : M), f (c • x) = c • f x) : NoZeroSMulDivisors R M :=
  ⟨fun c m h =>
    Or.imp_right (@hf _ _) <| h0.symm ▸ eq_zero_or_eq_zero_of_smul_eq_zero (by rw [← hs, h, h0])⟩
#align function.injective.no_zero_smul_divisors Function.Injective.noZeroSMulDivisors

#print NoZeroDivisors.toNoZeroSMulDivisors /-
-- See note [lower instance priority]
instance (priority := 100) NoZeroDivisors.toNoZeroSMulDivisors [Zero R] [Mul R] [NoZeroDivisors R] :
    NoZeroSMulDivisors R R :=
  ⟨fun c x => eq_zero_or_eq_zero_of_mul_eq_zero⟩
#align no_zero_divisors.to_no_zero_smul_divisors NoZeroDivisors.toNoZeroSMulDivisors
-/

/- warning: smul_ne_zero -> smul_ne_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Zero.{u1} R] [_inst_2 : Zero.{u2} M] [_inst_3 : SMul.{u1, u2} R M] [_inst_4 : NoZeroSMulDivisors.{u1, u2} R M _inst_1 _inst_2 _inst_3] {c : R} {x : M}, (Ne.{succ u1} R c (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R _inst_1)))) -> (Ne.{succ u2} M x (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_2)))) -> (Ne.{succ u2} M (SMul.smul.{u1, u2} R M _inst_3 c x) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_2))))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u2} R] [_inst_2 : Zero.{u1} M] [_inst_3 : SMul.{u2, u1} R M] [_inst_4 : NoZeroSMulDivisors.{u2, u1} R M _inst_1 _inst_2 _inst_3] {c : R} {x : M}, (Ne.{succ u2} R c (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R _inst_1))) -> (Ne.{succ u1} M x (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M _inst_2))) -> (Ne.{succ u1} M (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M _inst_3) c x) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M _inst_2)))
Case conversion may be inaccurate. Consider using '#align smul_ne_zero smul_ne_zeroₓ'. -/
theorem smul_ne_zero [Zero R] [Zero M] [SMul R M] [NoZeroSMulDivisors R M] {c : R} {x : M}
    (hc : c ≠ 0) (hx : x ≠ 0) : c • x ≠ 0 := fun h =>
  (eq_zero_or_eq_zero_of_smul_eq_zero h).elim hc hx
#align smul_ne_zero smul_ne_zero

section SMulWithZero

variable [Zero R] [Zero M] [SMulWithZero R M] [NoZeroSMulDivisors R M] {c : R} {x : M}

#print smul_eq_zero /-
@[simp]
theorem smul_eq_zero : c • x = 0 ↔ c = 0 ∨ x = 0 :=
  ⟨eq_zero_or_eq_zero_of_smul_eq_zero, fun h =>
    h.elim (fun h => h.symm ▸ zero_smul R x) fun h => h.symm ▸ smul_zero c⟩
#align smul_eq_zero smul_eq_zero
-/

#print smul_ne_zero_iff /-
theorem smul_ne_zero_iff : c • x ≠ 0 ↔ c ≠ 0 ∧ x ≠ 0 := by rw [Ne.def, smul_eq_zero, not_or]
#align smul_ne_zero_iff smul_ne_zero_iff
-/

end SMulWithZero

section Module

variable [Semiring R] [AddCommMonoid M] [Module R M]

section Nat

variable (R) (M) [NoZeroSMulDivisors R M] [CharZero R]

include R

/- warning: nat.no_zero_smul_divisors -> Nat.noZeroSMulDivisors is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_4 : NoZeroSMulDivisors.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))] [_inst_5 : CharZero.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))], NoZeroSMulDivisors.{0, u2} Nat M Nat.hasZero (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddMonoid.SMul.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))
but is expected to have type
  forall (R : Type.{u2}) (M : Type.{u1}) [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] [_inst_4 : NoZeroSMulDivisors.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 _inst_3))))] [_inst_5 : CharZero.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))], NoZeroSMulDivisors.{0, u1} Nat M (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (AddMonoid.SMul.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))
Case conversion may be inaccurate. Consider using '#align nat.no_zero_smul_divisors Nat.noZeroSMulDivisorsₓ'. -/
theorem Nat.noZeroSMulDivisors : NoZeroSMulDivisors ℕ M :=
  ⟨by
    intro c x
    rw [nsmul_eq_smul_cast R, smul_eq_zero]
    simp⟩
#align nat.no_zero_smul_divisors Nat.noZeroSMulDivisors

/- warning: two_nsmul_eq_zero -> two_nsmul_eq_zero is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_4 : NoZeroSMulDivisors.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))] [_inst_5 : CharZero.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))] {v : M}, Iff (Eq.{succ u2} M (SMul.smul.{0, u2} Nat M (AddMonoid.SMul.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) v) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))))) (Eq.{succ u2} M v (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))))
but is expected to have type
  forall (R : Type.{u2}) (M : Type.{u1}) [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] [_inst_4 : NoZeroSMulDivisors.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 _inst_3))))] [_inst_5 : CharZero.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))] {v : M}, Iff (Eq.{succ u1} M (HSMul.hSMul.{0, u1, u1} Nat M M (instHSMul.{0, u1} Nat M (AddMonoid.SMul.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) v) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))))) (Eq.{succ u1} M v (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)))))
Case conversion may be inaccurate. Consider using '#align two_nsmul_eq_zero two_nsmul_eq_zeroₓ'. -/
@[simp]
theorem two_nsmul_eq_zero {v : M} : 2 • v = 0 ↔ v = 0 :=
  by
  haveI := Nat.noZeroSMulDivisors R M
  simp [smul_eq_zero]
#align two_nsmul_eq_zero two_nsmul_eq_zero

end Nat

variable (R M)

#print CharZero.of_module /-
/-- If `M` is an `R`-module with one and `M` has characteristic zero, then `R` has characteristic
zero as well. Usually `M` is an `R`-algebra. -/
theorem CharZero.of_module (M) [AddCommMonoidWithOne M] [CharZero M] [Module R M] : CharZero R :=
  by
  refine' ⟨fun m n h => @Nat.cast_injective M _ _ _ _ _⟩
  rw [← nsmul_one, ← nsmul_one, nsmul_eq_smul_cast R m (1 : M), nsmul_eq_smul_cast R n (1 : M), h]
#align char_zero.of_module CharZero.of_module
-/

end Module

section AddCommGroup

-- `R` can still be a semiring here
variable [Semiring R] [AddCommGroup M] [Module R M]

section SmulInjective

variable (M)

/- warning: smul_right_injective -> smul_right_injective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} (M : Type.{u2}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] [_inst_4 : NoZeroSMulDivisors.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))))] {c : R}, (Ne.{succ u1} R c (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Function.Injective.{succ u2, succ u2} M M (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)))) c))
but is expected to have type
  forall {R : Type.{u2}} (M : Type.{u1}) [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] [_inst_4 : NoZeroSMulDivisors.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))))] {c : R}, (Ne.{succ u2} R c (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))))) -> (Function.Injective.{succ u1, succ u1} M M ((fun (x._@.Mathlib.Algebra.Module.Basic._hyg.6218 : R) (x._@.Mathlib.Algebra.Module.Basic._hyg.6220 : M) => HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))))) x._@.Mathlib.Algebra.Module.Basic._hyg.6218 x._@.Mathlib.Algebra.Module.Basic._hyg.6220) c))
Case conversion may be inaccurate. Consider using '#align smul_right_injective smul_right_injectiveₓ'. -/
theorem smul_right_injective [NoZeroSMulDivisors R M] {c : R} (hc : c ≠ 0) :
    Function.Injective ((· • ·) c : M → M) :=
  (injective_iff_map_eq_zero (smulAddHom R M c)).2 fun a ha => (smul_eq_zero.mp ha).resolve_left hc
#align smul_right_injective smul_right_injective

variable {M}

/- warning: smul_right_inj -> smul_right_inj is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] [_inst_4 : NoZeroSMulDivisors.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))))] {c : R}, (Ne.{succ u1} R c (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (forall {x : M} {y : M}, Iff (Eq.{succ u2} M (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)))) c x) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)))) c y)) (Eq.{succ u2} M x y))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] [_inst_4 : NoZeroSMulDivisors.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))))] {c : R}, (Ne.{succ u2} R c (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))))) -> (forall {x : M} {y : M}, Iff (Eq.{succ u1} M (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))))) c x) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))))) c y)) (Eq.{succ u1} M x y))
Case conversion may be inaccurate. Consider using '#align smul_right_inj smul_right_injₓ'. -/
theorem smul_right_inj [NoZeroSMulDivisors R M] {c : R} (hc : c ≠ 0) {x y : M} :
    c • x = c • y ↔ x = y :=
  (smul_right_injective M hc).eq_iff
#align smul_right_inj smul_right_inj

end SmulInjective

section Nat

variable (R M) [NoZeroSMulDivisors R M] [CharZero R]

include R

/- warning: self_eq_neg -> self_eq_neg is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] [_inst_4 : NoZeroSMulDivisors.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))))] [_inst_5 : CharZero.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))] {v : M}, Iff (Eq.{succ u2} M v (Neg.neg.{u2} M (SubNegMonoid.toHasNeg.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))) v)) (Eq.{succ u2} M v (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))))))))
but is expected to have type
  forall (R : Type.{u2}) (M : Type.{u1}) [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] [_inst_4 : NoZeroSMulDivisors.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))))] [_inst_5 : CharZero.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))] {v : M}, Iff (Eq.{succ u1} M v (Neg.neg.{u1} M (NegZeroClass.toNeg.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) v)) (Eq.{succ u1} M v (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))))))
Case conversion may be inaccurate. Consider using '#align self_eq_neg self_eq_negₓ'. -/
theorem self_eq_neg {v : M} : v = -v ↔ v = 0 := by
  rw [← two_nsmul_eq_zero R M, two_smul, add_eq_zero_iff_eq_neg]
#align self_eq_neg self_eq_neg

/- warning: neg_eq_self -> neg_eq_self is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] [_inst_4 : NoZeroSMulDivisors.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))))] [_inst_5 : CharZero.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))] {v : M}, Iff (Eq.{succ u2} M (Neg.neg.{u2} M (SubNegMonoid.toHasNeg.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))) v) v) (Eq.{succ u2} M v (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))))))))
but is expected to have type
  forall (R : Type.{u2}) (M : Type.{u1}) [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] [_inst_4 : NoZeroSMulDivisors.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))))] [_inst_5 : CharZero.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))] {v : M}, Iff (Eq.{succ u1} M (Neg.neg.{u1} M (NegZeroClass.toNeg.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) v) v) (Eq.{succ u1} M v (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))))))
Case conversion may be inaccurate. Consider using '#align neg_eq_self neg_eq_selfₓ'. -/
theorem neg_eq_self {v : M} : -v = v ↔ v = 0 := by rw [eq_comm, self_eq_neg R M]
#align neg_eq_self neg_eq_self

/- warning: self_ne_neg -> self_ne_neg is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] [_inst_4 : NoZeroSMulDivisors.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))))] [_inst_5 : CharZero.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))] {v : M}, Iff (Ne.{succ u2} M v (Neg.neg.{u2} M (SubNegMonoid.toHasNeg.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))) v)) (Ne.{succ u2} M v (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))))))))
but is expected to have type
  forall (R : Type.{u2}) (M : Type.{u1}) [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] [_inst_4 : NoZeroSMulDivisors.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))))] [_inst_5 : CharZero.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))] {v : M}, Iff (Ne.{succ u1} M v (Neg.neg.{u1} M (NegZeroClass.toNeg.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) v)) (Ne.{succ u1} M v (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))))))
Case conversion may be inaccurate. Consider using '#align self_ne_neg self_ne_negₓ'. -/
theorem self_ne_neg {v : M} : v ≠ -v ↔ v ≠ 0 :=
  (self_eq_neg R M).Not
#align self_ne_neg self_ne_neg

/- warning: neg_ne_self -> neg_ne_self is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] [_inst_4 : NoZeroSMulDivisors.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))))] [_inst_5 : CharZero.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))] {v : M}, Iff (Ne.{succ u2} M (Neg.neg.{u2} M (SubNegMonoid.toHasNeg.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))) v) v) (Ne.{succ u2} M v (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))))))))
but is expected to have type
  forall (R : Type.{u2}) (M : Type.{u1}) [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] [_inst_4 : NoZeroSMulDivisors.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))))] [_inst_5 : CharZero.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))] {v : M}, Iff (Ne.{succ u1} M (Neg.neg.{u1} M (NegZeroClass.toNeg.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) v) v) (Ne.{succ u1} M v (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))))))
Case conversion may be inaccurate. Consider using '#align neg_ne_self neg_ne_selfₓ'. -/
theorem neg_ne_self {v : M} : -v ≠ v ↔ v ≠ 0 :=
  (neg_eq_self R M).Not
#align neg_ne_self neg_ne_self

end Nat

end AddCommGroup

section Module

variable [Ring R] [AddCommGroup M] [Module R M] [NoZeroSMulDivisors R M]

section SmulInjective

variable (R)

/- warning: smul_left_injective -> smul_left_injective is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] [_inst_4 : NoZeroSMulDivisors.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))))] {x : M}, (Ne.{succ u2} M x (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))))))))) -> (Function.Injective.{succ u1, succ u2} R M (fun (c : R) => SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)))) c x))
but is expected to have type
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] [_inst_4 : NoZeroSMulDivisors.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (SMulZeroClass.toSMul.{u1, u2} R M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))))] {x : M}, (Ne.{succ u2} M x (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2)))))))) -> (Function.Injective.{succ u1, succ u2} R M (fun (c : R) => HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))))) c x))
Case conversion may be inaccurate. Consider using '#align smul_left_injective smul_left_injectiveₓ'. -/
theorem smul_left_injective {x : M} (hx : x ≠ 0) : Function.Injective fun c : R => c • x :=
  fun c d h =>
  sub_eq_zero.mp
    ((smul_eq_zero.mp
          (calc
            (c - d) • x = c • x - d • x := sub_smul c d x
            _ = 0 := sub_eq_zero.mpr h
            )).resolve_right
      hx)
#align smul_left_injective smul_left_injective

end SmulInjective

end Module

section GroupWithZero

variable [GroupWithZero R] [AddMonoid M] [DistribMulAction R M]

/- warning: group_with_zero.to_no_zero_smul_divisors -> GroupWithZero.toNoZeroSMulDivisors is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : GroupWithZero.{u1} R] [_inst_2 : AddMonoid.{u2} M] [_inst_3 : DistribMulAction.{u1, u2} R M (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2], NoZeroSMulDivisors.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_2)) (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_2)) (DistribSMul.toSmulZeroClass.{u1, u2} R M (AddMonoid.toAddZeroClass.{u2} M _inst_2) (DistribMulAction.toDistribSMul.{u1, u2} R M (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2 _inst_3)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : GroupWithZero.{u1} R] [_inst_2 : AddMonoid.{u2} M] [_inst_3 : DistribMulAction.{u1, u2} R M (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2], NoZeroSMulDivisors.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M _inst_2) (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M _inst_2) (DistribSMul.toSMulZeroClass.{u1, u2} R M (AddMonoid.toAddZeroClass.{u2} M _inst_2) (DistribMulAction.toDistribSMul.{u1, u2} R M (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2 _inst_3)))
Case conversion may be inaccurate. Consider using '#align group_with_zero.to_no_zero_smul_divisors GroupWithZero.toNoZeroSMulDivisorsₓ'. -/
-- see note [lower instance priority]
/-- This instance applies to `division_semiring`s, in particular `nnreal` and `nnrat`. -/
instance (priority := 100) GroupWithZero.toNoZeroSMulDivisors : NoZeroSMulDivisors R M :=
  ⟨fun c x h => or_iff_not_imp_left.2 fun hc => (smul_eq_zero_iff_eq' hc).1 h⟩
#align group_with_zero.to_no_zero_smul_divisors GroupWithZero.toNoZeroSMulDivisors

end GroupWithZero

/- warning: rat_module.no_zero_smul_divisors -> RatModule.noZeroSMulDivisors is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : AddCommGroup.{u1} M] [_inst_2 : Module.{0, u1} Rat M Rat.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1)], NoZeroSMulDivisors.{0, u1} Int M Int.hasZero (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))))) (SubNegMonoid.SMulInt.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : AddCommGroup.{u1} M] [_inst_2 : Module.{0, u1} Rat M Rat.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1)], NoZeroSMulDivisors.{0, u1} Int M (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_1))))) (SubNegMonoid.SMulInt.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))
Case conversion may be inaccurate. Consider using '#align rat_module.no_zero_smul_divisors RatModule.noZeroSMulDivisorsₓ'. -/
-- see note [lower instance priority]
instance (priority := 100) RatModule.noZeroSMulDivisors [AddCommGroup M] [Module ℚ M] :
    NoZeroSMulDivisors ℤ M :=
  ⟨fun k x h => by simpa [zsmul_eq_smul_cast ℚ k x] using h⟩
#align rat_module.no_zero_smul_divisors RatModule.noZeroSMulDivisors

end NoZeroSMulDivisors

#print Nat.smul_one_eq_coe /-
@[simp]
theorem Nat.smul_one_eq_coe {R : Type _} [Semiring R] (m : ℕ) : m • (1 : R) = ↑m := by
  rw [nsmul_eq_mul, mul_one]
#align nat.smul_one_eq_coe Nat.smul_one_eq_coe
-/

/- warning: int.smul_one_eq_coe -> Int.smul_one_eq_coe is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] (m : Int), Eq.{succ u1} R (SMul.smul.{0, u1} Int R (SubNegMonoid.SMulInt.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) m (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int R (HasLiftT.mk.{1, succ u1} Int R (CoeTCₓ.coe.{1, succ u1} Int R (Int.castCoe.{u1} R (AddGroupWithOne.toHasIntCast.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))))) m)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] (m : Int), Eq.{succ u1} R (HSMul.hSMul.{0, u1, u1} Int R R (instHSMul.{0, u1} Int R (SubNegMonoid.SMulInt.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (Ring.toAddGroupWithOne.{u1} R _inst_1))))) m (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (Int.cast.{u1} R (Ring.toIntCast.{u1} R _inst_1) m)
Case conversion may be inaccurate. Consider using '#align int.smul_one_eq_coe Int.smul_one_eq_coeₓ'. -/
@[simp]
theorem Int.smul_one_eq_coe {R : Type _} [Ring R] (m : ℤ) : m • (1 : R) = ↑m := by
  rw [zsmul_eq_mul, mul_one]
#align int.smul_one_eq_coe Int.smul_one_eq_coe

assert_not_exists Multiset

