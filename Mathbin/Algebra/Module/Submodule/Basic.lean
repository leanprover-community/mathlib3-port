/-
Copyright (c) 2015 Nathaniel Thomas. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Nathaniel Thomas, Jeremy Avigad, Johannes Hölzl, Mario Carneiro

! This file was ported from Lean 3 source module algebra.module.submodule.basic
! leanprover-community/mathlib commit fac369018417f980cec5fcdafc766a69f88d8cfe
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Module.LinearMap
import Mathbin.Algebra.Module.Equiv
import Mathbin.GroupTheory.GroupAction.SubMulAction
import Mathbin.GroupTheory.Submonoid.Membership

/-!

# Submodules of a module

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file we define

* `submodule R M` : a subset of a `module` `M` that contains zero and is closed with respect to
  addition and scalar multiplication.

* `subspace k M` : an abbreviation for `submodule` assuming that `k` is a `field`.

## Tags

submodule, subspace, linear map
-/


open Function

open BigOperators

universe u'' u' u v w

variable {G : Type u''} {S : Type u'} {R : Type u} {M : Type v} {ι : Type w}

#print SubmoduleClass /-
/-- `submodule_class S R M` says `S` is a type of submodules `s ≤ M`.

Note that only `R` is marked as `out_param` since `M` is already supplied by the `set_like` class.
-/
class SubmoduleClass (S : Type _) (R : outParam <| Type _) (M : Type _) [AddZeroClass M] [SMul R M]
  [SetLike S M] [AddSubmonoidClass S M] extends SMulMemClass S R M
#align submodule_class SubmoduleClass
-/

#print Submodule /-
/-- A submodule of a module is one which is closed under vector operations.
  This is a sufficient condition for the subset of vectors in the submodule
  to themselves form a module. -/
structure Submodule (R : Type u) (M : Type v) [Semiring R] [AddCommMonoid M] [Module R M] extends
  AddSubmonoid M, SubMulAction R M : Type v
#align submodule Submodule
-/

/-- Reinterpret a `submodule` as an `add_submonoid`. -/
add_decl_doc Submodule.toAddSubmonoid

/-- Reinterpret a `submodule` as an `sub_mul_action`. -/
add_decl_doc Submodule.toSubMulAction

namespace Submodule

variable [Semiring R] [AddCommMonoid M] [Module R M]

instance : SetLike (Submodule R M) M
    where
  coe := Submodule.carrier
  coe_injective' p q h := by cases p <;> cases q <;> congr

instance : AddSubmonoidClass (Submodule R M) M
    where
  zero_mem := zero_mem'
  add_mem := add_mem'

instance : SubmoduleClass (Submodule R M) R M where smul_mem := smul_mem'

/- warning: submodule.mem_to_add_submonoid -> Submodule.mem_toAddSubmonoid is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (x : M), Iff (Membership.Mem.{u2, u2} M (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SetLike.hasMem.{u2, u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) M (AddSubmonoid.setLike.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) x (Submodule.toAddSubmonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3 p)) (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x p)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (x : M), Iff (Membership.mem.{u2, u2} M (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) M (AddSubmonoid.instSetLikeAddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) x (Submodule.toAddSubmonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3 p)) (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x p)
Case conversion may be inaccurate. Consider using '#align submodule.mem_to_add_submonoid Submodule.mem_toAddSubmonoidₓ'. -/
@[simp]
theorem mem_toAddSubmonoid (p : Submodule R M) (x : M) : x ∈ p.toAddSubmonoid ↔ x ∈ p :=
  Iff.rfl
#align submodule.mem_to_add_submonoid Submodule.mem_toAddSubmonoid

variable {p q : Submodule R M}

/- warning: submodule.mem_mk -> Submodule.mem_mk is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {S : Set.{u2} M} {x : M} (h₁ : forall {a : M} {b : M}, (Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) a S) -> (Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) b S) -> (Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) a b) S)) (h₂ : Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))) S) (h₃ : forall (c : R) {x : M}, (Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) x S) -> (Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) c x) S)), Iff (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.mk.{u1, u2} R M _inst_1 _inst_2 _inst_3 S h₁ h₂ h₃)) (Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) x S)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {S : AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))} {x : M} (h₁ : forall (a : R) {b : M}, (Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) b (AddSubsemigroup.carrier.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddSubmonoid.toAddSubsemigroup.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) S))) -> (Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) a b) (AddSubsemigroup.carrier.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddSubmonoid.toAddSubsemigroup.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) S)))), Iff (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.mk.{u1, u2} R M _inst_1 _inst_2 _inst_3 S h₁)) (Membership.mem.{u2, u2} M (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) M (AddSubmonoid.instSetLikeAddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) x S)
Case conversion may be inaccurate. Consider using '#align submodule.mem_mk Submodule.mem_mkₓ'. -/
@[simp]
theorem mem_mk {S : Set M} {x : M} (h₁ h₂ h₃) : x ∈ (⟨S, h₁, h₂, h₃⟩ : Submodule R M) ↔ x ∈ S :=
  Iff.rfl
#align submodule.mem_mk Submodule.mem_mk

/- warning: submodule.coe_set_mk -> Submodule.coe_set_mk is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (S : Set.{u2} M) (h₁ : forall {a : M} {b : M}, (Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) a S) -> (Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) b S) -> (Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) a b) S)) (h₂ : Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))) S) (h₃ : forall (c : R) {x : M}, (Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) x S) -> (Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) c x) S)), Eq.{succ u2} (Set.{u2} M) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (Submodule.mk.{u1, u2} R M _inst_1 _inst_2 _inst_3 S h₁ h₂ h₃)) S
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (S : AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (h₁ : forall (a : R) {b : M}, (Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) b (AddSubsemigroup.carrier.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddSubmonoid.toAddSubsemigroup.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) S))) -> (Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) a b) (AddSubsemigroup.carrier.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddSubmonoid.toAddSubsemigroup.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) S)))), Eq.{succ u2} (Set.{u2} M) (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.mk.{u1, u2} R M _inst_1 _inst_2 _inst_3 S h₁)) (SetLike.coe.{u2, u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) M (AddSubmonoid.instSetLikeAddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) S)
Case conversion may be inaccurate. Consider using '#align submodule.coe_set_mk Submodule.coe_set_mkₓ'. -/
@[simp]
theorem coe_set_mk (S : Set M) (h₁ h₂ h₃) : ((⟨S, h₁, h₂, h₃⟩ : Submodule R M) : Set M) = S :=
  rfl
#align submodule.coe_set_mk Submodule.coe_set_mk

/- warning: submodule.mk_le_mk -> Submodule.mk_le_mk is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {S : Set.{u2} M} {S' : Set.{u2} M} (h₁ : forall {a : M} {b : M}, (Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) a S) -> (Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) b S) -> (Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) a b) S)) (h₂ : Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))) S) (h₃ : forall (c : R) {x : M}, (Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) x S) -> (Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) c x) S)) (h₁' : forall {a : M} {b : M}, (Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) a S') -> (Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) b S') -> (Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) a b) S')) (h₂' : Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))) S') (h₃' : forall (c : R) {x : M}, (Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) x S') -> (Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) c x) S')), Iff (LE.le.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (Submodule.mk.{u1, u2} R M _inst_1 _inst_2 _inst_3 S h₁ h₂ h₃) (Submodule.mk.{u1, u2} R M _inst_1 _inst_2 _inst_3 S' h₁' h₂' h₃')) (HasSubset.Subset.{u2} (Set.{u2} M) (Set.hasSubset.{u2} M) S S')
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {S : AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))} {S' : AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))} (h₁ : forall (a : R) {b : M}, (Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) b (AddSubsemigroup.carrier.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddSubmonoid.toAddSubsemigroup.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) S))) -> (Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) a b) (AddSubsemigroup.carrier.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddSubmonoid.toAddSubsemigroup.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) S)))) (h₂ : forall (c : R) {x : M}, (Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (AddSubsemigroup.carrier.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddSubmonoid.toAddSubsemigroup.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) S'))) -> (Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) c x) (AddSubsemigroup.carrier.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddSubmonoid.toAddSubsemigroup.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) S')))), Iff (LE.le.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instPartialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (Submodule.mk.{u1, u2} R M _inst_1 _inst_2 _inst_3 S h₁) (Submodule.mk.{u1, u2} R M _inst_1 _inst_2 _inst_3 S' h₂)) (LE.le.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Preorder.toLE.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (PartialOrder.toPreorder.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (CompleteSemilatticeInf.toPartialOrder.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (CompleteLattice.toCompleteSemilatticeInf.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))))) S S')
Case conversion may be inaccurate. Consider using '#align submodule.mk_le_mk Submodule.mk_le_mkₓ'. -/
@[simp]
theorem mk_le_mk {S S' : Set M} (h₁ h₂ h₃ h₁' h₂' h₃') :
    (⟨S, h₁, h₂, h₃⟩ : Submodule R M) ≤ (⟨S', h₁', h₂', h₃'⟩ : Submodule R M) ↔ S ⊆ S' :=
  Iff.rfl
#align submodule.mk_le_mk Submodule.mk_le_mk

/- warning: submodule.ext -> Submodule.ext is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3} {q : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3}, (forall (x : M), Iff (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x p) (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x q)) -> (Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) p q)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3} {q : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3}, (forall (x : M), Iff (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x p) (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x q)) -> (Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) p q)
Case conversion may be inaccurate. Consider using '#align submodule.ext Submodule.extₓ'. -/
@[ext]
theorem ext (h : ∀ x, x ∈ p ↔ x ∈ q) : p = q :=
  SetLike.ext h
#align submodule.ext Submodule.ext

/- warning: submodule.copy -> Submodule.copy is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (s : Set.{u2} M), (Eq.{succ u2} (Set.{u2} M) s ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) p)) -> (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (s : Set.{u2} M), (Eq.{succ u2} (Set.{u2} M) s (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) p)) -> (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)
Case conversion may be inaccurate. Consider using '#align submodule.copy Submodule.copyₓ'. -/
/-- Copy of a submodule with a new `carrier` equal to the old one. Useful to fix definitional
equalities. -/
protected def copy (p : Submodule R M) (s : Set M) (hs : s = ↑p) : Submodule R M
    where
  carrier := s
  zero_mem' := hs.symm ▸ p.zero_mem'
  add_mem' _ _ := hs.symm ▸ p.add_mem'
  smul_mem' := hs.symm ▸ p.smul_mem'
#align submodule.copy Submodule.copy

/- warning: submodule.coe_copy -> Submodule.coe_copy is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (S : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (s : Set.{u2} M) (hs : Eq.{succ u2} (Set.{u2} M) s ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) S)), Eq.{succ u2} (Set.{u2} M) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (Submodule.copy.{u1, u2} R M _inst_1 _inst_2 _inst_3 S s hs)) s
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (S : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (s : Set.{u2} M) (hs : Eq.{succ u2} (Set.{u2} M) s (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) S)), Eq.{succ u2} (Set.{u2} M) (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.copy.{u1, u2} R M _inst_1 _inst_2 _inst_3 S s hs)) s
Case conversion may be inaccurate. Consider using '#align submodule.coe_copy Submodule.coe_copyₓ'. -/
@[simp]
theorem coe_copy (S : Submodule R M) (s : Set M) (hs : s = ↑S) : (S.copy s hs : Set M) = s :=
  rfl
#align submodule.coe_copy Submodule.coe_copy

/- warning: submodule.copy_eq -> Submodule.copy_eq is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (S : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (s : Set.{u2} M) (hs : Eq.{succ u2} (Set.{u2} M) s ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) S)), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.copy.{u1, u2} R M _inst_1 _inst_2 _inst_3 S s hs) S
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (S : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (s : Set.{u2} M) (hs : Eq.{succ u2} (Set.{u2} M) s (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) S)), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.copy.{u1, u2} R M _inst_1 _inst_2 _inst_3 S s hs) S
Case conversion may be inaccurate. Consider using '#align submodule.copy_eq Submodule.copy_eqₓ'. -/
theorem copy_eq (S : Submodule R M) (s : Set M) (hs : s = ↑S) : S.copy s hs = S :=
  SetLike.coe_injective hs
#align submodule.copy_eq Submodule.copy_eq

#print Submodule.toAddSubmonoid_injective /-
theorem toAddSubmonoid_injective : Injective (toAddSubmonoid : Submodule R M → AddSubmonoid M) :=
  fun p q h => SetLike.ext'_iff.2 (show _ from SetLike.ext'_iff.1 h)
#align submodule.to_add_submonoid_injective Submodule.toAddSubmonoid_injective
-/

#print Submodule.toAddSubmonoid_eq /-
@[simp]
theorem toAddSubmonoid_eq : p.toAddSubmonoid = q.toAddSubmonoid ↔ p = q :=
  toAddSubmonoid_injective.eq_iff
#align submodule.to_add_submonoid_eq Submodule.toAddSubmonoid_eq
-/

/- warning: submodule.to_add_submonoid_strict_mono -> Submodule.toAddSubmonoid_strictMono is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], StrictMono.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (PartialOrder.toPreorder.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (CompleteSemilatticeInf.toPartialOrder.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (CompleteLattice.toCompleteSemilatticeInf.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddSubmonoid.completeLattice.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))) (Submodule.toAddSubmonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], StrictMono.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instPartialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (PartialOrder.toPreorder.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (CompleteSemilatticeInf.toPartialOrder.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (CompleteLattice.toCompleteSemilatticeInf.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))) (Submodule.toAddSubmonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3)
Case conversion may be inaccurate. Consider using '#align submodule.to_add_submonoid_strict_mono Submodule.toAddSubmonoid_strictMonoₓ'. -/
@[mono]
theorem toAddSubmonoid_strictMono : StrictMono (toAddSubmonoid : Submodule R M → AddSubmonoid M) :=
  fun _ _ => id
#align submodule.to_add_submonoid_strict_mono Submodule.toAddSubmonoid_strictMono

/- warning: submodule.to_add_submonoid_le -> Submodule.toAddSubmonoid_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3} {q : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3}, Iff (LE.le.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Preorder.toLE.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (PartialOrder.toPreorder.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (CompleteSemilatticeInf.toPartialOrder.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (CompleteLattice.toCompleteSemilatticeInf.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddSubmonoid.completeLattice.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))))) (Submodule.toAddSubmonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3 p) (Submodule.toAddSubmonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3 q)) (LE.le.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) p q)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3} {q : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3}, Iff (LE.le.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Preorder.toLE.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (PartialOrder.toPreorder.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (CompleteSemilatticeInf.toPartialOrder.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (CompleteLattice.toCompleteSemilatticeInf.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))))) (Submodule.toAddSubmonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3 p) (Submodule.toAddSubmonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3 q)) (LE.le.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instPartialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) p q)
Case conversion may be inaccurate. Consider using '#align submodule.to_add_submonoid_le Submodule.toAddSubmonoid_leₓ'. -/
theorem toAddSubmonoid_le : p.toAddSubmonoid ≤ q.toAddSubmonoid ↔ p ≤ q :=
  Iff.rfl
#align submodule.to_add_submonoid_le Submodule.toAddSubmonoid_le

/- warning: submodule.to_add_submonoid_mono -> Submodule.toAddSubmonoid_mono is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], Monotone.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (PartialOrder.toPreorder.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (CompleteSemilatticeInf.toPartialOrder.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (CompleteLattice.toCompleteSemilatticeInf.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddSubmonoid.completeLattice.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))) (Submodule.toAddSubmonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], Monotone.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instPartialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (PartialOrder.toPreorder.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (CompleteSemilatticeInf.toPartialOrder.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (CompleteLattice.toCompleteSemilatticeInf.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))) (Submodule.toAddSubmonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3)
Case conversion may be inaccurate. Consider using '#align submodule.to_add_submonoid_mono Submodule.toAddSubmonoid_monoₓ'. -/
@[mono]
theorem toAddSubmonoid_mono : Monotone (toAddSubmonoid : Submodule R M → AddSubmonoid M) :=
  toAddSubmonoid_strictMono.Monotone
#align submodule.to_add_submonoid_mono Submodule.toAddSubmonoid_mono

/- warning: submodule.coe_to_add_submonoid -> Submodule.coe_toAddSubmonoid is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3), Eq.{succ u2} (Set.{u2} M) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) M (AddSubmonoid.setLike.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))) (Submodule.toAddSubmonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3 p)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) p)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3), Eq.{succ u2} (Set.{u2} M) (SetLike.coe.{u2, u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) M (AddSubmonoid.instSetLikeAddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Submodule.toAddSubmonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3 p)) (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) p)
Case conversion may be inaccurate. Consider using '#align submodule.coe_to_add_submonoid Submodule.coe_toAddSubmonoidₓ'. -/
@[simp]
theorem coe_toAddSubmonoid (p : Submodule R M) : (p.toAddSubmonoid : Set M) = p :=
  rfl
#align submodule.coe_to_add_submonoid Submodule.coe_toAddSubmonoid

#print Submodule.toSubMulAction_injective /-
theorem toSubMulAction_injective : Injective (toSubMulAction : Submodule R M → SubMulAction R M) :=
  fun p q h => SetLike.ext'_iff.2 (show _ from SetLike.ext'_iff.1 h)
#align submodule.to_sub_mul_action_injective Submodule.toSubMulAction_injective
-/

#print Submodule.toSubMulAction_eq /-
@[simp]
theorem toSubMulAction_eq : p.toSubMulAction = q.toSubMulAction ↔ p = q :=
  toSubMulAction_injective.eq_iff
#align submodule.to_sub_mul_action_eq Submodule.toSubMulAction_eq
-/

/- warning: submodule.to_sub_mul_action_strict_mono -> Submodule.toSubMulAction_strictMono is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], StrictMono.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SubMulAction.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (PartialOrder.toPreorder.{u2} (SubMulAction.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) (SetLike.partialOrder.{u2, u2} (SubMulAction.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) M (SubMulAction.setLike.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))))) (Submodule.toSubMulAction.{u1, u2} R M _inst_1 _inst_2 _inst_3)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], StrictMono.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SubMulAction.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instPartialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (PartialOrder.toPreorder.{u2} (SubMulAction.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) (SetLike.instPartialOrder.{u2, u2} (SubMulAction.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) M (SubMulAction.instSetLikeSubMulAction.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))))) (Submodule.toSubMulAction.{u1, u2} R M _inst_1 _inst_2 _inst_3)
Case conversion may be inaccurate. Consider using '#align submodule.to_sub_mul_action_strict_mono Submodule.toSubMulAction_strictMonoₓ'. -/
@[mono]
theorem toSubMulAction_strictMono :
    StrictMono (toSubMulAction : Submodule R M → SubMulAction R M) := fun _ _ => id
#align submodule.to_sub_mul_action_strict_mono Submodule.toSubMulAction_strictMono

/- warning: submodule.to_sub_mul_action_mono -> Submodule.toSubMulAction_mono is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], Monotone.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SubMulAction.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (PartialOrder.toPreorder.{u2} (SubMulAction.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) (SetLike.partialOrder.{u2, u2} (SubMulAction.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) M (SubMulAction.setLike.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))))) (Submodule.toSubMulAction.{u1, u2} R M _inst_1 _inst_2 _inst_3)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], Monotone.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SubMulAction.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instPartialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (PartialOrder.toPreorder.{u2} (SubMulAction.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) (SetLike.instPartialOrder.{u2, u2} (SubMulAction.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) M (SubMulAction.instSetLikeSubMulAction.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))))) (Submodule.toSubMulAction.{u1, u2} R M _inst_1 _inst_2 _inst_3)
Case conversion may be inaccurate. Consider using '#align submodule.to_sub_mul_action_mono Submodule.toSubMulAction_monoₓ'. -/
@[mono]
theorem toSubMulAction_mono : Monotone (toSubMulAction : Submodule R M → SubMulAction R M) :=
  toSubMulAction_strictMono.Monotone
#align submodule.to_sub_mul_action_mono Submodule.toSubMulAction_mono

/- warning: submodule.coe_to_sub_mul_action -> Submodule.coe_toSubMulAction is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3), Eq.{succ u2} (Set.{u2} M) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (SubMulAction.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (SubMulAction.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (SubMulAction.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (SubMulAction.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) M (SubMulAction.setLike.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))))))) (Submodule.toSubMulAction.{u1, u2} R M _inst_1 _inst_2 _inst_3 p)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) p)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3), Eq.{succ u2} (Set.{u2} M) (SetLike.coe.{u2, u2} (SubMulAction.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) M (SubMulAction.instSetLikeSubMulAction.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) (Submodule.toSubMulAction.{u1, u2} R M _inst_1 _inst_2 _inst_3 p)) (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) p)
Case conversion may be inaccurate. Consider using '#align submodule.coe_to_sub_mul_action Submodule.coe_toSubMulActionₓ'. -/
@[simp]
theorem coe_toSubMulAction (p : Submodule R M) : (p.toSubMulAction : Set M) = p :=
  rfl
#align submodule.coe_to_sub_mul_action Submodule.coe_toSubMulAction

end Submodule

namespace SubmoduleClass

variable [Semiring R] [AddCommMonoid M] [Module R M] {A : Type _} [SetLike A M]
  [AddSubmonoidClass A M] [hA : SubmoduleClass A R M] (S' : A)

include hA

#print SubmoduleClass.toModule /-
-- Prefer subclasses of `module` over `submodule_class`.
/-- A submodule of a `module` is a `module`.  -/
instance (priority := 75) toModule : Module R S' :=
  Subtype.coe_injective.Module R (AddSubmonoidClass.Subtype S') (SetLike.val_smul S')
#align submodule_class.to_module SubmoduleClass.toModule
-/

#print SubmoduleClass.subtype /-
/-- The natural `R`-linear map from a submodule of an `R`-module `M` to `M`. -/
protected def subtype : S' →ₗ[R] M :=
  ⟨coe, fun _ _ => rfl, fun _ _ => rfl⟩
#align submodule_class.subtype SubmoduleClass.subtype
-/

/- warning: submodule_class.coe_subtype -> SubmoduleClass.coeSubtype is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {A : Type.{u3}} [_inst_4 : SetLike.{u3, u2} A M] [_inst_5 : AddSubmonoidClass.{u3, u2} A M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_4] [hA : SubmoduleClass.{u3, u1, u2} A R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) _inst_4 _inst_5] (S' : A), Eq.{succ u2} ((fun (_x : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (coeSort.{succ u3, succ (succ u2)} A Type.{u2} (SetLike.hasCoeToSort.{u3, u2} A M _inst_4) S') M (AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 A _inst_4 _inst_5 S') _inst_2 (SubmoduleClass.toModule.{u1, u2, u3} R M _inst_1 _inst_2 _inst_3 A _inst_4 _inst_5 hA S') _inst_3) => (coeSort.{succ u3, succ (succ u2)} A Type.{u2} (SetLike.hasCoeToSort.{u3, u2} A M _inst_4) S') -> M) (SubmoduleClass.subtype.{u1, u2, u3} R M _inst_1 _inst_2 _inst_3 A _inst_4 _inst_5 hA S')) (coeFn.{succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (coeSort.{succ u3, succ (succ u2)} A Type.{u2} (SetLike.hasCoeToSort.{u3, u2} A M _inst_4) S') M (AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 A _inst_4 _inst_5 S') _inst_2 (SubmoduleClass.toModule.{u1, u2, u3} R M _inst_1 _inst_2 _inst_3 A _inst_4 _inst_5 hA S') _inst_3) (fun (_x : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (coeSort.{succ u3, succ (succ u2)} A Type.{u2} (SetLike.hasCoeToSort.{u3, u2} A M _inst_4) S') M (AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 A _inst_4 _inst_5 S') _inst_2 (SubmoduleClass.toModule.{u1, u2, u3} R M _inst_1 _inst_2 _inst_3 A _inst_4 _inst_5 hA S') _inst_3) => (coeSort.{succ u3, succ (succ u2)} A Type.{u2} (SetLike.hasCoeToSort.{u3, u2} A M _inst_4) S') -> M) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R (coeSort.{succ u3, succ (succ u2)} A Type.{u2} (SetLike.hasCoeToSort.{u3, u2} A M _inst_4) S') M _inst_1 _inst_1 (AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 A _inst_4 _inst_5 S') _inst_2 (SubmoduleClass.toModule.{u1, u2, u3} R M _inst_1 _inst_2 _inst_3 A _inst_4 _inst_5 hA S') _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (SubmoduleClass.subtype.{u1, u2, u3} R M _inst_1 _inst_2 _inst_3 A _inst_4 _inst_5 hA S')) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u3, succ (succ u2)} A Type.{u2} (SetLike.hasCoeToSort.{u3, u2} A M _inst_4) S') M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u3, succ (succ u2)} A Type.{u2} (SetLike.hasCoeToSort.{u3, u2} A M _inst_4) S') M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u3, succ (succ u2)} A Type.{u2} (SetLike.hasCoeToSort.{u3, u2} A M _inst_4) S') M (coeBase.{succ u2, succ u2} (coeSort.{succ u3, succ (succ u2)} A Type.{u2} (SetLike.hasCoeToSort.{u3, u2} A M _inst_4) S') M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u3} M A (SetLike.hasMem.{u3, u2} A M _inst_4) x S'))))))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u2, u3} R M _inst_1 _inst_2] {A : Type.{u1}} [_inst_4 : SetLike.{u1, u3} A M] [_inst_5 : AddSubmonoidClass.{u1, u3} A M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) _inst_4] [hA : SubmoduleClass.{u1, u2, u3} A R M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulZeroClass.toSMul.{u2, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u3} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_3)))) _inst_4 _inst_5] (S' : A), Eq.{succ u3} (forall (a : Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u1} M A (SetLike.instMembership.{u1, u3} A M _inst_4) x S')), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u1} M A (SetLike.instMembership.{u1, u3} A M _inst_4) x S')) => M) a) (FunLike.coe.{succ u3, succ u3, succ u3} (LinearMap.{u2, u2, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u1} M A (SetLike.instMembership.{u1, u3} A M _inst_4) x S')) M (AddSubmonoidClass.toAddCommMonoid.{u3, u1} M _inst_2 A _inst_4 _inst_5 S') _inst_2 (SubmoduleClass.toModule.{u2, u3, u1} R M _inst_1 _inst_2 _inst_3 A _inst_4 _inst_5 hA S') _inst_3) (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u1} M A (SetLike.instMembership.{u1, u3} A M _inst_4) x S')) (fun (_x : Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u1} M A (SetLike.instMembership.{u1, u3} A M _inst_4) x S')) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u1} M A (SetLike.instMembership.{u1, u3} A M _inst_4) x S')) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, u3, u3} R R (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u1} M A (SetLike.instMembership.{u1, u3} A M _inst_4) x S')) M _inst_1 _inst_1 (AddSubmonoidClass.toAddCommMonoid.{u3, u1} M _inst_2 A _inst_4 _inst_5 S') _inst_2 (SubmoduleClass.toModule.{u2, u3, u1} R M _inst_1 _inst_2 _inst_3 A _inst_4 _inst_5 hA S') _inst_3 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (SubmoduleClass.subtype.{u2, u3, u1} R M _inst_1 _inst_2 _inst_3 A _inst_4 _inst_5 hA S')) (Subtype.val.{succ u3} M (fun (x : M) => Membership.mem.{u3, u1} M A (SetLike.instMembership.{u1, u3} A M _inst_4) x S'))
Case conversion may be inaccurate. Consider using '#align submodule_class.coe_subtype SubmoduleClass.coeSubtypeₓ'. -/
@[simp]
protected theorem coeSubtype : (SubmoduleClass.subtype S' : S' → M) = coe :=
  rfl
#align submodule_class.coe_subtype SubmoduleClass.coeSubtype

end SubmoduleClass

namespace Submodule

section AddCommMonoid

variable [Semiring R] [AddCommMonoid M]

-- We can infer the module structure implicitly from the bundled submodule,
-- rather than via typeclass resolution.
variable {module_M : Module R M}

variable {p q : Submodule R M}

variable {r : R} {x y : M}

variable (p)

/- warning: submodule.mem_carrier -> Submodule.mem_carrier is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} (p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) {x : M}, Iff (Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) x (Submodule.carrier.{u1, u2} R M _inst_1 _inst_2 module_M p)) (Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)))) p))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} (p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) {x : M}, Iff (Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (AddSubsemigroup.carrier.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddSubmonoid.toAddSubsemigroup.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Submodule.toAddSubmonoid.{u1, u2} R M _inst_1 _inst_2 module_M p)))) (Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M) p))
Case conversion may be inaccurate. Consider using '#align submodule.mem_carrier Submodule.mem_carrierₓ'. -/
@[simp]
theorem mem_carrier : x ∈ p.carrier ↔ x ∈ (p : Set M) :=
  Iff.rfl
#align submodule.mem_carrier Submodule.mem_carrier

/- warning: submodule.zero_mem -> Submodule.zero_mem is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} (p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M), Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))) p
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} (p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M), Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) p
Case conversion may be inaccurate. Consider using '#align submodule.zero_mem Submodule.zero_memₓ'. -/
@[simp]
protected theorem zero_mem : (0 : M) ∈ p :=
  zero_mem _
#align submodule.zero_mem Submodule.zero_mem

/- warning: submodule.add_mem -> Submodule.add_mem is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} (p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) {x : M} {y : M}, (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) x p) -> (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) y p) -> (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) x y) p)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} (p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) {x : M} {y : M}, (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p) -> (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) y p) -> (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) x y) p)
Case conversion may be inaccurate. Consider using '#align submodule.add_mem Submodule.add_memₓ'. -/
protected theorem add_mem (h₁ : x ∈ p) (h₂ : y ∈ p) : x + y ∈ p :=
  add_mem h₁ h₂
#align submodule.add_mem Submodule.add_mem

/- warning: submodule.smul_mem -> Submodule.smul_mem is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} (p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) {x : M} (r : R), (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) x p) -> (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 module_M)))) r x) p)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} (p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) {x : M} (r : R), (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p) -> (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 module_M))))) r x) p)
Case conversion may be inaccurate. Consider using '#align submodule.smul_mem Submodule.smul_memₓ'. -/
theorem smul_mem (r : R) (h : x ∈ p) : r • x ∈ p :=
  p.smul_mem' r h
#align submodule.smul_mem Submodule.smul_mem

/- warning: submodule.smul_of_tower_mem -> Submodule.smul_of_tower_mem is a dubious translation:
lean 3 declaration is
  forall {S : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] {module_M : Module.{u2, u3} R M _inst_1 _inst_2} (p : Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) {x : M} [_inst_3 : SMul.{u1, u2} S R] [_inst_4 : SMul.{u1, u3} S M] [_inst_5 : IsScalarTower.{u1, u2, u3} S R M _inst_3 (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 module_M)))) _inst_4] (r : S), (Membership.Mem.{u3, u3} M (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u2, u3} R M _inst_1 _inst_2 module_M)) x p) -> (Membership.Mem.{u3, u3} M (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u2, u3} R M _inst_1 _inst_2 module_M)) (SMul.smul.{u1, u3} S M _inst_4 r x) p)
but is expected to have type
  forall {S : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] {module_M : Module.{u2, u3} R M _inst_1 _inst_2} (p : Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) {x : M} [_inst_3 : SMul.{u1, u2} S R] [_inst_4 : SMul.{u1, u3} S M] [_inst_5 : IsScalarTower.{u1, u2, u3} S R M _inst_3 (SMulZeroClass.toSMul.{u2, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u3} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 module_M)))) _inst_4] (r : S), (Membership.mem.{u3, u3} M (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u2, u3} R M _inst_1 _inst_2 module_M)) x p) -> (Membership.mem.{u3, u3} M (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u2, u3} R M _inst_1 _inst_2 module_M)) (HSMul.hSMul.{u1, u3, u3} S M M (instHSMul.{u1, u3} S M _inst_4) r x) p)
Case conversion may be inaccurate. Consider using '#align submodule.smul_of_tower_mem Submodule.smul_of_tower_memₓ'. -/
theorem smul_of_tower_mem [SMul S R] [SMul S M] [IsScalarTower S R M] (r : S) (h : x ∈ p) :
    r • x ∈ p :=
  p.toSubMulAction.smul_of_tower_mem r h
#align submodule.smul_of_tower_mem Submodule.smul_of_tower_mem

/- warning: submodule.sum_mem -> Submodule.sum_mem is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {ι : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} (p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) {t : Finset.{u3} ι} {f : ι -> M}, (forall (c : ι), (Membership.Mem.{u3, u3} ι (Finset.{u3} ι) (Finset.hasMem.{u3} ι) c t) -> (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) (f c) p)) -> (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) (Finset.sum.{u2, u3} M ι _inst_2 t (fun (i : ι) => f i)) p)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {ι : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} (p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) {t : Finset.{u3} ι} {f : ι -> M}, (forall (c : ι), (Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) c t) -> (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) (f c) p)) -> (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) (Finset.sum.{u2, u3} M ι _inst_2 t (fun (i : ι) => f i)) p)
Case conversion may be inaccurate. Consider using '#align submodule.sum_mem Submodule.sum_memₓ'. -/
protected theorem sum_mem {t : Finset ι} {f : ι → M} : (∀ c ∈ t, f c ∈ p) → (∑ i in t, f i) ∈ p :=
  sum_mem
#align submodule.sum_mem Submodule.sum_mem

/- warning: submodule.sum_smul_mem -> Submodule.sum_smul_mem is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {ι : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} (p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) {t : Finset.{u3} ι} {f : ι -> M} (r : ι -> R), (forall (c : ι), (Membership.Mem.{u3, u3} ι (Finset.{u3} ι) (Finset.hasMem.{u3} ι) c t) -> (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) (f c) p)) -> (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) (Finset.sum.{u2, u3} M ι _inst_2 t (fun (i : ι) => SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 module_M)))) (r i) (f i))) p)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {ι : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} (p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) {t : Finset.{u3} ι} {f : ι -> M} (r : ι -> R), (forall (c : ι), (Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) c t) -> (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) (f c) p)) -> (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) (Finset.sum.{u2, u3} M ι _inst_2 t (fun (i : ι) => HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 module_M))))) (r i) (f i))) p)
Case conversion may be inaccurate. Consider using '#align submodule.sum_smul_mem Submodule.sum_smul_memₓ'. -/
theorem sum_smul_mem {t : Finset ι} {f : ι → M} (r : ι → R) (hyp : ∀ c ∈ t, f c ∈ p) :
    (∑ i in t, r i • f i) ∈ p :=
  sum_mem fun i hi => smul_mem _ _ (hyp i hi)
#align submodule.sum_smul_mem Submodule.sum_smul_mem

/- warning: submodule.smul_mem_iff' -> Submodule.smul_mem_iff' is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] {module_M : Module.{u2, u3} R M _inst_1 _inst_2} (p : Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) {x : M} [_inst_3 : Group.{u1} G] [_inst_4 : MulAction.{u1, u3} G M (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))] [_inst_5 : SMul.{u1, u2} G R] [_inst_6 : IsScalarTower.{u1, u2, u3} G R M _inst_5 (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 module_M)))) (MulAction.toHasSmul.{u1, u3} G M (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) _inst_4)] (g : G), Iff (Membership.Mem.{u3, u3} M (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u2, u3} R M _inst_1 _inst_2 module_M)) (SMul.smul.{u1, u3} G M (MulAction.toHasSmul.{u1, u3} G M (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) _inst_4) g x) p) (Membership.Mem.{u3, u3} M (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u2, u3} R M _inst_1 _inst_2 module_M)) x p)
but is expected to have type
  forall {G : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] {module_M : Module.{u2, u3} R M _inst_1 _inst_2} (p : Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) {x : M} [_inst_3 : Group.{u1} G] [_inst_4 : MulAction.{u1, u3} G M (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))] [_inst_5 : SMul.{u1, u2} G R] [_inst_6 : IsScalarTower.{u1, u2, u3} G R M _inst_5 (SMulZeroClass.toSMul.{u2, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u3} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 module_M)))) (MulAction.toSMul.{u1, u3} G M (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) _inst_4)] (g : G), Iff (Membership.mem.{u3, u3} M (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u2, u3} R M _inst_1 _inst_2 module_M)) (HSMul.hSMul.{u1, u3, u3} G M M (instHSMul.{u1, u3} G M (MulAction.toSMul.{u1, u3} G M (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) _inst_4)) g x) p) (Membership.mem.{u3, u3} M (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u2, u3} R M _inst_1 _inst_2 module_M)) x p)
Case conversion may be inaccurate. Consider using '#align submodule.smul_mem_iff' Submodule.smul_mem_iff'ₓ'. -/
@[simp]
theorem smul_mem_iff' [Group G] [MulAction G M] [SMul G R] [IsScalarTower G R M] (g : G) :
    g • x ∈ p ↔ x ∈ p :=
  p.toSubMulAction.smul_mem_iff' g
#align submodule.smul_mem_iff' Submodule.smul_mem_iff'

instance : Add p :=
  ⟨fun x y => ⟨x.1 + y.1, add_mem x.2 y.2⟩⟩

instance : Zero p :=
  ⟨⟨0, zero_mem _⟩⟩

instance : Inhabited p :=
  ⟨0⟩

instance [SMul S R] [SMul S M] [IsScalarTower S R M] : SMul S p :=
  ⟨fun c x => ⟨c • x.1, smul_of_tower_mem _ c x.2⟩⟩

instance [SMul S R] [SMul S M] [IsScalarTower S R M] : IsScalarTower S R p :=
  p.toSubMulAction.IsScalarTower

/- warning: submodule.is_scalar_tower' -> Submodule.isScalarTower' is a dubious translation:
lean 3 declaration is
  forall {S : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] {module_M : Module.{u2, u3} R M _inst_1 _inst_2} (p : Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) {S' : Type.{u4}} [_inst_3 : SMul.{u1, u2} S R] [_inst_4 : SMul.{u1, u3} S M] [_inst_5 : SMul.{u4, u2} S' R] [_inst_6 : SMul.{u4, u3} S' M] [_inst_7 : SMul.{u1, u4} S S'] [_inst_8 : IsScalarTower.{u4, u2, u3} S' R M _inst_5 (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 module_M)))) _inst_6] [_inst_9 : IsScalarTower.{u1, u4, u3} S S' M _inst_7 _inst_6 _inst_4] [_inst_10 : IsScalarTower.{u1, u2, u3} S R M _inst_3 (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 module_M)))) _inst_4], IsScalarTower.{u1, u4, u3} S S' (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u2, u3} R M _inst_1 _inst_2 module_M)) p) _inst_7 (Submodule.hasSmul.{u4, u2, u3} S' R M _inst_1 _inst_2 module_M p _inst_5 _inst_6 _inst_8) (Submodule.hasSmul.{u1, u2, u3} S R M _inst_1 _inst_2 module_M p _inst_3 _inst_4 _inst_10)
but is expected to have type
  forall {S : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] {module_M : Module.{u2, u3} R M _inst_1 _inst_2} (p : Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) {S' : Type.{u4}} [_inst_3 : SMul.{u1, u2} S R] [_inst_4 : SMul.{u1, u3} S M] [_inst_5 : SMul.{u4, u2} S' R] [_inst_6 : SMul.{u4, u3} S' M] [_inst_7 : SMul.{u1, u4} S S'] [_inst_8 : IsScalarTower.{u4, u2, u3} S' R M _inst_5 (SMulZeroClass.toSMul.{u2, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u3} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 module_M)))) _inst_6] [_inst_9 : IsScalarTower.{u1, u4, u3} S S' M _inst_7 _inst_6 _inst_4] [_inst_10 : IsScalarTower.{u1, u2, u3} S R M _inst_3 (SMulZeroClass.toSMul.{u2, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u3} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 module_M)))) _inst_4], IsScalarTower.{u1, u4, u3} S S' (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u2, u3} R M _inst_1 _inst_2 module_M)) x p)) _inst_7 (Submodule.instSMulSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u4, u2, u3} S' R M _inst_1 _inst_2 module_M p _inst_5 _inst_6 _inst_8) (Submodule.instSMulSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2, u3} S R M _inst_1 _inst_2 module_M p _inst_3 _inst_4 _inst_10)
Case conversion may be inaccurate. Consider using '#align submodule.is_scalar_tower' Submodule.isScalarTower'ₓ'. -/
instance isScalarTower' {S' : Type _} [SMul S R] [SMul S M] [SMul S' R] [SMul S' M] [SMul S S']
    [IsScalarTower S' R M] [IsScalarTower S S' M] [IsScalarTower S R M] : IsScalarTower S S' p :=
  p.toSubMulAction.isScalarTower'
#align submodule.is_scalar_tower' Submodule.isScalarTower'

instance [SMul S R] [SMul S M] [IsScalarTower S R M] [SMul Sᵐᵒᵖ R] [SMul Sᵐᵒᵖ M]
    [IsScalarTower Sᵐᵒᵖ R M] [IsCentralScalar S M] : IsCentralScalar S p :=
  p.toSubMulAction.IsCentralScalar

/- warning: submodule.nonempty -> Submodule.nonempty is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} (p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M), Set.Nonempty.{u2} M ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)))) p)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} (p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M), Set.Nonempty.{u2} M (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M) p)
Case conversion may be inaccurate. Consider using '#align submodule.nonempty Submodule.nonemptyₓ'. -/
protected theorem nonempty : (p : Set M).Nonempty :=
  ⟨0, p.zero_mem⟩
#align submodule.nonempty Submodule.nonempty

/- warning: submodule.mk_eq_zero -> Submodule.mk_eq_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} (p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) {x : M} (h : Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) x p), Iff (Eq.{succ u2} (Subtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) (Subtype.mk.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) x p) x h) (OfNat.ofNat.{u2} (Subtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) 0 (OfNat.mk.{u2} (Subtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) 0 (Zero.zero.{u2} (Subtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) (Submodule.hasZero.{u1, u2} R M _inst_1 _inst_2 module_M p))))) (Eq.{succ u2} M x (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} (p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) {x : M} (h : Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p), Iff (Eq.{succ u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) (Subtype.mk.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p) x h) (OfNat.ofNat.{u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) 0 (Zero.toOfNat0.{u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) (Submodule.instZeroSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M p)))) (Eq.{succ u2} M x (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))
Case conversion may be inaccurate. Consider using '#align submodule.mk_eq_zero Submodule.mk_eq_zeroₓ'. -/
@[simp]
theorem mk_eq_zero {x} (h : x ∈ p) : (⟨x, h⟩ : p) = 0 ↔ x = 0 :=
  Subtype.ext_iff_val
#align submodule.mk_eq_zero Submodule.mk_eq_zero

variable {p}

/- warning: submodule.coe_eq_zero -> Submodule.coe_eq_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} {p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M} {x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p}, Iff (Eq.{succ u2} M ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) x p))))) x) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))))) (Eq.{succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) x (OfNat.ofNat.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) 0 (OfNat.mk.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) 0 (Zero.zero.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) (Submodule.hasZero.{u1, u2} R M _inst_1 _inst_2 module_M p)))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} {p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M} {x : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)}, Iff (Eq.{succ u2} M (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M) p)) x) (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))) (Eq.{succ u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) x (OfNat.ofNat.{u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) 0 (Zero.toOfNat0.{u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) (Submodule.instZeroSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M p))))
Case conversion may be inaccurate. Consider using '#align submodule.coe_eq_zero Submodule.coe_eq_zeroₓ'. -/
@[simp, norm_cast]
theorem coe_eq_zero {x : p} : (x : M) = 0 ↔ x = 0 :=
  (SetLike.coe_eq_coe : (x : M) = (0 : p) ↔ x = 0)
#align submodule.coe_eq_zero Submodule.coe_eq_zero

/- warning: submodule.coe_add -> Submodule.coe_add is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} {p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M} (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) (y : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p), Eq.{succ u2} M ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) x p))))) (HAdd.hAdd.{u2, u2, u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) (instHAdd.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) (Submodule.hasAdd.{u1, u2} R M _inst_1 _inst_2 module_M p)) x y)) (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) x p))))) x) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) x p))))) y))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} {p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M} (x : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) (y : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)), Eq.{succ u2} M (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M) p)) (HAdd.hAdd.{u2, u2, u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) (instHAdd.{u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) (Submodule.instAddSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M p)) x y)) (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M) p)) x) (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M) p)) y))
Case conversion may be inaccurate. Consider using '#align submodule.coe_add Submodule.coe_addₓ'. -/
@[simp, norm_cast]
theorem coe_add (x y : p) : (↑(x + y) : M) = ↑x + ↑y :=
  rfl
#align submodule.coe_add Submodule.coe_add

/- warning: submodule.coe_zero -> Submodule.coe_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} {p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M}, Eq.{succ u2} M ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) x p))))) (OfNat.ofNat.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) 0 (OfNat.mk.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) 0 (Zero.zero.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) (Submodule.hasZero.{u1, u2} R M _inst_1 _inst_2 module_M p))))) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} {p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M}, Eq.{succ u2} M (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M) p)) (OfNat.ofNat.{u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) 0 (Zero.toOfNat0.{u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) (Submodule.instZeroSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M p)))) (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))
Case conversion may be inaccurate. Consider using '#align submodule.coe_zero Submodule.coe_zeroₓ'. -/
@[simp, norm_cast]
theorem coe_zero : ((0 : p) : M) = 0 :=
  rfl
#align submodule.coe_zero Submodule.coe_zero

/- warning: submodule.coe_smul -> Submodule.coe_smul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} {p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M} (r : R) (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p), Eq.{succ u2} M ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) x p))))) (SMul.smul.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) (Submodule.hasSmul.{u1, u1, u2} R R M _inst_1 _inst_2 module_M p (Mul.toSMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) (MulAction.toHasSmul.{u1, u2} R M (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (MulActionWithZero.toMulAction.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 module_M))) (IsScalarTower.left.{u1, u2} R M (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (MulActionWithZero.toMulAction.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 module_M)))) r x)) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 module_M)))) r ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) x p))))) x))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} {p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M} (r : R) (x : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)), Eq.{succ u2} M (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M) p)) (HSMul.hSMul.{u1, u2, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) (instHSMul.{u1, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) (Submodule.instSMulSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u1, u2} R R M _inst_1 _inst_2 module_M p (SMulZeroClass.toSMul.{u1, u1} R R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (SMulWithZero.toSMulZeroClass.{u1, u1} R R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (MulZeroClass.toSMulWithZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 module_M)))) (IsScalarTower.left.{u1, u2} R M (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (MulActionWithZero.toMulAction.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 module_M))))) r x)) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 module_M))))) r (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M) p)) x))
Case conversion may be inaccurate. Consider using '#align submodule.coe_smul Submodule.coe_smulₓ'. -/
@[norm_cast]
theorem coe_smul (r : R) (x : p) : ((r • x : p) : M) = r • ↑x :=
  rfl
#align submodule.coe_smul Submodule.coe_smul

/- warning: submodule.coe_smul_of_tower -> Submodule.coe_smul_of_tower is a dubious translation:
lean 3 declaration is
  forall {S : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] {module_M : Module.{u2, u3} R M _inst_1 _inst_2} {p : Submodule.{u2, u3} R M _inst_1 _inst_2 module_M} [_inst_3 : SMul.{u1, u2} S R] [_inst_4 : SMul.{u1, u3} S M] [_inst_5 : IsScalarTower.{u1, u2, u3} S R M _inst_3 (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 module_M)))) _inst_4] (r : S) (x : coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u2, u3} R M _inst_1 _inst_2 module_M)) p), Eq.{succ u3} M ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u2, u3} R M _inst_1 _inst_2 module_M)) p) M (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u2, u3} R M _inst_1 _inst_2 module_M)) p) M (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u2, u3} R M _inst_1 _inst_2 module_M)) p) M (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u2, u3} R M _inst_1 _inst_2 module_M)) p) M (coeSubtype.{succ u3} M (fun (x : M) => Membership.Mem.{u3, u3} M (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u2, u3} R M _inst_1 _inst_2 module_M)) x p))))) (SMul.smul.{u1, u3} S (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u2, u3} R M _inst_1 _inst_2 module_M)) p) (Submodule.hasSmul.{u1, u2, u3} S R M _inst_1 _inst_2 module_M p _inst_3 _inst_4 _inst_5) r x)) (SMul.smul.{u1, u3} S M _inst_4 r ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u2, u3} R M _inst_1 _inst_2 module_M)) p) M (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u2, u3} R M _inst_1 _inst_2 module_M)) p) M (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u2, u3} R M _inst_1 _inst_2 module_M)) p) M (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u2, u3} R M _inst_1 _inst_2 module_M)) p) M (coeSubtype.{succ u3} M (fun (x : M) => Membership.Mem.{u3, u3} M (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u2, u3} R M _inst_1 _inst_2 module_M)) x p))))) x))
but is expected to have type
  forall {S : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] {module_M : Module.{u2, u3} R M _inst_1 _inst_2} {p : Submodule.{u2, u3} R M _inst_1 _inst_2 module_M} [_inst_3 : SMul.{u1, u2} S R] [_inst_4 : SMul.{u1, u3} S M] [_inst_5 : IsScalarTower.{u1, u2, u3} S R M _inst_3 (SMulZeroClass.toSMul.{u2, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u3} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 module_M)))) _inst_4] (r : S) (x : Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u2, u3} R M _inst_1 _inst_2 module_M)) x p)), Eq.{succ u3} M (Subtype.val.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (Set.{u3} M) (Set.instMembershipSet.{u3} M) x (SetLike.coe.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u2, u3} R M _inst_1 _inst_2 module_M) p)) (HSMul.hSMul.{u1, u3, u3} S (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u2, u3} R M _inst_1 _inst_2 module_M)) x p)) (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u2, u3} R M _inst_1 _inst_2 module_M)) x p)) (instHSMul.{u1, u3} S (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u2, u3} R M _inst_1 _inst_2 module_M)) x p)) (Submodule.instSMulSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2, u3} S R M _inst_1 _inst_2 module_M p _inst_3 _inst_4 _inst_5)) r x)) (HSMul.hSMul.{u1, u3, u3} S M M (instHSMul.{u1, u3} S M _inst_4) r (Subtype.val.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (Set.{u3} M) (Set.instMembershipSet.{u3} M) x (SetLike.coe.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u2, u3} R M _inst_1 _inst_2 module_M) p)) x))
Case conversion may be inaccurate. Consider using '#align submodule.coe_smul_of_tower Submodule.coe_smul_of_towerₓ'. -/
@[simp, norm_cast]
theorem coe_smul_of_tower [SMul S R] [SMul S M] [IsScalarTower S R M] (r : S) (x : p) :
    ((r • x : p) : M) = r • ↑x :=
  rfl
#align submodule.coe_smul_of_tower Submodule.coe_smul_of_tower

/- warning: submodule.coe_mk -> Submodule.coe_mk is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} {p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M} (x : M) (hx : Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) x p), Eq.{succ u2} M ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Subtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) M (HasLiftT.mk.{succ u2, succ u2} (Subtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) M (CoeTCₓ.coe.{succ u2, succ u2} (Subtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) M (coeBase.{succ u2, succ u2} (Subtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) x p))))) (Subtype.mk.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) x p) x hx)) x
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} {p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M} (x : M) (hx : Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p), Eq.{succ u2} M (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M) p)) (Subtype.mk.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p) x hx)) x
Case conversion may be inaccurate. Consider using '#align submodule.coe_mk Submodule.coe_mkₓ'. -/
@[simp, norm_cast]
theorem coe_mk (x : M) (hx : x ∈ p) : ((⟨x, hx⟩ : p) : M) = x :=
  rfl
#align submodule.coe_mk Submodule.coe_mk

/- warning: submodule.coe_mem -> Submodule.coe_mem is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} {p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M} (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p), Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) x p))))) x) p
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} {p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M} (x : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)), Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M) p)) x) p
Case conversion may be inaccurate. Consider using '#align submodule.coe_mem Submodule.coe_memₓ'. -/
@[simp]
theorem coe_mem (x : p) : (x : M) ∈ p :=
  x.2
#align submodule.coe_mem Submodule.coe_mem

variable (p)

instance : AddCommMonoid p :=
  { p.toAddSubmonoid.toAddCommMonoid with
    add := (· + ·)
    zero := 0 }

/- warning: submodule.module' -> Submodule.module' is a dubious translation:
lean 3 declaration is
  forall {S : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] {module_M : Module.{u2, u3} R M _inst_1 _inst_2} (p : Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) [_inst_3 : Semiring.{u1} S] [_inst_4 : SMul.{u1, u2} S R] [_inst_5 : Module.{u1, u3} S M _inst_3 _inst_2] [_inst_6 : IsScalarTower.{u1, u2, u3} S R M _inst_4 (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 module_M)))) (SMulZeroClass.toHasSmul.{u1, u3} S M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u3} S M (MulZeroClass.toHasZero.{u1} S (MulZeroOneClass.toMulZeroClass.{u1} S (MonoidWithZero.toMulZeroOneClass.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_3)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} S M (Semiring.toMonoidWithZero.{u1} S _inst_3) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u1, u3} S M _inst_3 _inst_2 _inst_5))))], Module.{u1, u3} S (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u2, u3} R M _inst_1 _inst_2 module_M)) p) _inst_3 (Submodule.addCommMonoid.{u2, u3} R M _inst_1 _inst_2 module_M p)
but is expected to have type
  forall {S : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] {module_M : Module.{u2, u3} R M _inst_1 _inst_2} (p : Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) [_inst_3 : Semiring.{u1} S] [_inst_4 : SMul.{u1, u2} S R] [_inst_5 : Module.{u1, u3} S M _inst_3 _inst_2] [_inst_6 : IsScalarTower.{u1, u2, u3} S R M _inst_4 (SMulZeroClass.toSMul.{u2, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u3} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 module_M)))) (SMulZeroClass.toSMul.{u1, u3} S M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u3} S M (MonoidWithZero.toZero.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_3)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u3} S M (Semiring.toMonoidWithZero.{u1} S _inst_3) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u1, u3} S M _inst_3 _inst_2 _inst_5))))], Module.{u1, u3} S (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u2, u3} R M _inst_1 _inst_2 module_M)) x p)) _inst_3 (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u2, u3} R M _inst_1 _inst_2 module_M p)
Case conversion may be inaccurate. Consider using '#align submodule.module' Submodule.module'ₓ'. -/
instance module' [Semiring S] [SMul S R] [Module S M] [IsScalarTower S R M] : Module S p := by
  refine' { p.to_sub_mul_action.mul_action' with smul := (· • ·).. } <;>
    · intros
      apply SetCoe.ext
      simp [smul_add, add_smul, mul_smul]
#align submodule.module' Submodule.module'

instance : Module R p :=
  p.module'

/- warning: submodule.no_zero_smul_divisors -> Submodule.noZeroSMulDivisors is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} (p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) [_inst_3 : NoZeroSMulDivisors.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 module_M))))], NoZeroSMulDivisors.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Submodule.hasZero.{u1, u2} R M _inst_1 _inst_2 module_M p) (Submodule.hasSmul.{u1, u1, u2} R R M _inst_1 _inst_2 module_M p (Mul.toSMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) (MulAction.toHasSmul.{u1, u2} R M (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (MulActionWithZero.toMulAction.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 module_M))) (IsScalarTower.left.{u1, u2} R M (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (MulActionWithZero.toMulAction.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 module_M))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} (p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) [_inst_3 : NoZeroSMulDivisors.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 module_M))))], NoZeroSMulDivisors.{u1, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (Submodule.instZeroSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M p) (Submodule.instSMulSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u1, u2} R R M _inst_1 _inst_2 module_M p (SMulZeroClass.toSMul.{u1, u1} R R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (SMulWithZero.toSMulZeroClass.{u1, u1} R R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (MulZeroClass.toSMulWithZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 module_M)))) (IsScalarTower.left.{u1, u2} R M (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (MulActionWithZero.toMulAction.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 module_M))))
Case conversion may be inaccurate. Consider using '#align submodule.no_zero_smul_divisors Submodule.noZeroSMulDivisorsₓ'. -/
instance noZeroSMulDivisors [NoZeroSMulDivisors R M] : NoZeroSMulDivisors R p :=
  ⟨fun c x h =>
    have : c = 0 ∨ (x : M) = 0 := eq_zero_or_eq_zero_of_smul_eq_zero (congr_arg coe h)
    this.imp_right (@Subtype.ext_iff _ _ x 0).mpr⟩
#align submodule.no_zero_smul_divisors Submodule.noZeroSMulDivisors

/- warning: submodule.subtype -> Submodule.subtype is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} (p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M), LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 module_M p) _inst_2 (Submodule.module.{u1, u2} R M _inst_1 _inst_2 module_M p) module_M
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} (p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M), LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) M (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M p) _inst_2 (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M p) module_M
Case conversion may be inaccurate. Consider using '#align submodule.subtype Submodule.subtypeₓ'. -/
/-- Embedding of a submodule `p` to the ambient space `M`. -/
protected def subtype : p →ₗ[R] M := by refine' { toFun := coe.. } <;> simp [coe_smul]
#align submodule.subtype Submodule.subtype

/- warning: submodule.subtype_apply -> Submodule.subtype_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} (p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p), Eq.{succ u2} M (coeFn.{succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 module_M p) _inst_2 (Submodule.module.{u1, u2} R M _inst_1 _inst_2 module_M p) module_M) (fun (_x : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 module_M p) _inst_2 (Submodule.module.{u1, u2} R M _inst_1 _inst_2 module_M p) module_M) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) -> M) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M _inst_1 _inst_1 (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 module_M p) _inst_2 (Submodule.module.{u1, u2} R M _inst_1 _inst_2 module_M p) module_M (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Submodule.subtype.{u1, u2} R M _inst_1 _inst_2 module_M p) x) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) x p))))) x)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} (p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (x : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) => M) x) (FunLike.coe.{succ u2, succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) M (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M p) _inst_2 (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M p) module_M) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) (fun (_x : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) => M) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} R R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) M _inst_1 _inst_1 (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M p) _inst_2 (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M p) module_M (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Submodule.subtype.{u1, u2} R M _inst_1 _inst_2 module_M p) x) (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M) p)) x)
Case conversion may be inaccurate. Consider using '#align submodule.subtype_apply Submodule.subtype_applyₓ'. -/
theorem subtype_apply (x : p) : p.Subtype x = x :=
  rfl
#align submodule.subtype_apply Submodule.subtype_apply

/- warning: submodule.coe_subtype -> Submodule.coeSubtype is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} (p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M), Eq.{succ u2} ((fun (_x : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 module_M p) _inst_2 (Submodule.module.{u1, u2} R M _inst_1 _inst_2 module_M p) module_M) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) -> M) (Submodule.subtype.{u1, u2} R M _inst_1 _inst_2 module_M p)) (coeFn.{succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 module_M p) _inst_2 (Submodule.module.{u1, u2} R M _inst_1 _inst_2 module_M p) module_M) (fun (_x : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 module_M p) _inst_2 (Submodule.module.{u1, u2} R M _inst_1 _inst_2 module_M p) module_M) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) -> M) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M _inst_1 _inst_1 (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 module_M p) _inst_2 (Submodule.module.{u1, u2} R M _inst_1 _inst_2 module_M p) module_M (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Submodule.subtype.{u1, u2} R M _inst_1 _inst_2 module_M p)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) x p))))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} (p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M), Eq.{succ u2} (forall (a : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) => M) a) (FunLike.coe.{succ u2, succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) M (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M p) _inst_2 (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M p) module_M) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) (fun (_x : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) => M) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} R R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) M _inst_1 _inst_1 (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M p) _inst_2 (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M p) module_M (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Submodule.subtype.{u1, u2} R M _inst_1 _inst_2 module_M p)) (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p))
Case conversion may be inaccurate. Consider using '#align submodule.coe_subtype Submodule.coeSubtypeₓ'. -/
@[simp]
theorem coeSubtype : (Submodule.subtype p : p → M) = coe :=
  rfl
#align submodule.coe_subtype Submodule.coeSubtype

/- warning: submodule.injective_subtype -> Submodule.injective_subtype is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} (p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M), Function.Injective.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (coeFn.{succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 module_M p) _inst_2 (Submodule.module.{u1, u2} R M _inst_1 _inst_2 module_M p) module_M) (fun (_x : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 module_M p) _inst_2 (Submodule.module.{u1, u2} R M _inst_1 _inst_2 module_M p) module_M) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) -> M) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M _inst_1 _inst_1 (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 module_M p) _inst_2 (Submodule.module.{u1, u2} R M _inst_1 _inst_2 module_M p) module_M (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Submodule.subtype.{u1, u2} R M _inst_1 _inst_2 module_M p))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} (p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M), Function.Injective.{succ u2, succ u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) M (FunLike.coe.{succ u2, succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) M (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M p) _inst_2 (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M p) module_M) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) (fun (_x : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) => M) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} R R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) M _inst_1 _inst_1 (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M p) _inst_2 (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M p) module_M (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Submodule.subtype.{u1, u2} R M _inst_1 _inst_2 module_M p))
Case conversion may be inaccurate. Consider using '#align submodule.injective_subtype Submodule.injective_subtypeₓ'. -/
theorem injective_subtype : Injective p.Subtype :=
  Subtype.coe_injective
#align submodule.injective_subtype Submodule.injective_subtype

/- warning: submodule.coe_sum -> Submodule.coe_sum is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {ι : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} (p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (x : ι -> (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p)) (s : Finset.{u3} ι), Eq.{succ u2} M ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) x p))))) (Finset.sum.{u2, u3} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) ι (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 module_M p) s (fun (i : ι) => x i))) (Finset.sum.{u2, u3} M ι _inst_2 s (fun (i : ι) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) p) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 module_M)) x p))))) (x i)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {ι : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} (p : Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (x : ι -> (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p))) (s : Finset.{u3} ι), Eq.{succ u2} M (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M) p)) (Finset.sum.{u2, u3} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M)) x p)) ι (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M p) s (fun (i : ι) => x i))) (Finset.sum.{u2, u3} M ι _inst_2 s (fun (i : ι) => Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M) p)) (x i)))
Case conversion may be inaccurate. Consider using '#align submodule.coe_sum Submodule.coe_sumₓ'. -/
/-- Note the `add_submonoid` version of this lemma is called `add_submonoid.coe_finset_sum`. -/
@[simp]
theorem coe_sum (x : ι → p) (s : Finset ι) : ↑(∑ i in s, x i) = ∑ i in s, (x i : M) :=
  map_sum p.Subtype _ _
#align submodule.coe_sum Submodule.coe_sum

section RestrictScalars

variable (S) [Semiring S] [Module S M] [Module R M] [SMul S R] [IsScalarTower S R M]

#print Submodule.restrictScalars /-
/-- `V.restrict_scalars S` is the `S`-submodule of the `S`-module given by restriction of scalars,
corresponding to `V`, an `R`-submodule of the original `R`-module.
-/
def restrictScalars (V : Submodule R M) : Submodule S M
    where
  carrier := V
  zero_mem' := V.zero_mem
  smul_mem' c m h := V.smul_of_tower_mem c h
  add_mem' x y hx hy := V.add_mem hx hy
#align submodule.restrict_scalars Submodule.restrictScalars
-/

/- warning: submodule.coe_restrict_scalars -> Submodule.coe_restrictScalars is a dubious translation:
lean 3 declaration is
  forall (S : Type.{u1}) {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Semiring.{u1} S] [_inst_4 : Module.{u1, u3} S M _inst_3 _inst_2] [_inst_5 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_6 : SMul.{u1, u2} S R] [_inst_7 : IsScalarTower.{u1, u2, u3} S R M _inst_6 (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_5)))) (SMulZeroClass.toHasSmul.{u1, u3} S M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u3} S M (MulZeroClass.toHasZero.{u1} S (MulZeroOneClass.toMulZeroClass.{u1} S (MonoidWithZero.toMulZeroOneClass.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_3)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} S M (Semiring.toMonoidWithZero.{u1} S _inst_3) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u1, u3} S M _inst_3 _inst_2 _inst_4))))] (V : Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5), Eq.{succ u3} (Set.{u3} M) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Submodule.{u1, u3} S M _inst_3 _inst_2 _inst_4) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (Submodule.{u1, u3} S M _inst_3 _inst_2 _inst_4) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (Submodule.{u1, u3} S M _inst_3 _inst_2 _inst_4) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (Submodule.{u1, u3} S M _inst_3 _inst_2 _inst_4) M (Submodule.setLike.{u1, u3} S M _inst_3 _inst_2 _inst_4)))) (Submodule.restrictScalars.{u1, u2, u3} S R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 V)) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5) M (Submodule.setLike.{u2, u3} R M _inst_1 _inst_2 _inst_5)))) V)
but is expected to have type
  forall (S : Type.{u1}) {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Semiring.{u1} S] [_inst_4 : Module.{u1, u3} S M _inst_3 _inst_2] [_inst_5 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_6 : SMul.{u1, u2} S R] [_inst_7 : IsScalarTower.{u1, u2, u3} S R M _inst_6 (SMulZeroClass.toSMul.{u2, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u3} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_5)))) (SMulZeroClass.toSMul.{u1, u3} S M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u3} S M (MonoidWithZero.toZero.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_3)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u3} S M (Semiring.toMonoidWithZero.{u1} S _inst_3) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u1, u3} S M _inst_3 _inst_2 _inst_4))))] (V : Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5), Eq.{succ u3} (Set.{u3} M) (SetLike.coe.{u3, u3} (Submodule.{u1, u3} S M _inst_3 _inst_2 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u3} S M _inst_3 _inst_2 _inst_4) (Submodule.restrictScalars.{u1, u2, u3} S R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 V)) (SetLike.coe.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5) M (Submodule.instSetLikeSubmodule.{u2, u3} R M _inst_1 _inst_2 _inst_5) V)
Case conversion may be inaccurate. Consider using '#align submodule.coe_restrict_scalars Submodule.coe_restrictScalarsₓ'. -/
@[simp]
theorem coe_restrictScalars (V : Submodule R M) : (V.restrictScalars S : Set M) = V :=
  rfl
#align submodule.coe_restrict_scalars Submodule.coe_restrictScalars

/- warning: submodule.restrict_scalars_mem -> Submodule.restrictScalars_mem is a dubious translation:
lean 3 declaration is
  forall (S : Type.{u1}) {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Semiring.{u1} S] [_inst_4 : Module.{u1, u3} S M _inst_3 _inst_2] [_inst_5 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_6 : SMul.{u1, u2} S R] [_inst_7 : IsScalarTower.{u1, u2, u3} S R M _inst_6 (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_5)))) (SMulZeroClass.toHasSmul.{u1, u3} S M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u3} S M (MulZeroClass.toHasZero.{u1} S (MulZeroOneClass.toMulZeroClass.{u1} S (MonoidWithZero.toMulZeroOneClass.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_3)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} S M (Semiring.toMonoidWithZero.{u1} S _inst_3) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u1, u3} S M _inst_3 _inst_2 _inst_4))))] (V : Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5) (m : M), Iff (Membership.Mem.{u3, u3} M (Submodule.{u1, u3} S M _inst_3 _inst_2 _inst_4) (SetLike.hasMem.{u3, u3} (Submodule.{u1, u3} S M _inst_3 _inst_2 _inst_4) M (Submodule.setLike.{u1, u3} S M _inst_3 _inst_2 _inst_4)) m (Submodule.restrictScalars.{u1, u2, u3} S R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 V)) (Membership.Mem.{u3, u3} M (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5) (SetLike.hasMem.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5) M (Submodule.setLike.{u2, u3} R M _inst_1 _inst_2 _inst_5)) m V)
but is expected to have type
  forall (S : Type.{u1}) {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Semiring.{u1} S] [_inst_4 : Module.{u1, u3} S M _inst_3 _inst_2] [_inst_5 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_6 : SMul.{u1, u2} S R] [_inst_7 : IsScalarTower.{u1, u2, u3} S R M _inst_6 (SMulZeroClass.toSMul.{u2, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u3} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_5)))) (SMulZeroClass.toSMul.{u1, u3} S M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u3} S M (MonoidWithZero.toZero.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_3)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u3} S M (Semiring.toMonoidWithZero.{u1} S _inst_3) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u1, u3} S M _inst_3 _inst_2 _inst_4))))] (V : Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5) (m : M), Iff (Membership.mem.{u3, u3} M (Submodule.{u1, u3} S M _inst_3 _inst_2 _inst_4) (SetLike.instMembership.{u3, u3} (Submodule.{u1, u3} S M _inst_3 _inst_2 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u3} S M _inst_3 _inst_2 _inst_4)) m (Submodule.restrictScalars.{u1, u2, u3} S R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 V)) (Membership.mem.{u3, u3} M (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5) M (Submodule.instSetLikeSubmodule.{u2, u3} R M _inst_1 _inst_2 _inst_5)) m V)
Case conversion may be inaccurate. Consider using '#align submodule.restrict_scalars_mem Submodule.restrictScalars_memₓ'. -/
@[simp]
theorem restrictScalars_mem (V : Submodule R M) (m : M) : m ∈ V.restrictScalars S ↔ m ∈ V :=
  Iff.refl _
#align submodule.restrict_scalars_mem Submodule.restrictScalars_mem

#print Submodule.restrictScalars_self /-
@[simp]
theorem restrictScalars_self (V : Submodule R M) : V.restrictScalars R = V :=
  SetLike.coe_injective rfl
#align submodule.restrict_scalars_self Submodule.restrictScalars_self
-/

variable (R S M)

#print Submodule.restrictScalars_injective /-
theorem restrictScalars_injective :
    Function.Injective (restrictScalars S : Submodule R M → Submodule S M) := fun V₁ V₂ h =>
  ext <| Set.ext_iff.1 (SetLike.ext'_iff.1 h : _)
#align submodule.restrict_scalars_injective Submodule.restrictScalars_injective
-/

#print Submodule.restrictScalars_inj /-
@[simp]
theorem restrictScalars_inj {V₁ V₂ : Submodule R M} :
    restrictScalars S V₁ = restrictScalars S V₂ ↔ V₁ = V₂ :=
  (restrictScalars_injective S _ _).eq_iff
#align submodule.restrict_scalars_inj Submodule.restrictScalars_inj
-/

/- warning: submodule.restrict_scalars.orig_module -> Submodule.restrictScalars.origModule is a dubious translation:
lean 3 declaration is
  forall (S : Type.{u1}) (R : Type.{u2}) (M : Type.{u3}) [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Semiring.{u1} S] [_inst_4 : Module.{u1, u3} S M _inst_3 _inst_2] [_inst_5 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_6 : SMul.{u1, u2} S R] [_inst_7 : IsScalarTower.{u1, u2, u3} S R M _inst_6 (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_5)))) (SMulZeroClass.toHasSmul.{u1, u3} S M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u3} S M (MulZeroClass.toHasZero.{u1} S (MulZeroOneClass.toMulZeroClass.{u1} S (MonoidWithZero.toMulZeroOneClass.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_3)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} S M (Semiring.toMonoidWithZero.{u1} S _inst_3) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u1, u3} S M _inst_3 _inst_2 _inst_4))))] (p : Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5), Module.{u2, u3} R (coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} S M _inst_3 _inst_2 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} S M _inst_3 _inst_2 _inst_4) M (Submodule.setLike.{u1, u3} S M _inst_3 _inst_2 _inst_4)) (Submodule.restrictScalars.{u1, u2, u3} S R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 p)) _inst_1 (Submodule.addCommMonoid.{u1, u3} S M _inst_3 _inst_2 _inst_4 (Submodule.restrictScalars.{u1, u2, u3} S R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 p))
but is expected to have type
  forall (S : Type.{u1}) (R : Type.{u2}) (M : Type.{u3}) [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Semiring.{u1} S] [_inst_4 : Module.{u1, u3} S M _inst_3 _inst_2] [_inst_5 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_6 : SMul.{u1, u2} S R] [_inst_7 : IsScalarTower.{u1, u2, u3} S R M _inst_6 (SMulZeroClass.toSMul.{u2, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u3} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_5)))) (SMulZeroClass.toSMul.{u1, u3} S M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u3} S M (MonoidWithZero.toZero.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_3)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u3} S M (Semiring.toMonoidWithZero.{u1} S _inst_3) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u1, u3} S M _inst_3 _inst_2 _inst_4))))] (p : Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5), Module.{u2, u3} R (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (Submodule.{u1, u3} S M _inst_3 _inst_2 _inst_4) (SetLike.instMembership.{u3, u3} (Submodule.{u1, u3} S M _inst_3 _inst_2 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u3} S M _inst_3 _inst_2 _inst_4)) x (Submodule.restrictScalars.{u1, u2, u3} S R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 p))) _inst_1 (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u3} S M _inst_3 _inst_2 _inst_4 (Submodule.restrictScalars.{u1, u2, u3} S R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 p))
Case conversion may be inaccurate. Consider using '#align submodule.restrict_scalars.orig_module Submodule.restrictScalars.origModuleₓ'. -/
/-- Even though `p.restrict_scalars S` has type `submodule S M`, it is still an `R`-module. -/
instance restrictScalars.origModule (p : Submodule R M) : Module R (p.restrictScalars S) :=
  (by infer_instance : Module R p)
#align submodule.restrict_scalars.orig_module Submodule.restrictScalars.origModule

instance (p : Submodule R M) : IsScalarTower S R (p.restrictScalars S)
    where smul_assoc r s x := Subtype.ext <| smul_assoc r s (x : M)

/- warning: submodule.restrict_scalars_embedding -> Submodule.restrictScalarsEmbedding is a dubious translation:
lean 3 declaration is
  forall (S : Type.{u1}) (R : Type.{u2}) (M : Type.{u3}) [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Semiring.{u1} S] [_inst_4 : Module.{u1, u3} S M _inst_3 _inst_2] [_inst_5 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_6 : SMul.{u1, u2} S R] [_inst_7 : IsScalarTower.{u1, u2, u3} S R M _inst_6 (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_5)))) (SMulZeroClass.toHasSmul.{u1, u3} S M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u3} S M (MulZeroClass.toHasZero.{u1} S (MulZeroOneClass.toMulZeroClass.{u1} S (MonoidWithZero.toMulZeroOneClass.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_3)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} S M (Semiring.toMonoidWithZero.{u1} S _inst_3) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u1, u3} S M _inst_3 _inst_2 _inst_4))))], OrderEmbedding.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5) (Submodule.{u1, u3} S M _inst_3 _inst_2 _inst_4) (Preorder.toLE.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5) (PartialOrder.toPreorder.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5) (SetLike.partialOrder.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5) M (Submodule.setLike.{u2, u3} R M _inst_1 _inst_2 _inst_5)))) (Preorder.toLE.{u3} (Submodule.{u1, u3} S M _inst_3 _inst_2 _inst_4) (PartialOrder.toPreorder.{u3} (Submodule.{u1, u3} S M _inst_3 _inst_2 _inst_4) (SetLike.partialOrder.{u3, u3} (Submodule.{u1, u3} S M _inst_3 _inst_2 _inst_4) M (Submodule.setLike.{u1, u3} S M _inst_3 _inst_2 _inst_4))))
but is expected to have type
  forall (S : Type.{u1}) (R : Type.{u2}) (M : Type.{u3}) [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Semiring.{u1} S] [_inst_4 : Module.{u1, u3} S M _inst_3 _inst_2] [_inst_5 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_6 : SMul.{u1, u2} S R] [_inst_7 : IsScalarTower.{u1, u2, u3} S R M _inst_6 (SMulZeroClass.toSMul.{u2, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u3} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_5)))) (SMulZeroClass.toSMul.{u1, u3} S M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u3} S M (MonoidWithZero.toZero.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_3)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u3} S M (Semiring.toMonoidWithZero.{u1} S _inst_3) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u1, u3} S M _inst_3 _inst_2 _inst_4))))], OrderEmbedding.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5) (Submodule.{u1, u3} S M _inst_3 _inst_2 _inst_4) (Preorder.toLE.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5) (PartialOrder.toPreorder.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5) (SetLike.instPartialOrder.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5) M (Submodule.instSetLikeSubmodule.{u2, u3} R M _inst_1 _inst_2 _inst_5)))) (Preorder.toLE.{u3} (Submodule.{u1, u3} S M _inst_3 _inst_2 _inst_4) (PartialOrder.toPreorder.{u3} (Submodule.{u1, u3} S M _inst_3 _inst_2 _inst_4) (SetLike.instPartialOrder.{u3, u3} (Submodule.{u1, u3} S M _inst_3 _inst_2 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u3} S M _inst_3 _inst_2 _inst_4))))
Case conversion may be inaccurate. Consider using '#align submodule.restrict_scalars_embedding Submodule.restrictScalarsEmbeddingₓ'. -/
/-- `restrict_scalars S` is an embedding of the lattice of `R`-submodules into
the lattice of `S`-submodules. -/
@[simps]
def restrictScalarsEmbedding : Submodule R M ↪o Submodule S M
    where
  toFun := restrictScalars S
  inj' := restrictScalars_injective S R M
  map_rel_iff' p q := by simp [SetLike.le_def]
#align submodule.restrict_scalars_embedding Submodule.restrictScalarsEmbedding

/- warning: submodule.restrict_scalars_equiv -> Submodule.restrictScalarsEquiv is a dubious translation:
lean 3 declaration is
  forall (S : Type.{u1}) (R : Type.{u2}) (M : Type.{u3}) [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Semiring.{u1} S] [_inst_4 : Module.{u1, u3} S M _inst_3 _inst_2] [_inst_5 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_6 : SMul.{u1, u2} S R] [_inst_7 : IsScalarTower.{u1, u2, u3} S R M _inst_6 (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_5)))) (SMulZeroClass.toHasSmul.{u1, u3} S M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u3} S M (MulZeroClass.toHasZero.{u1} S (MulZeroOneClass.toMulZeroClass.{u1} S (MonoidWithZero.toMulZeroOneClass.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_3)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} S M (Semiring.toMonoidWithZero.{u1} S _inst_3) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u1, u3} S M _inst_3 _inst_2 _inst_4))))] (p : Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5), LinearEquiv.{u2, u2, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} S M _inst_3 _inst_2 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} S M _inst_3 _inst_2 _inst_4) M (Submodule.setLike.{u1, u3} S M _inst_3 _inst_2 _inst_4)) (Submodule.restrictScalars.{u1, u2, u3} S R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 p)) (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5) M (Submodule.setLike.{u2, u3} R M _inst_1 _inst_2 _inst_5)) p) (Submodule.addCommMonoid.{u1, u3} S M _inst_3 _inst_2 _inst_4 (Submodule.restrictScalars.{u1, u2, u3} S R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 p)) (Submodule.addCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_5 p) (Submodule.restrictScalars.origModule.{u1, u2, u3} S R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 p) (Submodule.module.{u2, u3} R M _inst_1 _inst_2 _inst_5 p)
but is expected to have type
  forall (S : Type.{u1}) (R : Type.{u2}) (M : Type.{u3}) [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Semiring.{u1} S] [_inst_4 : Module.{u1, u3} S M _inst_3 _inst_2] [_inst_5 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_6 : SMul.{u1, u2} S R] [_inst_7 : IsScalarTower.{u1, u2, u3} S R M _inst_6 (SMulZeroClass.toSMul.{u2, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u3} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_5)))) (SMulZeroClass.toSMul.{u1, u3} S M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u3} S M (MonoidWithZero.toZero.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_3)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u3} S M (Semiring.toMonoidWithZero.{u1} S _inst_3) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u1, u3} S M _inst_3 _inst_2 _inst_4))))] (p : Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5), LinearEquiv.{u2, u2, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (Submodule.{u1, u3} S M _inst_3 _inst_2 _inst_4) (SetLike.instMembership.{u3, u3} (Submodule.{u1, u3} S M _inst_3 _inst_2 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u3} S M _inst_3 _inst_2 _inst_4)) x (Submodule.restrictScalars.{u1, u2, u3} S R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 p))) (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5) M (Submodule.instSetLikeSubmodule.{u2, u3} R M _inst_1 _inst_2 _inst_5)) x p)) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u3} S M _inst_3 _inst_2 _inst_4 (Submodule.restrictScalars.{u1, u2, u3} S R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 p)) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u2, u3} R M _inst_1 _inst_2 _inst_5 p) (Submodule.restrictScalars.origModule.{u1, u2, u3} S R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 p) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u2, u3} R M _inst_1 _inst_2 _inst_5 p)
Case conversion may be inaccurate. Consider using '#align submodule.restrict_scalars_equiv Submodule.restrictScalarsEquivₓ'. -/
/-- Turning `p : submodule R M` into an `S`-submodule gives the same module structure
as turning it into a type and adding a module structure. -/
@[simps (config := { simpRhs := true })]
def restrictScalarsEquiv (p : Submodule R M) : p.restrictScalars S ≃ₗ[R] p :=
  { AddEquiv.refl p with
    toFun := id
    invFun := id
    map_smul' := fun c x => rfl }
#align submodule.restrict_scalars_equiv Submodule.restrictScalarsEquiv

end RestrictScalars

end AddCommMonoid

section AddCommGroup

variable [Ring R] [AddCommGroup M]

variable {module_M : Module R M}

variable (p p' : Submodule R M)

variable {r : R} {x y : M}

instance [Module R M] : AddSubgroupClass (Submodule R M) M :=
  { Submodule.addSubmonoidClass with neg_mem := fun p x => p.toSubMulAction.neg_mem }

/- warning: submodule.neg_mem -> Submodule.neg_mem is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] {module_M : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)} (p : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) {x : M}, (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) x p) -> (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) (Neg.neg.{u2} M (SubNegMonoid.toHasNeg.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))) x) p)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] {module_M : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)} (p : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) {x : M}, (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) x p) -> (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) (Neg.neg.{u2} M (NegZeroClass.toNeg.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) x) p)
Case conversion may be inaccurate. Consider using '#align submodule.neg_mem Submodule.neg_memₓ'. -/
protected theorem neg_mem (hx : x ∈ p) : -x ∈ p :=
  neg_mem hx
#align submodule.neg_mem Submodule.neg_mem

#print Submodule.toAddSubgroup /-
/-- Reinterpret a submodule as an additive subgroup. -/
def toAddSubgroup : AddSubgroup M :=
  { p.toAddSubmonoid with neg_mem' := fun _ => p.neg_mem }
#align submodule.to_add_subgroup Submodule.toAddSubgroup
-/

/- warning: submodule.coe_to_add_subgroup -> Submodule.coe_toAddSubgroup is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] {module_M : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)} (p : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M), Eq.{succ u2} (Set.{u2} M) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) M (AddSubgroup.setLike.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))))) (Submodule.toAddSubgroup.{u1, u2} R M _inst_1 _inst_2 module_M p)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)))) p)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] {module_M : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)} (p : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M), Eq.{succ u2} (Set.{u2} M) (SetLike.coe.{u2, u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) M (AddSubgroup.instSetLikeAddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (Submodule.toAddSubgroup.{u1, u2} R M _inst_1 _inst_2 module_M p)) (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) p)
Case conversion may be inaccurate. Consider using '#align submodule.coe_to_add_subgroup Submodule.coe_toAddSubgroupₓ'. -/
@[simp]
theorem coe_toAddSubgroup : (p.toAddSubgroup : Set M) = p :=
  rfl
#align submodule.coe_to_add_subgroup Submodule.coe_toAddSubgroup

/- warning: submodule.mem_to_add_subgroup -> Submodule.mem_toAddSubgroup is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] {module_M : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)} (p : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) {x : M}, Iff (Membership.Mem.{u2, u2} M (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (SetLike.hasMem.{u2, u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) M (AddSubgroup.setLike.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))) x (Submodule.toAddSubgroup.{u1, u2} R M _inst_1 _inst_2 module_M p)) (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) x p)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] {module_M : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)} (p : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) {x : M}, Iff (Membership.mem.{u2, u2} M (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) M (AddSubgroup.instSetLikeAddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))) x (Submodule.toAddSubgroup.{u1, u2} R M _inst_1 _inst_2 module_M p)) (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) x p)
Case conversion may be inaccurate. Consider using '#align submodule.mem_to_add_subgroup Submodule.mem_toAddSubgroupₓ'. -/
@[simp]
theorem mem_toAddSubgroup : x ∈ p.toAddSubgroup ↔ x ∈ p :=
  Iff.rfl
#align submodule.mem_to_add_subgroup Submodule.mem_toAddSubgroup

include module_M

#print Submodule.toAddSubgroup_injective /-
theorem toAddSubgroup_injective : Injective (toAddSubgroup : Submodule R M → AddSubgroup M)
  | p, q, h => SetLike.ext (SetLike.ext_iff.1 h : _)
#align submodule.to_add_subgroup_injective Submodule.toAddSubgroup_injective
-/

#print Submodule.toAddSubgroup_eq /-
@[simp]
theorem toAddSubgroup_eq : p.toAddSubgroup = p'.toAddSubgroup ↔ p = p' :=
  toAddSubgroup_injective.eq_iff
#align submodule.to_add_subgroup_eq Submodule.toAddSubgroup_eq
-/

/- warning: submodule.to_add_subgroup_strict_mono -> Submodule.toAddSubgroup_strictMono is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] {module_M : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)}, StrictMono.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M))) (PartialOrder.toPreorder.{u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (CompleteSemilatticeInf.toPartialOrder.{u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (AddSubgroup.completeLattice.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))))) (Submodule.toAddSubgroup.{u1, u2} R M _inst_1 _inst_2 module_M)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] {module_M : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)}, StrictMono.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.instPartialOrder.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M))) (PartialOrder.toPreorder.{u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (CompleteSemilatticeInf.toPartialOrder.{u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (AddSubgroup.instCompleteLatticeAddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))))) (Submodule.toAddSubgroup.{u1, u2} R M _inst_1 _inst_2 module_M)
Case conversion may be inaccurate. Consider using '#align submodule.to_add_subgroup_strict_mono Submodule.toAddSubgroup_strictMonoₓ'. -/
@[mono]
theorem toAddSubgroup_strictMono : StrictMono (toAddSubgroup : Submodule R M → AddSubgroup M) :=
  fun _ _ => id
#align submodule.to_add_subgroup_strict_mono Submodule.toAddSubgroup_strictMono

/- warning: submodule.to_add_subgroup_le -> Submodule.toAddSubgroup_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] {module_M : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)} (p : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (p' : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M), Iff (LE.le.{u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (Preorder.toLE.{u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (PartialOrder.toPreorder.{u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (CompleteSemilatticeInf.toPartialOrder.{u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (AddSubgroup.completeLattice.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))))) (Submodule.toAddSubgroup.{u1, u2} R M _inst_1 _inst_2 module_M p) (Submodule.toAddSubgroup.{u1, u2} R M _inst_1 _inst_2 module_M p')) (LE.le.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)))) p p')
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] {module_M : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)} (p : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (p' : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M), Iff (LE.le.{u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (Preorder.toLE.{u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (PartialOrder.toPreorder.{u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (CompleteSemilatticeInf.toPartialOrder.{u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (AddSubgroup.instCompleteLatticeAddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))))) (Submodule.toAddSubgroup.{u1, u2} R M _inst_1 _inst_2 module_M p) (Submodule.toAddSubgroup.{u1, u2} R M _inst_1 _inst_2 module_M p')) (LE.le.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.instPartialOrder.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)))) p p')
Case conversion may be inaccurate. Consider using '#align submodule.to_add_subgroup_le Submodule.toAddSubgroup_leₓ'. -/
theorem toAddSubgroup_le : p.toAddSubgroup ≤ p'.toAddSubgroup ↔ p ≤ p' :=
  Iff.rfl
#align submodule.to_add_subgroup_le Submodule.toAddSubgroup_le

/- warning: submodule.to_add_subgroup_mono -> Submodule.toAddSubgroup_mono is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] {module_M : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)}, Monotone.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M))) (PartialOrder.toPreorder.{u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (CompleteSemilatticeInf.toPartialOrder.{u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (AddSubgroup.completeLattice.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))))) (Submodule.toAddSubgroup.{u1, u2} R M _inst_1 _inst_2 module_M)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] {module_M : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)}, Monotone.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.instPartialOrder.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M))) (PartialOrder.toPreorder.{u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (CompleteSemilatticeInf.toPartialOrder.{u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (AddSubgroup.instCompleteLatticeAddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))))) (Submodule.toAddSubgroup.{u1, u2} R M _inst_1 _inst_2 module_M)
Case conversion may be inaccurate. Consider using '#align submodule.to_add_subgroup_mono Submodule.toAddSubgroup_monoₓ'. -/
@[mono]
theorem toAddSubgroup_mono : Monotone (toAddSubgroup : Submodule R M → AddSubgroup M) :=
  toAddSubgroup_strictMono.Monotone
#align submodule.to_add_subgroup_mono Submodule.toAddSubgroup_mono

omit module_M

/- warning: submodule.sub_mem -> Submodule.sub_mem is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] {module_M : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)} (p : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) {x : M} {y : M}, (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) x p) -> (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) y p) -> (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) (HSub.hSub.{u2, u2, u2} M M M (instHSub.{u2} M (SubNegMonoid.toHasSub.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))) x y) p)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] {module_M : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)} (p : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) {x : M} {y : M}, (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) x p) -> (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) y p) -> (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) (HSub.hSub.{u2, u2, u2} M M M (instHSub.{u2} M (SubNegMonoid.toSub.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))) x y) p)
Case conversion may be inaccurate. Consider using '#align submodule.sub_mem Submodule.sub_memₓ'. -/
protected theorem sub_mem : x ∈ p → y ∈ p → x - y ∈ p :=
  sub_mem
#align submodule.sub_mem Submodule.sub_mem

/- warning: submodule.neg_mem_iff -> Submodule.neg_mem_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] {module_M : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)} (p : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) {x : M}, Iff (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) (Neg.neg.{u2} M (SubNegMonoid.toHasNeg.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))) x) p) (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) x p)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] {module_M : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)} (p : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) {x : M}, Iff (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) (Neg.neg.{u2} M (NegZeroClass.toNeg.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) x) p) (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) x p)
Case conversion may be inaccurate. Consider using '#align submodule.neg_mem_iff Submodule.neg_mem_iffₓ'. -/
protected theorem neg_mem_iff : -x ∈ p ↔ x ∈ p :=
  neg_mem_iff
#align submodule.neg_mem_iff Submodule.neg_mem_iff

/- warning: submodule.add_mem_iff_left -> Submodule.add_mem_iff_left is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] {module_M : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)} (p : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) {x : M} {y : M}, (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) y p) -> (Iff (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))))) x y) p) (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) x p))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] {module_M : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)} (p : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) {x : M} {y : M}, (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) y p) -> (Iff (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))))) x y) p) (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) x p))
Case conversion may be inaccurate. Consider using '#align submodule.add_mem_iff_left Submodule.add_mem_iff_leftₓ'. -/
protected theorem add_mem_iff_left : y ∈ p → (x + y ∈ p ↔ x ∈ p) :=
  add_mem_cancel_right
#align submodule.add_mem_iff_left Submodule.add_mem_iff_left

/- warning: submodule.add_mem_iff_right -> Submodule.add_mem_iff_right is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] {module_M : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)} (p : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) {x : M} {y : M}, (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) x p) -> (Iff (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))))) x y) p) (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) y p))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] {module_M : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)} (p : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) {x : M} {y : M}, (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) x p) -> (Iff (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))))) x y) p) (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) y p))
Case conversion may be inaccurate. Consider using '#align submodule.add_mem_iff_right Submodule.add_mem_iff_rightₓ'. -/
protected theorem add_mem_iff_right : x ∈ p → (x + y ∈ p ↔ y ∈ p) :=
  add_mem_cancel_left
#align submodule.add_mem_iff_right Submodule.add_mem_iff_right

/- warning: submodule.coe_neg -> Submodule.coe_neg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] {module_M : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)} (p : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) p), Eq.{succ u2} M ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) p) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) p) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) p) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) p) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) x p))))) (Neg.neg.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) p) (AddSubgroupClass.neg.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (Submodule.addSubgroupClass.{u1, u2} R M _inst_1 _inst_2 module_M) p) x)) (Neg.neg.{u2} M (SubNegMonoid.toHasNeg.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) p) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) p) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) p) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) p) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) x p))))) x))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] {module_M : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)} (p : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (x : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) x p)), Eq.{succ u2} M (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) p)) (Neg.neg.{u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) x p)) (AddSubgroupClass.neg.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (Submodule.instAddSubgroupClassSubmoduleToSemiringToAddCommMonoidToSubNegMonoidToAddGroupInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M) p) x)) (Neg.neg.{u2} M (NegZeroClass.toNeg.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) p)) x))
Case conversion may be inaccurate. Consider using '#align submodule.coe_neg Submodule.coe_negₓ'. -/
protected theorem coe_neg (x : p) : ((-x : p) : M) = -x :=
  AddSubgroupClass.coe_neg _
#align submodule.coe_neg Submodule.coe_neg

/- warning: submodule.coe_sub -> Submodule.coe_sub is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] {module_M : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)} (p : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) p) (y : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) p), Eq.{succ u2} M ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) p) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) p) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) p) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) p) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) x p))))) (HSub.hSub.{u2, u2, u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) p) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) p) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) p) (instHSub.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) p) (AddSubgroupClass.sub.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (Submodule.addSubgroupClass.{u1, u2} R M _inst_1 _inst_2 module_M) p)) x y)) (HSub.hSub.{u2, u2, u2} M M M (instHSub.{u2} M (SubNegMonoid.toHasSub.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) p) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) p) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) p) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) p) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) x p))))) x) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) p) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) p) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) p) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) p) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) x p))))) y))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] {module_M : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)} (p : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (x : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) x p)) (y : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) x p)), Eq.{succ u2} M (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) p)) (HSub.hSub.{u2, u2, u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) x p)) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) x p)) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) x p)) (instHSub.{u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) x p)) (AddSubgroupClass.sub.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (Submodule.instAddSubgroupClassSubmoduleToSemiringToAddCommMonoidToSubNegMonoidToAddGroupInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 module_M) p)) x y)) (HSub.hSub.{u2, u2, u2} M M M (instHSub.{u2} M (SubNegMonoid.toSub.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))) (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) p)) x) (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) p)) y))
Case conversion may be inaccurate. Consider using '#align submodule.coe_sub Submodule.coe_subₓ'. -/
protected theorem coe_sub (x y : p) : (↑(x - y) : M) = ↑x - ↑y :=
  AddSubgroupClass.coe_sub _ _
#align submodule.coe_sub Submodule.coe_sub

/- warning: submodule.sub_mem_iff_left -> Submodule.sub_mem_iff_left is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] {module_M : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)} (p : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) {x : M} {y : M}, (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) y p) -> (Iff (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) (HSub.hSub.{u2, u2, u2} M M M (instHSub.{u2} M (SubNegMonoid.toHasSub.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))) x y) p) (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) x p))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] {module_M : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)} (p : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) {x : M} {y : M}, (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) y p) -> (Iff (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) (HSub.hSub.{u2, u2, u2} M M M (instHSub.{u2} M (SubNegMonoid.toSub.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))) x y) p) (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) x p))
Case conversion may be inaccurate. Consider using '#align submodule.sub_mem_iff_left Submodule.sub_mem_iff_leftₓ'. -/
theorem sub_mem_iff_left (hy : y ∈ p) : x - y ∈ p ↔ x ∈ p := by
  rw [sub_eq_add_neg, p.add_mem_iff_left (p.neg_mem hy)]
#align submodule.sub_mem_iff_left Submodule.sub_mem_iff_left

/- warning: submodule.sub_mem_iff_right -> Submodule.sub_mem_iff_right is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] {module_M : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)} (p : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) {x : M} {y : M}, (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) x p) -> (Iff (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) (HSub.hSub.{u2, u2, u2} M M M (instHSub.{u2} M (SubNegMonoid.toHasSub.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))) x y) p) (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) y p))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] {module_M : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)} (p : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) {x : M} {y : M}, (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) x p) -> (Iff (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) (HSub.hSub.{u2, u2, u2} M M M (instHSub.{u2} M (SubNegMonoid.toSub.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))) x y) p) (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) module_M)) y p))
Case conversion may be inaccurate. Consider using '#align submodule.sub_mem_iff_right Submodule.sub_mem_iff_rightₓ'. -/
theorem sub_mem_iff_right (hx : x ∈ p) : x - y ∈ p ↔ y ∈ p := by
  rw [sub_eq_add_neg, p.add_mem_iff_right hx, p.neg_mem_iff]
#align submodule.sub_mem_iff_right Submodule.sub_mem_iff_right

instance : AddCommGroup p :=
  { p.toAddSubgroup.toAddCommGroup with
    add := (· + ·)
    zero := 0
    neg := Neg.neg }

end AddCommGroup

section IsDomain

variable [Ring R] [IsDomain R]

variable [AddCommGroup M] [Module R M] {b : ι → M}

/- warning: submodule.not_mem_of_ortho -> Submodule.not_mem_of_ortho is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R _inst_1)] [_inst_3 : AddCommGroup.{u2} M] [_inst_4 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)] {x : M} {N : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4}, (forall (c : R) (y : M), (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4)) y N) -> (Eq.{succ u2} M (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_3)))))) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4)))) c x) y) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_3))))))))) -> (Eq.{succ u1} R c (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))))))))) -> (Not (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4)) x N))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R _inst_1)] [_inst_3 : AddCommGroup.{u2} M] [_inst_4 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)] {x : M} {N : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4}, (forall (c : R) (y : M), (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4)) y N) -> (Eq.{succ u2} M (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_3)))))) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_3))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_3))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_3))))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4))))) c x) y) (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_3)))))))) -> (Eq.{succ u1} R c (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))))) -> (Not (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4)) x N))
Case conversion may be inaccurate. Consider using '#align submodule.not_mem_of_ortho Submodule.not_mem_of_orthoₓ'. -/
theorem not_mem_of_ortho {x : M} {N : Submodule R M}
    (ortho : ∀ (c : R), ∀ y ∈ N, c • x + y = (0 : M) → c = 0) : x ∉ N :=
  by
  intro hx
  simpa using ortho (-1) x hx
#align submodule.not_mem_of_ortho Submodule.not_mem_of_ortho

/- warning: submodule.ne_zero_of_ortho -> Submodule.ne_zero_of_ortho is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R _inst_1)] [_inst_3 : AddCommGroup.{u2} M] [_inst_4 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)] {x : M} {N : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4}, (forall (c : R) (y : M), (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4)) y N) -> (Eq.{succ u2} M (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_3)))))) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4)))) c x) y) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_3))))))))) -> (Eq.{succ u1} R c (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))))))))) -> (Ne.{succ u2} M x (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_3)))))))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R _inst_1)] [_inst_3 : AddCommGroup.{u2} M] [_inst_4 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)] {x : M} {N : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4}, (forall (c : R) (y : M), (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4)) y N) -> (Eq.{succ u2} M (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_3)))))) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_3))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_3))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_3))))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4))))) c x) y) (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_3)))))))) -> (Eq.{succ u1} R c (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))))) -> (Ne.{succ u2} M x (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_3))))))))
Case conversion may be inaccurate. Consider using '#align submodule.ne_zero_of_ortho Submodule.ne_zero_of_orthoₓ'. -/
theorem ne_zero_of_ortho {x : M} {N : Submodule R M}
    (ortho : ∀ (c : R), ∀ y ∈ N, c • x + y = (0 : M) → c = 0) : x ≠ 0 :=
  mt (fun h => show x ∈ N from h.symm ▸ N.zero_mem) (not_mem_of_ortho ortho)
#align submodule.ne_zero_of_ortho Submodule.ne_zero_of_ortho

end IsDomain

section OrderedMonoid

variable [Semiring R]

/- warning: submodule.to_ordered_add_comm_monoid -> Submodule.toOrderedAddCommMonoid is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {M : Type.{u2}} [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)] (S : Submodule.{u1, u2} R M _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2) _inst_3), OrderedAddCommMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2) _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2) _inst_3)) S)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {M : Type.{u2}} [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)] (S : Submodule.{u1, u2} R M _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2) _inst_3), OrderedAddCommMonoid.{u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2) _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2) _inst_3)) x S))
Case conversion may be inaccurate. Consider using '#align submodule.to_ordered_add_comm_monoid Submodule.toOrderedAddCommMonoidₓ'. -/
/-- A submodule of an `ordered_add_comm_monoid` is an `ordered_add_comm_monoid`. -/
instance toOrderedAddCommMonoid {M} [OrderedAddCommMonoid M] [Module R M] (S : Submodule R M) :
    OrderedAddCommMonoid S :=
  Subtype.coe_injective.OrderedAddCommMonoid coe rfl (fun _ _ => rfl) fun _ _ => rfl
#align submodule.to_ordered_add_comm_monoid Submodule.toOrderedAddCommMonoid

/- warning: submodule.to_linear_ordered_add_comm_monoid -> Submodule.toLinearOrderedAddCommMonoid is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {M : Type.{u2}} [_inst_2 : LinearOrderedAddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} M (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} M _inst_2))] (S : Submodule.{u1, u2} R M _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} M (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} M _inst_2)) _inst_3), LinearOrderedAddCommMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} M (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} M _inst_2)) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} M (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} M _inst_2)) _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} M (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} M _inst_2)) _inst_3)) S)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {M : Type.{u2}} [_inst_2 : LinearOrderedAddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)] (S : Submodule.{u1, u2} R M _inst_1 (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2) _inst_3), LinearOrderedAddCommMonoid.{u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2) _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2) _inst_3)) x S))
Case conversion may be inaccurate. Consider using '#align submodule.to_linear_ordered_add_comm_monoid Submodule.toLinearOrderedAddCommMonoidₓ'. -/
/-- A submodule of a `linear_ordered_add_comm_monoid` is a `linear_ordered_add_comm_monoid`. -/
instance toLinearOrderedAddCommMonoid {M} [LinearOrderedAddCommMonoid M] [Module R M]
    (S : Submodule R M) : LinearOrderedAddCommMonoid S :=
  Subtype.coe_injective.LinearOrderedAddCommMonoid coe rfl (fun _ _ => rfl) (fun _ _ => rfl)
    (fun _ _ => rfl) fun _ _ => rfl
#align submodule.to_linear_ordered_add_comm_monoid Submodule.toLinearOrderedAddCommMonoid

/- warning: submodule.to_ordered_cancel_add_comm_monoid -> Submodule.toOrderedCancelAddCommMonoid is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {M : Type.{u2}} [_inst_2 : OrderedCancelAddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)] (S : Submodule.{u1, u2} R M _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} M _inst_2) _inst_3), OrderedCancelAddCommMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} M _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} M _inst_2) _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} M _inst_2) _inst_3)) S)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {M : Type.{u2}} [_inst_2 : OrderedCancelAddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)] (S : Submodule.{u1, u2} R M _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} M _inst_2) _inst_3), OrderedCancelAddCommMonoid.{u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} M _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} M _inst_2) _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} M _inst_2) _inst_3)) x S))
Case conversion may be inaccurate. Consider using '#align submodule.to_ordered_cancel_add_comm_monoid Submodule.toOrderedCancelAddCommMonoidₓ'. -/
/-- A submodule of an `ordered_cancel_add_comm_monoid` is an `ordered_cancel_add_comm_monoid`. -/
instance toOrderedCancelAddCommMonoid {M} [OrderedCancelAddCommMonoid M] [Module R M]
    (S : Submodule R M) : OrderedCancelAddCommMonoid S :=
  Subtype.coe_injective.OrderedCancelAddCommMonoid coe rfl (fun _ _ => rfl) fun _ _ => rfl
#align submodule.to_ordered_cancel_add_comm_monoid Submodule.toOrderedCancelAddCommMonoid

/- warning: submodule.to_linear_ordered_cancel_add_comm_monoid -> Submodule.toLinearOrderedCancelAddCommMonoid is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {M : Type.{u2}} [_inst_2 : LinearOrderedCancelAddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} M (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u2} M _inst_2))] (S : Submodule.{u1, u2} R M _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} M (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u2} M _inst_2)) _inst_3), LinearOrderedCancelAddCommMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} M (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u2} M _inst_2)) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} M (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u2} M _inst_2)) _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} M (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u2} M _inst_2)) _inst_3)) S)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {M : Type.{u2}} [_inst_2 : LinearOrderedCancelAddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} M (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u2} M _inst_2))] (S : Submodule.{u1, u2} R M _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} M (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u2} M _inst_2)) _inst_3), LinearOrderedCancelAddCommMonoid.{u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} M (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u2} M _inst_2)) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} M (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u2} M _inst_2)) _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} M (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u2} M _inst_2)) _inst_3)) x S))
Case conversion may be inaccurate. Consider using '#align submodule.to_linear_ordered_cancel_add_comm_monoid Submodule.toLinearOrderedCancelAddCommMonoidₓ'. -/
/-- A submodule of a `linear_ordered_cancel_add_comm_monoid` is a
`linear_ordered_cancel_add_comm_monoid`. -/
instance toLinearOrderedCancelAddCommMonoid {M} [LinearOrderedCancelAddCommMonoid M] [Module R M]
    (S : Submodule R M) : LinearOrderedCancelAddCommMonoid S :=
  Subtype.coe_injective.LinearOrderedCancelAddCommMonoid coe rfl (fun _ _ => rfl) (fun _ _ => rfl)
    (fun _ _ => rfl) fun _ _ => rfl
#align submodule.to_linear_ordered_cancel_add_comm_monoid Submodule.toLinearOrderedCancelAddCommMonoid

end OrderedMonoid

section OrderedGroup

variable [Ring R]

/- warning: submodule.to_ordered_add_comm_group -> Submodule.toOrderedAddCommGroup is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {M : Type.{u2}} [_inst_2 : OrderedAddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M (OrderedAddCommGroup.toAddCommGroup.{u2} M _inst_2))] (S : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M (OrderedAddCommGroup.toAddCommGroup.{u2} M _inst_2)) _inst_3), OrderedAddCommGroup.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M (OrderedAddCommGroup.toAddCommGroup.{u2} M _inst_2)) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M (OrderedAddCommGroup.toAddCommGroup.{u2} M _inst_2)) _inst_3) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M (OrderedAddCommGroup.toAddCommGroup.{u2} M _inst_2)) _inst_3)) S)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {M : Type.{u2}} [_inst_2 : OrderedAddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} M (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u2} M _inst_2))] (S : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} M (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u2} M _inst_2)) _inst_3), OrderedAddCommGroup.{u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} M (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u2} M _inst_2)) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} M (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u2} M _inst_2)) _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} M (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u2} M _inst_2)) _inst_3)) x S))
Case conversion may be inaccurate. Consider using '#align submodule.to_ordered_add_comm_group Submodule.toOrderedAddCommGroupₓ'. -/
/-- A submodule of an `ordered_add_comm_group` is an `ordered_add_comm_group`. -/
instance toOrderedAddCommGroup {M} [OrderedAddCommGroup M] [Module R M] (S : Submodule R M) :
    OrderedAddCommGroup S :=
  Subtype.coe_injective.OrderedAddCommGroup coe rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)
    (fun _ _ => rfl) fun _ _ => rfl
#align submodule.to_ordered_add_comm_group Submodule.toOrderedAddCommGroup

/- warning: submodule.to_linear_ordered_add_comm_group -> Submodule.toLinearOrderedAddCommGroup is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {M : Type.{u2}} [_inst_2 : LinearOrderedAddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M (OrderedAddCommGroup.toAddCommGroup.{u2} M (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u2} M _inst_2)))] (S : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M (OrderedAddCommGroup.toAddCommGroup.{u2} M (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u2} M _inst_2))) _inst_3), LinearOrderedAddCommGroup.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M (OrderedAddCommGroup.toAddCommGroup.{u2} M (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u2} M _inst_2))) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M (OrderedAddCommGroup.toAddCommGroup.{u2} M (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u2} M _inst_2))) _inst_3) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M (OrderedAddCommGroup.toAddCommGroup.{u2} M (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u2} M _inst_2))) _inst_3)) S)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {M : Type.{u2}} [_inst_2 : LinearOrderedAddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} M (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u2} M (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u2} M _inst_2)))] (S : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} M (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u2} M (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u2} M _inst_2))) _inst_3), LinearOrderedAddCommGroup.{u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} M (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u2} M (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u2} M _inst_2))) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} M (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u2} M (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u2} M _inst_2))) _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} M (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u2} M (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u2} M _inst_2))) _inst_3)) x S))
Case conversion may be inaccurate. Consider using '#align submodule.to_linear_ordered_add_comm_group Submodule.toLinearOrderedAddCommGroupₓ'. -/
/-- A submodule of a `linear_ordered_add_comm_group` is a
`linear_ordered_add_comm_group`. -/
instance toLinearOrderedAddCommGroup {M} [LinearOrderedAddCommGroup M] [Module R M]
    (S : Submodule R M) : LinearOrderedAddCommGroup S :=
  Subtype.coe_injective.LinearOrderedAddCommGroup coe rfl (fun _ _ => rfl) (fun _ => rfl)
    (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) fun _ _ => rfl
#align submodule.to_linear_ordered_add_comm_group Submodule.toLinearOrderedAddCommGroup

end OrderedGroup

end Submodule

namespace Submodule

variable [DivisionRing S] [Semiring R] [AddCommMonoid M] [Module R M]

variable [SMul S R] [Module S M] [IsScalarTower S R M]

variable (p : Submodule R M) {s : S} {x y : M}

/- warning: submodule.smul_mem_iff -> Submodule.smul_mem_iff is a dubious translation:
lean 3 declaration is
  forall {S : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : DivisionRing.{u1} S] [_inst_2 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u3} M] [_inst_4 : Module.{u2, u3} R M _inst_2 _inst_3] [_inst_5 : SMul.{u1, u2} S R] [_inst_6 : Module.{u1, u3} S M (Ring.toSemiring.{u1} S (DivisionRing.toRing.{u1} S _inst_1)) _inst_3] [_inst_7 : IsScalarTower.{u1, u2, u3} S R M _inst_5 (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_2)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_2) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Module.toMulActionWithZero.{u2, u3} R M _inst_2 _inst_3 _inst_4)))) (SMulZeroClass.toHasSmul.{u1, u3} S M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} S M (MulZeroClass.toHasZero.{u1} S (MulZeroOneClass.toMulZeroClass.{u1} S (MonoidWithZero.toMulZeroOneClass.{u1} S (Semiring.toMonoidWithZero.{u1} S (Ring.toSemiring.{u1} S (DivisionRing.toRing.{u1} S _inst_1)))))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} S M (Semiring.toMonoidWithZero.{u1} S (Ring.toSemiring.{u1} S (DivisionRing.toRing.{u1} S _inst_1))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Module.toMulActionWithZero.{u1, u3} S M (Ring.toSemiring.{u1} S (DivisionRing.toRing.{u1} S _inst_1)) _inst_3 _inst_6))))] (p : Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) {s : S} {x : M}, (Ne.{succ u1} S s (OfNat.ofNat.{u1} S 0 (OfNat.mk.{u1} S 0 (Zero.zero.{u1} S (MulZeroClass.toHasZero.{u1} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (DivisionRing.toRing.{u1} S _inst_1)))))))))) -> (Iff (Membership.Mem.{u3, u3} M (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) (SMul.smul.{u1, u3} S M (SMulZeroClass.toHasSmul.{u1, u3} S M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} S M (MulZeroClass.toHasZero.{u1} S (MulZeroOneClass.toMulZeroClass.{u1} S (MonoidWithZero.toMulZeroOneClass.{u1} S (Semiring.toMonoidWithZero.{u1} S (Ring.toSemiring.{u1} S (DivisionRing.toRing.{u1} S _inst_1)))))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} S M (Semiring.toMonoidWithZero.{u1} S (Ring.toSemiring.{u1} S (DivisionRing.toRing.{u1} S _inst_1))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Module.toMulActionWithZero.{u1, u3} S M (Ring.toSemiring.{u1} S (DivisionRing.toRing.{u1} S _inst_1)) _inst_3 _inst_6)))) s x) p) (Membership.Mem.{u3, u3} M (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) x p))
but is expected to have type
  forall {S : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : DivisionRing.{u1} S] [_inst_2 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u3} M] [_inst_4 : Module.{u2, u3} R M _inst_2 _inst_3] [_inst_5 : SMul.{u1, u2} S R] [_inst_6 : Module.{u1, u3} S M (DivisionSemiring.toSemiring.{u1} S (DivisionRing.toDivisionSemiring.{u1} S _inst_1)) _inst_3] [_inst_7 : IsScalarTower.{u1, u2, u3} S R M _inst_5 (SMulZeroClass.toSMul.{u2, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u2, u3} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_2)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_2) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (Module.toMulActionWithZero.{u2, u3} R M _inst_2 _inst_3 _inst_4)))) (SMulZeroClass.toSMul.{u1, u3} S M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u1, u3} S M (MonoidWithZero.toZero.{u1} S (Semiring.toMonoidWithZero.{u1} S (DivisionSemiring.toSemiring.{u1} S (DivisionRing.toDivisionSemiring.{u1} S _inst_1)))) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u1, u3} S M (Semiring.toMonoidWithZero.{u1} S (DivisionSemiring.toSemiring.{u1} S (DivisionRing.toDivisionSemiring.{u1} S _inst_1))) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (Module.toMulActionWithZero.{u1, u3} S M (DivisionSemiring.toSemiring.{u1} S (DivisionRing.toDivisionSemiring.{u1} S _inst_1)) _inst_3 _inst_6))))] (p : Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) {s : S} {x : M}, (Ne.{succ u1} S s (OfNat.ofNat.{u1} S 0 (Zero.toOfNat0.{u1} S (MonoidWithZero.toZero.{u1} S (Semiring.toMonoidWithZero.{u1} S (DivisionSemiring.toSemiring.{u1} S (DivisionRing.toDivisionSemiring.{u1} S _inst_1))))))) -> (Iff (Membership.mem.{u3, u3} M (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u3} R M _inst_2 _inst_3 _inst_4)) (HSMul.hSMul.{u1, u3, u3} S M M (instHSMul.{u1, u3} S M (SMulZeroClass.toSMul.{u1, u3} S M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u1, u3} S M (MonoidWithZero.toZero.{u1} S (Semiring.toMonoidWithZero.{u1} S (DivisionSemiring.toSemiring.{u1} S (DivisionRing.toDivisionSemiring.{u1} S _inst_1)))) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u1, u3} S M (Semiring.toMonoidWithZero.{u1} S (DivisionSemiring.toSemiring.{u1} S (DivisionRing.toDivisionSemiring.{u1} S _inst_1))) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (Module.toMulActionWithZero.{u1, u3} S M (DivisionSemiring.toSemiring.{u1} S (DivisionRing.toDivisionSemiring.{u1} S _inst_1)) _inst_3 _inst_6))))) s x) p) (Membership.mem.{u3, u3} M (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u3} R M _inst_2 _inst_3 _inst_4)) x p))
Case conversion may be inaccurate. Consider using '#align submodule.smul_mem_iff Submodule.smul_mem_iffₓ'. -/
theorem smul_mem_iff (s0 : s ≠ 0) : s • x ∈ p ↔ x ∈ p :=
  p.toSubMulAction.smul_mem_iff s0
#align submodule.smul_mem_iff Submodule.smul_mem_iff

end Submodule

#print Subspace /-
/-- Subspace of a vector space. Defined to equal `submodule`. -/
abbrev Subspace (R : Type u) (M : Type v) [DivisionRing R] [AddCommGroup M] [Module R M] :=
  Submodule R M
#align subspace Subspace
-/

