/-
Copyright (c) 2021 Eric Wieser. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Eric Wieser

! This file was ported from Lean 3 source module algebra.module.submodule.pointwise
! leanprover-community/mathlib commit 1ead22342e1a078bd44744ace999f85756555d35
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.GroupTheory.Subgroup.Pointwise
import Mathbin.LinearAlgebra.Span

/-! # Pointwise instances on `submodule`s

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file provides:

* `submodule.has_pointwise_neg`

and the actions

* `submodule.pointwise_distrib_mul_action`
* `submodule.pointwise_mul_action_with_zero`

which matches the action of `mul_action_set`.

These actions are available in the `pointwise` locale.

## Implementation notes

Most of the lemmas in this file are direct copies of lemmas from
`group_theory/submonoid/pointwise.lean`.
-/


variable {α : Type _} {R : Type _} {M : Type _}

open Pointwise

namespace Submodule

section Neg

section Semiring

variable [Semiring R] [AddCommGroup M] [Module R M]

#print Submodule.pointwiseNeg /-
/-- The submodule with every element negated. Note if `R` is a ring and not just a semiring, this
is a no-op, as shown by `submodule.neg_eq_self`.

Recall that When `R` is the semiring corresponding to the nonnegative elements of `R'`,
`submodule R' M` is the type of cones of `M`. This instance reflects such cones about `0`.

This is available as an instance in the `pointwise` locale. -/
protected def pointwiseNeg : Neg (Submodule R M)
    where neg p :=
    { -p.toAddSubmonoid with
      carrier := -(p : Set M)
      smul_mem' := fun r m hm => Set.mem_neg.2 <| smul_neg r m ▸ p.smul_mem r <| Set.mem_neg.1 hm }
#align submodule.has_pointwise_neg Submodule.pointwiseNeg
-/

scoped[Pointwise] attribute [instance] Submodule.pointwiseNeg

open Pointwise

/- warning: submodule.coe_set_neg -> Submodule.coe_set_neg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] (S : Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3), Eq.{succ u2} (Set.{u2} M) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)))) (Neg.neg.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u1, u2} R M _inst_1 _inst_2 _inst_3) S)) (Neg.neg.{u2} (Set.{u2} M) (Set.neg.{u2} M (SubNegMonoid.toHasNeg.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)))) S))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] (S : Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3), Eq.{succ u1} (Set.{u1} M) (SetLike.coe.{u1, u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Neg.neg.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u2, u1} R M _inst_1 _inst_2 _inst_3) S)) (Neg.neg.{u1} (Set.{u1} M) (Set.neg.{u1} M (NegZeroClass.toNeg.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2)))))) (SetLike.coe.{u1, u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) S))
Case conversion may be inaccurate. Consider using '#align submodule.coe_set_neg Submodule.coe_set_negₓ'. -/
@[simp]
theorem coe_set_neg (S : Submodule R M) : ↑(-S) = -(S : Set M) :=
  rfl
#align submodule.coe_set_neg Submodule.coe_set_neg

/- warning: submodule.neg_to_add_submonoid -> Submodule.neg_toAddSubmonoid is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] (S : Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3), Eq.{succ u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (Submodule.toAddSubmonoid.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (Neg.neg.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u1, u2} R M _inst_1 _inst_2 _inst_3) S)) (Neg.neg.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (InvolutiveNeg.toHasNeg.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (AddSubmonoid.hasInvolutiveNeg.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))) (Submodule.toAddSubmonoid.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 S))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] (S : Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3), Eq.{succ u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)))) (Submodule.toAddSubmonoid.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3 (Neg.neg.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u2, u1} R M _inst_1 _inst_2 _inst_3) S)) (Neg.neg.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)))) (AddSubmonoid.neg.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2)) (Submodule.toAddSubmonoid.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3 S))
Case conversion may be inaccurate. Consider using '#align submodule.neg_to_add_submonoid Submodule.neg_toAddSubmonoidₓ'. -/
@[simp]
theorem neg_toAddSubmonoid (S : Submodule R M) : (-S).toAddSubmonoid = -S.toAddSubmonoid :=
  rfl
#align submodule.neg_to_add_submonoid Submodule.neg_toAddSubmonoid

/- warning: submodule.mem_neg -> Submodule.mem_neg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] {g : M} {S : Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3}, Iff (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)) g (Neg.neg.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u1, u2} R M _inst_1 _inst_2 _inst_3) S)) (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)) (Neg.neg.{u2} M (SubNegMonoid.toHasNeg.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))) g) S)
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] {g : M} {S : Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3}, Iff (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3)) g (Neg.neg.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u2, u1} R M _inst_1 _inst_2 _inst_3) S)) (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3)) (Neg.neg.{u1} M (NegZeroClass.toNeg.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) g) S)
Case conversion may be inaccurate. Consider using '#align submodule.mem_neg Submodule.mem_negₓ'. -/
@[simp]
theorem mem_neg {g : M} {S : Submodule R M} : g ∈ -S ↔ -g ∈ S :=
  Iff.rfl
#align submodule.mem_neg Submodule.mem_neg

#print Submodule.involutivePointwiseNeg /-
/-- `submodule.has_pointwise_neg` is involutive.

This is available as an instance in the `pointwise` locale. -/
protected def involutivePointwiseNeg : InvolutiveNeg (Submodule R M)
    where
  neg := Neg.neg
  neg_neg S := SetLike.coe_injective <| neg_neg _
#align submodule.has_involutive_pointwise_neg Submodule.involutivePointwiseNeg
-/

scoped[Pointwise] attribute [instance] Submodule.involutivePointwiseNeg

/- warning: submodule.neg_le_neg -> Submodule.neg_le_neg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] (S : Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (T : Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3), Iff (LE.le.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)))) (Neg.neg.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u1, u2} R M _inst_1 _inst_2 _inst_3) S) (Neg.neg.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u1, u2} R M _inst_1 _inst_2 _inst_3) T)) (LE.le.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)))) S T)
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] (S : Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (T : Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3), Iff (LE.le.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Preorder.toLE.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))))) (Neg.neg.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u2, u1} R M _inst_1 _inst_2 _inst_3) S) (Neg.neg.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u2, u1} R M _inst_1 _inst_2 _inst_3) T)) (LE.le.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Preorder.toLE.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))))) S T)
Case conversion may be inaccurate. Consider using '#align submodule.neg_le_neg Submodule.neg_le_negₓ'. -/
@[simp]
theorem neg_le_neg (S T : Submodule R M) : -S ≤ -T ↔ S ≤ T :=
  SetLike.coe_subset_coe.symm.trans Set.neg_subset_neg
#align submodule.neg_le_neg Submodule.neg_le_neg

/- warning: submodule.neg_le -> Submodule.neg_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] (S : Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (T : Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3), Iff (LE.le.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)))) (Neg.neg.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u1, u2} R M _inst_1 _inst_2 _inst_3) S) T) (LE.le.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)))) S (Neg.neg.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u1, u2} R M _inst_1 _inst_2 _inst_3) T))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] (S : Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (T : Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3), Iff (LE.le.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Preorder.toLE.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))))) (Neg.neg.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u2, u1} R M _inst_1 _inst_2 _inst_3) S) T) (LE.le.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Preorder.toLE.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))))) S (Neg.neg.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u2, u1} R M _inst_1 _inst_2 _inst_3) T))
Case conversion may be inaccurate. Consider using '#align submodule.neg_le Submodule.neg_leₓ'. -/
theorem neg_le (S T : Submodule R M) : -S ≤ T ↔ S ≤ -T :=
  SetLike.coe_subset_coe.symm.trans Set.neg_subset
#align submodule.neg_le Submodule.neg_le

/- warning: submodule.neg_order_iso -> Submodule.negOrderIso is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)], OrderIso.{u2, u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)))) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)], OrderIso.{u2, u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))))) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)))))
Case conversion may be inaccurate. Consider using '#align submodule.neg_order_iso Submodule.negOrderIsoₓ'. -/
/-- `submodule.has_pointwise_neg` as an order isomorphism. -/
def negOrderIso : Submodule R M ≃o Submodule R M
    where
  toEquiv := Equiv.neg _
  map_rel_iff' := neg_le_neg
#align submodule.neg_order_iso Submodule.negOrderIso

/- warning: submodule.closure_neg -> Submodule.closure_neg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] (s : Set.{u2} M), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.span.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (Neg.neg.{u2} (Set.{u2} M) (Set.neg.{u2} M (SubNegMonoid.toHasNeg.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))) s)) (Neg.neg.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 s))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] (s : Set.{u2} M), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.span.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (Neg.neg.{u2} (Set.{u2} M) (Set.neg.{u2} M (NegZeroClass.toNeg.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2)))))) s)) (Neg.neg.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 s))
Case conversion may be inaccurate. Consider using '#align submodule.closure_neg Submodule.closure_negₓ'. -/
theorem closure_neg (s : Set M) : span R (-s) = -span R s :=
  by
  apply le_antisymm
  · rw [span_le, coe_set_neg, ← Set.neg_subset, neg_neg]
    exact subset_span
  · rw [neg_le, span_le, coe_set_neg, ← Set.neg_subset]
    exact subset_span
#align submodule.closure_neg Submodule.closure_neg

/- warning: submodule.neg_inf -> Submodule.neg_inf is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] (S : Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (T : Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Neg.neg.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Inf.inf.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.hasInf.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) S T)) (Inf.inf.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.hasInf.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Neg.neg.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u1, u2} R M _inst_1 _inst_2 _inst_3) S) (Neg.neg.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u1, u2} R M _inst_1 _inst_2 _inst_3) T))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] (S : Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (T : Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3), Eq.{succ u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Neg.neg.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Inf.inf.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.instInfSubmodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) S T)) (Inf.inf.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.instInfSubmodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Neg.neg.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u2, u1} R M _inst_1 _inst_2 _inst_3) S) (Neg.neg.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u2, u1} R M _inst_1 _inst_2 _inst_3) T))
Case conversion may be inaccurate. Consider using '#align submodule.neg_inf Submodule.neg_infₓ'. -/
@[simp]
theorem neg_inf (S T : Submodule R M) : -(S ⊓ T) = -S ⊓ -T :=
  SetLike.coe_injective Set.inter_neg
#align submodule.neg_inf Submodule.neg_inf

/- warning: submodule.neg_sup -> Submodule.neg_sup is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] (S : Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (T : Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Neg.neg.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Sup.sup.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))))) S T)) (Sup.sup.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))))) (Neg.neg.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u1, u2} R M _inst_1 _inst_2 _inst_3) S) (Neg.neg.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u1, u2} R M _inst_1 _inst_2 _inst_3) T))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] (S : Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (T : Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3), Eq.{succ u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Neg.neg.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Sup.sup.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (SemilatticeSup.toSup.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))))) S T)) (Sup.sup.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (SemilatticeSup.toSup.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))))) (Neg.neg.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u2, u1} R M _inst_1 _inst_2 _inst_3) S) (Neg.neg.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u2, u1} R M _inst_1 _inst_2 _inst_3) T))
Case conversion may be inaccurate. Consider using '#align submodule.neg_sup Submodule.neg_supₓ'. -/
@[simp]
theorem neg_sup (S T : Submodule R M) : -(S ⊔ T) = -S ⊔ -T :=
  (negOrderIso : Submodule R M ≃o Submodule R M).map_sup S T
#align submodule.neg_sup Submodule.neg_sup

/- warning: submodule.neg_bot -> Submodule.neg_bot is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)], Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Neg.neg.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.hasBot.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))) (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.hasBot.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)], Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Neg.neg.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.instBotSubmodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))) (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.instBotSubmodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))
Case conversion may be inaccurate. Consider using '#align submodule.neg_bot Submodule.neg_botₓ'. -/
@[simp]
theorem neg_bot : -(⊥ : Submodule R M) = ⊥ :=
  SetLike.coe_injective <| (Set.neg_singleton 0).trans <| congr_arg _ neg_zero
#align submodule.neg_bot Submodule.neg_bot

/- warning: submodule.neg_top -> Submodule.neg_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)], Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Neg.neg.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Top.top.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.hasTop.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))) (Top.top.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.hasTop.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)], Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Neg.neg.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Top.top.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.instTopSubmodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))) (Top.top.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.instTopSubmodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))
Case conversion may be inaccurate. Consider using '#align submodule.neg_top Submodule.neg_topₓ'. -/
@[simp]
theorem neg_top : -(⊤ : Submodule R M) = ⊤ :=
  SetLike.coe_injective <| Set.neg_univ
#align submodule.neg_top Submodule.neg_top

/- warning: submodule.neg_infi -> Submodule.neg_infᵢ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] {ι : Sort.{u3}} (S : ι -> (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Neg.neg.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u1, u2} R M _inst_1 _inst_2 _inst_3) (infᵢ.{u2, u3} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.hasInf.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) ι (fun (i : ι) => S i))) (infᵢ.{u2, u3} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.hasInf.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) ι (fun (i : ι) => Neg.neg.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u1, u2} R M _inst_1 _inst_2 _inst_3) (S i)))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] {ι : Sort.{u3}} (S : ι -> (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3)), Eq.{succ u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Neg.neg.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u2, u1} R M _inst_1 _inst_2 _inst_3) (infᵢ.{u1, u3} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.instInfSetSubmodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) ι (fun (i : ι) => S i))) (infᵢ.{u1, u3} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.instInfSetSubmodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) ι (fun (i : ι) => Neg.neg.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u2, u1} R M _inst_1 _inst_2 _inst_3) (S i)))
Case conversion may be inaccurate. Consider using '#align submodule.neg_infi Submodule.neg_infᵢₓ'. -/
@[simp]
theorem neg_infᵢ {ι : Sort _} (S : ι → Submodule R M) : (-⨅ i, S i) = ⨅ i, -S i :=
  (negOrderIso : Submodule R M ≃o Submodule R M).map_infᵢ _
#align submodule.neg_infi Submodule.neg_infᵢ

/- warning: submodule.neg_supr -> Submodule.neg_supᵢ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] {ι : Sort.{u3}} (S : ι -> (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Neg.neg.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u1, u2} R M _inst_1 _inst_2 _inst_3) (supᵢ.{u2, u3} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))) ι (fun (i : ι) => S i))) (supᵢ.{u2, u3} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))) ι (fun (i : ι) => Neg.neg.{u2} (Submodule.{u1, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u1, u2} R M _inst_1 _inst_2 _inst_3) (S i)))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] {ι : Sort.{u3}} (S : ι -> (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3)), Eq.{succ u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Neg.neg.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u2, u1} R M _inst_1 _inst_2 _inst_3) (supᵢ.{u1, u3} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (ConditionallyCompleteLattice.toSupSet.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))) ι (fun (i : ι) => S i))) (supᵢ.{u1, u3} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (ConditionallyCompleteLattice.toSupSet.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))) ι (fun (i : ι) => Neg.neg.{u1} (Submodule.{u2, u1} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u2, u1} R M _inst_1 _inst_2 _inst_3) (S i)))
Case conversion may be inaccurate. Consider using '#align submodule.neg_supr Submodule.neg_supᵢₓ'. -/
@[simp]
theorem neg_supᵢ {ι : Sort _} (S : ι → Submodule R M) : (-⨆ i, S i) = ⨆ i, -S i :=
  (negOrderIso : Submodule R M ≃o Submodule R M).map_supᵢ _
#align submodule.neg_supr Submodule.neg_supᵢ

end Semiring

open Pointwise

/- warning: submodule.neg_eq_self -> Submodule.neg_eq_self is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] (p : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3), Eq.{succ u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Neg.neg.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) p) p
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_3 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] (p : Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3), Eq.{succ u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Neg.neg.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.pointwiseNeg.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) p) p
Case conversion may be inaccurate. Consider using '#align submodule.neg_eq_self Submodule.neg_eq_selfₓ'. -/
@[simp]
theorem neg_eq_self [Ring R] [AddCommGroup M] [Module R M] (p : Submodule R M) : -p = p :=
  ext fun _ => p.neg_mem_iff
#align submodule.neg_eq_self Submodule.neg_eq_self

end Neg

variable [Semiring R] [AddCommMonoid M] [Module R M]

#print Submodule.pointwiseAddCommMonoid /-
instance pointwiseAddCommMonoid : AddCommMonoid (Submodule R M)
    where
  add := (· ⊔ ·)
  add_assoc _ _ _ := sup_assoc
  zero := ⊥
  zero_add _ := bot_sup_eq
  add_zero _ := sup_bot_eq
  add_comm _ _ := sup_comm
#align submodule.pointwise_add_comm_monoid Submodule.pointwiseAddCommMonoid
-/

/- warning: submodule.add_eq_sup -> Submodule.add_eq_sup is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (q : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (HAdd.hAdd.{u2, u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (instHAdd.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (AddZeroClass.toHasAdd.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) p q) (Sup.sup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) p q)
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] (p : Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (q : Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3), Eq.{succ u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (HAdd.hAdd.{u1, u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (instHAdd.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (AddZeroClass.toAdd.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3))))) p q) (Sup.sup.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SemilatticeSup.toSup.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Lattice.toSemilatticeSup.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toLattice.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))))) p q)
Case conversion may be inaccurate. Consider using '#align submodule.add_eq_sup Submodule.add_eq_supₓ'. -/
@[simp]
theorem add_eq_sup (p q : Submodule R M) : p + q = p ⊔ q :=
  rfl
#align submodule.add_eq_sup Submodule.add_eq_sup

/- warning: submodule.zero_eq_bot -> Submodule.zero_eq_bot is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (OfNat.ofNat.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) 0 (OfNat.mk.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) 0 (Zero.zero.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (AddZeroClass.toHasZero.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3))))))) (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.hasBot.{u1, u2} R M _inst_1 _inst_2 _inst_3))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (OfNat.ofNat.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) 0 (Zero.toOfNat0.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toZero.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.instBotSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align submodule.zero_eq_bot Submodule.zero_eq_botₓ'. -/
@[simp]
theorem zero_eq_bot : (0 : Submodule R M) = ⊥ :=
  rfl
#align submodule.zero_eq_bot Submodule.zero_eq_bot

instance : CanonicallyOrderedAddMonoid (Submodule R M) :=
  { Submodule.pointwiseAddCommMonoid,
    Submodule.completeLattice with
    zero := 0
    bot := ⊥
    add := (· + ·)
    add_le_add_left := fun a b => sup_le_sup_left
    exists_add_of_le := fun a b h => ⟨b, (sup_eq_right.2 h).symm⟩
    le_self_add := fun a b => le_sup_left }

section

variable [Monoid α] [DistribMulAction α M] [SMulCommClass α R M]

/- warning: submodule.pointwise_distrib_mul_action -> Submodule.pointwiseDistribMulAction is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_4 : Monoid.{u1} α] [_inst_5 : DistribMulAction.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_6 : SMulCommClass.{u1, u2, u3} α R M (SMulZeroClass.toHasSmul.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (DistribSMul.toSmulZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5))) (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_3))))], DistribMulAction.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) _inst_4 (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3))
but is expected to have type
  forall {α : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_4 : Monoid.{u1} α] [_inst_5 : DistribMulAction.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_6 : SMulCommClass.{u1, u2, u3} α R M (SMulZeroClass.toSMul.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5))) (SMulZeroClass.toSMul.{u2, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u3} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_3))))], DistribMulAction.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) _inst_4 (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align submodule.pointwise_distrib_mul_action Submodule.pointwiseDistribMulActionₓ'. -/
/-- The action on a submodule corresponding to applying the action to every element.

This is available as an instance in the `pointwise` locale. -/
protected def pointwiseDistribMulAction : DistribMulAction α (Submodule R M)
    where
  smul a S := S.map (DistribMulAction.toLinearMap R M a : M →ₗ[R] M)
  one_smul S :=
    (congr_arg (fun f : Module.End R M => S.map f) (LinearMap.ext <| one_smul α)).trans S.map_id
  mul_smul a₁ a₂ S :=
    (congr_arg (fun f : Module.End R M => S.map f) (LinearMap.ext <| mul_smul _ _)).trans
      (S.map_comp _ _)
  smul_zero a := map_bot _
  smul_add a S₁ S₂ := map_sup _ _ _
#align submodule.pointwise_distrib_mul_action Submodule.pointwiseDistribMulAction

scoped[Pointwise] attribute [instance] Submodule.pointwiseDistribMulAction

open Pointwise

/- warning: submodule.coe_pointwise_smul -> Submodule.coe_pointwise_smul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_4 : Monoid.{u1} α] [_inst_5 : DistribMulAction.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_6 : SMulCommClass.{u1, u2, u3} α R M (SMulZeroClass.toHasSmul.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (DistribSMul.toSmulZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5))) (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_3))))] (a : α) (S : Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3), Eq.{succ u3} (Set.{u3} M) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u3} R M _inst_1 _inst_2 _inst_3)))) (SMul.smul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (SMulZeroClass.toHasSmul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddZeroClass.toHasZero.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3)))) (DistribSMul.toSmulZeroClass.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3))) (DistribMulAction.toDistribSMul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) _inst_4 (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3)) (Submodule.pointwiseDistribMulAction.{u1, u2, u3} α R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)))) a S)) (SMul.smul.{u1, u3} α (Set.{u3} M) (Set.smulSet.{u1, u3} α M (SMulZeroClass.toHasSmul.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (DistribSMul.toSmulZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5)))) a ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u3} R M _inst_1 _inst_2 _inst_3)))) S))
but is expected to have type
  forall {α : Type.{u1}} {R : Type.{u3}} {M : Type.{u2}} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u3, u2} R M _inst_1 _inst_2] [_inst_4 : Monoid.{u1} α] [_inst_5 : DistribMulAction.{u1, u2} α M _inst_4 (AddCommMonoid.toAddMonoid.{u2} M _inst_2)] [_inst_6 : SMulCommClass.{u1, u3, u2} α R M (SMulZeroClass.toSMul.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u2} α M _inst_4 (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_5))) (SMulZeroClass.toSMul.{u3, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u3, u2} R M (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u3, u2} R M _inst_1 _inst_2 _inst_3))))] (a : α) (S : Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3), Eq.{succ u2} (Set.{u2} M) (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u3, u2} R M _inst_1 _inst_2 _inst_3) (HSMul.hSMul.{u1, u2, u2} α (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (instHSMul.{u1, u2} α (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (SMulZeroClass.toSMul.{u1, u2} α (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toZero.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u3, u2} R M _inst_1 _inst_2 _inst_3))) (DistribSMul.toSMulZeroClass.{u1, u2} α (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u3, u2} R M _inst_1 _inst_2 _inst_3))) (DistribMulAction.toDistribSMul.{u1, u2} α (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) _inst_4 (AddCommMonoid.toAddMonoid.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u3, u2} R M _inst_1 _inst_2 _inst_3)) (Submodule.pointwiseDistribMulAction.{u1, u3, u2} α R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6))))) a S)) (HSMul.hSMul.{u1, u2, u2} α (Set.{u2} M) (Set.{u2} M) (instHSMul.{u1, u2} α (Set.{u2} M) (Set.smulSet.{u1, u2} α M (SMulZeroClass.toSMul.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u2} α M _inst_4 (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_5))))) a (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u3, u2} R M _inst_1 _inst_2 _inst_3) S))
Case conversion may be inaccurate. Consider using '#align submodule.coe_pointwise_smul Submodule.coe_pointwise_smulₓ'. -/
@[simp]
theorem coe_pointwise_smul (a : α) (S : Submodule R M) : ↑(a • S) = a • (S : Set M) :=
  rfl
#align submodule.coe_pointwise_smul Submodule.coe_pointwise_smul

/- warning: submodule.pointwise_smul_to_add_submonoid -> Submodule.pointwise_smul_toAddSubmonoid is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_4 : Monoid.{u1} α] [_inst_5 : DistribMulAction.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_6 : SMulCommClass.{u1, u2, u3} α R M (SMulZeroClass.toHasSmul.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (DistribSMul.toSmulZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5))) (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_3))))] (a : α) (S : Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3), Eq.{succ u3} (AddSubmonoid.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Submodule.toAddSubmonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3 (SMul.smul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (SMulZeroClass.toHasSmul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddZeroClass.toHasZero.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3)))) (DistribSMul.toSmulZeroClass.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3))) (DistribMulAction.toDistribSMul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) _inst_4 (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3)) (Submodule.pointwiseDistribMulAction.{u1, u2, u3} α R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)))) a S)) (SMul.smul.{u1, u3} α (AddSubmonoid.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulAction.toHasSmul.{u1, u3} α (AddSubmonoid.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) _inst_4 (AddSubmonoid.pointwiseMulAction.{u1, u3} α M (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_4 _inst_5)) a (Submodule.toAddSubmonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3 S))
but is expected to have type
  forall {α : Type.{u1}} {R : Type.{u3}} {M : Type.{u2}} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u3, u2} R M _inst_1 _inst_2] [_inst_4 : Monoid.{u1} α] [_inst_5 : DistribMulAction.{u1, u2} α M _inst_4 (AddCommMonoid.toAddMonoid.{u2} M _inst_2)] [_inst_6 : SMulCommClass.{u1, u3, u2} α R M (SMulZeroClass.toSMul.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u2} α M _inst_4 (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_5))) (SMulZeroClass.toSMul.{u3, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u3, u2} R M (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u3, u2} R M _inst_1 _inst_2 _inst_3))))] (a : α) (S : Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3), Eq.{succ u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Submodule.toAddSubmonoid.{u3, u2} R M _inst_1 _inst_2 _inst_3 (HSMul.hSMul.{u1, u2, u2} α (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (instHSMul.{u1, u2} α (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (SMulZeroClass.toSMul.{u1, u2} α (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toZero.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u3, u2} R M _inst_1 _inst_2 _inst_3))) (DistribSMul.toSMulZeroClass.{u1, u2} α (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u3, u2} R M _inst_1 _inst_2 _inst_3))) (DistribMulAction.toDistribSMul.{u1, u2} α (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) _inst_4 (AddCommMonoid.toAddMonoid.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u3, u2} R M _inst_1 _inst_2 _inst_3)) (Submodule.pointwiseDistribMulAction.{u1, u3, u2} α R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6))))) a S)) (HSMul.hSMul.{u1, u2, u2} α (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (instHSMul.{u1, u2} α (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulAction.toSMul.{u1, u2} α (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) _inst_4 (AddSubmonoid.pointwiseMulAction.{u1, u2} α M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_4 _inst_5))) a (Submodule.toAddSubmonoid.{u3, u2} R M _inst_1 _inst_2 _inst_3 S))
Case conversion may be inaccurate. Consider using '#align submodule.pointwise_smul_to_add_submonoid Submodule.pointwise_smul_toAddSubmonoidₓ'. -/
@[simp]
theorem pointwise_smul_toAddSubmonoid (a : α) (S : Submodule R M) :
    (a • S).toAddSubmonoid = a • S.toAddSubmonoid :=
  rfl
#align submodule.pointwise_smul_to_add_submonoid Submodule.pointwise_smul_toAddSubmonoid

/- warning: submodule.pointwise_smul_to_add_subgroup -> Submodule.pointwise_smul_toAddSubgroup is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_4 : Monoid.{u1} α] {R : Type.{u2}} {M : Type.{u3}} [_inst_7 : Ring.{u2} R] [_inst_8 : AddCommGroup.{u3} M] [_inst_9 : DistribMulAction.{u1, u3} α M _inst_4 (SubNegMonoid.toAddMonoid.{u3} M (AddGroup.toSubNegMonoid.{u3} M (AddCommGroup.toAddGroup.{u3} M _inst_8)))] [_inst_10 : Module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M _inst_8)] [_inst_11 : SMulCommClass.{u1, u2, u3} α R M (SMulZeroClass.toHasSmul.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (SubNegMonoid.toAddMonoid.{u3} M (AddGroup.toSubNegMonoid.{u3} M (AddCommGroup.toAddGroup.{u3} M _inst_8))))) (DistribSMul.toSmulZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (SubNegMonoid.toAddMonoid.{u3} M (AddGroup.toSubNegMonoid.{u3} M (AddCommGroup.toAddGroup.{u3} M _inst_8)))) (DistribMulAction.toDistribSMul.{u1, u3} α M _inst_4 (SubNegMonoid.toAddMonoid.{u3} M (AddGroup.toSubNegMonoid.{u3} M (AddCommGroup.toAddGroup.{u3} M _inst_8))) _inst_9))) (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_8)))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_7))))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_8)))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_7)) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_8)))) (Module.toMulActionWithZero.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M _inst_8) _inst_10))))] (a : α) (S : Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M _inst_8) _inst_10), Eq.{succ u3} (AddSubgroup.{u3} M (AddCommGroup.toAddGroup.{u3} M _inst_8)) (Submodule.toAddSubgroup.{u2, u3} R M _inst_7 _inst_8 _inst_10 (SMul.smul.{u1, u3} α (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M _inst_8) _inst_10) (SMulZeroClass.toHasSmul.{u1, u3} α (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M _inst_8) _inst_10) (AddZeroClass.toHasZero.{u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M _inst_8) _inst_10) (AddMonoid.toAddZeroClass.{u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M _inst_8) _inst_10) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M _inst_8) _inst_10) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M _inst_8) _inst_10)))) (DistribSMul.toSmulZeroClass.{u1, u3} α (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M _inst_8) _inst_10) (AddMonoid.toAddZeroClass.{u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M _inst_8) _inst_10) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M _inst_8) _inst_10) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M _inst_8) _inst_10))) (DistribMulAction.toDistribSMul.{u1, u3} α (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M _inst_8) _inst_10) _inst_4 (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M _inst_8) _inst_10) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M _inst_8) _inst_10)) (Submodule.pointwiseDistribMulAction.{u1, u2, u3} α R M (Ring.toSemiring.{u2} R _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M _inst_8) _inst_10 _inst_4 _inst_9 _inst_11)))) a S)) (SMul.smul.{u1, u3} α (AddSubgroup.{u3} M (AddCommGroup.toAddGroup.{u3} M _inst_8)) (MulAction.toHasSmul.{u1, u3} α (AddSubgroup.{u3} M (AddCommGroup.toAddGroup.{u3} M _inst_8)) _inst_4 (AddSubgroup.pointwiseMulAction.{u1, u3} α M (AddCommGroup.toAddGroup.{u3} M _inst_8) _inst_4 _inst_9)) a (Submodule.toAddSubgroup.{u2, u3} R M _inst_7 _inst_8 _inst_10 S))
but is expected to have type
  forall {α : Type.{u1}} [_inst_4 : Monoid.{u1} α] {R : Type.{u3}} {M : Type.{u2}} [_inst_7 : Ring.{u3} R] [_inst_8 : AddCommGroup.{u2} M] [_inst_9 : DistribMulAction.{u1, u2} α M _inst_4 (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_8)))] [_inst_10 : Module.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_7) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8)] [_inst_11 : SMulCommClass.{u1, u3, u2} α R M (SMulZeroClass.toSMul.{u1, u2} α M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_8))))) (DistribSMul.toSMulZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_8)))) (DistribMulAction.toDistribSMul.{u1, u2} α M _inst_4 (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_8))) _inst_9))) (SMulZeroClass.toSMul.{u3, u2} R M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_8))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R M (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R _inst_7))) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_8))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R _inst_7)) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_8))))) (Module.toMulActionWithZero.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_7) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8) _inst_10))))] (a : α) (S : Submodule.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_7) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8) _inst_10), Eq.{succ u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_8)) (Submodule.toAddSubgroup.{u3, u2} R M _inst_7 _inst_8 _inst_10 (HSMul.hSMul.{u1, u2, u2} α (Submodule.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_7) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8) _inst_10) (Submodule.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_7) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8) _inst_10) (instHSMul.{u1, u2} α (Submodule.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_7) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8) _inst_10) (SMulZeroClass.toSMul.{u1, u2} α (Submodule.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_7) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8) _inst_10) (AddMonoid.toZero.{u2} (Submodule.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_7) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8) _inst_10) (AddCommMonoid.toAddMonoid.{u2} (Submodule.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_7) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8) _inst_10) (Submodule.pointwiseAddCommMonoid.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_7) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8) _inst_10))) (DistribSMul.toSMulZeroClass.{u1, u2} α (Submodule.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_7) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8) _inst_10) (AddMonoid.toAddZeroClass.{u2} (Submodule.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_7) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8) _inst_10) (AddCommMonoid.toAddMonoid.{u2} (Submodule.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_7) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8) _inst_10) (Submodule.pointwiseAddCommMonoid.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_7) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8) _inst_10))) (DistribMulAction.toDistribSMul.{u1, u2} α (Submodule.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_7) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8) _inst_10) _inst_4 (AddCommMonoid.toAddMonoid.{u2} (Submodule.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_7) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8) _inst_10) (Submodule.pointwiseAddCommMonoid.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_7) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8) _inst_10)) (Submodule.pointwiseDistribMulAction.{u1, u3, u2} α R M (Ring.toSemiring.{u3} R _inst_7) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8) _inst_10 _inst_4 _inst_9 _inst_11))))) a S)) (HSMul.hSMul.{u1, u2, u2} α (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_8)) (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_8)) (instHSMul.{u1, u2} α (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_8)) (MulAction.toSMul.{u1, u2} α (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_8)) _inst_4 (AddSubgroup.pointwiseMulAction.{u1, u2} α M (AddCommGroup.toAddGroup.{u2} M _inst_8) _inst_4 _inst_9))) a (Submodule.toAddSubgroup.{u3, u2} R M _inst_7 _inst_8 _inst_10 S))
Case conversion may be inaccurate. Consider using '#align submodule.pointwise_smul_to_add_subgroup Submodule.pointwise_smul_toAddSubgroupₓ'. -/
@[simp]
theorem pointwise_smul_toAddSubgroup {R M : Type _} [Ring R] [AddCommGroup M] [DistribMulAction α M]
    [Module R M] [SMulCommClass α R M] (a : α) (S : Submodule R M) :
    (a • S).toAddSubgroup = a • S.toAddSubgroup :=
  rfl
#align submodule.pointwise_smul_to_add_subgroup Submodule.pointwise_smul_toAddSubgroup

/- warning: submodule.smul_mem_pointwise_smul -> Submodule.smul_mem_pointwise_smul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_4 : Monoid.{u1} α] [_inst_5 : DistribMulAction.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_6 : SMulCommClass.{u1, u2, u3} α R M (SMulZeroClass.toHasSmul.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (DistribSMul.toSmulZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5))) (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_3))))] (m : M) (a : α) (S : Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3), (Membership.Mem.{u3, u3} M (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u3} R M _inst_1 _inst_2 _inst_3)) m S) -> (Membership.Mem.{u3, u3} M (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u3} R M _inst_1 _inst_2 _inst_3)) (SMul.smul.{u1, u3} α M (SMulZeroClass.toHasSmul.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (DistribSMul.toSmulZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5))) a m) (SMul.smul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (SMulZeroClass.toHasSmul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddZeroClass.toHasZero.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3)))) (DistribSMul.toSmulZeroClass.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3))) (DistribMulAction.toDistribSMul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) _inst_4 (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3)) (Submodule.pointwiseDistribMulAction.{u1, u2, u3} α R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)))) a S))
but is expected to have type
  forall {α : Type.{u1}} {R : Type.{u3}} {M : Type.{u2}} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u3, u2} R M _inst_1 _inst_2] [_inst_4 : Monoid.{u1} α] [_inst_5 : DistribMulAction.{u1, u2} α M _inst_4 (AddCommMonoid.toAddMonoid.{u2} M _inst_2)] [_inst_6 : SMulCommClass.{u1, u3, u2} α R M (SMulZeroClass.toSMul.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u2} α M _inst_4 (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_5))) (SMulZeroClass.toSMul.{u3, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u3, u2} R M (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u3, u2} R M _inst_1 _inst_2 _inst_3))))] (m : M) (a : α) (S : Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3), (Membership.mem.{u2, u2} M (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u3, u2} R M _inst_1 _inst_2 _inst_3)) m S) -> (Membership.mem.{u2, u2} M (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u3, u2} R M _inst_1 _inst_2 _inst_3)) (HSMul.hSMul.{u1, u2, u2} α M M (instHSMul.{u1, u2} α M (SMulZeroClass.toSMul.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u2} α M _inst_4 (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_5)))) a m) (HSMul.hSMul.{u1, u2, u2} α (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (instHSMul.{u1, u2} α (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (SMulZeroClass.toSMul.{u1, u2} α (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toZero.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u3, u2} R M _inst_1 _inst_2 _inst_3))) (DistribSMul.toSMulZeroClass.{u1, u2} α (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u3, u2} R M _inst_1 _inst_2 _inst_3))) (DistribMulAction.toDistribSMul.{u1, u2} α (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) _inst_4 (AddCommMonoid.toAddMonoid.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u3, u2} R M _inst_1 _inst_2 _inst_3)) (Submodule.pointwiseDistribMulAction.{u1, u3, u2} α R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6))))) a S))
Case conversion may be inaccurate. Consider using '#align submodule.smul_mem_pointwise_smul Submodule.smul_mem_pointwise_smulₓ'. -/
theorem smul_mem_pointwise_smul (m : M) (a : α) (S : Submodule R M) : m ∈ S → a • m ∈ a • S :=
  (Set.smul_mem_smul_set : _ → _ ∈ a • (S : Set M))
#align submodule.smul_mem_pointwise_smul Submodule.smul_mem_pointwise_smul

/- warning: submodule.smul_bot' -> Submodule.smul_bot' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_4 : Monoid.{u1} α] [_inst_5 : DistribMulAction.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_6 : SMulCommClass.{u1, u2, u3} α R M (SMulZeroClass.toHasSmul.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (DistribSMul.toSmulZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5))) (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_3))))] (a : α), Eq.{succ u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (SMul.smul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (SMulZeroClass.toHasSmul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddZeroClass.toHasZero.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3)))) (DistribSMul.toSmulZeroClass.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3))) (DistribMulAction.toDistribSMul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) _inst_4 (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3)) (Submodule.pointwiseDistribMulAction.{u1, u2, u3} α R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)))) a (Bot.bot.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.hasBot.{u2, u3} R M _inst_1 _inst_2 _inst_3))) (Bot.bot.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.hasBot.{u2, u3} R M _inst_1 _inst_2 _inst_3))
but is expected to have type
  forall {α : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_4 : Monoid.{u1} α] [_inst_5 : DistribMulAction.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_6 : SMulCommClass.{u1, u2, u3} α R M (SMulZeroClass.toSMul.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5))) (SMulZeroClass.toSMul.{u2, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u3} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_3))))] (a : α), Eq.{succ u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (HSMul.hSMul.{u1, u3, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (instHSMul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (SMulZeroClass.toSMul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toZero.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3))) (DistribSMul.toSMulZeroClass.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3))) (DistribMulAction.toDistribSMul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) _inst_4 (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3)) (Submodule.pointwiseDistribMulAction.{u1, u2, u3} α R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6))))) a (Bot.bot.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.instBotSubmodule.{u2, u3} R M _inst_1 _inst_2 _inst_3))) (Bot.bot.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.instBotSubmodule.{u2, u3} R M _inst_1 _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align submodule.smul_bot' Submodule.smul_bot'ₓ'. -/
/-- See also `submodule.smul_bot`. -/
@[simp]
theorem smul_bot' (a : α) : a • (⊥ : Submodule R M) = ⊥ :=
  map_bot _
#align submodule.smul_bot' Submodule.smul_bot'

/- warning: submodule.smul_sup' -> Submodule.smul_sup' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_4 : Monoid.{u1} α] [_inst_5 : DistribMulAction.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_6 : SMulCommClass.{u1, u2, u3} α R M (SMulZeroClass.toHasSmul.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (DistribSMul.toSmulZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5))) (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_3))))] (a : α) (S : Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (T : Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3), Eq.{succ u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (SMul.smul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (SMulZeroClass.toHasSmul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddZeroClass.toHasZero.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3)))) (DistribSMul.toSmulZeroClass.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3))) (DistribMulAction.toDistribSMul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) _inst_4 (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3)) (Submodule.pointwiseDistribMulAction.{u1, u2, u3} α R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)))) a (Sup.sup.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (SemilatticeSup.toHasSup.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Lattice.toSemilatticeSup.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toLattice.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u3} R M _inst_1 _inst_2 _inst_3))))) S T)) (Sup.sup.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (SemilatticeSup.toHasSup.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Lattice.toSemilatticeSup.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toLattice.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u3} R M _inst_1 _inst_2 _inst_3))))) (SMul.smul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (SMulZeroClass.toHasSmul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddZeroClass.toHasZero.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3)))) (DistribSMul.toSmulZeroClass.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3))) (DistribMulAction.toDistribSMul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) _inst_4 (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3)) (Submodule.pointwiseDistribMulAction.{u1, u2, u3} α R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)))) a S) (SMul.smul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (SMulZeroClass.toHasSmul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddZeroClass.toHasZero.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3)))) (DistribSMul.toSmulZeroClass.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3))) (DistribMulAction.toDistribSMul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) _inst_4 (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3)) (Submodule.pointwiseDistribMulAction.{u1, u2, u3} α R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)))) a T))
but is expected to have type
  forall {α : Type.{u1}} {R : Type.{u3}} {M : Type.{u2}} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u3, u2} R M _inst_1 _inst_2] [_inst_4 : Monoid.{u1} α] [_inst_5 : DistribMulAction.{u1, u2} α M _inst_4 (AddCommMonoid.toAddMonoid.{u2} M _inst_2)] [_inst_6 : SMulCommClass.{u1, u3, u2} α R M (SMulZeroClass.toSMul.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u2} α M _inst_4 (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_5))) (SMulZeroClass.toSMul.{u3, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u3, u2} R M (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u3, u2} R M _inst_1 _inst_2 _inst_3))))] (a : α) (S : Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (T : Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3), Eq.{succ u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (HSMul.hSMul.{u1, u2, u2} α (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (instHSMul.{u1, u2} α (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (SMulZeroClass.toSMul.{u1, u2} α (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toZero.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u3, u2} R M _inst_1 _inst_2 _inst_3))) (DistribSMul.toSMulZeroClass.{u1, u2} α (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u3, u2} R M _inst_1 _inst_2 _inst_3))) (DistribMulAction.toDistribSMul.{u1, u2} α (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) _inst_4 (AddCommMonoid.toAddMonoid.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u3, u2} R M _inst_1 _inst_2 _inst_3)) (Submodule.pointwiseDistribMulAction.{u1, u3, u2} α R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6))))) a (Sup.sup.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (SemilatticeSup.toSup.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u3, u2} R M _inst_1 _inst_2 _inst_3))))) S T)) (Sup.sup.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (SemilatticeSup.toSup.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u3, u2} R M _inst_1 _inst_2 _inst_3))))) (HSMul.hSMul.{u1, u2, u2} α (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (instHSMul.{u1, u2} α (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (SMulZeroClass.toSMul.{u1, u2} α (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toZero.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u3, u2} R M _inst_1 _inst_2 _inst_3))) (DistribSMul.toSMulZeroClass.{u1, u2} α (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u3, u2} R M _inst_1 _inst_2 _inst_3))) (DistribMulAction.toDistribSMul.{u1, u2} α (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) _inst_4 (AddCommMonoid.toAddMonoid.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u3, u2} R M _inst_1 _inst_2 _inst_3)) (Submodule.pointwiseDistribMulAction.{u1, u3, u2} α R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6))))) a S) (HSMul.hSMul.{u1, u2, u2} α (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (instHSMul.{u1, u2} α (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (SMulZeroClass.toSMul.{u1, u2} α (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toZero.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u3, u2} R M _inst_1 _inst_2 _inst_3))) (DistribSMul.toSMulZeroClass.{u1, u2} α (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u3, u2} R M _inst_1 _inst_2 _inst_3))) (DistribMulAction.toDistribSMul.{u1, u2} α (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) _inst_4 (AddCommMonoid.toAddMonoid.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u3, u2} R M _inst_1 _inst_2 _inst_3)) (Submodule.pointwiseDistribMulAction.{u1, u3, u2} α R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6))))) a T))
Case conversion may be inaccurate. Consider using '#align submodule.smul_sup' Submodule.smul_sup'ₓ'. -/
/-- See also `submodule.smul_sup`. -/
theorem smul_sup' (a : α) (S T : Submodule R M) : a • (S ⊔ T) = a • S ⊔ a • T :=
  map_sup _ _ _
#align submodule.smul_sup' Submodule.smul_sup'

/- warning: submodule.smul_span -> Submodule.smul_span is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_4 : Monoid.{u1} α] [_inst_5 : DistribMulAction.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_6 : SMulCommClass.{u1, u2, u3} α R M (SMulZeroClass.toHasSmul.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (DistribSMul.toSmulZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5))) (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_3))))] (a : α) (s : Set.{u3} M), Eq.{succ u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (SMul.smul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (SMulZeroClass.toHasSmul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddZeroClass.toHasZero.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3)))) (DistribSMul.toSmulZeroClass.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3))) (DistribMulAction.toDistribSMul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) _inst_4 (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3)) (Submodule.pointwiseDistribMulAction.{u1, u2, u3} α R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)))) a (Submodule.span.{u2, u3} R M _inst_1 _inst_2 _inst_3 s)) (Submodule.span.{u2, u3} R M _inst_1 _inst_2 _inst_3 (SMul.smul.{u1, u3} α (Set.{u3} M) (Set.smulSet.{u1, u3} α M (SMulZeroClass.toHasSmul.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (DistribSMul.toSmulZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5)))) a s))
but is expected to have type
  forall {α : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_4 : Monoid.{u1} α] [_inst_5 : DistribMulAction.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_6 : SMulCommClass.{u1, u2, u3} α R M (SMulZeroClass.toSMul.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5))) (SMulZeroClass.toSMul.{u2, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u3} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_3))))] (a : α) (s : Set.{u3} M), Eq.{succ u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (HSMul.hSMul.{u1, u3, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (instHSMul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (SMulZeroClass.toSMul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toZero.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3))) (DistribSMul.toSMulZeroClass.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3))) (DistribMulAction.toDistribSMul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) _inst_4 (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3)) (Submodule.pointwiseDistribMulAction.{u1, u2, u3} α R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6))))) a (Submodule.span.{u2, u3} R M _inst_1 _inst_2 _inst_3 s)) (Submodule.span.{u2, u3} R M _inst_1 _inst_2 _inst_3 (HSMul.hSMul.{u1, u3, u3} α (Set.{u3} M) (Set.{u3} M) (instHSMul.{u1, u3} α (Set.{u3} M) (Set.smulSet.{u1, u3} α M (SMulZeroClass.toSMul.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5))))) a s))
Case conversion may be inaccurate. Consider using '#align submodule.smul_span Submodule.smul_spanₓ'. -/
theorem smul_span (a : α) (s : Set M) : a • span R s = span R (a • s) :=
  map_span _ _
#align submodule.smul_span Submodule.smul_span

/- warning: submodule.span_smul -> Submodule.span_smul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_4 : Monoid.{u1} α] [_inst_5 : DistribMulAction.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_6 : SMulCommClass.{u1, u2, u3} α R M (SMulZeroClass.toHasSmul.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (DistribSMul.toSmulZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5))) (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_3))))] (a : α) (s : Set.{u3} M), Eq.{succ u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u2, u3} R M _inst_1 _inst_2 _inst_3 (SMul.smul.{u1, u3} α (Set.{u3} M) (Set.smulSet.{u1, u3} α M (SMulZeroClass.toHasSmul.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (DistribSMul.toSmulZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5)))) a s)) (SMul.smul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (SMulZeroClass.toHasSmul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddZeroClass.toHasZero.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3)))) (DistribSMul.toSmulZeroClass.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3))) (DistribMulAction.toDistribSMul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) _inst_4 (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3)) (Submodule.pointwiseDistribMulAction.{u1, u2, u3} α R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)))) a (Submodule.span.{u2, u3} R M _inst_1 _inst_2 _inst_3 s))
but is expected to have type
  forall {α : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_4 : Monoid.{u1} α] [_inst_5 : DistribMulAction.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_6 : SMulCommClass.{u1, u2, u3} α R M (SMulZeroClass.toSMul.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5))) (SMulZeroClass.toSMul.{u2, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u3} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_3))))] (a : α) (s : Set.{u3} M), Eq.{succ u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u2, u3} R M _inst_1 _inst_2 _inst_3 (HSMul.hSMul.{u1, u3, u3} α (Set.{u3} M) (Set.{u3} M) (instHSMul.{u1, u3} α (Set.{u3} M) (Set.smulSet.{u1, u3} α M (SMulZeroClass.toSMul.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5))))) a s)) (HSMul.hSMul.{u1, u3, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (instHSMul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (SMulZeroClass.toSMul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toZero.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3))) (DistribSMul.toSMulZeroClass.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3))) (DistribMulAction.toDistribSMul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) _inst_4 (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3)) (Submodule.pointwiseDistribMulAction.{u1, u2, u3} α R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6))))) a (Submodule.span.{u2, u3} R M _inst_1 _inst_2 _inst_3 s))
Case conversion may be inaccurate. Consider using '#align submodule.span_smul Submodule.span_smulₓ'. -/
theorem span_smul (a : α) (s : Set M) : span R (a • s) = a • span R s :=
  Eq.symm (span_image _).symm
#align submodule.span_smul Submodule.span_smul

/- warning: submodule.pointwise_central_scalar -> Submodule.pointwiseCentralScalar is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_4 : Monoid.{u1} α] [_inst_5 : DistribMulAction.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_6 : SMulCommClass.{u1, u2, u3} α R M (SMulZeroClass.toHasSmul.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (DistribSMul.toSmulZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5))) (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_3))))] [_inst_7 : DistribMulAction.{u1, u3} (MulOpposite.{u1} α) M (MulOpposite.monoid.{u1} α _inst_4) (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_8 : SMulCommClass.{u1, u2, u3} (MulOpposite.{u1} α) R M (SMulZeroClass.toHasSmul.{u1, u3} (MulOpposite.{u1} α) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (DistribSMul.toSmulZeroClass.{u1, u3} (MulOpposite.{u1} α) M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u3} (MulOpposite.{u1} α) M (MulOpposite.monoid.{u1} α _inst_4) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_7))) (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_3))))] [_inst_9 : IsCentralScalar.{u1, u3} α M (SMulZeroClass.toHasSmul.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (DistribSMul.toSmulZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5))) (SMulZeroClass.toHasSmul.{u1, u3} (MulOpposite.{u1} α) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (DistribSMul.toSmulZeroClass.{u1, u3} (MulOpposite.{u1} α) M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u3} (MulOpposite.{u1} α) M (MulOpposite.monoid.{u1} α _inst_4) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_7)))], IsCentralScalar.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (SMulZeroClass.toHasSmul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddZeroClass.toHasZero.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3)))) (DistribSMul.toSmulZeroClass.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3))) (DistribMulAction.toDistribSMul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) _inst_4 (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3)) (Submodule.pointwiseDistribMulAction.{u1, u2, u3} α R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)))) (SMulZeroClass.toHasSmul.{u1, u3} (MulOpposite.{u1} α) (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddZeroClass.toHasZero.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3)))) (DistribSMul.toSmulZeroClass.{u1, u3} (MulOpposite.{u1} α) (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3))) (DistribMulAction.toDistribSMul.{u1, u3} (MulOpposite.{u1} α) (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (MulOpposite.monoid.{u1} α _inst_4) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3)) (Submodule.pointwiseDistribMulAction.{u1, u2, u3} (MulOpposite.{u1} α) R M _inst_1 _inst_2 _inst_3 (MulOpposite.monoid.{u1} α _inst_4) _inst_7 _inst_8))))
but is expected to have type
  forall {α : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_4 : Monoid.{u1} α] [_inst_5 : DistribMulAction.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_6 : SMulCommClass.{u1, u2, u3} α R M (SMulZeroClass.toSMul.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5))) (SMulZeroClass.toSMul.{u2, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u3} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_3))))] [_inst_7 : DistribMulAction.{u1, u3} (MulOpposite.{u1} α) M (MulOpposite.monoid.{u1} α _inst_4) (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_8 : SMulCommClass.{u1, u2, u3} (MulOpposite.{u1} α) R M (SMulZeroClass.toSMul.{u1, u3} (MulOpposite.{u1} α) M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u3} (MulOpposite.{u1} α) M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u3} (MulOpposite.{u1} α) M (MulOpposite.monoid.{u1} α _inst_4) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_7))) (SMulZeroClass.toSMul.{u2, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u3} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_3))))] [_inst_9 : IsCentralScalar.{u1, u3} α M (SMulZeroClass.toSMul.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u3} α M _inst_4 (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5))) (SMulZeroClass.toSMul.{u1, u3} (MulOpposite.{u1} α) M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u3} (MulOpposite.{u1} α) M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u3} (MulOpposite.{u1} α) M (MulOpposite.monoid.{u1} α _inst_4) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_7)))], IsCentralScalar.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (SMulZeroClass.toSMul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toZero.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3))) (DistribSMul.toSMulZeroClass.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3))) (DistribMulAction.toDistribSMul.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) _inst_4 (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3)) (Submodule.pointwiseDistribMulAction.{u1, u2, u3} α R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)))) (SMulZeroClass.toSMul.{u1, u3} (MulOpposite.{u1} α) (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toZero.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3))) (DistribSMul.toSMulZeroClass.{u1, u3} (MulOpposite.{u1} α) (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3))) (DistribMulAction.toDistribSMul.{u1, u3} (MulOpposite.{u1} α) (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (MulOpposite.monoid.{u1} α _inst_4) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3)) (Submodule.pointwiseDistribMulAction.{u1, u2, u3} (MulOpposite.{u1} α) R M _inst_1 _inst_2 _inst_3 (MulOpposite.monoid.{u1} α _inst_4) _inst_7 _inst_8))))
Case conversion may be inaccurate. Consider using '#align submodule.pointwise_central_scalar Submodule.pointwiseCentralScalarₓ'. -/
instance pointwiseCentralScalar [DistribMulAction αᵐᵒᵖ M] [SMulCommClass αᵐᵒᵖ R M]
    [IsCentralScalar α M] : IsCentralScalar α (Submodule R M) :=
  ⟨fun a S => (congr_arg fun f : Module.End R M => S.map f) <| LinearMap.ext <| op_smul_eq_smul _⟩
#align submodule.pointwise_central_scalar Submodule.pointwiseCentralScalar

/- warning: submodule.smul_le_self_of_tower -> Submodule.smul_le_self_of_tower is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {α : Type.{u3}} [_inst_7 : Semiring.{u3} α] [_inst_8 : Module.{u3, u1} α R _inst_7 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))] [_inst_9 : Module.{u3, u2} α M _inst_7 _inst_2] [_inst_10 : SMulCommClass.{u3, u1, u2} α R M (SMulZeroClass.toHasSmul.{u3, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u3, u2} α M (MulZeroClass.toHasZero.{u3} α (MulZeroOneClass.toMulZeroClass.{u3} α (MonoidWithZero.toMulZeroOneClass.{u3} α (Semiring.toMonoidWithZero.{u3} α _inst_7)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u3, u2} α M (Semiring.toMonoidWithZero.{u3} α _inst_7) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u3, u2} α M _inst_7 _inst_2 _inst_9)))) (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))] [_inst_11 : IsScalarTower.{u3, u1, u2} α R M (SMulZeroClass.toHasSmul.{u3, u1} α R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (SMulWithZero.toSmulZeroClass.{u3, u1} α R (MulZeroClass.toHasZero.{u3} α (MulZeroOneClass.toMulZeroClass.{u3} α (MonoidWithZero.toMulZeroOneClass.{u3} α (Semiring.toMonoidWithZero.{u3} α _inst_7)))) (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (MulActionWithZero.toSMulWithZero.{u3, u1} α R (Semiring.toMonoidWithZero.{u3} α _inst_7) (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (Module.toMulActionWithZero.{u3, u1} α R _inst_7 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_8)))) (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (SMulZeroClass.toHasSmul.{u3, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u3, u2} α M (MulZeroClass.toHasZero.{u3} α (MulZeroOneClass.toMulZeroClass.{u3} α (MonoidWithZero.toMulZeroOneClass.{u3} α (Semiring.toMonoidWithZero.{u3} α _inst_7)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u3, u2} α M (Semiring.toMonoidWithZero.{u3} α _inst_7) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u3, u2} α M _inst_7 _inst_2 _inst_9))))] (a : α) (S : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3), LE.le.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (SMul.smul.{u3, u2} α (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SMulZeroClass.toHasSmul.{u3, u2} α (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (AddZeroClass.toHasZero.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (DistribSMul.toSmulZeroClass.{u3, u2} α (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (DistribMulAction.toDistribSMul.{u3, u2} α (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (MonoidWithZero.toMonoid.{u3} α (Semiring.toMonoidWithZero.{u3} α _inst_7)) (AddCommMonoid.toAddMonoid.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Submodule.pointwiseDistribMulAction.{u3, u1, u2} α R M _inst_1 _inst_2 _inst_3 (MonoidWithZero.toMonoid.{u3} α (Semiring.toMonoidWithZero.{u3} α _inst_7)) (Module.toDistribMulAction.{u3, u2} α M _inst_7 _inst_2 _inst_9) _inst_10)))) a S) S
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] {α : Type.{u3}} [_inst_7 : Semiring.{u3} α] [_inst_8 : Module.{u3, u2} α R _inst_7 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))] [_inst_9 : Module.{u3, u1} α M _inst_7 _inst_2] [_inst_10 : SMulCommClass.{u3, u2, u1} α R M (SMulZeroClass.toSMul.{u3, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u3, u1} α M (MonoidWithZero.toZero.{u3} α (Semiring.toMonoidWithZero.{u3} α _inst_7)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u3, u1} α M (Semiring.toMonoidWithZero.{u3} α _inst_7) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u3, u1} α M _inst_7 _inst_2 _inst_9)))) (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 _inst_3))))] [_inst_11 : IsScalarTower.{u3, u2, u1} α R M (SMulZeroClass.toSMul.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (SMulWithZero.toSMulZeroClass.{u3, u2} α R (MonoidWithZero.toZero.{u3} α (Semiring.toMonoidWithZero.{u3} α _inst_7)) (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (MulActionWithZero.toSMulWithZero.{u3, u2} α R (Semiring.toMonoidWithZero.{u3} α _inst_7) (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (Module.toMulActionWithZero.{u3, u2} α R _inst_7 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) _inst_8)))) (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 _inst_3)))) (SMulZeroClass.toSMul.{u3, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u3, u1} α M (MonoidWithZero.toZero.{u3} α (Semiring.toMonoidWithZero.{u3} α _inst_7)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u3, u1} α M (Semiring.toMonoidWithZero.{u3} α _inst_7) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u3, u1} α M _inst_7 _inst_2 _inst_9))))] (a : α) (S : Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3), LE.le.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))))) (HSMul.hSMul.{u3, u1, u1} α (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (instHSMul.{u3, u1} α (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SMulZeroClass.toSMul.{u3, u1} α (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toZero.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3))) (DistribSMul.toSMulZeroClass.{u3, u1} α (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3))) (DistribMulAction.toDistribSMul.{u3, u1} α (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (MonoidWithZero.toMonoid.{u3} α (Semiring.toMonoidWithZero.{u3} α _inst_7)) (AddCommMonoid.toAddMonoid.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3)) (Submodule.pointwiseDistribMulAction.{u3, u2, u1} α R M _inst_1 _inst_2 _inst_3 (MonoidWithZero.toMonoid.{u3} α (Semiring.toMonoidWithZero.{u3} α _inst_7)) (Module.toDistribMulAction.{u3, u1} α M _inst_7 _inst_2 _inst_9) _inst_10))))) a S) S
Case conversion may be inaccurate. Consider using '#align submodule.smul_le_self_of_tower Submodule.smul_le_self_of_towerₓ'. -/
@[simp]
theorem smul_le_self_of_tower {α : Type _} [Semiring α] [Module α R] [Module α M]
    [SMulCommClass α R M] [IsScalarTower α R M] (a : α) (S : Submodule R M) : a • S ≤ S :=
  by
  rintro y ⟨x, hx, rfl⟩
  exact smul_of_tower_mem _ a hx
#align submodule.smul_le_self_of_tower Submodule.smul_le_self_of_tower

end

section

variable [Semiring α] [Module α M] [SMulCommClass α R M]

/- warning: submodule.pointwise_mul_action_with_zero -> Submodule.pointwiseMulActionWithZero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_4 : Semiring.{u1} α] [_inst_5 : Module.{u1, u3} α M _inst_4 _inst_2] [_inst_6 : SMulCommClass.{u1, u2, u3} α R M (SMulZeroClass.toHasSmul.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u3} α M (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (Semiring.toMonoidWithZero.{u1} α _inst_4)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} α M (Semiring.toMonoidWithZero.{u1} α _inst_4) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u1, u3} α M _inst_4 _inst_2 _inst_5)))) (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_3))))], MulActionWithZero.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Semiring.toMonoidWithZero.{u1} α _inst_4) (AddZeroClass.toHasZero.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddMonoid.toAddZeroClass.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3))))
but is expected to have type
  forall {α : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_4 : Semiring.{u1} α] [_inst_5 : Module.{u1, u3} α M _inst_4 _inst_2] [_inst_6 : SMulCommClass.{u1, u2, u3} α R M (SMulZeroClass.toSMul.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u3} α M (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α _inst_4)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u3} α M (Semiring.toMonoidWithZero.{u1} α _inst_4) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u1, u3} α M _inst_4 _inst_2 _inst_5)))) (SMulZeroClass.toSMul.{u2, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u3} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_3))))], MulActionWithZero.{u1, u3} α (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Semiring.toMonoidWithZero.{u1} α _inst_4) (AddMonoid.toZero.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (AddCommMonoid.toAddMonoid.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.pointwiseAddCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_3)))
Case conversion may be inaccurate. Consider using '#align submodule.pointwise_mul_action_with_zero Submodule.pointwiseMulActionWithZeroₓ'. -/
/-- The action on a submodule corresponding to applying the action to every element.

This is available as an instance in the `pointwise` locale.

This is a stronger version of `submodule.pointwise_distrib_mul_action`. Note that `add_smul` does
not hold so this cannot be stated as a `module`. -/
protected def pointwiseMulActionWithZero : MulActionWithZero α (Submodule R M) :=
  { Submodule.pointwiseDistribMulAction with
    zero_smul := fun S =>
      (congr_arg (fun f : M →ₗ[R] M => S.map f) (LinearMap.ext <| zero_smul α)).trans S.map_zero }
#align submodule.pointwise_mul_action_with_zero Submodule.pointwiseMulActionWithZero

scoped[Pointwise] attribute [instance] Submodule.pointwiseMulActionWithZero

end

end Submodule

