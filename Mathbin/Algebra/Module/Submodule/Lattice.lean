/-
Copyright (c) 2017 Johannes Hölzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes Hölzl, Mario Carneiro, Kevin Buzzard, Yury Kudryashov

! This file was ported from Lean 3 source module algebra.module.submodule.lattice
! leanprover-community/mathlib commit 2738d2ca56cbc63be80c3bd48e9ed90ad94e947d
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Module.Submodule.Basic
import Mathbin.Algebra.PunitInstances

/-!
# The lattice structure on `submodule`s

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file defines the lattice structure on submodules, `submodule.complete_lattice`, with `⊥`
defined as `{0}` and `⊓` defined as intersection of the underlying carrier.
If `p` and `q` are submodules of a module, `p ≤ q` means that `p ⊆ q`.

Many results about operations on this lattice structure are defined in `linear_algebra/basic.lean`,
most notably those which use `span`.

## Implementation notes

This structure should match the `add_submonoid.complete_lattice` structure, and we should try
to unify the APIs where possible.

-/


variable {R S M : Type _}

section AddCommMonoid

variable [Semiring R] [Semiring S] [AddCommMonoid M] [Module R M] [Module S M]

variable [SMul S R] [IsScalarTower S R M]

variable {p q : Submodule R M}

namespace Submodule

/-- The set `{0}` is the bottom element of the lattice of submodules. -/
instance : Bot (Submodule R M) :=
  ⟨{ (⊥ : AddSubmonoid M) with
      carrier := {0}
      smul_mem' := by simp (config := { contextual := true }) }⟩

#print Submodule.inhabited' /-
instance inhabited' : Inhabited (Submodule R M) :=
  ⟨⊥⟩
#align submodule.inhabited' Submodule.inhabited'
-/

/- warning: submodule.bot_coe -> Submodule.bot_coe is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3], Eq.{succ u2} (Set.{u2} M) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)))) (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.hasBot.{u1, u2} R M _inst_1 _inst_3 _inst_4))) (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3], Eq.{succ u2} (Set.{u2} M) (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.instBotSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4))) (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.instSingletonSet.{u2} M) (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))))
Case conversion may be inaccurate. Consider using '#align submodule.bot_coe Submodule.bot_coeₓ'. -/
@[simp]
theorem bot_coe : ((⊥ : Submodule R M) : Set M) = {0} :=
  rfl
#align submodule.bot_coe Submodule.bot_coe

/- warning: submodule.bot_to_add_submonoid -> Submodule.bot_toAddSubmonoid is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3], Eq.{succ u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.toAddSubmonoid.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.hasBot.{u1, u2} R M _inst_1 _inst_3 _inst_4))) (Bot.bot.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddSubmonoid.hasBot.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3], Eq.{succ u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.toAddSubmonoid.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.instBotSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4))) (Bot.bot.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddSubmonoid.instBotAddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))))
Case conversion may be inaccurate. Consider using '#align submodule.bot_to_add_submonoid Submodule.bot_toAddSubmonoidₓ'. -/
@[simp]
theorem bot_toAddSubmonoid : (⊥ : Submodule R M).toAddSubmonoid = ⊥ :=
  rfl
#align submodule.bot_to_add_submonoid Submodule.bot_toAddSubmonoid

section

variable (R)

/- warning: submodule.restrict_scalars_bot -> Submodule.restrictScalars_bot is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {S : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_4 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_5 : Module.{u2, u3} S M _inst_2 _inst_3] [_inst_6 : SMul.{u2, u1} S R] [_inst_7 : IsScalarTower.{u2, u1, u3} S R M _inst_6 (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_3 _inst_4)))) (SMulZeroClass.toHasSmul.{u2, u3} S M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u2, u3} S M (MulZeroClass.toHasZero.{u2} S (MulZeroOneClass.toMulZeroClass.{u2} S (MonoidWithZero.toMulZeroOneClass.{u2} S (Semiring.toMonoidWithZero.{u2} S _inst_2)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u2, u3} S M (Semiring.toMonoidWithZero.{u2} S _inst_2) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Module.toMulActionWithZero.{u2, u3} S M _inst_2 _inst_3 _inst_5))))], Eq.{succ u3} (Submodule.{u2, u3} S M _inst_2 _inst_3 _inst_5) (Submodule.restrictScalars.{u2, u1, u3} S R M _inst_1 _inst_3 _inst_2 _inst_5 _inst_4 _inst_6 _inst_7 (Bot.bot.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_3 _inst_4) (Submodule.hasBot.{u1, u3} R M _inst_1 _inst_3 _inst_4))) (Bot.bot.{u3} (Submodule.{u2, u3} S M _inst_2 _inst_3 _inst_5) (Submodule.hasBot.{u2, u3} S M _inst_2 _inst_3 _inst_5))
but is expected to have type
  forall (R : Type.{u1}) {S : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_4 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_5 : Module.{u2, u3} S M _inst_2 _inst_3] [_inst_6 : SMul.{u2, u1} S R] [_inst_7 : IsScalarTower.{u2, u1, u3} S R M _inst_6 (SMulZeroClass.toSMul.{u1, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u1, u3} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_3 _inst_4)))) (SMulZeroClass.toSMul.{u2, u3} S M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u2, u3} S M (MonoidWithZero.toZero.{u2} S (Semiring.toMonoidWithZero.{u2} S _inst_2)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u2, u3} S M (Semiring.toMonoidWithZero.{u2} S _inst_2) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (Module.toMulActionWithZero.{u2, u3} S M _inst_2 _inst_3 _inst_5))))], Eq.{succ u3} (Submodule.{u2, u3} S M _inst_2 _inst_3 _inst_5) (Submodule.restrictScalars.{u2, u1, u3} S R M _inst_1 _inst_3 _inst_2 _inst_5 _inst_4 _inst_6 _inst_7 (Bot.bot.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_3 _inst_4) (Submodule.instBotSubmodule.{u1, u3} R M _inst_1 _inst_3 _inst_4))) (Bot.bot.{u3} (Submodule.{u2, u3} S M _inst_2 _inst_3 _inst_5) (Submodule.instBotSubmodule.{u2, u3} S M _inst_2 _inst_3 _inst_5))
Case conversion may be inaccurate. Consider using '#align submodule.restrict_scalars_bot Submodule.restrictScalars_botₓ'. -/
@[simp]
theorem restrictScalars_bot : restrictScalars S (⊥ : Submodule R M) = ⊥ :=
  rfl
#align submodule.restrict_scalars_bot Submodule.restrictScalars_bot

/- warning: submodule.mem_bot -> Submodule.mem_bot is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {x : M}, Iff (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.hasBot.{u1, u2} R M _inst_1 _inst_3 _inst_4))) (Eq.{succ u2} M x (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))))))
but is expected to have type
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {x : M}, Iff (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.instBotSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4))) (Eq.{succ u2} M x (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))))
Case conversion may be inaccurate. Consider using '#align submodule.mem_bot Submodule.mem_botₓ'. -/
@[simp]
theorem mem_bot {x : M} : x ∈ (⊥ : Submodule R M) ↔ x = 0 :=
  Set.mem_singleton_iff
#align submodule.mem_bot Submodule.mem_bot

end

/- warning: submodule.restrict_scalars_eq_bot_iff -> Submodule.restrictScalars_eq_bot_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_4 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_5 : Module.{u2, u3} S M _inst_2 _inst_3] [_inst_6 : SMul.{u2, u1} S R] [_inst_7 : IsScalarTower.{u2, u1, u3} S R M _inst_6 (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_3 _inst_4)))) (SMulZeroClass.toHasSmul.{u2, u3} S M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u2, u3} S M (MulZeroClass.toHasZero.{u2} S (MulZeroOneClass.toMulZeroClass.{u2} S (MonoidWithZero.toMulZeroOneClass.{u2} S (Semiring.toMonoidWithZero.{u2} S _inst_2)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u2, u3} S M (Semiring.toMonoidWithZero.{u2} S _inst_2) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Module.toMulActionWithZero.{u2, u3} S M _inst_2 _inst_3 _inst_5))))] {p : Submodule.{u1, u3} R M _inst_1 _inst_3 _inst_4}, Iff (Eq.{succ u3} (Submodule.{u2, u3} S M _inst_2 _inst_3 _inst_5) (Submodule.restrictScalars.{u2, u1, u3} S R M _inst_1 _inst_3 _inst_2 _inst_5 _inst_4 _inst_6 _inst_7 p) (Bot.bot.{u3} (Submodule.{u2, u3} S M _inst_2 _inst_3 _inst_5) (Submodule.hasBot.{u2, u3} S M _inst_2 _inst_3 _inst_5))) (Eq.{succ u3} (Submodule.{u1, u3} R M _inst_1 _inst_3 _inst_4) p (Bot.bot.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_3 _inst_4) (Submodule.hasBot.{u1, u3} R M _inst_1 _inst_3 _inst_4)))
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u3} R] [_inst_2 : Semiring.{u1} S] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] [_inst_5 : Module.{u1, u2} S M _inst_2 _inst_3] [_inst_6 : SMul.{u1, u3} S R] [_inst_7 : IsScalarTower.{u1, u3, u2} S R M _inst_6 (SMulZeroClass.toSMul.{u3, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u3, u2} R M (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (Module.toMulActionWithZero.{u3, u2} R M _inst_1 _inst_3 _inst_4)))) (SMulZeroClass.toSMul.{u1, u2} S M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u1, u2} S M (MonoidWithZero.toZero.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_2)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u1, u2} S M (Semiring.toMonoidWithZero.{u1} S _inst_2) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (Module.toMulActionWithZero.{u1, u2} S M _inst_2 _inst_3 _inst_5))))] {p : Submodule.{u3, u2} R M _inst_1 _inst_3 _inst_4}, Iff (Eq.{succ u2} (Submodule.{u1, u2} S M _inst_2 _inst_3 _inst_5) (Submodule.restrictScalars.{u1, u3, u2} S R M _inst_1 _inst_3 _inst_2 _inst_5 _inst_4 _inst_6 _inst_7 p) (Bot.bot.{u2} (Submodule.{u1, u2} S M _inst_2 _inst_3 _inst_5) (Submodule.instBotSubmodule.{u1, u2} S M _inst_2 _inst_3 _inst_5))) (Eq.{succ u2} (Submodule.{u3, u2} R M _inst_1 _inst_3 _inst_4) p (Bot.bot.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.instBotSubmodule.{u3, u2} R M _inst_1 _inst_3 _inst_4)))
Case conversion may be inaccurate. Consider using '#align submodule.restrict_scalars_eq_bot_iff Submodule.restrictScalars_eq_bot_iffₓ'. -/
@[simp]
theorem restrictScalars_eq_bot_iff {p : Submodule R M} : restrictScalars S p = ⊥ ↔ p = ⊥ := by
  simp [SetLike.ext_iff]
#align submodule.restrict_scalars_eq_bot_iff Submodule.restrictScalars_eq_bot_iff

/- warning: submodule.unique_bot -> Submodule.uniqueBot is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3], Unique.{succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.hasBot.{u1, u2} R M _inst_1 _inst_3 _inst_4)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3], Unique.{succ u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.instBotSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4))))
Case conversion may be inaccurate. Consider using '#align submodule.unique_bot Submodule.uniqueBotₓ'. -/
instance uniqueBot : Unique (⊥ : Submodule R M) :=
  ⟨inferInstance, fun x => Subtype.ext <| (mem_bot R).1 x.Mem⟩
#align submodule.unique_bot Submodule.uniqueBot

instance : OrderBot (Submodule R M) where
  bot := ⊥
  bot_le p x := by simp (config := { contextual := true }) [zero_mem]

/- warning: submodule.eq_bot_iff -> Submodule.eq_bot_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] (p : Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4), Iff (Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) p (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.hasBot.{u1, u2} R M _inst_1 _inst_3 _inst_4))) (forall (x : M), (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x p) -> (Eq.{succ u2} M x (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))))))))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] (p : Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4), Iff (Eq.{succ u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) p (Bot.bot.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (Submodule.instBotSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4))) (forall (x : M), (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) x p) -> (Eq.{succ u1} M x (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))))
Case conversion may be inaccurate. Consider using '#align submodule.eq_bot_iff Submodule.eq_bot_iffₓ'. -/
protected theorem eq_bot_iff (p : Submodule R M) : p = ⊥ ↔ ∀ x ∈ p, x = (0 : M) :=
  ⟨fun h => h.symm ▸ fun x hx => (mem_bot R).mp hx, fun h =>
    eq_bot_iff.mpr fun x hx => (mem_bot R).mpr (h x hx)⟩
#align submodule.eq_bot_iff Submodule.eq_bot_iff

/- warning: submodule.bot_ext -> Submodule.bot_ext is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.hasBot.{u1, u2} R M _inst_1 _inst_3 _inst_4))) (y : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.hasBot.{u1, u2} R M _inst_1 _inst_3 _inst_4))), Eq.{succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.hasBot.{u1, u2} R M _inst_1 _inst_3 _inst_4))) x y
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] (x : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.instBotSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)))) (y : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.instBotSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)))), Eq.{succ u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.instBotSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)))) x y
Case conversion may be inaccurate. Consider using '#align submodule.bot_ext Submodule.bot_extₓ'. -/
@[ext]
protected theorem bot_ext (x y : (⊥ : Submodule R M)) : x = y :=
  by
  rcases x with ⟨x, xm⟩; rcases y with ⟨y, ym⟩; congr
  rw [(Submodule.eq_bot_iff _).mp rfl x xm]
  rw [(Submodule.eq_bot_iff _).mp rfl y ym]
#align submodule.bot_ext Submodule.bot_ext

/- warning: submodule.ne_bot_iff -> Submodule.ne_bot_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] (p : Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4), Iff (Ne.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) p (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.hasBot.{u1, u2} R M _inst_1 _inst_3 _inst_4))) (Exists.{succ u2} M (fun (x : M) => Exists.{0} (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x p) (fun (H : Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x p) => Ne.{succ u2} M x (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))))))))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] (p : Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4), Iff (Ne.{succ u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) p (Bot.bot.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (Submodule.instBotSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4))) (Exists.{succ u1} M (fun (x : M) => And (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) x p) (Ne.{succ u1} M x (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))))))
Case conversion may be inaccurate. Consider using '#align submodule.ne_bot_iff Submodule.ne_bot_iffₓ'. -/
protected theorem ne_bot_iff (p : Submodule R M) : p ≠ ⊥ ↔ ∃ x ∈ p, x ≠ (0 : M) :=
  by
  haveI := Classical.propDecidable
  simp_rw [Ne.def, p.eq_bot_iff, not_forall]
#align submodule.ne_bot_iff Submodule.ne_bot_iff

/- warning: submodule.nonzero_mem_of_bot_lt -> Submodule.nonzero_mem_of_bot_lt is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {p : Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4}, (LT.lt.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Preorder.toLT.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)))) (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.hasBot.{u1, u2} R M _inst_1 _inst_3 _inst_4)) p) -> (Exists.{succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) p) (fun (a : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) p) => Ne.{succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) p) a (OfNat.ofNat.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) p) 0 (OfNat.mk.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) p) 0 (Zero.zero.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) p) (Submodule.hasZero.{u1, u2} R M _inst_1 _inst_3 _inst_4 p))))))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] {p : Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4}, (LT.lt.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (Preorder.toLT.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instPartialOrder.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)))) (Bot.bot.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (Submodule.instBotSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) p) -> (Exists.{succ u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) x p)) (fun (a : Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) x p)) => Ne.{succ u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) x p)) a (OfNat.ofNat.{u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) x p)) 0 (Zero.toOfNat0.{u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) x p)) (Submodule.instZeroSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4 p)))))
Case conversion may be inaccurate. Consider using '#align submodule.nonzero_mem_of_bot_lt Submodule.nonzero_mem_of_bot_ltₓ'. -/
theorem nonzero_mem_of_bot_lt {p : Submodule R M} (bot_lt : ⊥ < p) : ∃ a : p, a ≠ 0 :=
  let ⟨b, hb₁, hb₂⟩ := p.ne_bot_iff.mp bot_lt.ne'
  ⟨⟨b, hb₁⟩, hb₂ ∘ congr_arg coe⟩
#align submodule.nonzero_mem_of_bot_lt Submodule.nonzero_mem_of_bot_lt

/- warning: submodule.exists_mem_ne_zero_of_ne_bot -> Submodule.exists_mem_ne_zero_of_ne_bot is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {p : Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4}, (Ne.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) p (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.hasBot.{u1, u2} R M _inst_1 _inst_3 _inst_4))) -> (Exists.{succ u2} M (fun (b : M) => And (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) b p) (Ne.{succ u2} M b (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))))))))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] {p : Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4}, (Ne.{succ u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) p (Bot.bot.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (Submodule.instBotSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4))) -> (Exists.{succ u1} M (fun (b : M) => And (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) b p) (Ne.{succ u1} M b (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))))))
Case conversion may be inaccurate. Consider using '#align submodule.exists_mem_ne_zero_of_ne_bot Submodule.exists_mem_ne_zero_of_ne_botₓ'. -/
theorem exists_mem_ne_zero_of_ne_bot {p : Submodule R M} (h : p ≠ ⊥) : ∃ b : M, b ∈ p ∧ b ≠ 0 :=
  let ⟨b, hb₁, hb₂⟩ := p.ne_bot_iff.mp h
  ⟨b, hb₁, hb₂⟩
#align submodule.exists_mem_ne_zero_of_ne_bot Submodule.exists_mem_ne_zero_of_ne_bot

/- warning: submodule.bot_equiv_punit -> Submodule.botEquivPUnit is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3], LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.hasBot.{u1, u2} R M _inst_1 _inst_3 _inst_4))) PUnit.{succ u3} (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.hasBot.{u1, u2} R M _inst_1 _inst_3 _inst_4))) (AddCommGroup.toAddCommMonoid.{u3} PUnit.{succ u3} PUnit.addCommGroup.{u3}) (Submodule.module.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.hasBot.{u1, u2} R M _inst_1 _inst_3 _inst_4))) (PUnit.module.{u1, u3} R _inst_1)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3], LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.instBotSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)))) PUnit.{succ u3} (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.instBotSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u3} PUnit.{succ u3} (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u3} PUnit.{succ u3} PUnit.linearOrderedCancelAddCommMonoid.{u3})) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.instBotSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4))) (PUnit.module.{u1, u3} R _inst_1)
Case conversion may be inaccurate. Consider using '#align submodule.bot_equiv_punit Submodule.botEquivPUnitₓ'. -/
/-- The bottom submodule is linearly equivalent to punit as an `R`-module. -/
@[simps]
def botEquivPUnit : (⊥ : Submodule R M) ≃ₗ[R] PUnit
    where
  toFun x := PUnit.unit
  invFun x := 0
  map_add' := by
    intros
    ext
  map_smul' := by
    intros
    ext
  left_inv := by
    intro x
    ext
  right_inv := by
    intro x
    ext
#align submodule.bot_equiv_punit Submodule.botEquivPUnit

/- warning: submodule.eq_bot_of_subsingleton -> Submodule.eq_bot_of_subsingleton is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] (p : Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) [_inst_8 : Subsingleton.{succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) p)], Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) p (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.hasBot.{u1, u2} R M _inst_1 _inst_3 _inst_4))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] (p : Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) [_inst_8 : Subsingleton.{succ u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) x p))], Eq.{succ u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) p (Bot.bot.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (Submodule.instBotSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4))
Case conversion may be inaccurate. Consider using '#align submodule.eq_bot_of_subsingleton Submodule.eq_bot_of_subsingletonₓ'. -/
theorem eq_bot_of_subsingleton (p : Submodule R M) [Subsingleton p] : p = ⊥ :=
  by
  rw [eq_bot_iff]
  intro v hv
  exact congr_arg coe (Subsingleton.elim (⟨v, hv⟩ : p) 0)
#align submodule.eq_bot_of_subsingleton Submodule.eq_bot_of_subsingleton

/-- The universal set is the top element of the lattice of submodules. -/
instance : Top (Submodule R M) :=
  ⟨{ (⊤ : AddSubmonoid M) with
      carrier := Set.univ
      smul_mem' := fun _ _ _ => trivial }⟩

/- warning: submodule.top_coe -> Submodule.top_coe is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3], Eq.{succ u2} (Set.{u2} M) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)))) (Top.top.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.hasTop.{u1, u2} R M _inst_1 _inst_3 _inst_4))) (Set.univ.{u2} M)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3], Eq.{succ u2} (Set.{u2} M) (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Top.top.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.instTopSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4))) (Set.univ.{u2} M)
Case conversion may be inaccurate. Consider using '#align submodule.top_coe Submodule.top_coeₓ'. -/
@[simp]
theorem top_coe : ((⊤ : Submodule R M) : Set M) = Set.univ :=
  rfl
#align submodule.top_coe Submodule.top_coe

/- warning: submodule.top_to_add_submonoid -> Submodule.top_toAddSubmonoid is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3], Eq.{succ u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.toAddSubmonoid.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Top.top.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.hasTop.{u1, u2} R M _inst_1 _inst_3 _inst_4))) (Top.top.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddSubmonoid.hasTop.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3], Eq.{succ u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.toAddSubmonoid.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Top.top.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.instTopSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4))) (Top.top.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddSubmonoid.instTopAddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))))
Case conversion may be inaccurate. Consider using '#align submodule.top_to_add_submonoid Submodule.top_toAddSubmonoidₓ'. -/
@[simp]
theorem top_toAddSubmonoid : (⊤ : Submodule R M).toAddSubmonoid = ⊤ :=
  rfl
#align submodule.top_to_add_submonoid Submodule.top_toAddSubmonoid

/- warning: submodule.mem_top -> Submodule.mem_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {x : M}, Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x (Top.top.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.hasTop.{u1, u2} R M _inst_1 _inst_3 _inst_4))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {x : M}, Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x (Top.top.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.instTopSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4))
Case conversion may be inaccurate. Consider using '#align submodule.mem_top Submodule.mem_topₓ'. -/
@[simp]
theorem mem_top {x : M} : x ∈ (⊤ : Submodule R M) :=
  trivial
#align submodule.mem_top Submodule.mem_top

section

variable (R)

/- warning: submodule.restrict_scalars_top -> Submodule.restrictScalars_top is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {S : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_4 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_5 : Module.{u2, u3} S M _inst_2 _inst_3] [_inst_6 : SMul.{u2, u1} S R] [_inst_7 : IsScalarTower.{u2, u1, u3} S R M _inst_6 (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_3 _inst_4)))) (SMulZeroClass.toHasSmul.{u2, u3} S M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u2, u3} S M (MulZeroClass.toHasZero.{u2} S (MulZeroOneClass.toMulZeroClass.{u2} S (MonoidWithZero.toMulZeroOneClass.{u2} S (Semiring.toMonoidWithZero.{u2} S _inst_2)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u2, u3} S M (Semiring.toMonoidWithZero.{u2} S _inst_2) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Module.toMulActionWithZero.{u2, u3} S M _inst_2 _inst_3 _inst_5))))], Eq.{succ u3} (Submodule.{u2, u3} S M _inst_2 _inst_3 _inst_5) (Submodule.restrictScalars.{u2, u1, u3} S R M _inst_1 _inst_3 _inst_2 _inst_5 _inst_4 _inst_6 _inst_7 (Top.top.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_3 _inst_4) (Submodule.hasTop.{u1, u3} R M _inst_1 _inst_3 _inst_4))) (Top.top.{u3} (Submodule.{u2, u3} S M _inst_2 _inst_3 _inst_5) (Submodule.hasTop.{u2, u3} S M _inst_2 _inst_3 _inst_5))
but is expected to have type
  forall (R : Type.{u1}) {S : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_4 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_5 : Module.{u2, u3} S M _inst_2 _inst_3] [_inst_6 : SMul.{u2, u1} S R] [_inst_7 : IsScalarTower.{u2, u1, u3} S R M _inst_6 (SMulZeroClass.toSMul.{u1, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u1, u3} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_3 _inst_4)))) (SMulZeroClass.toSMul.{u2, u3} S M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u2, u3} S M (MonoidWithZero.toZero.{u2} S (Semiring.toMonoidWithZero.{u2} S _inst_2)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u2, u3} S M (Semiring.toMonoidWithZero.{u2} S _inst_2) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (Module.toMulActionWithZero.{u2, u3} S M _inst_2 _inst_3 _inst_5))))], Eq.{succ u3} (Submodule.{u2, u3} S M _inst_2 _inst_3 _inst_5) (Submodule.restrictScalars.{u2, u1, u3} S R M _inst_1 _inst_3 _inst_2 _inst_5 _inst_4 _inst_6 _inst_7 (Top.top.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_3 _inst_4) (Submodule.instTopSubmodule.{u1, u3} R M _inst_1 _inst_3 _inst_4))) (Top.top.{u3} (Submodule.{u2, u3} S M _inst_2 _inst_3 _inst_5) (Submodule.instTopSubmodule.{u2, u3} S M _inst_2 _inst_3 _inst_5))
Case conversion may be inaccurate. Consider using '#align submodule.restrict_scalars_top Submodule.restrictScalars_topₓ'. -/
@[simp]
theorem restrictScalars_top : restrictScalars S (⊤ : Submodule R M) = ⊤ :=
  rfl
#align submodule.restrict_scalars_top Submodule.restrictScalars_top

end

/- warning: submodule.restrict_scalars_eq_top_iff -> Submodule.restrictScalars_eq_top_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {M : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_4 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_5 : Module.{u2, u3} S M _inst_2 _inst_3] [_inst_6 : SMul.{u2, u1} S R] [_inst_7 : IsScalarTower.{u2, u1, u3} S R M _inst_6 (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_3 _inst_4)))) (SMulZeroClass.toHasSmul.{u2, u3} S M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u2, u3} S M (MulZeroClass.toHasZero.{u2} S (MulZeroOneClass.toMulZeroClass.{u2} S (MonoidWithZero.toMulZeroOneClass.{u2} S (Semiring.toMonoidWithZero.{u2} S _inst_2)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u2, u3} S M (Semiring.toMonoidWithZero.{u2} S _inst_2) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Module.toMulActionWithZero.{u2, u3} S M _inst_2 _inst_3 _inst_5))))] {p : Submodule.{u1, u3} R M _inst_1 _inst_3 _inst_4}, Iff (Eq.{succ u3} (Submodule.{u2, u3} S M _inst_2 _inst_3 _inst_5) (Submodule.restrictScalars.{u2, u1, u3} S R M _inst_1 _inst_3 _inst_2 _inst_5 _inst_4 _inst_6 _inst_7 p) (Top.top.{u3} (Submodule.{u2, u3} S M _inst_2 _inst_3 _inst_5) (Submodule.hasTop.{u2, u3} S M _inst_2 _inst_3 _inst_5))) (Eq.{succ u3} (Submodule.{u1, u3} R M _inst_1 _inst_3 _inst_4) p (Top.top.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_3 _inst_4) (Submodule.hasTop.{u1, u3} R M _inst_1 _inst_3 _inst_4)))
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u3} R] [_inst_2 : Semiring.{u1} S] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] [_inst_5 : Module.{u1, u2} S M _inst_2 _inst_3] [_inst_6 : SMul.{u1, u3} S R] [_inst_7 : IsScalarTower.{u1, u3, u2} S R M _inst_6 (SMulZeroClass.toSMul.{u3, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u3, u2} R M (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (Module.toMulActionWithZero.{u3, u2} R M _inst_1 _inst_3 _inst_4)))) (SMulZeroClass.toSMul.{u1, u2} S M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u1, u2} S M (MonoidWithZero.toZero.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_2)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u1, u2} S M (Semiring.toMonoidWithZero.{u1} S _inst_2) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (Module.toMulActionWithZero.{u1, u2} S M _inst_2 _inst_3 _inst_5))))] {p : Submodule.{u3, u2} R M _inst_1 _inst_3 _inst_4}, Iff (Eq.{succ u2} (Submodule.{u1, u2} S M _inst_2 _inst_3 _inst_5) (Submodule.restrictScalars.{u1, u3, u2} S R M _inst_1 _inst_3 _inst_2 _inst_5 _inst_4 _inst_6 _inst_7 p) (Top.top.{u2} (Submodule.{u1, u2} S M _inst_2 _inst_3 _inst_5) (Submodule.instTopSubmodule.{u1, u2} S M _inst_2 _inst_3 _inst_5))) (Eq.{succ u2} (Submodule.{u3, u2} R M _inst_1 _inst_3 _inst_4) p (Top.top.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.instTopSubmodule.{u3, u2} R M _inst_1 _inst_3 _inst_4)))
Case conversion may be inaccurate. Consider using '#align submodule.restrict_scalars_eq_top_iff Submodule.restrictScalars_eq_top_iffₓ'. -/
@[simp]
theorem restrictScalars_eq_top_iff {p : Submodule R M} : restrictScalars S p = ⊤ ↔ p = ⊤ := by
  simp [SetLike.ext_iff]
#align submodule.restrict_scalars_eq_top_iff Submodule.restrictScalars_eq_top_iff

instance : OrderTop (Submodule R M) where
  top := ⊤
  le_top p x _ := trivial

/- warning: submodule.eq_top_iff' -> Submodule.eq_top_iff' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {p : Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4}, Iff (Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) p (Top.top.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.hasTop.{u1, u2} R M _inst_1 _inst_3 _inst_4))) (forall (x : M), Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x p)
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] {p : Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4}, Iff (Eq.{succ u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) p (Top.top.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (Submodule.instTopSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4))) (forall (x : M), Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) x p)
Case conversion may be inaccurate. Consider using '#align submodule.eq_top_iff' Submodule.eq_top_iff'ₓ'. -/
theorem eq_top_iff' {p : Submodule R M} : p = ⊤ ↔ ∀ x, x ∈ p :=
  eq_top_iff.trans ⟨fun h x => h trivial, fun h x _ => h x⟩
#align submodule.eq_top_iff' Submodule.eq_top_iff'

/- warning: submodule.top_equiv -> Submodule.topEquiv is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3], LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) (Top.top.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.hasTop.{u1, u2} R M _inst_1 _inst_3 _inst_4))) M (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Top.top.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.hasTop.{u1, u2} R M _inst_1 _inst_3 _inst_4))) _inst_3 (Submodule.module.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Top.top.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.hasTop.{u1, u2} R M _inst_1 _inst_3 _inst_4))) _inst_4
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3], LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x (Top.top.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.instTopSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)))) M (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Top.top.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.instTopSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4))) _inst_3 (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Top.top.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.instTopSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4))) _inst_4
Case conversion may be inaccurate. Consider using '#align submodule.top_equiv Submodule.topEquivₓ'. -/
/-- The top submodule is linearly equivalent to the module.

This is the module version of `add_submonoid.top_equiv`. -/
@[simps]
def topEquiv : (⊤ : Submodule R M) ≃ₗ[R] M
    where
  toFun x := x
  invFun x := ⟨x, by simp⟩
  map_add' := by
    intros
    rfl
  map_smul' := by
    intros
    rfl
  left_inv := by
    intro x
    ext
    rfl
  right_inv := by
    intro x
    rfl
#align submodule.top_equiv Submodule.topEquiv

instance : InfSet (Submodule R M) :=
  ⟨fun S =>
    { carrier := ⋂ s ∈ S, (s : Set M)
      zero_mem' := by simp [zero_mem]
      add_mem' := by simp (config := { contextual := true }) [add_mem]
      smul_mem' := by simp (config := { contextual := true }) [smul_mem] }⟩

private theorem Inf_le' {S : Set (Submodule R M)} {p} : p ∈ S → infₛ S ≤ p :=
  Set.binterᵢ_subset_of_mem
#align submodule.Inf_le' submodule.Inf_le'

private theorem le_Inf' {S : Set (Submodule R M)} {p} : (∀ q ∈ S, p ≤ q) → p ≤ infₛ S :=
  Set.subset_interᵢ₂
#align submodule.le_Inf' submodule.le_Inf'

instance : HasInf (Submodule R M) :=
  ⟨fun p q =>
    { carrier := p ∩ q
      zero_mem' := by simp [zero_mem]
      add_mem' := by simp (config := { contextual := true }) [add_mem]
      smul_mem' := by simp (config := { contextual := true }) [smul_mem] }⟩

instance : CompleteLattice (Submodule R M) :=
  { Submodule.orderTop, Submodule.orderBot,
    SetLike.partialOrder with
    sup := fun a b => infₛ { x | a ≤ x ∧ b ≤ x }
    le_sup_left := fun a b => le_Inf' fun x ⟨ha, hb⟩ => ha
    le_sup_right := fun a b => le_Inf' fun x ⟨ha, hb⟩ => hb
    sup_le := fun a b c h₁ h₂ => infₛ_le' ⟨h₁, h₂⟩
    inf := (· ⊓ ·)
    le_inf := fun a b c => Set.subset_inter
    inf_le_left := fun a b => Set.inter_subset_left _ _
    inf_le_right := fun a b => Set.inter_subset_right _ _
    supₛ := fun tt => infₛ { t | ∀ t' ∈ tt, t' ≤ t }
    le_sup := fun s p hs => le_Inf' fun q hq => hq _ hs
    sup_le := fun s p hs => infₛ_le' hs
    infₛ := infₛ
    le_inf := fun s a => le_Inf'
    inf_le := fun s a => infₛ_le' }

/- warning: submodule.inf_coe -> Submodule.inf_coe is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {p : Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4} {q : Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4}, Eq.{succ u2} (Set.{u2} M) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)))) (HasInf.inf.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.hasInf.{u1, u2} R M _inst_1 _inst_3 _inst_4) p q)) (Inter.inter.{u2} (Set.{u2} M) (Set.hasInter.{u2} M) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)))) p) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)))) q))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {p : Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4} {q : Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4}, Eq.{succ u2} (Set.{u2} M) (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (HasInf.inf.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.instHasInfSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) p q)) (Inter.inter.{u2} (Set.{u2} M) (Set.instInterSet.{u2} M) (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) p) (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) q))
Case conversion may be inaccurate. Consider using '#align submodule.inf_coe Submodule.inf_coeₓ'. -/
@[simp]
theorem inf_coe : ↑(p ⊓ q) = (p ∩ q : Set M) :=
  rfl
#align submodule.inf_coe Submodule.inf_coe

/- warning: submodule.mem_inf -> Submodule.mem_inf is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {p : Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4} {q : Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4} {x : M}, Iff (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x (HasInf.inf.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.hasInf.{u1, u2} R M _inst_1 _inst_3 _inst_4) p q)) (And (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x p) (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x q))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] {p : Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4} {q : Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4} {x : M}, Iff (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) x (HasInf.inf.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (Submodule.instHasInfSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) p q)) (And (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) x p) (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) x q))
Case conversion may be inaccurate. Consider using '#align submodule.mem_inf Submodule.mem_infₓ'. -/
@[simp]
theorem mem_inf {p q : Submodule R M} {x : M} : x ∈ p ⊓ q ↔ x ∈ p ∧ x ∈ q :=
  Iff.rfl
#align submodule.mem_inf Submodule.mem_inf

/- warning: submodule.Inf_coe -> Submodule.infₛ_coe is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] (P : Set.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)), Eq.{succ u2} (Set.{u2} M) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)))) (InfSet.infₛ.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.hasInf.{u1, u2} R M _inst_1 _inst_3 _inst_4) P)) (Set.interᵢ.{u2, succ u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (fun (p : Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) => Set.interᵢ.{u2, 0} M (Membership.Mem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)) (Set.hasMem.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)) p P) (fun (H : Membership.Mem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)) (Set.hasMem.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)) p P) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)))) p)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] (P : Set.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)), Eq.{succ u2} (Set.{u2} M) (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (InfSet.infₛ.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.instInfSetSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) P)) (Set.interᵢ.{u2, succ u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (fun (p : Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) => Set.interᵢ.{u2, 0} M (Membership.mem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)) (Set.instMembershipSet.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)) p P) (fun (H : Membership.mem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)) (Set.instMembershipSet.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)) p P) => SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) p)))
Case conversion may be inaccurate. Consider using '#align submodule.Inf_coe Submodule.infₛ_coeₓ'. -/
@[simp]
theorem infₛ_coe (P : Set (Submodule R M)) : (↑(infₛ P) : Set M) = ⋂ p ∈ P, ↑p :=
  rfl
#align submodule.Inf_coe Submodule.infₛ_coe

/- warning: submodule.finset_inf_coe -> Submodule.finset_inf_coe is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {ι : Type.{u3}} (s : Finset.{u3} ι) (p : ι -> (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)), Eq.{succ u2} (Set.{u2} M) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)))) (Finset.inf.{u2, u3} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) ι (Lattice.toSemilatticeInf.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (CompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_3 _inst_4))) (Submodule.orderTop.{u1, u2} R M _inst_1 _inst_3 _inst_4) s p)) (Set.interᵢ.{u2, succ u3} M ι (fun (i : ι) => Set.interᵢ.{u2, 0} M (Membership.Mem.{u3, u3} ι (Finset.{u3} ι) (Finset.hasMem.{u3} ι) i s) (fun (H : Membership.Mem.{u3, u3} ι (Finset.{u3} ι) (Finset.hasMem.{u3} ι) i s) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)))) (p i))))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] {ι : Type.{u3}} (s : Finset.{u3} ι) (p : ι -> (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)), Eq.{succ u1} (Set.{u1} M) (SetLike.coe.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (Finset.inf.{u1, u3} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) ι (Lattice.toSemilatticeInf.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (CompleteLattice.toLattice.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_3 _inst_4))) (Submodule.instOrderTopSubmoduleToLEToPreorderInstPartialOrderInstSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) s p)) (Set.interᵢ.{u1, succ u3} M ι (fun (i : ι) => Set.interᵢ.{u1, 0} M (Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) i s) (fun (H : Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) i s) => SetLike.coe.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (p i))))
Case conversion may be inaccurate. Consider using '#align submodule.finset_inf_coe Submodule.finset_inf_coeₓ'. -/
@[simp]
theorem finset_inf_coe {ι} (s : Finset ι) (p : ι → Submodule R M) :
    (↑(s.inf p) : Set M) = ⋂ i ∈ s, ↑(p i) :=
  by
  letI := Classical.decEq ι
  refine' s.induction_on _ fun i s hi ih => _
  · simp
  · rw [Finset.inf_insert, inf_coe, ih]
    simp
#align submodule.finset_inf_coe Submodule.finset_inf_coe

/- warning: submodule.infi_coe -> Submodule.infᵢ_coe is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {ι : Sort.{u3}} (p : ι -> (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)), Eq.{succ u2} (Set.{u2} M) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)))) (infᵢ.{u2, u3} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.hasInf.{u1, u2} R M _inst_1 _inst_3 _inst_4) ι (fun (i : ι) => p i))) (Set.interᵢ.{u2, u3} M ι (fun (i : ι) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)))) (p i)))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] {ι : Sort.{u3}} (p : ι -> (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)), Eq.{succ u1} (Set.{u1} M) (SetLike.coe.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (infᵢ.{u1, u3} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (Submodule.instInfSetSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) ι (fun (i : ι) => p i))) (Set.interᵢ.{u1, u3} M ι (fun (i : ι) => SetLike.coe.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (p i)))
Case conversion may be inaccurate. Consider using '#align submodule.infi_coe Submodule.infᵢ_coeₓ'. -/
@[simp]
theorem infᵢ_coe {ι} (p : ι → Submodule R M) : (↑(⨅ i, p i) : Set M) = ⋂ i, ↑(p i) := by
  rw [infᵢ, Inf_coe] <;> ext a <;> simp <;> exact ⟨fun h i => h _ i rfl, fun h i x e => e ▸ h _⟩
#align submodule.infi_coe Submodule.infᵢ_coe

/- warning: submodule.mem_Inf -> Submodule.mem_infₛ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {S : Set.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)} {x : M}, Iff (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x (InfSet.infₛ.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.hasInf.{u1, u2} R M _inst_1 _inst_3 _inst_4) S)) (forall (p : Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4), (Membership.Mem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)) (Set.hasMem.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)) p S) -> (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x p))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {S : Set.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)} {x : M}, Iff (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x (InfSet.infₛ.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.instInfSetSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) S)) (forall (p : Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4), (Membership.mem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)) (Set.instMembershipSet.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)) p S) -> (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x p))
Case conversion may be inaccurate. Consider using '#align submodule.mem_Inf Submodule.mem_infₛₓ'. -/
@[simp]
theorem mem_infₛ {S : Set (Submodule R M)} {x : M} : x ∈ infₛ S ↔ ∀ p ∈ S, x ∈ p :=
  Set.mem_interᵢ₂
#align submodule.mem_Inf Submodule.mem_infₛ

/- warning: submodule.mem_infi -> Submodule.mem_infᵢ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {ι : Sort.{u3}} (p : ι -> (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)) {x : M}, Iff (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x (infᵢ.{u2, u3} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.hasInf.{u1, u2} R M _inst_1 _inst_3 _inst_4) ι (fun (i : ι) => p i))) (forall (i : ι), Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x (p i))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] {ι : Sort.{u3}} (p : ι -> (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) {x : M}, Iff (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) x (infᵢ.{u1, u3} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (Submodule.instInfSetSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) ι (fun (i : ι) => p i))) (forall (i : ι), Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) x (p i))
Case conversion may be inaccurate. Consider using '#align submodule.mem_infi Submodule.mem_infᵢₓ'. -/
@[simp]
theorem mem_infᵢ {ι} (p : ι → Submodule R M) {x} : (x ∈ ⨅ i, p i) ↔ ∀ i, x ∈ p i := by
  rw [← SetLike.mem_coe, infi_coe, Set.mem_interᵢ] <;> rfl
#align submodule.mem_infi Submodule.mem_infᵢ

/- warning: submodule.mem_finset_inf -> Submodule.mem_finset_inf is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {ι : Type.{u3}} {s : Finset.{u3} ι} {p : ι -> (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)} {x : M}, Iff (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x (Finset.inf.{u2, u3} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) ι (Lattice.toSemilatticeInf.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (CompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_3 _inst_4))) (Submodule.orderTop.{u1, u2} R M _inst_1 _inst_3 _inst_4) s p)) (forall (i : ι), (Membership.Mem.{u3, u3} ι (Finset.{u3} ι) (Finset.hasMem.{u3} ι) i s) -> (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x (p i)))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] {ι : Type.{u3}} {s : Finset.{u3} ι} {p : ι -> (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)} {x : M}, Iff (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) x (Finset.inf.{u1, u3} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) ι (Lattice.toSemilatticeInf.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (CompleteLattice.toLattice.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_3 _inst_4))) (Submodule.instOrderTopSubmoduleToLEToPreorderInstPartialOrderInstSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) s p)) (forall (i : ι), (Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) i s) -> (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) x (p i)))
Case conversion may be inaccurate. Consider using '#align submodule.mem_finset_inf Submodule.mem_finset_infₓ'. -/
@[simp]
theorem mem_finset_inf {ι} {s : Finset ι} {p : ι → Submodule R M} {x : M} :
    x ∈ s.inf p ↔ ∀ i ∈ s, x ∈ p i := by
  simp only [← SetLike.mem_coe, finset_inf_coe, Set.mem_interᵢ]
#align submodule.mem_finset_inf Submodule.mem_finset_inf

/- warning: submodule.mem_sup_left -> Submodule.mem_sup_left is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {S : Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4} {T : Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4} {x : M}, (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x S) -> (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x (HasSup.sup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (CompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_3 _inst_4)))) S T))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] {S : Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4} {T : Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4} {x : M}, (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) x S) -> (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) x (HasSup.sup.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SemilatticeSup.toHasSup.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (Lattice.toSemilatticeSup.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (CompleteLattice.toLattice.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_3 _inst_4)))) S T))
Case conversion may be inaccurate. Consider using '#align submodule.mem_sup_left Submodule.mem_sup_leftₓ'. -/
theorem mem_sup_left {S T : Submodule R M} : ∀ {x : M}, x ∈ S → x ∈ S ⊔ T :=
  show S ≤ S ⊔ T from le_sup_left
#align submodule.mem_sup_left Submodule.mem_sup_left

/- warning: submodule.mem_sup_right -> Submodule.mem_sup_right is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {S : Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4} {T : Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4} {x : M}, (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x T) -> (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x (HasSup.sup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (CompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_3 _inst_4)))) S T))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] {S : Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4} {T : Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4} {x : M}, (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) x T) -> (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) x (HasSup.sup.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SemilatticeSup.toHasSup.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (Lattice.toSemilatticeSup.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (CompleteLattice.toLattice.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_3 _inst_4)))) S T))
Case conversion may be inaccurate. Consider using '#align submodule.mem_sup_right Submodule.mem_sup_rightₓ'. -/
theorem mem_sup_right {S T : Submodule R M} : ∀ {x : M}, x ∈ T → x ∈ S ⊔ T :=
  show T ≤ S ⊔ T from le_sup_right
#align submodule.mem_sup_right Submodule.mem_sup_right

/- warning: submodule.add_mem_sup -> Submodule.add_mem_sup is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {S : Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4} {T : Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4} {s : M} {t : M}, (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) s S) -> (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) t T) -> (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) s t) (HasSup.sup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (CompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_3 _inst_4)))) S T))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] {S : Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4} {T : Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4} {s : M} {t : M}, (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) s S) -> (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) t T) -> (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) s t) (HasSup.sup.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SemilatticeSup.toHasSup.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (Lattice.toSemilatticeSup.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (CompleteLattice.toLattice.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_3 _inst_4)))) S T))
Case conversion may be inaccurate. Consider using '#align submodule.add_mem_sup Submodule.add_mem_supₓ'. -/
theorem add_mem_sup {S T : Submodule R M} {s t : M} (hs : s ∈ S) (ht : t ∈ T) : s + t ∈ S ⊔ T :=
  add_mem (mem_sup_left hs) (mem_sup_right ht)
#align submodule.add_mem_sup Submodule.add_mem_sup

/- warning: submodule.sub_mem_sup -> Submodule.sub_mem_sup is a dubious translation:
lean 3 declaration is
  forall {R' : Type.{u1}} {M' : Type.{u2}} [_inst_8 : Ring.{u1} R'] [_inst_9 : AddCommGroup.{u2} M'] [_inst_10 : Module.{u1, u2} R' M' (Ring.toSemiring.{u1} R' _inst_8) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_9)] {S : Submodule.{u1, u2} R' M' (Ring.toSemiring.{u1} R' _inst_8) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_9) _inst_10} {T : Submodule.{u1, u2} R' M' (Ring.toSemiring.{u1} R' _inst_8) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_9) _inst_10} {s : M'} {t : M'}, (Membership.Mem.{u2, u2} M' (Submodule.{u1, u2} R' M' (Ring.toSemiring.{u1} R' _inst_8) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_9) _inst_10) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R' M' (Ring.toSemiring.{u1} R' _inst_8) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_9) _inst_10) M' (Submodule.setLike.{u1, u2} R' M' (Ring.toSemiring.{u1} R' _inst_8) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_9) _inst_10)) s S) -> (Membership.Mem.{u2, u2} M' (Submodule.{u1, u2} R' M' (Ring.toSemiring.{u1} R' _inst_8) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_9) _inst_10) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R' M' (Ring.toSemiring.{u1} R' _inst_8) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_9) _inst_10) M' (Submodule.setLike.{u1, u2} R' M' (Ring.toSemiring.{u1} R' _inst_8) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_9) _inst_10)) t T) -> (Membership.Mem.{u2, u2} M' (Submodule.{u1, u2} R' M' (Ring.toSemiring.{u1} R' _inst_8) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_9) _inst_10) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R' M' (Ring.toSemiring.{u1} R' _inst_8) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_9) _inst_10) M' (Submodule.setLike.{u1, u2} R' M' (Ring.toSemiring.{u1} R' _inst_8) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_9) _inst_10)) (HSub.hSub.{u2, u2, u2} M' M' M' (instHSub.{u2} M' (SubNegMonoid.toHasSub.{u2} M' (AddGroup.toSubNegMonoid.{u2} M' (AddCommGroup.toAddGroup.{u2} M' _inst_9)))) s t) (HasSup.sup.{u2} (Submodule.{u1, u2} R' M' (Ring.toSemiring.{u1} R' _inst_8) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_9) _inst_10) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R' M' (Ring.toSemiring.{u1} R' _inst_8) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_9) _inst_10) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} R' M' (Ring.toSemiring.{u1} R' _inst_8) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_9) _inst_10) (CompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R' M' (Ring.toSemiring.{u1} R' _inst_8) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_9) _inst_10) (Submodule.completeLattice.{u1, u2} R' M' (Ring.toSemiring.{u1} R' _inst_8) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_9) _inst_10)))) S T))
but is expected to have type
  forall {R' : Type.{u2}} {M' : Type.{u1}} [_inst_8 : Ring.{u2} R'] [_inst_9 : AddCommGroup.{u1} M'] [_inst_10 : Module.{u2, u1} R' M' (Ring.toSemiring.{u2} R' _inst_8) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_9)] {S : Submodule.{u2, u1} R' M' (Ring.toSemiring.{u2} R' _inst_8) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_9) _inst_10} {T : Submodule.{u2, u1} R' M' (Ring.toSemiring.{u2} R' _inst_8) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_9) _inst_10} {s : M'} {t : M'}, (Membership.mem.{u1, u1} M' (Submodule.{u2, u1} R' M' (Ring.toSemiring.{u2} R' _inst_8) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_9) _inst_10) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R' M' (Ring.toSemiring.{u2} R' _inst_8) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_9) _inst_10) M' (Submodule.instSetLikeSubmodule.{u2, u1} R' M' (Ring.toSemiring.{u2} R' _inst_8) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_9) _inst_10)) s S) -> (Membership.mem.{u1, u1} M' (Submodule.{u2, u1} R' M' (Ring.toSemiring.{u2} R' _inst_8) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_9) _inst_10) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R' M' (Ring.toSemiring.{u2} R' _inst_8) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_9) _inst_10) M' (Submodule.instSetLikeSubmodule.{u2, u1} R' M' (Ring.toSemiring.{u2} R' _inst_8) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_9) _inst_10)) t T) -> (Membership.mem.{u1, u1} M' (Submodule.{u2, u1} R' M' (Ring.toSemiring.{u2} R' _inst_8) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_9) _inst_10) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R' M' (Ring.toSemiring.{u2} R' _inst_8) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_9) _inst_10) M' (Submodule.instSetLikeSubmodule.{u2, u1} R' M' (Ring.toSemiring.{u2} R' _inst_8) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_9) _inst_10)) (HSub.hSub.{u1, u1, u1} M' M' M' (instHSub.{u1} M' (SubNegMonoid.toSub.{u1} M' (AddGroup.toSubNegMonoid.{u1} M' (AddCommGroup.toAddGroup.{u1} M' _inst_9)))) s t) (HasSup.sup.{u1} (Submodule.{u2, u1} R' M' (Ring.toSemiring.{u2} R' _inst_8) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_9) _inst_10) (SemilatticeSup.toHasSup.{u1} (Submodule.{u2, u1} R' M' (Ring.toSemiring.{u2} R' _inst_8) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_9) _inst_10) (Lattice.toSemilatticeSup.{u1} (Submodule.{u2, u1} R' M' (Ring.toSemiring.{u2} R' _inst_8) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_9) _inst_10) (CompleteLattice.toLattice.{u1} (Submodule.{u2, u1} R' M' (Ring.toSemiring.{u2} R' _inst_8) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_9) _inst_10) (Submodule.completeLattice.{u2, u1} R' M' (Ring.toSemiring.{u2} R' _inst_8) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_9) _inst_10)))) S T))
Case conversion may be inaccurate. Consider using '#align submodule.sub_mem_sup Submodule.sub_mem_supₓ'. -/
theorem sub_mem_sup {R' M' : Type _} [Ring R'] [AddCommGroup M'] [Module R' M']
    {S T : Submodule R' M'} {s t : M'} (hs : s ∈ S) (ht : t ∈ T) : s - t ∈ S ⊔ T :=
  by
  rw [sub_eq_add_neg]
  exact add_mem_sup hs (neg_mem ht)
#align submodule.sub_mem_sup Submodule.sub_mem_sup

/- warning: submodule.mem_supr_of_mem -> Submodule.mem_supᵢ_of_mem is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {ι : Sort.{u3}} {b : M} {p : ι -> (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)} (i : ι), (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) b (p i)) -> (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) b (supᵢ.{u2, u3} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (CompleteSemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (CompleteLattice.toCompleteSemilatticeSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_3 _inst_4))) ι (fun (i : ι) => p i)))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] {ι : Sort.{u3}} {b : M} {p : ι -> (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)} (i : ι), (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) b (p i)) -> (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) b (supᵢ.{u1, u3} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (CompleteLattice.toSupSet.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_3 _inst_4)) ι (fun (i : ι) => p i)))
Case conversion may be inaccurate. Consider using '#align submodule.mem_supr_of_mem Submodule.mem_supᵢ_of_memₓ'. -/
theorem mem_supᵢ_of_mem {ι : Sort _} {b : M} {p : ι → Submodule R M} (i : ι) (h : b ∈ p i) :
    b ∈ ⨆ i, p i :=
  have : p i ≤ ⨆ i, p i := le_supᵢ p i
  @this b h
#align submodule.mem_supr_of_mem Submodule.mem_supᵢ_of_mem

open BigOperators

/- warning: submodule.sum_mem_supr -> Submodule.sum_mem_supᵢ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {ι : Type.{u3}} [_inst_8 : Fintype.{u3} ι] {f : ι -> M} {p : ι -> (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)}, (forall (i : ι), Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) (f i) (p i)) -> (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) (Finset.sum.{u2, u3} M ι _inst_3 (Finset.univ.{u3} ι _inst_8) (fun (i : ι) => f i)) (supᵢ.{u2, succ u3} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (CompleteSemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (CompleteLattice.toCompleteSemilatticeSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_3 _inst_4))) ι (fun (i : ι) => p i)))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] {ι : Type.{u3}} [_inst_8 : Fintype.{u3} ι] {f : ι -> M} {p : ι -> (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)}, (forall (i : ι), Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) (f i) (p i)) -> (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) (Finset.sum.{u1, u3} M ι _inst_3 (Finset.univ.{u3} ι _inst_8) (fun (i : ι) => f i)) (supᵢ.{u1, succ u3} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (CompleteLattice.toSupSet.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_3 _inst_4)) ι (fun (i : ι) => p i)))
Case conversion may be inaccurate. Consider using '#align submodule.sum_mem_supr Submodule.sum_mem_supᵢₓ'. -/
theorem sum_mem_supᵢ {ι : Type _} [Fintype ι] {f : ι → M} {p : ι → Submodule R M}
    (h : ∀ i, f i ∈ p i) : (∑ i, f i) ∈ ⨆ i, p i :=
  sum_mem fun i hi => mem_supᵢ_of_mem i (h i)
#align submodule.sum_mem_supr Submodule.sum_mem_supᵢ

/- warning: submodule.sum_mem_bsupr -> Submodule.sum_mem_bsupᵢ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {ι : Type.{u3}} {s : Finset.{u3} ι} {f : ι -> M} {p : ι -> (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)}, (forall (i : ι), (Membership.Mem.{u3, u3} ι (Finset.{u3} ι) (Finset.hasMem.{u3} ι) i s) -> (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) (f i) (p i))) -> (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) (Finset.sum.{u2, u3} M ι _inst_3 s (fun (i : ι) => f i)) (supᵢ.{u2, succ u3} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (CompleteSemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (CompleteLattice.toCompleteSemilatticeSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_3 _inst_4))) ι (fun (i : ι) => supᵢ.{u2, 0} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (CompleteSemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (CompleteLattice.toCompleteSemilatticeSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_3 _inst_4))) (Membership.Mem.{u3, u3} ι (Finset.{u3} ι) (Finset.hasMem.{u3} ι) i s) (fun (H : Membership.Mem.{u3, u3} ι (Finset.{u3} ι) (Finset.hasMem.{u3} ι) i s) => p i))))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] {ι : Type.{u3}} {s : Finset.{u3} ι} {f : ι -> M} {p : ι -> (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)}, (forall (i : ι), (Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) i s) -> (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) (f i) (p i))) -> (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) (Finset.sum.{u1, u3} M ι _inst_3 s (fun (i : ι) => f i)) (supᵢ.{u1, succ u3} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (CompleteLattice.toSupSet.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_3 _inst_4)) ι (fun (i : ι) => supᵢ.{u1, 0} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (CompleteLattice.toSupSet.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_3 _inst_4)) (Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) i s) (fun (H : Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) i s) => p i))))
Case conversion may be inaccurate. Consider using '#align submodule.sum_mem_bsupr Submodule.sum_mem_bsupᵢₓ'. -/
theorem sum_mem_bsupᵢ {ι : Type _} {s : Finset ι} {f : ι → M} {p : ι → Submodule R M}
    (h : ∀ i ∈ s, f i ∈ p i) : (∑ i in s, f i) ∈ ⨆ i ∈ s, p i :=
  sum_mem fun i hi => mem_supᵢ_of_mem i <| mem_supᵢ_of_mem hi (h i hi)
#align submodule.sum_mem_bsupr Submodule.sum_mem_bsupᵢ

/-! Note that `submodule.mem_supr` is provided in `linear_algebra/basic.lean`. -/


/- warning: submodule.mem_Sup_of_mem -> Submodule.mem_supₛ_of_mem is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {S : Set.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)} {s : Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4}, (Membership.Mem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)) (Set.hasMem.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)) s S) -> (forall {x : M}, (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x s) -> (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x (SupSet.supₛ.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (CompleteSemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (CompleteLattice.toCompleteSemilatticeSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_3 _inst_4))) S)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {S : Set.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)} {s : Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4}, (Membership.mem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Set.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)) (Set.instMembershipSet.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)) s S) -> (forall {x : M}, (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x s) -> (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x (SupSet.supₛ.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (CompleteLattice.toSupSet.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_3 _inst_4)) S)))
Case conversion may be inaccurate. Consider using '#align submodule.mem_Sup_of_mem Submodule.mem_supₛ_of_memₓ'. -/
theorem mem_supₛ_of_mem {S : Set (Submodule R M)} {s : Submodule R M} (hs : s ∈ S) :
    ∀ {x : M}, x ∈ s → x ∈ supₛ S :=
  show s ≤ supₛ S from le_supₛ hs
#align submodule.mem_Sup_of_mem Submodule.mem_supₛ_of_mem

/- warning: submodule.disjoint_def -> Submodule.disjoint_def is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {p : Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4} {p' : Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4}, Iff (Disjoint.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_3 _inst_4))) (Submodule.orderBot.{u1, u2} R M _inst_1 _inst_3 _inst_4) p p') (forall (x : M), (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x p) -> (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x p') -> (Eq.{succ u2} M x (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))))))))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] {p : Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4} {p' : Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4}, Iff (Disjoint.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_3 _inst_4))) (Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderInstSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) p p') (forall (x : M), (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) x p) -> (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) x p') -> (Eq.{succ u1} M x (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))))
Case conversion may be inaccurate. Consider using '#align submodule.disjoint_def Submodule.disjoint_defₓ'. -/
theorem disjoint_def {p p' : Submodule R M} : Disjoint p p' ↔ ∀ x ∈ p, x ∈ p' → x = (0 : M) :=
  disjoint_iff_inf_le.trans <| show (∀ x, x ∈ p ∧ x ∈ p' → x ∈ ({0} : Set M)) ↔ _ by simp
#align submodule.disjoint_def Submodule.disjoint_def

/- warning: submodule.disjoint_def' -> Submodule.disjoint_def' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {p : Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4} {p' : Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4}, Iff (Disjoint.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_3 _inst_4))) (Submodule.orderBot.{u1, u2} R M _inst_1 _inst_3 _inst_4) p p') (forall (x : M), (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x p) -> (forall (y : M), (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) y p') -> (Eq.{succ u2} M x y) -> (Eq.{succ u2} M x (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))))))))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] {p : Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4} {p' : Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4}, Iff (Disjoint.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_3 _inst_4))) (Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderInstSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) p p') (forall (x : M), (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) x p) -> (forall (y : M), (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_3 _inst_4)) y p') -> (Eq.{succ u1} M x y) -> (Eq.{succ u1} M x (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))))))
Case conversion may be inaccurate. Consider using '#align submodule.disjoint_def' Submodule.disjoint_def'ₓ'. -/
theorem disjoint_def' {p p' : Submodule R M} :
    Disjoint p p' ↔ ∀ x ∈ p, ∀ y ∈ p', x = y → x = (0 : M) :=
  disjoint_def.trans
    ⟨fun h x hx y hy hxy => h x hx <| hxy.symm ▸ hy, fun h x hx hx' => h _ hx x hx' rfl⟩
#align submodule.disjoint_def' Submodule.disjoint_def'

/- warning: submodule.eq_zero_of_coe_mem_of_disjoint -> Submodule.eq_zero_of_coe_mem_of_disjoint is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {p : Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4} {q : Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4}, (Disjoint.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_3 _inst_4))) (Submodule.orderBot.{u1, u2} R M _inst_1 _inst_3 _inst_4) p q) -> (forall {a : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) p}, (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) p) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) p) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) p) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) p) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x p))))) a) q) -> (Eq.{succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) p) a (OfNat.ofNat.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) p) 0 (OfNat.mk.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) p) 0 (Zero.zero.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) p) (Submodule.hasZero.{u1, u2} R M _inst_1 _inst_3 _inst_4 p))))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {p : Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4} {q : Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4}, (Disjoint.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_3 _inst_4))) (Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) p q) -> (forall {a : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x p)}, (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)) (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) p)) a) q) -> (Eq.{succ u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x p)) a (OfNat.ofNat.{u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x p)) 0 (Zero.toOfNat0.{u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x p)) (Submodule.instZeroSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4 p)))))
Case conversion may be inaccurate. Consider using '#align submodule.eq_zero_of_coe_mem_of_disjoint Submodule.eq_zero_of_coe_mem_of_disjointₓ'. -/
theorem eq_zero_of_coe_mem_of_disjoint (hpq : Disjoint p q) {a : p} (ha : (a : M) ∈ q) : a = 0 := by
  exact_mod_cast disjoint_def.mp hpq a (coe_mem a) ha
#align submodule.eq_zero_of_coe_mem_of_disjoint Submodule.eq_zero_of_coe_mem_of_disjoint

end Submodule

section NatSubmodule

/- warning: add_submonoid.to_nat_submodule -> AddSubmonoid.toNatSubmodule is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_3 : AddCommMonoid.{u1} M], OrderIso.{u1, u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Preorder.toLE.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (AddSubmonoid.completeLattice.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))))) (Preorder.toLE.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Submodule.completeLattice.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3))))))
but is expected to have type
  forall {M : Type.{u1}} [_inst_3 : AddCommMonoid.{u1} M], OrderIso.{u1, u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Preorder.toLE.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))))) (Preorder.toLE.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Submodule.completeLattice.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3))))))
Case conversion may be inaccurate. Consider using '#align add_submonoid.to_nat_submodule AddSubmonoid.toNatSubmoduleₓ'. -/
/-- An additive submonoid is equivalent to a ℕ-submodule. -/
def AddSubmonoid.toNatSubmodule : AddSubmonoid M ≃o Submodule ℕ M
    where
  toFun S := { S with smul_mem' := fun r s hs => show r • s ∈ S from nsmul_mem hs _ }
  invFun := Submodule.toAddSubmonoid
  left_inv := fun ⟨S, _, _⟩ => rfl
  right_inv := fun ⟨S, _, _, _⟩ => rfl
  map_rel_iff' a b := Iff.rfl
#align add_submonoid.to_nat_submodule AddSubmonoid.toNatSubmodule

/- warning: add_submonoid.to_nat_submodule_symm -> AddSubmonoid.toNatSubmodule_symm is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_3 : AddCommMonoid.{u1} M], Eq.{succ u1} ((Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) -> (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (coeFn.{succ u1, succ u1} (OrderIso.{u1, u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Preorder.toLE.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Submodule.completeLattice.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)))))) (Preorder.toLE.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (AddSubmonoid.completeLattice.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))))))) (fun (_x : RelIso.{u1, u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (LE.le.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Preorder.toLE.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Submodule.completeLattice.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3))))))) (LE.le.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Preorder.toLE.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (AddSubmonoid.completeLattice.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))))))) => (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) -> (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (RelIso.hasCoeToFun.{u1, u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (LE.le.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Preorder.toLE.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Submodule.completeLattice.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3))))))) (LE.le.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Preorder.toLE.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (AddSubmonoid.completeLattice.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))))))) (OrderIso.symm.{u1, u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Preorder.toLE.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (AddSubmonoid.completeLattice.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))))) (Preorder.toLE.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Submodule.completeLattice.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)))))) (AddSubmonoid.toNatSubmodule.{u1} M _inst_3))) (Submodule.toAddSubmonoid.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3))
but is expected to have type
  forall {M : Type.{u1}} [_inst_3 : AddCommMonoid.{u1} M], Eq.{succ u1} (forall (ᾰ : Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)), (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) => AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (fun (_x : Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) => AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Function.instEmbeddingLikeEmbedding.{succ u1, succ u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))) (RelEmbedding.toEmbedding.{u1, u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) => LE.le.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Preorder.toLE.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Submodule.completeLattice.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) => LE.le.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Preorder.toLE.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{u1, u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) => LE.le.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Preorder.toLE.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Submodule.completeLattice.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) => LE.le.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Preorder.toLE.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (OrderIso.symm.{u1, u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Preorder.toLE.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))))) (Preorder.toLE.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Submodule.completeLattice.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)))))) (AddSubmonoid.toNatSubmodule.{u1} M _inst_3))))) (Submodule.toAddSubmonoid.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3))
Case conversion may be inaccurate. Consider using '#align add_submonoid.to_nat_submodule_symm AddSubmonoid.toNatSubmodule_symmₓ'. -/
@[simp]
theorem AddSubmonoid.toNatSubmodule_symm :
    ⇑(AddSubmonoid.toNatSubmodule.symm : _ ≃o AddSubmonoid M) = Submodule.toAddSubmonoid :=
  rfl
#align add_submonoid.to_nat_submodule_symm AddSubmonoid.toNatSubmodule_symm

/- warning: add_submonoid.coe_to_nat_submodule -> AddSubmonoid.coe_toNatSubmodule is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_3 : AddCommMonoid.{u1} M] (S : AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))), Eq.{succ u1} (Set.{u1} M) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Set.{u1} M) (HasLiftT.mk.{succ u1, succ u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Set.{u1} M) (CoeTCₓ.coe.{succ u1, succ u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Set.{u1} M) (SetLike.Set.hasCoeT.{u1, u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) M (Submodule.setLike.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3))))) (coeFn.{succ u1, succ u1} (OrderIso.{u1, u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Preorder.toLE.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (AddSubmonoid.completeLattice.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))))) (Preorder.toLE.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Submodule.completeLattice.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3))))))) (fun (_x : RelIso.{u1, u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (LE.le.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Preorder.toLE.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (AddSubmonoid.completeLattice.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))))))) (LE.le.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Preorder.toLE.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Submodule.completeLattice.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)))))))) => (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) -> (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3))) (RelIso.hasCoeToFun.{u1, u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (LE.le.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Preorder.toLE.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (AddSubmonoid.completeLattice.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))))))) (LE.le.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Preorder.toLE.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Submodule.completeLattice.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)))))))) (AddSubmonoid.toNatSubmodule.{u1} M _inst_3) S)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Set.{u1} M) (HasLiftT.mk.{succ u1, succ u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Set.{u1} M) (CoeTCₓ.coe.{succ u1, succ u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Set.{u1} M) (SetLike.Set.hasCoeT.{u1, u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) M (AddSubmonoid.setLike.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))))) S)
but is expected to have type
  forall {M : Type.{u1}} [_inst_3 : AddCommMonoid.{u1} M] (S : AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))), Eq.{succ u1} (Set.{u1} M) (SetLike.coe.{u1, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) => Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) S) M (Submodule.instSetLikeSubmodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (FunLike.coe.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3))) (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (fun (_x : AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) => Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3))) (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Function.instEmbeddingLikeEmbedding.{succ u1, succ u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)))) (RelEmbedding.toEmbedding.{u1, u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) => LE.le.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Preorder.toLE.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) => LE.le.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Preorder.toLE.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Submodule.completeLattice.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{u1, u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) => LE.le.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Preorder.toLE.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) => LE.le.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Preorder.toLE.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Submodule.completeLattice.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (AddSubmonoid.toNatSubmodule.{u1} M _inst_3))) S)) (SetLike.coe.{u1, u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) M (AddSubmonoid.instSetLikeAddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) S)
Case conversion may be inaccurate. Consider using '#align add_submonoid.coe_to_nat_submodule AddSubmonoid.coe_toNatSubmoduleₓ'. -/
@[simp]
theorem AddSubmonoid.coe_toNatSubmodule (S : AddSubmonoid M) : (S.toNatSubmodule : Set M) = S :=
  rfl
#align add_submonoid.coe_to_nat_submodule AddSubmonoid.coe_toNatSubmodule

/- warning: add_submonoid.to_nat_submodule_to_add_submonoid -> AddSubmonoid.toNatSubmodule_toAddSubmonoid is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_3 : AddCommMonoid.{u1} M] (S : AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))), Eq.{succ u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Submodule.toAddSubmonoid.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3) (coeFn.{succ u1, succ u1} (OrderIso.{u1, u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Preorder.toLE.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (AddSubmonoid.completeLattice.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))))) (Preorder.toLE.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Submodule.completeLattice.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3))))))) (fun (_x : RelIso.{u1, u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (LE.le.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Preorder.toLE.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (AddSubmonoid.completeLattice.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))))))) (LE.le.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Preorder.toLE.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Submodule.completeLattice.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)))))))) => (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) -> (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3))) (RelIso.hasCoeToFun.{u1, u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (LE.le.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Preorder.toLE.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (AddSubmonoid.completeLattice.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))))))) (LE.le.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Preorder.toLE.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Submodule.completeLattice.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)))))))) (AddSubmonoid.toNatSubmodule.{u1} M _inst_3) S)) S
but is expected to have type
  forall {M : Type.{u1}} [_inst_3 : AddCommMonoid.{u1} M] (S : AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))), Eq.{succ u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Submodule.toAddSubmonoid.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3) (FunLike.coe.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3))) (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (fun (_x : AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) => Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3))) (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Function.instEmbeddingLikeEmbedding.{succ u1, succ u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)))) (RelEmbedding.toEmbedding.{u1, u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) => LE.le.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Preorder.toLE.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) => LE.le.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Preorder.toLE.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Submodule.completeLattice.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{u1, u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) => LE.le.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Preorder.toLE.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) => LE.le.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Preorder.toLE.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Submodule.completeLattice.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (AddSubmonoid.toNatSubmodule.{u1} M _inst_3))) S)) S
Case conversion may be inaccurate. Consider using '#align add_submonoid.to_nat_submodule_to_add_submonoid AddSubmonoid.toNatSubmodule_toAddSubmonoidₓ'. -/
@[simp]
theorem AddSubmonoid.toNatSubmodule_toAddSubmonoid (S : AddSubmonoid M) :
    S.toNatSubmodule.toAddSubmonoid = S :=
  AddSubmonoid.toNatSubmodule.symm_apply_apply S
#align add_submonoid.to_nat_submodule_to_add_submonoid AddSubmonoid.toNatSubmodule_toAddSubmonoid

/- warning: submodule.to_add_submonoid_to_nat_submodule -> Submodule.toAddSubmonoid_toNatSubmodule is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_3 : AddCommMonoid.{u1} M] (S : Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)), Eq.{succ u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (coeFn.{succ u1, succ u1} (OrderIso.{u1, u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Preorder.toLE.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (AddSubmonoid.completeLattice.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))))) (Preorder.toLE.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Submodule.completeLattice.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3))))))) (fun (_x : RelIso.{u1, u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (LE.le.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Preorder.toLE.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (AddSubmonoid.completeLattice.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))))))) (LE.le.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Preorder.toLE.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Submodule.completeLattice.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)))))))) => (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) -> (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3))) (RelIso.hasCoeToFun.{u1, u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (LE.le.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Preorder.toLE.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (AddSubmonoid.completeLattice.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))))))) (LE.le.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Preorder.toLE.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Submodule.completeLattice.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)))))))) (AddSubmonoid.toNatSubmodule.{u1} M _inst_3) (Submodule.toAddSubmonoid.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3) S)) S
but is expected to have type
  forall {M : Type.{u1}} [_inst_3 : AddCommMonoid.{u1} M] (S : Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) => Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Submodule.toAddSubmonoid.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3) S)) (FunLike.coe.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3))) (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (fun (_x : AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) => Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3))) (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Function.instEmbeddingLikeEmbedding.{succ u1, succ u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)))) (RelEmbedding.toEmbedding.{u1, u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) => LE.le.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Preorder.toLE.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) => LE.le.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Preorder.toLE.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Submodule.completeLattice.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{u1, u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) => LE.le.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Preorder.toLE.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) => LE.le.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Preorder.toLE.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)) (Submodule.completeLattice.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3)))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (AddSubmonoid.toNatSubmodule.{u1} M _inst_3))) (Submodule.toAddSubmonoid.{0, u1} Nat M Nat.semiring _inst_3 (AddCommMonoid.natModule.{u1} M _inst_3) S)) S
Case conversion may be inaccurate. Consider using '#align submodule.to_add_submonoid_to_nat_submodule Submodule.toAddSubmonoid_toNatSubmoduleₓ'. -/
@[simp]
theorem Submodule.toAddSubmonoid_toNatSubmodule (S : Submodule ℕ M) :
    S.toAddSubmonoid.toNatSubmodule = S :=
  AddSubmonoid.toNatSubmodule.apply_symm_apply S
#align submodule.to_add_submonoid_to_nat_submodule Submodule.toAddSubmonoid_toNatSubmodule

end NatSubmodule

end AddCommMonoid

section IntSubmodule

variable [AddCommGroup M]

/- warning: add_subgroup.to_int_submodule -> AddSubgroup.toIntSubmodule is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : AddCommGroup.{u1} M], OrderIso.{u1, u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Preorder.toLE.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (AddSubgroup.completeLattice.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))))) (Preorder.toLE.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Submodule.completeLattice.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1))))))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : AddCommGroup.{u1} M], OrderIso.{u1, u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Preorder.toLE.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (AddSubgroup.instCompleteLatticeAddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))))) (Preorder.toLE.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Submodule.completeLattice.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1))))))
Case conversion may be inaccurate. Consider using '#align add_subgroup.to_int_submodule AddSubgroup.toIntSubmoduleₓ'. -/
/-- An additive subgroup is equivalent to a ℤ-submodule. -/
def AddSubgroup.toIntSubmodule : AddSubgroup M ≃o Submodule ℤ M
    where
  toFun S := { S with smul_mem' := fun r s hs => S.zsmul_mem hs _ }
  invFun := Submodule.toAddSubgroup
  left_inv := fun ⟨S, _, _, _⟩ => rfl
  right_inv := fun ⟨S, _, _, _⟩ => rfl
  map_rel_iff' a b := Iff.rfl
#align add_subgroup.to_int_submodule AddSubgroup.toIntSubmodule

/- warning: add_subgroup.to_int_submodule_symm -> AddSubgroup.toIntSubmodule_symm is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : AddCommGroup.{u1} M], Eq.{succ u1} ((Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) -> (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))) (coeFn.{succ u1, succ u1} (OrderIso.{u1, u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Preorder.toLE.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Submodule.completeLattice.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)))))) (Preorder.toLE.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (AddSubgroup.completeLattice.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))))))) (fun (_x : RelIso.{u1, u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (LE.le.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Preorder.toLE.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Submodule.completeLattice.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1))))))) (LE.le.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Preorder.toLE.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (AddSubgroup.completeLattice.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))))))) => (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) -> (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))) (RelIso.hasCoeToFun.{u1, u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (LE.le.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Preorder.toLE.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Submodule.completeLattice.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1))))))) (LE.le.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Preorder.toLE.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (AddSubgroup.completeLattice.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))))))) (OrderIso.symm.{u1, u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Preorder.toLE.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (AddSubgroup.completeLattice.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))))) (Preorder.toLE.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Submodule.completeLattice.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)))))) (AddSubgroup.toIntSubmodule.{u1} M _inst_1))) (Submodule.toAddSubgroup.{0, u1} Int M Int.ring _inst_1 (AddCommGroup.intModule.{u1} M _inst_1))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : AddCommGroup.{u1} M], Eq.{succ u1} (forall (ᾰ : Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)), (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) => AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))) (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (fun (_x : Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) => AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))) (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Function.instEmbeddingLikeEmbedding.{succ u1, succ u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))) (RelEmbedding.toEmbedding.{u1, u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) => LE.le.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Preorder.toLE.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Submodule.completeLattice.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) => LE.le.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Preorder.toLE.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (AddSubgroup.instCompleteLatticeAddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{u1, u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) => LE.le.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Preorder.toLE.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Submodule.completeLattice.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) => LE.le.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Preorder.toLE.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (AddSubgroup.instCompleteLatticeAddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (OrderIso.symm.{u1, u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Preorder.toLE.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (AddSubgroup.instCompleteLatticeAddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))))) (Preorder.toLE.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Submodule.completeLattice.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)))))) (AddSubgroup.toIntSubmodule.{u1} M _inst_1))))) (Submodule.toAddSubgroup.{0, u1} Int M Int.instRingInt _inst_1 (AddCommGroup.intModule.{u1} M _inst_1))
Case conversion may be inaccurate. Consider using '#align add_subgroup.to_int_submodule_symm AddSubgroup.toIntSubmodule_symmₓ'. -/
@[simp]
theorem AddSubgroup.toIntSubmodule_symm :
    ⇑(AddSubgroup.toIntSubmodule.symm : _ ≃o AddSubgroup M) = Submodule.toAddSubgroup :=
  rfl
#align add_subgroup.to_int_submodule_symm AddSubgroup.toIntSubmodule_symm

/- warning: add_subgroup.coe_to_int_submodule -> AddSubgroup.coe_toIntSubmodule is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : AddCommGroup.{u1} M] (S : AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)), Eq.{succ u1} (Set.{u1} M) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Set.{u1} M) (HasLiftT.mk.{succ u1, succ u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Set.{u1} M) (CoeTCₓ.coe.{succ u1, succ u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Set.{u1} M) (SetLike.Set.hasCoeT.{u1, u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) M (Submodule.setLike.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1))))) (coeFn.{succ u1, succ u1} (OrderIso.{u1, u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Preorder.toLE.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (AddSubgroup.completeLattice.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))))) (Preorder.toLE.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Submodule.completeLattice.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1))))))) (fun (_x : RelIso.{u1, u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (LE.le.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Preorder.toLE.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (AddSubgroup.completeLattice.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))))))) (LE.le.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Preorder.toLE.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Submodule.completeLattice.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)))))))) => (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) -> (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1))) (RelIso.hasCoeToFun.{u1, u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (LE.le.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Preorder.toLE.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (AddSubgroup.completeLattice.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))))))) (LE.le.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Preorder.toLE.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Submodule.completeLattice.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)))))))) (AddSubgroup.toIntSubmodule.{u1} M _inst_1) S)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Set.{u1} M) (HasLiftT.mk.{succ u1, succ u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Set.{u1} M) (CoeTCₓ.coe.{succ u1, succ u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Set.{u1} M) (SetLike.Set.hasCoeT.{u1, u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) M (AddSubgroup.setLike.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))))) S)
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : AddCommGroup.{u1} M] (S : AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)), Eq.{succ u1} (Set.{u1} M) (SetLike.coe.{u1, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) => Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) S) M (Submodule.instSetLikeSubmodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (FunLike.coe.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1))) (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (fun (_x : AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) => Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1))) (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Function.instEmbeddingLikeEmbedding.{succ u1, succ u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)))) (RelEmbedding.toEmbedding.{u1, u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) => LE.le.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Preorder.toLE.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (AddSubgroup.instCompleteLatticeAddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) => LE.le.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Preorder.toLE.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Submodule.completeLattice.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{u1, u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) => LE.le.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Preorder.toLE.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (AddSubgroup.instCompleteLatticeAddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) => LE.le.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Preorder.toLE.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Submodule.completeLattice.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (AddSubgroup.toIntSubmodule.{u1} M _inst_1))) S)) (SetLike.coe.{u1, u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) M (AddSubgroup.instSetLikeAddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) S)
Case conversion may be inaccurate. Consider using '#align add_subgroup.coe_to_int_submodule AddSubgroup.coe_toIntSubmoduleₓ'. -/
@[simp]
theorem AddSubgroup.coe_toIntSubmodule (S : AddSubgroup M) : (S.toIntSubmodule : Set M) = S :=
  rfl
#align add_subgroup.coe_to_int_submodule AddSubgroup.coe_toIntSubmodule

/- warning: add_subgroup.to_int_submodule_to_add_subgroup -> AddSubgroup.toIntSubmodule_toAddSubgroup is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : AddCommGroup.{u1} M] (S : AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)), Eq.{succ u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Submodule.toAddSubgroup.{0, u1} Int M Int.ring _inst_1 (AddCommGroup.intModule.{u1} M _inst_1) (coeFn.{succ u1, succ u1} (OrderIso.{u1, u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Preorder.toLE.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (AddSubgroup.completeLattice.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))))) (Preorder.toLE.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Submodule.completeLattice.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1))))))) (fun (_x : RelIso.{u1, u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (LE.le.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Preorder.toLE.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (AddSubgroup.completeLattice.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))))))) (LE.le.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Preorder.toLE.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Submodule.completeLattice.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)))))))) => (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) -> (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1))) (RelIso.hasCoeToFun.{u1, u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (LE.le.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Preorder.toLE.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (AddSubgroup.completeLattice.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))))))) (LE.le.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Preorder.toLE.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Submodule.completeLattice.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)))))))) (AddSubgroup.toIntSubmodule.{u1} M _inst_1) S)) S
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : AddCommGroup.{u1} M] (S : AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)), Eq.{succ u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Submodule.toAddSubgroup.{0, u1} Int M Int.instRingInt _inst_1 (AddCommGroup.intModule.{u1} M _inst_1) (FunLike.coe.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1))) (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (fun (_x : AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) => Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1))) (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Function.instEmbeddingLikeEmbedding.{succ u1, succ u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)))) (RelEmbedding.toEmbedding.{u1, u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) => LE.le.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Preorder.toLE.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (AddSubgroup.instCompleteLatticeAddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) => LE.le.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Preorder.toLE.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Submodule.completeLattice.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{u1, u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) => LE.le.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Preorder.toLE.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (AddSubgroup.instCompleteLatticeAddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) => LE.le.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Preorder.toLE.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Submodule.completeLattice.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (AddSubgroup.toIntSubmodule.{u1} M _inst_1))) S)) S
Case conversion may be inaccurate. Consider using '#align add_subgroup.to_int_submodule_to_add_subgroup AddSubgroup.toIntSubmodule_toAddSubgroupₓ'. -/
@[simp]
theorem AddSubgroup.toIntSubmodule_toAddSubgroup (S : AddSubgroup M) :
    S.toIntSubmodule.toAddSubgroup = S :=
  AddSubgroup.toIntSubmodule.symm_apply_apply S
#align add_subgroup.to_int_submodule_to_add_subgroup AddSubgroup.toIntSubmodule_toAddSubgroup

/- warning: submodule.to_add_subgroup_to_int_submodule -> Submodule.toAddSubgroup_toIntSubmodule is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : AddCommGroup.{u1} M] (S : Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)), Eq.{succ u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (coeFn.{succ u1, succ u1} (OrderIso.{u1, u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Preorder.toLE.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (AddSubgroup.completeLattice.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))))) (Preorder.toLE.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Submodule.completeLattice.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1))))))) (fun (_x : RelIso.{u1, u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (LE.le.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Preorder.toLE.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (AddSubgroup.completeLattice.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))))))) (LE.le.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Preorder.toLE.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Submodule.completeLattice.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)))))))) => (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) -> (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1))) (RelIso.hasCoeToFun.{u1, u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (LE.le.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Preorder.toLE.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (AddSubgroup.completeLattice.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1))))))) (LE.le.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Preorder.toLE.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Submodule.completeLattice.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)))))))) (AddSubgroup.toIntSubmodule.{u1} M _inst_1) (Submodule.toAddSubgroup.{0, u1} Int M Int.ring _inst_1 (AddCommGroup.intModule.{u1} M _inst_1) S)) S
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : AddCommGroup.{u1} M] (S : Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) => Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Submodule.toAddSubgroup.{0, u1} Int M Int.instRingInt _inst_1 (AddCommGroup.intModule.{u1} M _inst_1) S)) (FunLike.coe.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1))) (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (fun (_x : AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) => Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1))) (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Function.instEmbeddingLikeEmbedding.{succ u1, succ u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)))) (RelEmbedding.toEmbedding.{u1, u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) => LE.le.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Preorder.toLE.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (AddSubgroup.instCompleteLatticeAddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) => LE.le.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Preorder.toLE.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Submodule.completeLattice.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{u1, u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) => LE.le.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (Preorder.toLE.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)) (AddSubgroup.instCompleteLatticeAddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) => LE.le.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Preorder.toLE.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submodule.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)) (Submodule.completeLattice.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1)))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (AddSubgroup.toIntSubmodule.{u1} M _inst_1))) (Submodule.toAddSubgroup.{0, u1} Int M Int.instRingInt _inst_1 (AddCommGroup.intModule.{u1} M _inst_1) S)) S
Case conversion may be inaccurate. Consider using '#align submodule.to_add_subgroup_to_int_submodule Submodule.toAddSubgroup_toIntSubmoduleₓ'. -/
@[simp]
theorem Submodule.toAddSubgroup_toIntSubmodule (S : Submodule ℤ M) :
    S.toAddSubgroup.toIntSubmodule = S :=
  AddSubgroup.toIntSubmodule.apply_symm_apply S
#align submodule.to_add_subgroup_to_int_submodule Submodule.toAddSubgroup_toIntSubmodule

end IntSubmodule

