/-
Copyright (c) 2022 Pierre-Alexandre Bazin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Pierre-Alexandre Bazin

! This file was ported from Lean 3 source module algebra.module.torsion
! leanprover-community/mathlib commit 0b7c740e25651db0ba63648fbae9f9d6f941e31b
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.DirectSum.Module
import Mathbin.Algebra.Module.BigOperators
import Mathbin.LinearAlgebra.Isomorphisms
import Mathbin.GroupTheory.Torsion
import Mathbin.RingTheory.Coprime.Ideal
import Mathbin.RingTheory.Finiteness

/-!
# Torsion submodules

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

## Main definitions

* `torsion_of R M x` : the torsion ideal of `x`, containing all `a` such that `a • x = 0`.
* `submodule.torsion_by R M a` : the `a`-torsion submodule, containing all elements `x` of `M` such
  that `a • x = 0`.
* `submodule.torsion_by_set R M s` : the submodule containing all elements `x` of `M` such that
  `a • x = 0` for all `a` in `s`.
* `submodule.torsion' R M S` : the `S`-torsion submodule, containing all elements `x` of `M` such
  that `a • x = 0` for some `a` in `S`.
* `submodule.torsion R M` : the torsion submoule, containing all elements `x` of `M` such that
  `a • x = 0` for some non-zero-divisor `a` in `R`.
* `module.is_torsion_by R M a` : the property that defines a `a`-torsion module. Similarly,
  `is_torsion_by_set`, `is_torsion'` and `is_torsion`.
* `module.is_torsion_by_set.module` : Creates a `R ⧸ I`-module from a `R`-module that
  `is_torsion_by_set R _ I`.

## Main statements

* `quot_torsion_of_equiv_span_singleton` : isomorphism between the span of an element of `M` and
  the quotient by its torsion ideal.
* `torsion' R M S` and `torsion R M` are submodules.
* `torsion_by_set_eq_torsion_by_span` : torsion by a set is torsion by the ideal generated by it.
* `submodule.torsion_by_is_torsion_by` : the `a`-torsion submodule is a `a`-torsion module.
  Similar lemmas for `torsion'` and `torsion`.
* `submodule.torsion_by_is_internal` : a `∏ i, p i`-torsion module is the internal direct sum of its
  `p i`-torsion submodules when the `p i` are pairwise coprime. A more general version with coprime
  ideals is `submodule.torsion_by_set_is_internal`.
* `submodule.no_zero_smul_divisors_iff_torsion_bot` : a module over a domain has
  `no_zero_smul_divisors` (that is, there is no non-zero `a`, `x` such that `a • x = 0`)
  iff its torsion submodule is trivial.
* `submodule.quotient_torsion.torsion_eq_bot` : quotienting by the torsion submodule makes the
  torsion submodule of the new module trivial. If `R` is a domain, we can derive an instance
  `submodule.quotient_torsion.no_zero_smul_divisors : no_zero_smul_divisors R (M ⧸ torsion R M)`.

## Notation

* The notions are defined for a `comm_semiring R` and a `module R M`. Some additional hypotheses on
  `R` and `M` are required by some lemmas.
* The letters `a`, `b`, ... are used for scalars (in `R`), while `x`, `y`, ... are used for vectors
  (in `M`).

## Tags

Torsion, submodule, module, quotient
-/


namespace Ideal

section TorsionOf

variable (R M : Type _) [Semiring R] [AddCommMonoid M] [Module R M]

#print Ideal.torsionOf /-
/-- The torsion ideal of `x`, containing all `a` such that `a • x = 0`.-/
@[simps]
def torsionOf (x : M) : Ideal R :=
  (LinearMap.toSpanSingleton R M x).ker
#align ideal.torsion_of Ideal.torsionOf
-/

/- warning: ideal.torsion_of_zero -> Ideal.torsionOf_zero is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], Eq.{succ u1} (Ideal.{u1} R _inst_1) (Ideal.torsionOf.{u1, u2} R M _inst_1 _inst_2 _inst_3 (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))))) (Top.top.{u1} (Ideal.{u1} R _inst_1) (Submodule.hasTop.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))
but is expected to have type
  forall (R : Type.{u2}) (M : Type.{u1}) [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2], Eq.{succ u2} (Ideal.{u2} R _inst_1) (Ideal.torsionOf.{u2, u1} R M _inst_1 _inst_2 _inst_3 (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))))) (Top.top.{u2} (Ideal.{u2} R _inst_1) (Submodule.instTopSubmodule.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)))
Case conversion may be inaccurate. Consider using '#align ideal.torsion_of_zero Ideal.torsionOf_zeroₓ'. -/
@[simp]
theorem torsionOf_zero : torsionOf R M (0 : M) = ⊤ := by simp [torsion_of]
#align ideal.torsion_of_zero Ideal.torsionOf_zero

variable {R M}

/- warning: ideal.mem_torsion_of_iff -> Ideal.mem_torsionOf_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (x : M) (a : R), Iff (Membership.Mem.{u1, u1} R (Ideal.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R _inst_1) R (Submodule.setLike.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) a (Ideal.torsionOf.{u1, u2} R M _inst_1 _inst_2 _inst_3 x)) (Eq.{succ u2} M (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) a x) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] (x : M) (a : R), Iff (Membership.mem.{u2, u2} R (Ideal.{u2} R _inst_1) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R _inst_1) R (Submodule.setLike.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) a (Ideal.torsionOf.{u2, u1} R M _inst_1 _inst_2 _inst_3 x)) (Eq.{succ u1} M (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 _inst_3))))) a x) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)))))
Case conversion may be inaccurate. Consider using '#align ideal.mem_torsion_of_iff Ideal.mem_torsionOf_iffₓ'. -/
@[simp]
theorem mem_torsionOf_iff (x : M) (a : R) : a ∈ torsionOf R M x ↔ a • x = 0 :=
  Iff.rfl
#align ideal.mem_torsion_of_iff Ideal.mem_torsionOf_iff

variable (R)

/- warning: ideal.torsion_of_eq_top_iff -> Ideal.torsionOf_eq_top_iff is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (m : M), Iff (Eq.{succ u1} (Ideal.{u1} R _inst_1) (Ideal.torsionOf.{u1, u2} R M _inst_1 _inst_2 _inst_3 m) (Top.top.{u1} (Ideal.{u1} R _inst_1) (Submodule.hasTop.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))) (Eq.{succ u2} M m (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))))
but is expected to have type
  forall (R : Type.{u2}) {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] (m : M), Iff (Eq.{succ u2} (Ideal.{u2} R _inst_1) (Ideal.torsionOf.{u2, u1} R M _inst_1 _inst_2 _inst_3 m) (Top.top.{u2} (Ideal.{u2} R _inst_1) (Submodule.instTopSubmodule.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)))) (Eq.{succ u1} M m (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)))))
Case conversion may be inaccurate. Consider using '#align ideal.torsion_of_eq_top_iff Ideal.torsionOf_eq_top_iffₓ'. -/
@[simp]
theorem torsionOf_eq_top_iff (m : M) : torsionOf R M m = ⊤ ↔ m = 0 :=
  by
  refine' ⟨fun h => _, fun h => by simp [h]⟩
  rw [← one_smul R m, ← mem_torsion_of_iff m (1 : R), h]
  exact Submodule.mem_top
#align ideal.torsion_of_eq_top_iff Ideal.torsionOf_eq_top_iff

/- warning: ideal.torsion_of_eq_bot_iff_of_no_zero_smul_divisors -> Ideal.torsionOf_eq_bot_iff_of_noZeroSMulDivisors is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_4 : Nontrivial.{u1} R] [_inst_5 : NoZeroSMulDivisors.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))] (m : M), Iff (Eq.{succ u1} (Ideal.{u1} R _inst_1) (Ideal.torsionOf.{u1, u2} R M _inst_1 _inst_2 _inst_3 m) (Bot.bot.{u1} (Ideal.{u1} R _inst_1) (Submodule.hasBot.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))) (Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))))
but is expected to have type
  forall (R : Type.{u2}) {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] [_inst_4 : Nontrivial.{u2} R] [_inst_5 : NoZeroSMulDivisors.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 _inst_3))))] (m : M), Iff (Eq.{succ u2} (Ideal.{u2} R _inst_1) (Ideal.torsionOf.{u2, u1} R M _inst_1 _inst_2 _inst_3 m) (Bot.bot.{u2} (Ideal.{u2} R _inst_1) (Submodule.instBotSubmodule.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)))) (Ne.{succ u1} M m (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)))))
Case conversion may be inaccurate. Consider using '#align ideal.torsion_of_eq_bot_iff_of_no_zero_smul_divisors Ideal.torsionOf_eq_bot_iff_of_noZeroSMulDivisorsₓ'. -/
@[simp]
theorem torsionOf_eq_bot_iff_of_noZeroSMulDivisors [Nontrivial R] [NoZeroSMulDivisors R M] (m : M) :
    torsionOf R M m = ⊥ ↔ m ≠ 0 :=
  by
  refine' ⟨fun h contra => _, fun h => (Submodule.eq_bot_iff _).mpr fun r hr => _⟩
  · rw [contra, torsion_of_zero] at h
    exact bot_ne_top.symm h
  · rw [mem_torsion_of_iff, smul_eq_zero] at hr
    tauto
#align ideal.torsion_of_eq_bot_iff_of_no_zero_smul_divisors Ideal.torsionOf_eq_bot_iff_of_noZeroSMulDivisors

/- warning: ideal.complete_lattice.independent.linear_independent' -> Ideal.CompleteLattice.Independent.linear_independent' is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_4 : Ring.{u2} R] [_inst_5 : AddCommGroup.{u3} M] [_inst_6 : Module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_4) (AddCommGroup.toAddCommMonoid.{u3} M _inst_5)], (CompleteLattice.Independent.{succ u1, u3} ι (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_4) (AddCommGroup.toAddCommMonoid.{u3} M _inst_5) _inst_6) (Submodule.completeLattice.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_4) (AddCommGroup.toAddCommMonoid.{u3} M _inst_5) _inst_6) (fun (i : ι) => Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_4) (AddCommGroup.toAddCommMonoid.{u3} M _inst_5) _inst_6 (Singleton.singleton.{u3, u3} M (Set.{u3} M) (Set.hasSingleton.{u3} M) (v i)))) -> (forall (i : ι), Eq.{succ u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R _inst_4)) (Ideal.torsionOf.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_4) (AddCommGroup.toAddCommMonoid.{u3} M _inst_5) _inst_6 (v i)) (Bot.bot.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R _inst_4)) (Submodule.hasBot.{u2, u2} R R (Ring.toSemiring.{u2} R _inst_4) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_4)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_4))))) -> (LinearIndependent.{u1, u2, u3} ι R M v (Ring.toSemiring.{u2} R _inst_4) (AddCommGroup.toAddCommMonoid.{u3} M _inst_5) _inst_6)
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} {v : ι -> M} [_inst_4 : Ring.{u2} R] [_inst_5 : AddCommGroup.{u1} M] [_inst_6 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_4) (AddCommGroup.toAddCommMonoid.{u1} M _inst_5)], (CompleteLattice.Independent.{succ u3, u1} ι (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_4) (AddCommGroup.toAddCommMonoid.{u1} M _inst_5) _inst_6) (Submodule.completeLattice.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_4) (AddCommGroup.toAddCommMonoid.{u1} M _inst_5) _inst_6) (fun (i : ι) => Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_4) (AddCommGroup.toAddCommMonoid.{u1} M _inst_5) _inst_6 (Singleton.singleton.{u1, u1} M (Set.{u1} M) (Set.instSingletonSet.{u1} M) (v i)))) -> (forall (i : ι), Eq.{succ u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R _inst_4)) (Ideal.torsionOf.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_4) (AddCommGroup.toAddCommMonoid.{u1} M _inst_5) _inst_6 (v i)) (Bot.bot.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R _inst_4)) (Submodule.instBotSubmodule.{u2, u2} R R (Ring.toSemiring.{u2} R _inst_4) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_4)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_4))))) -> (LinearIndependent.{u3, u2, u1} ι R M v (Ring.toSemiring.{u2} R _inst_4) (AddCommGroup.toAddCommMonoid.{u1} M _inst_5) _inst_6)
Case conversion may be inaccurate. Consider using '#align ideal.complete_lattice.independent.linear_independent' Ideal.CompleteLattice.Independent.linear_independent'ₓ'. -/
/-- See also `complete_lattice.independent.linear_independent` which provides the same conclusion
but requires the stronger hypothesis `no_zero_smul_divisors R M`. -/
theorem CompleteLattice.Independent.linear_independent' {ι R M : Type _} {v : ι → M} [Ring R]
    [AddCommGroup M] [Module R M] (hv : CompleteLattice.Independent fun i => R ∙ v i)
    (h_ne_zero : ∀ i, Ideal.torsionOf R M (v i) = ⊥) : LinearIndependent R v :=
  by
  refine' linear_independent_iff_not_smul_mem_span.mpr fun i r hi => _
  replace hv := complete_lattice.independent_def.mp hv i
  simp only [iSup_subtype', ← Submodule.span_range_eq_iSup, disjoint_iff] at hv
  have : r • v i ∈ ⊥ := by
    rw [← hv, Submodule.mem_inf]
    refine' ⟨submodule.mem_span_singleton.mpr ⟨r, rfl⟩, _⟩
    convert hi
    ext
    simp
  rw [← Submodule.mem_bot R, ← h_ne_zero i]
  simpa using this
#align ideal.complete_lattice.independent.linear_independent' Ideal.CompleteLattice.Independent.linear_independent'

end TorsionOf

section

variable (R M : Type _) [Ring R] [AddCommGroup M] [Module R M]

#print Ideal.quotTorsionOfEquivSpanSingleton /-
/-- The span of `x` in `M` is isomorphic to `R` quotiented by the torsion ideal of `x`.-/
noncomputable def quotTorsionOfEquivSpanSingleton (x : M) : (R ⧸ torsionOf R M x) ≃ₗ[R] R ∙ x :=
  (LinearMap.toSpanSingleton R M x).quotKerEquivRange.trans <|
    LinearEquiv.ofEq _ _ (LinearMap.span_singleton_eq_range R M x).symm
#align ideal.quot_torsion_of_equiv_span_singleton Ideal.quotTorsionOfEquivSpanSingleton
-/

variable {R M}

/- warning: ideal.quot_torsion_of_equiv_span_singleton_apply_mk -> Ideal.quotTorsionOfEquivSpanSingleton_apply_mk is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align ideal.quot_torsion_of_equiv_span_singleton_apply_mk Ideal.quotTorsionOfEquivSpanSingleton_apply_mkₓ'. -/
@[simp]
theorem quotTorsionOfEquivSpanSingleton_apply_mk (x : M) (a : R) :
    quotTorsionOfEquivSpanSingleton R M x (Submodule.Quotient.mk a) =
      a • ⟨x, Submodule.mem_span_singleton_self x⟩ :=
  rfl
#align ideal.quot_torsion_of_equiv_span_singleton_apply_mk Ideal.quotTorsionOfEquivSpanSingleton_apply_mk

end

end Ideal

open nonZeroDivisors

section Defs

variable (R M : Type _) [CommSemiring R] [AddCommMonoid M] [Module R M]

namespace Submodule

#print Submodule.torsionBy /-
/-- The `a`-torsion submodule for `a` in `R`, containing all elements `x` of `M` such that
  `a • x = 0`. -/
@[simps]
def torsionBy (a : R) : Submodule R M :=
  (DistribMulAction.toLinearMap R M a).ker
#align submodule.torsion_by Submodule.torsionBy
-/

#print Submodule.torsionBySet /-
/-- The submodule containing all elements `x` of `M` such that `a • x = 0` for all `a` in `s`. -/
@[simps]
def torsionBySet (s : Set R) : Submodule R M :=
  sInf (torsionBy R M '' s)
#align submodule.torsion_by_set Submodule.torsionBySet
-/

/- warning: submodule.torsion' -> Submodule.torsion' is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (S : Type.{u3}) [_inst_4 : CommMonoid.{u3} S] [_inst_5 : DistribMulAction.{u3, u2} S M (CommMonoid.toMonoid.{u3} S _inst_4) (AddCommMonoid.toAddMonoid.{u2} M _inst_2)] [_inst_6 : SMulCommClass.{u3, u1, u2} S R M (SMulZeroClass.toHasSmul.{u3, u2} S M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (DistribSMul.toSmulZeroClass.{u3, u2} S M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u3, u2} S M (CommMonoid.toMonoid.{u3} S _inst_4) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_5))) (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))], Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3
but is expected to have type
  forall (R : Type.{u2}) (M : Type.{u3}) [_inst_1 : CommSemiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2] (S : Type.{u1}) [_inst_4 : CommMonoid.{u1} S] [_inst_5 : DistribMulAction.{u1, u3} S M (CommMonoid.toMonoid.{u1} S _inst_4) (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_6 : SMulCommClass.{u1, u2, u3} S R M (SMulZeroClass.toSMul.{u1, u3} S M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u3} S M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u3} S M (CommMonoid.toMonoid.{u1} S _inst_4) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5))) (SMulZeroClass.toSMul.{u2, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u3} R M (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3))))], Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3
Case conversion may be inaccurate. Consider using '#align submodule.torsion' Submodule.torsion'ₓ'. -/
/-- The `S`-torsion submodule, containing all elements `x` of `M` such that `a • x = 0` for some
`a` in `S`. -/
@[simps]
def torsion' (S : Type _) [CommMonoid S] [DistribMulAction S M] [SMulCommClass S R M] :
    Submodule R M where
  carrier := { x | ∃ a : S, a • x = 0 }
  zero_mem' := ⟨1, smul_zero _⟩
  add_mem' := fun x y ⟨a, hx⟩ ⟨b, hy⟩ =>
    ⟨b * a, by rw [smul_add, mul_smul, mul_comm, mul_smul, hx, hy, smul_zero, smul_zero, add_zero]⟩
  smul_mem' := fun a x ⟨b, h⟩ => ⟨b, by rw [smul_comm, h, smul_zero]⟩
#align submodule.torsion' Submodule.torsion'

#print Submodule.torsion /-
/-- The torsion submodule, containing all elements `x` of `M` such that  `a • x = 0` for some
  non-zero-divisor `a` in `R`. -/
@[reducible]
def torsion :=
  torsion' R M R⁰
#align submodule.torsion Submodule.torsion
-/

end Submodule

namespace Module

#print Module.IsTorsionBy /-
/-- A `a`-torsion module is a module where every element is `a`-torsion. -/
@[reducible]
def IsTorsionBy (a : R) :=
  ∀ ⦃x : M⦄, a • x = 0
#align module.is_torsion_by Module.IsTorsionBy
-/

#print Module.IsTorsionBySet /-
/-- A module where every element is `a`-torsion for all `a` in `s`. -/
@[reducible]
def IsTorsionBySet (s : Set R) :=
  ∀ ⦃x : M⦄ ⦃a : s⦄, (a : R) • x = 0
#align module.is_torsion_by_set Module.IsTorsionBySet
-/

#print Module.IsTorsion' /-
/-- A `S`-torsion module is a module where every element is `a`-torsion for some `a` in `S`. -/
@[reducible]
def IsTorsion' (S : Type _) [SMul S M] :=
  ∀ ⦃x : M⦄, ∃ a : S, a • x = 0
#align module.is_torsion' Module.IsTorsion'
-/

#print Module.IsTorsion /-
/-- A torsion module is a module where every element is `a`-torsion for some non-zero-divisor `a`.
-/
@[reducible]
def IsTorsion :=
  ∀ ⦃x : M⦄, ∃ a : R⁰, a • x = 0
#align module.is_torsion Module.IsTorsion
-/

end Module

end Defs

variable {R M : Type _}

section

variable [CommSemiring R] [AddCommMonoid M] [Module R M] (s : Set R) (a : R)

namespace Submodule

#print Submodule.smul_torsionBy /-
@[simp]
theorem smul_torsionBy (x : torsionBy R M a) : a • x = 0 :=
  Subtype.ext x.Prop
#align submodule.smul_torsion_by Submodule.smul_torsionBy
-/

/- warning: submodule.smul_coe_torsion_by -> Submodule.smul_coe_torsionBy is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (a : R) (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a)), Eq.{succ u2} M (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))) a ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a)) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a)) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a)) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a)) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a)))))) x)) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (a : R) (x : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a))), Eq.{succ u2} M (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))) a (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a))) x)) (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))
Case conversion may be inaccurate. Consider using '#align submodule.smul_coe_torsion_by Submodule.smul_coe_torsionByₓ'. -/
@[simp]
theorem smul_coe_torsionBy (x : torsionBy R M a) : a • (x : M) = 0 :=
  x.Prop
#align submodule.smul_coe_torsion_by Submodule.smul_coe_torsionBy

/- warning: submodule.mem_torsion_by_iff -> Submodule.mem_torsionBy_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (a : R) (x : M), Iff (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a)) (Eq.{succ u2} M (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))) a x) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (a : R) (x : M), Iff (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a)) (Eq.{succ u2} M (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))) a x) (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))
Case conversion may be inaccurate. Consider using '#align submodule.mem_torsion_by_iff Submodule.mem_torsionBy_iffₓ'. -/
@[simp]
theorem mem_torsionBy_iff (x : M) : x ∈ torsionBy R M a ↔ a • x = 0 :=
  Iff.rfl
#align submodule.mem_torsion_by_iff Submodule.mem_torsionBy_iff

/- warning: submodule.mem_torsion_by_set_iff -> Submodule.mem_torsionBySet_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (s : Set.{u1} R) (x : M), Iff (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) (forall (a : coeSort.{succ u1, succ (succ u1)} (Set.{u1} R) Type.{u1} (Set.hasCoeToSort.{u1} R) s), Eq.{succ u2} M (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} R) Type.{u1} (Set.hasCoeToSort.{u1} R) s) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} R) Type.{u1} (Set.hasCoeToSort.{u1} R) s) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} R) Type.{u1} (Set.hasCoeToSort.{u1} R) s) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} R) Type.{u1} (Set.hasCoeToSort.{u1} R) s) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Set.{u1} R) (Set.hasMem.{u1} R) x s))))) a) x) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (s : Set.{u1} R) (x : M), Iff (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) (forall (a : Set.Elem.{u1} R s), Eq.{succ u2} M (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x s) a) x) (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))
Case conversion may be inaccurate. Consider using '#align submodule.mem_torsion_by_set_iff Submodule.mem_torsionBySet_iffₓ'. -/
@[simp]
theorem mem_torsionBySet_iff (x : M) : x ∈ torsionBySet R M s ↔ ∀ a : s, (a : R) • x = 0 :=
  by
  refine' ⟨fun h ⟨a, ha⟩ => mem_Inf.mp h _ (Set.mem_image_of_mem _ ha), fun h => mem_Inf.mpr _⟩
  rintro _ ⟨a, ha, rfl⟩; exact h ⟨a, ha⟩
#align submodule.mem_torsion_by_set_iff Submodule.mem_torsionBySet_iff

#print Submodule.torsionBySet_singleton_eq /-
@[simp]
theorem torsionBySet_singleton_eq : torsionBySet R M {a} = torsionBy R M a :=
  by
  ext x
  simp only [mem_torsion_by_set_iff, SetCoe.forall, Subtype.coe_mk, Set.mem_singleton_iff,
    forall_eq, mem_torsion_by_iff]
#align submodule.torsion_by_singleton_eq Submodule.torsionBySet_singleton_eq
-/

/- warning: submodule.torsion_by_set_le_torsion_by_set_of_subset -> Submodule.torsionBySet_le_torsionBySet_of_subset is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] {s : Set.{u1} R} {t : Set.{u1} R}, (HasSubset.Subset.{u1} (Set.{u1} R) (Set.hasSubset.{u1} R) s t) -> (LE.le.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))) (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 t) (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 s))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2] {s : Set.{u2} R} {t : Set.{u2} R}, (HasSubset.Subset.{u2} (Set.{u2} R) (Set.instHasSubsetSet.{u2} R) s t) -> (LE.le.{u1} (Submodule.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (Preorder.toLE.{u1} (Submodule.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3))))) (Submodule.torsionBySet.{u2, u1} R M _inst_1 _inst_2 _inst_3 t) (Submodule.torsionBySet.{u2, u1} R M _inst_1 _inst_2 _inst_3 s))
Case conversion may be inaccurate. Consider using '#align submodule.torsion_by_set_le_torsion_by_set_of_subset Submodule.torsionBySet_le_torsionBySet_of_subsetₓ'. -/
theorem torsionBySet_le_torsionBySet_of_subset {s t : Set R} (st : s ⊆ t) :
    torsionBySet R M t ≤ torsionBySet R M s :=
  sInf_le_sInf fun _ ⟨a, ha, h⟩ => ⟨a, st ha, h⟩
#align submodule.torsion_by_set_le_torsion_by_set_of_subset Submodule.torsionBySet_le_torsionBySet_of_subset

#print Submodule.torsionBySet_eq_torsionBySet_span /-
/-- Torsion by a set is torsion by the ideal generated by it. -/
theorem torsionBySet_eq_torsionBySet_span : torsionBySet R M s = torsionBySet R M (Ideal.span s) :=
  by
  refine' le_antisymm (fun x hx => _) (torsion_by_set_le_torsion_by_set_of_subset subset_span)
  rw [mem_torsion_by_set_iff] at hx⊢
  suffices Ideal.span s ≤ Ideal.torsionOf R M x by rintro ⟨a, ha⟩; exact this ha
  rw [Ideal.span_le]; exact fun a ha => hx ⟨a, ha⟩
#align submodule.torsion_by_set_eq_torsion_by_span Submodule.torsionBySet_eq_torsionBySet_span
-/

#print Submodule.torsionBySet_span_singleton_eq /-
theorem torsionBySet_span_singleton_eq : torsionBySet R M (R ∙ a) = torsionBy R M a :=
  (torsionBySet_eq_torsionBySet_span _).symm.trans <| torsionBySet_singleton_eq _
#align submodule.torsion_by_span_singleton_eq Submodule.torsionBySet_span_singleton_eq
-/

/- warning: submodule.torsion_by_le_torsion_by_of_dvd -> Submodule.torsionBy_le_torsionBy_of_dvd is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (a : R) (b : R), (Dvd.Dvd.{u1} R (semigroupDvd.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} R (CommSemiring.toNonUnitalCommSemiring.{u1} R _inst_1))))) a b) -> (LE.le.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))) (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a) (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 b))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2] (a : R) (b : R), (Dvd.dvd.{u2} R (semigroupDvd.{u2} R (SemigroupWithZero.toSemigroup.{u2} R (NonUnitalSemiring.toSemigroupWithZero.{u2} R (NonUnitalCommSemiring.toNonUnitalSemiring.{u2} R (CommSemiring.toNonUnitalCommSemiring.{u2} R _inst_1))))) a b) -> (LE.le.{u1} (Submodule.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (Preorder.toLE.{u1} (Submodule.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3))))) (Submodule.torsionBy.{u2, u1} R M _inst_1 _inst_2 _inst_3 a) (Submodule.torsionBy.{u2, u1} R M _inst_1 _inst_2 _inst_3 b))
Case conversion may be inaccurate. Consider using '#align submodule.torsion_by_le_torsion_by_of_dvd Submodule.torsionBy_le_torsionBy_of_dvdₓ'. -/
theorem torsionBy_le_torsionBy_of_dvd (a b : R) (dvd : a ∣ b) : torsionBy R M a ≤ torsionBy R M b :=
  by
  rw [← torsion_by_span_singleton_eq, ← torsion_by_singleton_eq]
  apply torsion_by_set_le_torsion_by_set_of_subset
  rintro c (rfl : c = b); exact ideal.mem_span_singleton.mpr dvd
#align submodule.torsion_by_le_torsion_by_of_dvd Submodule.torsionBy_le_torsionBy_of_dvd

/- warning: submodule.torsion_by_one -> Submodule.torsionBy_one is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2], Eq.{succ u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))))) (Bot.bot.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasBot.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2], Eq.{succ u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (Bot.bot.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.instBotSubmodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align submodule.torsion_by_one Submodule.torsionBy_oneₓ'. -/
@[simp]
theorem torsionBy_one : torsionBy R M 1 = ⊥ :=
  eq_bot_iff.mpr fun _ h => by rw [mem_torsion_by_iff, one_smul] at h; exact h
#align submodule.torsion_by_one Submodule.torsionBy_one

/- warning: submodule.torsion_by_univ -> Submodule.torsionBySet_univ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2], Eq.{succ u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Set.univ.{u1} R)) (Bot.bot.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasBot.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2], Eq.{succ u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Set.univ.{u1} R)) (Bot.bot.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.instBotSubmodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align submodule.torsion_by_univ Submodule.torsionBySet_univₓ'. -/
@[simp]
theorem torsionBySet_univ : torsionBySet R M Set.univ = ⊥ :=
  by
  rw [eq_bot_iff, ← torsion_by_one, ← torsion_by_singleton_eq]
  exact torsion_by_set_le_torsion_by_set_of_subset fun _ _ => trivial
#align submodule.torsion_by_univ Submodule.torsionBySet_univ

end Submodule

open Submodule

namespace Module

/- warning: module.is_torsion_by_singleton_iff -> Module.isTorsionBySet_singleton_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (a : R), Iff (Module.IsTorsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) a)) (Module.IsTorsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a)
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2] (a : R), Iff (Module.IsTorsionBySet.{u2, u1} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.instSingletonSet.{u2} R) a)) (Module.IsTorsionBy.{u2, u1} R M _inst_1 _inst_2 _inst_3 a)
Case conversion may be inaccurate. Consider using '#align module.is_torsion_by_singleton_iff Module.isTorsionBySet_singleton_iffₓ'. -/
@[simp]
theorem isTorsionBySet_singleton_iff : IsTorsionBySet R M {a} ↔ IsTorsionBy R M a :=
  by
  refine' ⟨fun h x => @h _ ⟨_, Set.mem_singleton _⟩, fun h x => _⟩
  rintro ⟨b, rfl : b = a⟩; exact @h _
#align module.is_torsion_by_singleton_iff Module.isTorsionBySet_singleton_iff

/- warning: module.is_torsion_by_set_iff_torsion_by_set_eq_top -> Module.isTorsionBySet_iff_torsionBySet_eq_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (s : Set.{u1} R), Iff (Module.IsTorsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 s) (Eq.{succ u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 s) (Top.top.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasTop.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2] (s : Set.{u2} R), Iff (Module.IsTorsionBySet.{u2, u1} R M _inst_1 _inst_2 _inst_3 s) (Eq.{succ u1} (Submodule.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (Submodule.torsionBySet.{u2, u1} R M _inst_1 _inst_2 _inst_3 s) (Top.top.{u1} (Submodule.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (Submodule.instTopSubmodule.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3)))
Case conversion may be inaccurate. Consider using '#align module.is_torsion_by_set_iff_torsion_by_set_eq_top Module.isTorsionBySet_iff_torsionBySet_eq_topₓ'. -/
theorem isTorsionBySet_iff_torsionBySet_eq_top :
    IsTorsionBySet R M s ↔ Submodule.torsionBySet R M s = ⊤ :=
  ⟨fun h => eq_top_iff.mpr fun _ _ => (mem_torsionBySet_iff _ _).mpr <| @h _, fun h x => by
    rw [← mem_torsion_by_set_iff, h]; trivial⟩
#align module.is_torsion_by_set_iff_torsion_by_set_eq_top Module.isTorsionBySet_iff_torsionBySet_eq_top

/- warning: module.is_torsion_by_iff_torsion_by_eq_top -> Module.isTorsionBy_iff_torsionBy_eq_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (a : R), Iff (Module.IsTorsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a) (Eq.{succ u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a) (Top.top.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasTop.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2] (a : R), Iff (Module.IsTorsionBy.{u2, u1} R M _inst_1 _inst_2 _inst_3 a) (Eq.{succ u1} (Submodule.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (Submodule.torsionBy.{u2, u1} R M _inst_1 _inst_2 _inst_3 a) (Top.top.{u1} (Submodule.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (Submodule.instTopSubmodule.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3)))
Case conversion may be inaccurate. Consider using '#align module.is_torsion_by_iff_torsion_by_eq_top Module.isTorsionBy_iff_torsionBy_eq_topₓ'. -/
/-- A `a`-torsion module is a module whose `a`-torsion submodule is the full space. -/
theorem isTorsionBy_iff_torsionBy_eq_top : IsTorsionBy R M a ↔ torsionBy R M a = ⊤ := by
  rw [← torsion_by_singleton_eq, ← is_torsion_by_singleton_iff,
    is_torsion_by_set_iff_torsion_by_set_eq_top]
#align module.is_torsion_by_iff_torsion_by_eq_top Module.isTorsionBy_iff_torsionBy_eq_top

/- warning: module.is_torsion_by_set_iff_is_torsion_by_span -> Module.isTorsionBySet_iff_is_torsion_by_span is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (s : Set.{u1} R), Iff (Module.IsTorsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 s) (Module.IsTorsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) s)))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2] (s : Set.{u2} R), Iff (Module.IsTorsionBySet.{u2, u1} R M _inst_1 _inst_2 _inst_3 s) (Module.IsTorsionBySet.{u2, u1} R M _inst_1 _inst_2 _inst_3 (SetLike.coe.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (Ideal.span.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1) s)))
Case conversion may be inaccurate. Consider using '#align module.is_torsion_by_set_iff_is_torsion_by_span Module.isTorsionBySet_iff_is_torsion_by_spanₓ'. -/
theorem isTorsionBySet_iff_is_torsion_by_span :
    IsTorsionBySet R M s ↔ IsTorsionBySet R M (Ideal.span s) := by
  rw [is_torsion_by_set_iff_torsion_by_set_eq_top, is_torsion_by_set_iff_torsion_by_set_eq_top,
    torsion_by_set_eq_torsion_by_span]
#align module.is_torsion_by_set_iff_is_torsion_by_span Module.isTorsionBySet_iff_is_torsion_by_span

/- warning: module.is_torsion_by_span_singleton_iff -> Module.isTorsionBySet_span_singleton_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (a : R), Iff (Module.IsTorsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Submodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Submodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Submodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Submodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (Submodule.span.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) a)))) (Module.IsTorsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a)
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2] (a : R), Iff (Module.IsTorsionBySet.{u2, u1} R M _inst_1 _inst_2 _inst_3 (SetLike.coe.{u2, u2} (Submodule.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (Submodule.span.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.instSingletonSet.{u2} R) a)))) (Module.IsTorsionBy.{u2, u1} R M _inst_1 _inst_2 _inst_3 a)
Case conversion may be inaccurate. Consider using '#align module.is_torsion_by_span_singleton_iff Module.isTorsionBySet_span_singleton_iffₓ'. -/
theorem isTorsionBySet_span_singleton_iff : IsTorsionBySet R M (R ∙ a) ↔ IsTorsionBy R M a :=
  (isTorsionBySet_iff_is_torsion_by_span _).symm.trans <| isTorsionBySet_singleton_iff _
#align module.is_torsion_by_span_singleton_iff Module.isTorsionBySet_span_singleton_iff

end Module

namespace Submodule

open Module

/- warning: submodule.torsion_by_set_is_torsion_by_set -> Submodule.torsionBySet_isTorsionBySet is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (s : Set.{u1} R), Module.IsTorsionBySet.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) _inst_1 (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) s
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2] (s : Set.{u2} R), Module.IsTorsionBySet.{u2, u1} R (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3)) x (Submodule.torsionBySet.{u2, u1} R M _inst_1 _inst_2 _inst_3 s))) _inst_1 (Submodule.addCommMonoid.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBySet.{u2, u1} R M _inst_1 _inst_2 _inst_3 s)) (Submodule.module.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBySet.{u2, u1} R M _inst_1 _inst_2 _inst_3 s)) s
Case conversion may be inaccurate. Consider using '#align submodule.torsion_by_set_is_torsion_by_set Submodule.torsionBySet_isTorsionBySetₓ'. -/
theorem torsionBySet_isTorsionBySet : IsTorsionBySet R (torsionBySet R M s) s := fun ⟨x, hx⟩ a =>
  Subtype.ext <| (mem_torsionBySet_iff _ _).mp hx a
#align submodule.torsion_by_set_is_torsion_by_set Submodule.torsionBySet_isTorsionBySet

/- warning: submodule.torsion_by_is_torsion_by -> Submodule.torsionBy_isTorsionBy is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (a : R), Module.IsTorsionBy.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a)) _inst_1 (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a)) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a)) a
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2] (a : R), Module.IsTorsionBy.{u2, u1} R (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3)) x (Submodule.torsionBy.{u2, u1} R M _inst_1 _inst_2 _inst_3 a))) _inst_1 (Submodule.addCommMonoid.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBy.{u2, u1} R M _inst_1 _inst_2 _inst_3 a)) (Submodule.module.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBy.{u2, u1} R M _inst_1 _inst_2 _inst_3 a)) a
Case conversion may be inaccurate. Consider using '#align submodule.torsion_by_is_torsion_by Submodule.torsionBy_isTorsionByₓ'. -/
/-- The `a`-torsion submodule is a `a`-torsion module. -/
theorem torsionBy_isTorsionBy : IsTorsionBy R (torsionBy R M a) a := fun _ => smul_torsionBy _ _
#align submodule.torsion_by_is_torsion_by Submodule.torsionBy_isTorsionBy

/- warning: submodule.torsion_by_torsion_by_eq_top -> Submodule.torsionBy_torsionBy_eq_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (a : R), Eq.{succ u2} (Submodule.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a)) (CommSemiring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a)) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a))) (Submodule.torsionBy.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a)) _inst_1 (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a)) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a)) a) (Top.top.{u2} (Submodule.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a)) (CommSemiring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a)) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a))) (Submodule.hasTop.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a)) (CommSemiring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a)) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (a : R), Eq.{succ u2} (Submodule.{u1, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a))) (CommSemiring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a)) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a))) (Submodule.torsionBy.{u1, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a))) _inst_1 (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a)) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a)) a) (Top.top.{u2} (Submodule.{u1, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a))) (CommSemiring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a)) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a))) (Submodule.instTopSubmodule.{u1, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a))) (CommSemiring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a)) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 a))))
Case conversion may be inaccurate. Consider using '#align submodule.torsion_by_torsion_by_eq_top Submodule.torsionBy_torsionBy_eq_topₓ'. -/
@[simp]
theorem torsionBy_torsionBy_eq_top : torsionBy R (torsionBy R M a) a = ⊤ :=
  (isTorsionBy_iff_torsionBy_eq_top a).mp <| torsionBy_isTorsionBy a
#align submodule.torsion_by_torsion_by_eq_top Submodule.torsionBy_torsionBy_eq_top

/- warning: submodule.torsion_by_set_torsion_by_set_eq_top -> Submodule.torsionBySet_torsionBySet_eq_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (s : Set.{u1} R), Eq.{succ u2} (Submodule.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) (CommSemiring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 s))) (Submodule.torsionBySet.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) _inst_1 (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) s) (Top.top.{u2} (Submodule.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) (CommSemiring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 s))) (Submodule.hasTop.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) (CommSemiring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 s))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (s : Set.{u1} R), Eq.{succ u2} (Submodule.{u1, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 s))) (CommSemiring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 s))) (Submodule.torsionBySet.{u1, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 s))) _inst_1 (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) s) (Top.top.{u2} (Submodule.{u1, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 s))) (CommSemiring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 s))) (Submodule.instTopSubmodule.{u1, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 s))) (CommSemiring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 s))))
Case conversion may be inaccurate. Consider using '#align submodule.torsion_by_set_torsion_by_set_eq_top Submodule.torsionBySet_torsionBySet_eq_topₓ'. -/
@[simp]
theorem torsionBySet_torsionBySet_eq_top : torsionBySet R (torsionBySet R M s) s = ⊤ :=
  (isTorsionBySet_iff_torsionBySet_eq_top s).mp <| torsionBySet_isTorsionBySet s
#align submodule.torsion_by_set_torsion_by_set_eq_top Submodule.torsionBySet_torsionBySet_eq_top

variable (R M)

#print Submodule.torsion_gc /-
theorem torsion_gc :
    @GaloisConnection (Submodule R M) (Ideal R)ᵒᵈ _ _ annihilator fun I =>
      torsionBySet R M <| I.ofDual :=
  fun A I =>
  ⟨fun h x hx => (mem_torsionBySet_iff _ _).mpr fun ⟨a, ha⟩ => mem_annihilator.mp (h ha) x hx,
    fun h a ha => mem_annihilator.mpr fun x hx => (mem_torsionBySet_iff _ _).mp (h hx) ⟨a, ha⟩⟩
#align submodule.torsion_gc Submodule.torsion_gc
-/

variable {R M}

section Coprime

open BigOperators

variable {ι : Type _} {p : ι → Ideal R} {S : Finset ι}

variable (hp : (S : Set ι).Pairwise fun i j => p i ⊔ p j = ⊤)

include hp

/- warning: submodule.supr_torsion_by_ideal_eq_torsion_by_infi -> Submodule.iSup_torsionBySet_ideal_eq_torsionBySet_iInf is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] {ι : Type.{u3}} {p : ι -> (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))} {S : Finset.{u3} ι}, (Set.Pairwise.{u3} ι ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Finset.{u3} ι) (Set.{u3} ι) (HasLiftT.mk.{succ u3, succ u3} (Finset.{u3} ι) (Set.{u3} ι) (CoeTCₓ.coe.{succ u3, succ u3} (Finset.{u3} ι) (Set.{u3} ι) (Finset.Set.hasCoeT.{u3} ι))) S) (fun (i : ι) (j : ι) => Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) (p i) (p j)) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) -> (Eq.{succ u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (iSup.{u2, succ u3} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) ι (fun (i : ι) => iSup.{u2, 0} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) (Membership.Mem.{u3, u3} ι (Finset.{u3} ι) (Finset.hasMem.{u3} ι) i S) (fun (H : Membership.Mem.{u3, u3} ι (Finset.{u3} ι) (Finset.hasMem.{u3} ι) i S) => Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (p i))))) (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (iInf.{u1, succ u3} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasInf.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) ι (fun (i : ι) => iInf.{u1, 0} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasInf.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (Membership.Mem.{u3, u3} ι (Finset.{u3} ι) (Finset.hasMem.{u3} ι) i S) (fun (H : Membership.Mem.{u3, u3} ι (Finset.{u3} ι) (Finset.hasMem.{u3} ι) i S) => p i))))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] {ι : Type.{u3}} {p : ι -> (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))} {S : Finset.{u3} ι}, (Set.Pairwise.{u3} ι (Finset.toSet.{u3} ι S) (fun (i : ι) (j : ι) => Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instIdemCommSemiringIdealToSemiring.{u1} R _inst_1))) (p i) (p j)) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instTopSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) -> (forall [inst._@.Mathlib.Algebra.Module.Torsion._hyg.2869 : DecidableEq.{succ u3} ι], Eq.{succ u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (iSup.{u2, succ u3} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) ι (fun (i : ι) => iSup.{u2, 0} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) (Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) i S) (fun (h._@.Mathlib.Algebra.Module.Torsion._hyg.2878 : Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) i S) => Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 (SetLike.coe.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (p i))))) (Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 (SetLike.coe.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (iInf.{u1, succ u3} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instInfSetSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) ι (fun (i : ι) => iInf.{u1, 0} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instInfSetSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) i S) (fun (h._@.Mathlib.Algebra.Module.Torsion._hyg.2919 : Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) i S) => p i))))))
Case conversion may be inaccurate. Consider using '#align submodule.supr_torsion_by_ideal_eq_torsion_by_infi Submodule.iSup_torsionBySet_ideal_eq_torsionBySet_iInfₓ'. -/
theorem iSup_torsionBySet_ideal_eq_torsionBySet_iInf :
    (⨆ i ∈ S, torsionBySet R M <| p i) = torsionBySet R M ↑(⨅ i ∈ S, p i) :=
  by
  cases' S.eq_empty_or_nonempty with h h
  · rw [h]; convert iSup_emptyset; convert torsion_by_univ; convert top_coe; exact iInf_emptyset
  apply le_antisymm
  · apply iSup_le _; intro i; apply iSup_le _; intro is
    apply torsion_by_set_le_torsion_by_set_of_subset
    exact (iInf_le (fun i => ⨅ H : i ∈ S, p i) i).trans (iInf_le _ is)
  · intro x hx
    rw [mem_supr_finset_iff_exists_sum]
    obtain ⟨μ, hμ⟩ :=
      (mem_supr_finset_iff_exists_sum _ _).mp
        ((Ideal.eq_top_iff_one _).mp <| (Ideal.iSup_iInf_eq_top_iff_pairwise h _).mpr hp)
    refine' ⟨fun i => ⟨(μ i : R) • x, _⟩, _⟩
    · rw [mem_torsion_by_set_iff] at hx⊢
      rintro ⟨a, ha⟩; rw [smul_smul]
      suffices : a * μ i ∈ ⨅ i ∈ S, p i; exact hx ⟨_, this⟩
      rw [mem_infi]; intro j; rw [mem_infi]; intro hj
      by_cases ij : j = i
      · rw [ij]; exact Ideal.mul_mem_right _ _ ha
      · have := coe_mem (μ i); simp only [mem_infi] at this
        exact Ideal.mul_mem_left _ _ (this j hj ij)
    · simp_rw [coe_mk]; rw [← Finset.sum_smul, hμ, one_smul]
#align submodule.supr_torsion_by_ideal_eq_torsion_by_infi Submodule.iSup_torsionBySet_ideal_eq_torsionBySet_iInf

/- warning: submodule.sup_indep_torsion_by_ideal -> Submodule.supIndep_torsionBySet_ideal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] {ι : Type.{u3}} {p : ι -> (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))} {S : Finset.{u3} ι}, (Set.Pairwise.{u3} ι ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Finset.{u3} ι) (Set.{u3} ι) (HasLiftT.mk.{succ u3, succ u3} (Finset.{u3} ι) (Set.{u3} ι) (CoeTCₓ.coe.{succ u3, succ u3} (Finset.{u3} ι) (Set.{u3} ι) (Finset.Set.hasCoeT.{u3} ι))) S) (fun (i : ι) (j : ι) => Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) (p i) (p j)) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) -> (Finset.SupIndep.{u2, u3} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) ι (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) (Submodule.orderBot.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) S (fun (i : ι) => Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (p i))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] {ι : Type.{u3}} {p : ι -> (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))} {S : Finset.{u3} ι}, (Set.Pairwise.{u3} ι (Finset.toSet.{u3} ι S) (fun (i : ι) (j : ι) => Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instIdemCommSemiringIdealToSemiring.{u1} R _inst_1))) (p i) (p j)) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instTopSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) -> (forall [inst._@.Mathlib.Algebra.Module.Torsion._hyg.3647 : DecidableEq.{succ u3} ι], Finset.SupIndep.{u2, u3} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) ι (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) (Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderSetLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) S (fun (i : ι) => Submodule.torsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 (SetLike.coe.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (p i))))
Case conversion may be inaccurate. Consider using '#align submodule.sup_indep_torsion_by_ideal Submodule.supIndep_torsionBySet_idealₓ'. -/
theorem supIndep_torsionBySet_ideal : S.SupIndep fun i => torsionBySet R M <| p i :=
  fun T hT i hi hiT =>
  by
  rw [disjoint_iff, Finset.sup_eq_iSup,
    supr_torsion_by_ideal_eq_torsion_by_infi fun i hi j hj ij => hp (hT hi) (hT hj) ij]
  have :=
    @GaloisConnection.u_inf _ _ (OrderDual.toDual _) (OrderDual.toDual _) _ _ _ _ (torsion_gc R M)
  dsimp at this⊢
  rw [← this, Ideal.sup_iInf_eq_top, top_coe, torsion_by_univ]
  intro j hj; apply hp hi (hT hj); rintro rfl; exact hiT hj
#align submodule.sup_indep_torsion_by_ideal Submodule.supIndep_torsionBySet_ideal

omit hp

variable {q : ι → R} (hq : (S : Set ι).Pairwise <| (IsCoprime on q))

include hq

/- warning: submodule.supr_torsion_by_eq_torsion_by_prod -> Submodule.iSup_torsionBy_eq_torsionBy_prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] {ι : Type.{u3}} {S : Finset.{u3} ι} {q : ι -> R}, (Set.Pairwise.{u3} ι ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Finset.{u3} ι) (Set.{u3} ι) (HasLiftT.mk.{succ u3, succ u3} (Finset.{u3} ι) (Set.{u3} ι) (CoeTCₓ.coe.{succ u3, succ u3} (Finset.{u3} ι) (Set.{u3} ι) (Finset.Set.hasCoeT.{u3} ι))) S) (Function.onFun.{succ u3, succ u1, 1} ι R Prop (IsCoprime.{u1} R _inst_1) q)) -> (Eq.{succ u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (iSup.{u2, succ u3} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) ι (fun (i : ι) => iSup.{u2, 0} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) (Membership.Mem.{u3, u3} ι (Finset.{u3} ι) (Finset.hasMem.{u3} ι) i S) (fun (H : Membership.Mem.{u3, u3} ι (Finset.{u3} ι) (Finset.hasMem.{u3} ι) i S) => Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 (q i)))) (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Finset.prod.{u1, u3} R ι (CommSemiring.toCommMonoid.{u1} R _inst_1) S (fun (i : ι) => q i))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] {ι : Type.{u3}} {S : Finset.{u3} ι} {q : ι -> R}, (Set.Pairwise.{u3} ι (Finset.toSet.{u3} ι S) (Function.onFun.{succ u3, succ u1, 1} ι R Prop (IsCoprime.{u1} R _inst_1) q)) -> (forall [inst._@.Mathlib.Algebra.Module.Torsion._hyg.3961 : DecidableEq.{succ u3} ι], Eq.{succ u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (iSup.{u2, succ u3} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) ι (fun (i : ι) => iSup.{u2, 0} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) (Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) i S) (fun (h._@.Mathlib.Algebra.Module.Torsion._hyg.3970 : Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) i S) => Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 (q i)))) (Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Finset.prod.{u1, u3} R ι (CommSemiring.toCommMonoid.{u1} R _inst_1) S (fun (i : ι) => q i))))
Case conversion may be inaccurate. Consider using '#align submodule.supr_torsion_by_eq_torsion_by_prod Submodule.iSup_torsionBy_eq_torsionBy_prodₓ'. -/
theorem iSup_torsionBy_eq_torsionBy_prod :
    (⨆ i ∈ S, torsionBy R M <| q i) = torsionBy R M (∏ i in S, q i) :=
  by
  rw [← torsion_by_span_singleton_eq, Ideal.submodule_span_eq, ←
    Ideal.finset_inf_span_singleton _ _ hq, Finset.inf_eq_iInf, ←
    supr_torsion_by_ideal_eq_torsion_by_infi]
  · congr ; ext : 1; congr ; ext : 1; exact (torsion_by_span_singleton_eq _).symm
  · exact fun i hi j hj ij => (Ideal.sup_eq_top_iff_isCoprime _ _).mpr (hq hi hj ij)
#align submodule.supr_torsion_by_eq_torsion_by_prod Submodule.iSup_torsionBy_eq_torsionBy_prod

/- warning: submodule.sup_indep_torsion_by -> Submodule.supIndep_torsionBy is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] {ι : Type.{u3}} {S : Finset.{u3} ι} {q : ι -> R}, (Set.Pairwise.{u3} ι ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Finset.{u3} ι) (Set.{u3} ι) (HasLiftT.mk.{succ u3, succ u3} (Finset.{u3} ι) (Set.{u3} ι) (CoeTCₓ.coe.{succ u3, succ u3} (Finset.{u3} ι) (Set.{u3} ι) (Finset.Set.hasCoeT.{u3} ι))) S) (Function.onFun.{succ u3, succ u1, 1} ι R Prop (IsCoprime.{u1} R _inst_1) q)) -> (Finset.SupIndep.{u2, u3} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) ι (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) (Submodule.orderBot.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) S (fun (i : ι) => Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 (q i)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] {ι : Type.{u3}} {S : Finset.{u3} ι} {q : ι -> R}, (Set.Pairwise.{u3} ι (Finset.toSet.{u3} ι S) (Function.onFun.{succ u3, succ u1, 1} ι R Prop (IsCoprime.{u1} R _inst_1) q)) -> (forall [inst._@.Mathlib.Algebra.Module.Torsion._hyg.4151 : DecidableEq.{succ u3} ι], Finset.SupIndep.{u2, u3} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) ι (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) (Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderSetLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) S (fun (i : ι) => Submodule.torsionBy.{u1, u2} R M _inst_1 _inst_2 _inst_3 (q i)))
Case conversion may be inaccurate. Consider using '#align submodule.sup_indep_torsion_by Submodule.supIndep_torsionByₓ'. -/
theorem supIndep_torsionBy : S.SupIndep fun i => torsionBy R M <| q i :=
  by
  convert sup_indep_torsion_by_ideal fun i hi j hj ij =>
      (Ideal.sup_eq_top_iff_isCoprime (q i) _).mpr <| hq hi hj ij
  ext : 1; exact (torsion_by_span_singleton_eq _).symm
#align submodule.sup_indep_torsion_by Submodule.supIndep_torsionBy

end Coprime

end Submodule

end

section NeedsGroup

variable [CommRing R] [AddCommGroup M] [Module R M]

namespace Submodule

open BigOperators

variable {ι : Type _} [DecidableEq ι] {S : Finset ι}

/- warning: submodule.torsion_by_set_is_internal -> Submodule.torsionBySet_isInternal is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align submodule.torsion_by_set_is_internal Submodule.torsionBySet_isInternalₓ'. -/
/-- If the `p i` are pairwise coprime, a `⨅ i, p i`-torsion module is the internal direct sum of
its `p i`-torsion submodules.-/
theorem torsionBySet_isInternal {p : ι → Ideal R}
    (hp : (S : Set ι).Pairwise fun i j => p i ⊔ p j = ⊤)
    (hM : Module.IsTorsionBySet R M (⨅ i ∈ S, p i : Ideal R)) :
    DirectSum.IsInternal fun i : S => torsionBySet R M <| p i :=
  DirectSum.isInternal_submodule_of_independent_of_iSup_eq_top
    (CompleteLattice.independent_iff_supIndep.mpr <| supIndep_torsionBySet_ideal hp)
    ((iSup_subtype'' ↑S fun i => torsionBySet R M <| p i).trans <|
      (iSup_torsionBySet_ideal_eq_torsionBySet_iInf hp).trans <|
        (Module.isTorsionBySet_iff_torsionBySet_eq_top _).mp hM)
#align submodule.torsion_by_set_is_internal Submodule.torsionBySet_isInternal

/- warning: submodule.torsion_by_is_internal -> Submodule.torsionBy_isInternal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] {ι : Type.{u3}} [_inst_4 : DecidableEq.{succ u3} ι] {S : Finset.{u3} ι} {q : ι -> R}, (Set.Pairwise.{u3} ι ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Finset.{u3} ι) (Set.{u3} ι) (HasLiftT.mk.{succ u3, succ u3} (Finset.{u3} ι) (Set.{u3} ι) (CoeTCₓ.coe.{succ u3, succ u3} (Finset.{u3} ι) (Set.{u3} ι) (Finset.Set.hasCoeT.{u3} ι))) S) (Function.onFun.{succ u3, succ u1, 1} ι R Prop (IsCoprime.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) q)) -> (Module.IsTorsionBy.{u1, u2} R M (CommRing.toCommSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (Finset.prod.{u1, u3} R ι (CommRing.toCommMonoid.{u1} R _inst_1) S (fun (i : ι) => q i))) -> (DirectSum.IsInternal.{u3, u2, u2} (coeSort.{succ u3, succ (succ u3)} (Finset.{u3} ι) Type.{u3} (Finset.hasCoeToSort.{u3} ι) S) M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (fun (a : coeSort.{succ u3, succ (succ u3)} (Finset.{u3} ι) Type.{u3} (Finset.hasCoeToSort.{u3} ι) S) (b : coeSort.{succ u3, succ (succ u3)} (Finset.{u3} ι) Type.{u3} (Finset.hasCoeToSort.{u3} ι) S) => Subtype.decidableEq.{u3} ι (fun (x : ι) => Membership.Mem.{u3, u3} ι (Finset.{u3} ι) (Finset.hasMem.{u3} ι) x S) (fun (a : ι) (b : ι) => _inst_4 a b) a b) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.addSubmonoidClass.{u1, u2} R M (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (fun (i : coeSort.{succ u3, succ (succ u3)} (Finset.{u3} ι) Type.{u3} (Finset.hasCoeToSort.{u3} ι) S) => Submodule.torsionBy.{u1, u2} R M (CommRing.toCommSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (q ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Finset.{u3} ι) Type.{u3} (Finset.hasCoeToSort.{u3} ι) S) ι (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Finset.{u3} ι) Type.{u3} (Finset.hasCoeToSort.{u3} ι) S) ι (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Finset.{u3} ι) Type.{u3} (Finset.hasCoeToSort.{u3} ι) S) ι (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Finset.{u3} ι) Type.{u3} (Finset.hasCoeToSort.{u3} ι) S) ι (coeSubtype.{succ u3} ι (fun (x : ι) => Membership.Mem.{u3, u3} ι (Finset.{u3} ι) (Finset.hasMem.{u3} ι) x S))))) i))))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : CommRing.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_3 : Module.{u2, u1} R M (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] {ι : Type.{u3}} [_inst_4 : DecidableEq.{succ u3} ι] {S : Finset.{u3} ι} {q : ι -> R}, (Set.Pairwise.{u3} ι (Finset.toSet.{u3} ι S) (Function.onFun.{succ u3, succ u2, 1} ι R Prop (IsCoprime.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) q)) -> (Module.IsTorsionBy.{u2, u1} R M (CommRing.toCommSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3 (Finset.prod.{u2, u3} R ι (CommRing.toCommMonoid.{u2} R _inst_1) S (fun (i : ι) => q i))) -> (DirectSum.IsInternal.{u3, u1, u1} (Subtype.{succ u3} ι (fun (x : ι) => Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) x S)) M (Submodule.{u2, u1} R M (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (fun (a : Subtype.{succ u3} ι (fun (x : ι) => Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) x S)) (b : Subtype.{succ u3} ι (fun (x : ι) => Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) x S)) => Subtype.instDecidableEqSubtype.{u3} ι (fun (x : ι) => Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) x S) (fun (a : ι) (b : ι) => _inst_4 a b) a b) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) (Submodule.setLike.{u2, u1} R M (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.addSubmonoidClass.{u2, u1} R M (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (fun (i : Subtype.{succ u3} ι (fun (x : ι) => Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) x S)) => Submodule.torsionBy.{u2, u1} R M (CommRing.toCommSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3 (q (Subtype.val.{succ u3} ι (fun (x : ι) => Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) x S) i))))
Case conversion may be inaccurate. Consider using '#align submodule.torsion_by_is_internal Submodule.torsionBy_isInternalₓ'. -/
/-- If the `q i` are pairwise coprime, a `∏ i, q i`-torsion module is the internal direct sum of
its `q i`-torsion submodules.-/
theorem torsionBy_isInternal {q : ι → R} (hq : (S : Set ι).Pairwise <| (IsCoprime on q))
    (hM : Module.IsTorsionBy R M <| ∏ i in S, q i) :
    DirectSum.IsInternal fun i : S => torsionBy R M <| q i :=
  by
  rw [← Module.isTorsionBySet_span_singleton_iff, Ideal.submodule_span_eq, ←
    Ideal.finset_inf_span_singleton _ _ hq, Finset.inf_eq_iInf] at hM
  convert torsion_by_set_is_internal
      (fun i hi j hj ij => (Ideal.sup_eq_top_iff_isCoprime (q i) _).mpr <| hq hi hj ij) hM
  ext : 1; exact (torsion_by_span_singleton_eq _).symm
#align submodule.torsion_by_is_internal Submodule.torsionBy_isInternal

end Submodule

namespace Module

variable {I : Ideal R} (hM : IsTorsionBySet R M I)

include hM

#print Module.IsTorsionBySet.hasSMul /-
/-- can't be an instance because hM can't be inferred -/
def IsTorsionBySet.hasSMul : SMul (R ⧸ I) M
    where smul b x :=
    Quotient.liftOn' b (· • x) fun b₁ b₂ h =>
      by
      show b₁ • x = b₂ • x
      have : (-b₁ + b₂) • x = 0 := @hM x ⟨_, quotient_add_group.left_rel_apply.mp h⟩
      rw [add_smul, neg_smul, neg_add_eq_zero] at this
      exact this
#align module.is_torsion_by_set.has_smul Module.IsTorsionBySet.hasSMul
-/

/- warning: module.is_torsion_by_set.mk_smul -> Module.IsTorsionBySet.mk_smul is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align module.is_torsion_by_set.mk_smul Module.IsTorsionBySet.mk_smulₓ'. -/
@[simp]
theorem IsTorsionBySet.mk_smul (b : R) (x : M) :
    haveI := hM.has_smul
    Ideal.Quotient.mk I b • x = b • x :=
  rfl
#align module.is_torsion_by_set.mk_smul Module.IsTorsionBySet.mk_smul

#print Module.IsTorsionBySet.module /-
/-- A `(R ⧸ I)`-module is a `R`-module which `is_torsion_by_set R M I`. -/
def IsTorsionBySet.module : Module (R ⧸ I) M :=
  @Function.Surjective.moduleLeft _ _ _ _ _ _ _ hM.SMul _ Ideal.Quotient.mk_surjective
    (IsTorsionBySet.mk_smul hM)
#align module.is_torsion_by_set.module Module.IsTorsionBySet.module
-/

/- warning: module.is_torsion_by_set.is_scalar_tower -> Module.IsTorsionBySet.isScalarTower is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align module.is_torsion_by_set.is_scalar_tower Module.IsTorsionBySet.isScalarTowerₓ'. -/
instance IsTorsionBySet.isScalarTower {S : Type _} [SMul S R] [SMul S M] [IsScalarTower S R M]
    [IsScalarTower S R R] : @IsScalarTower S (R ⧸ I) M _ (IsTorsionBySet.module hM).toSMul _
    where smul_assoc b d x := Quotient.inductionOn' d fun c => (smul_assoc b c x : _)
#align module.is_torsion_by_set.is_scalar_tower Module.IsTorsionBySet.isScalarTower

omit hM

instance : Module (R ⧸ I) (M ⧸ I • (⊤ : Submodule R M)) :=
  IsTorsionBySet.module fun x r =>
    by
    induction x using Quotient.inductionOn
    refine' (Submodule.Quotient.mk_eq_zero _).mpr (Submodule.smul_mem_smul r.prop _)
    trivial

end Module

namespace Submodule

instance (I : Ideal R) : Module (R ⧸ I) (torsionBySet R M I) :=
  Module.IsTorsionBySet.module <| torsionBySet_isTorsionBySet I

/- warning: submodule.torsion_by_set.mk_smul -> Submodule.torsionBySet.mk_smul is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align submodule.torsion_by_set.mk_smul Submodule.torsionBySet.mk_smulₓ'. -/
@[simp]
theorem torsionBySet.mk_smul (I : Ideal R) (b : R) (x : torsionBySet R M I) :
    Ideal.Quotient.mk I b • x = b • x :=
  rfl
#align submodule.torsion_by_set.mk_smul Submodule.torsionBySet.mk_smul

instance (I : Ideal R) {S : Type _} [SMul S R] [SMul S M] [IsScalarTower S R M]
    [IsScalarTower S R R] : IsScalarTower S (R ⧸ I) (torsionBySet R M I) :=
  inferInstance

/-- The `a`-torsion submodule as a `(R ⧸ R∙a)`-module. -/
instance (a : R) : Module (R ⧸ R ∙ a) (torsionBy R M a) :=
  Module.IsTorsionBySet.module <|
    (Module.isTorsionBySet_span_singleton_iff a).mpr <| torsionBy_isTorsionBy a

/- warning: submodule.torsion_by.mk_smul -> Submodule.torsionBy.mk_smul is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align submodule.torsion_by.mk_smul Submodule.torsionBy.mk_smulₓ'. -/
@[simp]
theorem torsionBy.mk_smul (a b : R) (x : torsionBy R M a) :
    Ideal.Quotient.mk (R ∙ a) b • x = b • x :=
  rfl
#align submodule.torsion_by.mk_smul Submodule.torsionBy.mk_smul

instance (a : R) {S : Type _} [SMul S R] [SMul S M] [IsScalarTower S R M] [IsScalarTower S R R] :
    IsScalarTower S (R ⧸ R ∙ a) (torsionBy R M a) :=
  inferInstance

end Submodule

end NeedsGroup

namespace Submodule

section Torsion'

open Module

variable [CommSemiring R] [AddCommMonoid M] [Module R M]

variable (S : Type _) [CommMonoid S] [DistribMulAction S M] [SMulCommClass S R M]

/- warning: submodule.mem_torsion'_iff -> Submodule.mem_torsion'_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (S : Type.{u3}) [_inst_4 : CommMonoid.{u3} S] [_inst_5 : DistribMulAction.{u3, u2} S M (CommMonoid.toMonoid.{u3} S _inst_4) (AddCommMonoid.toAddMonoid.{u2} M _inst_2)] [_inst_6 : SMulCommClass.{u3, u1, u2} S R M (SMulZeroClass.toHasSmul.{u3, u2} S M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (DistribSMul.toSmulZeroClass.{u3, u2} S M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u3, u2} S M (CommMonoid.toMonoid.{u3} S _inst_4) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_5))) (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))] (x : M), Iff (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x (Submodule.torsion'.{u1, u2, u3} R M _inst_1 _inst_2 _inst_3 S _inst_4 _inst_5 _inst_6)) (Exists.{succ u3} S (fun (a : S) => Eq.{succ u2} M (SMul.smul.{u3, u2} S M (SMulZeroClass.toHasSmul.{u3, u2} S M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (DistribSMul.toSmulZeroClass.{u3, u2} S M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u3, u2} S M (CommMonoid.toMonoid.{u3} S _inst_4) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_5))) a x) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))))))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2] (S : Type.{u1}) [_inst_4 : CommMonoid.{u1} S] [_inst_5 : DistribMulAction.{u1, u3} S M (CommMonoid.toMonoid.{u1} S _inst_4) (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_6 : SMulCommClass.{u1, u2, u3} S R M (SMulZeroClass.toSMul.{u1, u3} S M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u3} S M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u3} S M (CommMonoid.toMonoid.{u1} S _inst_4) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5))) (SMulZeroClass.toSMul.{u2, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u3} R M (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3))))] (x : M), Iff (Membership.mem.{u3, u3} M (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3)) x (Submodule.torsion'.{u1, u2, u3} R M _inst_1 _inst_2 _inst_3 S _inst_4 _inst_5 _inst_6)) (Exists.{succ u1} S (fun (a : S) => Eq.{succ u3} M (HSMul.hSMul.{u1, u3, u3} S M M (instHSMul.{u1, u3} S M (SMulZeroClass.toSMul.{u1, u3} S M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u3} S M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u3} S M (CommMonoid.toMonoid.{u1} S _inst_4) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5)))) a x) (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))))))
Case conversion may be inaccurate. Consider using '#align submodule.mem_torsion'_iff Submodule.mem_torsion'_iffₓ'. -/
@[simp]
theorem mem_torsion'_iff (x : M) : x ∈ torsion' R M S ↔ ∃ a : S, a • x = 0 :=
  Iff.rfl
#align submodule.mem_torsion'_iff Submodule.mem_torsion'_iff

/- warning: submodule.mem_torsion_iff -> Submodule.mem_torsion_iff is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align submodule.mem_torsion_iff Submodule.mem_torsion_iffₓ'. -/
@[simp]
theorem mem_torsion_iff (x : M) : x ∈ torsion R M ↔ ∃ a : R⁰, a • x = 0 :=
  Iff.rfl
#align submodule.mem_torsion_iff Submodule.mem_torsion_iff

@[simps]
instance : SMul S (torsion' R M S) :=
  ⟨fun s x => ⟨s • x, by obtain ⟨x, a, h⟩ := x; use a; dsimp; rw [smul_comm, h, smul_zero]⟩⟩

instance : DistribMulAction S (torsion' R M S) :=
  Subtype.coe_injective.DistribMulAction (torsion' R M S).Subtype.toAddMonoidHom fun (c : S) x =>
    rfl

instance : SMulCommClass S R (torsion' R M S) :=
  ⟨fun s a x => Subtype.ext <| smul_comm _ _ _⟩

/- warning: submodule.is_torsion'_iff_torsion'_eq_top -> Submodule.isTorsion'_iff_torsion'_eq_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (S : Type.{u3}) [_inst_4 : CommMonoid.{u3} S] [_inst_5 : DistribMulAction.{u3, u2} S M (CommMonoid.toMonoid.{u3} S _inst_4) (AddCommMonoid.toAddMonoid.{u2} M _inst_2)] [_inst_6 : SMulCommClass.{u3, u1, u2} S R M (SMulZeroClass.toHasSmul.{u3, u2} S M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (DistribSMul.toSmulZeroClass.{u3, u2} S M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u3, u2} S M (CommMonoid.toMonoid.{u3} S _inst_4) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_5))) (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))], Iff (Module.IsTorsion'.{u2, u3} M _inst_2 S (SMulZeroClass.toHasSmul.{u3, u2} S M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (DistribSMul.toSmulZeroClass.{u3, u2} S M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u3, u2} S M (CommMonoid.toMonoid.{u3} S _inst_4) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_5)))) (Eq.{succ u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.torsion'.{u1, u2, u3} R M _inst_1 _inst_2 _inst_3 S _inst_4 _inst_5 _inst_6) (Top.top.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasTop.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u3}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (S : Type.{u2}) [_inst_4 : CommMonoid.{u2} S] [_inst_5 : DistribMulAction.{u2, u3} S M (CommMonoid.toMonoid.{u2} S _inst_4) (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_6 : SMulCommClass.{u2, u1, u3} S R M (SMulZeroClass.toSMul.{u2, u3} S M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribSMul.toSMulZeroClass.{u2, u3} S M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u2, u3} S M (CommMonoid.toMonoid.{u2} S _inst_4) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5))) (SMulZeroClass.toSMul.{u1, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u3} R M (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u1, u3} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))], Iff (Module.IsTorsion'.{u3, u2} M _inst_2 S (SMulZeroClass.toSMul.{u2, u3} S M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribSMul.toSMulZeroClass.{u2, u3} S M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u2, u3} S M (CommMonoid.toMonoid.{u2} S _inst_4) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5)))) (Eq.{succ u3} (Submodule.{u1, u3} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.torsion'.{u2, u1, u3} R M _inst_1 _inst_2 _inst_3 S _inst_4 _inst_5 _inst_6) (Top.top.{u3} (Submodule.{u1, u3} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.instTopSubmodule.{u1, u3} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))
Case conversion may be inaccurate. Consider using '#align submodule.is_torsion'_iff_torsion'_eq_top Submodule.isTorsion'_iff_torsion'_eq_topₓ'. -/
/-- A `S`-torsion module is a module whose `S`-torsion submodule is the full space. -/
theorem isTorsion'_iff_torsion'_eq_top : IsTorsion' M S ↔ torsion' R M S = ⊤ :=
  ⟨fun h => eq_top_iff.mpr fun _ _ => @h _, fun h x => by rw [← @mem_torsion'_iff R, h]; trivial⟩
#align submodule.is_torsion'_iff_torsion'_eq_top Submodule.isTorsion'_iff_torsion'_eq_top

/- warning: submodule.torsion'_is_torsion' -> Submodule.torsion'_isTorsion' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (S : Type.{u3}) [_inst_4 : CommMonoid.{u3} S] [_inst_5 : DistribMulAction.{u3, u2} S M (CommMonoid.toMonoid.{u3} S _inst_4) (AddCommMonoid.toAddMonoid.{u2} M _inst_2)] [_inst_6 : SMulCommClass.{u3, u1, u2} S R M (SMulZeroClass.toHasSmul.{u3, u2} S M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (DistribSMul.toSmulZeroClass.{u3, u2} S M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u3, u2} S M (CommMonoid.toMonoid.{u3} S _inst_4) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_5))) (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))], Module.IsTorsion'.{u2, u3} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (Submodule.torsion'.{u1, u2, u3} R M _inst_1 _inst_2 _inst_3 S _inst_4 _inst_5 _inst_6)) (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsion'.{u1, u2, u3} R M _inst_1 _inst_2 _inst_3 S _inst_4 _inst_5 _inst_6)) S (Submodule.torsion'.hasSmul.{u1, u2, u3} R M _inst_1 _inst_2 _inst_3 S _inst_4 _inst_5 _inst_6)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u3}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (S : Type.{u2}) [_inst_4 : CommMonoid.{u2} S] [_inst_5 : DistribMulAction.{u2, u3} S M (CommMonoid.toMonoid.{u2} S _inst_4) (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_6 : SMulCommClass.{u2, u1, u3} S R M (SMulZeroClass.toSMul.{u2, u3} S M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribSMul.toSMulZeroClass.{u2, u3} S M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (DistribMulAction.toDistribSMul.{u2, u3} S M (CommMonoid.toMonoid.{u2} S _inst_4) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_5))) (SMulZeroClass.toSMul.{u1, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u3} R M (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u1, u3} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))], Module.IsTorsion'.{u3, u2} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (Submodule.{u1, u3} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u1, u3} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x (Submodule.torsion'.{u2, u1, u3} R M _inst_1 _inst_2 _inst_3 S _inst_4 _inst_5 _inst_6))) (Submodule.addCommMonoid.{u1, u3} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsion'.{u2, u1, u3} R M _inst_1 _inst_2 _inst_3 S _inst_4 _inst_5 _inst_6)) S (Submodule.instSMulSubtypeMemSubmoduleToSemiringInstMembershipSetLikeTorsion'.{u1, u3, u2} R M _inst_1 _inst_2 _inst_3 S _inst_4 _inst_5 _inst_6)
Case conversion may be inaccurate. Consider using '#align submodule.torsion'_is_torsion' Submodule.torsion'_isTorsion'ₓ'. -/
/-- The `S`-torsion submodule is a `S`-torsion module. -/
theorem torsion'_isTorsion' : IsTorsion' (torsion' R M S) S := fun ⟨x, ⟨a, h⟩⟩ => ⟨a, Subtype.ext h⟩
#align submodule.torsion'_is_torsion' Submodule.torsion'_isTorsion'

/- warning: submodule.torsion'_torsion'_eq_top -> Submodule.torsion'_torsion'_eq_top is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align submodule.torsion'_torsion'_eq_top Submodule.torsion'_torsion'_eq_topₓ'. -/
@[simp]
theorem torsion'_torsion'_eq_top : torsion' R (torsion' R M S) S = ⊤ :=
  (isTorsion'_iff_torsion'_eq_top S).mp <| torsion'_isTorsion' S
#align submodule.torsion'_torsion'_eq_top Submodule.torsion'_torsion'_eq_top

/- warning: submodule.torsion_torsion_eq_top -> Submodule.torsion_torsion_eq_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2], Eq.{succ u2} (Submodule.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (Submodule.torsion.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (CommSemiring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsion.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsion.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (Submodule.torsion.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (Submodule.torsion.{u1, u2} R M _inst_1 _inst_2 _inst_3)) _inst_1 (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsion.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsion.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (Top.top.{u2} (Submodule.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (Submodule.torsion.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (CommSemiring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsion.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsion.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (Submodule.hasTop.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (Submodule.torsion.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (CommSemiring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsion.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsion.{u1, u2} R M _inst_1 _inst_2 _inst_3))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2], Eq.{succ u2} (Submodule.{u1, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x (Submodule.torsion.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (CommSemiring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsion.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsion.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (Submodule.torsion.{u1, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x (Submodule.torsion.{u1, u2} R M _inst_1 _inst_2 _inst_3))) _inst_1 (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsion.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsion.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (Top.top.{u2} (Submodule.{u1, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x (Submodule.torsion.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (CommSemiring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsion.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsion.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (Submodule.instTopSubmodule.{u1, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x (Submodule.torsion.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (CommSemiring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsion.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsion.{u1, u2} R M _inst_1 _inst_2 _inst_3))))
Case conversion may be inaccurate. Consider using '#align submodule.torsion_torsion_eq_top Submodule.torsion_torsion_eq_topₓ'. -/
/-- The torsion submodule of the torsion submodule (viewed as a module) is the full
torsion module. -/
@[simp]
theorem torsion_torsion_eq_top : torsion R (torsion R M) = ⊤ :=
  torsion'_torsion'_eq_top R⁰
#align submodule.torsion_torsion_eq_top Submodule.torsion_torsion_eq_top

/- warning: submodule.torsion_is_torsion -> Submodule.torsion_isTorsion is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2], Module.IsTorsion.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (Submodule.torsion.{u1, u2} R M _inst_1 _inst_2 _inst_3)) _inst_1 (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsion.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Submodule.torsion.{u1, u2} R M _inst_1 _inst_2 _inst_3))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2], Module.IsTorsion.{u2, u1} R (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3)) x (Submodule.torsion.{u2, u1} R M _inst_1 _inst_2 _inst_3))) _inst_1 (Submodule.addCommMonoid.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3 (Submodule.torsion.{u2, u1} R M _inst_1 _inst_2 _inst_3)) (Submodule.module.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3 (Submodule.torsion.{u2, u1} R M _inst_1 _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align submodule.torsion_is_torsion Submodule.torsion_isTorsionₓ'. -/
/-- The torsion submodule is always a torsion module. -/
theorem torsion_isTorsion : Module.IsTorsion R (torsion R M) :=
  torsion'_isTorsion' R⁰
#align submodule.torsion_is_torsion Submodule.torsion_isTorsion

end Torsion'

section Torsion

variable [CommSemiring R] [AddCommMonoid M] [Module R M]

open BigOperators

variable (R M)

/- warning: module.is_torsion_by_set_annihilator_top -> Module.isTorsionBySet_annihilator_top is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2], Module.IsTorsionBySet.{u1, u2} R M _inst_1 _inst_2 _inst_3 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (Submodule.annihilator.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Top.top.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasTop.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))
but is expected to have type
  forall (R : Type.{u2}) (M : Type.{u1}) [_inst_1 : CommSemiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2], Module.IsTorsionBySet.{u2, u1} R M _inst_1 _inst_2 _inst_3 (SetLike.coe.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (Submodule.annihilator.{u2, u1} R M _inst_1 _inst_2 _inst_3 (Top.top.{u1} (Submodule.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (Submodule.instTopSubmodule.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3))))
Case conversion may be inaccurate. Consider using '#align module.is_torsion_by_set_annihilator_top Module.isTorsionBySet_annihilator_topₓ'. -/
theorem Module.isTorsionBySet_annihilator_top :
    Module.IsTorsionBySet R M (⊤ : Submodule R M).annihilator := fun x ha =>
  mem_annihilator.mp ha.Prop x mem_top
#align module.is_torsion_by_set_annihilator_top Module.isTorsionBySet_annihilator_top

variable {R M}

/- warning: submodule.annihilator_top_inter_non_zero_divisors -> Submodule.annihilator_top_inter_nonZeroDivisors is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] [_inst_4 : Module.Finite.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3], (Module.IsTorsion.{u1, u2} R M _inst_1 _inst_2 _inst_3) -> (Ne.{succ u1} (Set.{u1} R) (Inter.inter.{u1} (Set.{u1} R) (Set.hasInter.{u1} R) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (Submodule.annihilator.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Top.top.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasTop.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (EmptyCollection.emptyCollection.{u1} (Set.{u1} R) (Set.hasEmptyc.{u1} R)))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2] [_inst_4 : Module.Finite.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3], (Module.IsTorsion.{u2, u1} R M _inst_1 _inst_2 _inst_3) -> (Ne.{succ u2} (Set.{u2} R) (Inter.inter.{u2} (Set.{u2} R) (Set.instInterSet.{u2} R) (SetLike.coe.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (Submodule.annihilator.{u2, u1} R M _inst_1 _inst_2 _inst_3 (Top.top.{u1} (Submodule.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (Submodule.instTopSubmodule.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3)))) (SetLike.coe.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) (nonZeroDivisors.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) (EmptyCollection.emptyCollection.{u2} (Set.{u2} R) (Set.instEmptyCollectionSet.{u2} R)))
Case conversion may be inaccurate. Consider using '#align submodule.annihilator_top_inter_non_zero_divisors Submodule.annihilator_top_inter_nonZeroDivisorsₓ'. -/
theorem Submodule.annihilator_top_inter_nonZeroDivisors [Module.Finite R M]
    (hM : Module.IsTorsion R M) : ((⊤ : Submodule R M).annihilator : Set R) ∩ R⁰ ≠ ∅ :=
  by
  obtain ⟨S, hS⟩ := ‹Module.Finite R M›.out
  refine' Set.Nonempty.ne_empty ⟨_, _, (∏ x in S, (@hM x).some : R⁰).Prop⟩
  rw [Submonoid.coe_finset_prod, SetLike.mem_coe, ← hS, mem_annihilator_span]
  intro n
  letI := Classical.decEq M
  rw [← Finset.prod_erase_mul _ _ n.prop, mul_smul, ← Submonoid.smul_def, (@hM n).choose_spec,
    smul_zero]
#align submodule.annihilator_top_inter_non_zero_divisors Submodule.annihilator_top_inter_nonZeroDivisors

variable [NoZeroDivisors R] [Nontrivial R]

/- warning: submodule.coe_torsion_eq_annihilator_ne_bot -> Submodule.coe_torsion_eq_annihilator_ne_bot is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] [_inst_4 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))] [_inst_5 : Nontrivial.{u1} R], Eq.{succ u2} (Set.{u2} M) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))) (Submodule.torsion.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (setOf.{u2} M (fun (x : M) => Ne.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.annihilator.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Submodule.span.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) x))) (Bot.bot.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasBot.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] [_inst_4 : NoZeroDivisors.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1))] [_inst_5 : Nontrivial.{u1} R], Eq.{succ u2} (Set.{u2} M) (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.torsion.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (setOf.{u2} M (fun (x : M) => Ne.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.annihilator.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Submodule.span.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.instSingletonSet.{u2} M) x))) (Bot.bot.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instBotSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))
Case conversion may be inaccurate. Consider using '#align submodule.coe_torsion_eq_annihilator_ne_bot Submodule.coe_torsion_eq_annihilator_ne_botₓ'. -/
theorem coe_torsion_eq_annihilator_ne_bot :
    (torsion R M : Set M) = { x : M | (R ∙ x).annihilator ≠ ⊥ } :=
  by
  ext x; simp_rw [Submodule.ne_bot_iff, mem_annihilator, mem_span_singleton]
  exact
    ⟨fun ⟨a, hax⟩ =>
      ⟨a, fun _ ⟨b, hb⟩ => by rw [← hb, smul_comm, ← Submonoid.smul_def, hax, smul_zero],
        nonZeroDivisors.coe_ne_zero _⟩,
      fun ⟨a, hax, ha⟩ => ⟨⟨_, mem_nonZeroDivisors_of_ne_zero ha⟩, hax x ⟨1, one_smul _ _⟩⟩⟩
#align submodule.coe_torsion_eq_annihilator_ne_bot Submodule.coe_torsion_eq_annihilator_ne_bot

/- warning: submodule.no_zero_smul_divisors_iff_torsion_eq_bot -> Submodule.noZeroSMulDivisors_iff_torsion_eq_bot is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] [_inst_4 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))] [_inst_5 : Nontrivial.{u1} R], Iff (NoZeroSMulDivisors.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))) (Eq.{succ u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.torsion.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Bot.bot.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasBot.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2] [_inst_4 : NoZeroDivisors.{u2} R (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R _inst_1))] [_inst_5 : Nontrivial.{u2} R], Iff (NoZeroSMulDivisors.{u2, u1} R M (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3))))) (Eq.{succ u1} (Submodule.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (Submodule.torsion.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Bot.bot.{u1} (Submodule.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (Submodule.instBotSubmodule.{u2, u1} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3)))
Case conversion may be inaccurate. Consider using '#align submodule.no_zero_smul_divisors_iff_torsion_eq_bot Submodule.noZeroSMulDivisors_iff_torsion_eq_botₓ'. -/
/-- A module over a domain has `no_zero_smul_divisors` iff its torsion submodule is trivial. -/
theorem noZeroSMulDivisors_iff_torsion_eq_bot : NoZeroSMulDivisors R M ↔ torsion R M = ⊥ :=
  by
  constructor <;> intro h
  · haveI : NoZeroSMulDivisors R M := h
    rw [eq_bot_iff]; rintro x ⟨a, hax⟩
    change (a : R) • x = 0 at hax
    cases' eq_zero_or_eq_zero_of_smul_eq_zero hax with h0 h0
    · exfalso; exact nonZeroDivisors.coe_ne_zero a h0; · exact h0
  ·
    exact
      {
        eq_zero_or_eq_zero_of_smul_eq_zero := fun a x hax =>
          by
          by_cases ha : a = 0
          · left; exact ha
          · right; rw [← mem_bot _, ← h]
            exact ⟨⟨a, mem_nonZeroDivisors_of_ne_zero ha⟩, hax⟩ }
#align submodule.no_zero_smul_divisors_iff_torsion_eq_bot Submodule.noZeroSMulDivisors_iff_torsion_eq_bot

end Torsion

namespace QuotientTorsion

variable [CommRing R] [AddCommGroup M] [Module R M]

/- warning: submodule.quotient_torsion.torsion_eq_bot -> Submodule.QuotientTorsion.torsion_eq_bot is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align submodule.quotient_torsion.torsion_eq_bot Submodule.QuotientTorsion.torsion_eq_botₓ'. -/
/-- Quotienting by the torsion submodule gives a torsion-free module. -/
@[simp]
theorem torsion_eq_bot : torsion R (M ⧸ torsion R M) = ⊥ :=
  eq_bot_iff.mpr fun z =>
    Quotient.inductionOn' z fun x ⟨a, hax⟩ =>
      by
      rw [Quotient.mk''_eq_mk', ← quotient.mk_smul, quotient.mk_eq_zero] at hax
      rw [mem_bot, Quotient.mk''_eq_mk', quotient.mk_eq_zero]
      cases' hax with b h
      exact ⟨b * a, (mul_smul _ _ _).trans h⟩
#align submodule.quotient_torsion.torsion_eq_bot Submodule.QuotientTorsion.torsion_eq_bot

/- warning: submodule.quotient_torsion.no_zero_smul_divisors -> Submodule.QuotientTorsion.noZeroSMulDivisors is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align submodule.quotient_torsion.no_zero_smul_divisors Submodule.QuotientTorsion.noZeroSMulDivisorsₓ'. -/
instance noZeroSMulDivisors [IsDomain R] : NoZeroSMulDivisors R (M ⧸ torsion R M) :=
  noZeroSMulDivisors_iff_torsion_eq_bot.mpr torsion_eq_bot
#align submodule.quotient_torsion.no_zero_smul_divisors Submodule.QuotientTorsion.noZeroSMulDivisors

end QuotientTorsion

section PTorsion

open Module

section

variable [Monoid R] [AddCommMonoid M] [DistribMulAction R M]

/- warning: submodule.is_torsion'_powers_iff -> Submodule.isTorsion'_powers_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : DistribMulAction.{u1, u2} R M _inst_1 (AddCommMonoid.toAddMonoid.{u2} M _inst_2)] (p : R), Iff (Module.IsTorsion'.{u2, u1} M _inst_2 (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (Submonoid.powers.{u1} R _inst_1 p)) (Submonoid.hasSmul.{u1, u2} R M (Monoid.toMulOneClass.{u1} R _inst_1) (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (DistribSMul.toSmulZeroClass.{u1, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u2} R M _inst_1 (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_3))) (Submonoid.powers.{u1} R _inst_1 p))) (forall (x : M), Exists.{1} Nat (fun (n : Nat) => Eq.{succ u2} M (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (DistribSMul.toSmulZeroClass.{u1, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u2} R M _inst_1 (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_3))) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R _inst_1)) p n) x) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : DistribMulAction.{u1, u2} R M _inst_1 (AddCommMonoid.toAddMonoid.{u2} M _inst_2)] (p : R), Iff (Module.IsTorsion'.{u2, u1} M _inst_2 (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (Submonoid.powers.{u1} R _inst_1 p))) (Submonoid.smul.{u1, u2} R M (Monoid.toMulOneClass.{u1} R _inst_1) (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u2} R M _inst_1 (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_3))) (Submonoid.powers.{u1} R _inst_1 p))) (forall (x : M), Exists.{1} Nat (fun (n : Nat) => Eq.{succ u2} M (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u2} R M _inst_1 (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_3)))) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R _inst_1)) p n) x) (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))))
Case conversion may be inaccurate. Consider using '#align submodule.is_torsion'_powers_iff Submodule.isTorsion'_powers_iffₓ'. -/
theorem isTorsion'_powers_iff (p : R) :
    IsTorsion' M (Submonoid.powers p) ↔ ∀ x : M, ∃ n : ℕ, p ^ n • x = 0 :=
  ⟨fun h x =>
    let ⟨⟨a, ⟨n, rfl⟩⟩, hx⟩ := @h x
    ⟨n, hx⟩,
    fun h x =>
    let ⟨n, hn⟩ := h x
    ⟨⟨_, ⟨n, rfl⟩⟩, hn⟩⟩
#align submodule.is_torsion'_powers_iff Submodule.isTorsion'_powers_iff

/- warning: submodule.p_order -> Submodule.pOrder is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : DistribMulAction.{u1, u2} R M _inst_1 (AddCommMonoid.toAddMonoid.{u2} M _inst_2)] {p : R}, (Module.IsTorsion'.{u2, u1} M _inst_2 (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (Submonoid.powers.{u1} R _inst_1 p)) (Submonoid.hasSmul.{u1, u2} R M (Monoid.toMulOneClass.{u1} R _inst_1) (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (DistribSMul.toSmulZeroClass.{u1, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u2} R M _inst_1 (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_3))) (Submonoid.powers.{u1} R _inst_1 p))) -> (forall (x : M) [_inst_4 : forall (n : Nat), Decidable (Eq.{succ u2} M (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (DistribSMul.toSmulZeroClass.{u1, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u2} R M _inst_1 (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_3))) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R _inst_1)) p n) x) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))))], Nat)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : DistribMulAction.{u1, u2} R M _inst_1 (AddCommMonoid.toAddMonoid.{u2} M _inst_2)] {p : R}, (Module.IsTorsion'.{u2, u1} M _inst_2 (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (Submonoid.powers.{u1} R _inst_1 p))) (Submonoid.smul.{u1, u2} R M (Monoid.toMulOneClass.{u1} R _inst_1) (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u2} R M _inst_1 (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_3))) (Submonoid.powers.{u1} R _inst_1 p))) -> (forall (x : M) [_inst_4 : forall (n : Nat), Decidable (Eq.{succ u2} M (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u2} R M _inst_1 (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_3)))) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R _inst_1)) p n) x) (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))], Nat)
Case conversion may be inaccurate. Consider using '#align submodule.p_order Submodule.pOrderₓ'. -/
/-- In a `p ^ ∞`-torsion module (that is, a module where all elements are cancelled by scalar
multiplication by some power of `p`), the smallest `n` such that `p ^ n • x = 0`.-/
def pOrder {p : R} (hM : IsTorsion' M <| Submonoid.powers p) (x : M)
    [∀ n : ℕ, Decidable (p ^ n • x = 0)] :=
  Nat.find <| (isTorsion'_powers_iff p).mp hM x
#align submodule.p_order Submodule.pOrder

/- warning: submodule.pow_p_order_smul -> Submodule.pow_pOrder_smul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : DistribMulAction.{u1, u2} R M _inst_1 (AddCommMonoid.toAddMonoid.{u2} M _inst_2)] {p : R} (hM : Module.IsTorsion'.{u2, u1} M _inst_2 (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (Submonoid.powers.{u1} R _inst_1 p)) (Submonoid.hasSmul.{u1, u2} R M (Monoid.toMulOneClass.{u1} R _inst_1) (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (DistribSMul.toSmulZeroClass.{u1, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u2} R M _inst_1 (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_3))) (Submonoid.powers.{u1} R _inst_1 p))) (x : M) [_inst_4 : forall (n : Nat), Decidable (Eq.{succ u2} M (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (DistribSMul.toSmulZeroClass.{u1, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u2} R M _inst_1 (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_3))) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R _inst_1)) p n) x) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))))], Eq.{succ u2} M (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (DistribSMul.toSmulZeroClass.{u1, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u2} R M _inst_1 (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_3))) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R _inst_1)) p (Submodule.pOrder.{u1, u2} R M _inst_1 _inst_2 _inst_3 p hM x (fun (n : Nat) => _inst_4 n))) x) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : DistribMulAction.{u1, u2} R M _inst_1 (AddCommMonoid.toAddMonoid.{u2} M _inst_2)] {p : R} (hM : Module.IsTorsion'.{u2, u1} M _inst_2 (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (Submonoid.powers.{u1} R _inst_1 p))) (Submonoid.smul.{u1, u2} R M (Monoid.toMulOneClass.{u1} R _inst_1) (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u2} R M _inst_1 (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_3))) (Submonoid.powers.{u1} R _inst_1 p))) (x : M) [_inst_4 : forall (n : Nat), Decidable (Eq.{succ u2} M (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u2} R M _inst_1 (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_3)))) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R _inst_1)) p n) x) (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))], Eq.{succ u2} M (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u2} R M _inst_1 (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_3)))) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R _inst_1)) p (Submodule.pOrder.{u1, u2} R M _inst_1 _inst_2 _inst_3 p hM x (fun (n : Nat) => _inst_4 n))) x) (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))
Case conversion may be inaccurate. Consider using '#align submodule.pow_p_order_smul Submodule.pow_pOrder_smulₓ'. -/
@[simp]
theorem pow_pOrder_smul {p : R} (hM : IsTorsion' M <| Submonoid.powers p) (x : M)
    [∀ n : ℕ, Decidable (p ^ n • x = 0)] : p ^ pOrder hM x • x = 0 :=
  Nat.find_spec <| (isTorsion'_powers_iff p).mp hM x
#align submodule.pow_p_order_smul Submodule.pow_pOrder_smul

end

variable [CommSemiring R] [AddCommMonoid M] [Module R M] [∀ x : M, Decidable (x = 0)]

/- warning: submodule.exists_is_torsion_by -> Submodule.exists_isTorsionBy is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align submodule.exists_is_torsion_by Submodule.exists_isTorsionByₓ'. -/
theorem exists_isTorsionBy {p : R} (hM : IsTorsion' M <| Submonoid.powers p) (d : ℕ) (hd : d ≠ 0)
    (s : Fin d → M) (hs : span R (Set.range s) = ⊤) :
    ∃ j : Fin d, Module.IsTorsionBy R M (p ^ pOrder hM (s j)) :=
  by
  let oj := List.argmax (fun i => p_order hM <| s i) (List.finRange d)
  have hoj : oj.is_some :=
    option.ne_none_iff_is_some.mp fun eq_none =>
      hd <| list.fin_range_eq_nil.mp <| list.argmax_eq_none.mp eq_none
  use Option.get hoj
  rw [is_torsion_by_iff_torsion_by_eq_top, eq_top_iff, ← hs, Submodule.span_le,
    Set.range_subset_iff]
  intro i; change _ • _ = _
  have : p_order hM (s i) ≤ p_order hM (s <| Option.get hoj) :=
    List.le_of_mem_argmax (List.mem_finRange i) (Option.get_mem hoj)
  rw [← Nat.sub_add_cancel this, pow_add, mul_smul, pow_p_order_smul, smul_zero]
#align submodule.exists_is_torsion_by Submodule.exists_isTorsionBy

end PTorsion

end Submodule

namespace Ideal.Quotient

open Submodule

/- warning: ideal.quotient.torsion_by_eq_span_singleton -> Ideal.Quotient.torsionBy_eq_span_singleton is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align ideal.quotient.torsion_by_eq_span_singleton Ideal.Quotient.torsionBy_eq_span_singletonₓ'. -/
theorem torsionBy_eq_span_singleton {R : Type _} [CommRing R] (a b : R) (ha : a ∈ R⁰) :
    torsionBy R (R ⧸ R ∙ a * b) a = R ∙ mk _ b :=
  by
  ext x; rw [mem_torsion_by_iff, mem_span_singleton]
  obtain ⟨x, rfl⟩ := mk_surjective x; constructor <;> intro h
  · rw [← mk_eq_mk, ← quotient.mk_smul, quotient.mk_eq_zero, mem_span_singleton] at h
    obtain ⟨c, h⟩ := h;
    rw [smul_eq_mul, smul_eq_mul, mul_comm, mul_assoc, mul_cancel_left_mem_nonZeroDivisors ha,
      mul_comm] at h
    use c; rw [← h, ← mk_eq_mk, ← quotient.mk_smul, smul_eq_mul, mk_eq_mk]
  · obtain ⟨c, h⟩ := h
    rw [← h, smul_comm, ← mk_eq_mk, ← quotient.mk_smul,
      (quotient.mk_eq_zero _).mpr <| mem_span_singleton_self _, smul_zero]
#align ideal.quotient.torsion_by_eq_span_singleton Ideal.Quotient.torsionBy_eq_span_singleton

end Ideal.Quotient

namespace AddMonoid

#print AddMonoid.isTorsion_iff_isTorsion_nat /-
theorem isTorsion_iff_isTorsion_nat [AddCommMonoid M] :
    AddMonoid.IsTorsion M ↔ Module.IsTorsion ℕ M :=
  by
  refine' ⟨fun h x => _, fun h x => _⟩
  · obtain ⟨n, h0, hn⟩ := (isOfFinAddOrder_iff_nsmul_eq_zero x).mp (h x)
    exact ⟨⟨n, mem_nonZeroDivisors_of_ne_zero <| ne_of_gt h0⟩, hn⟩
  · rw [isOfFinAddOrder_iff_nsmul_eq_zero]
    obtain ⟨n, hn⟩ := @h x
    refine' ⟨n, Nat.pos_of_ne_zero (nonZeroDivisors.coe_ne_zero _), hn⟩
#align add_monoid.is_torsion_iff_is_torsion_nat AddMonoid.isTorsion_iff_isTorsion_nat
-/

/- warning: add_monoid.is_torsion_iff_is_torsion_int -> AddMonoid.isTorsion_iff_isTorsion_int is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : AddCommGroup.{u1} M], Iff (AddMonoid.IsTorsion.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))) (Module.IsTorsion.{0, u1} Int M Int.commSemiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : AddCommGroup.{u1} M], Iff (AddMonoid.IsTorsion.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_1)))) (Module.IsTorsion.{0, u1} Int M Int.instCommSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (AddCommGroup.intModule.{u1} M _inst_1))
Case conversion may be inaccurate. Consider using '#align add_monoid.is_torsion_iff_is_torsion_int AddMonoid.isTorsion_iff_isTorsion_intₓ'. -/
theorem isTorsion_iff_isTorsion_int [AddCommGroup M] :
    AddMonoid.IsTorsion M ↔ Module.IsTorsion ℤ M :=
  by
  refine' ⟨fun h x => _, fun h x => _⟩
  · obtain ⟨n, h0, hn⟩ := (isOfFinAddOrder_iff_nsmul_eq_zero x).mp (h x)
    exact
      ⟨⟨n, mem_nonZeroDivisors_of_ne_zero <| ne_of_gt <| int.coe_nat_pos.mpr h0⟩,
        (coe_nat_zsmul _ _).trans hn⟩
  · rw [isOfFinAddOrder_iff_nsmul_eq_zero]
    obtain ⟨n, hn⟩ := @h x
    exact exists_nsmul_eq_zero_of_zsmul_eq_zero (nonZeroDivisors.coe_ne_zero n) hn
#align add_monoid.is_torsion_iff_is_torsion_int AddMonoid.isTorsion_iff_isTorsion_int

end AddMonoid

