/-
Copyright (c) 2020 Eric Wieser. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Eric Wieser

! This file was ported from Lean 3 source module algebra.module.opposites
! leanprover-community/mathlib commit dde670c9a3f503647fd5bfdf1037bad526d3397a
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Module.Equiv
import Mathbin.GroupTheory.GroupAction.Opposite

/-!
# Module operations on `Mᵐᵒᵖ`

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file contains definitions that build on top of the group action definitions in
`group_theory.group_action.opposite`.
-/


namespace MulOpposite

universe u v

variable (R : Type u) {M : Type v} [Semiring R] [AddCommMonoid M] [Module R M]

/-- `mul_opposite.distrib_mul_action` extends to a `module` -/
instance : Module R (MulOpposite M) :=
  {
    MulOpposite.distribMulAction M
      R with
    add_smul := fun r₁ r₂ x => unop_injective <| add_smul r₁ r₂ (unop x)
    zero_smul := fun x => unop_injective <| zero_smul _ (unop x) }

/- warning: mul_opposite.op_linear_equiv -> MulOpposite.opLinearEquiv is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M (MulOpposite.{u2} M) _inst_2 (MulOpposite.addCommMonoid.{u2} M _inst_2) _inst_3 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3)
but is expected to have type
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M (MulOpposite.{u2} M) _inst_2 (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2) _inst_3 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3)
Case conversion may be inaccurate. Consider using '#align mul_opposite.op_linear_equiv MulOpposite.opLinearEquivₓ'. -/
/-- The function `op` is a linear equivalence. -/
def opLinearEquiv : M ≃ₗ[R] Mᵐᵒᵖ :=
  { opAddEquiv with map_smul' := MulOpposite.op_smul }
#align mul_opposite.op_linear_equiv MulOpposite.opLinearEquiv

/- warning: mul_opposite.coe_op_linear_equiv -> MulOpposite.coe_opLinearEquiv is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], Eq.{succ u2} ((fun (_x : LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M (MulOpposite.{u2} M) _inst_2 (MulOpposite.addCommMonoid.{u2} M _inst_2) _inst_3 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3)) => M -> (MulOpposite.{u2} M)) (MulOpposite.opLinearEquiv.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (coeFn.{succ u2, succ u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M (MulOpposite.{u2} M) _inst_2 (MulOpposite.addCommMonoid.{u2} M _inst_2) _inst_3 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (fun (_x : LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M (MulOpposite.{u2} M) _inst_2 (MulOpposite.addCommMonoid.{u2} M _inst_2) _inst_3 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3)) => M -> (MulOpposite.{u2} M)) (LinearEquiv.hasCoeToFun.{u1, u1, u2, u2} R R M (MulOpposite.{u2} M) _inst_1 _inst_1 _inst_2 (MulOpposite.addCommMonoid.{u2} M _inst_2) _inst_3 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)) (MulOpposite.opLinearEquiv.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (MulOpposite.op.{u2} M)
but is expected to have type
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], Eq.{succ u2} (forall (a : M), (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M) => MulOpposite.{u2} M) a) (FunLike.coe.{succ u2, succ u2, succ u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M (MulOpposite.{u2} M) _inst_2 (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2) _inst_3 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3)) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M) => MulOpposite.{u2} M) _x) (SMulHomClass.toFunLike.{u2, u1, u2, u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M (MulOpposite.{u2} M) _inst_2 (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2) _inst_3 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3)) R M (MulOpposite.{u2} M) (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u2} R M (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (SMulZeroClass.toSMul.{u1, u2} R (MulOpposite.{u2} M) (AddMonoid.toZero.{u2} (MulOpposite.{u2} M) (AddCommMonoid.toAddMonoid.{u2} (MulOpposite.{u2} M) (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2))) (DistribSMul.toSMulZeroClass.{u1, u2} R (MulOpposite.{u2} M) (AddMonoid.toAddZeroClass.{u2} (MulOpposite.{u2} M) (AddCommMonoid.toAddMonoid.{u2} (MulOpposite.{u2} M) (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2))) (DistribMulAction.toDistribSMul.{u1, u2} R (MulOpposite.{u2} M) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} (MulOpposite.{u2} M) (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2)) (Module.toDistribMulAction.{u1, u2} R (MulOpposite.{u2} M) _inst_1 (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2) (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) (DistribMulActionHomClass.toSMulHomClass.{u2, u1, u2, u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M (MulOpposite.{u2} M) _inst_2 (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2) _inst_3 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3)) R M (MulOpposite.{u2} M) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (AddCommMonoid.toAddMonoid.{u2} (MulOpposite.{u2} M) (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2)) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Module.toDistribMulAction.{u1, u2} R (MulOpposite.{u2} M) _inst_1 (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2) (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (SemilinearMapClass.distribMulActionHomClass.{u1, u2, u2, u2} R M (MulOpposite.{u2} M) (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M (MulOpposite.{u2} M) _inst_2 (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2) _inst_3 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3)) _inst_1 _inst_2 (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2) _inst_3 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SemilinearEquivClass.instSemilinearMapClass.{u1, u1, u2, u2, u2} R R M (MulOpposite.{u2} M) (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M (MulOpposite.{u2} M) _inst_2 (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2) _inst_3 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3)) _inst_1 _inst_1 _inst_2 (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2) _inst_3 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u1, u2, u2} R R M (MulOpposite.{u2} M) _inst_1 _inst_1 _inst_2 (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2) _inst_3 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)))))) (MulOpposite.opLinearEquiv.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (MulOpposite.op.{u2} M)
Case conversion may be inaccurate. Consider using '#align mul_opposite.coe_op_linear_equiv MulOpposite.coe_opLinearEquivₓ'. -/
@[simp]
theorem coe_opLinearEquiv : (opLinearEquiv R : M → Mᵐᵒᵖ) = op :=
  rfl
#align mul_opposite.coe_op_linear_equiv MulOpposite.coe_opLinearEquiv

/- warning: mul_opposite.coe_op_linear_equiv_symm -> MulOpposite.coe_opLinearEquiv_symm is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], Eq.{succ u2} ((fun (_x : LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (MulOpposite.{u2} M) M (MulOpposite.addCommMonoid.{u2} M _inst_2) _inst_2 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) _inst_3) => (MulOpposite.{u2} M) -> M) (LinearEquiv.symm.{u1, u1, u2, u2} R R M (MulOpposite.{u2} M) _inst_1 _inst_1 _inst_2 (MulOpposite.addCommMonoid.{u2} M _inst_2) _inst_3 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (MulOpposite.opLinearEquiv.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (coeFn.{succ u2, succ u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (MulOpposite.{u2} M) M (MulOpposite.addCommMonoid.{u2} M _inst_2) _inst_2 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) _inst_3) (fun (_x : LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (MulOpposite.{u2} M) M (MulOpposite.addCommMonoid.{u2} M _inst_2) _inst_2 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) _inst_3) => (MulOpposite.{u2} M) -> M) (LinearEquiv.hasCoeToFun.{u1, u1, u2, u2} R R (MulOpposite.{u2} M) M _inst_1 _inst_1 (MulOpposite.addCommMonoid.{u2} M _inst_2) _inst_2 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)) (LinearEquiv.symm.{u1, u1, u2, u2} R R M (MulOpposite.{u2} M) _inst_1 _inst_1 _inst_2 (MulOpposite.addCommMonoid.{u2} M _inst_2) _inst_3 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (MulOpposite.opLinearEquiv.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (MulOpposite.unop.{u2} M)
but is expected to have type
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], Eq.{succ u2} (forall (a : MulOpposite.{u2} M), (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : MulOpposite.{u2} M) => M) a) (FunLike.coe.{succ u2, succ u2, succ u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (MulOpposite.{u2} M) M (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2) _inst_2 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) _inst_3) (MulOpposite.{u2} M) (fun (_x : MulOpposite.{u2} M) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : MulOpposite.{u2} M) => M) _x) (SMulHomClass.toFunLike.{u2, u1, u2, u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (MulOpposite.{u2} M) M (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2) _inst_2 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) _inst_3) R (MulOpposite.{u2} M) M (SMulZeroClass.toSMul.{u1, u2} R (MulOpposite.{u2} M) (AddMonoid.toZero.{u2} (MulOpposite.{u2} M) (AddCommMonoid.toAddMonoid.{u2} (MulOpposite.{u2} M) (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2))) (DistribSMul.toSMulZeroClass.{u1, u2} R (MulOpposite.{u2} M) (AddMonoid.toAddZeroClass.{u2} (MulOpposite.{u2} M) (AddCommMonoid.toAddMonoid.{u2} (MulOpposite.{u2} M) (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2))) (DistribMulAction.toDistribSMul.{u1, u2} R (MulOpposite.{u2} M) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} (MulOpposite.{u2} M) (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2)) (Module.toDistribMulAction.{u1, u2} R (MulOpposite.{u2} M) _inst_1 (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2) (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u2} R M (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (DistribMulActionHomClass.toSMulHomClass.{u2, u1, u2, u2} (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (MulOpposite.{u2} M) M (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2) _inst_2 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) _inst_3) R (MulOpposite.{u2} M) M (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} (MulOpposite.{u2} M) (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u2} R (MulOpposite.{u2} M) _inst_1 (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2) (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SemilinearMapClass.distribMulActionHomClass.{u1, u2, u2, u2} R (MulOpposite.{u2} M) M (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (MulOpposite.{u2} M) M (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2) _inst_2 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) _inst_3) _inst_1 (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2) _inst_2 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) _inst_3 (SemilinearEquivClass.instSemilinearMapClass.{u1, u1, u2, u2, u2} R R (MulOpposite.{u2} M) M (LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (MulOpposite.{u2} M) M (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2) _inst_2 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) _inst_3) _inst_1 _inst_1 (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2) _inst_2 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u1, u2, u2} R R (MulOpposite.{u2} M) M _inst_1 _inst_1 (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2) _inst_2 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)))))) (LinearEquiv.symm.{u1, u1, u2, u2} R R M (MulOpposite.{u2} M) _inst_1 _inst_1 _inst_2 (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2) _inst_3 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (MulOpposite.opLinearEquiv.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (MulOpposite.unop.{u2} M)
Case conversion may be inaccurate. Consider using '#align mul_opposite.coe_op_linear_equiv_symm MulOpposite.coe_opLinearEquiv_symmₓ'. -/
@[simp]
theorem coe_opLinearEquiv_symm : ((opLinearEquiv R).symm : Mᵐᵒᵖ → M) = unop :=
  rfl
#align mul_opposite.coe_op_linear_equiv_symm MulOpposite.coe_opLinearEquiv_symm

/- warning: mul_opposite.coe_op_linear_equiv_to_linear_map -> MulOpposite.coe_opLinearEquiv_toLinearMap is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], Eq.{succ u2} ((fun (_x : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (MulOpposite.{u2} M) _inst_2 (MulOpposite.addCommMonoid.{u2} M _inst_2) _inst_3 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3)) => M -> (MulOpposite.{u2} M)) (LinearEquiv.toLinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M (MulOpposite.{u2} M) _inst_2 (MulOpposite.addCommMonoid.{u2} M _inst_2) _inst_3 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) (MulOpposite.opLinearEquiv.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (coeFn.{succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (MulOpposite.{u2} M) _inst_2 (MulOpposite.addCommMonoid.{u2} M _inst_2) _inst_3 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (fun (_x : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (MulOpposite.{u2} M) _inst_2 (MulOpposite.addCommMonoid.{u2} M _inst_2) _inst_3 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3)) => M -> (MulOpposite.{u2} M)) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R M (MulOpposite.{u2} M) _inst_1 _inst_1 _inst_2 (MulOpposite.addCommMonoid.{u2} M _inst_2) _inst_3 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearEquiv.toLinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M (MulOpposite.{u2} M) _inst_2 (MulOpposite.addCommMonoid.{u2} M _inst_2) _inst_3 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) (MulOpposite.opLinearEquiv.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (MulOpposite.op.{u2} M)
but is expected to have type
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], Eq.{succ u2} (forall (a : M), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => MulOpposite.{u2} M) a) (FunLike.coe.{succ u2, succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (MulOpposite.{u2} M) _inst_2 (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2) _inst_3 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3)) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => MulOpposite.{u2} M) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} R R M (MulOpposite.{u2} M) _inst_1 _inst_1 _inst_2 (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2) _inst_3 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearEquiv.toLinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M (MulOpposite.{u2} M) _inst_2 (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2) _inst_3 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) (MulOpposite.opLinearEquiv.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (MulOpposite.op.{u2} M)
Case conversion may be inaccurate. Consider using '#align mul_opposite.coe_op_linear_equiv_to_linear_map MulOpposite.coe_opLinearEquiv_toLinearMapₓ'. -/
@[simp]
theorem coe_opLinearEquiv_toLinearMap : ((opLinearEquiv R).toLinearMap : M → Mᵐᵒᵖ) = op :=
  rfl
#align mul_opposite.coe_op_linear_equiv_to_linear_map MulOpposite.coe_opLinearEquiv_toLinearMap

/- warning: mul_opposite.coe_op_linear_equiv_symm_to_linear_map -> MulOpposite.coe_opLinearEquiv_symm_toLinearMap is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], Eq.{succ u2} ((fun (_x : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (MulOpposite.{u2} M) M (MulOpposite.addCommMonoid.{u2} M _inst_2) _inst_2 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) _inst_3) => (MulOpposite.{u2} M) -> M) (LinearEquiv.toLinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (MulOpposite.{u2} M) M (MulOpposite.addCommMonoid.{u2} M _inst_2) _inst_2 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) _inst_3 (LinearEquiv.symm.{u1, u1, u2, u2} R R M (MulOpposite.{u2} M) _inst_1 _inst_1 _inst_2 (MulOpposite.addCommMonoid.{u2} M _inst_2) _inst_3 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (MulOpposite.opLinearEquiv.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (coeFn.{succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (MulOpposite.{u2} M) M (MulOpposite.addCommMonoid.{u2} M _inst_2) _inst_2 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) _inst_3) (fun (_x : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (MulOpposite.{u2} M) M (MulOpposite.addCommMonoid.{u2} M _inst_2) _inst_2 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) _inst_3) => (MulOpposite.{u2} M) -> M) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R (MulOpposite.{u2} M) M _inst_1 _inst_1 (MulOpposite.addCommMonoid.{u2} M _inst_2) _inst_2 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearEquiv.toLinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (MulOpposite.{u2} M) M (MulOpposite.addCommMonoid.{u2} M _inst_2) _inst_2 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) _inst_3 (LinearEquiv.symm.{u1, u1, u2, u2} R R M (MulOpposite.{u2} M) _inst_1 _inst_1 _inst_2 (MulOpposite.addCommMonoid.{u2} M _inst_2) _inst_3 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (MulOpposite.opLinearEquiv.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (MulOpposite.unop.{u2} M)
but is expected to have type
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], Eq.{succ u2} (forall (a : MulOpposite.{u2} M), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : MulOpposite.{u2} M) => M) a) (FunLike.coe.{succ u2, succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (MulOpposite.{u2} M) M (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2) _inst_2 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) _inst_3) (MulOpposite.{u2} M) (fun (_x : MulOpposite.{u2} M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : MulOpposite.{u2} M) => M) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} R R (MulOpposite.{u2} M) M _inst_1 _inst_1 (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2) _inst_2 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearEquiv.toLinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (MulOpposite.{u2} M) M (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2) _inst_2 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) _inst_3 (LinearEquiv.symm.{u1, u1, u2, u2} R R M (MulOpposite.{u2} M) _inst_1 _inst_1 _inst_2 (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2) _inst_3 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (MulOpposite.opLinearEquiv.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (MulOpposite.unop.{u2} M)
Case conversion may be inaccurate. Consider using '#align mul_opposite.coe_op_linear_equiv_symm_to_linear_map MulOpposite.coe_opLinearEquiv_symm_toLinearMapₓ'. -/
@[simp]
theorem coe_opLinearEquiv_symm_toLinearMap :
    ((opLinearEquiv R).symm.toLinearMap : Mᵐᵒᵖ → M) = unop :=
  rfl
#align mul_opposite.coe_op_linear_equiv_symm_to_linear_map MulOpposite.coe_opLinearEquiv_symm_toLinearMap

/- warning: mul_opposite.op_linear_equiv_to_add_equiv -> MulOpposite.opLinearEquiv_toAddEquiv is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], Eq.{succ u2} (AddEquiv.{u2, u2} M (MulOpposite.{u2} M) (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toHasAdd.{u2} (MulOpposite.{u2} M) (AddMonoid.toAddZeroClass.{u2} (MulOpposite.{u2} M) (AddCommMonoid.toAddMonoid.{u2} (MulOpposite.{u2} M) (MulOpposite.addCommMonoid.{u2} M _inst_2))))) (LinearEquiv.toAddEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M (MulOpposite.{u2} M) _inst_2 (MulOpposite.addCommMonoid.{u2} M _inst_2) _inst_3 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) (MulOpposite.opLinearEquiv.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (MulOpposite.opAddEquiv.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))
but is expected to have type
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], Eq.{succ u2} (AddEquiv.{u2, u2} M (MulOpposite.{u2} M) (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toAdd.{u2} (MulOpposite.{u2} M) (AddMonoid.toAddZeroClass.{u2} (MulOpposite.{u2} M) (AddCommMonoid.toAddMonoid.{u2} (MulOpposite.{u2} M) (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2))))) (LinearEquiv.toAddEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M (MulOpposite.{u2} M) _inst_2 (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2) _inst_3 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) (MulOpposite.opLinearEquiv.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (MulOpposite.opAddEquiv.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))
Case conversion may be inaccurate. Consider using '#align mul_opposite.op_linear_equiv_to_add_equiv MulOpposite.opLinearEquiv_toAddEquivₓ'. -/
@[simp]
theorem opLinearEquiv_toAddEquiv : (opLinearEquiv R : M ≃ₗ[R] Mᵐᵒᵖ).toAddEquiv = opAddEquiv :=
  rfl
#align mul_opposite.op_linear_equiv_to_add_equiv MulOpposite.opLinearEquiv_toAddEquiv

/- warning: mul_opposite.op_linear_equiv_symm_to_add_equiv -> MulOpposite.opLinearEquiv_symm_toAddEquiv is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], Eq.{succ u2} (AddEquiv.{u2, u2} (MulOpposite.{u2} M) M (AddZeroClass.toHasAdd.{u2} (MulOpposite.{u2} M) (AddMonoid.toAddZeroClass.{u2} (MulOpposite.{u2} M) (AddCommMonoid.toAddMonoid.{u2} (MulOpposite.{u2} M) (MulOpposite.addCommMonoid.{u2} M _inst_2)))) (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (LinearEquiv.toAddEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (MulOpposite.{u2} M) M (MulOpposite.addCommMonoid.{u2} M _inst_2) _inst_2 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) _inst_3 (LinearEquiv.symm.{u1, u1, u2, u2} R R M (MulOpposite.{u2} M) _inst_1 _inst_1 _inst_2 (MulOpposite.addCommMonoid.{u2} M _inst_2) _inst_3 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (MulOpposite.opLinearEquiv.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (AddEquiv.symm.{u2, u2} M (MulOpposite.{u2} M) (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulOpposite.hasAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (MulOpposite.opAddEquiv.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))
but is expected to have type
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], Eq.{succ u2} (AddEquiv.{u2, u2} (MulOpposite.{u2} M) M (AddZeroClass.toAdd.{u2} (MulOpposite.{u2} M) (AddMonoid.toAddZeroClass.{u2} (MulOpposite.{u2} M) (AddCommMonoid.toAddMonoid.{u2} (MulOpposite.{u2} M) (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2)))) (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (LinearEquiv.toAddEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (MulOpposite.{u2} M) M (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2) _inst_2 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) _inst_3 (LinearEquiv.symm.{u1, u1, u2, u2} R R M (MulOpposite.{u2} M) _inst_1 _inst_1 _inst_2 (MulOpposite.instAddCommMonoidMulOpposite.{u2} M _inst_2) _inst_3 (MulOpposite.module.{u1, u2} R M _inst_1 _inst_2 _inst_3) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (MulOpposite.opLinearEquiv.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (AddEquiv.symm.{u2, u2} M (MulOpposite.{u2} M) (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulOpposite.instAddMulOpposite.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (MulOpposite.opAddEquiv.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))
Case conversion may be inaccurate. Consider using '#align mul_opposite.op_linear_equiv_symm_to_add_equiv MulOpposite.opLinearEquiv_symm_toAddEquivₓ'. -/
@[simp]
theorem opLinearEquiv_symm_toAddEquiv :
    (opLinearEquiv R : M ≃ₗ[R] Mᵐᵒᵖ).symm.toAddEquiv = opAddEquiv.symm :=
  rfl
#align mul_opposite.op_linear_equiv_symm_to_add_equiv MulOpposite.opLinearEquiv_symm_toAddEquiv

end MulOpposite

