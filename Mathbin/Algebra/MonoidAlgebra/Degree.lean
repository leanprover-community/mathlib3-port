/-
Copyright (c) 2022 Damiano Testa. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Damiano Testa

! This file was ported from Lean 3 source module algebra.monoid_algebra.degree
! leanprover-community/mathlib commit 932872382355f00112641d305ba0619305dc8642
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.MonoidAlgebra.Support

/-!
# Lemmas about the `sup` and `inf` of the support of `add_monoid_algebra`

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

## TODO
The current plan is to state and prove lemmas about `finset.sup (finsupp.support f) D` with a
"generic" degree/weight function `D` from the grading Type `A` to a somewhat ordered Type `B`.

Next, the general lemmas get specialized for some yet-to-be-defined `degree`s.
-/


variable {R A T B ι : Type _}

namespace AddMonoidAlgebra

open Classical BigOperators

/-! ### Results about the `finset.sup` and `finset.inf` of `finsupp.support` -/


section GeneralResultsAssumingSemilatticeSup

variable [SemilatticeSup B] [OrderBot B] [SemilatticeInf T] [OrderTop T]

section Semiring

variable [Semiring R]

section ExplicitDegrees

/-!

In this section, we use `degb` and `degt` to denote "degree functions" on `A` with values in
a type with *b*ot or *t*op respectively.
-/


variable (degb : A → B) (degt : A → T) (f g : AddMonoidAlgebra R A)

/- warning: add_monoid_algebra.sup_support_add_le -> AddMonoidAlgebra.sup_support_add_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} {B : Type.{u3}} [_inst_1 : SemilatticeSup.{u3} B] [_inst_2 : OrderBot.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1)))] [_inst_5 : Semiring.{u1} R] (degb : A -> B) (f : AddMonoidAlgebra.{u1, u2} R A _inst_5) (g : AddMonoidAlgebra.{u1, u2} R A _inst_5), LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))) (Finset.sup.{u3, u2} B A _inst_1 _inst_2 (Finsupp.support.{u2, u1} A R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_5)))) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (AddMonoidAlgebra.{u1, u2} R A _inst_5) (AddMonoidAlgebra.{u1, u2} R A _inst_5) (instHAdd.{max u2 u1} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (AddZeroClass.toHasAdd.{max u2 u1} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (AddMonoidAlgebra.addCommMonoid.{u2, u1} R A _inst_5))))) f g)) degb) (Sup.sup.{u3} B (SemilatticeSup.toHasSup.{u3} B _inst_1) (Finset.sup.{u3, u2} B A _inst_1 _inst_2 (Finsupp.support.{u2, u1} A R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_5)))) f) degb) (Finset.sup.{u3, u2} B A _inst_1 _inst_2 (Finsupp.support.{u2, u1} A R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_5)))) g) degb))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} {B : Type.{u3}} [_inst_1 : SemilatticeSup.{u3} B] [_inst_2 : OrderBot.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1)))] [_inst_5 : Semiring.{u1} R] (degb : A -> B) (f : AddMonoidAlgebra.{u1, u2} R A _inst_5) (g : AddMonoidAlgebra.{u1, u2} R A _inst_5), LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))) (Finset.sup.{u3, u2} B A _inst_1 _inst_2 (Finsupp.support.{u2, u1} A R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_5)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (AddMonoidAlgebra.{u1, u2} R A _inst_5) (AddMonoidAlgebra.{u1, u2} R A _inst_5) (instHAdd.{max u1 u2} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (AddZeroClass.toAdd.{max u1 u2} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (AddMonoid.toAddZeroClass.{max u1 u2} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (AddCommMonoid.toAddMonoid.{max u1 u2} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (AddMonoidAlgebra.addCommMonoid.{u1, u2} R A _inst_5))))) f g)) degb) (Sup.sup.{u3} B (SemilatticeSup.toSup.{u3} B _inst_1) (Finset.sup.{u3, u2} B A _inst_1 _inst_2 (Finsupp.support.{u2, u1} A R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_5)) f) degb) (Finset.sup.{u3, u2} B A _inst_1 _inst_2 (Finsupp.support.{u2, u1} A R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_5)) g) degb))
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.sup_support_add_le AddMonoidAlgebra.sup_support_add_leₓ'. -/
theorem sup_support_add_le : (f + g).support.sup degb ≤ f.support.sup degb ⊔ g.support.sup degb :=
  (Finset.sup_mono Finsupp.support_add).trans_eq Finset.sup_union
#align add_monoid_algebra.sup_support_add_le AddMonoidAlgebra.sup_support_add_le

/- warning: add_monoid_algebra.le_inf_support_add -> AddMonoidAlgebra.le_inf_support_add is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} {T : Type.{u3}} [_inst_3 : SemilatticeInf.{u3} T] [_inst_4 : OrderTop.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3)))] [_inst_5 : Semiring.{u1} R] (degt : A -> T) (f : AddMonoidAlgebra.{u1, u2} R A _inst_5) (g : AddMonoidAlgebra.{u1, u2} R A _inst_5), LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))) (Inf.inf.{u3} T (SemilatticeInf.toHasInf.{u3} T _inst_3) (Finset.inf.{u3, u2} T A _inst_3 _inst_4 (Finsupp.support.{u2, u1} A R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_5)))) f) degt) (Finset.inf.{u3, u2} T A _inst_3 _inst_4 (Finsupp.support.{u2, u1} A R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_5)))) g) degt)) (Finset.inf.{u3, u2} T A _inst_3 _inst_4 (Finsupp.support.{u2, u1} A R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_5)))) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (AddMonoidAlgebra.{u1, u2} R A _inst_5) (AddMonoidAlgebra.{u1, u2} R A _inst_5) (instHAdd.{max u2 u1} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (AddZeroClass.toHasAdd.{max u2 u1} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (AddMonoidAlgebra.addCommMonoid.{u2, u1} R A _inst_5))))) f g)) degt)
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} {T : Type.{u3}} [_inst_3 : SemilatticeInf.{u3} T] [_inst_4 : OrderTop.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3)))] [_inst_5 : Semiring.{u1} R] (degt : A -> T) (f : AddMonoidAlgebra.{u1, u2} R A _inst_5) (g : AddMonoidAlgebra.{u1, u2} R A _inst_5), LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))) (Inf.inf.{u3} T (SemilatticeInf.toInf.{u3} T _inst_3) (Finset.inf.{u3, u2} T A _inst_3 _inst_4 (Finsupp.support.{u2, u1} A R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_5)) f) degt) (Finset.inf.{u3, u2} T A _inst_3 _inst_4 (Finsupp.support.{u2, u1} A R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_5)) g) degt)) (Finset.inf.{u3, u2} T A _inst_3 _inst_4 (Finsupp.support.{u2, u1} A R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_5)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (AddMonoidAlgebra.{u1, u2} R A _inst_5) (AddMonoidAlgebra.{u1, u2} R A _inst_5) (instHAdd.{max u1 u2} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (AddZeroClass.toAdd.{max u1 u2} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (AddMonoid.toAddZeroClass.{max u1 u2} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (AddCommMonoid.toAddMonoid.{max u1 u2} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (AddMonoidAlgebra.addCommMonoid.{u1, u2} R A _inst_5))))) f g)) degt)
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.le_inf_support_add AddMonoidAlgebra.le_inf_support_addₓ'. -/
theorem le_inf_support_add : f.support.inf degt ⊓ g.support.inf degt ≤ (f + g).support.inf degt :=
  sup_support_add_le (fun a : A => OrderDual.toDual (degt a)) f g
#align add_monoid_algebra.le_inf_support_add AddMonoidAlgebra.le_inf_support_add

end ExplicitDegrees

section AddOnly

variable [Add A] [Add B] [Add T] [CovariantClass B B (· + ·) (· ≤ ·)]
  [CovariantClass B B (Function.swap (· + ·)) (· ≤ ·)] [CovariantClass T T (· + ·) (· ≤ ·)]
  [CovariantClass T T (Function.swap (· + ·)) (· ≤ ·)]

#print AddMonoidAlgebra.sup_support_mul_le /-
theorem sup_support_mul_le {degb : A → B} (degbm : ∀ {a b}, degb (a + b) ≤ degb a + degb b)
    (f g : AddMonoidAlgebra R A) :
    (f * g).support.sup degb ≤ f.support.sup degb + g.support.sup degb :=
  by
  refine' (Finset.sup_mono <| support_mul _ _).trans _
  simp_rw [Finset.sup_biUnion, Finset.sup_singleton]
  refine' Finset.sup_le fun fd fds => Finset.sup_le fun gd gds => degbm.trans <| add_le_add _ _ <;>
    exact Finset.le_sup ‹_›
#align add_monoid_algebra.sup_support_mul_le AddMonoidAlgebra.sup_support_mul_le
-/

#print AddMonoidAlgebra.le_inf_support_mul /-
theorem le_inf_support_mul {degt : A → T} (degtm : ∀ {a b}, degt a + degt b ≤ degt (a + b))
    (f g : AddMonoidAlgebra R A) :
    f.support.inf degt + g.support.inf degt ≤ (f * g).support.inf degt :=
  OrderDual.ofDual_le_ofDual.mpr <|
    sup_support_mul_le (fun a b => OrderDual.ofDual_le_ofDual.mp degtm) f g
#align add_monoid_algebra.le_inf_support_mul AddMonoidAlgebra.le_inf_support_mul
-/

end AddOnly

section AddMonoids

variable [AddMonoid A] [AddMonoid B] [CovariantClass B B (· + ·) (· ≤ ·)]
  [CovariantClass B B (Function.swap (· + ·)) (· ≤ ·)] [AddMonoid T]
  [CovariantClass T T (· + ·) (· ≤ ·)] [CovariantClass T T (Function.swap (· + ·)) (· ≤ ·)]
  {degb : A → B} {degt : A → T}

/- warning: add_monoid_algebra.sup_support_list_prod_le -> AddMonoidAlgebra.sup_support_list_prod_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} {B : Type.{u3}} [_inst_1 : SemilatticeSup.{u3} B] [_inst_2 : OrderBot.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1)))] [_inst_5 : Semiring.{u1} R] [_inst_6 : AddMonoid.{u2} A] [_inst_7 : AddMonoid.{u3} B] [_inst_8 : CovariantClass.{u3, u3} B B (HAdd.hAdd.{u3, u3, u3} B B B (instHAdd.{u3} B (AddZeroClass.toHasAdd.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_7)))) (LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))))] [_inst_9 : CovariantClass.{u3, u3} B B (Function.swap.{succ u3, succ u3, succ u3} B B (fun (ᾰ : B) (ᾰ : B) => B) (HAdd.hAdd.{u3, u3, u3} B B B (instHAdd.{u3} B (AddZeroClass.toHasAdd.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_7))))) (LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))))] {degb : A -> B}, (LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))) (degb (OfNat.ofNat.{u2} A 0 (OfNat.mk.{u2} A 0 (Zero.zero.{u2} A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_6)))))) (OfNat.ofNat.{u3} B 0 (OfNat.mk.{u3} B 0 (Zero.zero.{u3} B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_7)))))) -> (forall (a : A) (b : A), LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))) (degb (HAdd.hAdd.{u2, u2, u2} A A A (instHAdd.{u2} A (AddZeroClass.toHasAdd.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_6))) a b)) (HAdd.hAdd.{u3, u3, u3} B B B (instHAdd.{u3} B (AddZeroClass.toHasAdd.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_7))) (degb a) (degb b))) -> (forall (l : List.{max u2 u1} (AddMonoidAlgebra.{u1, u2} R A _inst_5)), LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))) (Finset.sup.{u3, u2} B A _inst_1 _inst_2 (Finsupp.support.{u2, u1} A R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_5)))) (List.prod.{max u2 u1} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (AddMonoidAlgebra.hasMul.{u1, u2} R A _inst_5 (AddZeroClass.toHasAdd.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_6))) (AddMonoidAlgebra.one.{u1, u2} R A _inst_5 (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_6))) l)) degb) (List.sum.{u3} B (AddZeroClass.toHasAdd.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_7)) (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_7)) (List.map.{max u2 u1, u3} (AddMonoidAlgebra.{u1, u2} R A _inst_5) B (fun (f : AddMonoidAlgebra.{u1, u2} R A _inst_5) => Finset.sup.{u3, u2} B A _inst_1 _inst_2 (Finsupp.support.{u2, u1} A R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_5)))) f) degb) l)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} {B : Type.{u3}} [_inst_1 : SemilatticeSup.{u3} B] [_inst_2 : OrderBot.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1)))] [_inst_5 : Semiring.{u1} R] [_inst_6 : AddMonoid.{u2} A] [_inst_7 : AddMonoid.{u3} B] [_inst_8 : CovariantClass.{u3, u3} B B (fun (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1155 : B) (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1157 : B) => HAdd.hAdd.{u3, u3, u3} B B B (instHAdd.{u3} B (AddZeroClass.toAdd.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_7))) x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1155 x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1157) (fun (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1170 : B) (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1172 : B) => LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))) x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1170 x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1172)] [_inst_9 : CovariantClass.{u3, u3} B B (Function.swap.{succ u3, succ u3, succ u3} B B (fun (ᾰ : B) (ᾰ : B) => B) (fun (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1192 : B) (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1194 : B) => HAdd.hAdd.{u3, u3, u3} B B B (instHAdd.{u3} B (AddZeroClass.toAdd.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_7))) x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1192 x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1194)) (fun (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1207 : B) (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1209 : B) => LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))) x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1207 x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1209)] {degb : A -> B}, (LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))) (degb (OfNat.ofNat.{u2} A 0 (Zero.toOfNat0.{u2} A (AddMonoid.toZero.{u2} A _inst_6)))) (OfNat.ofNat.{u3} B 0 (Zero.toOfNat0.{u3} B (AddMonoid.toZero.{u3} B _inst_7)))) -> (forall (a : A) (b : A), LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))) (degb (HAdd.hAdd.{u2, u2, u2} A A A (instHAdd.{u2} A (AddZeroClass.toAdd.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_6))) a b)) (HAdd.hAdd.{u3, u3, u3} B B B (instHAdd.{u3} B (AddZeroClass.toAdd.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_7))) (degb a) (degb b))) -> (forall (l : List.{max u2 u1} (AddMonoidAlgebra.{u1, u2} R A _inst_5)), LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))) (Finset.sup.{u3, u2} B A _inst_1 _inst_2 (Finsupp.support.{u2, u1} A R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_5)) (List.prod.{max u1 u2} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (AddMonoidAlgebra.hasMul.{u1, u2} R A _inst_5 (AddZeroClass.toAdd.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_6))) (AddMonoidAlgebra.one.{u1, u2} R A _inst_5 (AddMonoid.toZero.{u2} A _inst_6)) l)) degb) (List.sum.{u3} B (AddZeroClass.toAdd.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_7)) (AddMonoid.toZero.{u3} B _inst_7) (List.map.{max u1 u2, u3} (AddMonoidAlgebra.{u1, u2} R A _inst_5) B (fun (f : AddMonoidAlgebra.{u1, u2} R A _inst_5) => Finset.sup.{u3, u2} B A _inst_1 _inst_2 (Finsupp.support.{u2, u1} A R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_5)) f) degb) l)))
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.sup_support_list_prod_le AddMonoidAlgebra.sup_support_list_prod_leₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
theorem sup_support_list_prod_le (degb0 : degb 0 ≤ 0)
    (degbm : ∀ a b, degb (a + b) ≤ degb a + degb b) :
    ∀ l : List (AddMonoidAlgebra R A),
      l.Prod.support.sup degb ≤ (l.map fun f : AddMonoidAlgebra R A => f.support.sup degb).Sum
  | [] => by
    rw [List.map_nil, Finset.sup_le_iff, List.prod_nil, List.sum_nil]
    exact fun a ha => by rwa [finset.mem_singleton.mp (Finsupp.support_single_subset ha)]
  | f::fs => by
    rw [List.prod_cons, List.map_cons, List.sum_cons]
    exact (sup_support_mul_le degbm _ _).trans (add_le_add_left (sup_support_list_prod_le _) _)
#align add_monoid_algebra.sup_support_list_prod_le AddMonoidAlgebra.sup_support_list_prod_le

/- warning: add_monoid_algebra.le_inf_support_list_prod -> AddMonoidAlgebra.le_inf_support_list_prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} {T : Type.{u3}} [_inst_3 : SemilatticeInf.{u3} T] [_inst_4 : OrderTop.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3)))] [_inst_5 : Semiring.{u1} R] [_inst_6 : AddMonoid.{u2} A] [_inst_10 : AddMonoid.{u3} T] [_inst_11 : CovariantClass.{u3, u3} T T (HAdd.hAdd.{u3, u3, u3} T T T (instHAdd.{u3} T (AddZeroClass.toHasAdd.{u3} T (AddMonoid.toAddZeroClass.{u3} T _inst_10)))) (LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))))] [_inst_12 : CovariantClass.{u3, u3} T T (Function.swap.{succ u3, succ u3, succ u3} T T (fun (ᾰ : T) (ᾰ : T) => T) (HAdd.hAdd.{u3, u3, u3} T T T (instHAdd.{u3} T (AddZeroClass.toHasAdd.{u3} T (AddMonoid.toAddZeroClass.{u3} T _inst_10))))) (LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))))] {degt : A -> T}, (LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))) (OfNat.ofNat.{u3} T 0 (OfNat.mk.{u3} T 0 (Zero.zero.{u3} T (AddZeroClass.toHasZero.{u3} T (AddMonoid.toAddZeroClass.{u3} T _inst_10))))) (degt (OfNat.ofNat.{u2} A 0 (OfNat.mk.{u2} A 0 (Zero.zero.{u2} A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_6))))))) -> (forall (a : A) (b : A), LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))) (HAdd.hAdd.{u3, u3, u3} T T T (instHAdd.{u3} T (AddZeroClass.toHasAdd.{u3} T (AddMonoid.toAddZeroClass.{u3} T _inst_10))) (degt a) (degt b)) (degt (HAdd.hAdd.{u2, u2, u2} A A A (instHAdd.{u2} A (AddZeroClass.toHasAdd.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_6))) a b))) -> (forall (l : List.{max u2 u1} (AddMonoidAlgebra.{u1, u2} R A _inst_5)), LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))) (List.sum.{u3} T (AddZeroClass.toHasAdd.{u3} T (AddMonoid.toAddZeroClass.{u3} T _inst_10)) (AddZeroClass.toHasZero.{u3} T (AddMonoid.toAddZeroClass.{u3} T _inst_10)) (List.map.{max u2 u1, u3} (AddMonoidAlgebra.{u1, u2} R A _inst_5) T (fun (f : AddMonoidAlgebra.{u1, u2} R A _inst_5) => Finset.inf.{u3, u2} T A _inst_3 _inst_4 (Finsupp.support.{u2, u1} A R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_5)))) f) degt) l)) (Finset.inf.{u3, u2} T A _inst_3 _inst_4 (Finsupp.support.{u2, u1} A R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_5)))) (List.prod.{max u2 u1} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (AddMonoidAlgebra.hasMul.{u1, u2} R A _inst_5 (AddZeroClass.toHasAdd.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_6))) (AddMonoidAlgebra.one.{u1, u2} R A _inst_5 (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_6))) l)) degt))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} {T : Type.{u3}} [_inst_3 : SemilatticeInf.{u3} T] [_inst_4 : OrderTop.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3)))] [_inst_5 : Semiring.{u1} R] [_inst_6 : AddMonoid.{u2} A] [_inst_10 : AddMonoid.{u3} T] [_inst_11 : CovariantClass.{u3, u3} T T (fun (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1636 : T) (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1638 : T) => HAdd.hAdd.{u3, u3, u3} T T T (instHAdd.{u3} T (AddZeroClass.toAdd.{u3} T (AddMonoid.toAddZeroClass.{u3} T _inst_10))) x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1636 x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1638) (fun (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1651 : T) (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1653 : T) => LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))) x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1651 x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1653)] [_inst_12 : CovariantClass.{u3, u3} T T (Function.swap.{succ u3, succ u3, succ u3} T T (fun (ᾰ : T) (ᾰ : T) => T) (fun (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1673 : T) (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1675 : T) => HAdd.hAdd.{u3, u3, u3} T T T (instHAdd.{u3} T (AddZeroClass.toAdd.{u3} T (AddMonoid.toAddZeroClass.{u3} T _inst_10))) x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1673 x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1675)) (fun (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1688 : T) (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1690 : T) => LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))) x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1688 x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1690)] {degt : A -> T}, (LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))) (OfNat.ofNat.{u3} T 0 (Zero.toOfNat0.{u3} T (AddMonoid.toZero.{u3} T _inst_10))) (degt (OfNat.ofNat.{u2} A 0 (Zero.toOfNat0.{u2} A (AddMonoid.toZero.{u2} A _inst_6))))) -> (forall (a : A) (b : A), LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))) (HAdd.hAdd.{u3, u3, u3} T T T (instHAdd.{u3} T (AddZeroClass.toAdd.{u3} T (AddMonoid.toAddZeroClass.{u3} T _inst_10))) (degt a) (degt b)) (degt (HAdd.hAdd.{u2, u2, u2} A A A (instHAdd.{u2} A (AddZeroClass.toAdd.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_6))) a b))) -> (forall (l : List.{max u2 u1} (AddMonoidAlgebra.{u1, u2} R A _inst_5)), LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))) (List.sum.{u3} T (AddZeroClass.toAdd.{u3} T (AddMonoid.toAddZeroClass.{u3} T _inst_10)) (AddMonoid.toZero.{u3} T _inst_10) (List.map.{max u1 u2, u3} (AddMonoidAlgebra.{u1, u2} R A _inst_5) T (fun (f : AddMonoidAlgebra.{u1, u2} R A _inst_5) => Finset.inf.{u3, u2} T A _inst_3 _inst_4 (Finsupp.support.{u2, u1} A R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_5)) f) degt) l)) (Finset.inf.{u3, u2} T A _inst_3 _inst_4 (Finsupp.support.{u2, u1} A R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_5)) (List.prod.{max u1 u2} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (AddMonoidAlgebra.hasMul.{u1, u2} R A _inst_5 (AddZeroClass.toAdd.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_6))) (AddMonoidAlgebra.one.{u1, u2} R A _inst_5 (AddMonoid.toZero.{u2} A _inst_6)) l)) degt))
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.le_inf_support_list_prod AddMonoidAlgebra.le_inf_support_list_prodₓ'. -/
theorem le_inf_support_list_prod (degt0 : 0 ≤ degt 0)
    (degtm : ∀ a b, degt a + degt b ≤ degt (a + b)) (l : List (AddMonoidAlgebra R A)) :
    (l.map fun f : AddMonoidAlgebra R A => f.support.inf degt).Sum ≤ l.Prod.support.inf degt :=
  OrderDual.ofDual_le_ofDual.mpr <|
    sup_support_list_prod_le (OrderDual.ofDual_le_ofDual.mp degt0)
      (fun a b => OrderDual.ofDual_le_ofDual.mp (degtm _ _)) l
#align add_monoid_algebra.le_inf_support_list_prod AddMonoidAlgebra.le_inf_support_list_prod

/- warning: add_monoid_algebra.sup_support_pow_le -> AddMonoidAlgebra.sup_support_pow_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} {B : Type.{u3}} [_inst_1 : SemilatticeSup.{u3} B] [_inst_2 : OrderBot.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1)))] [_inst_5 : Semiring.{u1} R] [_inst_6 : AddMonoid.{u2} A] [_inst_7 : AddMonoid.{u3} B] [_inst_8 : CovariantClass.{u3, u3} B B (HAdd.hAdd.{u3, u3, u3} B B B (instHAdd.{u3} B (AddZeroClass.toHasAdd.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_7)))) (LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))))] [_inst_9 : CovariantClass.{u3, u3} B B (Function.swap.{succ u3, succ u3, succ u3} B B (fun (ᾰ : B) (ᾰ : B) => B) (HAdd.hAdd.{u3, u3, u3} B B B (instHAdd.{u3} B (AddZeroClass.toHasAdd.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_7))))) (LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))))] {degb : A -> B}, (LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))) (degb (OfNat.ofNat.{u2} A 0 (OfNat.mk.{u2} A 0 (Zero.zero.{u2} A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_6)))))) (OfNat.ofNat.{u3} B 0 (OfNat.mk.{u3} B 0 (Zero.zero.{u3} B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_7)))))) -> (forall (a : A) (b : A), LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))) (degb (HAdd.hAdd.{u2, u2, u2} A A A (instHAdd.{u2} A (AddZeroClass.toHasAdd.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_6))) a b)) (HAdd.hAdd.{u3, u3, u3} B B B (instHAdd.{u3} B (AddZeroClass.toHasAdd.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_7))) (degb a) (degb b))) -> (forall (n : Nat) (f : AddMonoidAlgebra.{u1, u2} R A _inst_5), LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))) (Finset.sup.{u3, u2} B A _inst_1 _inst_2 (Finsupp.support.{u2, u1} A R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_5)))) (HPow.hPow.{max u2 u1, 0, max u2 u1} (AddMonoidAlgebra.{u1, u2} R A _inst_5) Nat (AddMonoidAlgebra.{u1, u2} R A _inst_5) (instHPow.{max u2 u1, 0} (AddMonoidAlgebra.{u1, u2} R A _inst_5) Nat (Monoid.Pow.{max u2 u1} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (MonoidWithZero.toMonoid.{max u2 u1} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (Semiring.toMonoidWithZero.{max u2 u1} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (AddMonoidAlgebra.semiring.{u1, u2} R A _inst_5 _inst_6))))) f n)) degb) (SMul.smul.{0, u3} Nat B (AddMonoid.SMul.{u3} B _inst_7) n (Finset.sup.{u3, u2} B A _inst_1 _inst_2 (Finsupp.support.{u2, u1} A R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_5)))) f) degb)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} {B : Type.{u3}} [_inst_1 : SemilatticeSup.{u3} B] [_inst_2 : OrderBot.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1)))] [_inst_5 : Semiring.{u1} R] [_inst_6 : AddMonoid.{u2} A] [_inst_7 : AddMonoid.{u3} B] [_inst_8 : CovariantClass.{u3, u3} B B (fun (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1826 : B) (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1828 : B) => HAdd.hAdd.{u3, u3, u3} B B B (instHAdd.{u3} B (AddZeroClass.toAdd.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_7))) x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1826 x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1828) (fun (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1841 : B) (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1843 : B) => LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))) x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1841 x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1843)] [_inst_9 : CovariantClass.{u3, u3} B B (Function.swap.{succ u3, succ u3, succ u3} B B (fun (ᾰ : B) (ᾰ : B) => B) (fun (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1863 : B) (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1865 : B) => HAdd.hAdd.{u3, u3, u3} B B B (instHAdd.{u3} B (AddZeroClass.toAdd.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_7))) x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1863 x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1865)) (fun (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1878 : B) (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1880 : B) => LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))) x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1878 x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.1880)] {degb : A -> B}, (LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))) (degb (OfNat.ofNat.{u2} A 0 (Zero.toOfNat0.{u2} A (AddMonoid.toZero.{u2} A _inst_6)))) (OfNat.ofNat.{u3} B 0 (Zero.toOfNat0.{u3} B (AddMonoid.toZero.{u3} B _inst_7)))) -> (forall (a : A) (b : A), LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))) (degb (HAdd.hAdd.{u2, u2, u2} A A A (instHAdd.{u2} A (AddZeroClass.toAdd.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_6))) a b)) (HAdd.hAdd.{u3, u3, u3} B B B (instHAdd.{u3} B (AddZeroClass.toAdd.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_7))) (degb a) (degb b))) -> (forall (n : Nat) (f : AddMonoidAlgebra.{u1, u2} R A _inst_5), LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))) (Finset.sup.{u3, u2} B A _inst_1 _inst_2 (Finsupp.support.{u2, u1} A R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_5)) (HPow.hPow.{max u1 u2, 0, max u1 u2} (AddMonoidAlgebra.{u1, u2} R A _inst_5) Nat (AddMonoidAlgebra.{u1, u2} R A _inst_5) (instHPow.{max u1 u2, 0} (AddMonoidAlgebra.{u1, u2} R A _inst_5) Nat (Monoid.Pow.{max u1 u2} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (MonoidWithZero.toMonoid.{max u1 u2} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (Semiring.toMonoidWithZero.{max u1 u2} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (AddMonoidAlgebra.semiring.{u1, u2} R A _inst_5 _inst_6))))) f n)) degb) (HSMul.hSMul.{0, u3, u3} Nat B B (instHSMul.{0, u3} Nat B (AddMonoid.SMul.{u3} B _inst_7)) n (Finset.sup.{u3, u2} B A _inst_1 _inst_2 (Finsupp.support.{u2, u1} A R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_5)) f) degb)))
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.sup_support_pow_le AddMonoidAlgebra.sup_support_pow_leₓ'. -/
theorem sup_support_pow_le (degb0 : degb 0 ≤ 0) (degbm : ∀ a b, degb (a + b) ≤ degb a + degb b)
    (n : ℕ) (f : AddMonoidAlgebra R A) : (f ^ n).support.sup degb ≤ n • f.support.sup degb :=
  by
  rw [← List.prod_replicate, ← List.sum_replicate]
  refine' (sup_support_list_prod_le degb0 degbm _).trans_eq _
  rw [List.map_replicate]
#align add_monoid_algebra.sup_support_pow_le AddMonoidAlgebra.sup_support_pow_le

/- warning: add_monoid_algebra.le_inf_support_pow -> AddMonoidAlgebra.le_inf_support_pow is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} {T : Type.{u3}} [_inst_3 : SemilatticeInf.{u3} T] [_inst_4 : OrderTop.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3)))] [_inst_5 : Semiring.{u1} R] [_inst_6 : AddMonoid.{u2} A] [_inst_10 : AddMonoid.{u3} T] [_inst_11 : CovariantClass.{u3, u3} T T (HAdd.hAdd.{u3, u3, u3} T T T (instHAdd.{u3} T (AddZeroClass.toHasAdd.{u3} T (AddMonoid.toAddZeroClass.{u3} T _inst_10)))) (LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))))] [_inst_12 : CovariantClass.{u3, u3} T T (Function.swap.{succ u3, succ u3, succ u3} T T (fun (ᾰ : T) (ᾰ : T) => T) (HAdd.hAdd.{u3, u3, u3} T T T (instHAdd.{u3} T (AddZeroClass.toHasAdd.{u3} T (AddMonoid.toAddZeroClass.{u3} T _inst_10))))) (LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))))] {degt : A -> T}, (LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))) (OfNat.ofNat.{u3} T 0 (OfNat.mk.{u3} T 0 (Zero.zero.{u3} T (AddZeroClass.toHasZero.{u3} T (AddMonoid.toAddZeroClass.{u3} T _inst_10))))) (degt (OfNat.ofNat.{u2} A 0 (OfNat.mk.{u2} A 0 (Zero.zero.{u2} A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_6))))))) -> (forall (a : A) (b : A), LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))) (HAdd.hAdd.{u3, u3, u3} T T T (instHAdd.{u3} T (AddZeroClass.toHasAdd.{u3} T (AddMonoid.toAddZeroClass.{u3} T _inst_10))) (degt a) (degt b)) (degt (HAdd.hAdd.{u2, u2, u2} A A A (instHAdd.{u2} A (AddZeroClass.toHasAdd.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_6))) a b))) -> (forall (n : Nat) (f : AddMonoidAlgebra.{u1, u2} R A _inst_5), LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))) (SMul.smul.{0, u3} Nat T (AddMonoid.SMul.{u3} T _inst_10) n (Finset.inf.{u3, u2} T A _inst_3 _inst_4 (Finsupp.support.{u2, u1} A R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_5)))) f) degt)) (Finset.inf.{u3, u2} T A _inst_3 _inst_4 (Finsupp.support.{u2, u1} A R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_5)))) (HPow.hPow.{max u2 u1, 0, max u2 u1} (AddMonoidAlgebra.{u1, u2} R A _inst_5) Nat (AddMonoidAlgebra.{u1, u2} R A _inst_5) (instHPow.{max u2 u1, 0} (AddMonoidAlgebra.{u1, u2} R A _inst_5) Nat (Monoid.Pow.{max u2 u1} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (MonoidWithZero.toMonoid.{max u2 u1} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (Semiring.toMonoidWithZero.{max u2 u1} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (AddMonoidAlgebra.semiring.{u1, u2} R A _inst_5 _inst_6))))) f n)) degt))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} {T : Type.{u3}} [_inst_3 : SemilatticeInf.{u3} T] [_inst_4 : OrderTop.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3)))] [_inst_5 : Semiring.{u1} R] [_inst_6 : AddMonoid.{u2} A] [_inst_10 : AddMonoid.{u3} T] [_inst_11 : CovariantClass.{u3, u3} T T (fun (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2196 : T) (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2198 : T) => HAdd.hAdd.{u3, u3, u3} T T T (instHAdd.{u3} T (AddZeroClass.toAdd.{u3} T (AddMonoid.toAddZeroClass.{u3} T _inst_10))) x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2196 x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2198) (fun (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2211 : T) (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2213 : T) => LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))) x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2211 x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2213)] [_inst_12 : CovariantClass.{u3, u3} T T (Function.swap.{succ u3, succ u3, succ u3} T T (fun (ᾰ : T) (ᾰ : T) => T) (fun (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2233 : T) (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2235 : T) => HAdd.hAdd.{u3, u3, u3} T T T (instHAdd.{u3} T (AddZeroClass.toAdd.{u3} T (AddMonoid.toAddZeroClass.{u3} T _inst_10))) x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2233 x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2235)) (fun (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2248 : T) (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2250 : T) => LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))) x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2248 x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2250)] {degt : A -> T}, (LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))) (OfNat.ofNat.{u3} T 0 (Zero.toOfNat0.{u3} T (AddMonoid.toZero.{u3} T _inst_10))) (degt (OfNat.ofNat.{u2} A 0 (Zero.toOfNat0.{u2} A (AddMonoid.toZero.{u2} A _inst_6))))) -> (forall (a : A) (b : A), LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))) (HAdd.hAdd.{u3, u3, u3} T T T (instHAdd.{u3} T (AddZeroClass.toAdd.{u3} T (AddMonoid.toAddZeroClass.{u3} T _inst_10))) (degt a) (degt b)) (degt (HAdd.hAdd.{u2, u2, u2} A A A (instHAdd.{u2} A (AddZeroClass.toAdd.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_6))) a b))) -> (forall (n : Nat) (f : AddMonoidAlgebra.{u1, u2} R A _inst_5), LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))) (HSMul.hSMul.{0, u3, u3} Nat T T (instHSMul.{0, u3} Nat T (AddMonoid.SMul.{u3} T _inst_10)) n (Finset.inf.{u3, u2} T A _inst_3 _inst_4 (Finsupp.support.{u2, u1} A R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_5)) f) degt)) (Finset.inf.{u3, u2} T A _inst_3 _inst_4 (Finsupp.support.{u2, u1} A R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_5)) (HPow.hPow.{max u1 u2, 0, max u1 u2} (AddMonoidAlgebra.{u1, u2} R A _inst_5) Nat (AddMonoidAlgebra.{u1, u2} R A _inst_5) (instHPow.{max u1 u2, 0} (AddMonoidAlgebra.{u1, u2} R A _inst_5) Nat (Monoid.Pow.{max u1 u2} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (MonoidWithZero.toMonoid.{max u1 u2} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (Semiring.toMonoidWithZero.{max u1 u2} (AddMonoidAlgebra.{u1, u2} R A _inst_5) (AddMonoidAlgebra.semiring.{u1, u2} R A _inst_5 _inst_6))))) f n)) degt))
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.le_inf_support_pow AddMonoidAlgebra.le_inf_support_powₓ'. -/
theorem le_inf_support_pow (degt0 : 0 ≤ degt 0) (degtm : ∀ a b, degt a + degt b ≤ degt (a + b))
    (n : ℕ) (f : AddMonoidAlgebra R A) : n • f.support.inf degt ≤ (f ^ n).support.inf degt :=
  OrderDual.ofDual_le_ofDual.mpr <|
    sup_support_pow_le (OrderDual.ofDual_le_ofDual.mp degt0)
      (fun a b => OrderDual.ofDual_le_ofDual.mp (degtm _ _)) n f
#align add_monoid_algebra.le_inf_support_pow AddMonoidAlgebra.le_inf_support_pow

end AddMonoids

end Semiring

section CommutativeLemmas

variable [CommSemiring R] [AddCommMonoid A] [AddCommMonoid B] [CovariantClass B B (· + ·) (· ≤ ·)]
  [CovariantClass B B (Function.swap (· + ·)) (· ≤ ·)] [AddCommMonoid T]
  [CovariantClass T T (· + ·) (· ≤ ·)] [CovariantClass T T (Function.swap (· + ·)) (· ≤ ·)]
  {degb : A → B} {degt : A → T}

/- warning: add_monoid_algebra.sup_support_multiset_prod_le -> AddMonoidAlgebra.sup_support_multiset_prod_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} {B : Type.{u3}} [_inst_1 : SemilatticeSup.{u3} B] [_inst_2 : OrderBot.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1)))] [_inst_5 : CommSemiring.{u1} R] [_inst_6 : AddCommMonoid.{u2} A] [_inst_7 : AddCommMonoid.{u3} B] [_inst_8 : CovariantClass.{u3, u3} B B (HAdd.hAdd.{u3, u3, u3} B B B (instHAdd.{u3} B (AddZeroClass.toHasAdd.{u3} B (AddMonoid.toAddZeroClass.{u3} B (AddCommMonoid.toAddMonoid.{u3} B _inst_7))))) (LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))))] [_inst_9 : CovariantClass.{u3, u3} B B (Function.swap.{succ u3, succ u3, succ u3} B B (fun (ᾰ : B) (ᾰ : B) => B) (HAdd.hAdd.{u3, u3, u3} B B B (instHAdd.{u3} B (AddZeroClass.toHasAdd.{u3} B (AddMonoid.toAddZeroClass.{u3} B (AddCommMonoid.toAddMonoid.{u3} B _inst_7)))))) (LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))))] {degb : A -> B}, (LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))) (degb (OfNat.ofNat.{u2} A 0 (OfNat.mk.{u2} A 0 (Zero.zero.{u2} A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A _inst_6))))))) (OfNat.ofNat.{u3} B 0 (OfNat.mk.{u3} B 0 (Zero.zero.{u3} B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B (AddCommMonoid.toAddMonoid.{u3} B _inst_7))))))) -> (forall (a : A) (b : A), LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))) (degb (HAdd.hAdd.{u2, u2, u2} A A A (instHAdd.{u2} A (AddZeroClass.toHasAdd.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A _inst_6)))) a b)) (HAdd.hAdd.{u3, u3, u3} B B B (instHAdd.{u3} B (AddZeroClass.toHasAdd.{u3} B (AddMonoid.toAddZeroClass.{u3} B (AddCommMonoid.toAddMonoid.{u3} B _inst_7)))) (degb a) (degb b))) -> (forall (m : Multiset.{max u2 u1} (AddMonoidAlgebra.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_5))), LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))) (Finset.sup.{u3, u2} B A _inst_1 _inst_2 (Finsupp.support.{u2, u1} A R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_5))))) (Multiset.prod.{max u2 u1} (AddMonoidAlgebra.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_5)) (CommSemiring.toCommMonoid.{max u2 u1} (AddMonoidAlgebra.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_5)) (AddMonoidAlgebra.commSemiring.{u1, u2} R A _inst_5 _inst_6)) m)) degb) (Multiset.sum.{u3} B _inst_7 (Multiset.map.{max u2 u1, u3} (AddMonoidAlgebra.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_5)) B (fun (f : AddMonoidAlgebra.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_5)) => Finset.sup.{u3, u2} B A _inst_1 _inst_2 (Finsupp.support.{u2, u1} A R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_5))))) f) degb) m)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} {B : Type.{u3}} [_inst_1 : SemilatticeSup.{u3} B] [_inst_2 : OrderBot.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1)))] [_inst_5 : CommSemiring.{u1} R] [_inst_6 : AddCommMonoid.{u2} A] [_inst_7 : AddCommMonoid.{u3} B] [_inst_8 : CovariantClass.{u3, u3} B B (fun (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2569 : B) (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2571 : B) => HAdd.hAdd.{u3, u3, u3} B B B (instHAdd.{u3} B (AddZeroClass.toAdd.{u3} B (AddMonoid.toAddZeroClass.{u3} B (AddCommMonoid.toAddMonoid.{u3} B _inst_7)))) x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2569 x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2571) (fun (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2584 : B) (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2586 : B) => LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))) x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2584 x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2586)] [_inst_9 : CovariantClass.{u3, u3} B B (Function.swap.{succ u3, succ u3, succ u3} B B (fun (ᾰ : B) (ᾰ : B) => B) (fun (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2606 : B) (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2608 : B) => HAdd.hAdd.{u3, u3, u3} B B B (instHAdd.{u3} B (AddZeroClass.toAdd.{u3} B (AddMonoid.toAddZeroClass.{u3} B (AddCommMonoid.toAddMonoid.{u3} B _inst_7)))) x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2606 x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2608)) (fun (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2621 : B) (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2623 : B) => LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))) x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2621 x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2623)] {degb : A -> B}, (LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))) (degb (OfNat.ofNat.{u2} A 0 (Zero.toOfNat0.{u2} A (AddMonoid.toZero.{u2} A (AddCommMonoid.toAddMonoid.{u2} A _inst_6))))) (OfNat.ofNat.{u3} B 0 (Zero.toOfNat0.{u3} B (AddMonoid.toZero.{u3} B (AddCommMonoid.toAddMonoid.{u3} B _inst_7))))) -> (forall (a : A) (b : A), LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))) (degb (HAdd.hAdd.{u2, u2, u2} A A A (instHAdd.{u2} A (AddZeroClass.toAdd.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A _inst_6)))) a b)) (HAdd.hAdd.{u3, u3, u3} B B B (instHAdd.{u3} B (AddZeroClass.toAdd.{u3} B (AddMonoid.toAddZeroClass.{u3} B (AddCommMonoid.toAddMonoid.{u3} B _inst_7)))) (degb a) (degb b))) -> (forall (m : Multiset.{max u2 u1} (AddMonoidAlgebra.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_5))), LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))) (Finset.sup.{u3, u2} B A _inst_1 _inst_2 (Finsupp.support.{u2, u1} A R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_5))) (Multiset.prod.{max u1 u2} (AddMonoidAlgebra.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_5)) (CommSemiring.toCommMonoid.{max u1 u2} (AddMonoidAlgebra.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_5)) (AddMonoidAlgebra.commSemiring.{u1, u2} R A _inst_5 _inst_6)) m)) degb) (Multiset.sum.{u3} B _inst_7 (Multiset.map.{max u1 u2, u3} (AddMonoidAlgebra.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_5)) B (fun (f : AddMonoidAlgebra.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_5)) => Finset.sup.{u3, u2} B A _inst_1 _inst_2 (Finsupp.support.{u2, u1} A R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_5))) f) degb) m)))
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.sup_support_multiset_prod_le AddMonoidAlgebra.sup_support_multiset_prod_leₓ'. -/
theorem sup_support_multiset_prod_le (degb0 : degb 0 ≤ 0)
    (degbm : ∀ a b, degb (a + b) ≤ degb a + degb b) (m : Multiset (AddMonoidAlgebra R A)) :
    m.Prod.support.sup degb ≤ (m.map fun f : AddMonoidAlgebra R A => f.support.sup degb).Sum :=
  by
  induction m using Quot.inductionOn
  rw [Multiset.quot_mk_to_coe'', Multiset.coe_map, Multiset.coe_sum, Multiset.coe_prod]
  exact sup_support_list_prod_le degb0 degbm m
#align add_monoid_algebra.sup_support_multiset_prod_le AddMonoidAlgebra.sup_support_multiset_prod_le

/- warning: add_monoid_algebra.le_inf_support_multiset_prod -> AddMonoidAlgebra.le_inf_support_multiset_prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} {T : Type.{u3}} [_inst_3 : SemilatticeInf.{u3} T] [_inst_4 : OrderTop.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3)))] [_inst_5 : CommSemiring.{u1} R] [_inst_6 : AddCommMonoid.{u2} A] [_inst_10 : AddCommMonoid.{u3} T] [_inst_11 : CovariantClass.{u3, u3} T T (HAdd.hAdd.{u3, u3, u3} T T T (instHAdd.{u3} T (AddZeroClass.toHasAdd.{u3} T (AddMonoid.toAddZeroClass.{u3} T (AddCommMonoid.toAddMonoid.{u3} T _inst_10))))) (LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))))] [_inst_12 : CovariantClass.{u3, u3} T T (Function.swap.{succ u3, succ u3, succ u3} T T (fun (ᾰ : T) (ᾰ : T) => T) (HAdd.hAdd.{u3, u3, u3} T T T (instHAdd.{u3} T (AddZeroClass.toHasAdd.{u3} T (AddMonoid.toAddZeroClass.{u3} T (AddCommMonoid.toAddMonoid.{u3} T _inst_10)))))) (LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))))] {degt : A -> T}, (LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))) (OfNat.ofNat.{u3} T 0 (OfNat.mk.{u3} T 0 (Zero.zero.{u3} T (AddZeroClass.toHasZero.{u3} T (AddMonoid.toAddZeroClass.{u3} T (AddCommMonoid.toAddMonoid.{u3} T _inst_10)))))) (degt (OfNat.ofNat.{u2} A 0 (OfNat.mk.{u2} A 0 (Zero.zero.{u2} A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A _inst_6)))))))) -> (forall (a : A) (b : A), LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))) (HAdd.hAdd.{u3, u3, u3} T T T (instHAdd.{u3} T (AddZeroClass.toHasAdd.{u3} T (AddMonoid.toAddZeroClass.{u3} T (AddCommMonoid.toAddMonoid.{u3} T _inst_10)))) (degt a) (degt b)) (degt (HAdd.hAdd.{u2, u2, u2} A A A (instHAdd.{u2} A (AddZeroClass.toHasAdd.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A _inst_6)))) a b))) -> (forall (m : Multiset.{max u2 u1} (AddMonoidAlgebra.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_5))), LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))) (Multiset.sum.{u3} T _inst_10 (Multiset.map.{max u2 u1, u3} (AddMonoidAlgebra.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_5)) T (fun (f : AddMonoidAlgebra.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_5)) => Finset.inf.{u3, u2} T A _inst_3 _inst_4 (Finsupp.support.{u2, u1} A R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_5))))) f) degt) m)) (Finset.inf.{u3, u2} T A _inst_3 _inst_4 (Finsupp.support.{u2, u1} A R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_5))))) (Multiset.prod.{max u2 u1} (AddMonoidAlgebra.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_5)) (CommSemiring.toCommMonoid.{max u2 u1} (AddMonoidAlgebra.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_5)) (AddMonoidAlgebra.commSemiring.{u1, u2} R A _inst_5 _inst_6)) m)) degt))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} {T : Type.{u3}} [_inst_3 : SemilatticeInf.{u3} T] [_inst_4 : OrderTop.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3)))] [_inst_5 : CommSemiring.{u1} R] [_inst_6 : AddCommMonoid.{u2} A] [_inst_10 : AddCommMonoid.{u3} T] [_inst_11 : CovariantClass.{u3, u3} T T (fun (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2915 : T) (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2917 : T) => HAdd.hAdd.{u3, u3, u3} T T T (instHAdd.{u3} T (AddZeroClass.toAdd.{u3} T (AddMonoid.toAddZeroClass.{u3} T (AddCommMonoid.toAddMonoid.{u3} T _inst_10)))) x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2915 x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2917) (fun (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2930 : T) (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2932 : T) => LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))) x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2930 x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2932)] [_inst_12 : CovariantClass.{u3, u3} T T (Function.swap.{succ u3, succ u3, succ u3} T T (fun (ᾰ : T) (ᾰ : T) => T) (fun (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2952 : T) (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2954 : T) => HAdd.hAdd.{u3, u3, u3} T T T (instHAdd.{u3} T (AddZeroClass.toAdd.{u3} T (AddMonoid.toAddZeroClass.{u3} T (AddCommMonoid.toAddMonoid.{u3} T _inst_10)))) x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2952 x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2954)) (fun (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2967 : T) (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2969 : T) => LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))) x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2967 x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.2969)] {degt : A -> T}, (LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))) (OfNat.ofNat.{u3} T 0 (Zero.toOfNat0.{u3} T (AddMonoid.toZero.{u3} T (AddCommMonoid.toAddMonoid.{u3} T _inst_10)))) (degt (OfNat.ofNat.{u2} A 0 (Zero.toOfNat0.{u2} A (AddMonoid.toZero.{u2} A (AddCommMonoid.toAddMonoid.{u2} A _inst_6)))))) -> (forall (a : A) (b : A), LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))) (HAdd.hAdd.{u3, u3, u3} T T T (instHAdd.{u3} T (AddZeroClass.toAdd.{u3} T (AddMonoid.toAddZeroClass.{u3} T (AddCommMonoid.toAddMonoid.{u3} T _inst_10)))) (degt a) (degt b)) (degt (HAdd.hAdd.{u2, u2, u2} A A A (instHAdd.{u2} A (AddZeroClass.toAdd.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A _inst_6)))) a b))) -> (forall (m : Multiset.{max u2 u1} (AddMonoidAlgebra.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_5))), LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))) (Multiset.sum.{u3} T _inst_10 (Multiset.map.{max u1 u2, u3} (AddMonoidAlgebra.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_5)) T (fun (f : AddMonoidAlgebra.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_5)) => Finset.inf.{u3, u2} T A _inst_3 _inst_4 (Finsupp.support.{u2, u1} A R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_5))) f) degt) m)) (Finset.inf.{u3, u2} T A _inst_3 _inst_4 (Finsupp.support.{u2, u1} A R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_5))) (Multiset.prod.{max u1 u2} (AddMonoidAlgebra.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_5)) (CommSemiring.toCommMonoid.{max u1 u2} (AddMonoidAlgebra.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_5)) (AddMonoidAlgebra.commSemiring.{u1, u2} R A _inst_5 _inst_6)) m)) degt))
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.le_inf_support_multiset_prod AddMonoidAlgebra.le_inf_support_multiset_prodₓ'. -/
theorem le_inf_support_multiset_prod (degt0 : 0 ≤ degt 0)
    (degtm : ∀ a b, degt a + degt b ≤ degt (a + b)) (m : Multiset (AddMonoidAlgebra R A)) :
    (m.map fun f : AddMonoidAlgebra R A => f.support.inf degt).Sum ≤ m.Prod.support.inf degt :=
  OrderDual.ofDual_le_ofDual.mpr <|
    sup_support_multiset_prod_le (OrderDual.ofDual_le_ofDual.mp degt0)
      (fun a b => OrderDual.ofDual_le_ofDual.mp (degtm _ _)) m
#align add_monoid_algebra.le_inf_support_multiset_prod AddMonoidAlgebra.le_inf_support_multiset_prod

/- warning: add_monoid_algebra.sup_support_finset_prod_le -> AddMonoidAlgebra.sup_support_finset_prod_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} {B : Type.{u3}} {ι : Type.{u4}} [_inst_1 : SemilatticeSup.{u3} B] [_inst_2 : OrderBot.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1)))] [_inst_5 : CommSemiring.{u1} R] [_inst_6 : AddCommMonoid.{u2} A] [_inst_7 : AddCommMonoid.{u3} B] [_inst_8 : CovariantClass.{u3, u3} B B (HAdd.hAdd.{u3, u3, u3} B B B (instHAdd.{u3} B (AddZeroClass.toHasAdd.{u3} B (AddMonoid.toAddZeroClass.{u3} B (AddCommMonoid.toAddMonoid.{u3} B _inst_7))))) (LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))))] [_inst_9 : CovariantClass.{u3, u3} B B (Function.swap.{succ u3, succ u3, succ u3} B B (fun (ᾰ : B) (ᾰ : B) => B) (HAdd.hAdd.{u3, u3, u3} B B B (instHAdd.{u3} B (AddZeroClass.toHasAdd.{u3} B (AddMonoid.toAddZeroClass.{u3} B (AddCommMonoid.toAddMonoid.{u3} B _inst_7)))))) (LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))))] {degb : A -> B}, (LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))) (degb (OfNat.ofNat.{u2} A 0 (OfNat.mk.{u2} A 0 (Zero.zero.{u2} A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A _inst_6))))))) (OfNat.ofNat.{u3} B 0 (OfNat.mk.{u3} B 0 (Zero.zero.{u3} B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B (AddCommMonoid.toAddMonoid.{u3} B _inst_7))))))) -> (forall (a : A) (b : A), LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))) (degb (HAdd.hAdd.{u2, u2, u2} A A A (instHAdd.{u2} A (AddZeroClass.toHasAdd.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A _inst_6)))) a b)) (HAdd.hAdd.{u3, u3, u3} B B B (instHAdd.{u3} B (AddZeroClass.toHasAdd.{u3} B (AddMonoid.toAddZeroClass.{u3} B (AddCommMonoid.toAddMonoid.{u3} B _inst_7)))) (degb a) (degb b))) -> (forall (s : Finset.{u4} ι) (f : ι -> (AddMonoidAlgebra.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_5))), LE.le.{u3} B (Preorder.toLE.{u3} B (PartialOrder.toPreorder.{u3} B (SemilatticeSup.toPartialOrder.{u3} B _inst_1))) (Finset.sup.{u3, u2} B A _inst_1 _inst_2 (Finsupp.support.{u2, u1} A R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_5))))) (Finset.prod.{max u2 u1, u4} (AddMonoidAlgebra.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_5)) ι (CommSemiring.toCommMonoid.{max u2 u1} (AddMonoidAlgebra.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_5)) (AddMonoidAlgebra.commSemiring.{u1, u2} R A _inst_5 _inst_6)) s (fun (i : ι) => f i))) degb) (Finset.sum.{u3, u4} B ι _inst_7 s (fun (i : ι) => Finset.sup.{u3, u2} B A _inst_1 _inst_2 (Finsupp.support.{u2, u1} A R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_5))))) (f i)) degb)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u3}} {B : Type.{u4}} {ι : Type.{u2}} [_inst_1 : SemilatticeSup.{u4} B] [_inst_2 : OrderBot.{u4} B (Preorder.toLE.{u4} B (PartialOrder.toPreorder.{u4} B (SemilatticeSup.toPartialOrder.{u4} B _inst_1)))] [_inst_5 : CommSemiring.{u1} R] [_inst_6 : AddCommMonoid.{u3} A] [_inst_7 : AddCommMonoid.{u4} B] [_inst_8 : CovariantClass.{u4, u4} B B (fun (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.3099 : B) (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.3101 : B) => HAdd.hAdd.{u4, u4, u4} B B B (instHAdd.{u4} B (AddZeroClass.toAdd.{u4} B (AddMonoid.toAddZeroClass.{u4} B (AddCommMonoid.toAddMonoid.{u4} B _inst_7)))) x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.3099 x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.3101) (fun (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.3114 : B) (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.3116 : B) => LE.le.{u4} B (Preorder.toLE.{u4} B (PartialOrder.toPreorder.{u4} B (SemilatticeSup.toPartialOrder.{u4} B _inst_1))) x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.3114 x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.3116)] [_inst_9 : CovariantClass.{u4, u4} B B (Function.swap.{succ u4, succ u4, succ u4} B B (fun (ᾰ : B) (ᾰ : B) => B) (fun (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.3136 : B) (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.3138 : B) => HAdd.hAdd.{u4, u4, u4} B B B (instHAdd.{u4} B (AddZeroClass.toAdd.{u4} B (AddMonoid.toAddZeroClass.{u4} B (AddCommMonoid.toAddMonoid.{u4} B _inst_7)))) x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.3136 x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.3138)) (fun (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.3151 : B) (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.3153 : B) => LE.le.{u4} B (Preorder.toLE.{u4} B (PartialOrder.toPreorder.{u4} B (SemilatticeSup.toPartialOrder.{u4} B _inst_1))) x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.3151 x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.3153)] {degb : A -> B}, (LE.le.{u4} B (Preorder.toLE.{u4} B (PartialOrder.toPreorder.{u4} B (SemilatticeSup.toPartialOrder.{u4} B _inst_1))) (degb (OfNat.ofNat.{u3} A 0 (Zero.toOfNat0.{u3} A (AddMonoid.toZero.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_6))))) (OfNat.ofNat.{u4} B 0 (Zero.toOfNat0.{u4} B (AddMonoid.toZero.{u4} B (AddCommMonoid.toAddMonoid.{u4} B _inst_7))))) -> (forall (a : A) (b : A), LE.le.{u4} B (Preorder.toLE.{u4} B (PartialOrder.toPreorder.{u4} B (SemilatticeSup.toPartialOrder.{u4} B _inst_1))) (degb (HAdd.hAdd.{u3, u3, u3} A A A (instHAdd.{u3} A (AddZeroClass.toAdd.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_6)))) a b)) (HAdd.hAdd.{u4, u4, u4} B B B (instHAdd.{u4} B (AddZeroClass.toAdd.{u4} B (AddMonoid.toAddZeroClass.{u4} B (AddCommMonoid.toAddMonoid.{u4} B _inst_7)))) (degb a) (degb b))) -> (forall (s : Finset.{u2} ι) (f : ι -> (AddMonoidAlgebra.{u1, u3} R A (CommSemiring.toSemiring.{u1} R _inst_5))), LE.le.{u4} B (Preorder.toLE.{u4} B (PartialOrder.toPreorder.{u4} B (SemilatticeSup.toPartialOrder.{u4} B _inst_1))) (Finset.sup.{u4, u3} B A _inst_1 _inst_2 (Finsupp.support.{u3, u1} A R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_5))) (Finset.prod.{max u1 u3, u2} (AddMonoidAlgebra.{u1, u3} R A (CommSemiring.toSemiring.{u1} R _inst_5)) ι (CommSemiring.toCommMonoid.{max u1 u3} (AddMonoidAlgebra.{u1, u3} R A (CommSemiring.toSemiring.{u1} R _inst_5)) (AddMonoidAlgebra.commSemiring.{u1, u3} R A _inst_5 _inst_6)) s (fun (i : ι) => f i))) degb) (Finset.sum.{u4, u2} B ι _inst_7 s (fun (i : ι) => Finset.sup.{u4, u3} B A _inst_1 _inst_2 (Finsupp.support.{u3, u1} A R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_5))) (f i)) degb)))
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.sup_support_finset_prod_le AddMonoidAlgebra.sup_support_finset_prod_leₓ'. -/
theorem sup_support_finset_prod_le (degb0 : degb 0 ≤ 0)
    (degbm : ∀ a b, degb (a + b) ≤ degb a + degb b) (s : Finset ι) (f : ι → AddMonoidAlgebra R A) :
    (∏ i in s, f i).support.sup degb ≤ ∑ i in s, (f i).support.sup degb :=
  (sup_support_multiset_prod_le degb0 degbm _).trans_eq <| congr_arg _ <| Multiset.map_map _ _ _
#align add_monoid_algebra.sup_support_finset_prod_le AddMonoidAlgebra.sup_support_finset_prod_le

/- warning: add_monoid_algebra.le_inf_support_finset_prod -> AddMonoidAlgebra.le_inf_support_finset_prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} {T : Type.{u3}} {ι : Type.{u4}} [_inst_3 : SemilatticeInf.{u3} T] [_inst_4 : OrderTop.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3)))] [_inst_5 : CommSemiring.{u1} R] [_inst_6 : AddCommMonoid.{u2} A] [_inst_10 : AddCommMonoid.{u3} T] [_inst_11 : CovariantClass.{u3, u3} T T (HAdd.hAdd.{u3, u3, u3} T T T (instHAdd.{u3} T (AddZeroClass.toHasAdd.{u3} T (AddMonoid.toAddZeroClass.{u3} T (AddCommMonoid.toAddMonoid.{u3} T _inst_10))))) (LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))))] [_inst_12 : CovariantClass.{u3, u3} T T (Function.swap.{succ u3, succ u3, succ u3} T T (fun (ᾰ : T) (ᾰ : T) => T) (HAdd.hAdd.{u3, u3, u3} T T T (instHAdd.{u3} T (AddZeroClass.toHasAdd.{u3} T (AddMonoid.toAddZeroClass.{u3} T (AddCommMonoid.toAddMonoid.{u3} T _inst_10)))))) (LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))))] {degt : A -> T}, (LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))) (OfNat.ofNat.{u3} T 0 (OfNat.mk.{u3} T 0 (Zero.zero.{u3} T (AddZeroClass.toHasZero.{u3} T (AddMonoid.toAddZeroClass.{u3} T (AddCommMonoid.toAddMonoid.{u3} T _inst_10)))))) (degt (OfNat.ofNat.{u2} A 0 (OfNat.mk.{u2} A 0 (Zero.zero.{u2} A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A _inst_6)))))))) -> (forall (a : A) (b : A), LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))) (HAdd.hAdd.{u3, u3, u3} T T T (instHAdd.{u3} T (AddZeroClass.toHasAdd.{u3} T (AddMonoid.toAddZeroClass.{u3} T (AddCommMonoid.toAddMonoid.{u3} T _inst_10)))) (degt a) (degt b)) (degt (HAdd.hAdd.{u2, u2, u2} A A A (instHAdd.{u2} A (AddZeroClass.toHasAdd.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A _inst_6)))) a b))) -> (forall (s : Finset.{u4} ι) (f : ι -> (AddMonoidAlgebra.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_5))), LE.le.{u3} T (Preorder.toLE.{u3} T (PartialOrder.toPreorder.{u3} T (SemilatticeInf.toPartialOrder.{u3} T _inst_3))) (Finset.sum.{u3, u4} T ι _inst_10 s (fun (i : ι) => Finset.inf.{u3, u2} T A _inst_3 _inst_4 (Finsupp.support.{u2, u1} A R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_5))))) (f i)) degt)) (Finset.inf.{u3, u2} T A _inst_3 _inst_4 (Finsupp.support.{u2, u1} A R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_5))))) (Finset.prod.{max u2 u1, u4} (AddMonoidAlgebra.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_5)) ι (CommSemiring.toCommMonoid.{max u2 u1} (AddMonoidAlgebra.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_5)) (AddMonoidAlgebra.commSemiring.{u1, u2} R A _inst_5 _inst_6)) s (fun (i : ι) => f i))) degt))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u3}} {T : Type.{u4}} {ι : Type.{u2}} [_inst_3 : SemilatticeInf.{u4} T] [_inst_4 : OrderTop.{u4} T (Preorder.toLE.{u4} T (PartialOrder.toPreorder.{u4} T (SemilatticeInf.toPartialOrder.{u4} T _inst_3)))] [_inst_5 : CommSemiring.{u1} R] [_inst_6 : AddCommMonoid.{u3} A] [_inst_10 : AddCommMonoid.{u4} T] [_inst_11 : CovariantClass.{u4, u4} T T (fun (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.3434 : T) (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.3436 : T) => HAdd.hAdd.{u4, u4, u4} T T T (instHAdd.{u4} T (AddZeroClass.toAdd.{u4} T (AddMonoid.toAddZeroClass.{u4} T (AddCommMonoid.toAddMonoid.{u4} T _inst_10)))) x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.3434 x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.3436) (fun (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.3449 : T) (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.3451 : T) => LE.le.{u4} T (Preorder.toLE.{u4} T (PartialOrder.toPreorder.{u4} T (SemilatticeInf.toPartialOrder.{u4} T _inst_3))) x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.3449 x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.3451)] [_inst_12 : CovariantClass.{u4, u4} T T (Function.swap.{succ u4, succ u4, succ u4} T T (fun (ᾰ : T) (ᾰ : T) => T) (fun (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.3471 : T) (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.3473 : T) => HAdd.hAdd.{u4, u4, u4} T T T (instHAdd.{u4} T (AddZeroClass.toAdd.{u4} T (AddMonoid.toAddZeroClass.{u4} T (AddCommMonoid.toAddMonoid.{u4} T _inst_10)))) x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.3471 x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.3473)) (fun (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.3486 : T) (x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.3488 : T) => LE.le.{u4} T (Preorder.toLE.{u4} T (PartialOrder.toPreorder.{u4} T (SemilatticeInf.toPartialOrder.{u4} T _inst_3))) x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.3486 x._@.Mathlib.Algebra.MonoidAlgebra.Degree._hyg.3488)] {degt : A -> T}, (LE.le.{u4} T (Preorder.toLE.{u4} T (PartialOrder.toPreorder.{u4} T (SemilatticeInf.toPartialOrder.{u4} T _inst_3))) (OfNat.ofNat.{u4} T 0 (Zero.toOfNat0.{u4} T (AddMonoid.toZero.{u4} T (AddCommMonoid.toAddMonoid.{u4} T _inst_10)))) (degt (OfNat.ofNat.{u3} A 0 (Zero.toOfNat0.{u3} A (AddMonoid.toZero.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_6)))))) -> (forall (a : A) (b : A), LE.le.{u4} T (Preorder.toLE.{u4} T (PartialOrder.toPreorder.{u4} T (SemilatticeInf.toPartialOrder.{u4} T _inst_3))) (HAdd.hAdd.{u4, u4, u4} T T T (instHAdd.{u4} T (AddZeroClass.toAdd.{u4} T (AddMonoid.toAddZeroClass.{u4} T (AddCommMonoid.toAddMonoid.{u4} T _inst_10)))) (degt a) (degt b)) (degt (HAdd.hAdd.{u3, u3, u3} A A A (instHAdd.{u3} A (AddZeroClass.toAdd.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_6)))) a b))) -> (forall (s : Finset.{u2} ι) (f : ι -> (AddMonoidAlgebra.{u1, u3} R A (CommSemiring.toSemiring.{u1} R _inst_5))), LE.le.{u4} T (Preorder.toLE.{u4} T (PartialOrder.toPreorder.{u4} T (SemilatticeInf.toPartialOrder.{u4} T _inst_3))) (Finset.sum.{u4, u2} T ι _inst_10 s (fun (i : ι) => Finset.inf.{u4, u3} T A _inst_3 _inst_4 (Finsupp.support.{u3, u1} A R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_5))) (f i)) degt)) (Finset.inf.{u4, u3} T A _inst_3 _inst_4 (Finsupp.support.{u3, u1} A R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_5))) (Finset.prod.{max u1 u3, u2} (AddMonoidAlgebra.{u1, u3} R A (CommSemiring.toSemiring.{u1} R _inst_5)) ι (CommSemiring.toCommMonoid.{max u1 u3} (AddMonoidAlgebra.{u1, u3} R A (CommSemiring.toSemiring.{u1} R _inst_5)) (AddMonoidAlgebra.commSemiring.{u1, u3} R A _inst_5 _inst_6)) s (fun (i : ι) => f i))) degt))
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.le_inf_support_finset_prod AddMonoidAlgebra.le_inf_support_finset_prodₓ'. -/
theorem le_inf_support_finset_prod (degt0 : 0 ≤ degt 0)
    (degtm : ∀ a b, degt a + degt b ≤ degt (a + b)) (s : Finset ι) (f : ι → AddMonoidAlgebra R A) :
    (∑ i in s, (f i).support.inf degt) ≤ (∏ i in s, f i).support.inf degt :=
  le_of_eq_of_le (by rw [Multiset.map_map] <;> rfl) (le_inf_support_multiset_prod degt0 degtm _)
#align add_monoid_algebra.le_inf_support_finset_prod AddMonoidAlgebra.le_inf_support_finset_prod

end CommutativeLemmas

end GeneralResultsAssumingSemilatticeSup

end AddMonoidAlgebra

