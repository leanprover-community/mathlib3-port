/-
Copyright (c) 2021 Eric Wieser. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Eric Wieser

! This file was ported from Lean 3 source module algebra.monoid_algebra.to_direct_sum
! leanprover-community/mathlib commit 1b0a28e1c93409dbf6d69526863cd9984ef652ce
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.DirectSum.Algebra
import Mathbin.Algebra.MonoidAlgebra.Basic
import Mathbin.Data.Finsupp.ToDfinsupp

/-!
# Conversion between `add_monoid_algebra` and homogenous `direct_sum`

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This module provides conversions between `add_monoid_algebra` and `direct_sum`.
The latter is essentially a dependent version of the former.

Note that since `direct_sum.has_mul` combines indices additively, there is no equivalent to
`monoid_algebra`.

## Main definitions

* `add_monoid_algebra.to_direct_sum : add_monoid_algebra M ι → (⨁ i : ι, M)`
* `direct_sum.to_add_monoid_algebra : (⨁ i : ι, M) → add_monoid_algebra M ι`
* Bundled equiv versions of the above:
  * `add_monoid_algebra_equiv_direct_sum : add_monoid_algebra M ι ≃ (⨁ i : ι, M)`
  * `add_monoid_algebra_add_equiv_direct_sum : add_monoid_algebra M ι ≃+ (⨁ i : ι, M)`
  * `add_monoid_algebra_ring_equiv_direct_sum R : add_monoid_algebra M ι ≃+* (⨁ i : ι, M)`
  * `add_monoid_algebra_alg_equiv_direct_sum R : add_monoid_algebra A ι ≃ₐ[R] (⨁ i : ι, A)`

## Theorems

The defining feature of these operations is that they map `finsupp.single` to
`direct_sum.of` and vice versa:

* `add_monoid_algebra.to_direct_sum_single`
* `direct_sum.to_add_monoid_algebra_of`

as well as preserving arithmetic operations.

For the bundled equivalences, we provide lemmas that they reduce to
`add_monoid_algebra.to_direct_sum`:

* `add_monoid_algebra_add_equiv_direct_sum_apply`
* `add_monoid_algebra_lequiv_direct_sum_apply`
* `add_monoid_algebra_add_equiv_direct_sum_symm_apply`
* `add_monoid_algebra_lequiv_direct_sum_symm_apply`

## Implementation notes

This file largely just copies the API of `data/finsupp/to_dfinsupp`, and reuses the proofs.
Recall that `add_monoid_algebra M ι` is defeq to `ι →₀ M` and `⨁ i : ι, M` is defeq to
`Π₀ i : ι, M`.

Note that there is no `add_monoid_algebra` equivalent to `finsupp.single`, so many statements
still involve this definition.
-/


variable {ι : Type _} {R : Type _} {M : Type _} {A : Type _}

open DirectSum

/-! ### Basic definitions and lemmas -/


section Defs

#print AddMonoidAlgebra.toDirectSum /-
/-- Interpret a `add_monoid_algebra` as a homogenous `direct_sum`. -/
def AddMonoidAlgebra.toDirectSum [Semiring M] (f : AddMonoidAlgebra M ι) : ⨁ i : ι, M :=
  Finsupp.toDfinsupp f
#align add_monoid_algebra.to_direct_sum AddMonoidAlgebra.toDirectSum
-/

section

variable [DecidableEq ι] [Semiring M]

/- warning: add_monoid_algebra.to_direct_sum_single -> AddMonoidAlgebra.toDirectSum_single is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.to_direct_sum_single AddMonoidAlgebra.toDirectSum_singleₓ'. -/
@[simp]
theorem AddMonoidAlgebra.toDirectSum_single (i : ι) (m : M) :
    AddMonoidAlgebra.toDirectSum (Finsupp.single i m) = DirectSum.of _ i m :=
  Finsupp.toDfinsupp_single i m
#align add_monoid_algebra.to_direct_sum_single AddMonoidAlgebra.toDirectSum_single

variable [∀ m : M, Decidable (m ≠ 0)]

/- warning: direct_sum.to_add_monoid_algebra -> DirectSum.toAddMonoidAlgebra is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : Semiring.{u2} M] [_inst_3 : forall (m : M), Decidable (Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (MulZeroClass.toHasZero.{u2} M (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_2))))))))], (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_2)))) -> (AddMonoidAlgebra.{u2, u1} M ι _inst_2)
but is expected to have type
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : Semiring.{u2} M] [_inst_3 : forall (m : M), Decidable (Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (MonoidWithZero.toZero.{u2} M (Semiring.toMonoidWithZero.{u2} M _inst_2)))))], (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_2)))) -> (AddMonoidAlgebra.{u2, u1} M ι _inst_2)
Case conversion may be inaccurate. Consider using '#align direct_sum.to_add_monoid_algebra DirectSum.toAddMonoidAlgebraₓ'. -/
/-- Interpret a homogenous `direct_sum` as a `add_monoid_algebra`. -/
def DirectSum.toAddMonoidAlgebra (f : ⨁ i : ι, M) : AddMonoidAlgebra M ι :=
  Dfinsupp.toFinsupp f
#align direct_sum.to_add_monoid_algebra DirectSum.toAddMonoidAlgebra

/- warning: direct_sum.to_add_monoid_algebra_of -> DirectSum.toAddMonoidAlgebra_of is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align direct_sum.to_add_monoid_algebra_of DirectSum.toAddMonoidAlgebra_ofₓ'. -/
@[simp]
theorem DirectSum.toAddMonoidAlgebra_of (i : ι) (m : M) :
    (DirectSum.of _ i m : ⨁ i : ι, M).toAddMonoidAlgebra = Finsupp.single i m :=
  Dfinsupp.toFinsupp_single i m
#align direct_sum.to_add_monoid_algebra_of DirectSum.toAddMonoidAlgebra_of

/- warning: add_monoid_algebra.to_direct_sum_to_add_monoid_algebra -> AddMonoidAlgebra.toDirectSum_toAddMonoidAlgebra is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : Semiring.{u2} M] [_inst_3 : forall (m : M), Decidable (Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (MulZeroClass.toHasZero.{u2} M (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_2))))))))] (f : AddMonoidAlgebra.{u2, u1} M ι _inst_2), Eq.{max (succ u1) (succ u2)} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (DirectSum.toAddMonoidAlgebra.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 (fun (m : M) => _inst_3 m) (AddMonoidAlgebra.toDirectSum.{u1, u2} ι M _inst_2 f)) f
but is expected to have type
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : Semiring.{u2} M] [_inst_3 : forall (m : M), Decidable (Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (MonoidWithZero.toZero.{u2} M (Semiring.toMonoidWithZero.{u2} M _inst_2)))))] (f : AddMonoidAlgebra.{u2, u1} M ι _inst_2), Eq.{max (succ u1) (succ u2)} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (DirectSum.toAddMonoidAlgebra.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 (fun (m : M) => _inst_3 m) (AddMonoidAlgebra.toDirectSum.{u1, u2} ι M _inst_2 f)) f
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.to_direct_sum_to_add_monoid_algebra AddMonoidAlgebra.toDirectSum_toAddMonoidAlgebraₓ'. -/
@[simp]
theorem AddMonoidAlgebra.toDirectSum_toAddMonoidAlgebra (f : AddMonoidAlgebra M ι) :
    f.toDirectSum.toAddMonoidAlgebra = f :=
  Finsupp.toDfinsupp_toFinsupp f
#align add_monoid_algebra.to_direct_sum_to_add_monoid_algebra AddMonoidAlgebra.toDirectSum_toAddMonoidAlgebra

/- warning: direct_sum.to_add_monoid_algebra_to_direct_sum -> DirectSum.toAddMonoidAlgebra_toDirectSum is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : Semiring.{u2} M] [_inst_3 : forall (m : M), Decidable (Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (MulZeroClass.toHasZero.{u2} M (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_2))))))))] (f : DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_2)))), Eq.{succ (max u1 u2)} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_2)))) (AddMonoidAlgebra.toDirectSum.{u1, u2} ι M _inst_2 (DirectSum.toAddMonoidAlgebra.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 (fun (m : M) => _inst_3 m) f)) f
but is expected to have type
  forall {ι : Type.{u2}} {M : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} ι] [_inst_2 : Semiring.{u1} M] [_inst_3 : forall (m : M), Decidable (Ne.{succ u1} M m (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (MonoidWithZero.toZero.{u1} M (Semiring.toMonoidWithZero.{u1} M _inst_2)))))] (f : DirectSum.{u2, u1} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u1} ((fun (i : ι) => M) i) _inst_2)))), Eq.{max (succ u2) (succ u1)} (DirectSum.{u2, u1} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u1} ((fun (_i : ι) => M) i) _inst_2)))) (AddMonoidAlgebra.toDirectSum.{u2, u1} ι M _inst_2 (DirectSum.toAddMonoidAlgebra.{u2, u1} ι M (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 (fun (m : M) => _inst_3 m) f)) f
Case conversion may be inaccurate. Consider using '#align direct_sum.to_add_monoid_algebra_to_direct_sum DirectSum.toAddMonoidAlgebra_toDirectSumₓ'. -/
@[simp]
theorem DirectSum.toAddMonoidAlgebra_toDirectSum (f : ⨁ i : ι, M) :
    f.toAddMonoidAlgebra.toDirectSum = f :=
  Dfinsupp.toFinsupp_toDfinsupp f
#align direct_sum.to_add_monoid_algebra_to_direct_sum DirectSum.toAddMonoidAlgebra_toDirectSum

end

end Defs

/-! ### Lemmas about arithmetic operations -/


section Lemmas

namespace AddMonoidAlgebra

/- warning: add_monoid_algebra.to_direct_sum_zero -> AddMonoidAlgebra.toDirectSum_zero is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u2} M], Eq.{succ (max u1 u2)} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_1)))) (AddMonoidAlgebra.toDirectSum.{u1, u2} ι M _inst_1 (OfNat.ofNat.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_1) 0 (OfNat.mk.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_1) 0 (Zero.zero.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_1) (AddZeroClass.toHasZero.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_1) (AddMonoid.toAddZeroClass.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_1) (AddCommMonoid.toAddMonoid.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_1) (AddMonoidAlgebra.addCommMonoid.{u1, u2} M ι _inst_1)))))))) (OfNat.ofNat.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_1)))) 0 (OfNat.mk.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_1)))) 0 (Zero.zero.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_1)))) (AddZeroClass.toHasZero.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_1)))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_1)))) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_1)))) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_1))))))))))
but is expected to have type
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u2} M], Eq.{max (succ u1) (succ u2)} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) _inst_1)))) (AddMonoidAlgebra.toDirectSum.{u1, u2} ι M _inst_1 (OfNat.ofNat.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_1) 0 (Zero.toOfNat0.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_1) (AddMonoid.toZero.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_1) (AddCommMonoid.toAddMonoid.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_1) (AddMonoidAlgebra.addCommMonoid.{u2, u1} M ι _inst_1)))))) (OfNat.ofNat.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) _inst_1)))) 0 (Zero.toOfNat0.{max u1 u2} (DirectSum.{u1, u2} ι (fun (_i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) _inst_1)))) (AddMonoid.toZero.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) _inst_1)))) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) _inst_1)))) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (_i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.to_direct_sum_zero AddMonoidAlgebra.toDirectSum_zeroₓ'. -/
@[simp]
theorem toDirectSum_zero [Semiring M] : (0 : AddMonoidAlgebra M ι).toDirectSum = 0 :=
  Finsupp.toDfinsupp_zero
#align add_monoid_algebra.to_direct_sum_zero AddMonoidAlgebra.toDirectSum_zero

/- warning: add_monoid_algebra.to_direct_sum_add -> AddMonoidAlgebra.toDirectSum_add is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u2} M] (f : AddMonoidAlgebra.{u2, u1} M ι _inst_1) (g : AddMonoidAlgebra.{u2, u1} M ι _inst_1), Eq.{succ (max u1 u2)} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_1)))) (AddMonoidAlgebra.toDirectSum.{u1, u2} ι M _inst_1 (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_1) (AddMonoidAlgebra.{u2, u1} M ι _inst_1) (AddMonoidAlgebra.{u2, u1} M ι _inst_1) (instHAdd.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_1) (AddZeroClass.toHasAdd.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_1) (AddMonoid.toAddZeroClass.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_1) (AddCommMonoid.toAddMonoid.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_1) (AddMonoidAlgebra.addCommMonoid.{u1, u2} M ι _inst_1))))) f g)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_1)))) (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_1)))) (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_1)))) (instHAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_1)))) (AddZeroClass.toHasAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_1)))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_1)))) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_1)))) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_1)))))))) (AddMonoidAlgebra.toDirectSum.{u1, u2} ι M _inst_1 f) (AddMonoidAlgebra.toDirectSum.{u1, u2} ι M _inst_1 g))
but is expected to have type
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u2} M] (f : AddMonoidAlgebra.{u2, u1} M ι _inst_1) (g : AddMonoidAlgebra.{u2, u1} M ι _inst_1), Eq.{max (succ u1) (succ u2)} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) _inst_1)))) (AddMonoidAlgebra.toDirectSum.{u1, u2} ι M _inst_1 (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_1) (AddMonoidAlgebra.{u2, u1} M ι _inst_1) (AddMonoidAlgebra.{u2, u1} M ι _inst_1) (instHAdd.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_1) (AddZeroClass.toAdd.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_1) (AddMonoid.toAddZeroClass.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_1) (AddCommMonoid.toAddMonoid.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_1) (AddMonoidAlgebra.addCommMonoid.{u2, u1} M ι _inst_1))))) f g)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) _inst_1)))) (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) _inst_1)))) (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) _inst_1)))) (instHAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) _inst_1)))) (AddZeroClass.toAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) _inst_1)))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) _inst_1)))) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) _inst_1)))) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) _inst_1)))))))) (AddMonoidAlgebra.toDirectSum.{u1, u2} ι M _inst_1 f) (AddMonoidAlgebra.toDirectSum.{u1, u2} ι M _inst_1 g))
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.to_direct_sum_add AddMonoidAlgebra.toDirectSum_addₓ'. -/
@[simp]
theorem toDirectSum_add [Semiring M] (f g : AddMonoidAlgebra M ι) :
    (f + g).toDirectSum = f.toDirectSum + g.toDirectSum :=
  Finsupp.toDfinsupp_add _ _
#align add_monoid_algebra.to_direct_sum_add AddMonoidAlgebra.toDirectSum_add

/- warning: add_monoid_algebra.to_direct_sum_mul -> AddMonoidAlgebra.toDirectSum_mul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddMonoid.{u1} ι] [_inst_3 : Semiring.{u2} M] (f : AddMonoidAlgebra.{u2, u1} M ι _inst_3) (g : AddMonoidAlgebra.{u2, u1} M ι _inst_3), Eq.{succ (max u1 u2)} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_3)))) (AddMonoidAlgebra.toDirectSum.{u1, u2} ι M _inst_3 (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_3) (AddMonoidAlgebra.{u2, u1} M ι _inst_3) (AddMonoidAlgebra.{u2, u1} M ι _inst_3) (instHMul.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_3) (AddMonoidAlgebra.hasMul.{u2, u1} M ι _inst_3 (AddZeroClass.toHasAdd.{u1} ι (AddMonoid.toAddZeroClass.{u1} ι _inst_2)))) f g)) (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_3)))) (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_3)))) (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_3)))) (instHMul.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_3)))) (Distrib.toHasMul.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_3)))) (NonUnitalNonAssocSemiring.toDistrib.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_3)))) (DirectSum.nonUnitalNonAssocSemiring.{u1, u2} ι (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => M) (AddZeroClass.toHasAdd.{u1} ι (AddMonoid.toAddZeroClass.{u1} ι _inst_2)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_3))) (NonUnitalNonAssocSemiring.directSumGNonUnitalNonAssocSemiring.{u1, u2} ι (fun (a : ι) (b : ι) => _inst_1 a b) M _inst_2 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_3))))))) (AddMonoidAlgebra.toDirectSum.{u1, u2} ι M _inst_3 f) (AddMonoidAlgebra.toDirectSum.{u1, u2} ι M _inst_3 g))
but is expected to have type
  forall {ι : Type.{u2}} {M : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} ι] [_inst_2 : AddMonoid.{u2} ι] [_inst_3 : Semiring.{u1} M] (f : AddMonoidAlgebra.{u1, u2} M ι _inst_3) (g : AddMonoidAlgebra.{u1, u2} M ι _inst_3), Eq.{max (succ u2) (succ u1)} (DirectSum.{u2, u1} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u1} ((fun (_i : ι) => M) i) _inst_3)))) (AddMonoidAlgebra.toDirectSum.{u2, u1} ι M _inst_3 (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (AddMonoidAlgebra.{u1, u2} M ι _inst_3) (AddMonoidAlgebra.{u1, u2} M ι _inst_3) (AddMonoidAlgebra.{u1, u2} M ι _inst_3) (instHMul.{max u2 u1} (AddMonoidAlgebra.{u1, u2} M ι _inst_3) (AddMonoidAlgebra.hasMul.{u1, u2} M ι _inst_3 (AddZeroClass.toAdd.{u2} ι (AddMonoid.toAddZeroClass.{u2} ι _inst_2)))) f g)) (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (DirectSum.{u2, u1} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u1} ((fun (_i : ι) => M) i) _inst_3)))) (DirectSum.{u2, u1} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u1} ((fun (_i : ι) => M) i) _inst_3)))) (DirectSum.{u2, u1} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u1} ((fun (_i : ι) => M) i) _inst_3)))) (instHMul.{max u2 u1} (DirectSum.{u2, u1} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u1} ((fun (_i : ι) => M) i) _inst_3)))) (NonUnitalNonAssocSemiring.toMul.{max u2 u1} (DirectSum.{u2, u1} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u1} ((fun (_i : ι) => M) i) _inst_3)))) (DirectSum.instNonUnitalNonAssocSemiringDirectSum.{u2, u1} ι (fun (a : ι) (b : ι) => _inst_1 a b) (fun (_i : ι) => M) (AddZeroClass.toAdd.{u2} ι (AddMonoid.toAddZeroClass.{u2} ι _inst_2)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u1} ((fun (_i : ι) => M) i) _inst_3))) (NonUnitalNonAssocSemiring.directSumGNonUnitalNonAssocSemiring.{u2, u1} ι M _inst_2 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} M (Semiring.toNonAssocSemiring.{u1} M _inst_3)))))) (AddMonoidAlgebra.toDirectSum.{u2, u1} ι M _inst_3 f) (AddMonoidAlgebra.toDirectSum.{u2, u1} ι M _inst_3 g))
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.to_direct_sum_mul AddMonoidAlgebra.toDirectSum_mulₓ'. -/
@[simp]
theorem toDirectSum_mul [DecidableEq ι] [AddMonoid ι] [Semiring M] (f g : AddMonoidAlgebra M ι) :
    (f * g).toDirectSum = f.toDirectSum * g.toDirectSum :=
  by
  let to_hom : AddMonoidAlgebra M ι →+ ⨁ i : ι, M :=
    ⟨to_direct_sum, to_direct_sum_zero, to_direct_sum_add⟩
  show to_hom (f * g) = to_hom f * to_hom g
  revert f g
  rw [AddMonoidHom.map_mul_iff]
  ext (xi xv yi yv) : 4
  dsimp only [AddMonoidHom.comp_apply, AddMonoidHom.compl₂_apply, AddMonoidHom.compr₂_apply,
    AddMonoidHom.mul_apply, AddEquiv.coe_toAddMonoidHom, Finsupp.singleAddHom_apply]
  simp only [AddMonoidAlgebra.single_mul_single, to_hom, AddMonoidHom.coe_mk,
    AddMonoidAlgebra.toDirectSum_single, DirectSum.of_mul_of, Mul.gMul_mul]
#align add_monoid_algebra.to_direct_sum_mul AddMonoidAlgebra.toDirectSum_mul

end AddMonoidAlgebra

namespace DirectSum

variable [DecidableEq ι]

/- warning: direct_sum.to_add_monoid_algebra_zero -> DirectSum.toAddMonoidAlgebra_zero is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : Semiring.{u2} M] [_inst_3 : forall (m : M), Decidable (Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (MulZeroClass.toHasZero.{u2} M (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_2))))))))], Eq.{max (succ u1) (succ u2)} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (DirectSum.toAddMonoidAlgebra.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 (fun (m : M) => _inst_3 m) (OfNat.ofNat.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_2)))) 0 (OfNat.mk.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_2)))) 0 (Zero.zero.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_2)))) (AddZeroClass.toHasZero.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_2)))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_2)))) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_2)))) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_2))))))))))) (OfNat.ofNat.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) 0 (OfNat.mk.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) 0 (Zero.zero.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (AddZeroClass.toHasZero.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (AddMonoid.toAddZeroClass.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (AddCommMonoid.toAddMonoid.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (AddMonoidAlgebra.addCommMonoid.{u1, u2} M ι _inst_2)))))))
but is expected to have type
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : Semiring.{u2} M] [_inst_3 : forall (m : M), Decidable (Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (MonoidWithZero.toZero.{u2} M (Semiring.toMonoidWithZero.{u2} M _inst_2)))))], Eq.{max (succ u1) (succ u2)} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (DirectSum.toAddMonoidAlgebra.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 (fun (m : M) => _inst_3 m) (OfNat.ofNat.{max u2 u1} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_2)))) 0 (Zero.toOfNat0.{max u1 u2} (DirectSum.{u1, u2} ι (fun (_i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) _inst_2)))) (AddMonoid.toZero.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_2)))) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_2)))) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (_i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) _inst_2))))))))) (OfNat.ofNat.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) 0 (Zero.toOfNat0.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (AddMonoid.toZero.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (AddCommMonoid.toAddMonoid.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (AddMonoidAlgebra.addCommMonoid.{u2, u1} M ι _inst_2)))))
Case conversion may be inaccurate. Consider using '#align direct_sum.to_add_monoid_algebra_zero DirectSum.toAddMonoidAlgebra_zeroₓ'. -/
@[simp]
theorem toAddMonoidAlgebra_zero [Semiring M] [∀ m : M, Decidable (m ≠ 0)] :
    toAddMonoidAlgebra 0 = (0 : AddMonoidAlgebra M ι) :=
  Dfinsupp.toFinsupp_zero
#align direct_sum.to_add_monoid_algebra_zero DirectSum.toAddMonoidAlgebra_zero

/- warning: direct_sum.to_add_monoid_algebra_add -> DirectSum.toAddMonoidAlgebra_add is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : Semiring.{u2} M] [_inst_3 : forall (m : M), Decidable (Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (MulZeroClass.toHasZero.{u2} M (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_2))))))))] (f : DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_2)))) (g : DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_2)))), Eq.{max (succ u1) (succ u2)} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (DirectSum.toAddMonoidAlgebra.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 (fun (m : M) => _inst_3 m) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_2)))) (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_2)))) (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_2)))) (instHAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_2)))) (AddZeroClass.toHasAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_2)))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_2)))) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_2)))) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_2)))))))) f g)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (instHAdd.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (AddZeroClass.toHasAdd.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (AddMonoid.toAddZeroClass.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (AddCommMonoid.toAddMonoid.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (AddMonoidAlgebra.addCommMonoid.{u1, u2} M ι _inst_2))))) (DirectSum.toAddMonoidAlgebra.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 (fun (m : M) => _inst_3 m) f) (DirectSum.toAddMonoidAlgebra.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 (fun (m : M) => _inst_3 m) g))
but is expected to have type
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : Semiring.{u2} M] [_inst_3 : forall (m : M), Decidable (Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (MonoidWithZero.toZero.{u2} M (Semiring.toMonoidWithZero.{u2} M _inst_2)))))] (f : DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_2)))) (g : DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_2)))), Eq.{max (succ u1) (succ u2)} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (DirectSum.toAddMonoidAlgebra.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 (fun (m : M) => _inst_3 m) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_2)))) (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_2)))) (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_2)))) (instHAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_2)))) (AddZeroClass.toAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_2)))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_2)))) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_2)))) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_2)))))))) f g)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (instHAdd.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (AddZeroClass.toAdd.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (AddMonoid.toAddZeroClass.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (AddCommMonoid.toAddMonoid.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (AddMonoidAlgebra.addCommMonoid.{u2, u1} M ι _inst_2))))) (DirectSum.toAddMonoidAlgebra.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 (fun (m : M) => _inst_3 m) f) (DirectSum.toAddMonoidAlgebra.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 (fun (m : M) => _inst_3 m) g))
Case conversion may be inaccurate. Consider using '#align direct_sum.to_add_monoid_algebra_add DirectSum.toAddMonoidAlgebra_addₓ'. -/
@[simp]
theorem toAddMonoidAlgebra_add [Semiring M] [∀ m : M, Decidable (m ≠ 0)] (f g : ⨁ i : ι, M) :
    (f + g).toAddMonoidAlgebra = toAddMonoidAlgebra f + toAddMonoidAlgebra g :=
  Dfinsupp.toFinsupp_add _ _
#align direct_sum.to_add_monoid_algebra_add DirectSum.toAddMonoidAlgebra_add

/- warning: direct_sum.to_add_monoid_algebra_mul -> DirectSum.toAddMonoidAlgebra_mul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddMonoid.{u1} ι] [_inst_3 : Semiring.{u2} M] [_inst_4 : forall (m : M), Decidable (Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (MulZeroClass.toHasZero.{u2} M (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_3))))))))] (f : DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_3)))) (g : DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_3)))), Eq.{max (succ u1) (succ u2)} (AddMonoidAlgebra.{u2, u1} M ι _inst_3) (DirectSum.toAddMonoidAlgebra.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) _inst_3 (fun (m : M) => _inst_4 m) (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_3)))) (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_3)))) (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_3)))) (instHMul.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_3)))) (Distrib.toHasMul.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_3)))) (NonUnitalNonAssocSemiring.toDistrib.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_3)))) (DirectSum.nonUnitalNonAssocSemiring.{u1, u2} ι (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => M) (AddZeroClass.toHasAdd.{u1} ι (AddMonoid.toAddZeroClass.{u1} ι _inst_2)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => M) i) _inst_3))) (NonUnitalNonAssocSemiring.directSumGNonUnitalNonAssocSemiring.{u1, u2} ι (fun (a : ι) (b : ι) => _inst_1 a b) M _inst_2 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_3))))))) f g)) (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_3) (AddMonoidAlgebra.{u2, u1} M ι _inst_3) (AddMonoidAlgebra.{u2, u1} M ι _inst_3) (instHMul.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_3) (AddMonoidAlgebra.hasMul.{u2, u1} M ι _inst_3 (AddZeroClass.toHasAdd.{u1} ι (AddMonoid.toAddZeroClass.{u1} ι _inst_2)))) (DirectSum.toAddMonoidAlgebra.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) _inst_3 (fun (m : M) => _inst_4 m) f) (DirectSum.toAddMonoidAlgebra.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) _inst_3 (fun (m : M) => _inst_4 m) g))
but is expected to have type
  forall {ι : Type.{u2}} {M : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} ι] [_inst_2 : AddMonoid.{u2} ι] [_inst_3 : Semiring.{u1} M] [_inst_4 : forall (m : M), Decidable (Ne.{succ u1} M m (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (MonoidWithZero.toZero.{u1} M (Semiring.toMonoidWithZero.{u1} M _inst_3)))))] (f : DirectSum.{u2, u1} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u1} ((fun (i : ι) => M) i) _inst_3)))) (g : DirectSum.{u2, u1} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u1} ((fun (i : ι) => M) i) _inst_3)))), Eq.{max (succ u2) (succ u1)} (AddMonoidAlgebra.{u1, u2} M ι _inst_3) (DirectSum.toAddMonoidAlgebra.{u2, u1} ι M (fun (a : ι) (b : ι) => _inst_1 a b) _inst_3 (fun (m : M) => _inst_4 m) (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (DirectSum.{u2, u1} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u1} ((fun (i : ι) => M) i) _inst_3)))) (DirectSum.{u2, u1} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u1} ((fun (i : ι) => M) i) _inst_3)))) (DirectSum.{u2, u1} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u1} ((fun (i : ι) => M) i) _inst_3)))) (instHMul.{max u2 u1} (DirectSum.{u2, u1} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u1} ((fun (i : ι) => M) i) _inst_3)))) (NonUnitalNonAssocSemiring.toMul.{max u2 u1} (DirectSum.{u2, u1} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (i : ι) => M) i) (Semiring.toNonAssocSemiring.{u1} ((fun (i : ι) => M) i) _inst_3)))) (DirectSum.instNonUnitalNonAssocSemiringDirectSum.{u2, u1} ι (fun (a : ι) (b : ι) => _inst_1 a b) (fun (_i : ι) => M) (AddZeroClass.toAdd.{u2} ι (AddMonoid.toAddZeroClass.{u2} ι _inst_2)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u1} ((fun (_i : ι) => M) i) _inst_3))) (NonUnitalNonAssocSemiring.directSumGNonUnitalNonAssocSemiring.{u2, u1} ι M _inst_2 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} M (Semiring.toNonAssocSemiring.{u1} M _inst_3)))))) f g)) (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (AddMonoidAlgebra.{u1, u2} M ι _inst_3) (AddMonoidAlgebra.{u1, u2} M ι _inst_3) (AddMonoidAlgebra.{u1, u2} M ι _inst_3) (instHMul.{max u2 u1} (AddMonoidAlgebra.{u1, u2} M ι _inst_3) (AddMonoidAlgebra.hasMul.{u1, u2} M ι _inst_3 (AddZeroClass.toAdd.{u2} ι (AddMonoid.toAddZeroClass.{u2} ι _inst_2)))) (DirectSum.toAddMonoidAlgebra.{u2, u1} ι M (fun (a : ι) (b : ι) => _inst_1 a b) _inst_3 (fun (m : M) => _inst_4 m) f) (DirectSum.toAddMonoidAlgebra.{u2, u1} ι M (fun (a : ι) (b : ι) => _inst_1 a b) _inst_3 (fun (m : M) => _inst_4 m) g))
Case conversion may be inaccurate. Consider using '#align direct_sum.to_add_monoid_algebra_mul DirectSum.toAddMonoidAlgebra_mulₓ'. -/
@[simp]
theorem toAddMonoidAlgebra_mul [AddMonoid ι] [Semiring M] [∀ m : M, Decidable (m ≠ 0)]
    (f g : ⨁ i : ι, M) : (f * g).toAddMonoidAlgebra = toAddMonoidAlgebra f * toAddMonoidAlgebra g :=
  by
  apply_fun AddMonoidAlgebra.toDirectSum
  · simp
  · apply Function.LeftInverse.injective
    apply AddMonoidAlgebra.toDirectSum_toAddMonoidAlgebra
#align direct_sum.to_add_monoid_algebra_mul DirectSum.toAddMonoidAlgebra_mul

end DirectSum

end Lemmas

/-! ### Bundled `equiv`s -/


section Equivs

/- warning: add_monoid_algebra_equiv_direct_sum -> addMonoidAlgebraEquivDirectSum is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : Semiring.{u2} M] [_inst_3 : forall (m : M), Decidable (Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (MulZeroClass.toHasZero.{u2} M (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_2))))))))], Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_2))))
but is expected to have type
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : Semiring.{u2} M] [_inst_3 : forall (m : M), Decidable (Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (MonoidWithZero.toZero.{u2} M (Semiring.toMonoidWithZero.{u2} M _inst_2)))))], Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) _inst_2))))
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra_equiv_direct_sum addMonoidAlgebraEquivDirectSumₓ'. -/
/-- `add_monoid_algebra.to_direct_sum` and `direct_sum.to_add_monoid_algebra` together form an
equiv. -/
@[simps (config := { fullyApplied := false })]
def addMonoidAlgebraEquivDirectSum [DecidableEq ι] [Semiring M] [∀ m : M, Decidable (m ≠ 0)] :
    AddMonoidAlgebra M ι ≃ ⨁ i : ι, M :=
  { finsuppEquivDfinsupp with
    toFun := AddMonoidAlgebra.toDirectSum
    invFun := DirectSum.toAddMonoidAlgebra }
#align add_monoid_algebra_equiv_direct_sum addMonoidAlgebraEquivDirectSum

/- warning: add_monoid_algebra_add_equiv_direct_sum -> addMonoidAlgebraAddEquivDirectSum is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : Semiring.{u2} M] [_inst_3 : forall (m : M), Decidable (Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (MulZeroClass.toHasZero.{u2} M (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_2))))))))], AddEquiv.{max u1 u2, max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_2)))) (AddZeroClass.toHasAdd.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (AddMonoid.toAddZeroClass.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (AddCommMonoid.toAddMonoid.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (AddMonoidAlgebra.addCommMonoid.{u1, u2} M ι _inst_2)))) (AddZeroClass.toHasAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_2)))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_2)))) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_2)))) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_2)))))))
but is expected to have type
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : Semiring.{u2} M] [_inst_3 : forall (m : M), Decidable (Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (MonoidWithZero.toZero.{u2} M (Semiring.toMonoidWithZero.{u2} M _inst_2)))))], AddEquiv.{max u1 u2, max u2 u1} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) _inst_2)))) (AddZeroClass.toAdd.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (AddMonoid.toAddZeroClass.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (AddCommMonoid.toAddMonoid.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_2) (AddMonoidAlgebra.addCommMonoid.{u2, u1} M ι _inst_2)))) (AddZeroClass.toAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) _inst_2)))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) _inst_2)))) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) _inst_2)))) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) _inst_2)))))))
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra_add_equiv_direct_sum addMonoidAlgebraAddEquivDirectSumₓ'. -/
/-- The additive version of `add_monoid_algebra.to_add_monoid_algebra`. Note that this is
`noncomputable` because `add_monoid_algebra.has_add` is noncomputable. -/
@[simps (config := { fullyApplied := false })]
def addMonoidAlgebraAddEquivDirectSum [DecidableEq ι] [Semiring M] [∀ m : M, Decidable (m ≠ 0)] :
    AddMonoidAlgebra M ι ≃+ ⨁ i : ι, M :=
  {
    addMonoidAlgebraEquivDirectSum with
    toFun := AddMonoidAlgebra.toDirectSum
    invFun := DirectSum.toAddMonoidAlgebra
    map_add' := AddMonoidAlgebra.toDirectSum_add }
#align add_monoid_algebra_add_equiv_direct_sum addMonoidAlgebraAddEquivDirectSum

/- warning: add_monoid_algebra_ring_equiv_direct_sum -> addMonoidAlgebraRingEquivDirectSum is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddMonoid.{u1} ι] [_inst_3 : Semiring.{u2} M] [_inst_4 : forall (m : M), Decidable (Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (MulZeroClass.toHasZero.{u2} M (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_3))))))))], RingEquiv.{max u1 u2, max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_3) (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_3)))) (AddMonoidAlgebra.hasMul.{u2, u1} M ι _inst_3 (AddZeroClass.toHasAdd.{u1} ι (AddMonoid.toAddZeroClass.{u1} ι _inst_2))) (Distrib.toHasAdd.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_3) (NonUnitalNonAssocSemiring.toDistrib.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_3) (AddMonoidAlgebra.nonUnitalNonAssocSemiring.{u2, u1} M ι _inst_3 (AddZeroClass.toHasAdd.{u1} ι (AddMonoid.toAddZeroClass.{u1} ι _inst_2))))) (Distrib.toHasMul.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_3)))) (NonUnitalNonAssocSemiring.toDistrib.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_3)))) (DirectSum.nonUnitalNonAssocSemiring.{u1, u2} ι (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => M) (AddZeroClass.toHasAdd.{u1} ι (AddMonoid.toAddZeroClass.{u1} ι _inst_2)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_3))) (NonUnitalNonAssocSemiring.directSumGNonUnitalNonAssocSemiring.{u1, u2} ι (fun (a : ι) (b : ι) => _inst_1 a b) M _inst_2 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_3)))))) (Distrib.toHasAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_3)))) (NonUnitalNonAssocSemiring.toDistrib.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_3)))) (DirectSum.nonUnitalNonAssocSemiring.{u1, u2} ι (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => M) (AddZeroClass.toHasAdd.{u1} ι (AddMonoid.toAddZeroClass.{u1} ι _inst_2)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} M (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_3))) (NonUnitalNonAssocSemiring.directSumGNonUnitalNonAssocSemiring.{u1, u2} ι (fun (a : ι) (b : ι) => _inst_1 a b) M _inst_2 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_3))))))
but is expected to have type
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddMonoid.{u1} ι] [_inst_3 : Semiring.{u2} M] [_inst_4 : forall (m : M), Decidable (Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (MonoidWithZero.toZero.{u2} M (Semiring.toMonoidWithZero.{u2} M _inst_3)))))], RingEquiv.{max u1 u2, max u2 u1} (AddMonoidAlgebra.{u2, u1} M ι _inst_3) (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) _inst_3)))) (AddMonoidAlgebra.hasMul.{u2, u1} M ι _inst_3 (AddZeroClass.toAdd.{u1} ι (AddMonoid.toAddZeroClass.{u1} ι _inst_2))) (NonUnitalNonAssocSemiring.toMul.{max u1 u2} (DirectSum.{u1, u2} ι (fun (_i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) _inst_3)))) (DirectSum.instNonUnitalNonAssocSemiringDirectSum.{u1, u2} ι (fun (a : ι) (b : ι) => _inst_1 a b) (fun (_i : ι) => M) (AddZeroClass.toAdd.{u1} ι (AddMonoid.toAddZeroClass.{u1} ι _inst_2)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) _inst_3))) (NonUnitalNonAssocSemiring.directSumGNonUnitalNonAssocSemiring.{u1, u2} ι M _inst_2 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_3))))) (Distrib.toAdd.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_3) (NonUnitalNonAssocSemiring.toDistrib.{max u1 u2} (AddMonoidAlgebra.{u2, u1} M ι _inst_3) (AddMonoidAlgebra.nonUnitalNonAssocSemiring.{u2, u1} M ι _inst_3 (AddZeroClass.toAdd.{u1} ι (AddMonoid.toAddZeroClass.{u1} ι _inst_2))))) (Distrib.toAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) _inst_3)))) (NonUnitalNonAssocSemiring.toDistrib.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) _inst_3)))) (DirectSum.instNonUnitalNonAssocSemiringDirectSum.{u1, u2} ι (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => M) (AddZeroClass.toAdd.{u1} ι (AddMonoid.toAddZeroClass.{u1} ι _inst_2)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_i : ι) => M) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_i : ι) => M) i) _inst_3))) (NonUnitalNonAssocSemiring.directSumGNonUnitalNonAssocSemiring.{u1, u2} ι M _inst_2 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} M (Semiring.toNonAssocSemiring.{u2} M _inst_3))))))
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra_ring_equiv_direct_sum addMonoidAlgebraRingEquivDirectSumₓ'. -/
/-- The ring version of `add_monoid_algebra.to_add_monoid_algebra`. Note that this is
`noncomputable` because `add_monoid_algebra.has_add` is noncomputable. -/
@[simps (config := { fullyApplied := false })]
def addMonoidAlgebraRingEquivDirectSum [DecidableEq ι] [AddMonoid ι] [Semiring M]
    [∀ m : M, Decidable (m ≠ 0)] : AddMonoidAlgebra M ι ≃+* ⨁ i : ι, M :=
  {
    (addMonoidAlgebraAddEquivDirectSum :
      AddMonoidAlgebra M ι ≃+
        ⨁ i : ι, M) with
    toFun := AddMonoidAlgebra.toDirectSum
    invFun := DirectSum.toAddMonoidAlgebra
    map_mul' := AddMonoidAlgebra.toDirectSum_mul }
#align add_monoid_algebra_ring_equiv_direct_sum addMonoidAlgebraRingEquivDirectSum

/- warning: add_monoid_algebra_alg_equiv_direct_sum -> addMonoidAlgebraAlgEquivDirectSum is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {A : Type.{u3}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddMonoid.{u1} ι] [_inst_3 : CommSemiring.{u2} R] [_inst_4 : Semiring.{u3} A] [_inst_5 : Algebra.{u2, u3} R A _inst_3 _inst_4] [_inst_6 : forall (m : A), Decidable (Ne.{succ u3} A m (OfNat.ofNat.{u3} A 0 (OfNat.mk.{u3} A 0 (Zero.zero.{u3} A (MulZeroClass.toHasZero.{u3} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_4))))))))], AlgEquiv.{u2, max u1 u3, max u1 u3} R (AddMonoidAlgebra.{u3, u1} A ι _inst_4) (DirectSum.{u1, u3} ι (fun (i : ι) => A) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_4)))) _inst_3 (AddMonoidAlgebra.semiring.{u3, u1} A ι _inst_4 _inst_2) (DirectSum.semiring.{u1, u3} ι (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => A) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_4))) _inst_2 (Semiring.directSumGSemiring.{u1, u3} ι (fun (a : ι) (b : ι) => _inst_1 a b) A _inst_2 _inst_4)) (AddMonoidAlgebra.algebra.{u3, u1, u2} A ι R _inst_3 _inst_4 _inst_5 _inst_2) (DirectSum.algebra.{u1, u2, u3} ι R (fun (i : ι) => A) (fun (a : ι) (b : ι) => _inst_1 a b) _inst_3 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_4))) (fun (i : ι) => Algebra.toModule.{u2, u3} R A _inst_3 _inst_4 _inst_5) _inst_2 (Semiring.directSumGSemiring.{u1, u3} ι (fun (a : ι) (b : ι) => _inst_1 a b) A _inst_2 _inst_4) (Algebra.directSumGAlgebra.{u1, u2, u3} ι R A (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 _inst_5))
but is expected to have type
  forall {ι : Type.{u1}} {R : Type.{u2}} {A : Type.{u3}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddMonoid.{u1} ι] [_inst_3 : CommSemiring.{u2} R] [_inst_4 : Semiring.{u3} A] [_inst_5 : Algebra.{u2, u3} R A _inst_3 _inst_4] [_inst_6 : forall (m : A), Decidable (Ne.{succ u3} A m (OfNat.ofNat.{u3} A 0 (Zero.toOfNat0.{u3} A (MonoidWithZero.toZero.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_4)))))], AlgEquiv.{u2, max u1 u3, max u3 u1} R (AddMonoidAlgebra.{u3, u1} A ι _inst_4) (DirectSum.{u1, u3} ι (fun (i : ι) => A) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} ((fun (_i : ι) => A) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} ((fun (_i : ι) => A) i) (Semiring.toNonAssocSemiring.{u3} ((fun (_i : ι) => A) i) _inst_4)))) _inst_3 (AddMonoidAlgebra.semiring.{u3, u1} A ι _inst_4 _inst_2) (DirectSum.semiring.{u1, u3} ι (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => A) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} ((fun (_i : ι) => A) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} ((fun (_i : ι) => A) i) (Semiring.toNonAssocSemiring.{u3} ((fun (_i : ι) => A) i) _inst_4))) _inst_2 (Semiring.directSumGSemiring.{u1, u3} ι A _inst_2 _inst_4)) (AddMonoidAlgebra.algebra.{u3, u1, u2} A ι R _inst_3 _inst_4 _inst_5 _inst_2) (DirectSum.instAlgebraDirectSumSemiring.{u1, u2, u3} ι R (fun (i : ι) => A) (fun (a : ι) (b : ι) => _inst_1 a b) _inst_3 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} ((fun (_i : ι) => A) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} ((fun (_i : ι) => A) i) (Semiring.toNonAssocSemiring.{u3} ((fun (_i : ι) => A) i) _inst_4))) (fun (i : ι) => Algebra.toModule.{u2, u3} R A _inst_3 _inst_4 _inst_5) _inst_2 (Semiring.directSumGSemiring.{u1, u3} ι A _inst_2 _inst_4) (Algebra.directSumGAlgebra.{u1, u2, u3} ι R A (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 _inst_5))
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra_alg_equiv_direct_sum addMonoidAlgebraAlgEquivDirectSumₓ'. -/
/-- The algebra version of `add_monoid_algebra.to_add_monoid_algebra`. Note that this is
`noncomputable` because `add_monoid_algebra.has_add` is noncomputable. -/
@[simps (config := { fullyApplied := false })]
def addMonoidAlgebraAlgEquivDirectSum [DecidableEq ι] [AddMonoid ι] [CommSemiring R] [Semiring A]
    [Algebra R A] [∀ m : A, Decidable (m ≠ 0)] : AddMonoidAlgebra A ι ≃ₐ[R] ⨁ i : ι, A :=
  {
    (addMonoidAlgebraRingEquivDirectSum :
      AddMonoidAlgebra A ι ≃+*
        ⨁ i : ι, A) with
    toFun := AddMonoidAlgebra.toDirectSum
    invFun := DirectSum.toAddMonoidAlgebra
    commutes' := fun r => AddMonoidAlgebra.toDirectSum_single _ _ }
#align add_monoid_algebra_alg_equiv_direct_sum addMonoidAlgebraAlgEquivDirectSum

end Equivs

