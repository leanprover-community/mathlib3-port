/-
Copyright (c) 2022 Damiano Testa. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Damiano Testa
-/
import Mathbin.Algebra.MonoidAlgebra.Basic

/-!
#  Lemmas about the support of a finitely supported function
-/


universe u₁ u₂ u₃

namespace MonoidAlgebra

open Finsetₓ Finsupp

variable {k : Type u₁} {G : Type u₂} [Semiringₓ k]

theorem support_single_mul_subset [DecidableEq G] [Mul G] (f : MonoidAlgebra k G) (r : k) (a : G) :
    (single a r * f : MonoidAlgebra k G).Support ⊆ Finsetₓ.image ((· * ·) a) f.Support := by
  intro x hx
  contrapose hx
  have : ∀ y, a * y = x → f y = 0 := by
    simpa only [not_and', mem_image, mem_support_iff, exists_propₓ, not_exists, not_not] using hx
  simp only [mem_support_iff, mul_apply, sum_single_index, zero_mul, if_t_t, sum_zero, not_not]
  exact
    Finsetₓ.sum_eq_zero
      (by
        simp (config := { contextual := true }) only [this, mem_support_iff, mul_zero, Ne.def, ite_eq_right_iff,
          eq_self_iff_true, implies_true_iff])

theorem support_mul_single_subset [DecidableEq G] [Mul G] (f : MonoidAlgebra k G) (r : k) (a : G) :
    (f * single a r).Support ⊆ Finsetₓ.image (· * a) f.Support := by
  intro x hx
  contrapose hx
  have : ∀ y, y * a = x → f y = 0 := by
    simpa only [not_and', mem_image, mem_support_iff, exists_propₓ, not_exists, not_not] using hx
  simp only [mem_support_iff, mul_apply, sum_single_index, zero_mul, if_t_t, sum_zero, not_not]
  exact
    Finsetₓ.sum_eq_zero
      (by
        simp (config := { contextual := true }) only [this, sum_single_index, ite_eq_right_iff, eq_self_iff_true,
          implies_true_iff, zero_mul])

theorem support_single_mul_eq_image [DecidableEq G] [Mul G] (f : MonoidAlgebra k G) {r : k}
    (hr : ∀ y, r * y = 0 ↔ y = 0) {x : G} (lx : IsLeftRegular x) :
    (single x r * f : MonoidAlgebra k G).Support = Finsetₓ.image ((· * ·) x) f.Support := by
  refine' subset_antisymm (support_single_mul_subset f _ _) fun y hy => _
  obtain ⟨y, yf, rfl⟩ : ∃ a : G, a ∈ f.support ∧ x * a = y := by simpa only [Finsetₓ.mem_image, exists_propₓ] using hy
  simp only [mul_apply, mem_support_iff.mp yf, hr, mem_support_iff, sum_single_index, Finsupp.sum_ite_eq', Ne.def,
    not_false_iff, if_true, zero_mul, if_t_t, sum_zero, lx.eq_iff]

theorem support_mul_single_eq_image [DecidableEq G] [Mul G] (f : MonoidAlgebra k G) {r : k}
    (hr : ∀ y, y * r = 0 ↔ y = 0) {x : G} (rx : IsRightRegular x) :
    (f * single x r).Support = Finsetₓ.image (· * x) f.Support := by
  refine' subset_antisymm (support_mul_single_subset f _ _) fun y hy => _
  obtain ⟨y, yf, rfl⟩ : ∃ a : G, a ∈ f.support ∧ a * x = y := by simpa only [Finsetₓ.mem_image, exists_propₓ] using hy
  simp only [mul_apply, mem_support_iff.mp yf, hr, mem_support_iff, sum_single_index, Finsupp.sum_ite_eq', Ne.def,
    not_false_iff, if_true, mul_zero, if_t_t, sum_zero, rx.eq_iff]

theorem support_mul [Mul G] [DecidableEq G] (a b : MonoidAlgebra k G) :
    (a * b).Support ⊆ a.Support.bUnion fun a₁ => b.Support.bUnion fun a₂ => {a₁ * a₂} :=
  Subset.trans support_sum <|
    bUnion_mono fun a₁ _ => Subset.trans support_sum <| bUnion_mono fun a₂ _ => support_single_subset

theorem support_mul_single [RightCancelSemigroup G] (f : MonoidAlgebra k G) (r : k) (hr : ∀ y, y * r = 0 ↔ y = 0)
    (x : G) : (f * single x r).Support = f.Support.map (mulRightEmbedding x) := by
  classical
  ext
  simp only [support_mul_single_eq_image f hr (is_right_regular_of_right_cancel_semigroup x), mem_image, mem_map,
    mul_right_embedding_apply]

theorem support_single_mul [LeftCancelSemigroup G] (f : MonoidAlgebra k G) (r : k) (hr : ∀ y, r * y = 0 ↔ y = 0)
    (x : G) : (single x r * f : MonoidAlgebra k G).Support = f.Support.map (mulLeftEmbedding x) := by
  classical
  ext
  simp only [support_single_mul_eq_image f hr (is_left_regular_of_left_cancel_semigroup x), mem_image, mem_map,
    mul_left_embedding_apply]

section Span

variable [MulOneClassₓ G]

/-- An element of `monoid_algebra k G` is in the subalgebra generated by its support. -/
theorem mem_span_support (f : MonoidAlgebra k G) : f ∈ Submodule.span k (of k G '' (f.Support : Set G)) := by
  rw [of, MonoidHom.coe_mk, ← Finsupp.supported_eq_span_single, Finsupp.mem_supported]

end Span

end MonoidAlgebra

namespace AddMonoidAlgebra

open Finsetₓ Finsupp MulOpposite

variable {k : Type u₁} {G : Type u₂} [Semiringₓ k]

theorem support_mul [DecidableEq G] [Add G] (a b : AddMonoidAlgebra k G) :
    (a * b).Support ⊆ a.Support.bUnion fun a₁ => b.Support.bUnion fun a₂ => {a₁ + a₂} :=
  @MonoidAlgebra.support_mul k (Multiplicative G) _ _ _ _ _

theorem support_mul_single [AddRightCancelSemigroup G] (f : AddMonoidAlgebra k G) (r : k) (hr : ∀ y, y * r = 0 ↔ y = 0)
    (x : G) : (f * single x r : AddMonoidAlgebra k G).Support = f.Support.map (addRightEmbedding x) :=
  @MonoidAlgebra.support_mul_single k (Multiplicative G) _ _ _ _ hr _

theorem support_single_mul [AddLeftCancelSemigroup G] (f : AddMonoidAlgebra k G) (r : k) (hr : ∀ y, r * y = 0 ↔ y = 0)
    (x : G) : (single x r * f : AddMonoidAlgebra k G).Support = f.Support.map (addLeftEmbedding x) :=
  @MonoidAlgebra.support_single_mul k (Multiplicative G) _ _ _ _ hr _

section Span

/-- An element of `add_monoid_algebra k G` is in the submodule generated by its support. -/
theorem mem_span_support [AddZeroClassₓ G] (f : AddMonoidAlgebra k G) :
    f ∈ Submodule.span k (of k G '' (f.Support : Set G)) := by
  rw [of, MonoidHom.coe_mk, ← Finsupp.supported_eq_span_single, Finsupp.mem_supported]

/-- An element of `add_monoid_algebra k G` is in the subalgebra generated by its support, using
unbundled inclusion. -/
theorem mem_span_support' (f : AddMonoidAlgebra k G) : f ∈ Submodule.span k (of' k G '' (f.Support : Set G)) := by
  rw [of', ← Finsupp.supported_eq_span_single, Finsupp.mem_supported]

end Span

end AddMonoidAlgebra

