/-
Copyright (c) 2022 Damiano Testa. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Damiano Testa

! This file was ported from Lean 3 source module algebra.monoid_algebra.support
! leanprover-community/mathlib commit 69c6a5a12d8a2b159f20933e60115a4f2de62b58
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.MonoidAlgebra.Basic

/-!
#  Lemmas about the support of a finitely supported function

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.
-/


universe u₁ u₂ u₃

namespace MonoidAlgebra

open Finset Finsupp

variable {k : Type u₁} {G : Type u₂} [Semiring k]

/- warning: monoid_algebra.support_single_mul_subset -> MonoidAlgebra.support_single_mul_subset is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : DecidableEq.{succ u2} G] [_inst_3 : Mul.{u2} G] (f : MonoidAlgebra.{u1, u2} k G _inst_1) (r : k) (a : G), HasSubset.Subset.{u2} (Finset.{u2} G) (Finset.hasSubset.{u2} G) (Finsupp.support.{u2, u1} G k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.{u1, u2} k G _inst_1) (instHMul.{max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.mul.{u1, u2} k G _inst_1 _inst_3)) (Finsupp.single.{u2, u1} G k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) a r) f)) (Finset.image.{u2, u2} G G (fun (a : G) (b : G) => _inst_2 a b) (HMul.hMul.{u2, u2, u2} G G G (instHMul.{u2} G _inst_3) a) (Finsupp.support.{u2, u1} G k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) f))
but is expected to have type
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : DecidableEq.{succ u2} G] [_inst_3 : Mul.{u2} G] (f : MonoidAlgebra.{u1, u2} k G _inst_1) (r : k) (a : G), HasSubset.Subset.{u2} (Finset.{u2} G) (Finset.instHasSubsetFinset.{u2} G) (Finsupp.support.{u2, u1} G k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k _inst_1)) (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.{u1, u2} k G _inst_1) (instHMul.{max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.mul.{u1, u2} k G _inst_1 _inst_3)) (MonoidAlgebra.single.{u1, u2} k G _inst_1 a r) f)) (Finset.image.{u2, u2} G G (fun (a : G) (b : G) => _inst_2 a b) ((fun (x._@.Mathlib.Algebra.MonoidAlgebra.Support._hyg.55 : G) (x._@.Mathlib.Algebra.MonoidAlgebra.Support._hyg.57 : G) => HMul.hMul.{u2, u2, u2} G G G (instHMul.{u2} G _inst_3) x._@.Mathlib.Algebra.MonoidAlgebra.Support._hyg.55 x._@.Mathlib.Algebra.MonoidAlgebra.Support._hyg.57) a) (Finsupp.support.{u2, u1} G k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k _inst_1)) f))
Case conversion may be inaccurate. Consider using '#align monoid_algebra.support_single_mul_subset MonoidAlgebra.support_single_mul_subsetₓ'. -/
theorem support_single_mul_subset [DecidableEq G] [Mul G] (f : MonoidAlgebra k G) (r : k) (a : G) :
    (single a r * f : MonoidAlgebra k G).support ⊆ Finset.image ((· * ·) a) f.support :=
  by
  intro x hx
  contrapose hx
  have : ∀ y, a * y = x → f y = 0 := by
    simpa only [not_and', mem_image, mem_support_iff, exists_prop, not_exists,
      Classical.not_not] using hx
  simp only [mem_support_iff, mul_apply, sum_single_index, MulZeroClass.zero_mul, if_t_t, sum_zero,
    Classical.not_not]
  exact
    Finset.sum_eq_zero
      (by
        simp (config := { contextual := true }) only [this, mem_support_iff, MulZeroClass.mul_zero,
          Ne.def, ite_eq_right_iff, eq_self_iff_true, imp_true_iff])
#align monoid_algebra.support_single_mul_subset MonoidAlgebra.support_single_mul_subset

/- warning: monoid_algebra.support_mul_single_subset -> MonoidAlgebra.support_mul_single_subset is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : DecidableEq.{succ u2} G] [_inst_3 : Mul.{u2} G] (f : MonoidAlgebra.{u1, u2} k G _inst_1) (r : k) (a : G), HasSubset.Subset.{u2} (Finset.{u2} G) (Finset.hasSubset.{u2} G) (Finsupp.support.{u2, u1} G k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.{u1, u2} k G _inst_1) (instHMul.{max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.mul.{u1, u2} k G _inst_1 _inst_3)) f (Finsupp.single.{u2, u1} G k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) a r))) (Finset.image.{u2, u2} G G (fun (a : G) (b : G) => _inst_2 a b) (fun (_x : G) => HMul.hMul.{u2, u2, u2} G G G (instHMul.{u2} G _inst_3) _x a) (Finsupp.support.{u2, u1} G k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) f))
but is expected to have type
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : DecidableEq.{succ u2} G] [_inst_3 : Mul.{u2} G] (f : MonoidAlgebra.{u1, u2} k G _inst_1) (r : k) (a : G), HasSubset.Subset.{u2} (Finset.{u2} G) (Finset.instHasSubsetFinset.{u2} G) (Finsupp.support.{u2, u1} G k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k _inst_1)) (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.{u1, u2} k G _inst_1) (instHMul.{max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.mul.{u1, u2} k G _inst_1 _inst_3)) f (MonoidAlgebra.single.{u1, u2} k G _inst_1 a r))) (Finset.image.{u2, u2} G G (fun (a : G) (b : G) => _inst_2 a b) (fun (_x : G) => HMul.hMul.{u2, u2, u2} G G G (instHMul.{u2} G _inst_3) _x a) (Finsupp.support.{u2, u1} G k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k _inst_1)) f))
Case conversion may be inaccurate. Consider using '#align monoid_algebra.support_mul_single_subset MonoidAlgebra.support_mul_single_subsetₓ'. -/
theorem support_mul_single_subset [DecidableEq G] [Mul G] (f : MonoidAlgebra k G) (r : k) (a : G) :
    (f * single a r).support ⊆ Finset.image (· * a) f.support :=
  by
  intro x hx
  contrapose hx
  have : ∀ y, y * a = x → f y = 0 := by
    simpa only [not_and', mem_image, mem_support_iff, exists_prop, not_exists,
      Classical.not_not] using hx
  simp only [mem_support_iff, mul_apply, sum_single_index, MulZeroClass.zero_mul, if_t_t, sum_zero,
    Classical.not_not]
  exact
    Finset.sum_eq_zero
      (by
        simp (config := { contextual := true }) only [this, sum_single_index, ite_eq_right_iff,
          eq_self_iff_true, imp_true_iff, MulZeroClass.zero_mul])
#align monoid_algebra.support_mul_single_subset MonoidAlgebra.support_mul_single_subset

/- warning: monoid_algebra.support_single_mul_eq_image -> MonoidAlgebra.support_single_mul_eq_image is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : DecidableEq.{succ u2} G] [_inst_3 : Mul.{u2} G] (f : MonoidAlgebra.{u1, u2} k G _inst_1) {r : k}, (forall (y : k), Iff (Eq.{succ u1} k (HMul.hMul.{u1, u1, u1} k k k (instHMul.{u1} k (Distrib.toHasMul.{u1} k (NonUnitalNonAssocSemiring.toDistrib.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1))))) r y) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))))))) (Eq.{succ u1} k y (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1))))))))) -> (forall {x : G}, (IsLeftRegular.{u2} G _inst_3 x) -> (Eq.{succ u2} (Finset.{u2} G) (Finsupp.support.{u2, u1} G k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.{u1, u2} k G _inst_1) (instHMul.{max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.mul.{u1, u2} k G _inst_1 _inst_3)) (Finsupp.single.{u2, u1} G k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) x r) f)) (Finset.image.{u2, u2} G G (fun (a : G) (b : G) => _inst_2 a b) (HMul.hMul.{u2, u2, u2} G G G (instHMul.{u2} G _inst_3) x) (Finsupp.support.{u2, u1} G k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) f))))
but is expected to have type
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : DecidableEq.{succ u2} G] [_inst_3 : Mul.{u2} G] (f : MonoidAlgebra.{u1, u2} k G _inst_1) {r : k}, (forall (y : k), Iff (Eq.{succ u1} k (HMul.hMul.{u1, u1, u1} k k k (instHMul.{u1} k (NonUnitalNonAssocSemiring.toMul.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) r y) (OfNat.ofNat.{u1} k 0 (Zero.toOfNat0.{u1} k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k _inst_1))))) (Eq.{succ u1} k y (OfNat.ofNat.{u1} k 0 (Zero.toOfNat0.{u1} k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k _inst_1)))))) -> (forall {x : G}, (IsLeftRegular.{u2} G _inst_3 x) -> (Eq.{succ u2} (Finset.{u2} G) (Finsupp.support.{u2, u1} G k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k _inst_1)) (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.{u1, u2} k G _inst_1) (instHMul.{max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.mul.{u1, u2} k G _inst_1 _inst_3)) (MonoidAlgebra.single.{u1, u2} k G _inst_1 x r) f)) (Finset.image.{u2, u2} G G (fun (a : G) (b : G) => _inst_2 a b) ((fun (x._@.Mathlib.Algebra.MonoidAlgebra.Support._hyg.365 : G) (x._@.Mathlib.Algebra.MonoidAlgebra.Support._hyg.367 : G) => HMul.hMul.{u2, u2, u2} G G G (instHMul.{u2} G _inst_3) x._@.Mathlib.Algebra.MonoidAlgebra.Support._hyg.365 x._@.Mathlib.Algebra.MonoidAlgebra.Support._hyg.367) x) (Finsupp.support.{u2, u1} G k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k _inst_1)) f))))
Case conversion may be inaccurate. Consider using '#align monoid_algebra.support_single_mul_eq_image MonoidAlgebra.support_single_mul_eq_imageₓ'. -/
theorem support_single_mul_eq_image [DecidableEq G] [Mul G] (f : MonoidAlgebra k G) {r : k}
    (hr : ∀ y, r * y = 0 ↔ y = 0) {x : G} (lx : IsLeftRegular x) :
    (single x r * f : MonoidAlgebra k G).support = Finset.image ((· * ·) x) f.support :=
  by
  refine' subset_antisymm (support_single_mul_subset f _ _) fun y hy => _
  obtain ⟨y, yf, rfl⟩ : ∃ a : G, a ∈ f.support ∧ x * a = y := by
    simpa only [Finset.mem_image, exists_prop] using hy
  simp only [mul_apply, mem_support_iff.mp yf, hr, mem_support_iff, sum_single_index,
    Finsupp.sum_ite_eq', Ne.def, not_false_iff, if_true, MulZeroClass.zero_mul, if_t_t, sum_zero,
    lx.eq_iff]
#align monoid_algebra.support_single_mul_eq_image MonoidAlgebra.support_single_mul_eq_image

/- warning: monoid_algebra.support_mul_single_eq_image -> MonoidAlgebra.support_mul_single_eq_image is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : DecidableEq.{succ u2} G] [_inst_3 : Mul.{u2} G] (f : MonoidAlgebra.{u1, u2} k G _inst_1) {r : k}, (forall (y : k), Iff (Eq.{succ u1} k (HMul.hMul.{u1, u1, u1} k k k (instHMul.{u1} k (Distrib.toHasMul.{u1} k (NonUnitalNonAssocSemiring.toDistrib.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1))))) y r) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))))))) (Eq.{succ u1} k y (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1))))))))) -> (forall {x : G}, (IsRightRegular.{u2} G _inst_3 x) -> (Eq.{succ u2} (Finset.{u2} G) (Finsupp.support.{u2, u1} G k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.{u1, u2} k G _inst_1) (instHMul.{max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.mul.{u1, u2} k G _inst_1 _inst_3)) f (Finsupp.single.{u2, u1} G k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) x r))) (Finset.image.{u2, u2} G G (fun (a : G) (b : G) => _inst_2 a b) (fun (_x : G) => HMul.hMul.{u2, u2, u2} G G G (instHMul.{u2} G _inst_3) _x x) (Finsupp.support.{u2, u1} G k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) f))))
but is expected to have type
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : DecidableEq.{succ u2} G] [_inst_3 : Mul.{u2} G] (f : MonoidAlgebra.{u1, u2} k G _inst_1) {r : k}, (forall (y : k), Iff (Eq.{succ u1} k (HMul.hMul.{u1, u1, u1} k k k (instHMul.{u1} k (NonUnitalNonAssocSemiring.toMul.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) y r) (OfNat.ofNat.{u1} k 0 (Zero.toOfNat0.{u1} k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k _inst_1))))) (Eq.{succ u1} k y (OfNat.ofNat.{u1} k 0 (Zero.toOfNat0.{u1} k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k _inst_1)))))) -> (forall {x : G}, (IsRightRegular.{u2} G _inst_3 x) -> (Eq.{succ u2} (Finset.{u2} G) (Finsupp.support.{u2, u1} G k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k _inst_1)) (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.{u1, u2} k G _inst_1) (instHMul.{max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.mul.{u1, u2} k G _inst_1 _inst_3)) f (MonoidAlgebra.single.{u1, u2} k G _inst_1 x r))) (Finset.image.{u2, u2} G G (fun (a : G) (b : G) => _inst_2 a b) (fun (_x : G) => HMul.hMul.{u2, u2, u2} G G G (instHMul.{u2} G _inst_3) _x x) (Finsupp.support.{u2, u1} G k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k _inst_1)) f))))
Case conversion may be inaccurate. Consider using '#align monoid_algebra.support_mul_single_eq_image MonoidAlgebra.support_mul_single_eq_imageₓ'. -/
theorem support_mul_single_eq_image [DecidableEq G] [Mul G] (f : MonoidAlgebra k G) {r : k}
    (hr : ∀ y, y * r = 0 ↔ y = 0) {x : G} (rx : IsRightRegular x) :
    (f * single x r).support = Finset.image (· * x) f.support :=
  by
  refine' subset_antisymm (support_mul_single_subset f _ _) fun y hy => _
  obtain ⟨y, yf, rfl⟩ : ∃ a : G, a ∈ f.support ∧ a * x = y := by
    simpa only [Finset.mem_image, exists_prop] using hy
  simp only [mul_apply, mem_support_iff.mp yf, hr, mem_support_iff, sum_single_index,
    Finsupp.sum_ite_eq', Ne.def, not_false_iff, if_true, MulZeroClass.mul_zero, if_t_t, sum_zero,
    rx.eq_iff]
#align monoid_algebra.support_mul_single_eq_image MonoidAlgebra.support_mul_single_eq_image

#print MonoidAlgebra.support_mul /-
theorem support_mul [Mul G] [DecidableEq G] (a b : MonoidAlgebra k G) :
    (a * b).support ⊆ a.support.bunionᵢ fun a₁ => b.support.bunionᵢ fun a₂ => {a₁ * a₂} :=
  Subset.trans support_sum <|
    bunionᵢ_mono fun a₁ _ =>
      Subset.trans support_sum <| bunionᵢ_mono fun a₂ _ => support_single_subset
#align monoid_algebra.support_mul MonoidAlgebra.support_mul
-/

/- warning: monoid_algebra.support_mul_single -> MonoidAlgebra.support_mul_single is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : RightCancelSemigroup.{u2} G] (f : MonoidAlgebra.{u1, u2} k G _inst_1) (r : k), (forall (y : k), Iff (Eq.{succ u1} k (HMul.hMul.{u1, u1, u1} k k k (instHMul.{u1} k (Distrib.toHasMul.{u1} k (NonUnitalNonAssocSemiring.toDistrib.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1))))) y r) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))))))) (Eq.{succ u1} k y (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1))))))))) -> (forall (x : G), Eq.{succ u2} (Finset.{u2} G) (Finsupp.support.{u2, u1} G k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.{u1, u2} k G _inst_1) (instHMul.{max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.mul.{u1, u2} k G _inst_1 (Semigroup.toHasMul.{u2} G (RightCancelSemigroup.toSemigroup.{u2} G _inst_2)))) f (Finsupp.single.{u2, u1} G k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) x r))) (Finset.map.{u2, u2} G G (mulRightEmbedding.{u2} G _inst_2 x) (Finsupp.support.{u2, u1} G k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) f)))
but is expected to have type
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : RightCancelSemigroup.{u2} G] (f : MonoidAlgebra.{u1, u2} k G _inst_1) (r : k), (forall (y : k), Iff (Eq.{succ u1} k (HMul.hMul.{u1, u1, u1} k k k (instHMul.{u1} k (NonUnitalNonAssocSemiring.toMul.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) y r) (OfNat.ofNat.{u1} k 0 (Zero.toOfNat0.{u1} k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k _inst_1))))) (Eq.{succ u1} k y (OfNat.ofNat.{u1} k 0 (Zero.toOfNat0.{u1} k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k _inst_1)))))) -> (forall (x : G), Eq.{succ u2} (Finset.{u2} G) (Finsupp.support.{u2, u1} G k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k _inst_1)) (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.{u1, u2} k G _inst_1) (instHMul.{max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.mul.{u1, u2} k G _inst_1 (Semigroup.toMul.{u2} G (RightCancelSemigroup.toSemigroup.{u2} G _inst_2)))) f (MonoidAlgebra.single.{u1, u2} k G _inst_1 x r))) (Finset.map.{u2, u2} G G (mulRightEmbedding.{u2} G _inst_2 x) (Finsupp.support.{u2, u1} G k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k _inst_1)) f)))
Case conversion may be inaccurate. Consider using '#align monoid_algebra.support_mul_single MonoidAlgebra.support_mul_singleₓ'. -/
theorem support_mul_single [RightCancelSemigroup G] (f : MonoidAlgebra k G) (r : k)
    (hr : ∀ y, y * r = 0 ↔ y = 0) (x : G) :
    (f * single x r).support = f.support.map (mulRightEmbedding x) := by
  classical
    ext
    simp only [support_mul_single_eq_image f hr (isRightRegular_of_rightCancelSemigroup x),
      mem_image, mem_map, mulRightEmbedding_apply]
#align monoid_algebra.support_mul_single MonoidAlgebra.support_mul_single

/- warning: monoid_algebra.support_single_mul -> MonoidAlgebra.support_single_mul is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : LeftCancelSemigroup.{u2} G] (f : MonoidAlgebra.{u1, u2} k G _inst_1) (r : k), (forall (y : k), Iff (Eq.{succ u1} k (HMul.hMul.{u1, u1, u1} k k k (instHMul.{u1} k (Distrib.toHasMul.{u1} k (NonUnitalNonAssocSemiring.toDistrib.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1))))) r y) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))))))) (Eq.{succ u1} k y (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1))))))))) -> (forall (x : G), Eq.{succ u2} (Finset.{u2} G) (Finsupp.support.{u2, u1} G k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.{u1, u2} k G _inst_1) (instHMul.{max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.mul.{u1, u2} k G _inst_1 (Semigroup.toHasMul.{u2} G (LeftCancelSemigroup.toSemigroup.{u2} G _inst_2)))) (Finsupp.single.{u2, u1} G k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) x r) f)) (Finset.map.{u2, u2} G G (mulLeftEmbedding.{u2} G _inst_2 x) (Finsupp.support.{u2, u1} G k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) f)))
but is expected to have type
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : LeftCancelSemigroup.{u2} G] (f : MonoidAlgebra.{u1, u2} k G _inst_1) (r : k), (forall (y : k), Iff (Eq.{succ u1} k (HMul.hMul.{u1, u1, u1} k k k (instHMul.{u1} k (NonUnitalNonAssocSemiring.toMul.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) r y) (OfNat.ofNat.{u1} k 0 (Zero.toOfNat0.{u1} k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k _inst_1))))) (Eq.{succ u1} k y (OfNat.ofNat.{u1} k 0 (Zero.toOfNat0.{u1} k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k _inst_1)))))) -> (forall (x : G), Eq.{succ u2} (Finset.{u2} G) (Finsupp.support.{u2, u1} G k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k _inst_1)) (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.{u1, u2} k G _inst_1) (instHMul.{max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.mul.{u1, u2} k G _inst_1 (Semigroup.toMul.{u2} G (LeftCancelSemigroup.toSemigroup.{u2} G _inst_2)))) (MonoidAlgebra.single.{u1, u2} k G _inst_1 x r) f)) (Finset.map.{u2, u2} G G (mulLeftEmbedding.{u2} G _inst_2 x) (Finsupp.support.{u2, u1} G k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k _inst_1)) f)))
Case conversion may be inaccurate. Consider using '#align monoid_algebra.support_single_mul MonoidAlgebra.support_single_mulₓ'. -/
theorem support_single_mul [LeftCancelSemigroup G] (f : MonoidAlgebra k G) (r : k)
    (hr : ∀ y, r * y = 0 ↔ y = 0) (x : G) :
    (single x r * f : MonoidAlgebra k G).support = f.support.map (mulLeftEmbedding x) := by
  classical
    ext
    simp only [support_single_mul_eq_image f hr (isLeftRegular_of_leftCancelSemigroup x), mem_image,
      mem_map, mulLeftEmbedding_apply]
#align monoid_algebra.support_single_mul MonoidAlgebra.support_single_mul

section Span

variable [MulOneClass G]

/- warning: monoid_algebra.mem_span_support -> MonoidAlgebra.mem_span_support is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : MulOneClass.{u2} G] (f : MonoidAlgebra.{u1, u2} k G _inst_1), Membership.Mem.{max u1 u2, max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (Submodule.{u1, max u1 u2} k (MonoidAlgebra.{u1, u2} k G _inst_1) _inst_1 (MonoidAlgebra.addCommMonoid.{u2, u1} k G _inst_1) (MonoidAlgebra.module.{u1, u2, u1} k G k _inst_1 _inst_1 (Semiring.toModule.{u1} k _inst_1))) (SetLike.hasMem.{max u1 u2, max u1 u2} (Submodule.{u1, max u1 u2} k (MonoidAlgebra.{u1, u2} k G _inst_1) _inst_1 (MonoidAlgebra.addCommMonoid.{u2, u1} k G _inst_1) (MonoidAlgebra.module.{u1, u2, u1} k G k _inst_1 _inst_1 (Semiring.toModule.{u1} k _inst_1))) (MonoidAlgebra.{u1, u2} k G _inst_1) (Submodule.setLike.{u1, max u1 u2} k (MonoidAlgebra.{u1, u2} k G _inst_1) _inst_1 (MonoidAlgebra.addCommMonoid.{u2, u1} k G _inst_1) (MonoidAlgebra.module.{u1, u2, u1} k G k _inst_1 _inst_1 (Semiring.toModule.{u1} k _inst_1)))) f (Submodule.span.{u1, max u1 u2} k (MonoidAlgebra.{u1, u2} k G _inst_1) _inst_1 (MonoidAlgebra.addCommMonoid.{u2, u1} k G _inst_1) (MonoidAlgebra.module.{u1, u2, u1} k G k _inst_1 _inst_1 (Semiring.toModule.{u1} k _inst_1)) (Set.image.{u2, max u1 u2} G (MonoidAlgebra.{u1, u2} k G _inst_1) (coeFn.{max (succ (max u1 u2)) (succ u2), max (succ u2) (succ (max u1 u2))} (MonoidHom.{u2, max u1 u2} G (MonoidAlgebra.{u1, u2} k G _inst_1) _inst_2 (MulZeroOneClass.toMulOneClass.{max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.nonAssocSemiring.{u1, u2} k G _inst_1 _inst_2)))) (fun (_x : MonoidHom.{u2, max u1 u2} G (MonoidAlgebra.{u1, u2} k G _inst_1) _inst_2 (MulZeroOneClass.toMulOneClass.{max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.nonAssocSemiring.{u1, u2} k G _inst_1 _inst_2)))) => G -> (MonoidAlgebra.{u1, u2} k G _inst_1)) (MonoidHom.hasCoeToFun.{u2, max u1 u2} G (MonoidAlgebra.{u1, u2} k G _inst_1) _inst_2 (MulZeroOneClass.toMulOneClass.{max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.nonAssocSemiring.{u1, u2} k G _inst_1 _inst_2)))) (MonoidAlgebra.of.{u1, u2} k G _inst_1 _inst_2)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} G) (Set.{u2} G) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} G) (Set.{u2} G) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} G) (Set.{u2} G) (Finset.Set.hasCoeT.{u2} G))) (Finsupp.support.{u2, u1} G k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) f))))
but is expected to have type
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : MulOneClass.{u2} G] (f : MonoidAlgebra.{u1, u2} k G _inst_1), Membership.mem.{max u1 u2, max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (Submodule.{u1, max u1 u2} k (MonoidAlgebra.{u1, u2} k G _inst_1) _inst_1 (MonoidAlgebra.addCommMonoid.{u1, u2} k G _inst_1) (MonoidAlgebra.module.{u1, u2, u1} k G k _inst_1 _inst_1 (Semiring.toModule.{u1} k _inst_1))) (SetLike.instMembership.{max u1 u2, max u1 u2} (Submodule.{u1, max u1 u2} k (MonoidAlgebra.{u1, u2} k G _inst_1) _inst_1 (MonoidAlgebra.addCommMonoid.{u1, u2} k G _inst_1) (MonoidAlgebra.module.{u1, u2, u1} k G k _inst_1 _inst_1 (Semiring.toModule.{u1} k _inst_1))) (MonoidAlgebra.{u1, u2} k G _inst_1) (Submodule.setLike.{u1, max u1 u2} k (MonoidAlgebra.{u1, u2} k G _inst_1) _inst_1 (MonoidAlgebra.addCommMonoid.{u1, u2} k G _inst_1) (MonoidAlgebra.module.{u1, u2, u1} k G k _inst_1 _inst_1 (Semiring.toModule.{u1} k _inst_1)))) f (Submodule.span.{u1, max u1 u2} k (MonoidAlgebra.{u1, u2} k G _inst_1) _inst_1 (MonoidAlgebra.addCommMonoid.{u1, u2} k G _inst_1) (MonoidAlgebra.module.{u1, u2, u1} k G k _inst_1 _inst_1 (Semiring.toModule.{u1} k _inst_1)) (Set.image.{u2, max u1 u2} G (MonoidAlgebra.{u1, u2} k G _inst_1) (FunLike.coe.{max (succ u1) (succ u2), succ u2, max (succ u1) (succ u2)} (MonoidHom.{u2, max u2 u1} G (MonoidAlgebra.{u1, u2} k G _inst_1) _inst_2 (MulZeroOneClass.toMulOneClass.{max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.nonAssocSemiring.{u1, u2} k G _inst_1 _inst_2)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : G) => MonoidAlgebra.{u1, u2} k G _inst_1) _x) (MulHomClass.toFunLike.{max u1 u2, u2, max u1 u2} (MonoidHom.{u2, max u2 u1} G (MonoidAlgebra.{u1, u2} k G _inst_1) _inst_2 (MulZeroOneClass.toMulOneClass.{max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.nonAssocSemiring.{u1, u2} k G _inst_1 _inst_2)))) G (MonoidAlgebra.{u1, u2} k G _inst_1) (MulOneClass.toMul.{u2} G _inst_2) (MulOneClass.toMul.{max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (MulZeroOneClass.toMulOneClass.{max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.nonAssocSemiring.{u1, u2} k G _inst_1 _inst_2)))) (MonoidHomClass.toMulHomClass.{max u1 u2, u2, max u1 u2} (MonoidHom.{u2, max u2 u1} G (MonoidAlgebra.{u1, u2} k G _inst_1) _inst_2 (MulZeroOneClass.toMulOneClass.{max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.nonAssocSemiring.{u1, u2} k G _inst_1 _inst_2)))) G (MonoidAlgebra.{u1, u2} k G _inst_1) _inst_2 (MulZeroOneClass.toMulOneClass.{max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.nonAssocSemiring.{u1, u2} k G _inst_1 _inst_2))) (MonoidHom.monoidHomClass.{u2, max u1 u2} G (MonoidAlgebra.{u1, u2} k G _inst_1) _inst_2 (MulZeroOneClass.toMulOneClass.{max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (MonoidAlgebra.{u1, u2} k G _inst_1) (MonoidAlgebra.nonAssocSemiring.{u1, u2} k G _inst_1 _inst_2)))))) (MonoidAlgebra.of.{u1, u2} k G _inst_1 _inst_2)) (Finset.toSet.{u2} G (Finsupp.support.{u2, u1} G k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k _inst_1)) f))))
Case conversion may be inaccurate. Consider using '#align monoid_algebra.mem_span_support MonoidAlgebra.mem_span_supportₓ'. -/
/-- An element of `monoid_algebra k G` is in the subalgebra generated by its support. -/
theorem mem_span_support (f : MonoidAlgebra k G) :
    f ∈ Submodule.span k (of k G '' (f.support : Set G)) := by
  rw [of, MonoidHom.coe_mk, ← Finsupp.supported_eq_span_single, Finsupp.mem_supported]
#align monoid_algebra.mem_span_support MonoidAlgebra.mem_span_support

end Span

end MonoidAlgebra

namespace AddMonoidAlgebra

open Finset Finsupp MulOpposite

variable {k : Type u₁} {G : Type u₂} [Semiring k]

#print AddMonoidAlgebra.support_mul /-
theorem support_mul [DecidableEq G] [Add G] (a b : AddMonoidAlgebra k G) :
    (a * b).support ⊆ a.support.bunionᵢ fun a₁ => b.support.bunionᵢ fun a₂ => {a₁ + a₂} :=
  @MonoidAlgebra.support_mul k (Multiplicative G) _ _ _ _ _
#align add_monoid_algebra.support_mul AddMonoidAlgebra.support_mul
-/

/- warning: add_monoid_algebra.support_mul_single -> AddMonoidAlgebra.support_mul_single is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : AddRightCancelSemigroup.{u2} G] (f : AddMonoidAlgebra.{u1, u2} k G _inst_1) (r : k), (forall (y : k), Iff (Eq.{succ u1} k (HMul.hMul.{u1, u1, u1} k k k (instHMul.{u1} k (Distrib.toHasMul.{u1} k (NonUnitalNonAssocSemiring.toDistrib.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1))))) y r) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))))))) (Eq.{succ u1} k y (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1))))))))) -> (forall (x : G), Eq.{succ u2} (Finset.{u2} G) (Finsupp.support.{u2, u1} G k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (instHMul.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.hasMul.{u1, u2} k G _inst_1 (AddSemigroup.toHasAdd.{u2} G (AddRightCancelSemigroup.toAddSemigroup.{u2} G _inst_2)))) f (Finsupp.single.{u2, u1} G k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) x r))) (Finset.map.{u2, u2} G G (addRightEmbedding.{u2} G _inst_2 x) (Finsupp.support.{u2, u1} G k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) f)))
but is expected to have type
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : AddRightCancelSemigroup.{u2} G] (f : AddMonoidAlgebra.{u1, u2} k G _inst_1) (r : k), (forall (y : k), Iff (Eq.{succ u1} k (HMul.hMul.{u1, u1, u1} k k k (instHMul.{u1} k (NonUnitalNonAssocSemiring.toMul.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) y r) (OfNat.ofNat.{u1} k 0 (Zero.toOfNat0.{u1} k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k _inst_1))))) (Eq.{succ u1} k y (OfNat.ofNat.{u1} k 0 (Zero.toOfNat0.{u1} k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k _inst_1)))))) -> (forall (x : G), Eq.{succ u2} (Finset.{u2} G) (Finsupp.support.{u2, u1} G k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k _inst_1)) (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (instHMul.{max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.hasMul.{u1, u2} k G _inst_1 (AddSemigroup.toAdd.{u2} G (AddRightCancelSemigroup.toAddSemigroup.{u2} G _inst_2)))) f (AddMonoidAlgebra.single.{u1, u2} k G _inst_1 x r))) (Finset.map.{u2, u2} G G (addRightEmbedding.{u2} G _inst_2 x) (Finsupp.support.{u2, u1} G k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k _inst_1)) f)))
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.support_mul_single AddMonoidAlgebra.support_mul_singleₓ'. -/
theorem support_mul_single [AddRightCancelSemigroup G] (f : AddMonoidAlgebra k G) (r : k)
    (hr : ∀ y, y * r = 0 ↔ y = 0) (x : G) :
    (f * single x r : AddMonoidAlgebra k G).support = f.support.map (addRightEmbedding x) :=
  @MonoidAlgebra.support_mul_single k (Multiplicative G) _ _ _ _ hr _
#align add_monoid_algebra.support_mul_single AddMonoidAlgebra.support_mul_single

/- warning: add_monoid_algebra.support_single_mul -> AddMonoidAlgebra.support_single_mul is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : AddLeftCancelSemigroup.{u2} G] (f : AddMonoidAlgebra.{u1, u2} k G _inst_1) (r : k), (forall (y : k), Iff (Eq.{succ u1} k (HMul.hMul.{u1, u1, u1} k k k (instHMul.{u1} k (Distrib.toHasMul.{u1} k (NonUnitalNonAssocSemiring.toDistrib.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1))))) r y) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))))))) (Eq.{succ u1} k y (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1))))))))) -> (forall (x : G), Eq.{succ u2} (Finset.{u2} G) (Finsupp.support.{u2, u1} G k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (instHMul.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.hasMul.{u1, u2} k G _inst_1 (AddSemigroup.toHasAdd.{u2} G (AddLeftCancelSemigroup.toAddSemigroup.{u2} G _inst_2)))) (Finsupp.single.{u2, u1} G k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) x r) f)) (Finset.map.{u2, u2} G G (addLeftEmbedding.{u2} G _inst_2 x) (Finsupp.support.{u2, u1} G k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) f)))
but is expected to have type
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : AddLeftCancelSemigroup.{u2} G] (f : AddMonoidAlgebra.{u1, u2} k G _inst_1) (r : k), (forall (y : k), Iff (Eq.{succ u1} k (HMul.hMul.{u1, u1, u1} k k k (instHMul.{u1} k (NonUnitalNonAssocSemiring.toMul.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) r y) (OfNat.ofNat.{u1} k 0 (Zero.toOfNat0.{u1} k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k _inst_1))))) (Eq.{succ u1} k y (OfNat.ofNat.{u1} k 0 (Zero.toOfNat0.{u1} k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k _inst_1)))))) -> (forall (x : G), Eq.{succ u2} (Finset.{u2} G) (Finsupp.support.{u2, u1} G k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k _inst_1)) (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (instHMul.{max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.hasMul.{u1, u2} k G _inst_1 (AddSemigroup.toAdd.{u2} G (AddLeftCancelSemigroup.toAddSemigroup.{u2} G _inst_2)))) (AddMonoidAlgebra.single.{u1, u2} k G _inst_1 x r) f)) (Finset.map.{u2, u2} G G (addLeftEmbedding.{u2} G _inst_2 x) (Finsupp.support.{u2, u1} G k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k _inst_1)) f)))
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.support_single_mul AddMonoidAlgebra.support_single_mulₓ'. -/
theorem support_single_mul [AddLeftCancelSemigroup G] (f : AddMonoidAlgebra k G) (r : k)
    (hr : ∀ y, r * y = 0 ↔ y = 0) (x : G) :
    (single x r * f : AddMonoidAlgebra k G).support = f.support.map (addLeftEmbedding x) :=
  @MonoidAlgebra.support_single_mul k (Multiplicative G) _ _ _ _ hr _
#align add_monoid_algebra.support_single_mul AddMonoidAlgebra.support_single_mul

section Span

/- warning: add_monoid_algebra.mem_span_support -> AddMonoidAlgebra.mem_span_support is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : AddZeroClass.{u2} G] (f : AddMonoidAlgebra.{u1, u2} k G _inst_1), Membership.Mem.{max u2 u1, max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (Submodule.{u1, max u2 u1} k (AddMonoidAlgebra.{u1, u2} k G _inst_1) _inst_1 (AddMonoidAlgebra.addCommMonoid.{u2, u1} k G _inst_1) (AddMonoidAlgebra.module.{u1, u2, u1} k G k _inst_1 _inst_1 (Semiring.toModule.{u1} k _inst_1))) (SetLike.hasMem.{max u2 u1, max u2 u1} (Submodule.{u1, max u2 u1} k (AddMonoidAlgebra.{u1, u2} k G _inst_1) _inst_1 (AddMonoidAlgebra.addCommMonoid.{u2, u1} k G _inst_1) (AddMonoidAlgebra.module.{u1, u2, u1} k G k _inst_1 _inst_1 (Semiring.toModule.{u1} k _inst_1))) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (Submodule.setLike.{u1, max u2 u1} k (AddMonoidAlgebra.{u1, u2} k G _inst_1) _inst_1 (AddMonoidAlgebra.addCommMonoid.{u2, u1} k G _inst_1) (AddMonoidAlgebra.module.{u1, u2, u1} k G k _inst_1 _inst_1 (Semiring.toModule.{u1} k _inst_1)))) f (Submodule.span.{u1, max u2 u1} k (AddMonoidAlgebra.{u1, u2} k G _inst_1) _inst_1 (AddMonoidAlgebra.addCommMonoid.{u2, u1} k G _inst_1) (AddMonoidAlgebra.module.{u1, u2, u1} k G k _inst_1 _inst_1 (Semiring.toModule.{u1} k _inst_1)) (Set.image.{u2, max u2 u1} (Multiplicative.{u2} G) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (coeFn.{max (succ (max u2 u1)) (succ u2), max (succ u2) (succ (max u2 u1))} (MonoidHom.{u2, max u2 u1} (Multiplicative.{u2} G) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (Multiplicative.mulOneClass.{u2} G _inst_2) (MulZeroOneClass.toMulOneClass.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.nonAssocSemiring.{u1, u2} k G _inst_1 _inst_2)))) (fun (_x : MonoidHom.{u2, max u2 u1} (Multiplicative.{u2} G) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (Multiplicative.mulOneClass.{u2} G _inst_2) (MulZeroOneClass.toMulOneClass.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.nonAssocSemiring.{u1, u2} k G _inst_1 _inst_2)))) => (Multiplicative.{u2} G) -> (AddMonoidAlgebra.{u1, u2} k G _inst_1)) (MonoidHom.hasCoeToFun.{u2, max u2 u1} (Multiplicative.{u2} G) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (Multiplicative.mulOneClass.{u2} G _inst_2) (MulZeroOneClass.toMulOneClass.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.nonAssocSemiring.{u1, u2} k G _inst_1 _inst_2)))) (AddMonoidAlgebra.of.{u1, u2} k G _inst_1 _inst_2)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} G) (Set.{u2} G) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} G) (Set.{u2} G) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} G) (Set.{u2} G) (Finset.Set.hasCoeT.{u2} G))) (Finsupp.support.{u2, u1} G k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) f))))
but is expected to have type
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : AddZeroClass.{u2} G] (f : AddMonoidAlgebra.{u1, u2} k G _inst_1), Membership.mem.{max u1 u2, max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (Submodule.{u1, max u1 u2} k (AddMonoidAlgebra.{u1, u2} k G _inst_1) _inst_1 (AddMonoidAlgebra.addCommMonoid.{u1, u2} k G _inst_1) (AddMonoidAlgebra.module.{u1, u2, u1} k G k _inst_1 _inst_1 (Semiring.toModule.{u1} k _inst_1))) (SetLike.instMembership.{max u1 u2, max u1 u2} (Submodule.{u1, max u1 u2} k (AddMonoidAlgebra.{u1, u2} k G _inst_1) _inst_1 (AddMonoidAlgebra.addCommMonoid.{u1, u2} k G _inst_1) (AddMonoidAlgebra.module.{u1, u2, u1} k G k _inst_1 _inst_1 (Semiring.toModule.{u1} k _inst_1))) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (Submodule.setLike.{u1, max u1 u2} k (AddMonoidAlgebra.{u1, u2} k G _inst_1) _inst_1 (AddMonoidAlgebra.addCommMonoid.{u1, u2} k G _inst_1) (AddMonoidAlgebra.module.{u1, u2, u1} k G k _inst_1 _inst_1 (Semiring.toModule.{u1} k _inst_1)))) f (Submodule.span.{u1, max u1 u2} k (AddMonoidAlgebra.{u1, u2} k G _inst_1) _inst_1 (AddMonoidAlgebra.addCommMonoid.{u1, u2} k G _inst_1) (AddMonoidAlgebra.module.{u1, u2, u1} k G k _inst_1 _inst_1 (Semiring.toModule.{u1} k _inst_1)) (Set.image.{u2, max u1 u2} (Multiplicative.{u2} G) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (FunLike.coe.{max (succ u1) (succ u2), succ u2, max (succ u1) (succ u2)} (MonoidHom.{u2, max u2 u1} (Multiplicative.{u2} G) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (Multiplicative.mulOneClass.{u2} G _inst_2) (MulZeroOneClass.toMulOneClass.{max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.nonAssocSemiring.{u1, u2} k G _inst_1 _inst_2)))) (Multiplicative.{u2} G) (fun (_x : Multiplicative.{u2} G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{u2} G) => AddMonoidAlgebra.{u1, u2} k G _inst_1) _x) (MulHomClass.toFunLike.{max u1 u2, u2, max u1 u2} (MonoidHom.{u2, max u2 u1} (Multiplicative.{u2} G) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (Multiplicative.mulOneClass.{u2} G _inst_2) (MulZeroOneClass.toMulOneClass.{max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.nonAssocSemiring.{u1, u2} k G _inst_1 _inst_2)))) (Multiplicative.{u2} G) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (MulOneClass.toMul.{u2} (Multiplicative.{u2} G) (Multiplicative.mulOneClass.{u2} G _inst_2)) (MulOneClass.toMul.{max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (MulZeroOneClass.toMulOneClass.{max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.nonAssocSemiring.{u1, u2} k G _inst_1 _inst_2)))) (MonoidHomClass.toMulHomClass.{max u1 u2, u2, max u1 u2} (MonoidHom.{u2, max u2 u1} (Multiplicative.{u2} G) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (Multiplicative.mulOneClass.{u2} G _inst_2) (MulZeroOneClass.toMulOneClass.{max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.nonAssocSemiring.{u1, u2} k G _inst_1 _inst_2)))) (Multiplicative.{u2} G) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (Multiplicative.mulOneClass.{u2} G _inst_2) (MulZeroOneClass.toMulOneClass.{max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.nonAssocSemiring.{u1, u2} k G _inst_1 _inst_2))) (MonoidHom.monoidHomClass.{u2, max u1 u2} (Multiplicative.{u2} G) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (Multiplicative.mulOneClass.{u2} G _inst_2) (MulZeroOneClass.toMulOneClass.{max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.nonAssocSemiring.{u1, u2} k G _inst_1 _inst_2)))))) (AddMonoidAlgebra.of.{u1, u2} k G _inst_1 _inst_2)) (Finset.toSet.{u2} G (Finsupp.support.{u2, u1} G k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k _inst_1)) f))))
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.mem_span_support AddMonoidAlgebra.mem_span_supportₓ'. -/
/-- An element of `add_monoid_algebra k G` is in the submodule generated by its support. -/
theorem mem_span_support [AddZeroClass G] (f : AddMonoidAlgebra k G) :
    f ∈ Submodule.span k (of k G '' (f.support : Set G)) := by
  rw [of, MonoidHom.coe_mk, ← Finsupp.supported_eq_span_single, Finsupp.mem_supported]
#align add_monoid_algebra.mem_span_support AddMonoidAlgebra.mem_span_support

/- warning: add_monoid_algebra.mem_span_support' -> AddMonoidAlgebra.mem_span_support' is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] (f : AddMonoidAlgebra.{u1, u2} k G _inst_1), Membership.Mem.{max u2 u1, max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (Submodule.{u1, max u2 u1} k (AddMonoidAlgebra.{u1, u2} k G _inst_1) _inst_1 (AddMonoidAlgebra.addCommMonoid.{u2, u1} k G _inst_1) (AddMonoidAlgebra.module.{u1, u2, u1} k G k _inst_1 _inst_1 (Semiring.toModule.{u1} k _inst_1))) (SetLike.hasMem.{max u2 u1, max u2 u1} (Submodule.{u1, max u2 u1} k (AddMonoidAlgebra.{u1, u2} k G _inst_1) _inst_1 (AddMonoidAlgebra.addCommMonoid.{u2, u1} k G _inst_1) (AddMonoidAlgebra.module.{u1, u2, u1} k G k _inst_1 _inst_1 (Semiring.toModule.{u1} k _inst_1))) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (Submodule.setLike.{u1, max u2 u1} k (AddMonoidAlgebra.{u1, u2} k G _inst_1) _inst_1 (AddMonoidAlgebra.addCommMonoid.{u2, u1} k G _inst_1) (AddMonoidAlgebra.module.{u1, u2, u1} k G k _inst_1 _inst_1 (Semiring.toModule.{u1} k _inst_1)))) f (Submodule.span.{u1, max u2 u1} k (AddMonoidAlgebra.{u1, u2} k G _inst_1) _inst_1 (AddMonoidAlgebra.addCommMonoid.{u2, u1} k G _inst_1) (AddMonoidAlgebra.module.{u1, u2, u1} k G k _inst_1 _inst_1 (Semiring.toModule.{u1} k _inst_1)) (Set.image.{u2, max u2 u1} G (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.of'.{u1, u2} k G _inst_1) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} G) (Set.{u2} G) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} G) (Set.{u2} G) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} G) (Set.{u2} G) (Finset.Set.hasCoeT.{u2} G))) (Finsupp.support.{u2, u1} G k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) f))))
but is expected to have type
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] (f : AddMonoidAlgebra.{u1, u2} k G _inst_1), Membership.mem.{max u1 u2, max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (Submodule.{u1, max u1 u2} k (AddMonoidAlgebra.{u1, u2} k G _inst_1) _inst_1 (AddMonoidAlgebra.addCommMonoid.{u1, u2} k G _inst_1) (AddMonoidAlgebra.module.{u1, u2, u1} k G k _inst_1 _inst_1 (Semiring.toModule.{u1} k _inst_1))) (SetLike.instMembership.{max u1 u2, max u1 u2} (Submodule.{u1, max u1 u2} k (AddMonoidAlgebra.{u1, u2} k G _inst_1) _inst_1 (AddMonoidAlgebra.addCommMonoid.{u1, u2} k G _inst_1) (AddMonoidAlgebra.module.{u1, u2, u1} k G k _inst_1 _inst_1 (Semiring.toModule.{u1} k _inst_1))) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (Submodule.setLike.{u1, max u1 u2} k (AddMonoidAlgebra.{u1, u2} k G _inst_1) _inst_1 (AddMonoidAlgebra.addCommMonoid.{u1, u2} k G _inst_1) (AddMonoidAlgebra.module.{u1, u2, u1} k G k _inst_1 _inst_1 (Semiring.toModule.{u1} k _inst_1)))) f (Submodule.span.{u1, max u1 u2} k (AddMonoidAlgebra.{u1, u2} k G _inst_1) _inst_1 (AddMonoidAlgebra.addCommMonoid.{u1, u2} k G _inst_1) (AddMonoidAlgebra.module.{u1, u2, u1} k G k _inst_1 _inst_1 (Semiring.toModule.{u1} k _inst_1)) (Set.image.{u2, max u1 u2} G (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.of'.{u1, u2} k G _inst_1) (Finset.toSet.{u2} G (Finsupp.support.{u2, u1} G k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k _inst_1)) f))))
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.mem_span_support' AddMonoidAlgebra.mem_span_support'ₓ'. -/
/-- An element of `add_monoid_algebra k G` is in the subalgebra generated by its support, using
unbundled inclusion. -/
theorem mem_span_support' (f : AddMonoidAlgebra k G) :
    f ∈ Submodule.span k (of' k G '' (f.support : Set G)) := by
  rw [of', ← Finsupp.supported_eq_span_single, Finsupp.mem_supported]
#align add_monoid_algebra.mem_span_support' AddMonoidAlgebra.mem_span_support'

end Span

end AddMonoidAlgebra

