import Mathbin.Algebra.BigOperators.Finsupp 
import Mathbin.LinearAlgebra.Finsupp 
import Mathbin.Algebra.NonUnitalAlgHom

/-!
# Monoid algebras

When the domain of a `finsupp` has a multiplicative or additive structure, we can define
a convolution product. To mathematicians this structure is known as the "monoid algebra",
i.e. the finite formal linear combinations over a given semiring of elements of the monoid.
The "group ring" ℤ[G] or the "group algebra" k[G] are typical uses.

In fact the construction of the "monoid algebra" makes sense when `G` is not even a monoid, but
merely a magma, i.e., when `G` carries a multiplication which is not required to satisfy any
conditions at all. In this case the construction yields a not-necessarily-unital,
not-necessarily-associative algebra but it is still adjoint to the forgetful functor from such
algebras to magmas, and we prove this as `monoid_algebra.lift_magma`.

In this file we define `monoid_algebra k G := G →₀ k`, and `add_monoid_algebra k G`
in the same way, and then define the convolution product on these.

When the domain is additive, this is used to define polynomials:
```
polynomial α := add_monoid_algebra ℕ α
mv_polynomial σ α := add_monoid_algebra (σ →₀ ℕ) α
```

When the domain is multiplicative, e.g. a group, this will be used to define the group ring.

## Implementation note
Unfortunately because additive and multiplicative structures both appear in both cases,
it doesn't appear to be possible to make much use of `to_additive`, and we just settle for
saying everything twice.

Similarly, I attempted to just define
`add_monoid_algebra k G := monoid_algebra k (multiplicative G)`, but the definitional equality
`multiplicative G = G` leaks through everywhere, and seems impossible to use.
-/


noncomputable theory

open_locale Classical BigOperators

open Finset Finsupp

universe u₁ u₂ u₃

variable(k : Type u₁)(G : Type u₂)

/-! ### Multiplicative monoids -/


section 

variable[Semiringₓ k]

-- error in Algebra.MonoidAlgebra.Basic: ././Mathport/Syntax/Translate/Basic.lean:704:9: unsupported derive handler inhabited
/--
The monoid algebra over a semiring `k` generated by the monoid `G`.
It is the type of finite formal `k`-linear combinations of terms of `G`,
endowed with the convolution product.
-/ @[derive #["[", expr inhabited, ",", expr add_comm_monoid, "]"]] def monoid_algebra : Type max u₁ u₂ :=
«expr →₀ »(G, k)

instance  : CoeFun (MonoidAlgebra k G) fun _ => G → k :=
  Finsupp.hasCoeToFun

end 

namespace MonoidAlgebra

variable{k G}

section Mul

variable[Semiringₓ k][Mul G]

/-- The product of `f g : monoid_algebra k G` is the finitely supported function
  whose value at `a` is the sum of `f x * g y` over all pairs `x, y`
  such that `x * y = a`. (Think of the group ring of a group.) -/
instance  : Mul (MonoidAlgebra k G) :=
  ⟨fun f g => f.sum$ fun a₁ b₁ => g.sum$ fun a₂ b₂ => single (a₁*a₂) (b₁*b₂)⟩

theorem mul_def {f g : MonoidAlgebra k G} : (f*g) = (f.sum$ fun a₁ b₁ => g.sum$ fun a₂ b₂ => single (a₁*a₂) (b₁*b₂)) :=
  rfl

instance  : NonUnitalNonAssocSemiring (MonoidAlgebra k G) :=
  { Finsupp.addCommMonoid with zero := 0, mul := ·*·, add := ·+·,
    left_distrib :=
      fun f g h =>
        by 
          simp only [mul_def, sum_add_index, mul_addₓ, mul_zero, single_zero, single_add, eq_self_iff_true,
            forall_true_iff, forall_3_true_iff, sum_add],
    right_distrib :=
      fun f g h =>
        by 
          simp only [mul_def, sum_add_index, add_mulₓ, zero_mul, single_zero, single_add, eq_self_iff_true,
            forall_true_iff, forall_3_true_iff, sum_zero, sum_add],
    zero_mul :=
      fun f =>
        by 
          simp only [mul_def, sum_zero_index],
    mul_zero :=
      fun f =>
        by 
          simp only [mul_def, sum_zero_index, sum_zero] }

end Mul

section Semigroupₓ

variable[Semiringₓ k][Semigroupₓ G]

instance  : NonUnitalSemiring (MonoidAlgebra k G) :=
  { MonoidAlgebra.nonUnitalNonAssocSemiring with zero := 0, mul := ·*·, add := ·+·,
    mul_assoc :=
      fun f g h =>
        by 
          simp only [mul_def, sum_sum_index, sum_zero_index, sum_add_index, sum_single_index, single_zero, single_add,
            eq_self_iff_true, forall_true_iff, forall_3_true_iff, add_mulₓ, mul_addₓ, add_assocₓ, mul_assocₓ, zero_mul,
            mul_zero, sum_zero, sum_add] }

end Semigroupₓ

section HasOne

variable[Semiringₓ k][HasOne G]

/-- The unit of the multiplication is `single 1 1`, i.e. the function
  that is `1` at `1` and zero elsewhere. -/
instance  : HasOne (MonoidAlgebra k G) :=
  ⟨single 1 1⟩

theorem one_def : (1 : MonoidAlgebra k G) = single 1 1 :=
  rfl

end HasOne

section MulOneClass

variable[Semiringₓ k][MulOneClass G]

instance  : NonAssocSemiring (MonoidAlgebra k G) :=
  { MonoidAlgebra.nonUnitalNonAssocSemiring with one := 1, mul := ·*·, zero := 0, add := ·+·,
    one_mul :=
      fun f =>
        by 
          simp only [mul_def, one_def, sum_single_index, zero_mul, single_zero, sum_zero, zero_addₓ, one_mulₓ,
            sum_single],
    mul_one :=
      fun f =>
        by 
          simp only [mul_def, one_def, sum_single_index, mul_zero, single_zero, sum_zero, add_zeroₓ, mul_oneₓ,
            sum_single] }

variable{R : Type _}[Semiringₓ R]

-- error in Algebra.MonoidAlgebra.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
/-- A non-commutative version of `monoid_algebra.lift`: given a additive homomorphism `f : k →+ R`
and a multiplicative monoid homomorphism `g : G →* R`, returns the additive homomorphism from
`monoid_algebra k G` such that `lift_nc f g (single a b) = f b * g a`. If `f` is a ring homomorphism
and the range of either `f` or `g` is in center of `R`, then the result is a ring homomorphism.  If
`R` is a `k`-algebra and `f = algebra_map k R`, then the result is an algebra homomorphism called
`monoid_algebra.lift`. -/
def lift_nc (f : «expr →+ »(k, R)) (g : «expr →* »(G, R)) : «expr →+ »(monoid_algebra k G, R) :=
lift_add_hom (λ x : G, (add_monoid_hom.mul_right (g x)).comp f)

@[simp]
theorem lift_nc_single (f : k →+ R) (g : G →* R) (a : G) (b : k) : lift_nc f g (single a b) = f b*g a :=
  lift_add_hom_apply_single _ _ _

@[simp]
theorem lift_nc_one (f : k →+* R) (g : G →* R) : lift_nc (f : k →+ R) g 1 = 1 :=
  by 
    simp [one_def]

theorem lift_nc_mul (f : k →+* R) (g : G →* R) (a b : MonoidAlgebra k G)
  (h_comm : ∀ {x y}, y ∈ a.support → Commute (f (b x)) (g y)) :
  lift_nc (f : k →+ R) g (a*b) = lift_nc (f : k →+ R) g a*lift_nc (f : k →+ R) g b :=
  by 
    convRHS => rw [←sum_single a, ←sum_single b]
    simpRw [mul_def, (lift_nc _ g).map_finsupp_sum, lift_nc_single, Finsupp.sum_mul, Finsupp.mul_sum]
    refine' Finset.sum_congr rfl fun y hy => Finset.sum_congr rfl fun x hx => _ 
    simp [mul_assocₓ, (h_comm hy).left_comm]

end MulOneClass

/-! #### Semiring structure -/


section Semiringₓ

variable[Semiringₓ k][Monoidₓ G]

instance  : Semiringₓ (MonoidAlgebra k G) :=
  { MonoidAlgebra.nonUnitalSemiring, MonoidAlgebra.nonAssocSemiring with one := 1, mul := ·*·, zero := 0, add := ·+· }

variable{R : Type _}[Semiringₓ R]

/-- `lift_nc` as a `ring_hom`, for when `f x` and `g y` commute -/
def lift_nc_ring_hom (f : k →+* R) (g : G →* R) (h_comm : ∀ x y, Commute (f x) (g y)) : MonoidAlgebra k G →+* R :=
  { lift_nc (f : k →+ R) g with toFun := lift_nc (f : k →+ R) g, map_one' := lift_nc_one _ _,
    map_mul' := fun a b => lift_nc_mul _ _ _ _$ fun _ _ _ => h_comm _ _ }

end Semiringₓ

instance  [CommSemiringₓ k] [CommMonoidₓ G] : CommSemiringₓ (MonoidAlgebra k G) :=
  { MonoidAlgebra.semiring with
    mul_comm :=
      fun f g =>
        by 
          simp only [mul_def, Finsupp.sum, mul_commₓ]
          rw [Finset.sum_comm]
          simp only [mul_commₓ] }

instance  [Semiringₓ k] [Nontrivial k] [Nonempty G] : Nontrivial (MonoidAlgebra k G) :=
  Finsupp.nontrivial

/-! #### Derived instances -/


section DerivedInstances

instance  [Semiringₓ k] [Subsingleton k] : Unique (MonoidAlgebra k G) :=
  Finsupp.uniqueOfRight

instance  [Ringₓ k] : AddGroupₓ (MonoidAlgebra k G) :=
  Finsupp.addGroup

instance  [Ringₓ k] [Monoidₓ G] : Ringₓ (MonoidAlgebra k G) :=
  { MonoidAlgebra.semiring with neg := Neg.neg, add_left_neg := add_left_negₓ }

instance  [CommRingₓ k] [CommMonoidₓ G] : CommRingₓ (MonoidAlgebra k G) :=
  { MonoidAlgebra.ring with mul_comm := mul_commₓ }

variable{R S : Type _}

instance  [Monoidₓ R] [Semiringₓ k] [DistribMulAction R k] : HasScalar R (MonoidAlgebra k G) :=
  Finsupp.hasScalar

instance  [Monoidₓ R] [Semiringₓ k] [DistribMulAction R k] : DistribMulAction R (MonoidAlgebra k G) :=
  Finsupp.distribMulAction G k

instance  [Semiringₓ R] [Semiringₓ k] [Module R k] : Module R (MonoidAlgebra k G) :=
  Finsupp.module G k

instance  [Monoidₓ R] [Semiringₓ k] [DistribMulAction R k] [HasFaithfulScalar R k] [Nonempty G] :
  HasFaithfulScalar R (MonoidAlgebra k G) :=
  Finsupp.has_faithful_scalar

instance  [Monoidₓ R] [Monoidₓ S] [Semiringₓ k] [DistribMulAction R k] [DistribMulAction S k] [HasScalar R S]
  [IsScalarTower R S k] : IsScalarTower R S (MonoidAlgebra k G) :=
  Finsupp.is_scalar_tower G k

instance  [Monoidₓ R] [Monoidₓ S] [Semiringₓ k] [DistribMulAction R k] [DistribMulAction S k] [SmulCommClass R S k] :
  SmulCommClass R S (MonoidAlgebra k G) :=
  Finsupp.smul_comm_class G k

instance comap_distrib_mul_action_self [Groupₓ G] [Semiringₓ k] : DistribMulAction G (MonoidAlgebra k G) :=
  Finsupp.comapDistribMulActionSelf

end DerivedInstances

section MiscTheorems

variable[Semiringₓ k]

attribute [local reducible] MonoidAlgebra

theorem mul_apply [Mul G] (f g : MonoidAlgebra k G) (x : G) :
  (f*g) x = (f.sum$ fun a₁ b₁ => g.sum$ fun a₂ b₂ => if (a₁*a₂) = x then b₁*b₂ else 0) :=
  by 
    rw [mul_def]
    simp only [Finsupp.sum_apply, single_apply]

-- error in Algebra.MonoidAlgebra.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem mul_apply_antidiagonal
[has_mul G]
(f g : monoid_algebra k G)
(x : G)
(s : finset «expr × »(G, G))
(hs : ∀
 {p : «expr × »(G, G)}, «expr ↔ »(«expr ∈ »(p, s), «expr = »(«expr * »(p.1, p.2), x))) : «expr = »(«expr * »(f, g) x, «expr∑ in , »((p), s, «expr * »(f p.1, g p.2))) :=
let F : «expr × »(G, G) → k := λ p, if «expr = »(«expr * »(p.1, p.2), x) then «expr * »(f p.1, g p.2) else 0 in
calc
  «expr = »(«expr * »(f, g) x, «expr∑ in , »((a₁), f.support, «expr∑ in , »((a₂), g.support, F (a₁, a₂)))) : mul_apply f g x
  «expr = »(..., «expr∑ in , »((p), f.support.product g.support, F p)) : finset.sum_product.symm
  «expr = »(..., «expr∑ in , »((p), (f.support.product g.support).filter (λ
     p : «expr × »(G, G), «expr = »(«expr * »(p.1, p.2), x)), «expr * »(f p.1, g p.2))) : (finset.sum_filter _ _).symm
  «expr = »(..., «expr∑ in , »((p), s.filter (λ
     p : «expr × »(G, G), «expr ∧ »(«expr ∈ »(p.1, f.support), «expr ∈ »(p.2, g.support))), «expr * »(f p.1, g p.2))) : sum_congr (by { ext [] [] [],
     simp [] [] ["only"] ["[", expr mem_filter, ",", expr mem_product, ",", expr hs, ",", expr and_comm, "]"] [] [] }) (λ
   _ _, rfl)
  «expr = »(..., «expr∑ in , »((p), s, «expr * »(f p.1, g p.2))) : «expr $ »(sum_subset (filter_subset _ _), λ
   p hps hp, begin
     simp [] [] ["only"] ["[", expr mem_filter, ",", expr mem_support_iff, ",", expr not_and, ",", expr not_not, "]"] [] ["at", ident hp, "⊢"],
     by_cases [expr h1, ":", expr «expr = »(f p.1, 0)],
     { rw ["[", expr h1, ",", expr zero_mul, "]"] [] },
     { rw ["[", expr hp hps h1, ",", expr mul_zero, "]"] [] }
   end)

theorem support_mul [Mul G] (a b : MonoidAlgebra k G) :
  (a*b).Support ⊆ a.support.bUnion fun a₁ => b.support.bUnion$ fun a₂ => {a₁*a₂} :=
  subset.trans support_sum$
    bUnion_mono$ fun a₁ _ => subset.trans support_sum$ bUnion_mono$ fun a₂ _ => support_single_subset

@[simp]
theorem single_mul_single [Mul G] {a₁ a₂ : G} {b₁ b₂ : k} :
  ((single a₁ b₁ : MonoidAlgebra k G)*single a₂ b₂) = single (a₁*a₂) (b₁*b₂) :=
  (sum_single_index
        (by 
          simp only [zero_mul, single_zero, sum_zero])).trans
    (sum_single_index
      (by 
        rw [mul_zero, single_zero]))

@[simp]
theorem single_pow [Monoidₓ G] {a : G} {b : k} :
  ∀ (n : ℕ), (single a b : MonoidAlgebra k G) ^ n = single (a ^ n) (b ^ n)
| 0 =>
  by 
    simp only [pow_zeroₓ]
    rfl
| n+1 =>
  by 
    simp only [pow_succₓ, single_pow n, single_mul_single]

section 

/-- Like `finsupp.map_domain_add`, but for the convolutive multiplication we define in this file -/
theorem map_domain_mul {α : Type _} {β : Type _} {α₂ : Type _} [Semiringₓ β] [Mul α] [Mul α₂] {x y : MonoidAlgebra β α}
  (f : MulHom α α₂) :
  (map_domain f (x*y : MonoidAlgebra β α) : MonoidAlgebra β α₂) =
    (map_domain f x*map_domain f y : MonoidAlgebra β α₂) :=
  by 
    simpRw [mul_def, map_domain_sum, map_domain_single, f.map_mul]
    rw [Finsupp.sum_map_domain_index]
    ·
      congr 
      ext a b 
      rw [Finsupp.sum_map_domain_index]
      ·
        simp 
      ·
        simp [mul_addₓ]
    ·
      simp 
    ·
      simp [add_mulₓ]

variable(k G)

/-- The embedding of a magma into its magma algebra. -/
@[simps]
def of_magma [Mul G] : MulHom G (MonoidAlgebra k G) :=
  { toFun := fun a => single a 1,
    map_mul' :=
      fun a b =>
        by 
          simp only [mul_def, mul_oneₓ, sum_single_index, single_eq_zero, mul_zero] }

/-- The embedding of a unital magma into its magma algebra. -/
@[simps]
def of [MulOneClass G] : G →* MonoidAlgebra k G :=
  { of_magma k G with toFun := fun a => single a 1, map_one' := rfl }

end 

theorem of_injective [MulOneClass G] [Nontrivial k] : Function.Injective (of k G) :=
  fun a b h =>
    by 
      simpa using (single_eq_single_iff _ _ _ _).mp h

theorem mul_single_apply_aux [Mul G] (f : MonoidAlgebra k G) {r : k} {x y z : G} (H : ∀ a, (a*x) = z ↔ a = y) :
  (f*single x r) z = f y*r :=
  have A : ∀ a₁ b₁, ((single x r).Sum fun a₂ b₂ => ite ((a₁*a₂) = z) (b₁*b₂) 0) = ite ((a₁*x) = z) (b₁*r) 0 :=
    fun a₁ b₁ =>
      sum_single_index$
        by 
          simp 
  calc (f*single x r) z = Sum f fun a b => if a = y then b*r else 0 :=
    by 
      simp only [mul_apply, A, H]
      congr 
      funext 
      splitIfs <;> rfl 
    _ = if y ∈ f.support then f y*r else 0 := f.support.sum_ite_eq' _ _ 
    _ = f y*r :=
    by 
      splitIfs with h <;> simp  at h <;> simp [h]
    

theorem mul_single_one_apply [MulOneClass G] (f : MonoidAlgebra k G) (r : k) (x : G) : (f*single 1 r) x = f x*r :=
  f.mul_single_apply_aux$
    fun a =>
      by 
        rw [mul_oneₓ]

theorem support_mul_single [RightCancelSemigroup G] (f : MonoidAlgebra k G) (r : k) (hr : ∀ y, (y*r) = 0 ↔ y = 0)
  (x : G) : (f*single x r).Support = f.support.map (mulRightEmbedding x) :=
  by 
    ext y 
    simp only [mem_support_iff, mem_map, exists_prop, mul_right_embedding_apply]
    byCases' H : ∃ a, (a*x) = y
    ·
      rcases H with ⟨a, rfl⟩
      rw [mul_single_apply_aux f fun _ => mul_left_injₓ x]
      simp [hr]
    ·
      pushNeg  at H 
      simp [mul_apply, H]

theorem single_mul_apply_aux [Mul G] (f : MonoidAlgebra k G) {r : k} {x y z : G} (H : ∀ a, (x*a) = y ↔ a = z) :
  (single x r*f) y = r*f z :=
  have  : (f.sum fun a b => ite ((x*a) = y) (0*b) 0) = 0 :=
    by 
      simp 
  calc (single x r*f) y = Sum f fun a b => ite ((x*a) = y) (r*b) 0 := (mul_apply _ _ _).trans$ sum_single_index this 
    _ = f.sum fun a b => ite (a = z) (r*b) 0 :=
    by 
      simp only [H]
      congr with g s 
      splitIfs <;> rfl 
    _ = if z ∈ f.support then r*f z else 0 := f.support.sum_ite_eq' _ _ 
    _ = _ :=
    by 
      splitIfs with h <;> simp  at h <;> simp [h]
    

theorem single_one_mul_apply [MulOneClass G] (f : MonoidAlgebra k G) (r : k) (x : G) : (single 1 r*f) x = r*f x :=
  f.single_mul_apply_aux$
    fun a =>
      by 
        rw [one_mulₓ]

theorem support_single_mul [LeftCancelSemigroup G] (f : MonoidAlgebra k G) (r : k) (hr : ∀ y, (r*y) = 0 ↔ y = 0)
  (x : G) : (single x r*f).Support = f.support.map (mulLeftEmbedding x) :=
  by 
    ext y 
    simp only [mem_support_iff, mem_map, exists_prop, mul_left_embedding_apply]
    byCases' H : ∃ a, (x*a) = y
    ·
      rcases H with ⟨a, rfl⟩
      rw [single_mul_apply_aux f fun _ => mul_right_injₓ x]
      simp [hr]
    ·
      pushNeg  at H 
      simp [mul_apply, H]

theorem lift_nc_smul [MulOneClass G] {R : Type _} [Semiringₓ R] (f : k →+* R) (g : G →* R) (c : k)
  (φ : MonoidAlgebra k G) : lift_nc (f : k →+ R) g (c • φ) = f c*lift_nc (f : k →+ R) g φ :=
  by 
    suffices  :
      (lift_nc («expr↑ » f) g).comp (smulAddHom k (MonoidAlgebra k G) c) =
        (AddMonoidHom.mulLeft (f c)).comp (lift_nc («expr↑ » f) g)
    exact AddMonoidHom.congr_fun this φ 
    ext a b 
    simp [mul_assocₓ]

end MiscTheorems

/-! #### Non-unital, non-associative algebra structure -/


section NonUnitalNonAssocAlgebra

variable{R : Type _}(k)[Semiringₓ R][Semiringₓ k][DistribMulAction R k][Mul G]

instance is_scalar_tower_self [IsScalarTower R k k] : IsScalarTower R (MonoidAlgebra k G) (MonoidAlgebra k G) :=
  ⟨fun t a b =>
      by 
        ext m 
        simp only [mul_apply, Finsupp.smul_sum, smul_ite, smul_mul_assoc, sum_smul_index', zero_mul, if_t_t,
          implies_true_iff, eq_self_iff_true, sum_zero, coe_smul, smul_eq_mul, Pi.smul_apply, smul_zero]⟩

/-- Note that if `k` is a `comm_semiring` then we have `smul_comm_class k k k` and so we can take
`R = k` in the below. In other words, if the coefficients are commutative amongst themselves, they
also commute with the algebra multiplication. -/
instance smul_comm_class_self [SmulCommClass R k k] : SmulCommClass R (MonoidAlgebra k G) (MonoidAlgebra k G) :=
  ⟨fun t a b =>
      by 
        ext m 
        simp only [mul_apply, Finsupp.sum, Finset.smul_sum, smul_ite, mul_smul_comm, sum_smul_index', implies_true_iff,
          eq_self_iff_true, coe_smul, ite_eq_right_iff, smul_eq_mul, Pi.smul_apply, mul_zero, smul_zero]⟩

-- error in Algebra.MonoidAlgebra.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
instance smul_comm_class_symm_self
[smul_comm_class k R k] : smul_comm_class (monoid_algebra k G) R (monoid_algebra k G) :=
⟨λ t a b, by { haveI [] [] [":=", expr smul_comm_class.symm k R k], rw ["<-", expr smul_comm] [] }⟩

variable{A : Type u₃}[NonUnitalNonAssocSemiring A]

/-- A non_unital `k`-algebra homomorphism from `monoid_algebra k G` is uniquely defined by its
values on the functions `single a 1`. -/
theorem non_unital_alg_hom_ext [DistribMulAction k A] {φ₁ φ₂ : NonUnitalAlgHom k (MonoidAlgebra k G) A}
  (h : ∀ x, φ₁ (single x 1) = φ₂ (single x 1)) : φ₁ = φ₂ :=
  NonUnitalAlgHom.to_distrib_mul_action_hom_injective$
    Finsupp.distrib_mul_action_hom_ext'$ fun a => DistribMulActionHom.ext_ring (h a)

/-- See note [partially-applied ext lemmas]. -/
@[ext]
theorem non_unital_alg_hom_ext' [DistribMulAction k A] {φ₁ φ₂ : NonUnitalAlgHom k (MonoidAlgebra k G) A}
  (h : φ₁.to_mul_hom.comp (of_magma k G) = φ₂.to_mul_hom.comp (of_magma k G)) : φ₁ = φ₂ :=
  non_unital_alg_hom_ext k$ MulHom.congr_fun h

-- error in Algebra.MonoidAlgebra.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The functor `G ↦ monoid_algebra k G`, from the category of magmas to the category of non-unital,
non-associative algebras over `k` is adjoint to the forgetful functor in the other direction. -/
@[simps #[]]
def lift_magma
[module k A]
[is_scalar_tower k A A]
[smul_comm_class k A A] : «expr ≃ »(mul_hom G A, non_unital_alg_hom k (monoid_algebra k G) A) :=
{ to_fun := λ
  f, { to_fun := λ a, a.sum (λ m t, «expr • »(t, f m)),
    map_smul' := λ t' a, begin
      rw ["[", expr finsupp.smul_sum, ",", expr sum_smul_index', "]"] [],
      { simp_rw [expr smul_assoc] [] },
      { intros [ident m],
        exact [expr zero_smul k (f m)] }
    end,
    map_mul' := λ a₁ a₂, begin
      let [ident g] [":", expr G → k → A] [":=", expr λ m t, «expr • »(t, f m)],
      have [ident h₁] [":", expr ∀ m, «expr = »(g m 0, 0)] [],
      { intros [],
        exact [expr zero_smul k (f m)] },
      have [ident h₂] [":", expr ∀ (m) (t₁ t₂ : k), «expr = »(g m «expr + »(t₁, t₂), «expr + »(g m t₁, g m t₂))] [],
      { intros [],
        rw ["<-", expr add_smul] [] },
      simp_rw ["[", expr finsupp.mul_sum, ",", expr finsupp.sum_mul, ",", expr smul_mul_smul, ",", "<-", expr f.map_mul, ",", expr mul_def, ",", expr sum_comm a₂ a₁, ",", expr sum_sum_index h₁ h₂, ",", expr sum_single_index (h₁ _), "]"] []
    end,
    ..lift_add_hom (λ x, (smul_add_hom k A).flip (f x)) },
  inv_fun := λ F, F.to_mul_hom.comp (of_magma k G),
  left_inv := λ f, by { ext [] [ident m] [],
    simp [] [] ["only"] ["[", expr non_unital_alg_hom.coe_mk, ",", expr of_magma_apply, ",", expr non_unital_alg_hom.to_mul_hom_eq_coe, ",", expr sum_single_index, ",", expr function.comp_app, ",", expr one_smul, ",", expr zero_smul, ",", expr mul_hom.coe_comp, ",", expr non_unital_alg_hom.coe_to_mul_hom, "]"] [] [] },
  right_inv := λ F, by { ext [] [ident m] [],
    simp [] [] ["only"] ["[", expr non_unital_alg_hom.coe_mk, ",", expr of_magma_apply, ",", expr non_unital_alg_hom.to_mul_hom_eq_coe, ",", expr sum_single_index, ",", expr function.comp_app, ",", expr one_smul, ",", expr zero_smul, ",", expr mul_hom.coe_comp, ",", expr non_unital_alg_hom.coe_to_mul_hom, "]"] [] [] } }

end NonUnitalNonAssocAlgebra

/-! #### Algebra structure -/


section Algebra

attribute [local reducible] MonoidAlgebra

theorem single_one_comm [CommSemiringₓ k] [MulOneClass G] (r : k) (f : MonoidAlgebra k G) :
  (single 1 r*f) = f*single 1 r :=
  by 
    ext 
    rw [single_one_mul_apply, mul_single_one_apply, mul_commₓ]

/-- `finsupp.single 1` as a `ring_hom` -/
@[simps]
def single_one_ring_hom [Semiringₓ k] [Monoidₓ G] : k →+* MonoidAlgebra k G :=
  { Finsupp.singleAddHom 1 with map_one' := rfl,
    map_mul' :=
      fun x y =>
        by 
          rw [single_add_hom, single_mul_single, one_mulₓ] }

/-- If two ring homomorphisms from `monoid_algebra k G` are equal on all `single a 1`
and `single 1 b`, then they are equal. -/
theorem ring_hom_ext {R} [Semiringₓ k] [Monoidₓ G] [Semiringₓ R] {f g : MonoidAlgebra k G →+* R}
  (h₁ : ∀ b, f (single 1 b) = g (single 1 b)) (h_of : ∀ a, f (single a 1) = g (single a 1)) : f = g :=
  RingHom.coe_add_monoid_hom_injective$
    add_hom_ext$
      fun a b =>
        by 
          rw [←one_mulₓ a, ←mul_oneₓ b, ←single_mul_single, f.coe_add_monoid_hom, g.coe_add_monoid_hom, f.map_mul,
            g.map_mul, h₁, h_of]

/-- If two ring homomorphisms from `monoid_algebra k G` are equal on all `single a 1`
and `single 1 b`, then they are equal.

See note [partially-applied ext lemmas]. -/
@[ext]
theorem ring_hom_ext' {R} [Semiringₓ k] [Monoidₓ G] [Semiringₓ R] {f g : MonoidAlgebra k G →+* R}
  (h₁ : f.comp single_one_ring_hom = g.comp single_one_ring_hom)
  (h_of : (f : MonoidAlgebra k G →* R).comp (of k G) = (g : MonoidAlgebra k G →* R).comp (of k G)) : f = g :=
  ring_hom_ext (RingHom.congr_fun h₁) (MonoidHom.congr_fun h_of)

/--
The instance `algebra k (monoid_algebra A G)` whenever we have `algebra k A`.

In particular this provides the instance `algebra k (monoid_algebra k G)`.
-/
instance  {A : Type _} [CommSemiringₓ k] [Semiringₓ A] [Algebra k A] [Monoidₓ G] : Algebra k (MonoidAlgebra A G) :=
  { single_one_ring_hom.comp (algebraMap k A) with
    smul_def' :=
      fun r a =>
        by 
          ext 
          simp [single_one_mul_apply, Algebra.smul_def, Pi.smul_apply],
    commutes' :=
      fun r f =>
        by 
          ext 
          simp [single_one_mul_apply, mul_single_one_apply, Algebra.commutes] }

/-- `finsupp.single 1` as a `alg_hom` -/
@[simps]
def single_one_alg_hom {A : Type _} [CommSemiringₓ k] [Semiringₓ A] [Algebra k A] [Monoidₓ G] :
  A →ₐ[k] MonoidAlgebra A G :=
  { single_one_ring_hom with
    commutes' :=
      fun r =>
        by 
          ext 
          simp 
          rfl }

@[simp]
theorem coe_algebra_map {A : Type _} [CommSemiringₓ k] [Semiringₓ A] [Algebra k A] [Monoidₓ G] :
  «expr⇑ » (algebraMap k (MonoidAlgebra A G)) = single 1 ∘ algebraMap k A :=
  rfl

theorem single_eq_algebra_map_mul_of [CommSemiringₓ k] [Monoidₓ G] (a : G) (b : k) :
  single a b = algebraMap k (MonoidAlgebra k G) b*of k G a :=
  by 
    simp 

theorem single_algebra_map_eq_algebra_map_mul_of {A : Type _} [CommSemiringₓ k] [Semiringₓ A] [Algebra k A] [Monoidₓ G]
  (a : G) (b : k) : single a (algebraMap k A b) = algebraMap k (MonoidAlgebra A G) b*of A G a :=
  by 
    simp 

theorem induction_on [Semiringₓ k] [Monoidₓ G] {p : MonoidAlgebra k G → Prop} (f : MonoidAlgebra k G)
  (hM : ∀ g, p (of k G g)) (hadd : ∀ (f g : MonoidAlgebra k G), p f → p g → p (f+g))
  (hsmul : ∀ (r : k) f, p f → p (r • f)) : p f :=
  by 
    refine' Finsupp.induction_linear f _ (fun f g hf hg => hadd f g hf hg) fun g r => _
    ·
      simpa using hsmul 0 (of k G 1) (hM 1)
    ·
      convert hsmul r (of k G g) (hM g)
      simp only [mul_oneₓ, smul_single', of_apply]

end Algebra

section lift

variable{k G}[CommSemiringₓ k][Monoidₓ G]

variable{A : Type u₃}[Semiringₓ A][Algebra k A]{B : Type _}[Semiringₓ B][Algebra k B]

/-- `lift_nc_ring_hom` as a `alg_hom`, for when `f` is an `alg_hom` -/
def lift_nc_alg_hom (f : A →ₐ[k] B) (g : G →* B) (h_comm : ∀ x y, Commute (f x) (g y)) : MonoidAlgebra A G →ₐ[k] B :=
  { lift_nc_ring_hom (f : A →+* B) g h_comm with toFun := lift_nc_ring_hom (f : A →+* B) g h_comm,
    commutes' :=
      by 
        simp [lift_nc_ring_hom] }

/-- A `k`-algebra homomorphism from `monoid_algebra k G` is uniquely defined by its
values on the functions `single a 1`. -/
theorem alg_hom_ext ⦃φ₁ φ₂ : MonoidAlgebra k G →ₐ[k] A⦄ (h : ∀ x, φ₁ (single x 1) = φ₂ (single x 1)) : φ₁ = φ₂ :=
  AlgHom.to_linear_map_injective$ Finsupp.lhom_ext'$ fun a => LinearMap.ext_ring (h a)

/-- See note [partially-applied ext lemmas]. -/
@[ext]
theorem alg_hom_ext' ⦃φ₁ φ₂ : MonoidAlgebra k G →ₐ[k] A⦄
  (h : (φ₁ : MonoidAlgebra k G →* A).comp (of k G) = (φ₂ : MonoidAlgebra k G →* A).comp (of k G)) : φ₁ = φ₂ :=
  alg_hom_ext$ MonoidHom.congr_fun h

variable(k G A)

/-- Any monoid homomorphism `G →* A` can be lifted to an algebra homomorphism
`monoid_algebra k G →ₐ[k] A`. -/
def lift : (G →* A) ≃ (MonoidAlgebra k G →ₐ[k] A) :=
  { invFun := fun f => (f : MonoidAlgebra k G →* A).comp (of k G),
    toFun := fun F => lift_nc_alg_hom (Algebra.ofId k A) F$ fun _ _ => Algebra.commutes _ _,
    left_inv :=
      fun f =>
        by 
          ext 
          simp [lift_nc_alg_hom, lift_nc_ring_hom],
    right_inv :=
      fun F =>
        by 
          ext 
          simp [lift_nc_alg_hom, lift_nc_ring_hom] }

variable{k G A}

theorem lift_apply' (F : G →* A) (f : MonoidAlgebra k G) : lift k G A F f = f.sum fun a b => algebraMap k A b*F a :=
  rfl

theorem lift_apply (F : G →* A) (f : MonoidAlgebra k G) : lift k G A F f = f.sum fun a b => b • F a :=
  by 
    simp only [lift_apply', Algebra.smul_def]

theorem lift_def (F : G →* A) : «expr⇑ » (lift k G A F) = lift_nc ((algebraMap k A : k →+* A) : k →+ A) F :=
  rfl

@[simp]
theorem lift_symm_apply (F : MonoidAlgebra k G →ₐ[k] A) (x : G) : (lift k G A).symm F x = F (single x 1) :=
  rfl

theorem lift_of (F : G →* A) x : lift k G A F (of k G x) = F x :=
  by 
    rw [of_apply, ←lift_symm_apply, Equiv.symm_apply_apply]

@[simp]
theorem lift_single (F : G →* A) a b : lift k G A F (single a b) = b • F a :=
  by 
    rw [lift_def, lift_nc_single, Algebra.smul_def, RingHom.coe_add_monoid_hom]

theorem lift_unique' (F : MonoidAlgebra k G →ₐ[k] A) : F = lift k G A ((F : MonoidAlgebra k G →* A).comp (of k G)) :=
  ((lift k G A).apply_symm_apply F).symm

/-- Decomposition of a `k`-algebra homomorphism from `monoid_algebra k G` by
its values on `F (single a 1)`. -/
theorem lift_unique (F : MonoidAlgebra k G →ₐ[k] A) (f : MonoidAlgebra k G) :
  F f = f.sum fun a b => b • F (single a 1) :=
  by 
    convLHS => rw [lift_unique' F]simp [lift_apply]

end lift

section 

attribute [local reducible] MonoidAlgebra

variable(k)

/-- When `V` is a `k[G]`-module, multiplication by a group element `g` is a `k`-linear map. -/
def group_smul.linear_map [Monoidₓ G] [CommSemiringₓ k] (V : Type u₃) [AddCommMonoidₓ V] [Module k V]
  [Module (MonoidAlgebra k G) V] [IsScalarTower k (MonoidAlgebra k G) V] (g : G) : V →ₗ[k] V :=
  { toFun := fun v => (single g (1 : k) • v : V), map_add' := fun x y => smul_add (single g (1 : k)) x y,
    map_smul' := fun c x => smul_algebra_smul_comm _ _ _ }

@[simp]
theorem group_smul.linear_map_apply [Monoidₓ G] [CommSemiringₓ k] (V : Type u₃) [AddCommMonoidₓ V] [Module k V]
  [Module (MonoidAlgebra k G) V] [IsScalarTower k (MonoidAlgebra k G) V] (g : G) (v : V) :
  (group_smul.linear_map k V g) v = (single g (1 : k) • v : V) :=
  rfl

section 

variable{k}

variable[Monoidₓ
      G][CommSemiringₓ
      k]{V W :
    Type
      u₃}[AddCommMonoidₓ
      V][Module k
      V][Module (MonoidAlgebra k G)
      V][IsScalarTower k (MonoidAlgebra k G)
      V][AddCommMonoidₓ
      W][Module k
      W][Module (MonoidAlgebra k G)
      W][IsScalarTower k (MonoidAlgebra k G)
      W](f : V →ₗ[k] W)(h : ∀ (g : G) (v : V), f (single g (1 : k) • v : V) = (single g (1 : k) • f v : W))

include h

/-- Build a `k[G]`-linear map from a `k`-linear map and evidence that it is `G`-equivariant. -/
def equivariant_of_linear_of_comm : V →ₗ[MonoidAlgebra k G] W :=
  { toFun := f,
    map_add' :=
      fun v v' =>
        by 
          simp ,
    map_smul' :=
      fun c v =>
        by 
          apply Finsupp.induction c
          ·
            simp 
          ·
            intro g r c' nm nz w 
            dsimp  at *
            simp only [add_smul, f.map_add, w, add_left_injₓ, single_eq_algebra_map_mul_of, ←smul_smul]
            erw [algebra_map_smul (MonoidAlgebra k G) r, algebra_map_smul (MonoidAlgebra k G) r, f.map_smul, h g v,
              of_apply]
            all_goals 
              infer_instance }

@[simp]
theorem equivariant_of_linear_of_comm_apply (v : V) : (equivariant_of_linear_of_comm f h) v = f v :=
  rfl

end 

end 

section 

universe ui

variable{ι : Type ui}

attribute [local reducible] MonoidAlgebra

theorem prod_single [CommSemiringₓ k] [CommMonoidₓ G] {s : Finset ι} {a : ι → G} {b : ι → k} :
  (∏i in s, single (a i) (b i)) = single (∏i in s, a i) (∏i in s, b i) :=
  Finset.induction_on s rfl$
    fun a s has ih =>
      by 
        rw [prod_insert has, ih, single_mul_single, prod_insert has, prod_insert has]

end 

section 

variable[Semiringₓ k][Groupₓ G]

attribute [local reducible] MonoidAlgebra

@[simp]
theorem mul_single_apply (f : MonoidAlgebra k G) (r : k) (x y : G) : (f*single x r) y = f (y*x⁻¹)*r :=
  f.mul_single_apply_aux$ fun a => eq_mul_inv_iff_mul_eq.symm

@[simp]
theorem single_mul_apply (r : k) (x : G) (f : MonoidAlgebra k G) (y : G) : (single x r*f) y = r*f (x⁻¹*y) :=
  f.single_mul_apply_aux$ fun z => eq_inv_mul_iff_mul_eq.symm

theorem mul_apply_left (f g : MonoidAlgebra k G) (x : G) : (f*g) x = (f.sum$ fun a b => b*g (a⁻¹*x)) :=
  calc (f*g) x = Sum f fun a b => (single a b*g) x :=
    by 
      rw [←Finsupp.sum_apply, ←Finsupp.sum_mul, f.sum_single]
    _ = _ :=
    by 
      simp only [single_mul_apply, Finsupp.sum]
    

theorem mul_apply_right (f g : MonoidAlgebra k G) (x : G) : (f*g) x = (g.sum$ fun a b => f (x*a⁻¹)*b) :=
  calc (f*g) x = Sum g fun a b => (f*single a b) x :=
    by 
      rw [←Finsupp.sum_apply, ←Finsupp.mul_sum, g.sum_single]
    _ = _ :=
    by 
      simp only [mul_single_apply, Finsupp.sum]
    

end 

section Span

variable[Semiringₓ k][MulOneClass G]

/-- An element of `monoid_algebra R M` is in the subalgebra generated by its support. -/
theorem mem_span_support (f : MonoidAlgebra k G) : f ∈ Submodule.span k (of k G '' (f.support : Set G)) :=
  by 
    rw [of, MonoidHom.coe_mk, ←Finsupp.supported_eq_span_single, Finsupp.mem_supported]

end Span

section Opposite

open Finsupp MulOpposite

variable[Semiringₓ k]

/-- The opposite of an `monoid_algebra R I` equivalent as a ring to
the `monoid_algebra Rᵐᵒᵖ Iᵐᵒᵖ` over the opposite ring, taking elements to their opposite. -/
@[simps (config := { simpRhs := tt })]
protected noncomputable def op_ring_equiv [Monoidₓ G] :
  «expr ᵐᵒᵖ» (MonoidAlgebra k G) ≃+* MonoidAlgebra («expr ᵐᵒᵖ» k) («expr ᵐᵒᵖ» G) :=
  { op_add_equiv.symm.trans$
      (Finsupp.mapRange.addEquiv (op_add_equiv : k ≃+ «expr ᵐᵒᵖ» k)).trans$ Finsupp.domCongr op_equiv with
    map_mul' :=
      by 
        dsimp only [AddEquiv.to_fun_eq_coe, ←AddEquiv.coe_to_add_monoid_hom]
        rw [AddMonoidHom.map_mul_iff]
        ext i₁ r₁ i₂ r₂ : 6
        simp  }

@[simp]
theorem op_ring_equiv_single [Monoidₓ G] (r : k) (x : G) :
  MonoidAlgebra.opRingEquiv (op (single x r)) = single (op x) (op r) :=
  by 
    simp 

@[simp]
theorem op_ring_equiv_symm_single [Monoidₓ G] (r : «expr ᵐᵒᵖ» k) (x : «expr ᵐᵒᵖ» G) :
  MonoidAlgebra.opRingEquiv.symm (single x r) = op (single x.unop r.unop) :=
  by 
    simp 

end Opposite

end MonoidAlgebra

/-! ### Additive monoids -/


section 

variable[Semiringₓ k]

-- error in Algebra.MonoidAlgebra.Basic: ././Mathport/Syntax/Translate/Basic.lean:704:9: unsupported derive handler inhabited
/--
The monoid algebra over a semiring `k` generated by the additive monoid `G`.
It is the type of finite formal `k`-linear combinations of terms of `G`,
endowed with the convolution product.
-/ @[derive #["[", expr inhabited, ",", expr add_comm_monoid, "]"]] def add_monoid_algebra :=
«expr →₀ »(G, k)

instance  : CoeFun (AddMonoidAlgebra k G) fun _ => G → k :=
  Finsupp.hasCoeToFun

end 

namespace AddMonoidAlgebra

variable{k G}

section Mul

variable[Semiringₓ k][Add G]

/-- The product of `f g : add_monoid_algebra k G` is the finitely supported function
  whose value at `a` is the sum of `f x * g y` over all pairs `x, y`
  such that `x + y = a`. (Think of the product of multivariate
  polynomials where `α` is the additive monoid of monomial exponents.) -/
instance  : Mul (AddMonoidAlgebra k G) :=
  ⟨fun f g => f.sum$ fun a₁ b₁ => g.sum$ fun a₂ b₂ => single (a₁+a₂) (b₁*b₂)⟩

theorem mul_def {f g : AddMonoidAlgebra k G} :
  (f*g) = (f.sum$ fun a₁ b₁ => g.sum$ fun a₂ b₂ => single (a₁+a₂) (b₁*b₂)) :=
  rfl

instance  : NonUnitalNonAssocSemiring (AddMonoidAlgebra k G) :=
  { Finsupp.addCommMonoid with zero := 0, mul := ·*·, add := ·+·,
    left_distrib :=
      fun f g h =>
        by 
          simp only [mul_def, sum_add_index, mul_addₓ, mul_zero, single_zero, single_add, eq_self_iff_true,
            forall_true_iff, forall_3_true_iff, sum_add],
    right_distrib :=
      fun f g h =>
        by 
          simp only [mul_def, sum_add_index, add_mulₓ, mul_zero, zero_mul, single_zero, single_add, eq_self_iff_true,
            forall_true_iff, forall_3_true_iff, sum_zero, sum_add],
    zero_mul :=
      fun f =>
        by 
          simp only [mul_def, sum_zero_index],
    mul_zero :=
      fun f =>
        by 
          simp only [mul_def, sum_zero_index, sum_zero],
    nsmul := fun n f => n • f,
    nsmul_zero' :=
      by 
        intros 
        ext 
        simp [-nsmul_eq_mul, add_smul],
    nsmul_succ' :=
      by 
        intros 
        ext 
        simp [-nsmul_eq_mul, Nat.succ_eq_one_add, add_smul] }

end Mul

section HasOne

variable[Semiringₓ k][HasZero G]

/-- The unit of the multiplication is `single 1 1`, i.e. the function
  that is `1` at `0` and zero elsewhere. -/
instance  : HasOne (AddMonoidAlgebra k G) :=
  ⟨single 0 1⟩

theorem one_def : (1 : AddMonoidAlgebra k G) = single 0 1 :=
  rfl

end HasOne

section Semigroupₓ

variable[Semiringₓ k][AddSemigroupₓ G]

instance  : NonUnitalSemiring (AddMonoidAlgebra k G) :=
  { AddMonoidAlgebra.nonUnitalNonAssocSemiring with zero := 0, mul := ·*·, add := ·+·,
    mul_assoc :=
      fun f g h =>
        by 
          simp only [mul_def, sum_sum_index, sum_zero_index, sum_add_index, sum_single_index, single_zero, single_add,
            eq_self_iff_true, forall_true_iff, forall_3_true_iff, add_mulₓ, mul_addₓ, add_assocₓ, mul_assocₓ, zero_mul,
            mul_zero, sum_zero, sum_add] }

end Semigroupₓ

section MulOneClass

variable[Semiringₓ k][AddZeroClass G]

instance  : NonAssocSemiring (AddMonoidAlgebra k G) :=
  { AddMonoidAlgebra.nonUnitalNonAssocSemiring with one := 1, mul := ·*·, zero := 0, add := ·+·,
    one_mul :=
      fun f =>
        by 
          simp only [mul_def, one_def, sum_single_index, zero_mul, single_zero, sum_zero, zero_addₓ, one_mulₓ,
            sum_single],
    mul_one :=
      fun f =>
        by 
          simp only [mul_def, one_def, sum_single_index, mul_zero, single_zero, sum_zero, add_zeroₓ, mul_oneₓ,
            sum_single] }

variable{R : Type _}[Semiringₓ R]

-- error in Algebra.MonoidAlgebra.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
/-- A non-commutative version of `add_monoid_algebra.lift`: given a additive homomorphism `f : k →+
R` and a multiplicative monoid homomorphism `g : multiplicative G →* R`, returns the additive
homomorphism from `add_monoid_algebra k G` such that `lift_nc f g (single a b) = f b * g a`. If `f`
is a ring homomorphism and the range of either `f` or `g` is in center of `R`, then the result is a
ring homomorphism.  If `R` is a `k`-algebra and `f = algebra_map k R`, then the result is an algebra
homomorphism called `add_monoid_algebra.lift`. -/
def lift_nc (f : «expr →+ »(k, R)) (g : «expr →* »(multiplicative G, R)) : «expr →+ »(add_monoid_algebra k G, R) :=
lift_add_hom (λ x : G, (add_monoid_hom.mul_right «expr $ »(g, multiplicative.of_add x)).comp f)

@[simp]
theorem lift_nc_single (f : k →+ R) (g : Multiplicative G →* R) (a : G) (b : k) :
  lift_nc f g (single a b) = f b*g (Multiplicative.ofAdd a) :=
  lift_add_hom_apply_single _ _ _

@[simp]
theorem lift_nc_one (f : k →+* R) (g : Multiplicative G →* R) : lift_nc (f : k →+ R) g 1 = 1 :=
  @MonoidAlgebra.lift_nc_one k (Multiplicative G) _ _ _ _ f g

theorem lift_nc_mul (f : k →+* R) (g : Multiplicative G →* R) (a b : AddMonoidAlgebra k G)
  (h_comm : ∀ {x y}, y ∈ a.support → Commute (f (b x)) (g$ Multiplicative.ofAdd y)) :
  lift_nc (f : k →+ R) g (a*b) = lift_nc (f : k →+ R) g a*lift_nc (f : k →+ R) g b :=
  @MonoidAlgebra.lift_nc_mul k (Multiplicative G) _ _ _ _ f g a b @h_comm

end MulOneClass

/-! #### Semiring structure -/


section Semiringₓ

instance  {R : Type _} [Monoidₓ R] [Semiringₓ k] [DistribMulAction R k] : HasScalar R (AddMonoidAlgebra k G) :=
  Finsupp.hasScalar

variable[Semiringₓ k][AddMonoidₓ G]

instance  : Semiringₓ (AddMonoidAlgebra k G) :=
  { AddMonoidAlgebra.nonUnitalSemiring, AddMonoidAlgebra.nonAssocSemiring with one := 1, mul := ·*·, zero := 0,
    add := ·+· }

variable{R : Type _}[Semiringₓ R]

/-- `lift_nc` as a `ring_hom`, for when `f` and `g` commute -/
def lift_nc_ring_hom (f : k →+* R) (g : Multiplicative G →* R) (h_comm : ∀ x y, Commute (f x) (g y)) :
  AddMonoidAlgebra k G →+* R :=
  { lift_nc (f : k →+ R) g with toFun := lift_nc (f : k →+ R) g, map_one' := lift_nc_one _ _,
    map_mul' := fun a b => lift_nc_mul _ _ _ _$ fun _ _ _ => h_comm _ _ }

end Semiringₓ

instance  [CommSemiringₓ k] [AddCommMonoidₓ G] : CommSemiringₓ (AddMonoidAlgebra k G) :=
  { AddMonoidAlgebra.semiring with mul_comm := @mul_commₓ (MonoidAlgebra k$ Multiplicative G) _ }

instance  [Semiringₓ k] [Nontrivial k] [Nonempty G] : Nontrivial (AddMonoidAlgebra k G) :=
  Finsupp.nontrivial

/-! #### Derived instances -/


section DerivedInstances

instance  [Semiringₓ k] [Subsingleton k] : Unique (AddMonoidAlgebra k G) :=
  Finsupp.uniqueOfRight

instance  [Ringₓ k] : AddGroupₓ (AddMonoidAlgebra k G) :=
  Finsupp.addGroup

instance  [Ringₓ k] [AddMonoidₓ G] : Ringₓ (AddMonoidAlgebra k G) :=
  { AddMonoidAlgebra.semiring with neg := Neg.neg, add_left_neg := add_left_negₓ, sub := Sub.sub,
    sub_eq_add_neg := Finsupp.addGroup.sub_eq_add_neg }

instance  [CommRingₓ k] [AddCommMonoidₓ G] : CommRingₓ (AddMonoidAlgebra k G) :=
  { AddMonoidAlgebra.ring with mul_comm := mul_commₓ }

variable{R S : Type _}

instance  [Monoidₓ R] [Semiringₓ k] [DistribMulAction R k] : DistribMulAction R (AddMonoidAlgebra k G) :=
  Finsupp.distribMulAction G k

instance  [Monoidₓ R] [Semiringₓ k] [DistribMulAction R k] [HasFaithfulScalar R k] [Nonempty G] :
  HasFaithfulScalar R (AddMonoidAlgebra k G) :=
  Finsupp.has_faithful_scalar

instance  [Semiringₓ R] [Semiringₓ k] [Module R k] : Module R (AddMonoidAlgebra k G) :=
  Finsupp.module G k

instance  [Monoidₓ R] [Monoidₓ S] [Semiringₓ k] [DistribMulAction R k] [DistribMulAction S k] [HasScalar R S]
  [IsScalarTower R S k] : IsScalarTower R S (AddMonoidAlgebra k G) :=
  Finsupp.is_scalar_tower G k

instance  [Monoidₓ R] [Monoidₓ S] [Semiringₓ k] [DistribMulAction R k] [DistribMulAction S k] [SmulCommClass R S k] :
  SmulCommClass R S (AddMonoidAlgebra k G) :=
  Finsupp.smul_comm_class G k

/-! It is hard to state the equivalent of `distrib_mul_action G (add_monoid_algebra k G)`
because we've never discussed actions of additive groups. -/


end DerivedInstances

section MiscTheorems

variable[Semiringₓ k]

theorem mul_apply [Add G] (f g : AddMonoidAlgebra k G) (x : G) :
  (f*g) x = (f.sum$ fun a₁ b₁ => g.sum$ fun a₂ b₂ => if (a₁+a₂) = x then b₁*b₂ else 0) :=
  @MonoidAlgebra.mul_apply k (Multiplicative G) _ _ _ _ _

theorem mul_apply_antidiagonal [Add G] (f g : AddMonoidAlgebra k G) (x : G) (s : Finset (G × G))
  (hs : ∀ {p : G × G}, p ∈ s ↔ (p.1+p.2) = x) : (f*g) x = ∑p in s, f p.1*g p.2 :=
  @MonoidAlgebra.mul_apply_antidiagonal k (Multiplicative G) _ _ _ _ _ s @hs

theorem support_mul [Add G] (a b : AddMonoidAlgebra k G) :
  (a*b).Support ⊆ a.support.bUnion fun a₁ => b.support.bUnion$ fun a₂ => {a₁+a₂} :=
  @MonoidAlgebra.support_mul k (Multiplicative G) _ _ _ _

theorem single_mul_single [Add G] {a₁ a₂ : G} {b₁ b₂ : k} :
  (single a₁ b₁*single a₂ b₂ : AddMonoidAlgebra k G) = single (a₁+a₂) (b₁*b₂) :=
  @MonoidAlgebra.single_mul_single k (Multiplicative G) _ _ _ _ _ _

theorem single_pow [AddMonoidₓ G] {a : G} {b : k} :
  ∀ (n : ℕ), (single a b ^ n : AddMonoidAlgebra k G) = single (n • a) (b ^ n)
| 0 =>
  by 
    simp only [pow_zeroₓ, zero_nsmul]
    rfl
| n+1 =>
  by 
    rw [pow_succₓ, pow_succₓ, single_pow n, single_mul_single, add_commₓ, add_nsmul, one_nsmul]

/-- Like `finsupp.map_domain_add`, but for the convolutive multiplication we define in this file -/
theorem map_domain_mul {α : Type _} {β : Type _} {α₂ : Type _} [Semiringₓ β] [Add α] [Add α₂]
  {x y : AddMonoidAlgebra β α} (f : AddHom α α₂) :
  (map_domain f (x*y : AddMonoidAlgebra β α) : AddMonoidAlgebra β α₂) =
    (map_domain f x*map_domain f y : AddMonoidAlgebra β α₂) :=
  by 
    simpRw [mul_def, map_domain_sum, map_domain_single, f.map_add]
    rw [Finsupp.sum_map_domain_index]
    ·
      congr 
      ext a b 
      rw [Finsupp.sum_map_domain_index]
      ·
        simp 
      ·
        simp [mul_addₓ]
    ·
      simp 
    ·
      simp [add_mulₓ]

section 

variable(k G)

/-- The embedding of an additive magma into its additive magma algebra. -/
@[simps]
def of_magma [Add G] : MulHom (Multiplicative G) (AddMonoidAlgebra k G) :=
  { toFun := fun a => single a 1,
    map_mul' :=
      fun a b =>
        by 
          simpa only [mul_def, mul_oneₓ, sum_single_index, single_eq_zero, mul_zero] }

/-- Embedding of a magma with zero into its magma algebra. -/
def of [AddZeroClass G] : Multiplicative G →* AddMonoidAlgebra k G :=
  { of_magma k G with toFun := fun a => single a 1, map_one' := rfl }

/-- Embedding of a magma with zero `G`, into its magma algebra, having `G` as source. -/
def of' : G → AddMonoidAlgebra k G :=
  fun a => single a 1

end 

@[simp]
theorem of_apply [AddZeroClass G] (a : Multiplicative G) : of k G a = single a.to_add 1 :=
  rfl

@[simp]
theorem of'_apply (a : G) : of' k G a = single a 1 :=
  rfl

theorem of'_eq_of [AddZeroClass G] (a : G) : of' k G a = of k G a :=
  rfl

theorem of_injective [Nontrivial k] [AddZeroClass G] : Function.Injective (of k G) :=
  fun a b h =>
    by 
      simpa using (single_eq_single_iff _ _ _ _).mp h

theorem mul_single_apply_aux [Add G] (f : AddMonoidAlgebra k G) (r : k) (x y z : G) (H : ∀ a, (a+x) = z ↔ a = y) :
  (f*single x r) z = f y*r :=
  @MonoidAlgebra.mul_single_apply_aux k (Multiplicative G) _ _ _ _ _ _ _ H

theorem mul_single_zero_apply [AddZeroClass G] (f : AddMonoidAlgebra k G) (r : k) (x : G) : (f*single 0 r) x = f x*r :=
  f.mul_single_apply_aux r _ _ _$
    fun a =>
      by 
        rw [add_zeroₓ]

theorem single_mul_apply_aux [Add G] (f : AddMonoidAlgebra k G) (r : k) (x y z : G) (H : ∀ a, (x+a) = y ↔ a = z) :
  (single x r*f : AddMonoidAlgebra k G) y = r*f z :=
  @MonoidAlgebra.single_mul_apply_aux k (Multiplicative G) _ _ _ _ _ _ _ H

theorem single_zero_mul_apply [AddZeroClass G] (f : AddMonoidAlgebra k G) (r : k) (x : G) :
  (single 0 r*f : AddMonoidAlgebra k G) x = r*f x :=
  f.single_mul_apply_aux r _ _ _$
    fun a =>
      by 
        rw [zero_addₓ]

theorem mul_single_apply [AddGroupₓ G] (f : AddMonoidAlgebra k G) (r : k) (x y : G) : (f*single x r) y = f (y - x)*r :=
  (sub_eq_add_neg y x).symm ▸ @MonoidAlgebra.mul_single_apply k (Multiplicative G) _ _ _ _ _ _

theorem single_mul_apply [AddGroupₓ G] (r : k) (x : G) (f : AddMonoidAlgebra k G) (y : G) :
  (single x r*f : AddMonoidAlgebra k G) y = r*f ((-x)+y) :=
  @MonoidAlgebra.single_mul_apply k (Multiplicative G) _ _ _ _ _ _

theorem support_mul_single [AddRightCancelSemigroup G] (f : AddMonoidAlgebra k G) (r : k) (hr : ∀ y, (y*r) = 0 ↔ y = 0)
  (x : G) : (f*single x r : AddMonoidAlgebra k G).Support = f.support.map (addRightEmbedding x) :=
  @MonoidAlgebra.support_mul_single k (Multiplicative G) _ _ _ _ hr _

theorem support_single_mul [AddLeftCancelSemigroup G] (f : AddMonoidAlgebra k G) (r : k) (hr : ∀ y, (r*y) = 0 ↔ y = 0)
  (x : G) : (single x r*f : AddMonoidAlgebra k G).Support = f.support.map (addLeftEmbedding x) :=
  @MonoidAlgebra.support_single_mul k (Multiplicative G) _ _ _ _ hr _

theorem lift_nc_smul {R : Type _} [AddZeroClass G] [Semiringₓ R] (f : k →+* R) (g : Multiplicative G →* R) (c : k)
  (φ : MonoidAlgebra k G) : lift_nc (f : k →+ R) g (c • φ) = f c*lift_nc (f : k →+ R) g φ :=
  @MonoidAlgebra.lift_nc_smul k (Multiplicative G) _ _ _ _ f g c φ

variable{k G}

theorem induction_on [AddMonoidₓ G] {p : AddMonoidAlgebra k G → Prop} (f : AddMonoidAlgebra k G)
  (hM : ∀ g, p (of k G (Multiplicative.ofAdd g))) (hadd : ∀ (f g : AddMonoidAlgebra k G), p f → p g → p (f+g))
  (hsmul : ∀ (r : k) f, p f → p (r • f)) : p f :=
  by 
    refine' Finsupp.induction_linear f _ (fun f g hf hg => hadd f g hf hg) fun g r => _
    ·
      simpa using hsmul 0 (of k G (Multiplicative.ofAdd 0)) (hM 0)
    ·
      convert hsmul r (of k G (Multiplicative.ofAdd g)) (hM g)
      simp only [mul_oneₓ, to_add_of_add, smul_single', of_apply]

end MiscTheorems

section Span

variable[Semiringₓ k]

/-- An element of `add_monoid_algebra R M` is in the submodule generated by its support. -/
theorem mem_span_support [AddZeroClass G] (f : AddMonoidAlgebra k G) :
  f ∈ Submodule.span k (of k G '' (f.support : Set G)) :=
  by 
    rw [of, MonoidHom.coe_mk, ←Finsupp.supported_eq_span_single, Finsupp.mem_supported]

/-- An element of `add_monoid_algebra R M` is in the subalgebra generated by its support, using
unbundled inclusion. -/
theorem mem_span_support' (f : AddMonoidAlgebra k G) : f ∈ Submodule.span k (of' k G '' (f.support : Set G)) :=
  by 
    rw [of', ←Finsupp.supported_eq_span_single, Finsupp.mem_supported]

end Span

end AddMonoidAlgebra

/-!
#### Conversions between `add_monoid_algebra` and `monoid_algebra`

We have not defined `add_monoid_algebra k G = monoid_algebra k (multiplicative G)`
because historically this caused problems;
since the changes that have made `nsmul` definitional, this would be possible,
but for now we just contruct the ring isomorphisms using `ring_equiv.refl _`.
-/


/-- The equivalence between `add_monoid_algebra` and `monoid_algebra` in terms of
`multiplicative` -/
protected def AddMonoidAlgebra.toMultiplicative [Semiringₓ k] [Add G] :
  AddMonoidAlgebra k G ≃+* MonoidAlgebra k (Multiplicative G) :=
  { Finsupp.domCongr Multiplicative.ofAdd with toFun := equiv_map_domain Multiplicative.ofAdd,
    map_mul' :=
      fun x y =>
        by 
          repeat' 
            rw [equiv_map_domain_eq_map_domain]
          dsimp [Multiplicative.ofAdd]
          convert MonoidAlgebra.map_domain_mul (MulHom.id (Multiplicative G)) }

/-- The equivalence between `monoid_algebra` and `add_monoid_algebra` in terms of `additive` -/
protected def MonoidAlgebra.toAdditive [Semiringₓ k] [Mul G] : MonoidAlgebra k G ≃+* AddMonoidAlgebra k (Additive G) :=
  { Finsupp.domCongr Additive.ofMul with toFun := equiv_map_domain Additive.ofMul,
    map_mul' :=
      fun x y =>
        by 
          repeat' 
            rw [equiv_map_domain_eq_map_domain]
          dsimp [Additive.ofMul]
          convert MonoidAlgebra.map_domain_mul (MulHom.id G) }

namespace AddMonoidAlgebra

variable{k G}

/-! #### Non-unital, non-associative algebra structure -/


section NonUnitalNonAssocAlgebra

variable{R : Type _}(k)[Semiringₓ R][Semiringₓ k][DistribMulAction R k][Add G]

instance is_scalar_tower_self [IsScalarTower R k k] : IsScalarTower R (AddMonoidAlgebra k G) (AddMonoidAlgebra k G) :=
  @MonoidAlgebra.is_scalar_tower_self k (Multiplicative G) R _ _ _ _ _

/-- Note that if `k` is a `comm_semiring` then we have `smul_comm_class k k k` and so we can take
`R = k` in the below. In other words, if the coefficients are commutative amongst themselves, they
also commute with the algebra multiplication. -/
instance smul_comm_class_self [SmulCommClass R k k] : SmulCommClass R (AddMonoidAlgebra k G) (AddMonoidAlgebra k G) :=
  @MonoidAlgebra.smul_comm_class_self k (Multiplicative G) R _ _ _ _ _

instance smul_comm_class_symm_self [SmulCommClass k R k] :
  SmulCommClass (AddMonoidAlgebra k G) R (AddMonoidAlgebra k G) :=
  @MonoidAlgebra.smul_comm_class_symm_self k (Multiplicative G) R _ _ _ _ _

variable{A : Type u₃}[NonUnitalNonAssocSemiring A]

/-- A non_unital `k`-algebra homomorphism from `add_monoid_algebra k G` is uniquely defined by its
values on the functions `single a 1`. -/
theorem non_unital_alg_hom_ext [DistribMulAction k A] {φ₁ φ₂ : NonUnitalAlgHom k (AddMonoidAlgebra k G) A}
  (h : ∀ x, φ₁ (single x 1) = φ₂ (single x 1)) : φ₁ = φ₂ :=
  @MonoidAlgebra.non_unital_alg_hom_ext k (Multiplicative G) _ _ _ _ _ φ₁ φ₂ h

/-- See note [partially-applied ext lemmas]. -/
@[ext]
theorem non_unital_alg_hom_ext' [DistribMulAction k A] {φ₁ φ₂ : NonUnitalAlgHom k (AddMonoidAlgebra k G) A}
  (h : φ₁.to_mul_hom.comp (of_magma k G) = φ₂.to_mul_hom.comp (of_magma k G)) : φ₁ = φ₂ :=
  @MonoidAlgebra.non_unital_alg_hom_ext' k (Multiplicative G) _ _ _ _ _ φ₁ φ₂ h

/-- The functor `G ↦ add_monoid_algebra k G`, from the category of magmas to the category of
non-unital, non-associative algebras over `k` is adjoint to the forgetful functor in the other
direction. -/
@[simps]
def lift_magma [Module k A] [IsScalarTower k A A] [SmulCommClass k A A] :
  MulHom (Multiplicative G) A ≃ NonUnitalAlgHom k (AddMonoidAlgebra k G) A :=
  { (MonoidAlgebra.liftMagma k : MulHom (Multiplicative G) A ≃ NonUnitalAlgHom k _ A) with
    toFun :=
      fun f =>
        { (MonoidAlgebra.liftMagma k f : _) with toFun := fun a => Sum a fun m t => t • f (Multiplicative.ofAdd m) },
    invFun := fun F => F.to_mul_hom.comp (of_magma k G) }

end NonUnitalNonAssocAlgebra

/-! #### Algebra structure -/


section Algebra

variable{R : Type _}

attribute [local reducible] AddMonoidAlgebra

/-- `finsupp.single 0` as a `ring_hom` -/
@[simps]
def single_zero_ring_hom [Semiringₓ k] [AddMonoidₓ G] : k →+* AddMonoidAlgebra k G :=
  { Finsupp.singleAddHom 0 with map_one' := rfl,
    map_mul' :=
      fun x y =>
        by 
          rw [single_add_hom, single_mul_single, zero_addₓ] }

/-- If two ring homomorphisms from `add_monoid_algebra k G` are equal on all `single a 1`
and `single 0 b`, then they are equal. -/
theorem ring_hom_ext {R} [Semiringₓ k] [AddMonoidₓ G] [Semiringₓ R] {f g : AddMonoidAlgebra k G →+* R}
  (h₀ : ∀ b, f (single 0 b) = g (single 0 b)) (h_of : ∀ a, f (single a 1) = g (single a 1)) : f = g :=
  @MonoidAlgebra.ring_hom_ext k (Multiplicative G) R _ _ _ _ _ h₀ h_of

/-- If two ring homomorphisms from `add_monoid_algebra k G` are equal on all `single a 1`
and `single 0 b`, then they are equal.

See note [partially-applied ext lemmas]. -/
@[ext]
theorem ring_hom_ext' {R} [Semiringₓ k] [AddMonoidₓ G] [Semiringₓ R] {f g : AddMonoidAlgebra k G →+* R}
  (h₁ : f.comp single_zero_ring_hom = g.comp single_zero_ring_hom)
  (h_of : (f : AddMonoidAlgebra k G →* R).comp (of k G) = (g : AddMonoidAlgebra k G →* R).comp (of k G)) : f = g :=
  ring_hom_ext (RingHom.congr_fun h₁) (MonoidHom.congr_fun h_of)

section Opposite

open Finsupp MulOpposite

variable[Semiringₓ k]

/-- The opposite of an `add_monoid_algebra R I` is ring equivalent to
the `add_monoid_algebra Rᵐᵒᵖ I` over the opposite ring, taking elements to their opposite. -/
@[simps (config := { simpRhs := tt })]
protected noncomputable def op_ring_equiv [AddCommMonoidₓ G] :
  «expr ᵐᵒᵖ» (AddMonoidAlgebra k G) ≃+* AddMonoidAlgebra («expr ᵐᵒᵖ» k) G :=
  { MulOpposite.opAddEquiv.symm.trans (Finsupp.mapRange.addEquiv (MulOpposite.opAddEquiv : k ≃+ «expr ᵐᵒᵖ» k)) with
    map_mul' :=
      by 
        dsimp only [AddEquiv.to_fun_eq_coe, ←AddEquiv.coe_to_add_monoid_hom]
        rw [AddMonoidHom.map_mul_iff]
        ext i r i' r' : 6
        dsimp 
        simp only [map_range_single, single_mul_single, ←op_mul, add_commₓ] }

@[simp]
theorem op_ring_equiv_single [AddCommMonoidₓ G] (r : k) (x : G) :
  AddMonoidAlgebra.opRingEquiv (op (single x r)) = single x (op r) :=
  by 
    simp 

@[simp]
theorem op_ring_equiv_symm_single [AddCommMonoidₓ G] (r : «expr ᵐᵒᵖ» k) (x : «expr ᵐᵒᵖ» G) :
  AddMonoidAlgebra.opRingEquiv.symm (single x r) = op (single x r.unop) :=
  by 
    simp 

end Opposite

/--
The instance `algebra R (add_monoid_algebra k G)` whenever we have `algebra R k`.

In particular this provides the instance `algebra k (add_monoid_algebra k G)`.
-/
instance  [CommSemiringₓ R] [Semiringₓ k] [Algebra R k] [AddMonoidₓ G] : Algebra R (AddMonoidAlgebra k G) :=
  { single_zero_ring_hom.comp (algebraMap R k) with
    smul_def' :=
      fun r a =>
        by 
          ext 
          simp [single_zero_mul_apply, Algebra.smul_def, Pi.smul_apply],
    commutes' :=
      fun r f =>
        by 
          ext 
          simp [single_zero_mul_apply, mul_single_zero_apply, Algebra.commutes] }

/-- `finsupp.single 0` as a `alg_hom` -/
@[simps]
def single_zero_alg_hom [CommSemiringₓ R] [Semiringₓ k] [Algebra R k] [AddMonoidₓ G] : k →ₐ[R] AddMonoidAlgebra k G :=
  { single_zero_ring_hom with
    commutes' :=
      fun r =>
        by 
          ext 
          simp 
          rfl }

@[simp]
theorem coe_algebra_map [CommSemiringₓ R] [Semiringₓ k] [Algebra R k] [AddMonoidₓ G] :
  (algebraMap R (AddMonoidAlgebra k G) : R → AddMonoidAlgebra k G) = single 0 ∘ algebraMap R k :=
  rfl

end Algebra

section lift

variable{k G}[CommSemiringₓ k][AddMonoidₓ G]

variable{A : Type u₃}[Semiringₓ A][Algebra k A]{B : Type _}[Semiringₓ B][Algebra k B]

/-- `lift_nc_ring_hom` as a `alg_hom`, for when `f` is an `alg_hom` -/
def lift_nc_alg_hom (f : A →ₐ[k] B) (g : Multiplicative G →* B) (h_comm : ∀ x y, Commute (f x) (g y)) :
  AddMonoidAlgebra A G →ₐ[k] B :=
  { lift_nc_ring_hom (f : A →+* B) g h_comm with toFun := lift_nc_ring_hom (f : A →+* B) g h_comm,
    commutes' :=
      by 
        simp [lift_nc_ring_hom] }

/-- A `k`-algebra homomorphism from `monoid_algebra k G` is uniquely defined by its
values on the functions `single a 1`. -/
theorem alg_hom_ext ⦃φ₁ φ₂ : AddMonoidAlgebra k G →ₐ[k] A⦄ (h : ∀ x, φ₁ (single x 1) = φ₂ (single x 1)) : φ₁ = φ₂ :=
  @MonoidAlgebra.alg_hom_ext k (Multiplicative G) _ _ _ _ _ _ _ h

/-- See note [partially-applied ext lemmas]. -/
@[ext]
theorem alg_hom_ext' ⦃φ₁ φ₂ : AddMonoidAlgebra k G →ₐ[k] A⦄
  (h : (φ₁ : AddMonoidAlgebra k G →* A).comp (of k G) = (φ₂ : AddMonoidAlgebra k G →* A).comp (of k G)) : φ₁ = φ₂ :=
  alg_hom_ext$ MonoidHom.congr_fun h

variable(k G A)

/-- Any monoid homomorphism `G →* A` can be lifted to an algebra homomorphism
`monoid_algebra k G →ₐ[k] A`. -/
def lift : (Multiplicative G →* A) ≃ (AddMonoidAlgebra k G →ₐ[k] A) :=
  { @MonoidAlgebra.lift k (Multiplicative G) _ _ A _ _ with
    invFun := fun f => (f : AddMonoidAlgebra k G →* A).comp (of k G),
    toFun :=
      fun F =>
        { @MonoidAlgebra.lift k (Multiplicative G) _ _ A _ _ F with
          toFun := lift_nc_alg_hom (Algebra.ofId k A) F$ fun _ _ => Algebra.commutes _ _ } }

variable{k G A}

theorem lift_apply' (F : Multiplicative G →* A) (f : MonoidAlgebra k G) :
  lift k G A F f = f.sum fun a b => algebraMap k A b*F (Multiplicative.ofAdd a) :=
  rfl

theorem lift_apply (F : Multiplicative G →* A) (f : MonoidAlgebra k G) :
  lift k G A F f = f.sum fun a b => b • F (Multiplicative.ofAdd a) :=
  by 
    simp only [lift_apply', Algebra.smul_def]

theorem lift_def (F : Multiplicative G →* A) :
  «expr⇑ » (lift k G A F) = lift_nc ((algebraMap k A : k →+* A) : k →+ A) F :=
  rfl

@[simp]
theorem lift_symm_apply (F : AddMonoidAlgebra k G →ₐ[k] A) (x : Multiplicative G) :
  (lift k G A).symm F x = F (single x.to_add 1) :=
  rfl

theorem lift_of (F : Multiplicative G →* A) (x : Multiplicative G) : lift k G A F (of k G x) = F x :=
  by 
    rw [of_apply, ←lift_symm_apply, Equiv.symm_apply_apply]

@[simp]
theorem lift_single (F : Multiplicative G →* A) a b : lift k G A F (single a b) = b • F (Multiplicative.ofAdd a) :=
  by 
    rw [lift_def, lift_nc_single, Algebra.smul_def, RingHom.coe_add_monoid_hom]

theorem lift_unique' (F : AddMonoidAlgebra k G →ₐ[k] A) :
  F = lift k G A ((F : AddMonoidAlgebra k G →* A).comp (of k G)) :=
  ((lift k G A).apply_symm_apply F).symm

/-- Decomposition of a `k`-algebra homomorphism from `monoid_algebra k G` by
its values on `F (single a 1)`. -/
theorem lift_unique (F : AddMonoidAlgebra k G →ₐ[k] A) (f : MonoidAlgebra k G) :
  F f = f.sum fun a b => b • F (single a 1) :=
  by 
    convLHS => rw [lift_unique' F]simp [lift_apply]

theorem alg_hom_ext_iff {φ₁ φ₂ : AddMonoidAlgebra k G →ₐ[k] A} :
  (∀ x, φ₁ (Finsupp.single x 1) = φ₂ (Finsupp.single x 1)) ↔ φ₁ = φ₂ :=
  ⟨fun h => alg_hom_ext h,
    by 
      rintro rfl _ <;> rfl⟩

end lift

section 

attribute [local reducible] AddMonoidAlgebra

universe ui

variable{ι : Type ui}

theorem prod_single [CommSemiringₓ k] [AddCommMonoidₓ G] {s : Finset ι} {a : ι → G} {b : ι → k} :
  (∏i in s, single (a i) (b i)) = single (∑i in s, a i) (∏i in s, b i) :=
  Finset.induction_on s rfl$
    fun a s has ih =>
      by 
        rw [prod_insert has, ih, single_mul_single, sum_insert has, prod_insert has]

end 

end AddMonoidAlgebra

variable{R : Type _}[CommSemiringₓ R](k G)

/-- The algebra equivalence between `add_monoid_algebra` and `monoid_algebra` in terms of
`multiplicative`. -/
def AddMonoidAlgebra.toMultiplicativeAlgEquiv [Semiringₓ k] [Algebra R k] [AddMonoidₓ G] :
  AddMonoidAlgebra k G ≃ₐ[R] MonoidAlgebra k (Multiplicative G) :=
  { AddMonoidAlgebra.toMultiplicative k G with
    commutes' :=
      fun r =>
        by 
          simp [AddMonoidAlgebra.toMultiplicative] }

/-- The algebra equivalence between `monoid_algebra` and `add_monoid_algebra` in terms of
`additive`. -/
def MonoidAlgebra.toAdditiveAlgEquiv [Semiringₓ k] [Algebra R k] [Monoidₓ G] :
  MonoidAlgebra k G ≃ₐ[R] AddMonoidAlgebra k (Additive G) :=
  { MonoidAlgebra.toAdditive k G with
    commutes' :=
      fun r =>
        by 
          simp [MonoidAlgebra.toAdditive] }

