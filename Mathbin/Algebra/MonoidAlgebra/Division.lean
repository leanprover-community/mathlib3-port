/-
Copyright (c) 2022 Eric Wieser. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Eric Wieser

! This file was ported from Lean 3 source module algebra.monoid_algebra.division
! leanprover-community/mathlib commit 31ca6f9cf5f90a6206092cd7f84b359dcb6d52e0
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.MonoidAlgebra.Basic
import Mathbin.Data.Finsupp.Order

/-!
# Division of `add_monoid_algebra` by monomials

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file is most important for when `G = ℕ` (polynomials) or `G = σ →₀ ℕ` (multivariate
polynomials).

In order to apply in maximal generality (such as for `laurent_polynomial`s), this uses
`∃ d, g' = g + d` in many places instead of `g ≤ g'`.

## Main definitions

* `add_monoid_algebra.div_of x g`: divides `x` by the monomial `add_monoid_algebra.of k G g`
* `add_monoid_algebra.mod_of x g`: the remainder upon dividing `x` by the monomial
  `add_monoid_algebra.of k G g`.

## Main results

* `add_monoid_algebra.div_of_add_mod_of`, `add_monoid_algebra.mod_of_add_div_of`: `div_of` and
  `mod_of` are well-behaved as quotient and remainder operators.

## Implementation notes

`∃ d, g' = g + d` is used as opposed to some other permutation up to commutativity in order to match
the definition of `semigroup_has_dvd`. The results in this file could be duplicated for
`monoid_algebra` by using `g ∣ g'`, but this can't be done automatically, and in any case is not
likely to be very useful.

-/


variable {k G : Type _} [Semiring k]

namespace AddMonoidAlgebra

section

variable [AddCancelCommMonoid G]

#print AddMonoidAlgebra.divOf /-
/-- Divide by `of' k G g`, discarding terms not divisible by this. -/
noncomputable def divOf (x : AddMonoidAlgebra k G) (g : G) : AddMonoidAlgebra k G :=
  -- note: comapping by `+ g` has the effect of subtracting `g` from every element in the support, and
    -- discarding the elements of the support from which `g` can't be subtracted. If `G` is an additive
    -- group, such as `ℤ` when used for `laurent_polynomial`, then no discarding occurs.
    @Finsupp.comapDomain.addMonoidHom
    _ _ _ _ ((· + ·) g) (add_right_injective g) x
#align add_monoid_algebra.div_of AddMonoidAlgebra.divOf
-/

-- mathport name: «expr /ᵒᶠ »
local infixl:70 " /ᵒᶠ " => divOf

/- warning: add_monoid_algebra.div_of_apply -> AddMonoidAlgebra.divOf_apply is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : AddCancelCommMonoid.{u2} G] (g : G) (x : AddMonoidAlgebra.{u1, u2} k G _inst_1) (g' : G), Eq.{succ u1} k (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (fun (_x : AddMonoidAlgebra.{u1, u2} k G _inst_1) => G -> k) (AddMonoidAlgebra.coeFun.{u1, u2} k G _inst_1) (AddMonoidAlgebra.divOf.{u1, u2} k G _inst_1 _inst_2 x g) g') (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (fun (_x : AddMonoidAlgebra.{u1, u2} k G _inst_1) => G -> k) (AddMonoidAlgebra.coeFun.{u1, u2} k G _inst_1) x (HAdd.hAdd.{u2, u2, u2} G G G (instHAdd.{u2} G (AddZeroClass.toHasAdd.{u2} G (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2)))))) g g'))
but is expected to have type
  forall {k : Type.{u2}} {G : Type.{u1}} [_inst_1 : Semiring.{u2} k] [_inst_2 : AddCancelCommMonoid.{u1} G] (g : G) (x : AddMonoidAlgebra.{u2, u1} k G _inst_1) (g' : G), Eq.{succ u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : G) => k) g') (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Finsupp.{u1, u2} G k (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k _inst_1))) G (fun (_x : G) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : G) => k) _x) (Finsupp.funLike.{u1, u2} G k (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k _inst_1))) (AddMonoidAlgebra.divOf.{u2, u1} k G _inst_1 _inst_2 x g) g') (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Finsupp.{u1, u2} G k (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k _inst_1))) G (fun (_x : G) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : G) => k) _x) (Finsupp.funLike.{u1, u2} G k (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k _inst_1))) x (HAdd.hAdd.{u1, u1, u1} G G G (instHAdd.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2)))))) g g'))
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.div_of_apply AddMonoidAlgebra.divOf_applyₓ'. -/
@[simp]
theorem divOf_apply (g : G) (x : AddMonoidAlgebra k G) (g' : G) : (x /ᵒᶠ g) g' = x (g + g') :=
  rfl
#align add_monoid_algebra.div_of_apply AddMonoidAlgebra.divOf_apply

/- warning: add_monoid_algebra.support_div_of -> AddMonoidAlgebra.support_divOf is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : AddCancelCommMonoid.{u2} G] (g : G) (x : AddMonoidAlgebra.{u1, u2} k G _inst_1), Eq.{succ u2} (Finset.{u2} G) (Finsupp.support.{u2, u1} G k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) (AddMonoidAlgebra.divOf.{u1, u2} k G _inst_1 _inst_2 x g)) (Finset.preimage.{u2, u2} G G (Finsupp.support.{u2, u1} G k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) x) (HAdd.hAdd.{u2, u2, u2} G G G (instHAdd.{u2} G (AddZeroClass.toHasAdd.{u2} G (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2)))))) g) (Function.Injective.injOn.{u2, u2} G G (HAdd.hAdd.{u2, u2, u2} G G G (instHAdd.{u2} G (AddZeroClass.toHasAdd.{u2} G (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2)))))) g) (add_right_injective.{u2} G (AddZeroClass.toHasAdd.{u2} G (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2))))) (AddLeftCancelSemigroup.toIsLeftCancelAdd.{u2} G (AddLeftCancelMonoid.toAddLeftCancelSemigroup.{u2} G (AddCancelCommMonoid.toAddLeftCancelMonoid.{u2} G _inst_2))) g) (Set.preimage.{u2, u2} G G (HAdd.hAdd.{u2, u2, u2} G G G (instHAdd.{u2} G (AddZeroClass.toHasAdd.{u2} G (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2)))))) g) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} G) (Set.{u2} G) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} G) (Set.{u2} G) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} G) (Set.{u2} G) (Finset.Set.hasCoeT.{u2} G))) (Finsupp.support.{u2, u1} G k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))) x)))))
but is expected to have type
  forall {k : Type.{u2}} {G : Type.{u1}} [_inst_1 : Semiring.{u2} k] [_inst_2 : AddCancelCommMonoid.{u1} G] (g : G) (x : AddMonoidAlgebra.{u2, u1} k G _inst_1), Eq.{succ u1} (Finset.{u1} G) (Finsupp.support.{u1, u2} G k (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k _inst_1)) (AddMonoidAlgebra.divOf.{u2, u1} k G _inst_1 _inst_2 x g)) (Finset.preimage.{u1, u1} G G (Finsupp.support.{u1, u2} G k (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k _inst_1)) x) ((fun (x._@.Mathlib.Algebra.MonoidAlgebra.Division._hyg.821 : G) (x._@.Mathlib.Algebra.MonoidAlgebra.Division._hyg.823 : G) => HAdd.hAdd.{u1, u1, u1} G G G (instHAdd.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2)))))) x._@.Mathlib.Algebra.MonoidAlgebra.Division._hyg.821 x._@.Mathlib.Algebra.MonoidAlgebra.Division._hyg.823) g) (Function.Injective.injOn.{u1, u1} G G ((fun (x._@.Mathlib.Algebra.Group.Defs._hyg.2622 : G) (x._@.Mathlib.Algebra.Group.Defs._hyg.2624 : G) => HAdd.hAdd.{u1, u1, u1} G G G (instHAdd.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2)))))) x._@.Mathlib.Algebra.Group.Defs._hyg.2622 x._@.Mathlib.Algebra.Group.Defs._hyg.2624) g) (add_right_injective.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2))))) (IsCancelAdd.toIsLeftCancelAdd.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2))))) (AddCancelMonoid.toIsCancelAdd.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2))) g) (Set.preimage.{u1, u1} G G ((fun (x._@.Mathlib.Algebra.MonoidAlgebra.Division._hyg.821 : G) (x._@.Mathlib.Algebra.MonoidAlgebra.Division._hyg.823 : G) => HAdd.hAdd.{u1, u1, u1} G G G (instHAdd.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2)))))) x._@.Mathlib.Algebra.MonoidAlgebra.Division._hyg.821 x._@.Mathlib.Algebra.MonoidAlgebra.Division._hyg.823) g) (Finset.toSet.{u1} G (Finsupp.support.{u1, u2} G k (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k _inst_1)) x)))))
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.support_div_of AddMonoidAlgebra.support_divOfₓ'. -/
@[simp]
theorem support_divOf (g : G) (x : AddMonoidAlgebra k G) :
    (x /ᵒᶠ g).support =
      x.support.Preimage ((· + ·) g) (Function.Injective.injOn (add_right_injective g) _) :=
  rfl
#align add_monoid_algebra.support_div_of AddMonoidAlgebra.support_divOf

/- warning: add_monoid_algebra.zero_div_of -> AddMonoidAlgebra.zero_divOf is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : AddCancelCommMonoid.{u2} G] (g : G), Eq.{max (succ u2) (succ u1)} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.divOf.{u1, u2} k G _inst_1 _inst_2 (OfNat.ofNat.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) 0 (OfNat.mk.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) 0 (Zero.zero.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (MulZeroClass.toHasZero.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (NonUnitalNonAssocSemiring.toMulZeroClass.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.nonUnitalNonAssocSemiring.{u1, u2} k G _inst_1 (AddZeroClass.toHasAdd.{u2} G (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2))))))))))) g) (OfNat.ofNat.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) 0 (OfNat.mk.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) 0 (Zero.zero.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (MulZeroClass.toHasZero.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (NonUnitalNonAssocSemiring.toMulZeroClass.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.nonUnitalNonAssocSemiring.{u1, u2} k G _inst_1 (AddZeroClass.toHasAdd.{u2} G (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2)))))))))))
but is expected to have type
  forall {k : Type.{u2}} {G : Type.{u1}} [_inst_1 : Semiring.{u2} k] [_inst_2 : AddCancelCommMonoid.{u1} G] (g : G), Eq.{max (succ u2) (succ u1)} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.divOf.{u2, u1} k G _inst_1 _inst_2 (OfNat.ofNat.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) 0 (Zero.toOfNat0.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (MonoidWithZero.toZero.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (Semiring.toMonoidWithZero.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.semiring.{u2, u1} k G _inst_1 (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2)))))))) g) (OfNat.ofNat.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) 0 (Zero.toOfNat0.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (MonoidWithZero.toZero.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (Semiring.toMonoidWithZero.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.semiring.{u2, u1} k G _inst_1 (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2))))))))
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.zero_div_of AddMonoidAlgebra.zero_divOfₓ'. -/
@[simp]
theorem zero_divOf (g : G) : (0 : AddMonoidAlgebra k G) /ᵒᶠ g = 0 :=
  map_zero _
#align add_monoid_algebra.zero_div_of AddMonoidAlgebra.zero_divOf

/- warning: add_monoid_algebra.div_of_zero -> AddMonoidAlgebra.divOf_zero is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : AddCancelCommMonoid.{u2} G] (x : AddMonoidAlgebra.{u1, u2} k G _inst_1), Eq.{max (succ u2) (succ u1)} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.divOf.{u1, u2} k G _inst_1 _inst_2 x (OfNat.ofNat.{u2} G 0 (OfNat.mk.{u2} G 0 (Zero.zero.{u2} G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2))))))))) x
but is expected to have type
  forall {k : Type.{u2}} {G : Type.{u1}} [_inst_1 : Semiring.{u2} k] [_inst_2 : AddCancelCommMonoid.{u1} G] (x : AddMonoidAlgebra.{u2, u1} k G _inst_1), Eq.{max (succ u2) (succ u1)} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.divOf.{u2, u1} k G _inst_1 _inst_2 x (OfNat.ofNat.{u1} G 0 (Zero.toOfNat0.{u1} G (AddRightCancelMonoid.toZero.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2)))))) x
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.div_of_zero AddMonoidAlgebra.divOf_zeroₓ'. -/
@[simp]
theorem divOf_zero (x : AddMonoidAlgebra k G) : x /ᵒᶠ 0 = x :=
  by
  ext
  simp only [AddMonoidAlgebra.divOf_apply, zero_add]
#align add_monoid_algebra.div_of_zero AddMonoidAlgebra.divOf_zero

/- warning: add_monoid_algebra.add_div_of -> AddMonoidAlgebra.add_divOf is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : AddCancelCommMonoid.{u2} G] (x : AddMonoidAlgebra.{u1, u2} k G _inst_1) (y : AddMonoidAlgebra.{u1, u2} k G _inst_1) (g : G), Eq.{max (succ u2) (succ u1)} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.divOf.{u1, u2} k G _inst_1 _inst_2 (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (instHAdd.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (Distrib.toHasAdd.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (NonUnitalNonAssocSemiring.toDistrib.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.nonUnitalNonAssocSemiring.{u1, u2} k G _inst_1 (AddZeroClass.toHasAdd.{u2} G (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2))))))))) x y) g) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (instHAdd.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (Distrib.toHasAdd.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (NonUnitalNonAssocSemiring.toDistrib.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.nonUnitalNonAssocSemiring.{u1, u2} k G _inst_1 (AddZeroClass.toHasAdd.{u2} G (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2))))))))) (AddMonoidAlgebra.divOf.{u1, u2} k G _inst_1 _inst_2 x g) (AddMonoidAlgebra.divOf.{u1, u2} k G _inst_1 _inst_2 y g))
but is expected to have type
  forall {k : Type.{u2}} {G : Type.{u1}} [_inst_1 : Semiring.{u2} k] [_inst_2 : AddCancelCommMonoid.{u1} G] (x : AddMonoidAlgebra.{u2, u1} k G _inst_1) (y : AddMonoidAlgebra.{u2, u1} k G _inst_1) (g : G), Eq.{max (succ u2) (succ u1)} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.divOf.{u2, u1} k G _inst_1 _inst_2 (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.{u2, u1} k G _inst_1) (instHAdd.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (Distrib.toAdd.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (NonUnitalNonAssocSemiring.toDistrib.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.nonUnitalNonAssocSemiring.{u2, u1} k G _inst_1 (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2))))))))) x y) g) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.{u2, u1} k G _inst_1) (instHAdd.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (Distrib.toAdd.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (NonUnitalNonAssocSemiring.toDistrib.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.nonUnitalNonAssocSemiring.{u2, u1} k G _inst_1 (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2))))))))) (AddMonoidAlgebra.divOf.{u2, u1} k G _inst_1 _inst_2 x g) (AddMonoidAlgebra.divOf.{u2, u1} k G _inst_1 _inst_2 y g))
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.add_div_of AddMonoidAlgebra.add_divOfₓ'. -/
theorem add_divOf (x y : AddMonoidAlgebra k G) (g : G) : (x + y) /ᵒᶠ g = x /ᵒᶠ g + y /ᵒᶠ g :=
  map_add _ _ _
#align add_monoid_algebra.add_div_of AddMonoidAlgebra.add_divOf

/- warning: add_monoid_algebra.div_of_add -> AddMonoidAlgebra.divOf_add is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : AddCancelCommMonoid.{u2} G] (x : AddMonoidAlgebra.{u1, u2} k G _inst_1) (a : G) (b : G), Eq.{max (succ u2) (succ u1)} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.divOf.{u1, u2} k G _inst_1 _inst_2 x (HAdd.hAdd.{u2, u2, u2} G G G (instHAdd.{u2} G (AddZeroClass.toHasAdd.{u2} G (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2)))))) a b)) (AddMonoidAlgebra.divOf.{u1, u2} k G _inst_1 _inst_2 (AddMonoidAlgebra.divOf.{u1, u2} k G _inst_1 _inst_2 x a) b)
but is expected to have type
  forall {k : Type.{u2}} {G : Type.{u1}} [_inst_1 : Semiring.{u2} k] [_inst_2 : AddCancelCommMonoid.{u1} G] (x : AddMonoidAlgebra.{u2, u1} k G _inst_1) (a : G) (b : G), Eq.{max (succ u2) (succ u1)} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.divOf.{u2, u1} k G _inst_1 _inst_2 x (HAdd.hAdd.{u1, u1, u1} G G G (instHAdd.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2)))))) a b)) (AddMonoidAlgebra.divOf.{u2, u1} k G _inst_1 _inst_2 (AddMonoidAlgebra.divOf.{u2, u1} k G _inst_1 _inst_2 x a) b)
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.div_of_add AddMonoidAlgebra.divOf_addₓ'. -/
theorem divOf_add (x : AddMonoidAlgebra k G) (a b : G) : x /ᵒᶠ (a + b) = x /ᵒᶠ a /ᵒᶠ b :=
  by
  ext
  simp only [AddMonoidAlgebra.divOf_apply, add_assoc]
#align add_monoid_algebra.div_of_add AddMonoidAlgebra.divOf_add

/- warning: add_monoid_algebra.div_of_hom -> AddMonoidAlgebra.divOfHom is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : AddCancelCommMonoid.{u2} G], MonoidHom.{u2, max u2 u1} (Multiplicative.{u2} G) (AddMonoid.End.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidWithOne.toAddMonoid.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.nonAssocSemiring.{u1, u2} k G _inst_1 (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2)))))))))) (Multiplicative.mulOneClass.{u2} G (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2))))) (MulZeroOneClass.toMulOneClass.{max u2 u1} (AddMonoid.End.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidWithOne.toAddMonoid.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.nonAssocSemiring.{u1, u2} k G _inst_1 (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2)))))))))) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (AddMonoid.End.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidWithOne.toAddMonoid.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.nonAssocSemiring.{u1, u2} k G _inst_1 (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2)))))))))) (Semiring.toNonAssocSemiring.{max u2 u1} (AddMonoid.End.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidWithOne.toAddMonoid.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.nonAssocSemiring.{u1, u2} k G _inst_1 (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2)))))))))) (AddMonoid.End.semiring.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.addCommMonoid.{u2, u1} k G _inst_1)))))
but is expected to have type
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : AddCancelCommMonoid.{u2} G], MonoidHom.{u2, max u2 u1} (Multiplicative.{u2} G) (AddMonoid.End.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoid.toAddZeroClass.{max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidWithOne.toAddMonoid.{max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.nonAssocSemiring.{u1, u2} k G _inst_1 (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2)))))))))) (Multiplicative.mulOneClass.{u2} G (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2))))) (MulZeroOneClass.toMulOneClass.{max u1 u2} (AddMonoid.End.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoid.toAddZeroClass.{max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidWithOne.toAddMonoid.{max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.nonAssocSemiring.{u1, u2} k G _inst_1 (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2)))))))))) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (AddMonoid.End.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoid.toAddZeroClass.{max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidWithOne.toAddMonoid.{max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.nonAssocSemiring.{u1, u2} k G _inst_1 (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2)))))))))) (Semiring.toNonAssocSemiring.{max u1 u2} (AddMonoid.End.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoid.toAddZeroClass.{max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidWithOne.toAddMonoid.{max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.nonAssocSemiring.{u1, u2} k G _inst_1 (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2)))))))))) (AddMonoid.End.semiring.{max u1 u2} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.addCommMonoid.{u1, u2} k G _inst_1)))))
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.div_of_hom AddMonoidAlgebra.divOfHomₓ'. -/
/-- A bundled version of `add_monoid_algebra.div_of`. -/
@[simps]
noncomputable def divOfHom : Multiplicative G →* AddMonoid.End (AddMonoidAlgebra k G)
    where
  toFun g :=
    { toFun := fun x => divOf x g.toAdd
      map_zero' := zero_divOf _
      map_add' := fun x y => add_divOf x y g.toAdd }
  map_one' := AddMonoidHom.ext divOf_zero
  map_mul' g₁ g₂ :=
    AddMonoidHom.ext fun x => (congr_arg _ (add_comm g₁.toAdd g₂.toAdd)).trans (divOf_add _ _ _)
#align add_monoid_algebra.div_of_hom AddMonoidAlgebra.divOfHom

/- warning: add_monoid_algebra.of'_mul_div_of -> AddMonoidAlgebra.of'_mul_divOf is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : AddCancelCommMonoid.{u2} G] (a : G) (x : AddMonoidAlgebra.{u1, u2} k G _inst_1), Eq.{max (succ u2) (succ u1)} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.divOf.{u1, u2} k G _inst_1 _inst_2 (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (instHMul.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.hasMul.{u1, u2} k G _inst_1 (AddZeroClass.toHasAdd.{u2} G (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2))))))) (AddMonoidAlgebra.of'.{u1, u2} k G _inst_1 a) x) a) x
but is expected to have type
  forall {k : Type.{u2}} {G : Type.{u1}} [_inst_1 : Semiring.{u2} k] [_inst_2 : AddCancelCommMonoid.{u1} G] (a : G) (x : AddMonoidAlgebra.{u2, u1} k G _inst_1), Eq.{max (succ u2) (succ u1)} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.divOf.{u2, u1} k G _inst_1 _inst_2 (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.{u2, u1} k G _inst_1) (instHMul.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.hasMul.{u2, u1} k G _inst_1 (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2))))))) (AddMonoidAlgebra.of'.{u2, u1} k G _inst_1 a) x) a) x
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.of'_mul_div_of AddMonoidAlgebra.of'_mul_divOfₓ'. -/
theorem of'_mul_divOf (a : G) (x : AddMonoidAlgebra k G) : of' k G a * x /ᵒᶠ a = x :=
  by
  ext b
  rw [AddMonoidAlgebra.divOf_apply, of'_apply, single_mul_apply_aux, one_mul]
  intro c
  exact add_right_inj _
#align add_monoid_algebra.of'_mul_div_of AddMonoidAlgebra.of'_mul_divOf

/- warning: add_monoid_algebra.mul_of'_div_of -> AddMonoidAlgebra.mul_of'_divOf is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : AddCancelCommMonoid.{u2} G] (x : AddMonoidAlgebra.{u1, u2} k G _inst_1) (a : G), Eq.{max (succ u2) (succ u1)} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.divOf.{u1, u2} k G _inst_1 _inst_2 (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (instHMul.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.hasMul.{u1, u2} k G _inst_1 (AddZeroClass.toHasAdd.{u2} G (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2))))))) x (AddMonoidAlgebra.of'.{u1, u2} k G _inst_1 a)) a) x
but is expected to have type
  forall {k : Type.{u2}} {G : Type.{u1}} [_inst_1 : Semiring.{u2} k] [_inst_2 : AddCancelCommMonoid.{u1} G] (x : AddMonoidAlgebra.{u2, u1} k G _inst_1) (a : G), Eq.{max (succ u2) (succ u1)} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.divOf.{u2, u1} k G _inst_1 _inst_2 (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.{u2, u1} k G _inst_1) (instHMul.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.hasMul.{u2, u1} k G _inst_1 (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2))))))) x (AddMonoidAlgebra.of'.{u2, u1} k G _inst_1 a)) a) x
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.mul_of'_div_of AddMonoidAlgebra.mul_of'_divOfₓ'. -/
theorem mul_of'_divOf (x : AddMonoidAlgebra k G) (a : G) : x * of' k G a /ᵒᶠ a = x :=
  by
  ext b
  rw [AddMonoidAlgebra.divOf_apply, of'_apply, mul_single_apply_aux, mul_one]
  intro c
  rw [add_comm]
  exact add_right_inj _
#align add_monoid_algebra.mul_of'_div_of AddMonoidAlgebra.mul_of'_divOf

/- warning: add_monoid_algebra.of'_div_of -> AddMonoidAlgebra.of'_divOf is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : AddCancelCommMonoid.{u2} G] (a : G), Eq.{max (succ u2) (succ u1)} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.divOf.{u1, u2} k G _inst_1 _inst_2 (AddMonoidAlgebra.of'.{u1, u2} k G _inst_1 a) a) (OfNat.ofNat.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) 1 (OfNat.mk.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) 1 (One.one.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.one.{u1, u2} k G _inst_1 (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2)))))))))
but is expected to have type
  forall {k : Type.{u2}} {G : Type.{u1}} [_inst_1 : Semiring.{u2} k] [_inst_2 : AddCancelCommMonoid.{u1} G] (a : G), Eq.{max (succ u2) (succ u1)} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.divOf.{u2, u1} k G _inst_1 _inst_2 (AddMonoidAlgebra.of'.{u2, u1} k G _inst_1 a) a) (OfNat.ofNat.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) 1 (One.toOfNat1.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.one.{u2, u1} k G _inst_1 (AddRightCancelMonoid.toZero.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2))))))
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.of'_div_of AddMonoidAlgebra.of'_divOfₓ'. -/
theorem of'_divOf (a : G) : of' k G a /ᵒᶠ a = 1 := by
  simpa only [one_mul] using mul_of'_div_of (1 : AddMonoidAlgebra k G) a
#align add_monoid_algebra.of'_div_of AddMonoidAlgebra.of'_divOf

#print AddMonoidAlgebra.modOf /-
/-- The remainder upon division by `of' k G g`. -/
noncomputable def modOf (x : AddMonoidAlgebra k G) (g : G) : AddMonoidAlgebra k G :=
  x.filterₓ fun g₁ => ¬∃ g₂, g₁ = g + g₂
#align add_monoid_algebra.mod_of AddMonoidAlgebra.modOf
-/

-- mathport name: «expr %ᵒᶠ »
local infixl:70 " %ᵒᶠ " => modOf

/- warning: add_monoid_algebra.mod_of_apply_of_not_exists_add -> AddMonoidAlgebra.modOf_apply_of_not_exists_add is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : AddCancelCommMonoid.{u2} G] (x : AddMonoidAlgebra.{u1, u2} k G _inst_1) (g : G) (g' : G), (Not (Exists.{succ u2} G (fun (d : G) => Eq.{succ u2} G g' (HAdd.hAdd.{u2, u2, u2} G G G (instHAdd.{u2} G (AddZeroClass.toHasAdd.{u2} G (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2)))))) g d)))) -> (Eq.{succ u1} k (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (fun (_x : AddMonoidAlgebra.{u1, u2} k G _inst_1) => G -> k) (AddMonoidAlgebra.coeFun.{u1, u2} k G _inst_1) (AddMonoidAlgebra.modOf.{u1, u2} k G _inst_1 _inst_2 x g) g') (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (fun (_x : AddMonoidAlgebra.{u1, u2} k G _inst_1) => G -> k) (AddMonoidAlgebra.coeFun.{u1, u2} k G _inst_1) x g'))
but is expected to have type
  forall {k : Type.{u2}} {G : Type.{u1}} [_inst_1 : Semiring.{u2} k] [_inst_2 : AddCancelCommMonoid.{u1} G] (x : AddMonoidAlgebra.{u2, u1} k G _inst_1) (g : G) (g' : G), (Not (Exists.{succ u1} G (fun (d : G) => Eq.{succ u1} G g' (HAdd.hAdd.{u1, u1, u1} G G G (instHAdd.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2)))))) g d)))) -> (Eq.{succ u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : G) => k) g') (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Finsupp.{u1, u2} G k (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k _inst_1))) G (fun (_x : G) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : G) => k) _x) (Finsupp.funLike.{u1, u2} G k (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k _inst_1))) (AddMonoidAlgebra.modOf.{u2, u1} k G _inst_1 _inst_2 x g) g') (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Finsupp.{u1, u2} G k (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k _inst_1))) G (fun (_x : G) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : G) => k) _x) (Finsupp.funLike.{u1, u2} G k (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k _inst_1))) x g'))
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.mod_of_apply_of_not_exists_add AddMonoidAlgebra.modOf_apply_of_not_exists_addₓ'. -/
@[simp]
theorem modOf_apply_of_not_exists_add (x : AddMonoidAlgebra k G) (g : G) (g' : G)
    (h : ¬∃ d, g' = g + d) : (x %ᵒᶠ g) g' = x g' :=
  Finsupp.filter_apply_pos _ _ h
#align add_monoid_algebra.mod_of_apply_of_not_exists_add AddMonoidAlgebra.modOf_apply_of_not_exists_add

/- warning: add_monoid_algebra.mod_of_apply_of_exists_add -> AddMonoidAlgebra.modOf_apply_of_exists_add is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : AddCancelCommMonoid.{u2} G] (x : AddMonoidAlgebra.{u1, u2} k G _inst_1) (g : G) (g' : G), (Exists.{succ u2} G (fun (d : G) => Eq.{succ u2} G g' (HAdd.hAdd.{u2, u2, u2} G G G (instHAdd.{u2} G (AddZeroClass.toHasAdd.{u2} G (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2)))))) g d))) -> (Eq.{succ u1} k (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (fun (_x : AddMonoidAlgebra.{u1, u2} k G _inst_1) => G -> k) (AddMonoidAlgebra.coeFun.{u1, u2} k G _inst_1) (AddMonoidAlgebra.modOf.{u1, u2} k G _inst_1 _inst_2 x g) g') (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1))))))))
but is expected to have type
  forall {k : Type.{u2}} {G : Type.{u1}} [_inst_1 : Semiring.{u2} k] [_inst_2 : AddCancelCommMonoid.{u1} G] (x : AddMonoidAlgebra.{u2, u1} k G _inst_1) (g : G) (g' : G), (Exists.{succ u1} G (fun (d : G) => Eq.{succ u1} G g' (HAdd.hAdd.{u1, u1, u1} G G G (instHAdd.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2)))))) g d))) -> (Eq.{succ u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : G) => k) g') (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Finsupp.{u1, u2} G k (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k _inst_1))) G (fun (_x : G) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : G) => k) _x) (Finsupp.funLike.{u1, u2} G k (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k _inst_1))) (AddMonoidAlgebra.modOf.{u2, u1} k G _inst_1 _inst_2 x g) g') (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : G) => k) g') 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : G) => k) g') (MonoidWithZero.toZero.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : G) => k) g') (Semiring.toMonoidWithZero.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : G) => k) g') _inst_1)))))
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.mod_of_apply_of_exists_add AddMonoidAlgebra.modOf_apply_of_exists_addₓ'. -/
@[simp]
theorem modOf_apply_of_exists_add (x : AddMonoidAlgebra k G) (g : G) (g' : G)
    (h : ∃ d, g' = g + d) : (x %ᵒᶠ g) g' = 0 :=
  Finsupp.filter_apply_neg _ _ <| by rwa [Classical.not_not]
#align add_monoid_algebra.mod_of_apply_of_exists_add AddMonoidAlgebra.modOf_apply_of_exists_add

/- warning: add_monoid_algebra.mod_of_apply_add_self -> AddMonoidAlgebra.modOf_apply_add_self is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : AddCancelCommMonoid.{u2} G] (x : AddMonoidAlgebra.{u1, u2} k G _inst_1) (g : G) (d : G), Eq.{succ u1} k (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (fun (_x : AddMonoidAlgebra.{u1, u2} k G _inst_1) => G -> k) (AddMonoidAlgebra.coeFun.{u1, u2} k G _inst_1) (AddMonoidAlgebra.modOf.{u1, u2} k G _inst_1 _inst_2 x g) (HAdd.hAdd.{u2, u2, u2} G G G (instHAdd.{u2} G (AddZeroClass.toHasAdd.{u2} G (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2)))))) d g)) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))))))
but is expected to have type
  forall {k : Type.{u2}} {G : Type.{u1}} [_inst_1 : Semiring.{u2} k] [_inst_2 : AddCancelCommMonoid.{u1} G] (x : AddMonoidAlgebra.{u2, u1} k G _inst_1) (g : G) (d : G), Eq.{succ u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : G) => k) (HAdd.hAdd.{u1, u1, u1} G G G (instHAdd.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2)))))) d g)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Finsupp.{u1, u2} G k (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k _inst_1))) G (fun (_x : G) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : G) => k) _x) (Finsupp.funLike.{u1, u2} G k (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k _inst_1))) (AddMonoidAlgebra.modOf.{u2, u1} k G _inst_1 _inst_2 x g) (HAdd.hAdd.{u1, u1, u1} G G G (instHAdd.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2)))))) d g)) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : G) => k) (HAdd.hAdd.{u1, u1, u1} G G G (instHAdd.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2)))))) d g)) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : G) => k) (HAdd.hAdd.{u1, u1, u1} G G G (instHAdd.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2)))))) d g)) (MonoidWithZero.toZero.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : G) => k) (HAdd.hAdd.{u1, u1, u1} G G G (instHAdd.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2)))))) d g)) (Semiring.toMonoidWithZero.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : G) => k) (HAdd.hAdd.{u1, u1, u1} G G G (instHAdd.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2)))))) d g)) _inst_1))))
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.mod_of_apply_add_self AddMonoidAlgebra.modOf_apply_add_selfₓ'. -/
@[simp]
theorem modOf_apply_add_self (x : AddMonoidAlgebra k G) (g : G) (d : G) : (x %ᵒᶠ g) (d + g) = 0 :=
  modOf_apply_of_exists_add _ _ _ ⟨_, add_comm _ _⟩
#align add_monoid_algebra.mod_of_apply_add_self AddMonoidAlgebra.modOf_apply_add_self

/- warning: add_monoid_algebra.mod_of_apply_self_add -> AddMonoidAlgebra.modOf_apply_self_add is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : AddCancelCommMonoid.{u2} G] (x : AddMonoidAlgebra.{u1, u2} k G _inst_1) (g : G) (d : G), Eq.{succ u1} k (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (fun (_x : AddMonoidAlgebra.{u1, u2} k G _inst_1) => G -> k) (AddMonoidAlgebra.coeFun.{u1, u2} k G _inst_1) (AddMonoidAlgebra.modOf.{u1, u2} k G _inst_1 _inst_2 x g) (HAdd.hAdd.{u2, u2, u2} G G G (instHAdd.{u2} G (AddZeroClass.toHasAdd.{u2} G (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2)))))) g d)) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k _inst_1)))))))
but is expected to have type
  forall {k : Type.{u2}} {G : Type.{u1}} [_inst_1 : Semiring.{u2} k] [_inst_2 : AddCancelCommMonoid.{u1} G] (x : AddMonoidAlgebra.{u2, u1} k G _inst_1) (g : G) (d : G), Eq.{succ u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : G) => k) (HAdd.hAdd.{u1, u1, u1} G G G (instHAdd.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2)))))) g d)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Finsupp.{u1, u2} G k (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k _inst_1))) G (fun (_x : G) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : G) => k) _x) (Finsupp.funLike.{u1, u2} G k (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k _inst_1))) (AddMonoidAlgebra.modOf.{u2, u1} k G _inst_1 _inst_2 x g) (HAdd.hAdd.{u1, u1, u1} G G G (instHAdd.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2)))))) g d)) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : G) => k) (HAdd.hAdd.{u1, u1, u1} G G G (instHAdd.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2)))))) g d)) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : G) => k) (HAdd.hAdd.{u1, u1, u1} G G G (instHAdd.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2)))))) g d)) (MonoidWithZero.toZero.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : G) => k) (HAdd.hAdd.{u1, u1, u1} G G G (instHAdd.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2)))))) g d)) (Semiring.toMonoidWithZero.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : G) => k) (HAdd.hAdd.{u1, u1, u1} G G G (instHAdd.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2)))))) g d)) _inst_1))))
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.mod_of_apply_self_add AddMonoidAlgebra.modOf_apply_self_addₓ'. -/
@[simp]
theorem modOf_apply_self_add (x : AddMonoidAlgebra k G) (g : G) (d : G) : (x %ᵒᶠ g) (g + d) = 0 :=
  modOf_apply_of_exists_add _ _ _ ⟨_, rfl⟩
#align add_monoid_algebra.mod_of_apply_self_add AddMonoidAlgebra.modOf_apply_self_add

/- warning: add_monoid_algebra.of'_mul_mod_of -> AddMonoidAlgebra.of'_mul_modOf is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : AddCancelCommMonoid.{u2} G] (g : G) (x : AddMonoidAlgebra.{u1, u2} k G _inst_1), Eq.{max (succ u2) (succ u1)} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.modOf.{u1, u2} k G _inst_1 _inst_2 (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (instHMul.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.hasMul.{u1, u2} k G _inst_1 (AddZeroClass.toHasAdd.{u2} G (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2))))))) (AddMonoidAlgebra.of'.{u1, u2} k G _inst_1 g) x) g) (OfNat.ofNat.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) 0 (OfNat.mk.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) 0 (Zero.zero.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (MulZeroClass.toHasZero.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (NonUnitalNonAssocSemiring.toMulZeroClass.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.nonUnitalNonAssocSemiring.{u1, u2} k G _inst_1 (AddZeroClass.toHasAdd.{u2} G (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2)))))))))))
but is expected to have type
  forall {k : Type.{u2}} {G : Type.{u1}} [_inst_1 : Semiring.{u2} k] [_inst_2 : AddCancelCommMonoid.{u1} G] (g : G) (x : AddMonoidAlgebra.{u2, u1} k G _inst_1), Eq.{max (succ u2) (succ u1)} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.modOf.{u2, u1} k G _inst_1 _inst_2 (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.{u2, u1} k G _inst_1) (instHMul.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.hasMul.{u2, u1} k G _inst_1 (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2))))))) (AddMonoidAlgebra.of'.{u2, u1} k G _inst_1 g) x) g) (OfNat.ofNat.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) 0 (Zero.toOfNat0.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (MonoidWithZero.toZero.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (Semiring.toMonoidWithZero.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.semiring.{u2, u1} k G _inst_1 (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2))))))))
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.of'_mul_mod_of AddMonoidAlgebra.of'_mul_modOfₓ'. -/
theorem of'_mul_modOf (g : G) (x : AddMonoidAlgebra k G) : of' k G g * x %ᵒᶠ g = 0 :=
  by
  ext g'
  rw [Finsupp.zero_apply]
  obtain ⟨d, rfl⟩ | h := em (∃ d, g' = g + d)
  · rw [mod_of_apply_self_add]
  · rw [mod_of_apply_of_not_exists_add _ _ _ h, of'_apply, single_mul_apply_of_not_exists_add _ _ h]
#align add_monoid_algebra.of'_mul_mod_of AddMonoidAlgebra.of'_mul_modOf

/- warning: add_monoid_algebra.mul_of'_mod_of -> AddMonoidAlgebra.mul_of'_modOf is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : AddCancelCommMonoid.{u2} G] (x : AddMonoidAlgebra.{u1, u2} k G _inst_1) (g : G), Eq.{max (succ u2) (succ u1)} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.modOf.{u1, u2} k G _inst_1 _inst_2 (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (instHMul.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.hasMul.{u1, u2} k G _inst_1 (AddZeroClass.toHasAdd.{u2} G (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2))))))) x (AddMonoidAlgebra.of'.{u1, u2} k G _inst_1 g)) g) (OfNat.ofNat.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) 0 (OfNat.mk.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) 0 (Zero.zero.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (MulZeroClass.toHasZero.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (NonUnitalNonAssocSemiring.toMulZeroClass.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.nonUnitalNonAssocSemiring.{u1, u2} k G _inst_1 (AddZeroClass.toHasAdd.{u2} G (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2)))))))))))
but is expected to have type
  forall {k : Type.{u2}} {G : Type.{u1}} [_inst_1 : Semiring.{u2} k] [_inst_2 : AddCancelCommMonoid.{u1} G] (x : AddMonoidAlgebra.{u2, u1} k G _inst_1) (g : G), Eq.{max (succ u2) (succ u1)} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.modOf.{u2, u1} k G _inst_1 _inst_2 (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.{u2, u1} k G _inst_1) (instHMul.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.hasMul.{u2, u1} k G _inst_1 (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2))))))) x (AddMonoidAlgebra.of'.{u2, u1} k G _inst_1 g)) g) (OfNat.ofNat.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) 0 (Zero.toOfNat0.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (MonoidWithZero.toZero.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (Semiring.toMonoidWithZero.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.semiring.{u2, u1} k G _inst_1 (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2))))))))
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.mul_of'_mod_of AddMonoidAlgebra.mul_of'_modOfₓ'. -/
theorem mul_of'_modOf (x : AddMonoidAlgebra k G) (g : G) : x * of' k G g %ᵒᶠ g = 0 :=
  by
  ext g'
  rw [Finsupp.zero_apply]
  obtain ⟨d, rfl⟩ | h := em (∃ d, g' = g + d)
  · rw [mod_of_apply_self_add]
  · rw [mod_of_apply_of_not_exists_add _ _ _ h, of'_apply, mul_single_apply_of_not_exists_add]
    simpa only [add_comm] using h
#align add_monoid_algebra.mul_of'_mod_of AddMonoidAlgebra.mul_of'_modOf

/- warning: add_monoid_algebra.of'_mod_of -> AddMonoidAlgebra.of'_modOf is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : AddCancelCommMonoid.{u2} G] (g : G), Eq.{max (succ u2) (succ u1)} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.modOf.{u1, u2} k G _inst_1 _inst_2 (AddMonoidAlgebra.of'.{u1, u2} k G _inst_1 g) g) (OfNat.ofNat.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) 0 (OfNat.mk.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) 0 (Zero.zero.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (MulZeroClass.toHasZero.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (NonUnitalNonAssocSemiring.toMulZeroClass.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.nonUnitalNonAssocSemiring.{u1, u2} k G _inst_1 (AddZeroClass.toHasAdd.{u2} G (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2)))))))))))
but is expected to have type
  forall {k : Type.{u2}} {G : Type.{u1}} [_inst_1 : Semiring.{u2} k] [_inst_2 : AddCancelCommMonoid.{u1} G] (g : G), Eq.{max (succ u2) (succ u1)} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.modOf.{u2, u1} k G _inst_1 _inst_2 (AddMonoidAlgebra.of'.{u2, u1} k G _inst_1 g) g) (OfNat.ofNat.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) 0 (Zero.toOfNat0.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (MonoidWithZero.toZero.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (Semiring.toMonoidWithZero.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.semiring.{u2, u1} k G _inst_1 (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2))))))))
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.of'_mod_of AddMonoidAlgebra.of'_modOfₓ'. -/
theorem of'_modOf (g : G) : of' k G g %ᵒᶠ g = 0 := by
  simpa only [one_mul] using mul_of'_mod_of (1 : AddMonoidAlgebra k G) g
#align add_monoid_algebra.of'_mod_of AddMonoidAlgebra.of'_modOf

/- warning: add_monoid_algebra.div_of_add_mod_of -> AddMonoidAlgebra.divOf_add_modOf is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : AddCancelCommMonoid.{u2} G] (x : AddMonoidAlgebra.{u1, u2} k G _inst_1) (g : G), Eq.{succ (max u2 u1)} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (instHAdd.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (Distrib.toHasAdd.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (NonUnitalNonAssocSemiring.toDistrib.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.nonUnitalNonAssocSemiring.{u1, u2} k G _inst_1 (AddZeroClass.toHasAdd.{u2} G (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2))))))))) (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (instHMul.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.hasMul.{u1, u2} k G _inst_1 (AddZeroClass.toHasAdd.{u2} G (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2))))))) (AddMonoidAlgebra.of'.{u1, u2} k G _inst_1 g) (AddMonoidAlgebra.divOf.{u1, u2} k G _inst_1 _inst_2 x g)) (AddMonoidAlgebra.modOf.{u1, u2} k G _inst_1 _inst_2 x g)) x
but is expected to have type
  forall {k : Type.{u2}} {G : Type.{u1}} [_inst_1 : Semiring.{u2} k] [_inst_2 : AddCancelCommMonoid.{u1} G] (x : AddMonoidAlgebra.{u2, u1} k G _inst_1) (g : G), Eq.{max (succ u2) (succ u1)} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.{u2, u1} k G _inst_1) (instHAdd.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (Distrib.toAdd.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (NonUnitalNonAssocSemiring.toDistrib.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.nonUnitalNonAssocSemiring.{u2, u1} k G _inst_1 (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2))))))))) (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.{u2, u1} k G _inst_1) (instHMul.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.hasMul.{u2, u1} k G _inst_1 (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2))))))) (AddMonoidAlgebra.of'.{u2, u1} k G _inst_1 g) (AddMonoidAlgebra.divOf.{u2, u1} k G _inst_1 _inst_2 x g)) (AddMonoidAlgebra.modOf.{u2, u1} k G _inst_1 _inst_2 x g)) x
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.div_of_add_mod_of AddMonoidAlgebra.divOf_add_modOfₓ'. -/
theorem divOf_add_modOf (x : AddMonoidAlgebra k G) (g : G) : of' k G g * (x /ᵒᶠ g) + x %ᵒᶠ g = x :=
  by
  ext g'
  simp_rw [Finsupp.add_apply]
  obtain ⟨d, rfl⟩ | h := em (∃ d, g' = g + d)
  swap
  ·
    rw [mod_of_apply_of_not_exists_add _ _ _ h, of'_apply, single_mul_apply_of_not_exists_add _ _ h,
      zero_add]
  · rw [mod_of_apply_self_add, add_zero]
    rw [of'_apply, single_mul_apply_aux _ _ _, one_mul, div_of_apply]
    intro a
    exact add_right_inj _
#align add_monoid_algebra.div_of_add_mod_of AddMonoidAlgebra.divOf_add_modOf

/- warning: add_monoid_algebra.mod_of_add_div_of -> AddMonoidAlgebra.modOf_add_divOf is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : AddCancelCommMonoid.{u2} G] (x : AddMonoidAlgebra.{u1, u2} k G _inst_1) (g : G), Eq.{succ (max u2 u1)} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (instHAdd.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (Distrib.toHasAdd.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (NonUnitalNonAssocSemiring.toDistrib.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.nonUnitalNonAssocSemiring.{u1, u2} k G _inst_1 (AddZeroClass.toHasAdd.{u2} G (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2))))))))) (AddMonoidAlgebra.modOf.{u1, u2} k G _inst_1 _inst_2 x g) (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.{u1, u2} k G _inst_1) (instHMul.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.hasMul.{u1, u2} k G _inst_1 (AddZeroClass.toHasAdd.{u2} G (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2))))))) (AddMonoidAlgebra.of'.{u1, u2} k G _inst_1 g) (AddMonoidAlgebra.divOf.{u1, u2} k G _inst_1 _inst_2 x g))) x
but is expected to have type
  forall {k : Type.{u2}} {G : Type.{u1}} [_inst_1 : Semiring.{u2} k] [_inst_2 : AddCancelCommMonoid.{u1} G] (x : AddMonoidAlgebra.{u2, u1} k G _inst_1) (g : G), Eq.{max (succ u2) (succ u1)} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.{u2, u1} k G _inst_1) (instHAdd.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (Distrib.toAdd.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (NonUnitalNonAssocSemiring.toDistrib.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.nonUnitalNonAssocSemiring.{u2, u1} k G _inst_1 (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2))))))))) (AddMonoidAlgebra.modOf.{u2, u1} k G _inst_1 _inst_2 x g) (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.{u2, u1} k G _inst_1) (instHMul.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.hasMul.{u2, u1} k G _inst_1 (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2))))))) (AddMonoidAlgebra.of'.{u2, u1} k G _inst_1 g) (AddMonoidAlgebra.divOf.{u2, u1} k G _inst_1 _inst_2 x g))) x
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.mod_of_add_div_of AddMonoidAlgebra.modOf_add_divOfₓ'. -/
theorem modOf_add_divOf (x : AddMonoidAlgebra k G) (g : G) : x %ᵒᶠ g + of' k G g * (x /ᵒᶠ g) = x :=
  by rw [add_comm, div_of_add_mod_of]
#align add_monoid_algebra.mod_of_add_div_of AddMonoidAlgebra.modOf_add_divOf

/- warning: add_monoid_algebra.of'_dvd_iff_mod_of_eq_zero -> AddMonoidAlgebra.of'_dvd_iff_modOf_eq_zero is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {G : Type.{u2}} [_inst_1 : Semiring.{u1} k] [_inst_2 : AddCancelCommMonoid.{u2} G] {x : AddMonoidAlgebra.{u1, u2} k G _inst_1} {g : G}, Iff (Dvd.Dvd.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (semigroupDvd.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (SemigroupWithZero.toSemigroup.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (NonUnitalSemiring.toSemigroupWithZero.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.nonUnitalSemiring.{u1, u2} k G _inst_1 (AddMonoid.toAddSemigroup.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2)))))))) (AddMonoidAlgebra.of'.{u1, u2} k G _inst_1 g) x) (Eq.{max (succ u2) (succ u1)} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.modOf.{u1, u2} k G _inst_1 _inst_2 x g) (OfNat.ofNat.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) 0 (OfNat.mk.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) 0 (Zero.zero.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (MulZeroClass.toHasZero.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (NonUnitalNonAssocSemiring.toMulZeroClass.{max u2 u1} (AddMonoidAlgebra.{u1, u2} k G _inst_1) (AddMonoidAlgebra.nonUnitalNonAssocSemiring.{u1, u2} k G _inst_1 (AddZeroClass.toHasAdd.{u2} G (AddMonoid.toAddZeroClass.{u2} G (AddRightCancelMonoid.toAddMonoid.{u2} G (AddCancelMonoid.toAddRightCancelMonoid.{u2} G (AddCancelCommMonoid.toAddCancelMonoid.{u2} G _inst_2))))))))))))
but is expected to have type
  forall {k : Type.{u2}} {G : Type.{u1}} [_inst_1 : Semiring.{u2} k] [_inst_2 : AddCancelCommMonoid.{u1} G] {x : AddMonoidAlgebra.{u2, u1} k G _inst_1} {g : G}, Iff (Dvd.dvd.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (semigroupDvd.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (SemigroupWithZero.toSemigroup.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (NonUnitalSemiring.toSemigroupWithZero.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.nonUnitalSemiring.{u2, u1} k G _inst_1 (AddMonoid.toAddSemigroup.{u1} G (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2)))))))) (AddMonoidAlgebra.of'.{u2, u1} k G _inst_1 g) x) (Eq.{max (succ u2) (succ u1)} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.modOf.{u2, u1} k G _inst_1 _inst_2 x g) (OfNat.ofNat.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) 0 (Zero.toOfNat0.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (MonoidWithZero.toZero.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (Semiring.toMonoidWithZero.{max u2 u1} (AddMonoidAlgebra.{u2, u1} k G _inst_1) (AddMonoidAlgebra.semiring.{u2, u1} k G _inst_1 (AddRightCancelMonoid.toAddMonoid.{u1} G (AddCancelMonoid.toAddRightCancelMonoid.{u1} G (AddCancelCommMonoid.toAddCancelMonoid.{u1} G _inst_2)))))))))
Case conversion may be inaccurate. Consider using '#align add_monoid_algebra.of'_dvd_iff_mod_of_eq_zero AddMonoidAlgebra.of'_dvd_iff_modOf_eq_zeroₓ'. -/
theorem of'_dvd_iff_modOf_eq_zero {x : AddMonoidAlgebra k G} {g : G} :
    of' k G g ∣ x ↔ x %ᵒᶠ g = 0 := by
  constructor
  · rintro ⟨x, rfl⟩
    rw [of'_mul_mod_of]
  · intro h
    rw [← div_of_add_mod_of x g, h, add_zero]
    exact dvd_mul_right _ _
#align add_monoid_algebra.of'_dvd_iff_mod_of_eq_zero AddMonoidAlgebra.of'_dvd_iff_modOf_eq_zero

end

end AddMonoidAlgebra

