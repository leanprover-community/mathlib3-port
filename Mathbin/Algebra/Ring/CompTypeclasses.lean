/-
Copyright (c) 2021 Frédéric Dupuis. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Frédéric Dupuis, Heather Macbeth

! This file was ported from Lean 3 source module algebra.ring.comp_typeclasses
! leanprover-community/mathlib commit e3d9ab8faa9dea8f78155c6c27d62a621f4c152d
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Ring.Equiv

/-!
# Propositional typeclasses on several ring homs

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file contains three typeclasses used in the definition of (semi)linear maps:
* `ring_hom_comp_triple σ₁₂ σ₂₃ σ₁₃`, which expresses the fact that `σ₂₃.comp σ₁₂ = σ₁₃`
* `ring_hom_inv_pair σ₁₂ σ₂₁`, which states that `σ₁₂` and `σ₂₁` are inverses of each other
* `ring_hom_surjective σ`, which states that `σ` is surjective
These typeclasses ensure that objects such as `σ₂₃.comp σ₁₂` never end up in the type of a
semilinear map; instead, the typeclass system directly finds the appropriate `ring_hom` to use.
A typical use-case is conjugate-linear maps, i.e. when `σ = complex.conj`; this system ensures that
composing two conjugate-linear maps is a linear map, and not a `conj.comp conj`-linear map.

Instances of these typeclasses mostly involving `ring_hom.id` are also provided:
* `ring_hom_inv_pair (ring_hom.id R) (ring_hom.id R)`
* `[ring_hom_inv_pair σ₁₂ σ₂₁] : ring_hom_comp_triple σ₁₂ σ₂₁ (ring_hom.id R₁)`
* `ring_hom_comp_triple (ring_hom.id R₁) σ₁₂ σ₁₂`
* `ring_hom_comp_triple σ₁₂ (ring_hom.id R₂) σ₁₂`
* `ring_hom_surjective (ring_hom.id R)`
* `[ring_hom_inv_pair σ₁ σ₂] : ring_hom_surjective σ₁`

## Implementation notes

* For the typeclass `ring_hom_inv_pair σ₁₂ σ₂₁`, `σ₂₁` is marked as an `out_param`,
  as it must typically be found via the typeclass inference system.

* Likewise, for `ring_hom_comp_triple σ₁₂ σ₂₃ σ₁₃`, `σ₁₃` is marked as an `out_param`,
  for the same reason.

## Tags

`ring_hom_comp_triple`, `ring_hom_inv_pair`, `ring_hom_surjective`
-/


variable {R₁ : Type _} {R₂ : Type _} {R₃ : Type _}

variable [Semiring R₁] [Semiring R₂] [Semiring R₃]

#print RingHomCompTriple /-
/-- Class that expresses the fact that three ring homomorphisms form a composition triple. This is
used to handle composition of semilinear maps. -/
class RingHomCompTriple (σ₁₂ : R₁ →+* R₂) (σ₂₃ : R₂ →+* R₃) (σ₁₃ : outParam (R₁ →+* R₃)) :
  Prop where
  comp_eq : σ₂₃.comp σ₁₂ = σ₁₃
#align ring_hom_comp_triple RingHomCompTriple
-/

attribute [simp] RingHomCompTriple.comp_eq

variable {σ₁₂ : R₁ →+* R₂} {σ₂₃ : R₂ →+* R₃} {σ₁₃ : R₁ →+* R₃}

namespace RingHomCompTriple

/- warning: ring_hom_comp_triple.comp_apply -> RingHomCompTriple.comp_apply is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {R₃ : Type.{u3}} [_inst_1 : Semiring.{u1} R₁] [_inst_2 : Semiring.{u2} R₂] [_inst_3 : Semiring.{u3} R₃] {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)} {σ₂₃ : RingHom.{u2, u3} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_3)} {σ₁₃ : RingHom.{u1, u3} R₁ R₃ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_3)} [_inst_4 : RingHomCompTriple.{u1, u2, u3} R₁ R₂ R₃ _inst_1 _inst_2 _inst_3 σ₁₂ σ₂₃ σ₁₃] {x : R₁}, Eq.{succ u3} R₃ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (RingHom.{u2, u3} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_3)) (fun (_x : RingHom.{u2, u3} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_3)) => R₂ -> R₃) (RingHom.hasCoeToFun.{u2, u3} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_3)) σ₂₃ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) (fun (_x : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) => R₁ -> R₂) (RingHom.hasCoeToFun.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) σ₁₂ x)) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (RingHom.{u1, u3} R₁ R₃ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_3)) (fun (_x : RingHom.{u1, u3} R₁ R₃ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_3)) => R₁ -> R₃) (RingHom.hasCoeToFun.{u1, u3} R₁ R₃ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_3)) σ₁₃ x)
but is expected to have type
  forall {R₁ : Type.{u3}} {R₂ : Type.{u2}} {R₃ : Type.{u1}} [_inst_1 : Semiring.{u3} R₁] [_inst_2 : Semiring.{u2} R₂] [_inst_3 : Semiring.{u1} R₃] {σ₁₂ : RingHom.{u3, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)} {σ₂₃ : RingHom.{u2, u1} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₃ _inst_3)} {σ₁₃ : RingHom.{u3, u1} R₁ R₃ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u1} R₃ _inst_3)} [_inst_4 : RingHomCompTriple.{u3, u2, u1} R₁ R₂ R₃ _inst_1 _inst_2 _inst_3 σ₁₂ σ₂₃ σ₁₃] {x : R₁}, Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : R₂) => R₃) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (RingHom.{u3, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) R₁ (fun (a : R₁) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : R₁) => R₂) a) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (RingHom.{u3, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) R₁ R₂ (NonUnitalNonAssocSemiring.toMul.{u3} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u2} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) R₁ R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) R₁ R₂ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (RingHom.instRingHomClassRingHom.{u3, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2))))) σ₁₂ x)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₃ _inst_3)) R₂ (fun (_x : R₂) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : R₂) => R₃) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₃ _inst_3)) R₂ R₃ (NonUnitalNonAssocSemiring.toMul.{u2} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u1} R₃ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₃ (Semiring.toNonAssocSemiring.{u1} R₃ _inst_3))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₃ _inst_3)) R₂ R₃ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₃ (Semiring.toNonAssocSemiring.{u1} R₃ _inst_3)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₃ _inst_3)) R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₃ _inst_3) (RingHom.instRingHomClassRingHom.{u2, u1} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₃ _inst_3))))) σ₂₃ (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (RingHom.{u3, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) R₁ (fun (_x : R₁) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : R₁) => R₂) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (RingHom.{u3, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) R₁ R₂ (NonUnitalNonAssocSemiring.toMul.{u3} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u2} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) R₁ R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) R₁ R₂ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (RingHom.instRingHomClassRingHom.{u3, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2))))) σ₁₂ x)) (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (RingHom.{u3, u1} R₁ R₃ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u1} R₃ _inst_3)) R₁ (fun (_x : R₁) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : R₁) => R₃) _x) (MulHomClass.toFunLike.{max u3 u1, u3, u1} (RingHom.{u3, u1} R₁ R₃ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u1} R₃ _inst_3)) R₁ R₃ (NonUnitalNonAssocSemiring.toMul.{u3} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R₃ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₃ (Semiring.toNonAssocSemiring.{u1} R₃ _inst_3))) (NonUnitalRingHomClass.toMulHomClass.{max u3 u1, u3, u1} (RingHom.{u3, u1} R₁ R₃ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u1} R₃ _inst_3)) R₁ R₃ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R₁ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₃ (Semiring.toNonAssocSemiring.{u1} R₃ _inst_3)) (RingHomClass.toNonUnitalRingHomClass.{max u3 u1, u3, u1} (RingHom.{u3, u1} R₁ R₃ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u1} R₃ _inst_3)) R₁ R₃ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u1} R₃ _inst_3) (RingHom.instRingHomClassRingHom.{u3, u1} R₁ R₃ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u1} R₃ _inst_3))))) σ₁₃ x)
Case conversion may be inaccurate. Consider using '#align ring_hom_comp_triple.comp_apply RingHomCompTriple.comp_applyₓ'. -/
@[simp]
theorem comp_apply [RingHomCompTriple σ₁₂ σ₂₃ σ₁₃] {x : R₁} : σ₂₃ (σ₁₂ x) = σ₁₃ x :=
  RingHom.congr_fun comp_eq x
#align ring_hom_comp_triple.comp_apply RingHomCompTriple.comp_apply

end RingHomCompTriple

#print RingHomInvPair /-
/-- Class that expresses the fact that two ring homomorphisms are inverses of each other. This is
used to handle `symm` for semilinear equivalences. -/
class RingHomInvPair (σ : R₁ →+* R₂) (σ' : outParam (R₂ →+* R₁)) : Prop where
  comp_eq : σ'.comp σ = RingHom.id R₁
  comp_eq₂ : σ.comp σ' = RingHom.id R₂
#align ring_hom_inv_pair RingHomInvPair
-/

attribute [simp] RingHomInvPair.comp_eq

attribute [simp] RingHomInvPair.comp_eq₂

variable {σ : R₁ →+* R₂} {σ' : R₂ →+* R₁}

namespace RingHomInvPair

variable [RingHomInvPair σ σ']

/- warning: ring_hom_inv_pair.comp_apply_eq -> RingHomInvPair.comp_apply_eq is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} [_inst_1 : Semiring.{u1} R₁] [_inst_2 : Semiring.{u2} R₂] {σ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)} {σ' : RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)} [_inst_4 : RingHomInvPair.{u1, u2} R₁ R₂ _inst_1 _inst_2 σ σ'] {x : R₁}, Eq.{succ u1} R₁ (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)) (fun (_x : RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)) => R₂ -> R₁) (RingHom.hasCoeToFun.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)) σ' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) (fun (_x : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) => R₁ -> R₂) (RingHom.hasCoeToFun.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) σ x)) x
but is expected to have type
  forall {R₁ : Type.{u2}} {R₂ : Type.{u1}} [_inst_1 : Semiring.{u2} R₁] [_inst_2 : Semiring.{u1} R₂] {σ : RingHom.{u2, u1} R₁ R₂ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2)} {σ' : RingHom.{u1, u2} R₂ R₁ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1)} [_inst_4 : RingHomInvPair.{u2, u1} R₁ R₂ _inst_1 _inst_2 σ σ'] {x : R₁}, Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : R₂) => R₁) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R₁ R₂ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2)) R₁ (fun (a : R₁) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : R₁) => R₂) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R₁ R₂ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2)) R₁ R₂ (NonUnitalNonAssocSemiring.toMul.{u2} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₁ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₂ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R₁ R₂ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2)) R₁ R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₁ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₂ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R₁ R₂ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2)) R₁ R₂ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2) (RingHom.instRingHomClassRingHom.{u2, u1} R₁ R₂ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2))))) σ x)) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (RingHom.{u1, u2} R₂ R₁ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1)) R₂ (fun (_x : R₂) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : R₂) => R₁) _x) (MulHomClass.toFunLike.{max u2 u1, u1, u2} (RingHom.{u1, u2} R₂ R₁ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1)) R₂ R₁ (NonUnitalNonAssocSemiring.toMul.{u1} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₂ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u2} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₁ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u1, u2} (RingHom.{u1, u2} R₂ R₁ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1)) R₂ R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₂ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₁ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u1, u2} (RingHom.{u1, u2} R₂ R₁ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1)) R₂ R₁ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1) (RingHom.instRingHomClassRingHom.{u1, u2} R₂ R₁ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1))))) σ' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R₁ R₂ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2)) R₁ (fun (_x : R₁) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : R₁) => R₂) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R₁ R₂ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2)) R₁ R₂ (NonUnitalNonAssocSemiring.toMul.{u2} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₁ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₂ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R₁ R₂ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2)) R₁ R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₁ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₂ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R₁ R₂ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2)) R₁ R₂ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2) (RingHom.instRingHomClassRingHom.{u2, u1} R₁ R₂ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2))))) σ x)) x
Case conversion may be inaccurate. Consider using '#align ring_hom_inv_pair.comp_apply_eq RingHomInvPair.comp_apply_eqₓ'. -/
@[simp]
theorem comp_apply_eq {x : R₁} : σ' (σ x) = x :=
  by
  rw [← RingHom.comp_apply, comp_eq]
  simp
#align ring_hom_inv_pair.comp_apply_eq RingHomInvPair.comp_apply_eq

/- warning: ring_hom_inv_pair.comp_apply_eq₂ -> RingHomInvPair.comp_apply_eq₂ is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} [_inst_1 : Semiring.{u1} R₁] [_inst_2 : Semiring.{u2} R₂] {σ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)} {σ' : RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)} [_inst_4 : RingHomInvPair.{u1, u2} R₁ R₂ _inst_1 _inst_2 σ σ'] {x : R₂}, Eq.{succ u2} R₂ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) (fun (_x : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) => R₁ -> R₂) (RingHom.hasCoeToFun.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) σ (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)) (fun (_x : RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)) => R₂ -> R₁) (RingHom.hasCoeToFun.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)) σ' x)) x
but is expected to have type
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} [_inst_1 : Semiring.{u1} R₁] [_inst_2 : Semiring.{u2} R₂] {σ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)} {σ' : RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)} [_inst_4 : RingHomInvPair.{u1, u2} R₁ R₂ _inst_1 _inst_2 σ σ'] {x : R₂}, Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : R₁) => R₂) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)) R₂ (fun (a : R₂) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : R₂) => R₁) a) (MulHomClass.toFunLike.{max u1 u2, u2, u1} (RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)) R₂ R₁ (NonUnitalNonAssocSemiring.toMul.{u2} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u1} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u2, u1} (RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)) R₂ R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u2, u1} (RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)) R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (RingHom.instRingHomClassRingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1))))) σ' x)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) R₁ (fun (_x : R₁) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : R₁) => R₂) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) R₁ R₂ (NonUnitalNonAssocSemiring.toMul.{u1} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u2} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) R₁ R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (RingHom.instRingHomClassRingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2))))) σ (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)) R₂ (fun (_x : R₂) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : R₂) => R₁) _x) (MulHomClass.toFunLike.{max u1 u2, u2, u1} (RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)) R₂ R₁ (NonUnitalNonAssocSemiring.toMul.{u2} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u1} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u2, u1} (RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)) R₂ R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u2, u1} (RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)) R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (RingHom.instRingHomClassRingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1))))) σ' x)) x
Case conversion may be inaccurate. Consider using '#align ring_hom_inv_pair.comp_apply_eq₂ RingHomInvPair.comp_apply_eq₂ₓ'. -/
@[simp]
theorem comp_apply_eq₂ {x : R₂} : σ (σ' x) = x :=
  by
  rw [← RingHom.comp_apply, comp_eq₂]
  simp
#align ring_hom_inv_pair.comp_apply_eq₂ RingHomInvPair.comp_apply_eq₂

#print RingHomInvPair.ids /-
instance ids : RingHomInvPair (RingHom.id R₁) (RingHom.id R₁) :=
  ⟨rfl, rfl⟩
#align ring_hom_inv_pair.ids RingHomInvPair.ids
-/

#print RingHomInvPair.triples /-
instance triples {σ₂₁ : R₂ →+* R₁} [RingHomInvPair σ₁₂ σ₂₁] :
    RingHomCompTriple σ₁₂ σ₂₁ (RingHom.id R₁) :=
  ⟨by simp only [comp_eq]⟩
#align ring_hom_inv_pair.triples RingHomInvPair.triples
-/

#print RingHomInvPair.triples₂ /-
instance triples₂ {σ₂₁ : R₂ →+* R₁} [RingHomInvPair σ₁₂ σ₂₁] :
    RingHomCompTriple σ₂₁ σ₁₂ (RingHom.id R₂) :=
  ⟨by simp only [comp_eq₂]⟩
#align ring_hom_inv_pair.triples₂ RingHomInvPair.triples₂
-/

/- warning: ring_hom_inv_pair.of_ring_equiv -> RingHomInvPair.of_ringEquiv is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} [_inst_1 : Semiring.{u1} R₁] [_inst_2 : Semiring.{u2} R₂] (e : RingEquiv.{u1, u2} R₁ R₂ (Distrib.toHasMul.{u1} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)))) (Distrib.toHasAdd.{u1} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)))) (Distrib.toHasMul.{u2} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)))) (Distrib.toHasAdd.{u2} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2))))), RingHomInvPair.{u1, u2} R₁ R₂ _inst_1 _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u1, u2} R₁ R₂ (Distrib.toHasMul.{u1} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)))) (Distrib.toHasAdd.{u1} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)))) (Distrib.toHasMul.{u2} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)))) (Distrib.toHasAdd.{u2} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2))))) (RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R₁ R₂ (Distrib.toHasMul.{u1} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)))) (Distrib.toHasAdd.{u1} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)))) (Distrib.toHasMul.{u2} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)))) (Distrib.toHasAdd.{u2} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2))))) (RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R₁ R₂ (Distrib.toHasMul.{u1} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)))) (Distrib.toHasAdd.{u1} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)))) (Distrib.toHasMul.{u2} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)))) (Distrib.toHasAdd.{u2} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2))))) (RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) (RingHom.hasCoeT.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R₁ R₂ (Distrib.toHasMul.{u1} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)))) (Distrib.toHasAdd.{u1} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)))) (Distrib.toHasMul.{u2} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)))) (Distrib.toHasAdd.{u2} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2))))) R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (RingEquivClass.toRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R₁ R₂ (Distrib.toHasMul.{u1} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)))) (Distrib.toHasAdd.{u1} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)))) (Distrib.toHasMul.{u2} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)))) (Distrib.toHasAdd.{u2} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2))))) R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (RingEquiv.ringEquivClass.{u1, u2} R₁ R₂ (Distrib.toHasMul.{u1} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)))) (Distrib.toHasAdd.{u1} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)))) (Distrib.toHasMul.{u2} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)))) (Distrib.toHasAdd.{u2} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2))))))))) e) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u2) (succ u1), max (succ u2) (succ u1)} a b] => self.0) (RingEquiv.{u2, u1} R₂ R₁ (Distrib.toHasMul.{u2} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)))) (Distrib.toHasAdd.{u2} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)))) (Distrib.toHasMul.{u1} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)))) (Distrib.toHasAdd.{u1} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1))))) (outParam.{max (succ u2) (succ u1)} (RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1))) (HasLiftT.mk.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingEquiv.{u2, u1} R₂ R₁ (Distrib.toHasMul.{u2} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)))) (Distrib.toHasAdd.{u2} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)))) (Distrib.toHasMul.{u1} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)))) (Distrib.toHasAdd.{u1} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1))))) (outParam.{max (succ u2) (succ u1)} (RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1))) (CoeTCₓ.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingEquiv.{u2, u1} R₂ R₁ (Distrib.toHasMul.{u2} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)))) (Distrib.toHasAdd.{u2} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)))) (Distrib.toHasMul.{u1} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)))) (Distrib.toHasAdd.{u1} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1))))) (outParam.{max (succ u2) (succ u1)} (RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1))) (RingHom.hasCoeT.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R₂ R₁ (Distrib.toHasMul.{u2} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)))) (Distrib.toHasAdd.{u2} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)))) (Distrib.toHasMul.{u1} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)))) (Distrib.toHasAdd.{u1} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1))))) R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (RingEquivClass.toRingHomClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R₂ R₁ (Distrib.toHasMul.{u2} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)))) (Distrib.toHasAdd.{u2} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)))) (Distrib.toHasMul.{u1} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)))) (Distrib.toHasAdd.{u1} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1))))) R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (RingEquiv.ringEquivClass.{u2, u1} R₂ R₁ (Distrib.toHasMul.{u2} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)))) (Distrib.toHasAdd.{u2} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)))) (Distrib.toHasMul.{u1} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)))) (Distrib.toHasAdd.{u1} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1))))))))) (RingEquiv.symm.{u1, u2} R₁ R₂ (Distrib.toHasMul.{u1} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)))) (Distrib.toHasAdd.{u1} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₁ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)))) (Distrib.toHasMul.{u2} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)))) (Distrib.toHasAdd.{u2} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₂ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)))) e))
but is expected to have type
  forall {R₁ : Type.{u2}} {R₂ : Type.{u1}} [_inst_1 : Semiring.{u2} R₁] [_inst_2 : Semiring.{u1} R₂] (e : RingEquiv.{u2, u1} R₁ R₂ (NonUnitalNonAssocSemiring.toMul.{u2} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₁ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₂ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2))) (Distrib.toAdd.{u2} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₁ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1)))) (Distrib.toAdd.{u1} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₂ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2))))), RingHomInvPair.{u2, u1} R₁ R₂ _inst_1 _inst_2 (RingHomClass.toRingHom.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R₁ R₂ (NonUnitalNonAssocSemiring.toMul.{u2} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₁ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₂ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2))) (Distrib.toAdd.{u2} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₁ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1)))) (Distrib.toAdd.{u1} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₂ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2))))) R₁ R₂ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2) (RingEquivClass.toRingHomClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R₁ R₂ (NonUnitalNonAssocSemiring.toMul.{u2} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₁ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₂ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2))) (Distrib.toAdd.{u2} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₁ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1)))) (Distrib.toAdd.{u1} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₂ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2))))) R₁ R₂ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2) (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R₁ R₂ (NonUnitalNonAssocSemiring.toMul.{u2} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₁ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₂ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2))) (Distrib.toAdd.{u2} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₁ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1)))) (Distrib.toAdd.{u1} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₂ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2)))))) e) (RingHomClass.toRingHom.{max u2 u1, u1, u2} (RingEquiv.{u1, u2} R₂ R₁ (NonUnitalNonAssocSemiring.toMul.{u1} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₂ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u2} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₁ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1))) (Distrib.toAdd.{u1} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₂ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2)))) (Distrib.toAdd.{u2} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₁ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1))))) R₂ R₁ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1) (RingEquivClass.toRingHomClass.{max u2 u1, u1, u2} (RingEquiv.{u1, u2} R₂ R₁ (NonUnitalNonAssocSemiring.toMul.{u1} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₂ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u2} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₁ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1))) (Distrib.toAdd.{u1} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₂ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2)))) (Distrib.toAdd.{u2} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₁ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1))))) R₂ R₁ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1) (RingEquiv.instRingEquivClassRingEquiv.{u1, u2} R₂ R₁ (NonUnitalNonAssocSemiring.toMul.{u1} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₂ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u2} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₁ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1))) (Distrib.toAdd.{u1} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₂ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2)))) (Distrib.toAdd.{u2} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₁ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1)))))) (RingEquiv.symm.{u2, u1} R₁ R₂ (NonUnitalNonAssocSemiring.toMul.{u2} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₁ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₂ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2))) (Distrib.toAdd.{u2} R₁ (NonUnitalNonAssocSemiring.toDistrib.{u2} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₁ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1)))) (Distrib.toAdd.{u1} R₂ (NonUnitalNonAssocSemiring.toDistrib.{u1} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₂ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2)))) e))
Case conversion may be inaccurate. Consider using '#align ring_hom_inv_pair.of_ring_equiv RingHomInvPair.of_ringEquivₓ'. -/
/-- Construct a `ring_hom_inv_pair` from both directions of a ring equiv.

This is not an instance, as for equivalences that are involutions, a better instance
would be `ring_hom_inv_pair e e`. Indeed, this declaration is not currently used in mathlib.

See note [reducible non-instances].
-/
@[reducible]
theorem of_ringEquiv (e : R₁ ≃+* R₂) : RingHomInvPair (↑e : R₁ →+* R₂) ↑e.symm :=
  ⟨e.symm_to_ring_hom_comp_to_ring_hom, e.symm.symm_to_ring_hom_comp_to_ring_hom⟩
#align ring_hom_inv_pair.of_ring_equiv RingHomInvPair.of_ringEquiv

/- warning: ring_hom_inv_pair.symm -> RingHomInvPair.symm is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} [_inst_1 : Semiring.{u1} R₁] [_inst_2 : Semiring.{u2} R₂] (σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) (σ₂₁ : RingHom.{u2, u1} R₂ R₁ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1)) [_inst_5 : RingHomInvPair.{u1, u2} R₁ R₂ _inst_1 _inst_2 σ₁₂ σ₂₁], RingHomInvPair.{u2, u1} R₂ R₁ _inst_2 _inst_1 σ₂₁ σ₁₂
but is expected to have type
  forall {R₁ : Type.{u2}} {R₂ : Type.{u1}} [_inst_1 : Semiring.{u2} R₁] [_inst_2 : Semiring.{u1} R₂] (σ₁₂ : RingHom.{u2, u1} R₁ R₂ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2)) (σ₂₁ : RingHom.{u1, u2} R₂ R₁ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1)) [_inst_5 : RingHomInvPair.{u2, u1} R₁ R₂ _inst_1 _inst_2 σ₁₂ σ₂₁], RingHomInvPair.{u1, u2} R₂ R₁ _inst_2 _inst_1 σ₂₁ σ₁₂
Case conversion may be inaccurate. Consider using '#align ring_hom_inv_pair.symm RingHomInvPair.symmₓ'. -/
/--
Swap the direction of a `ring_hom_inv_pair`. This is not an instance as it would loop, and better
instances are often available and may often be preferrable to using this one. Indeed, this
declaration is not currently used in mathlib.

See note [reducible non-instances].
-/
@[reducible]
theorem symm (σ₁₂ : R₁ →+* R₂) (σ₂₁ : R₂ →+* R₁) [RingHomInvPair σ₁₂ σ₂₁] :
    RingHomInvPair σ₂₁ σ₁₂ :=
  ⟨RingHomInvPair.comp_eq₂, RingHomInvPair.comp_eq⟩
#align ring_hom_inv_pair.symm RingHomInvPair.symm

end RingHomInvPair

namespace RingHomCompTriple

#print RingHomCompTriple.ids /-
instance ids : RingHomCompTriple (RingHom.id R₁) σ₁₂ σ₁₂ :=
  ⟨by
    ext
    simp⟩
#align ring_hom_comp_triple.ids RingHomCompTriple.ids
-/

#print RingHomCompTriple.right_ids /-
instance right_ids : RingHomCompTriple σ₁₂ (RingHom.id R₂) σ₁₂ :=
  ⟨by
    ext
    simp⟩
#align ring_hom_comp_triple.right_ids RingHomCompTriple.right_ids
-/

end RingHomCompTriple

#print RingHomSurjective /-
/-- Class expressing the fact that a `ring_hom` is surjective. This is needed in the context
of semilinear maps, where some lemmas require this. -/
class RingHomSurjective (σ : R₁ →+* R₂) : Prop where
  is_surjective : Function.Surjective σ
#align ring_hom_surjective RingHomSurjective
-/

/- warning: ring_hom.is_surjective -> RingHom.surjective is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} [_inst_1 : Semiring.{u1} R₁] [_inst_2 : Semiring.{u2} R₂] (σ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) [t : RingHomSurjective.{u1, u2} R₁ R₂ _inst_1 _inst_2 σ], Function.Surjective.{succ u1, succ u2} R₁ R₂ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) (fun (_x : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) => R₁ -> R₂) (RingHom.hasCoeToFun.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)) σ)
but is expected to have type
  forall {R₁ : Type.{u2}} {R₂ : Type.{u1}} [_inst_1 : Semiring.{u2} R₁] [_inst_2 : Semiring.{u1} R₂] (σ : RingHom.{u2, u1} R₁ R₂ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2)) [t : RingHomSurjective.{u2, u1} R₁ R₂ _inst_1 _inst_2 σ], Function.Surjective.{succ u2, succ u1} R₁ R₂ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R₁ R₂ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2)) R₁ (fun (_x : R₁) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : R₁) => R₂) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R₁ R₂ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2)) R₁ R₂ (NonUnitalNonAssocSemiring.toMul.{u2} R₁ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₁ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₂ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R₁ R₂ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2)) R₁ R₂ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R₁ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R₂ (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R₁ R₂ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2)) R₁ R₂ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2) (RingHom.instRingHomClassRingHom.{u2, u1} R₁ R₂ (Semiring.toNonAssocSemiring.{u2} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u1} R₂ _inst_2))))) σ)
Case conversion may be inaccurate. Consider using '#align ring_hom.is_surjective RingHom.surjectiveₓ'. -/
theorem RingHom.surjective (σ : R₁ →+* R₂) [t : RingHomSurjective σ] : Function.Surjective σ :=
  t.is_surjective
#align ring_hom.is_surjective RingHom.surjective

namespace RingHomSurjective

#print RingHomSurjective.invPair /-
-- The linter gives a false positive, since `σ₂` is an out_param
@[nolint dangerous_instance]
instance (priority := 100) invPair {σ₁ : R₁ →+* R₂} {σ₂ : R₂ →+* R₁} [RingHomInvPair σ₁ σ₂] :
    RingHomSurjective σ₁ :=
  ⟨fun x => ⟨σ₂ x, RingHomInvPair.comp_apply_eq₂⟩⟩
#align ring_hom_surjective.inv_pair RingHomSurjective.invPair
-/

#print RingHomSurjective.ids /-
instance ids : RingHomSurjective (RingHom.id R₁) :=
  ⟨is_surjective⟩
#align ring_hom_surjective.ids RingHomSurjective.ids
-/

/- warning: ring_hom_surjective.comp -> RingHomSurjective.comp is a dubious translation:
lean 3 declaration is
  forall {R₁ : Type.{u1}} {R₂ : Type.{u2}} {R₃ : Type.{u3}} [_inst_1 : Semiring.{u1} R₁] [_inst_2 : Semiring.{u2} R₂] [_inst_3 : Semiring.{u3} R₃] {σ₁₂ : RingHom.{u1, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)} {σ₂₃ : RingHom.{u2, u3} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_3)} {σ₁₃ : RingHom.{u1, u3} R₁ R₃ (Semiring.toNonAssocSemiring.{u1} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u3} R₃ _inst_3)} [_inst_4 : RingHomCompTriple.{u1, u2, u3} R₁ R₂ R₃ _inst_1 _inst_2 _inst_3 σ₁₂ σ₂₃ σ₁₃] [_inst_5 : RingHomSurjective.{u1, u2} R₁ R₂ _inst_1 _inst_2 σ₁₂] [_inst_6 : RingHomSurjective.{u2, u3} R₂ R₃ _inst_2 _inst_3 σ₂₃], RingHomSurjective.{u1, u3} R₁ R₃ _inst_1 _inst_3 σ₁₃
but is expected to have type
  forall {R₁ : Type.{u3}} {R₂ : Type.{u2}} {R₃ : Type.{u1}} [_inst_1 : Semiring.{u3} R₁] [_inst_2 : Semiring.{u2} R₂] [_inst_3 : Semiring.{u1} R₃] {σ₁₂ : RingHom.{u3, u2} R₁ R₂ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)} {σ₂₃ : RingHom.{u2, u1} R₂ R₃ (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2) (Semiring.toNonAssocSemiring.{u1} R₃ _inst_3)} {σ₁₃ : RingHom.{u3, u1} R₁ R₃ (Semiring.toNonAssocSemiring.{u3} R₁ _inst_1) (Semiring.toNonAssocSemiring.{u1} R₃ _inst_3)} [_inst_4 : RingHomCompTriple.{u3, u2, u1} R₁ R₂ R₃ _inst_1 _inst_2 _inst_3 σ₁₂ σ₂₃ σ₁₃] [_inst_5 : RingHomSurjective.{u3, u2} R₁ R₂ _inst_1 _inst_2 σ₁₂] [_inst_6 : RingHomSurjective.{u2, u1} R₂ R₃ _inst_2 _inst_3 σ₂₃], RingHomSurjective.{u3, u1} R₁ R₃ _inst_1 _inst_3 σ₁₃
Case conversion may be inaccurate. Consider using '#align ring_hom_surjective.comp RingHomSurjective.compₓ'. -/
/-- This cannot be an instance as there is no way to infer `σ₁₂` and `σ₂₃`. -/
theorem comp [RingHomCompTriple σ₁₂ σ₂₃ σ₁₃] [RingHomSurjective σ₁₂] [RingHomSurjective σ₂₃] :
    RingHomSurjective σ₁₃ :=
  {
    is_surjective := by
      have := σ₂₃.is_surjective.comp σ₁₂.is_surjective
      rwa [← RingHom.coe_comp, RingHomCompTriple.comp_eq] at this }
#align ring_hom_surjective.comp RingHomSurjective.comp

end RingHomSurjective

