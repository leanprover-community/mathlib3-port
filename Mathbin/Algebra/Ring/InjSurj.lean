/-
Copyright (c) 2014 Jeremy Avigad. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jeremy Avigad, Leonardo de Moura, Floris van Doorn, Yury Kudryashov, Neil Strickland
-/
import Mathbin.Algebra.Ring.Defs
import Mathbin.Algebra.Opposites
import Mathbin.Algebra.GroupWithZero.InjSurj

/-!
# Pulling back rings along injective maps, and pushing them forward along surjective maps.

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> https://github.com/leanprover-community/mathlib4/pull/734
> Any changes to this file require a corresponding PR to mathlib4.
-/


universe u v w x

variable {α : Type u} {β : Type v} {γ : Type w} {R : Type x}

open Function

/-!
### `distrib` class
-/


/- warning: function.injective.distrib -> Function.Injective.distrib is a dubious translation:
lean 3 declaration is
  forall {R : Type.{x}} {S : Type.{u_1}} [_inst_1 : Mul.{x} R] [_inst_2 : Add.{x} R] [_inst_3 : Distrib.{u_1} S] (f : R -> S), (Function.Injective.{succ x, succ u_1} R S f) -> (forall (x : R) (y : R), Eq.{succ u_1} S (f (HAdd.hAdd.{x, x, x} R R R (instHAdd.{x} R _inst_2) x y)) (HAdd.hAdd.{u_1, u_1, u_1} S S S (instHAdd.{u_1} S (Distrib.toHasAdd.{u_1} S _inst_3)) (f x) (f y))) -> (forall (x : R) (y : R), Eq.{succ u_1} S (f (HMul.hMul.{x, x, x} R R R (instHMul.{x} R _inst_1) x y)) (HMul.hMul.{u_1, u_1, u_1} S S S (instHMul.{u_1} S (Distrib.toHasMul.{u_1} S _inst_3)) (f x) (f y))) -> (Distrib.{x} R)
but is expected to have type
  forall {R : Type.{x}} {S : Type.{u_1}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.24 : Mul.{x} R] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.27 : Add.{x} R] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.30 : Distrib.{u_1} S] (f : R -> S), (Function.Injective.{succ x, succ u_1} R S f) -> (forall (x : R) (y : R), Eq.{succ u_1} S (f (HAdd.hAdd.{x, x, x} R R R (instHAdd.{x} R inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.27) x y)) (HAdd.hAdd.{u_1, u_1, u_1} S S S (instHAdd.{u_1} S (Distrib.toAdd.{u_1} S inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.30)) (f x) (f y))) -> (forall (x : R) (y : R), Eq.{succ u_1} S (f (HMul.hMul.{x, x, x} R R R (instHMul.{x} R inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.24) x y)) (HMul.hMul.{u_1, u_1, u_1} S S S (instHMul.{u_1} S (Distrib.toMul.{u_1} S inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.30)) (f x) (f y))) -> (Distrib.{x} R)
Case conversion may be inaccurate. Consider using '#align function.injective.distrib Function.Injective.distribₓ'. -/
/-- Pullback a `distrib` instance along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.distrib {S} [Mul R] [Add R] [Distrib S] (f : R → S)
    (hf : Injective f) (add : ∀ x y, f (x + y) = f x + f y) (mul : ∀ x y, f (x * y) = f x * f y) :
    Distrib R where 
  mul := (· * ·)
  add := (· + ·)
  left_distrib x y z := hf <| by simp only [*, left_distrib]
  right_distrib x y z := hf <| by simp only [*, right_distrib]
#align function.injective.distrib Function.Injective.distrib

/- warning: function.surjective.distrib -> Function.Surjective.distrib is a dubious translation:
lean 3 declaration is
  forall {R : Type.{x}} {S : Type.{u_1}} [_inst_1 : Distrib.{x} R] [_inst_2 : Add.{u_1} S] [_inst_3 : Mul.{u_1} S] (f : R -> S), (Function.Surjective.{succ x, succ u_1} R S f) -> (forall (x : R) (y : R), Eq.{succ u_1} S (f (HAdd.hAdd.{x, x, x} R R R (instHAdd.{x} R (Distrib.toHasAdd.{x} R _inst_1)) x y)) (HAdd.hAdd.{u_1, u_1, u_1} S S S (instHAdd.{u_1} S _inst_2) (f x) (f y))) -> (forall (x : R) (y : R), Eq.{succ u_1} S (f (HMul.hMul.{x, x, x} R R R (instHMul.{x} R (Distrib.toHasMul.{x} R _inst_1)) x y)) (HMul.hMul.{u_1, u_1, u_1} S S S (instHMul.{u_1} S _inst_3) (f x) (f y))) -> (Distrib.{u_1} S)
but is expected to have type
  forall {R : Type.{x}} {S : Type.{u_1}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.149 : Distrib.{x} R] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.152 : Add.{u_1} S] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.155 : Mul.{u_1} S] (f : R -> S), (Function.Surjective.{succ x, succ u_1} R S f) -> (forall (x : R) (y : R), Eq.{succ u_1} S (f (HAdd.hAdd.{x, x, x} R R R (instHAdd.{x} R (Distrib.toAdd.{x} R inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.149)) x y)) (HAdd.hAdd.{u_1, u_1, u_1} S S S (instHAdd.{u_1} S inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.152) (f x) (f y))) -> (forall (x : R) (y : R), Eq.{succ u_1} S (f (HMul.hMul.{x, x, x} R R R (instHMul.{x} R (Distrib.toMul.{x} R inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.149)) x y)) (HMul.hMul.{u_1, u_1, u_1} S S S (instHMul.{u_1} S inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.155) (f x) (f y))) -> (Distrib.{u_1} S)
Case conversion may be inaccurate. Consider using '#align function.surjective.distrib Function.Surjective.distribₓ'. -/
/-- Pushforward a `distrib` instance along a surjective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Surjective.distrib {S} [Distrib R] [Add S] [Mul S] (f : R → S)
    (hf : Surjective f) (add : ∀ x y, f (x + y) = f x + f y) (mul : ∀ x y, f (x * y) = f x * f y) :
    Distrib S where 
  mul := (· * ·)
  add := (· + ·)
  left_distrib := hf.forall₃.2 fun x y z => by simp only [← add, ← mul, left_distrib]
  right_distrib := hf.forall₃.2 fun x y z => by simp only [← add, ← mul, right_distrib]
#align function.surjective.distrib Function.Surjective.distrib

section InjectiveSurjectiveMaps

/-!
### Semirings
-/


variable [Zero β] [Add β] [Mul β] [HasSmul ℕ β]

/- warning: function.injective.non_unital_non_assoc_semiring -> Function.Injective.nonUnitalNonAssocSemiring is a dubious translation:
lean 3 declaration is
  forall {β : Type.{v}} [_inst_1 : Zero.{v} β] [_inst_2 : Add.{v} β] [_inst_3 : Mul.{v} β] [_inst_4 : HasSmul.{0, v} Nat β] {α : Type.{u}} [_inst_5 : NonUnitalNonAssocSemiring.{u} α] (f : β -> α), (Function.Injective.{succ v, succ u} β α f) -> (Eq.{succ u} α (f (OfNat.ofNat.{v} β 0 (OfNat.mk.{v} β 0 (Zero.zero.{v} β _inst_1)))) (OfNat.ofNat.{u} α 0 (OfNat.mk.{u} α 0 (Zero.zero.{u} α (MulZeroClass.toHasZero.{u} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u} α _inst_5)))))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β _inst_2) x y)) (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toHasAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α _inst_5))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HMul.hMul.{v, v, v} β β β (instHMul.{v} β _inst_3) x y)) (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (Distrib.toHasMul.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α _inst_5))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u} α (f (HasSmul.smul.{0, v} Nat β _inst_4 n x)) (HasSmul.smul.{0, u} Nat α (AddMonoid.hasSmulNat.{u} α (AddCommMonoid.toAddMonoid.{u} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u} α _inst_5))) n (f x))) -> (NonUnitalNonAssocSemiring.{v} β)
but is expected to have type
  forall {β : Type.{v}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.295 : Zero.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.298 : Add.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.301 : Mul.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.304 : SMul.{0, v} Nat β] {α : Type.{u}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.311 : NonUnitalNonAssocSemiring.{u} α] (f : β -> α), (Function.Injective.{succ v, succ u} β α f) -> (Eq.{succ u} α (f (OfNat.ofNat.{v} β 0 (Zero.toOfNat0.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.295))) (OfNat.ofNat.{u} α 0 (Zero.toOfNat0.{u} α (MulZeroClass.toZero.{u} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.311))))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.298) x y)) (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.311))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HMul.hMul.{v, v, v} β β β (instHMul.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.301) x y)) (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (NonUnitalNonAssocSemiring.toMul.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.311)) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u} α (f (HSMul.hSMul.{0, v, v} Nat β β (instHSMul.{0, v} Nat β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.304) n x)) (HSMul.hSMul.{0, u, u} Nat α α (instHSMul.{0, u} Nat α (AddMonoid.SMul.{u} α (AddCommMonoid.toAddMonoid.{u} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.311)))) n (f x))) -> (NonUnitalNonAssocSemiring.{v} β)
Case conversion may be inaccurate. Consider using '#align function.injective.non_unital_non_assoc_semiring Function.Injective.nonUnitalNonAssocSemiringₓ'. -/
/-- Pullback a `non_unital_non_assoc_semiring` instance along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.nonUnitalNonAssocSemiring {α : Type u}
    [NonUnitalNonAssocSemiring α] (f : β → α) (hf : Injective f) (zero : f 0 = 0)
    (add : ∀ x y, f (x + y) = f x + f y) (mul : ∀ x y, f (x * y) = f x * f y)
    (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) : NonUnitalNonAssocSemiring β :=
  { hf.MulZeroClass f zero mul, hf.AddCommMonoid f zero add nsmul, hf.Distrib f add mul with }
#align function.injective.non_unital_non_assoc_semiring Function.Injective.nonUnitalNonAssocSemiring

/- warning: function.injective.non_unital_semiring -> Function.Injective.nonUnitalSemiring is a dubious translation:
lean 3 declaration is
  forall {β : Type.{v}} [_inst_1 : Zero.{v} β] [_inst_2 : Add.{v} β] [_inst_3 : Mul.{v} β] [_inst_4 : HasSmul.{0, v} Nat β] {α : Type.{u}} [_inst_5 : NonUnitalSemiring.{u} α] (f : β -> α), (Function.Injective.{succ v, succ u} β α f) -> (Eq.{succ u} α (f (OfNat.ofNat.{v} β 0 (OfNat.mk.{v} β 0 (Zero.zero.{v} β _inst_1)))) (OfNat.ofNat.{u} α 0 (OfNat.mk.{u} α 0 (Zero.zero.{u} α (MulZeroClass.toHasZero.{u} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u} α _inst_5))))))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β _inst_2) x y)) (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toHasAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u} α _inst_5)))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HMul.hMul.{v, v, v} β β β (instHMul.{v} β _inst_3) x y)) (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (Distrib.toHasMul.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u} α _inst_5)))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u} α (f (HasSmul.smul.{0, v} Nat β _inst_4 n x)) (HasSmul.smul.{0, u} Nat α (AddMonoid.hasSmulNat.{u} α (AddCommMonoid.toAddMonoid.{u} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u} α _inst_5)))) n (f x))) -> (NonUnitalSemiring.{v} β)
but is expected to have type
  forall {β : Type.{v}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.438 : Zero.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.441 : Add.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.444 : Mul.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.447 : SMul.{0, v} Nat β] {α : Type.{u}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.454 : NonUnitalSemiring.{u} α] (f : β -> α), (Function.Injective.{succ v, succ u} β α f) -> (Eq.{succ u} α (f (OfNat.ofNat.{v} β 0 (Zero.toOfNat0.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.438))) (OfNat.ofNat.{u} α 0 (Zero.toOfNat0.{u} α (SemigroupWithZero.toZero.{u} α (NonUnitalSemiring.toSemigroupWithZero.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.454))))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.441) x y)) (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.454)))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HMul.hMul.{v, v, v} β β β (instHMul.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.444) x y)) (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (NonUnitalNonAssocSemiring.toMul.{u} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.454))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u} α (f (HSMul.hSMul.{0, v, v} Nat β β (instHSMul.{0, v} Nat β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.447) n x)) (HSMul.hSMul.{0, u, u} Nat α α (instHSMul.{0, u} Nat α (AddMonoid.SMul.{u} α (AddCommMonoid.toAddMonoid.{u} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.454))))) n (f x))) -> (NonUnitalSemiring.{v} β)
Case conversion may be inaccurate. Consider using '#align function.injective.non_unital_semiring Function.Injective.nonUnitalSemiringₓ'. -/
/-- Pullback a `non_unital_semiring` instance along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.nonUnitalSemiring {α : Type u} [NonUnitalSemiring α] (f : β → α)
    (hf : Injective f) (zero : f 0 = 0) (add : ∀ x y, f (x + y) = f x + f y)
    (mul : ∀ x y, f (x * y) = f x * f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) :
    NonUnitalSemiring β :=
  { hf.NonUnitalNonAssocSemiring f zero add mul nsmul, hf.SemigroupWithZero f zero mul with }
#align function.injective.non_unital_semiring Function.Injective.nonUnitalSemiring

/- warning: function.injective.non_assoc_semiring -> Function.Injective.nonAssocSemiring is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u}} [_inst_5 : NonAssocSemiring.{u} α] {β : Type.{v}} [_inst_6 : Zero.{v} β] [_inst_7 : One.{v} β] [_inst_8 : Mul.{v} β] [_inst_9 : Add.{v} β] [_inst_10 : HasSmul.{0, v} Nat β] [_inst_11 : NatCast.{v} β] (f : β -> α), (Function.Injective.{succ v, succ u} β α f) -> (Eq.{succ u} α (f (OfNat.ofNat.{v} β 0 (OfNat.mk.{v} β 0 (Zero.zero.{v} β _inst_6)))) (OfNat.ofNat.{u} α 0 (OfNat.mk.{u} α 0 (Zero.zero.{u} α (MulZeroClass.toHasZero.{u} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u} α _inst_5))))))) -> (Eq.{succ u} α (f (OfNat.ofNat.{v} β 1 (OfNat.mk.{v} β 1 (One.one.{v} β _inst_7)))) (OfNat.ofNat.{u} α 1 (OfNat.mk.{u} α 1 (One.one.{u} α (AddMonoidWithOne.toOne.{u} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u} α (NonAssocSemiring.toAddCommMonoidWithOne.{u} α _inst_5))))))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β _inst_9) x y)) (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toHasAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u} α _inst_5)))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HMul.hMul.{v, v, v} β β β (instHMul.{v} β _inst_8) x y)) (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (Distrib.toHasMul.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u} α _inst_5)))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u} α (f (HasSmul.smul.{0, v} Nat β _inst_10 n x)) (HasSmul.smul.{0, u} Nat α (AddMonoid.hasSmulNat.{u} α (AddMonoidWithOne.toAddMonoid.{u} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u} α (NonAssocSemiring.toAddCommMonoidWithOne.{u} α _inst_5)))) n (f x))) -> (forall (n : Nat), Eq.{succ u} α (f ((fun (a : Type) (b : Type.{v}) [self : HasLiftT.{1, succ v} a b] => self.0) Nat β (HasLiftT.mk.{1, succ v} Nat β (CoeTCₓ.coe.{1, succ v} Nat β (Nat.castCoe.{v} β _inst_11))) n)) ((fun (a : Type) (b : Type.{u}) [self : HasLiftT.{1, succ u} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u} Nat α (CoeTCₓ.coe.{1, succ u} Nat α (Nat.castCoe.{u} α (AddMonoidWithOne.toNatCast.{u} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u} α (NonAssocSemiring.toAddCommMonoidWithOne.{u} α _inst_5)))))) n)) -> (NonAssocSemiring.{v} β)
but is expected to have type
  forall {α : Type.{u}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.591 : NonAssocSemiring.{u} α] {β : Type.{v}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.595 : Zero.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.598 : One.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.601 : Mul.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.604 : Add.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.607 : SMul.{0, v} Nat β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.613 : NatCast.{v} β] (f : β -> α), (Function.Injective.{succ v, succ u} β α f) -> (Eq.{succ u} α (f (OfNat.ofNat.{v} β 0 (Zero.toOfNat0.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.595))) (OfNat.ofNat.{u} α 0 (Zero.toOfNat0.{u} α (MulZeroOneClass.toZero.{u} α (NonAssocSemiring.toMulZeroOneClass.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.591))))) -> (Eq.{succ u} α (f (OfNat.ofNat.{v} β 1 (One.toOfNat1.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.598))) (OfNat.ofNat.{u} α 1 (One.toOfNat1.{u} α (NonAssocSemiring.toOne.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.591)))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.604) x y)) (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.591)))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HMul.hMul.{v, v, v} β β β (instHMul.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.601) x y)) (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (NonUnitalNonAssocSemiring.toMul.{u} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.591))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u} α (f (HSMul.hSMul.{0, v, v} Nat β β (instHSMul.{0, v} Nat β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.607) n x)) (HSMul.hSMul.{0, u, u} Nat α α (instHSMul.{0, u} Nat α (AddMonoid.SMul.{u} α (AddMonoidWithOne.toAddMonoid.{u} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u} α (NonAssocSemiring.toAddCommMonoidWithOne.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.591))))) n (f x))) -> (forall (n : Nat), Eq.{succ u} α (f (Nat.cast.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.613 n)) (Nat.cast.{u} α (NonAssocSemiring.toNatCast.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.591) n)) -> (NonAssocSemiring.{v} β)
Case conversion may be inaccurate. Consider using '#align function.injective.non_assoc_semiring Function.Injective.nonAssocSemiringₓ'. -/
/-- Pullback a `non_assoc_semiring` instance along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.nonAssocSemiring {α : Type u} [NonAssocSemiring α] {β : Type v}
    [Zero β] [One β] [Mul β] [Add β] [HasSmul ℕ β] [NatCast β] (f : β → α) (hf : Injective f)
    (zero : f 0 = 0) (one : f 1 = 1) (add : ∀ x y, f (x + y) = f x + f y)
    (mul : ∀ x y, f (x * y) = f x * f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x)
    (nat_cast : ∀ n : ℕ, f n = n) : NonAssocSemiring β :=
  { hf.AddMonoidWithOne f zero one add nsmul nat_cast,
    hf.NonUnitalNonAssocSemiring f zero add mul nsmul, hf.MulOneClass f one mul with }
#align function.injective.non_assoc_semiring Function.Injective.nonAssocSemiring

/- warning: function.injective.semiring -> Function.Injective.semiring is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u}} [_inst_5 : Semiring.{u} α] {β : Type.{v}} [_inst_6 : Zero.{v} β] [_inst_7 : One.{v} β] [_inst_8 : Add.{v} β] [_inst_9 : Mul.{v} β] [_inst_10 : Pow.{v, 0} β Nat] [_inst_11 : HasSmul.{0, v} Nat β] [_inst_12 : NatCast.{v} β] (f : β -> α), (Function.Injective.{succ v, succ u} β α f) -> (Eq.{succ u} α (f (OfNat.ofNat.{v} β 0 (OfNat.mk.{v} β 0 (Zero.zero.{v} β _inst_6)))) (OfNat.ofNat.{u} α 0 (OfNat.mk.{u} α 0 (Zero.zero.{u} α (MulZeroClass.toHasZero.{u} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u} α (Semiring.toNonAssocSemiring.{u} α _inst_5)))))))) -> (Eq.{succ u} α (f (OfNat.ofNat.{v} β 1 (OfNat.mk.{v} β 1 (One.one.{v} β _inst_7)))) (OfNat.ofNat.{u} α 1 (OfNat.mk.{u} α 1 (One.one.{u} α (AddMonoidWithOne.toOne.{u} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u} α (NonAssocSemiring.toAddCommMonoidWithOne.{u} α (Semiring.toNonAssocSemiring.{u} α _inst_5)))))))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β _inst_8) x y)) (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toHasAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u} α (Semiring.toNonAssocSemiring.{u} α _inst_5))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HMul.hMul.{v, v, v} β β β (instHMul.{v} β _inst_9) x y)) (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (Distrib.toHasMul.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u} α (Semiring.toNonAssocSemiring.{u} α _inst_5))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u} α (f (HasSmul.smul.{0, v} Nat β _inst_11 n x)) (HasSmul.smul.{0, u} Nat α (AddMonoid.hasSmulNat.{u} α (AddMonoidWithOne.toAddMonoid.{u} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u} α (NonAssocSemiring.toAddCommMonoidWithOne.{u} α (Semiring.toNonAssocSemiring.{u} α _inst_5))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u} α (f (HPow.hPow.{v, 0, v} β Nat β (instHPow.{v, 0} β Nat _inst_10) x n)) (HPow.hPow.{u, 0, u} α Nat α (instHPow.{u, 0} α Nat (Monoid.hasPow.{u} α (MonoidWithZero.toMonoid.{u} α (Semiring.toMonoidWithZero.{u} α _inst_5)))) (f x) n)) -> (forall (n : Nat), Eq.{succ u} α (f ((fun (a : Type) (b : Type.{v}) [self : HasLiftT.{1, succ v} a b] => self.0) Nat β (HasLiftT.mk.{1, succ v} Nat β (CoeTCₓ.coe.{1, succ v} Nat β (Nat.castCoe.{v} β _inst_12))) n)) ((fun (a : Type) (b : Type.{u}) [self : HasLiftT.{1, succ u} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u} Nat α (CoeTCₓ.coe.{1, succ u} Nat α (Nat.castCoe.{u} α (AddMonoidWithOne.toNatCast.{u} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u} α (NonAssocSemiring.toAddCommMonoidWithOne.{u} α (Semiring.toNonAssocSemiring.{u} α _inst_5))))))) n)) -> (Semiring.{v} β)
but is expected to have type
  forall {α : Type.{u}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.784 : Semiring.{u} α] {β : Type.{v}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.788 : Zero.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.791 : One.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.794 : Add.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.797 : Mul.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.800 : Pow.{v, 0} β Nat] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.806 : SMul.{0, v} Nat β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.812 : NatCast.{v} β] (f : β -> α), (Function.Injective.{succ v, succ u} β α f) -> (Eq.{succ u} α (f (OfNat.ofNat.{v} β 0 (Zero.toOfNat0.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.788))) (OfNat.ofNat.{u} α 0 (Zero.toOfNat0.{u} α (MonoidWithZero.toZero.{u} α (Semiring.toMonoidWithZero.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.784))))) -> (Eq.{succ u} α (f (OfNat.ofNat.{v} β 1 (One.toOfNat1.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.791))) (OfNat.ofNat.{u} α 1 (One.toOfNat1.{u} α (Semiring.toOne.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.784)))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.794) x y)) (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u} α (Semiring.toNonAssocSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.784))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HMul.hMul.{v, v, v} β β β (instHMul.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.797) x y)) (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (NonUnitalNonAssocSemiring.toMul.{u} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u} α (Semiring.toNonAssocSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.784)))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u} α (f (HSMul.hSMul.{0, v, v} Nat β β (instHSMul.{0, v} Nat β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.806) n x)) (HSMul.hSMul.{0, u, u} Nat α α (instHSMul.{0, u} Nat α (AddMonoid.SMul.{u} α (AddMonoidWithOne.toAddMonoid.{u} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u} α (NonAssocSemiring.toAddCommMonoidWithOne.{u} α (Semiring.toNonAssocSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.784)))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u} α (f (HPow.hPow.{v, 0, v} β Nat β (instHPow.{v, 0} β Nat inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.800) x n)) (HPow.hPow.{u, 0, u} α Nat α (instHPow.{u, 0} α Nat (Monoid.Pow.{u} α (MonoidWithZero.toMonoid.{u} α (Semiring.toMonoidWithZero.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.784)))) (f x) n)) -> (forall (n : Nat), Eq.{succ u} α (f (Nat.cast.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.812 n)) (Nat.cast.{u} α (Semiring.toNatCast.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.784) n)) -> (Semiring.{v} β)
Case conversion may be inaccurate. Consider using '#align function.injective.semiring Function.Injective.semiringₓ'. -/
/-- Pullback a `semiring` instance along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.semiring {α : Type u} [Semiring α] {β : Type v} [Zero β] [One β]
    [Add β] [Mul β] [Pow β ℕ] [HasSmul ℕ β] [NatCast β] (f : β → α) (hf : Injective f)
    (zero : f 0 = 0) (one : f 1 = 1) (add : ∀ x y, f (x + y) = f x + f y)
    (mul : ∀ x y, f (x * y) = f x * f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x)
    (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n) (nat_cast : ∀ n : ℕ, f n = n) : Semiring β :=
  { hf.NonAssocSemiring f zero one add mul nsmul nat_cast, hf.MonoidWithZero f zero one mul npow,
    hf.Distrib f add mul with }
#align function.injective.semiring Function.Injective.semiring

/- warning: function.surjective.non_unital_non_assoc_semiring -> Function.Surjective.nonUnitalNonAssocSemiring is a dubious translation:
lean 3 declaration is
  forall {β : Type.{v}} [_inst_1 : Zero.{v} β] [_inst_2 : Add.{v} β] [_inst_3 : Mul.{v} β] [_inst_4 : HasSmul.{0, v} Nat β] {α : Type.{u}} [_inst_5 : NonUnitalNonAssocSemiring.{u} α] (f : α -> β), (Function.Surjective.{succ u, succ v} α β f) -> (Eq.{succ v} β (f (OfNat.ofNat.{u} α 0 (OfNat.mk.{u} α 0 (Zero.zero.{u} α (MulZeroClass.toHasZero.{u} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u} α _inst_5)))))) (OfNat.ofNat.{v} β 0 (OfNat.mk.{v} β 0 (Zero.zero.{v} β _inst_1)))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toHasAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α _inst_5))) x y)) (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β _inst_2) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (Distrib.toHasMul.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α _inst_5))) x y)) (HMul.hMul.{v, v, v} β β β (instHMul.{v} β _inst_3) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ v} β (f (HasSmul.smul.{0, u} Nat α (AddMonoid.hasSmulNat.{u} α (AddCommMonoid.toAddMonoid.{u} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u} α _inst_5))) n x)) (HasSmul.smul.{0, v} Nat β _inst_4 n (f x))) -> (NonUnitalNonAssocSemiring.{v} β)
but is expected to have type
  forall {β : Type.{v}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.988 : Zero.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.991 : Add.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.994 : Mul.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.997 : SMul.{0, v} Nat β] {α : Type.{u}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1004 : NonUnitalNonAssocSemiring.{u} α] (f : α -> β), (Function.Surjective.{succ u, succ v} α β f) -> (Eq.{succ v} β (f (OfNat.ofNat.{u} α 0 (Zero.toOfNat0.{u} α (MulZeroClass.toZero.{u} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1004))))) (OfNat.ofNat.{v} β 0 (Zero.toOfNat0.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.988))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1004))) x y)) (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.991) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (NonUnitalNonAssocSemiring.toMul.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1004)) x y)) (HMul.hMul.{v, v, v} β β β (instHMul.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.994) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ v} β (f (HSMul.hSMul.{0, u, u} Nat α α (instHSMul.{0, u} Nat α (AddMonoid.SMul.{u} α (AddCommMonoid.toAddMonoid.{u} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1004)))) n x)) (HSMul.hSMul.{0, v, v} Nat β β (instHSMul.{0, v} Nat β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.997) n (f x))) -> (NonUnitalNonAssocSemiring.{v} β)
Case conversion may be inaccurate. Consider using '#align function.surjective.non_unital_non_assoc_semiring Function.Surjective.nonUnitalNonAssocSemiringₓ'. -/
/-- Pushforward a `non_unital_non_assoc_semiring` instance along a surjective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Surjective.nonUnitalNonAssocSemiring {α : Type u}
    [NonUnitalNonAssocSemiring α] (f : α → β) (hf : Surjective f) (zero : f 0 = 0)
    (add : ∀ x y, f (x + y) = f x + f y) (mul : ∀ x y, f (x * y) = f x * f y)
    (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) : NonUnitalNonAssocSemiring β :=
  { hf.MulZeroClass f zero mul, hf.AddCommMonoid f zero add nsmul, hf.Distrib f add mul with }
#align
  function.surjective.non_unital_non_assoc_semiring Function.Surjective.nonUnitalNonAssocSemiring

/- warning: function.surjective.non_unital_semiring -> Function.Surjective.nonUnitalSemiring is a dubious translation:
lean 3 declaration is
  forall {β : Type.{v}} [_inst_1 : Zero.{v} β] [_inst_2 : Add.{v} β] [_inst_3 : Mul.{v} β] [_inst_4 : HasSmul.{0, v} Nat β] {α : Type.{u}} [_inst_5 : NonUnitalSemiring.{u} α] (f : α -> β), (Function.Surjective.{succ u, succ v} α β f) -> (Eq.{succ v} β (f (OfNat.ofNat.{u} α 0 (OfNat.mk.{u} α 0 (Zero.zero.{u} α (MulZeroClass.toHasZero.{u} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u} α _inst_5))))))) (OfNat.ofNat.{v} β 0 (OfNat.mk.{v} β 0 (Zero.zero.{v} β _inst_1)))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toHasAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u} α _inst_5)))) x y)) (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β _inst_2) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (Distrib.toHasMul.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u} α _inst_5)))) x y)) (HMul.hMul.{v, v, v} β β β (instHMul.{v} β _inst_3) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ v} β (f (HasSmul.smul.{0, u} Nat α (AddMonoid.hasSmulNat.{u} α (AddCommMonoid.toAddMonoid.{u} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u} α _inst_5)))) n x)) (HasSmul.smul.{0, v} Nat β _inst_4 n (f x))) -> (NonUnitalSemiring.{v} β)
but is expected to have type
  forall {β : Type.{v}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1131 : Zero.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1134 : Add.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1137 : Mul.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1140 : SMul.{0, v} Nat β] {α : Type.{u}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1147 : NonUnitalSemiring.{u} α] (f : α -> β), (Function.Surjective.{succ u, succ v} α β f) -> (Eq.{succ v} β (f (OfNat.ofNat.{u} α 0 (Zero.toOfNat0.{u} α (SemigroupWithZero.toZero.{u} α (NonUnitalSemiring.toSemigroupWithZero.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1147))))) (OfNat.ofNat.{v} β 0 (Zero.toOfNat0.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1131))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1147)))) x y)) (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1134) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (NonUnitalNonAssocSemiring.toMul.{u} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1147))) x y)) (HMul.hMul.{v, v, v} β β β (instHMul.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1137) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ v} β (f (HSMul.hSMul.{0, u, u} Nat α α (instHSMul.{0, u} Nat α (AddMonoid.SMul.{u} α (AddCommMonoid.toAddMonoid.{u} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1147))))) n x)) (HSMul.hSMul.{0, v, v} Nat β β (instHSMul.{0, v} Nat β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1140) n (f x))) -> (NonUnitalSemiring.{v} β)
Case conversion may be inaccurate. Consider using '#align function.surjective.non_unital_semiring Function.Surjective.nonUnitalSemiringₓ'. -/
/-- Pushforward a `non_unital_semiring` instance along a surjective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Surjective.nonUnitalSemiring {α : Type u} [NonUnitalSemiring α] (f : α → β)
    (hf : Surjective f) (zero : f 0 = 0) (add : ∀ x y, f (x + y) = f x + f y)
    (mul : ∀ x y, f (x * y) = f x * f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) :
    NonUnitalSemiring β :=
  { hf.NonUnitalNonAssocSemiring f zero add mul nsmul, hf.SemigroupWithZero f zero mul with }
#align function.surjective.non_unital_semiring Function.Surjective.nonUnitalSemiring

/- warning: function.surjective.non_assoc_semiring -> Function.Surjective.nonAssocSemiring is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u}} [_inst_5 : NonAssocSemiring.{u} α] {β : Type.{v}} [_inst_6 : Zero.{v} β] [_inst_7 : One.{v} β] [_inst_8 : Add.{v} β] [_inst_9 : Mul.{v} β] [_inst_10 : HasSmul.{0, v} Nat β] [_inst_11 : NatCast.{v} β] (f : α -> β), (Function.Surjective.{succ u, succ v} α β f) -> (Eq.{succ v} β (f (OfNat.ofNat.{u} α 0 (OfNat.mk.{u} α 0 (Zero.zero.{u} α (MulZeroClass.toHasZero.{u} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u} α _inst_5))))))) (OfNat.ofNat.{v} β 0 (OfNat.mk.{v} β 0 (Zero.zero.{v} β _inst_6)))) -> (Eq.{succ v} β (f (OfNat.ofNat.{u} α 1 (OfNat.mk.{u} α 1 (One.one.{u} α (AddMonoidWithOne.toOne.{u} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u} α (NonAssocSemiring.toAddCommMonoidWithOne.{u} α _inst_5))))))) (OfNat.ofNat.{v} β 1 (OfNat.mk.{v} β 1 (One.one.{v} β _inst_7)))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toHasAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u} α _inst_5)))) x y)) (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β _inst_8) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (Distrib.toHasMul.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u} α _inst_5)))) x y)) (HMul.hMul.{v, v, v} β β β (instHMul.{v} β _inst_9) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ v} β (f (HasSmul.smul.{0, u} Nat α (AddMonoid.hasSmulNat.{u} α (AddMonoidWithOne.toAddMonoid.{u} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u} α (NonAssocSemiring.toAddCommMonoidWithOne.{u} α _inst_5)))) n x)) (HasSmul.smul.{0, v} Nat β _inst_10 n (f x))) -> (forall (n : Nat), Eq.{succ v} β (f ((fun (a : Type) (b : Type.{u}) [self : HasLiftT.{1, succ u} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u} Nat α (CoeTCₓ.coe.{1, succ u} Nat α (Nat.castCoe.{u} α (AddMonoidWithOne.toNatCast.{u} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u} α (NonAssocSemiring.toAddCommMonoidWithOne.{u} α _inst_5)))))) n)) ((fun (a : Type) (b : Type.{v}) [self : HasLiftT.{1, succ v} a b] => self.0) Nat β (HasLiftT.mk.{1, succ v} Nat β (CoeTCₓ.coe.{1, succ v} Nat β (Nat.castCoe.{v} β _inst_11))) n)) -> (NonAssocSemiring.{v} β)
but is expected to have type
  forall {α : Type.{u}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1284 : NonAssocSemiring.{u} α] {β : Type.{v}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1288 : Zero.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1291 : One.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1294 : Add.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1297 : Mul.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1300 : SMul.{0, v} Nat β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1306 : NatCast.{v} β] (f : α -> β), (Function.Surjective.{succ u, succ v} α β f) -> (Eq.{succ v} β (f (OfNat.ofNat.{u} α 0 (Zero.toOfNat0.{u} α (MulZeroOneClass.toZero.{u} α (NonAssocSemiring.toMulZeroOneClass.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1284))))) (OfNat.ofNat.{v} β 0 (Zero.toOfNat0.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1288))) -> (Eq.{succ v} β (f (OfNat.ofNat.{u} α 1 (One.toOfNat1.{u} α (NonAssocSemiring.toOne.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1284)))) (OfNat.ofNat.{v} β 1 (One.toOfNat1.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1291))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1284)))) x y)) (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1294) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (NonUnitalNonAssocSemiring.toMul.{u} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1284))) x y)) (HMul.hMul.{v, v, v} β β β (instHMul.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1297) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ v} β (f (HSMul.hSMul.{0, u, u} Nat α α (instHSMul.{0, u} Nat α (AddMonoid.SMul.{u} α (AddMonoidWithOne.toAddMonoid.{u} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u} α (NonAssocSemiring.toAddCommMonoidWithOne.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1284))))) n x)) (HSMul.hSMul.{0, v, v} Nat β β (instHSMul.{0, v} Nat β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1300) n (f x))) -> (forall (n : Nat), Eq.{succ v} β (f (Nat.cast.{u} α (NonAssocSemiring.toNatCast.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1284) n)) (Nat.cast.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1306 n)) -> (NonAssocSemiring.{v} β)
Case conversion may be inaccurate. Consider using '#align function.surjective.non_assoc_semiring Function.Surjective.nonAssocSemiringₓ'. -/
/-- Pushforward a `non_assoc_semiring` instance along a surjective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Surjective.nonAssocSemiring {α : Type u} [NonAssocSemiring α] {β : Type v}
    [Zero β] [One β] [Add β] [Mul β] [HasSmul ℕ β] [NatCast β] (f : α → β) (hf : Surjective f)
    (zero : f 0 = 0) (one : f 1 = 1) (add : ∀ x y, f (x + y) = f x + f y)
    (mul : ∀ x y, f (x * y) = f x * f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x)
    (nat_cast : ∀ n : ℕ, f n = n) : NonAssocSemiring β :=
  { hf.AddMonoidWithOne f zero one add nsmul nat_cast,
    hf.NonUnitalNonAssocSemiring f zero add mul nsmul, hf.MulOneClass f one mul with }
#align function.surjective.non_assoc_semiring Function.Surjective.nonAssocSemiring

/- warning: function.surjective.semiring -> Function.Surjective.semiring is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u}} [_inst_5 : Semiring.{u} α] {β : Type.{v}} [_inst_6 : Zero.{v} β] [_inst_7 : One.{v} β] [_inst_8 : Add.{v} β] [_inst_9 : Mul.{v} β] [_inst_10 : Pow.{v, 0} β Nat] [_inst_11 : HasSmul.{0, v} Nat β] [_inst_12 : NatCast.{v} β] (f : α -> β), (Function.Surjective.{succ u, succ v} α β f) -> (Eq.{succ v} β (f (OfNat.ofNat.{u} α 0 (OfNat.mk.{u} α 0 (Zero.zero.{u} α (MulZeroClass.toHasZero.{u} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u} α (Semiring.toNonAssocSemiring.{u} α _inst_5)))))))) (OfNat.ofNat.{v} β 0 (OfNat.mk.{v} β 0 (Zero.zero.{v} β _inst_6)))) -> (Eq.{succ v} β (f (OfNat.ofNat.{u} α 1 (OfNat.mk.{u} α 1 (One.one.{u} α (AddMonoidWithOne.toOne.{u} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u} α (NonAssocSemiring.toAddCommMonoidWithOne.{u} α (Semiring.toNonAssocSemiring.{u} α _inst_5)))))))) (OfNat.ofNat.{v} β 1 (OfNat.mk.{v} β 1 (One.one.{v} β _inst_7)))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toHasAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u} α (Semiring.toNonAssocSemiring.{u} α _inst_5))))) x y)) (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β _inst_8) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (Distrib.toHasMul.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u} α (Semiring.toNonAssocSemiring.{u} α _inst_5))))) x y)) (HMul.hMul.{v, v, v} β β β (instHMul.{v} β _inst_9) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ v} β (f (HasSmul.smul.{0, u} Nat α (AddMonoid.hasSmulNat.{u} α (AddMonoidWithOne.toAddMonoid.{u} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u} α (NonAssocSemiring.toAddCommMonoidWithOne.{u} α (Semiring.toNonAssocSemiring.{u} α _inst_5))))) n x)) (HasSmul.smul.{0, v} Nat β _inst_11 n (f x))) -> (forall (x : α) (n : Nat), Eq.{succ v} β (f (HPow.hPow.{u, 0, u} α Nat α (instHPow.{u, 0} α Nat (Monoid.hasPow.{u} α (MonoidWithZero.toMonoid.{u} α (Semiring.toMonoidWithZero.{u} α _inst_5)))) x n)) (HPow.hPow.{v, 0, v} β Nat β (instHPow.{v, 0} β Nat _inst_10) (f x) n)) -> (forall (n : Nat), Eq.{succ v} β (f ((fun (a : Type) (b : Type.{u}) [self : HasLiftT.{1, succ u} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u} Nat α (CoeTCₓ.coe.{1, succ u} Nat α (Nat.castCoe.{u} α (AddMonoidWithOne.toNatCast.{u} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u} α (NonAssocSemiring.toAddCommMonoidWithOne.{u} α (Semiring.toNonAssocSemiring.{u} α _inst_5))))))) n)) ((fun (a : Type) (b : Type.{v}) [self : HasLiftT.{1, succ v} a b] => self.0) Nat β (HasLiftT.mk.{1, succ v} Nat β (CoeTCₓ.coe.{1, succ v} Nat β (Nat.castCoe.{v} β _inst_12))) n)) -> (Semiring.{v} β)
but is expected to have type
  forall {α : Type.{u}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1477 : Semiring.{u} α] {β : Type.{v}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1481 : Zero.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1484 : One.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1487 : Add.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1490 : Mul.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1493 : Pow.{v, 0} β Nat] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1499 : SMul.{0, v} Nat β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1505 : NatCast.{v} β] (f : α -> β), (Function.Surjective.{succ u, succ v} α β f) -> (Eq.{succ v} β (f (OfNat.ofNat.{u} α 0 (Zero.toOfNat0.{u} α (MonoidWithZero.toZero.{u} α (Semiring.toMonoidWithZero.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1477))))) (OfNat.ofNat.{v} β 0 (Zero.toOfNat0.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1481))) -> (Eq.{succ v} β (f (OfNat.ofNat.{u} α 1 (One.toOfNat1.{u} α (Semiring.toOne.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1477)))) (OfNat.ofNat.{v} β 1 (One.toOfNat1.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1484))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u} α (Semiring.toNonAssocSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1477))))) x y)) (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1487) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (NonUnitalNonAssocSemiring.toMul.{u} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u} α (Semiring.toNonAssocSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1477)))) x y)) (HMul.hMul.{v, v, v} β β β (instHMul.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1490) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ v} β (f (HSMul.hSMul.{0, u, u} Nat α α (instHSMul.{0, u} Nat α (AddMonoid.SMul.{u} α (AddMonoidWithOne.toAddMonoid.{u} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u} α (NonAssocSemiring.toAddCommMonoidWithOne.{u} α (Semiring.toNonAssocSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1477)))))) n x)) (HSMul.hSMul.{0, v, v} Nat β β (instHSMul.{0, v} Nat β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1499) n (f x))) -> (forall (x : α) (n : Nat), Eq.{succ v} β (f (HPow.hPow.{u, 0, u} α Nat α (instHPow.{u, 0} α Nat (Monoid.Pow.{u} α (MonoidWithZero.toMonoid.{u} α (Semiring.toMonoidWithZero.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1477)))) x n)) (HPow.hPow.{v, 0, v} β Nat β (instHPow.{v, 0} β Nat inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1493) (f x) n)) -> (forall (n : Nat), Eq.{succ v} β (f (Nat.cast.{u} α (Semiring.toNatCast.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1477) n)) (Nat.cast.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1505 n)) -> (Semiring.{v} β)
Case conversion may be inaccurate. Consider using '#align function.surjective.semiring Function.Surjective.semiringₓ'. -/
/-- Pushforward a `semiring` instance along a surjective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Surjective.semiring {α : Type u} [Semiring α] {β : Type v} [Zero β] [One β]
    [Add β] [Mul β] [Pow β ℕ] [HasSmul ℕ β] [NatCast β] (f : α → β) (hf : Surjective f)
    (zero : f 0 = 0) (one : f 1 = 1) (add : ∀ x y, f (x + y) = f x + f y)
    (mul : ∀ x y, f (x * y) = f x * f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x)
    (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n) (nat_cast : ∀ n : ℕ, f n = n) : Semiring β :=
  { hf.NonAssocSemiring f zero one add mul nsmul nat_cast, hf.MonoidWithZero f zero one mul npow,
    hf.AddCommMonoid f zero add nsmul, hf.Distrib f add mul with }
#align function.surjective.semiring Function.Surjective.semiring

end InjectiveSurjectiveMaps

section NonUnitalCommSemiring

variable [NonUnitalCommSemiring α] [NonUnitalCommSemiring β] {a b c : α}

/- warning: function.injective.non_unital_comm_semiring -> Function.Injective.nonUnitalCommSemiring is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u}} {γ : Type.{w}} [_inst_1 : NonUnitalCommSemiring.{u} α] [_inst_3 : Zero.{w} γ] [_inst_4 : Add.{w} γ] [_inst_5 : Mul.{w} γ] [_inst_6 : HasSmul.{0, w} Nat γ] (f : γ -> α), (Function.Injective.{succ w, succ u} γ α f) -> (Eq.{succ u} α (f (OfNat.ofNat.{w} γ 0 (OfNat.mk.{w} γ 0 (Zero.zero.{w} γ _inst_3)))) (OfNat.ofNat.{u} α 0 (OfNat.mk.{u} α 0 (Zero.zero.{u} α (MulZeroClass.toHasZero.{u} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u} α _inst_1)))))))) -> (forall (x : γ) (y : γ), Eq.{succ u} α (f (HAdd.hAdd.{w, w, w} γ γ γ (instHAdd.{w} γ _inst_4) x y)) (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toHasAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u} α _inst_1))))) (f x) (f y))) -> (forall (x : γ) (y : γ), Eq.{succ u} α (f (HMul.hMul.{w, w, w} γ γ γ (instHMul.{w} γ _inst_5) x y)) (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (Distrib.toHasMul.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u} α _inst_1))))) (f x) (f y))) -> (forall (x : γ) (n : Nat), Eq.{succ u} α (f (HasSmul.smul.{0, w} Nat γ _inst_6 n x)) (HasSmul.smul.{0, u} Nat α (AddMonoid.hasSmulNat.{u} α (AddCommMonoid.toAddMonoid.{u} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u} α _inst_1))))) n (f x))) -> (NonUnitalCommSemiring.{w} γ)
but is expected to have type
  forall {α : Type.{u}} {γ : Type.{w}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1710 : NonUnitalCommSemiring.{u} α] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1719 : Zero.{w} γ] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1722 : Add.{w} γ] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1725 : Mul.{w} γ] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1728 : SMul.{0, w} Nat γ] (f : γ -> α), (Function.Injective.{succ w, succ u} γ α f) -> (Eq.{succ u} α (f (OfNat.ofNat.{w} γ 0 (Zero.toOfNat0.{w} γ inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1719))) (OfNat.ofNat.{u} α 0 (Zero.toOfNat0.{u} α (SemigroupWithZero.toZero.{u} α (NonUnitalSemiring.toSemigroupWithZero.{u} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1710)))))) -> (forall (x : γ) (y : γ), Eq.{succ u} α (f (HAdd.hAdd.{w, w, w} γ γ γ (instHAdd.{w} γ inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1722) x y)) (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1710))))) (f x) (f y))) -> (forall (x : γ) (y : γ), Eq.{succ u} α (f (HMul.hMul.{w, w, w} γ γ γ (instHMul.{w} γ inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1725) x y)) (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (NonUnitalNonAssocSemiring.toMul.{u} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1710)))) (f x) (f y))) -> (forall (x : γ) (n : Nat), Eq.{succ u} α (f (HSMul.hSMul.{0, w, w} Nat γ γ (instHSMul.{0, w} Nat γ inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1728) n x)) (HSMul.hSMul.{0, u, u} Nat α α (instHSMul.{0, u} Nat α (AddMonoid.SMul.{u} α (AddCommMonoid.toAddMonoid.{u} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1710)))))) n (f x))) -> (NonUnitalCommSemiring.{w} γ)
Case conversion may be inaccurate. Consider using '#align function.injective.non_unital_comm_semiring Function.Injective.nonUnitalCommSemiringₓ'. -/
/-- Pullback a `non_unital_semiring` instance along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.nonUnitalCommSemiring [Zero γ] [Add γ] [Mul γ] [HasSmul ℕ γ]
    (f : γ → α) (hf : Injective f) (zero : f 0 = 0) (add : ∀ x y, f (x + y) = f x + f y)
    (mul : ∀ x y, f (x * y) = f x * f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) :
    NonUnitalCommSemiring γ :=
  { hf.NonUnitalSemiring f zero add mul nsmul, hf.CommSemigroup f mul with }
#align function.injective.non_unital_comm_semiring Function.Injective.nonUnitalCommSemiring

/- warning: function.surjective.non_unital_comm_semiring -> Function.Surjective.nonUnitalCommSemiring is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u}} {γ : Type.{w}} [_inst_1 : NonUnitalCommSemiring.{u} α] [_inst_3 : Zero.{w} γ] [_inst_4 : Add.{w} γ] [_inst_5 : Mul.{w} γ] [_inst_6 : HasSmul.{0, w} Nat γ] (f : α -> γ), (Function.Surjective.{succ u, succ w} α γ f) -> (Eq.{succ w} γ (f (OfNat.ofNat.{u} α 0 (OfNat.mk.{u} α 0 (Zero.zero.{u} α (MulZeroClass.toHasZero.{u} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u} α _inst_1)))))))) (OfNat.ofNat.{w} γ 0 (OfNat.mk.{w} γ 0 (Zero.zero.{w} γ _inst_3)))) -> (forall (x : α) (y : α), Eq.{succ w} γ (f (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toHasAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u} α _inst_1))))) x y)) (HAdd.hAdd.{w, w, w} γ γ γ (instHAdd.{w} γ _inst_4) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ w} γ (f (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (Distrib.toHasMul.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u} α _inst_1))))) x y)) (HMul.hMul.{w, w, w} γ γ γ (instHMul.{w} γ _inst_5) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ w} γ (f (HasSmul.smul.{0, u} Nat α (AddMonoid.hasSmulNat.{u} α (AddCommMonoid.toAddMonoid.{u} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u} α _inst_1))))) n x)) (HasSmul.smul.{0, w} Nat γ _inst_6 n (f x))) -> (NonUnitalCommSemiring.{w} γ)
but is expected to have type
  forall {α : Type.{u}} {γ : Type.{w}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1847 : NonUnitalCommSemiring.{u} α] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1856 : Zero.{w} γ] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1859 : Add.{w} γ] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1862 : Mul.{w} γ] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1865 : SMul.{0, w} Nat γ] (f : α -> γ), (Function.Surjective.{succ u, succ w} α γ f) -> (Eq.{succ w} γ (f (OfNat.ofNat.{u} α 0 (Zero.toOfNat0.{u} α (SemigroupWithZero.toZero.{u} α (NonUnitalSemiring.toSemigroupWithZero.{u} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1847)))))) (OfNat.ofNat.{w} γ 0 (Zero.toOfNat0.{w} γ inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1856))) -> (forall (x : α) (y : α), Eq.{succ w} γ (f (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1847))))) x y)) (HAdd.hAdd.{w, w, w} γ γ γ (instHAdd.{w} γ inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1859) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ w} γ (f (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (NonUnitalNonAssocSemiring.toMul.{u} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1847)))) x y)) (HMul.hMul.{w, w, w} γ γ γ (instHMul.{w} γ inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1862) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ w} γ (f (HSMul.hSMul.{0, u, u} Nat α α (instHSMul.{0, u} Nat α (AddMonoid.SMul.{u} α (AddCommMonoid.toAddMonoid.{u} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1847)))))) n x)) (HSMul.hSMul.{0, w, w} Nat γ γ (instHSMul.{0, w} Nat γ inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.1865) n (f x))) -> (NonUnitalCommSemiring.{w} γ)
Case conversion may be inaccurate. Consider using '#align function.surjective.non_unital_comm_semiring Function.Surjective.nonUnitalCommSemiringₓ'. -/
/-- Pushforward a `non_unital_semiring` instance along a surjective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Surjective.nonUnitalCommSemiring [Zero γ] [Add γ] [Mul γ] [HasSmul ℕ γ]
    (f : α → γ) (hf : Surjective f) (zero : f 0 = 0) (add : ∀ x y, f (x + y) = f x + f y)
    (mul : ∀ x y, f (x * y) = f x * f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) :
    NonUnitalCommSemiring γ :=
  { hf.NonUnitalSemiring f zero add mul nsmul, hf.CommSemigroup f mul with }
#align function.surjective.non_unital_comm_semiring Function.Surjective.nonUnitalCommSemiring

end NonUnitalCommSemiring

section CommSemiring

variable [CommSemiring α] [CommSemiring β] {a b c : α}

/- warning: function.injective.comm_semiring -> Function.Injective.commSemiring is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u}} {γ : Type.{w}} [_inst_1 : CommSemiring.{u} α] [_inst_3 : Zero.{w} γ] [_inst_4 : One.{w} γ] [_inst_5 : Add.{w} γ] [_inst_6 : Mul.{w} γ] [_inst_7 : HasSmul.{0, w} Nat γ] [_inst_8 : NatCast.{w} γ] [_inst_9 : Pow.{w, 0} γ Nat] (f : γ -> α), (Function.Injective.{succ w, succ u} γ α f) -> (Eq.{succ u} α (f (OfNat.ofNat.{w} γ 0 (OfNat.mk.{w} γ 0 (Zero.zero.{w} γ _inst_3)))) (OfNat.ofNat.{u} α 0 (OfNat.mk.{u} α 0 (Zero.zero.{u} α (MulZeroClass.toHasZero.{u} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u} α (Semiring.toNonAssocSemiring.{u} α (CommSemiring.toSemiring.{u} α _inst_1))))))))) -> (Eq.{succ u} α (f (OfNat.ofNat.{w} γ 1 (OfNat.mk.{w} γ 1 (One.one.{w} γ _inst_4)))) (OfNat.ofNat.{u} α 1 (OfNat.mk.{u} α 1 (One.one.{u} α (AddMonoidWithOne.toOne.{u} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u} α (NonAssocSemiring.toAddCommMonoidWithOne.{u} α (Semiring.toNonAssocSemiring.{u} α (CommSemiring.toSemiring.{u} α _inst_1))))))))) -> (forall (x : γ) (y : γ), Eq.{succ u} α (f (HAdd.hAdd.{w, w, w} γ γ γ (instHAdd.{w} γ _inst_5) x y)) (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toHasAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u} α (Semiring.toNonAssocSemiring.{u} α (CommSemiring.toSemiring.{u} α _inst_1)))))) (f x) (f y))) -> (forall (x : γ) (y : γ), Eq.{succ u} α (f (HMul.hMul.{w, w, w} γ γ γ (instHMul.{w} γ _inst_6) x y)) (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (Distrib.toHasMul.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u} α (Semiring.toNonAssocSemiring.{u} α (CommSemiring.toSemiring.{u} α _inst_1)))))) (f x) (f y))) -> (forall (x : γ) (n : Nat), Eq.{succ u} α (f (HasSmul.smul.{0, w} Nat γ _inst_7 n x)) (HasSmul.smul.{0, u} Nat α (AddMonoid.hasSmulNat.{u} α (AddMonoidWithOne.toAddMonoid.{u} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u} α (NonAssocSemiring.toAddCommMonoidWithOne.{u} α (Semiring.toNonAssocSemiring.{u} α (CommSemiring.toSemiring.{u} α _inst_1)))))) n (f x))) -> (forall (x : γ) (n : Nat), Eq.{succ u} α (f (HPow.hPow.{w, 0, w} γ Nat γ (instHPow.{w, 0} γ Nat _inst_9) x n)) (HPow.hPow.{u, 0, u} α Nat α (instHPow.{u, 0} α Nat (Monoid.hasPow.{u} α (MonoidWithZero.toMonoid.{u} α (Semiring.toMonoidWithZero.{u} α (CommSemiring.toSemiring.{u} α _inst_1))))) (f x) n)) -> (forall (n : Nat), Eq.{succ u} α (f ((fun (a : Type) (b : Type.{w}) [self : HasLiftT.{1, succ w} a b] => self.0) Nat γ (HasLiftT.mk.{1, succ w} Nat γ (CoeTCₓ.coe.{1, succ w} Nat γ (Nat.castCoe.{w} γ _inst_8))) n)) ((fun (a : Type) (b : Type.{u}) [self : HasLiftT.{1, succ u} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u} Nat α (CoeTCₓ.coe.{1, succ u} Nat α (Nat.castCoe.{u} α (AddMonoidWithOne.toNatCast.{u} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u} α (NonAssocSemiring.toAddCommMonoidWithOne.{u} α (Semiring.toNonAssocSemiring.{u} α (CommSemiring.toSemiring.{u} α _inst_1)))))))) n)) -> (CommSemiring.{w} γ)
but is expected to have type
  forall {α : Type.{u}} {γ : Type.{w}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2005 : CommSemiring.{u} α] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2014 : Zero.{w} γ] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2017 : One.{w} γ] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2020 : Add.{w} γ] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2023 : Mul.{w} γ] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2026 : SMul.{0, w} Nat γ] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2032 : NatCast.{w} γ] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2035 : Pow.{w, 0} γ Nat] (f : γ -> α), (Function.Injective.{succ w, succ u} γ α f) -> (Eq.{succ u} α (f (OfNat.ofNat.{w} γ 0 (Zero.toOfNat0.{w} γ inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2014))) (OfNat.ofNat.{u} α 0 (Zero.toOfNat0.{u} α (CommMonoidWithZero.toZero.{u} α (CommSemiring.toCommMonoidWithZero.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2005))))) -> (Eq.{succ u} α (f (OfNat.ofNat.{w} γ 1 (One.toOfNat1.{w} γ inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2017))) (OfNat.ofNat.{u} α 1 (One.toOfNat1.{u} α (Semiring.toOne.{u} α (CommSemiring.toSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2005))))) -> (forall (x : γ) (y : γ), Eq.{succ u} α (f (HAdd.hAdd.{w, w, w} γ γ γ (instHAdd.{w} γ inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2020) x y)) (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u} α (Semiring.toNonAssocSemiring.{u} α (CommSemiring.toSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2005)))))) (f x) (f y))) -> (forall (x : γ) (y : γ), Eq.{succ u} α (f (HMul.hMul.{w, w, w} γ γ γ (instHMul.{w} γ inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2023) x y)) (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (NonUnitalNonAssocSemiring.toMul.{u} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u} α (Semiring.toNonAssocSemiring.{u} α (CommSemiring.toSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2005))))) (f x) (f y))) -> (forall (x : γ) (n : Nat), Eq.{succ u} α (f (HSMul.hSMul.{0, w, w} Nat γ γ (instHSMul.{0, w} Nat γ inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2026) n x)) (HSMul.hSMul.{0, u, u} Nat α α (instHSMul.{0, u} Nat α (AddMonoid.SMul.{u} α (AddMonoidWithOne.toAddMonoid.{u} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u} α (NonAssocSemiring.toAddCommMonoidWithOne.{u} α (Semiring.toNonAssocSemiring.{u} α (CommSemiring.toSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2005))))))) n (f x))) -> (forall (x : γ) (n : Nat), Eq.{succ u} α (f (HPow.hPow.{w, 0, w} γ Nat γ (instHPow.{w, 0} γ Nat inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2035) x n)) (HPow.hPow.{u, 0, u} α Nat α (instHPow.{u, 0} α Nat (Monoid.Pow.{u} α (MonoidWithZero.toMonoid.{u} α (Semiring.toMonoidWithZero.{u} α (CommSemiring.toSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2005))))) (f x) n)) -> (forall (n : Nat), Eq.{succ u} α (f (Nat.cast.{w} γ inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2032 n)) (Nat.cast.{u} α (Semiring.toNatCast.{u} α (CommSemiring.toSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2005)) n)) -> (CommSemiring.{w} γ)
Case conversion may be inaccurate. Consider using '#align function.injective.comm_semiring Function.Injective.commSemiringₓ'. -/
/-- Pullback a `semiring` instance along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.commSemiring [Zero γ] [One γ] [Add γ] [Mul γ] [HasSmul ℕ γ]
    [NatCast γ] [Pow γ ℕ] (f : γ → α) (hf : Injective f) (zero : f 0 = 0) (one : f 1 = 1)
    (add : ∀ x y, f (x + y) = f x + f y) (mul : ∀ x y, f (x * y) = f x * f y)
    (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n)
    (nat_cast : ∀ n : ℕ, f n = n) : CommSemiring γ :=
  { hf.Semiring f zero one add mul nsmul npow nat_cast, hf.CommSemigroup f mul with }
#align function.injective.comm_semiring Function.Injective.commSemiring

/- warning: function.surjective.comm_semiring -> Function.Surjective.commSemiring is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u}} {γ : Type.{w}} [_inst_1 : CommSemiring.{u} α] [_inst_3 : Zero.{w} γ] [_inst_4 : One.{w} γ] [_inst_5 : Add.{w} γ] [_inst_6 : Mul.{w} γ] [_inst_7 : HasSmul.{0, w} Nat γ] [_inst_8 : NatCast.{w} γ] [_inst_9 : Pow.{w, 0} γ Nat] (f : α -> γ), (Function.Surjective.{succ u, succ w} α γ f) -> (Eq.{succ w} γ (f (OfNat.ofNat.{u} α 0 (OfNat.mk.{u} α 0 (Zero.zero.{u} α (MulZeroClass.toHasZero.{u} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u} α (Semiring.toNonAssocSemiring.{u} α (CommSemiring.toSemiring.{u} α _inst_1))))))))) (OfNat.ofNat.{w} γ 0 (OfNat.mk.{w} γ 0 (Zero.zero.{w} γ _inst_3)))) -> (Eq.{succ w} γ (f (OfNat.ofNat.{u} α 1 (OfNat.mk.{u} α 1 (One.one.{u} α (AddMonoidWithOne.toOne.{u} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u} α (NonAssocSemiring.toAddCommMonoidWithOne.{u} α (Semiring.toNonAssocSemiring.{u} α (CommSemiring.toSemiring.{u} α _inst_1))))))))) (OfNat.ofNat.{w} γ 1 (OfNat.mk.{w} γ 1 (One.one.{w} γ _inst_4)))) -> (forall (x : α) (y : α), Eq.{succ w} γ (f (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toHasAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u} α (Semiring.toNonAssocSemiring.{u} α (CommSemiring.toSemiring.{u} α _inst_1)))))) x y)) (HAdd.hAdd.{w, w, w} γ γ γ (instHAdd.{w} γ _inst_5) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ w} γ (f (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (Distrib.toHasMul.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u} α (Semiring.toNonAssocSemiring.{u} α (CommSemiring.toSemiring.{u} α _inst_1)))))) x y)) (HMul.hMul.{w, w, w} γ γ γ (instHMul.{w} γ _inst_6) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ w} γ (f (HasSmul.smul.{0, u} Nat α (AddMonoid.hasSmulNat.{u} α (AddMonoidWithOne.toAddMonoid.{u} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u} α (NonAssocSemiring.toAddCommMonoidWithOne.{u} α (Semiring.toNonAssocSemiring.{u} α (CommSemiring.toSemiring.{u} α _inst_1)))))) n x)) (HasSmul.smul.{0, w} Nat γ _inst_7 n (f x))) -> (forall (x : α) (n : Nat), Eq.{succ w} γ (f (HPow.hPow.{u, 0, u} α Nat α (instHPow.{u, 0} α Nat (Monoid.hasPow.{u} α (MonoidWithZero.toMonoid.{u} α (Semiring.toMonoidWithZero.{u} α (CommSemiring.toSemiring.{u} α _inst_1))))) x n)) (HPow.hPow.{w, 0, w} γ Nat γ (instHPow.{w, 0} γ Nat _inst_9) (f x) n)) -> (forall (n : Nat), Eq.{succ w} γ (f ((fun (a : Type) (b : Type.{u}) [self : HasLiftT.{1, succ u} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u} Nat α (CoeTCₓ.coe.{1, succ u} Nat α (Nat.castCoe.{u} α (AddMonoidWithOne.toNatCast.{u} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u} α (NonAssocSemiring.toAddCommMonoidWithOne.{u} α (Semiring.toNonAssocSemiring.{u} α (CommSemiring.toSemiring.{u} α _inst_1)))))))) n)) ((fun (a : Type) (b : Type.{w}) [self : HasLiftT.{1, succ w} a b] => self.0) Nat γ (HasLiftT.mk.{1, succ w} Nat γ (CoeTCₓ.coe.{1, succ w} Nat γ (Nat.castCoe.{w} γ _inst_8))) n)) -> (CommSemiring.{w} γ)
but is expected to have type
  forall {α : Type.{u}} {γ : Type.{w}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2205 : CommSemiring.{u} α] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2214 : Zero.{w} γ] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2217 : One.{w} γ] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2220 : Add.{w} γ] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2223 : Mul.{w} γ] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2226 : SMul.{0, w} Nat γ] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2232 : NatCast.{w} γ] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2235 : Pow.{w, 0} γ Nat] (f : α -> γ), (Function.Surjective.{succ u, succ w} α γ f) -> (Eq.{succ w} γ (f (OfNat.ofNat.{u} α 0 (Zero.toOfNat0.{u} α (CommMonoidWithZero.toZero.{u} α (CommSemiring.toCommMonoidWithZero.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2205))))) (OfNat.ofNat.{w} γ 0 (Zero.toOfNat0.{w} γ inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2214))) -> (Eq.{succ w} γ (f (OfNat.ofNat.{u} α 1 (One.toOfNat1.{u} α (Semiring.toOne.{u} α (CommSemiring.toSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2205))))) (OfNat.ofNat.{w} γ 1 (One.toOfNat1.{w} γ inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2217))) -> (forall (x : α) (y : α), Eq.{succ w} γ (f (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u} α (Semiring.toNonAssocSemiring.{u} α (CommSemiring.toSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2205)))))) x y)) (HAdd.hAdd.{w, w, w} γ γ γ (instHAdd.{w} γ inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2220) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ w} γ (f (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (NonUnitalNonAssocSemiring.toMul.{u} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u} α (Semiring.toNonAssocSemiring.{u} α (CommSemiring.toSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2205))))) x y)) (HMul.hMul.{w, w, w} γ γ γ (instHMul.{w} γ inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2223) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ w} γ (f (HSMul.hSMul.{0, u, u} Nat α α (instHSMul.{0, u} Nat α (AddMonoid.SMul.{u} α (AddMonoidWithOne.toAddMonoid.{u} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u} α (NonAssocSemiring.toAddCommMonoidWithOne.{u} α (Semiring.toNonAssocSemiring.{u} α (CommSemiring.toSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2205))))))) n x)) (HSMul.hSMul.{0, w, w} Nat γ γ (instHSMul.{0, w} Nat γ inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2226) n (f x))) -> (forall (x : α) (n : Nat), Eq.{succ w} γ (f (HPow.hPow.{u, 0, u} α Nat α (instHPow.{u, 0} α Nat (Monoid.Pow.{u} α (MonoidWithZero.toMonoid.{u} α (Semiring.toMonoidWithZero.{u} α (CommSemiring.toSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2205))))) x n)) (HPow.hPow.{w, 0, w} γ Nat γ (instHPow.{w, 0} γ Nat inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2235) (f x) n)) -> (forall (n : Nat), Eq.{succ w} γ (f (Nat.cast.{u} α (Semiring.toNatCast.{u} α (CommSemiring.toSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2205)) n)) (Nat.cast.{w} γ inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2232 n)) -> (CommSemiring.{w} γ)
Case conversion may be inaccurate. Consider using '#align function.surjective.comm_semiring Function.Surjective.commSemiringₓ'. -/
/-- Pushforward a `semiring` instance along a surjective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Surjective.commSemiring [Zero γ] [One γ] [Add γ] [Mul γ] [HasSmul ℕ γ]
    [NatCast γ] [Pow γ ℕ] (f : α → γ) (hf : Surjective f) (zero : f 0 = 0) (one : f 1 = 1)
    (add : ∀ x y, f (x + y) = f x + f y) (mul : ∀ x y, f (x * y) = f x * f y)
    (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n)
    (nat_cast : ∀ n : ℕ, f n = n) : CommSemiring γ :=
  { hf.Semiring f zero one add mul nsmul npow nat_cast, hf.CommSemigroup f mul with }
#align function.surjective.comm_semiring Function.Surjective.commSemiring

end CommSemiring

section HasDistribNeg

section Mul

variable [Mul α] [HasDistribNeg α]

/- warning: function.injective.has_distrib_neg -> Function.Injective.hasDistribNeg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u}} {β : Type.{v}} [_inst_1 : Mul.{u} α] [_inst_2 : HasDistribNeg.{u} α _inst_1] [_inst_3 : Neg.{v} β] [_inst_4 : Mul.{v} β] (f : β -> α), (Function.Injective.{succ v, succ u} β α f) -> (forall (a : β), Eq.{succ u} α (f (Neg.neg.{v} β _inst_3 a)) (Neg.neg.{u} α (HasInvolutiveNeg.toHasNeg.{u} α (HasDistribNeg.toHasInvolutiveNeg.{u} α _inst_1 _inst_2)) (f a))) -> (forall (a : β) (b : β), Eq.{succ u} α (f (HMul.hMul.{v, v, v} β β β (instHMul.{v} β _inst_4) a b)) (HMul.hMul.{u, u, u} α α α (instHMul.{u} α _inst_1) (f a) (f b))) -> (HasDistribNeg.{v} β _inst_4)
but is expected to have type
  forall {α : Type.{u}} {β : Type.{v}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2421 : Mul.{u} α] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2424 : HasDistribNeg.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2421] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2427 : Neg.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2430 : Mul.{v} β] (f : β -> α), (Function.Injective.{succ v, succ u} β α f) -> (forall (a : β), Eq.{succ u} α (f (Neg.neg.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2427 a)) (Neg.neg.{u} α (HasInvolutiveNeg.toNeg.{u} α (HasDistribNeg.toHasInvolutiveNeg.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2421 inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2424)) (f a))) -> (forall (a : β) (b : β), Eq.{succ u} α (f (HMul.hMul.{v, v, v} β β β (instHMul.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2430) a b)) (HMul.hMul.{u, u, u} α α α (instHMul.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2421) (f a) (f b))) -> (HasDistribNeg.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2430)
Case conversion may be inaccurate. Consider using '#align function.injective.has_distrib_neg Function.Injective.hasDistribNegₓ'. -/
-- See note [reducible non-instances]
/-- A type endowed with `-` and `*` has distributive negation, if it admits an injective map that
preserves `-` and `*` to a type which has distributive negation. -/
@[reducible]
protected def Function.Injective.hasDistribNeg [Neg β] [Mul β] (f : β → α) (hf : Injective f)
    (neg : ∀ a, f (-a) = -f a) (mul : ∀ a b, f (a * b) = f a * f b) : HasDistribNeg β :=
  { hf.HasInvolutiveNeg _ neg, ‹Mul β› with
    neg_mul := fun x y => hf <| by erw [neg, mul, neg, neg_mul, mul],
    mul_neg := fun x y => hf <| by erw [neg, mul, neg, mul_neg, mul] }
#align function.injective.has_distrib_neg Function.Injective.hasDistribNeg

/- warning: function.surjective.has_distrib_neg -> Function.Surjective.hasDistribNeg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u}} {β : Type.{v}} [_inst_1 : Mul.{u} α] [_inst_2 : HasDistribNeg.{u} α _inst_1] [_inst_3 : Neg.{v} β] [_inst_4 : Mul.{v} β] (f : α -> β), (Function.Surjective.{succ u, succ v} α β f) -> (forall (a : α), Eq.{succ v} β (f (Neg.neg.{u} α (HasInvolutiveNeg.toHasNeg.{u} α (HasDistribNeg.toHasInvolutiveNeg.{u} α _inst_1 _inst_2)) a)) (Neg.neg.{v} β _inst_3 (f a))) -> (forall (a : α) (b : α), Eq.{succ v} β (f (HMul.hMul.{u, u, u} α α α (instHMul.{u} α _inst_1) a b)) (HMul.hMul.{v, v, v} β β β (instHMul.{v} β _inst_4) (f a) (f b))) -> (HasDistribNeg.{v} β _inst_4)
but is expected to have type
  forall {α : Type.{u}} {β : Type.{v}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2613 : Mul.{u} α] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2616 : HasDistribNeg.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2613] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2619 : Neg.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2622 : Mul.{v} β] (f : α -> β), (Function.Surjective.{succ u, succ v} α β f) -> (forall (a : α), Eq.{succ v} β (f (Neg.neg.{u} α (HasInvolutiveNeg.toNeg.{u} α (HasDistribNeg.toHasInvolutiveNeg.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2613 inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2616)) a)) (Neg.neg.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2619 (f a))) -> (forall (a : α) (b : α), Eq.{succ v} β (f (HMul.hMul.{u, u, u} α α α (instHMul.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2613) a b)) (HMul.hMul.{v, v, v} β β β (instHMul.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2622) (f a) (f b))) -> (HasDistribNeg.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2622)
Case conversion may be inaccurate. Consider using '#align function.surjective.has_distrib_neg Function.Surjective.hasDistribNegₓ'. -/
-- See note [reducible non-instances]
/-- A type endowed with `-` and `*` has distributive negation, if it admits a surjective map that
preserves `-` and `*` from a type which has distributive negation. -/
@[reducible]
protected def Function.Surjective.hasDistribNeg [Neg β] [Mul β] (f : α → β) (hf : Surjective f)
    (neg : ∀ a, f (-a) = -f a) (mul : ∀ a b, f (a * b) = f a * f b) : HasDistribNeg β :=
  { hf.HasInvolutiveNeg _ neg, ‹Mul β› with
    neg_mul :=
      hf.Forall₂.2 fun x y => by 
        erw [← neg, ← mul, neg_mul, neg, mul]
        rfl,
    mul_neg :=
      hf.Forall₂.2 fun x y => by 
        erw [← neg, ← mul, mul_neg, neg, mul]
        rfl }
#align function.surjective.has_distrib_neg Function.Surjective.hasDistribNeg

namespace AddOpposite

instance : HasDistribNeg αᵃᵒᵖ :=
  unop_injective.HasDistribNeg _ unop_neg unop_mul

end AddOpposite

end Mul

end HasDistribNeg

/-!
### Rings
-/


section NonUnitalNonAssocRing

variable [NonUnitalNonAssocRing α]

/- warning: function.injective.non_unital_non_assoc_ring -> Function.Injective.nonUnitalNonAssocRing is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u}} {β : Type.{v}} [_inst_1 : NonUnitalNonAssocRing.{u} α] [_inst_2 : Zero.{v} β] [_inst_3 : Add.{v} β] [_inst_4 : Mul.{v} β] [_inst_5 : Neg.{v} β] [_inst_6 : Sub.{v} β] [_inst_7 : HasSmul.{0, v} Nat β] [_inst_8 : HasSmul.{0, v} Int β] (f : β -> α), (Function.Injective.{succ v, succ u} β α f) -> (Eq.{succ u} α (f (OfNat.ofNat.{v} β 0 (OfNat.mk.{v} β 0 (Zero.zero.{v} β _inst_2)))) (OfNat.ofNat.{u} α 0 (OfNat.mk.{u} α 0 (Zero.zero.{u} α (MulZeroClass.toHasZero.{u} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α _inst_1))))))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β _inst_3) x y)) (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toHasAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α _inst_1)))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HMul.hMul.{v, v, v} β β β (instHMul.{v} β _inst_4) x y)) (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (Distrib.toHasMul.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α _inst_1)))) (f x) (f y))) -> (forall (x : β), Eq.{succ u} α (f (Neg.neg.{v} β _inst_5 x)) (Neg.neg.{u} α (SubNegMonoid.toHasNeg.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α _inst_1)))) (f x))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HSub.hSub.{v, v, v} β β β (instHSub.{v} β _inst_6) x y)) (HSub.hSub.{u, u, u} α α α (instHSub.{u} α (SubNegMonoid.toHasSub.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α _inst_1))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u} α (f (HasSmul.smul.{0, v} Nat β _inst_7 n x)) (HasSmul.smul.{0, u} Nat α (AddMonoid.hasSmulNat.{u} α (SubNegMonoid.toAddMonoid.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α _inst_1))))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u} α (f (HasSmul.smul.{0, v} Int β _inst_8 n x)) (HasSmul.smul.{0, u} Int α (SubNegMonoid.hasSmulInt.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α _inst_1)))) n (f x))) -> (NonUnitalNonAssocRing.{v} β)
but is expected to have type
  forall {α : Type.{u}} {β : Type.{v}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2836 : NonUnitalNonAssocRing.{u} α] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2839 : Zero.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2842 : Add.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2845 : Mul.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2848 : Neg.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2851 : Sub.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2854 : SMul.{0, v} Nat β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2860 : SMul.{0, v} Int β] (f : β -> α), (Function.Injective.{succ v, succ u} β α f) -> (Eq.{succ u} α (f (OfNat.ofNat.{v} β 0 (Zero.toOfNat0.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2839))) (OfNat.ofNat.{u} α 0 (Zero.toOfNat0.{u} α (MulZeroClass.toZero.{u} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2836)))))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2842) x y)) (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2836)))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HMul.hMul.{v, v, v} β β β (instHMul.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2845) x y)) (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (NonUnitalNonAssocRing.toMul.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2836)) (f x) (f y))) -> (forall (x : β), Eq.{succ u} α (f (Neg.neg.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2848 x)) (Neg.neg.{u} α (NegZeroClass.toNeg.{u} α (SubNegZeroMonoid.toNegZeroClass.{u} α (SubtractionMonoid.toSubNegZeroMonoid.{u} α (SubtractionCommMonoid.toSubtractionMonoid.{u} α (AddCommGroup.toSubtractionCommMonoid.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2836)))))) (f x))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HSub.hSub.{v, v, v} β β β (instHSub.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2851) x y)) (HSub.hSub.{u, u, u} α α α (instHSub.{u} α (SubNegMonoid.toSub.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2836))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u} α (f (HSMul.hSMul.{0, v, v} Nat β β (instHSMul.{0, v} Nat β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2854) n x)) (HSMul.hSMul.{0, u, u} Nat α α (instHSMul.{0, u} Nat α (AddMonoid.SMul.{u} α (SubNegMonoid.toAddMonoid.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2836)))))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u} α (f (HSMul.hSMul.{0, v, v} Int β β (instHSMul.{0, v} Int β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2860) n x)) (HSMul.hSMul.{0, u, u} Int α α (instHSMul.{0, u} Int α (SubNegMonoid.SMulInt.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.2836))))) n (f x))) -> (NonUnitalNonAssocRing.{v} β)
Case conversion may be inaccurate. Consider using '#align function.injective.non_unital_non_assoc_ring Function.Injective.nonUnitalNonAssocRingₓ'. -/
/-- Pullback a `non_unital_non_assoc_ring` instance along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.nonUnitalNonAssocRing [Zero β] [Add β] [Mul β] [Neg β] [Sub β]
    [HasSmul ℕ β] [HasSmul ℤ β] (f : β → α) (hf : Injective f) (zero : f 0 = 0)
    (add : ∀ x y, f (x + y) = f x + f y) (mul : ∀ x y, f (x * y) = f x * f y)
    (neg : ∀ x, f (-x) = -f x) (sub : ∀ x y, f (x - y) = f x - f y)
    (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) (zsmul : ∀ (x) (n : ℤ), f (n • x) = n • f x) :
    NonUnitalNonAssocRing β :=
  { hf.AddCommGroup f zero add neg sub nsmul zsmul, hf.MulZeroClass f zero mul,
    hf.Distrib f add mul with }
#align function.injective.non_unital_non_assoc_ring Function.Injective.nonUnitalNonAssocRing

/- warning: function.surjective.non_unital_non_assoc_ring -> Function.Surjective.nonUnitalNonAssocRing is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u}} {β : Type.{v}} [_inst_1 : NonUnitalNonAssocRing.{u} α] [_inst_2 : Zero.{v} β] [_inst_3 : Add.{v} β] [_inst_4 : Mul.{v} β] [_inst_5 : Neg.{v} β] [_inst_6 : Sub.{v} β] [_inst_7 : HasSmul.{0, v} Nat β] [_inst_8 : HasSmul.{0, v} Int β] (f : α -> β), (Function.Surjective.{succ u, succ v} α β f) -> (Eq.{succ v} β (f (OfNat.ofNat.{u} α 0 (OfNat.mk.{u} α 0 (Zero.zero.{u} α (MulZeroClass.toHasZero.{u} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α _inst_1))))))) (OfNat.ofNat.{v} β 0 (OfNat.mk.{v} β 0 (Zero.zero.{v} β _inst_2)))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toHasAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α _inst_1)))) x y)) (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β _inst_3) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (Distrib.toHasMul.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α _inst_1)))) x y)) (HMul.hMul.{v, v, v} β β β (instHMul.{v} β _inst_4) (f x) (f y))) -> (forall (x : α), Eq.{succ v} β (f (Neg.neg.{u} α (SubNegMonoid.toHasNeg.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α _inst_1)))) x)) (Neg.neg.{v} β _inst_5 (f x))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HSub.hSub.{u, u, u} α α α (instHSub.{u} α (SubNegMonoid.toHasSub.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α _inst_1))))) x y)) (HSub.hSub.{v, v, v} β β β (instHSub.{v} β _inst_6) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ v} β (f (HasSmul.smul.{0, u} Nat α (AddMonoid.hasSmulNat.{u} α (SubNegMonoid.toAddMonoid.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α _inst_1))))) n x)) (HasSmul.smul.{0, v} Nat β _inst_7 n (f x))) -> (forall (x : α) (n : Int), Eq.{succ v} β (f (HasSmul.smul.{0, u} Int α (SubNegMonoid.hasSmulInt.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α _inst_1)))) n x)) (HasSmul.smul.{0, v} Int β _inst_8 n (f x))) -> (NonUnitalNonAssocRing.{v} β)
but is expected to have type
  forall {α : Type.{u}} {β : Type.{v}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3053 : NonUnitalNonAssocRing.{u} α] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3056 : Zero.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3059 : Add.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3062 : Mul.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3065 : Neg.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3068 : Sub.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3071 : SMul.{0, v} Nat β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3077 : SMul.{0, v} Int β] (f : α -> β), (Function.Surjective.{succ u, succ v} α β f) -> (Eq.{succ v} β (f (OfNat.ofNat.{u} α 0 (Zero.toOfNat0.{u} α (MulZeroClass.toZero.{u} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3053)))))) (OfNat.ofNat.{v} β 0 (Zero.toOfNat0.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3056))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3053)))) x y)) (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3059) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (NonUnitalNonAssocRing.toMul.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3053)) x y)) (HMul.hMul.{v, v, v} β β β (instHMul.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3062) (f x) (f y))) -> (forall (x : α), Eq.{succ v} β (f (Neg.neg.{u} α (NegZeroClass.toNeg.{u} α (SubNegZeroMonoid.toNegZeroClass.{u} α (SubtractionMonoid.toSubNegZeroMonoid.{u} α (SubtractionCommMonoid.toSubtractionMonoid.{u} α (AddCommGroup.toSubtractionCommMonoid.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3053)))))) x)) (Neg.neg.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3065 (f x))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HSub.hSub.{u, u, u} α α α (instHSub.{u} α (SubNegMonoid.toSub.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3053))))) x y)) (HSub.hSub.{v, v, v} β β β (instHSub.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3068) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ v} β (f (HSMul.hSMul.{0, u, u} Nat α α (instHSMul.{0, u} Nat α (AddMonoid.SMul.{u} α (SubNegMonoid.toAddMonoid.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3053)))))) n x)) (HSMul.hSMul.{0, v, v} Nat β β (instHSMul.{0, v} Nat β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3071) n (f x))) -> (forall (x : α) (n : Int), Eq.{succ v} β (f (HSMul.hSMul.{0, u, u} Int α α (instHSMul.{0, u} Int α (SubNegMonoid.SMulInt.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3053))))) n x)) (HSMul.hSMul.{0, v, v} Int β β (instHSMul.{0, v} Int β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3077) n (f x))) -> (NonUnitalNonAssocRing.{v} β)
Case conversion may be inaccurate. Consider using '#align function.surjective.non_unital_non_assoc_ring Function.Surjective.nonUnitalNonAssocRingₓ'. -/
/-- Pushforward a `non_unital_non_assoc_ring` instance along a surjective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Surjective.nonUnitalNonAssocRing [Zero β] [Add β] [Mul β] [Neg β] [Sub β]
    [HasSmul ℕ β] [HasSmul ℤ β] (f : α → β) (hf : Surjective f) (zero : f 0 = 0)
    (add : ∀ x y, f (x + y) = f x + f y) (mul : ∀ x y, f (x * y) = f x * f y)
    (neg : ∀ x, f (-x) = -f x) (sub : ∀ x y, f (x - y) = f x - f y)
    (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) (zsmul : ∀ (x) (n : ℤ), f (n • x) = n • f x) :
    NonUnitalNonAssocRing β :=
  { hf.AddCommGroup f zero add neg sub nsmul zsmul, hf.MulZeroClass f zero mul,
    hf.Distrib f add mul with }
#align function.surjective.non_unital_non_assoc_ring Function.Surjective.nonUnitalNonAssocRing

end NonUnitalNonAssocRing

section NonUnitalRing

variable [NonUnitalRing α]

/- warning: function.injective.non_unital_ring -> Function.Injective.nonUnitalRing is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u}} {β : Type.{v}} [_inst_1 : NonUnitalRing.{u} α] [_inst_2 : Zero.{v} β] [_inst_3 : Add.{v} β] [_inst_4 : Mul.{v} β] [_inst_5 : Neg.{v} β] [_inst_6 : Sub.{v} β] [_inst_7 : HasSmul.{0, v} Nat β] [_inst_8 : HasSmul.{0, v} Int β] (f : β -> α), (Function.Injective.{succ v, succ u} β α f) -> (Eq.{succ u} α (f (OfNat.ofNat.{v} β 0 (OfNat.mk.{v} β 0 (Zero.zero.{v} β _inst_2)))) (OfNat.ofNat.{u} α 0 (OfNat.mk.{u} α 0 (Zero.zero.{u} α (MulZeroClass.toHasZero.{u} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α _inst_1)))))))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β _inst_3) x y)) (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toHasAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α _inst_1))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HMul.hMul.{v, v, v} β β β (instHMul.{v} β _inst_4) x y)) (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (Distrib.toHasMul.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α _inst_1))))) (f x) (f y))) -> (forall (x : β), Eq.{succ u} α (f (Neg.neg.{v} β _inst_5 x)) (Neg.neg.{u} α (SubNegMonoid.toHasNeg.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α _inst_1))))) (f x))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HSub.hSub.{v, v, v} β β β (instHSub.{v} β _inst_6) x y)) (HSub.hSub.{u, u, u} α α α (instHSub.{u} α (SubNegMonoid.toHasSub.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α _inst_1)))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u} α (f (HasSmul.smul.{0, v} Nat β _inst_7 n x)) (HasSmul.smul.{0, u} Nat α (AddMonoid.hasSmulNat.{u} α (SubNegMonoid.toAddMonoid.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α _inst_1)))))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u} α (f (HasSmul.smul.{0, v} Int β _inst_8 n x)) (HasSmul.smul.{0, u} Int α (SubNegMonoid.hasSmulInt.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α _inst_1))))) n (f x))) -> (NonUnitalRing.{v} β)
but is expected to have type
  forall {α : Type.{u}} {β : Type.{v}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3281 : NonUnitalRing.{u} α] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3284 : Zero.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3287 : Add.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3290 : Mul.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3293 : Neg.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3296 : Sub.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3299 : SMul.{0, v} Nat β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3305 : SMul.{0, v} Int β] (f : β -> α), (Function.Injective.{succ v, succ u} β α f) -> (Eq.{succ u} α (f (OfNat.ofNat.{v} β 0 (Zero.toOfNat0.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3284))) (OfNat.ofNat.{u} α 0 (Zero.toOfNat0.{u} α (SemigroupWithZero.toZero.{u} α (NonUnitalSemiring.toSemigroupWithZero.{u} α (NonUnitalRing.toNonUnitalSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3281)))))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3287) x y)) (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3281))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HMul.hMul.{v, v, v} β β β (instHMul.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3290) x y)) (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (NonUnitalNonAssocRing.toMul.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3281))) (f x) (f y))) -> (forall (x : β), Eq.{succ u} α (f (Neg.neg.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3293 x)) (Neg.neg.{u} α (NegZeroClass.toNeg.{u} α (SubNegZeroMonoid.toNegZeroClass.{u} α (SubtractionMonoid.toSubNegZeroMonoid.{u} α (SubtractionCommMonoid.toSubtractionMonoid.{u} α (AddCommGroup.toSubtractionCommMonoid.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3281))))))) (f x))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HSub.hSub.{v, v, v} β β β (instHSub.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3296) x y)) (HSub.hSub.{u, u, u} α α α (instHSub.{u} α (SubNegMonoid.toSub.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3281)))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u} α (f (HSMul.hSMul.{0, v, v} Nat β β (instHSMul.{0, v} Nat β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3299) n x)) (HSMul.hSMul.{0, u, u} Nat α α (instHSMul.{0, u} Nat α (AddMonoid.SMul.{u} α (SubNegMonoid.toAddMonoid.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3281))))))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u} α (f (HSMul.hSMul.{0, v, v} Int β β (instHSMul.{0, v} Int β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3305) n x)) (HSMul.hSMul.{0, u, u} Int α α (instHSMul.{0, u} Int α (SubNegMonoid.SMulInt.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3281)))))) n (f x))) -> (NonUnitalRing.{v} β)
Case conversion may be inaccurate. Consider using '#align function.injective.non_unital_ring Function.Injective.nonUnitalRingₓ'. -/
/-- Pullback a `non_unital_ring` instance along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.nonUnitalRing [Zero β] [Add β] [Mul β] [Neg β] [Sub β]
    [HasSmul ℕ β] [HasSmul ℤ β] (f : β → α) (hf : Injective f) (zero : f 0 = 0)
    (add : ∀ x y, f (x + y) = f x + f y) (mul : ∀ x y, f (x * y) = f x * f y)
    (neg : ∀ x, f (-x) = -f x) (sub : ∀ x y, f (x - y) = f x - f y)
    (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) (gsmul : ∀ (x) (n : ℤ), f (n • x) = n • f x) :
    NonUnitalRing β :=
  { hf.AddCommGroup f zero add neg sub nsmul gsmul, hf.MulZeroClass f zero mul,
    hf.Distrib f add mul, hf.Semigroup f mul with }
#align function.injective.non_unital_ring Function.Injective.nonUnitalRing

/- warning: function.surjective.non_unital_ring -> Function.Surjective.nonUnitalRing is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u}} {β : Type.{v}} [_inst_1 : NonUnitalRing.{u} α] [_inst_2 : Zero.{v} β] [_inst_3 : Add.{v} β] [_inst_4 : Mul.{v} β] [_inst_5 : Neg.{v} β] [_inst_6 : Sub.{v} β] [_inst_7 : HasSmul.{0, v} Nat β] [_inst_8 : HasSmul.{0, v} Int β] (f : α -> β), (Function.Surjective.{succ u, succ v} α β f) -> (Eq.{succ v} β (f (OfNat.ofNat.{u} α 0 (OfNat.mk.{u} α 0 (Zero.zero.{u} α (MulZeroClass.toHasZero.{u} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α _inst_1)))))))) (OfNat.ofNat.{v} β 0 (OfNat.mk.{v} β 0 (Zero.zero.{v} β _inst_2)))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toHasAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α _inst_1))))) x y)) (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β _inst_3) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (Distrib.toHasMul.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α _inst_1))))) x y)) (HMul.hMul.{v, v, v} β β β (instHMul.{v} β _inst_4) (f x) (f y))) -> (forall (x : α), Eq.{succ v} β (f (Neg.neg.{u} α (SubNegMonoid.toHasNeg.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α _inst_1))))) x)) (Neg.neg.{v} β _inst_5 (f x))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HSub.hSub.{u, u, u} α α α (instHSub.{u} α (SubNegMonoid.toHasSub.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α _inst_1)))))) x y)) (HSub.hSub.{v, v, v} β β β (instHSub.{v} β _inst_6) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ v} β (f (HasSmul.smul.{0, u} Nat α (AddMonoid.hasSmulNat.{u} α (SubNegMonoid.toAddMonoid.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α _inst_1)))))) n x)) (HasSmul.smul.{0, v} Nat β _inst_7 n (f x))) -> (forall (x : α) (n : Int), Eq.{succ v} β (f (HasSmul.smul.{0, u} Int α (SubNegMonoid.hasSmulInt.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α _inst_1))))) n x)) (HasSmul.smul.{0, v} Int β _inst_8 n (f x))) -> (NonUnitalRing.{v} β)
but is expected to have type
  forall {α : Type.{u}} {β : Type.{v}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3505 : NonUnitalRing.{u} α] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3508 : Zero.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3511 : Add.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3514 : Mul.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3517 : Neg.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3520 : Sub.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3523 : SMul.{0, v} Nat β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3529 : SMul.{0, v} Int β] (f : α -> β), (Function.Surjective.{succ u, succ v} α β f) -> (Eq.{succ v} β (f (OfNat.ofNat.{u} α 0 (Zero.toOfNat0.{u} α (SemigroupWithZero.toZero.{u} α (NonUnitalSemiring.toSemigroupWithZero.{u} α (NonUnitalRing.toNonUnitalSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3505)))))) (OfNat.ofNat.{v} β 0 (Zero.toOfNat0.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3508))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3505))))) x y)) (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3511) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (NonUnitalNonAssocRing.toMul.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3505))) x y)) (HMul.hMul.{v, v, v} β β β (instHMul.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3514) (f x) (f y))) -> (forall (x : α), Eq.{succ v} β (f (Neg.neg.{u} α (NegZeroClass.toNeg.{u} α (SubNegZeroMonoid.toNegZeroClass.{u} α (SubtractionMonoid.toSubNegZeroMonoid.{u} α (SubtractionCommMonoid.toSubtractionMonoid.{u} α (AddCommGroup.toSubtractionCommMonoid.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3505))))))) x)) (Neg.neg.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3517 (f x))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HSub.hSub.{u, u, u} α α α (instHSub.{u} α (SubNegMonoid.toSub.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3505)))))) x y)) (HSub.hSub.{v, v, v} β β β (instHSub.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3520) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ v} β (f (HSMul.hSMul.{0, u, u} Nat α α (instHSMul.{0, u} Nat α (AddMonoid.SMul.{u} α (SubNegMonoid.toAddMonoid.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3505))))))) n x)) (HSMul.hSMul.{0, v, v} Nat β β (instHSMul.{0, v} Nat β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3523) n (f x))) -> (forall (x : α) (n : Int), Eq.{succ v} β (f (HSMul.hSMul.{0, u, u} Int α α (instHSMul.{0, u} Int α (SubNegMonoid.SMulInt.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3505)))))) n x)) (HSMul.hSMul.{0, v, v} Int β β (instHSMul.{0, v} Int β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3529) n (f x))) -> (NonUnitalRing.{v} β)
Case conversion may be inaccurate. Consider using '#align function.surjective.non_unital_ring Function.Surjective.nonUnitalRingₓ'. -/
/-- Pushforward a `non_unital_ring` instance along a surjective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Surjective.nonUnitalRing [Zero β] [Add β] [Mul β] [Neg β] [Sub β]
    [HasSmul ℕ β] [HasSmul ℤ β] (f : α → β) (hf : Surjective f) (zero : f 0 = 0)
    (add : ∀ x y, f (x + y) = f x + f y) (mul : ∀ x y, f (x * y) = f x * f y)
    (neg : ∀ x, f (-x) = -f x) (sub : ∀ x y, f (x - y) = f x - f y)
    (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) (gsmul : ∀ (x) (n : ℤ), f (n • x) = n • f x) :
    NonUnitalRing β :=
  { hf.AddCommGroup f zero add neg sub nsmul gsmul, hf.MulZeroClass f zero mul,
    hf.Distrib f add mul, hf.Semigroup f mul with }
#align function.surjective.non_unital_ring Function.Surjective.nonUnitalRing

end NonUnitalRing

section NonAssocRing

variable [NonAssocRing α]

/- warning: function.injective.non_assoc_ring -> Function.Injective.nonAssocRing is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u}} {β : Type.{v}} [_inst_1 : NonAssocRing.{u} α] [_inst_2 : Zero.{v} β] [_inst_3 : One.{v} β] [_inst_4 : Add.{v} β] [_inst_5 : Mul.{v} β] [_inst_6 : Neg.{v} β] [_inst_7 : Sub.{v} β] [_inst_8 : HasSmul.{0, v} Nat β] [_inst_9 : HasSmul.{0, v} Int β] [_inst_10 : NatCast.{v} β] [_inst_11 : IntCast.{v} β] (f : β -> α), (Function.Injective.{succ v, succ u} β α f) -> (Eq.{succ u} α (f (OfNat.ofNat.{v} β 0 (OfNat.mk.{v} β 0 (Zero.zero.{v} β _inst_2)))) (OfNat.ofNat.{u} α 0 (OfNat.mk.{u} α 0 (Zero.zero.{u} α (MulZeroClass.toHasZero.{u} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α (NonAssocRing.toNonUnitalNonAssocRing.{u} α _inst_1)))))))) -> (Eq.{succ u} α (f (OfNat.ofNat.{v} β 1 (OfNat.mk.{v} β 1 (One.one.{v} β _inst_3)))) (OfNat.ofNat.{u} α 1 (OfNat.mk.{u} α 1 (One.one.{u} α (AddMonoidWithOne.toOne.{u} α (AddGroupWithOne.toAddMonoidWithOne.{u} α (NonAssocRing.toAddGroupWithOne.{u} α _inst_1))))))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β _inst_4) x y)) (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toHasAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α (NonAssocRing.toNonUnitalNonAssocRing.{u} α _inst_1))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HMul.hMul.{v, v, v} β β β (instHMul.{v} β _inst_5) x y)) (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (Distrib.toHasMul.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α (NonAssocRing.toNonUnitalNonAssocRing.{u} α _inst_1))))) (f x) (f y))) -> (forall (x : β), Eq.{succ u} α (f (Neg.neg.{v} β _inst_6 x)) (Neg.neg.{u} α (SubNegMonoid.toHasNeg.{u} α (AddGroup.toSubNegMonoid.{u} α (AddGroupWithOne.toAddGroup.{u} α (NonAssocRing.toAddGroupWithOne.{u} α _inst_1)))) (f x))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HSub.hSub.{v, v, v} β β β (instHSub.{v} β _inst_7) x y)) (HSub.hSub.{u, u, u} α α α (instHSub.{u} α (SubNegMonoid.toHasSub.{u} α (AddGroup.toSubNegMonoid.{u} α (AddGroupWithOne.toAddGroup.{u} α (NonAssocRing.toAddGroupWithOne.{u} α _inst_1))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u} α (f (HasSmul.smul.{0, v} Nat β _inst_8 n x)) (HasSmul.smul.{0, u} Nat α (AddMonoid.hasSmulNat.{u} α (AddMonoidWithOne.toAddMonoid.{u} α (AddGroupWithOne.toAddMonoidWithOne.{u} α (NonAssocRing.toAddGroupWithOne.{u} α _inst_1)))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u} α (f (HasSmul.smul.{0, v} Int β _inst_9 n x)) (HasSmul.smul.{0, u} Int α (SubNegMonoid.hasSmulInt.{u} α (AddGroup.toSubNegMonoid.{u} α (AddGroupWithOne.toAddGroup.{u} α (NonAssocRing.toAddGroupWithOne.{u} α _inst_1)))) n (f x))) -> (forall (n : Nat), Eq.{succ u} α (f ((fun (a : Type) (b : Type.{v}) [self : HasLiftT.{1, succ v} a b] => self.0) Nat β (HasLiftT.mk.{1, succ v} Nat β (CoeTCₓ.coe.{1, succ v} Nat β (Nat.castCoe.{v} β _inst_10))) n)) ((fun (a : Type) (b : Type.{u}) [self : HasLiftT.{1, succ u} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u} Nat α (CoeTCₓ.coe.{1, succ u} Nat α (Nat.castCoe.{u} α (AddMonoidWithOne.toNatCast.{u} α (AddGroupWithOne.toAddMonoidWithOne.{u} α (NonAssocRing.toAddGroupWithOne.{u} α _inst_1)))))) n)) -> (forall (n : Int), Eq.{succ u} α (f ((fun (a : Type) (b : Type.{v}) [self : HasLiftT.{1, succ v} a b] => self.0) Int β (HasLiftT.mk.{1, succ v} Int β (CoeTCₓ.coe.{1, succ v} Int β (Int.castCoe.{v} β _inst_11))) n)) ((fun (a : Type) (b : Type.{u}) [self : HasLiftT.{1, succ u} a b] => self.0) Int α (HasLiftT.mk.{1, succ u} Int α (CoeTCₓ.coe.{1, succ u} Int α (Int.castCoe.{u} α (AddGroupWithOne.toHasIntCast.{u} α (NonAssocRing.toAddGroupWithOne.{u} α _inst_1))))) n)) -> (NonAssocRing.{v} β)
but is expected to have type
  forall {α : Type.{u}} {β : Type.{v}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3740 : NonAssocRing.{u} α] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3743 : Zero.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3746 : One.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3749 : Add.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3752 : Mul.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3755 : Neg.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3758 : Sub.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3761 : SMul.{0, v} Nat β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3767 : SMul.{0, v} Int β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3773 : NatCast.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3776 : IntCast.{v} β] (f : β -> α), (Function.Injective.{succ v, succ u} β α f) -> (Eq.{succ u} α (f (OfNat.ofNat.{v} β 0 (Zero.toOfNat0.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3743))) (OfNat.ofNat.{u} α 0 (Zero.toOfNat0.{u} α (MulZeroOneClass.toZero.{u} α (NonAssocSemiring.toMulZeroOneClass.{u} α (NonAssocRing.toNonAssocSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3740)))))) -> (Eq.{succ u} α (f (OfNat.ofNat.{v} β 1 (One.toOfNat1.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3746))) (OfNat.ofNat.{u} α 1 (One.toOfNat1.{u} α (NonAssocRing.toOne.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3740)))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3749) x y)) (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α (NonAssocRing.toNonUnitalNonAssocRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3740))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HMul.hMul.{v, v, v} β β β (instHMul.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3752) x y)) (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (NonUnitalNonAssocRing.toMul.{u} α (NonAssocRing.toNonUnitalNonAssocRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3740))) (f x) (f y))) -> (forall (x : β), Eq.{succ u} α (f (Neg.neg.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3755 x)) (Neg.neg.{u} α (AddGroupWithOne.toNeg.{u} α (NonAssocRing.toAddGroupWithOne.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3740)) (f x))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HSub.hSub.{v, v, v} β β β (instHSub.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3758) x y)) (HSub.hSub.{u, u, u} α α α (instHSub.{u} α (AddGroupWithOne.toSub.{u} α (NonAssocRing.toAddGroupWithOne.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3740))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u} α (f (HSMul.hSMul.{0, v, v} Nat β β (instHSMul.{0, v} Nat β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3761) n x)) (HSMul.hSMul.{0, u, u} Nat α α (instHSMul.{0, u} Nat α (AddMonoid.SMul.{u} α (AddMonoidWithOne.toAddMonoid.{u} α (AddGroupWithOne.toAddMonoidWithOne.{u} α (NonAssocRing.toAddGroupWithOne.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3740))))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u} α (f (HSMul.hSMul.{0, v, v} Int β β (instHSMul.{0, v} Int β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3767) n x)) (HSMul.hSMul.{0, u, u} Int α α (instHSMul.{0, u} Int α (SubNegMonoid.SMulInt.{u} α (AddGroup.toSubNegMonoid.{u} α (AddGroupWithOne.toAddGroup.{u} α (NonAssocRing.toAddGroupWithOne.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3740))))) n (f x))) -> (forall (n : Nat), Eq.{succ u} α (f (Nat.cast.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3773 n)) (Nat.cast.{u} α (NonAssocRing.toNatCast.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3740) n)) -> (forall (n : Int), Eq.{succ u} α (f (Int.cast.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3776 n)) (Int.cast.{u} α (NonAssocRing.toIntCast.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.3740) n)) -> (NonAssocRing.{v} β)
Case conversion may be inaccurate. Consider using '#align function.injective.non_assoc_ring Function.Injective.nonAssocRingₓ'. -/
/-- Pullback a `non_assoc_ring` instance along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.nonAssocRing [Zero β] [One β] [Add β] [Mul β] [Neg β] [Sub β]
    [HasSmul ℕ β] [HasSmul ℤ β] [NatCast β] [IntCast β] (f : β → α) (hf : Injective f)
    (zero : f 0 = 0) (one : f 1 = 1) (add : ∀ x y, f (x + y) = f x + f y)
    (mul : ∀ x y, f (x * y) = f x * f y) (neg : ∀ x, f (-x) = -f x)
    (sub : ∀ x y, f (x - y) = f x - f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x)
    (gsmul : ∀ (x) (n : ℤ), f (n • x) = n • f x) (nat_cast : ∀ n : ℕ, f n = n)
    (int_cast : ∀ n : ℤ, f n = n) : NonAssocRing β :=
  { hf.AddCommGroup f zero add neg sub nsmul gsmul,
    hf.AddGroupWithOne f zero one add neg sub nsmul gsmul nat_cast int_cast,
    hf.MulZeroClass f zero mul, hf.Distrib f add mul, hf.MulOneClass f one mul with }
#align function.injective.non_assoc_ring Function.Injective.nonAssocRing

/- warning: function.surjective.non_assoc_ring -> Function.Surjective.nonAssocRing is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u}} {β : Type.{v}} [_inst_1 : NonAssocRing.{u} α] [_inst_2 : Zero.{v} β] [_inst_3 : One.{v} β] [_inst_4 : Add.{v} β] [_inst_5 : Mul.{v} β] [_inst_6 : Neg.{v} β] [_inst_7 : Sub.{v} β] [_inst_8 : HasSmul.{0, v} Nat β] [_inst_9 : HasSmul.{0, v} Int β] [_inst_10 : NatCast.{v} β] [_inst_11 : IntCast.{v} β] (f : α -> β), (Function.Surjective.{succ u, succ v} α β f) -> (Eq.{succ v} β (f (OfNat.ofNat.{u} α 0 (OfNat.mk.{u} α 0 (Zero.zero.{u} α (MulZeroClass.toHasZero.{u} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α (NonAssocRing.toNonUnitalNonAssocRing.{u} α _inst_1)))))))) (OfNat.ofNat.{v} β 0 (OfNat.mk.{v} β 0 (Zero.zero.{v} β _inst_2)))) -> (Eq.{succ v} β (f (OfNat.ofNat.{u} α 1 (OfNat.mk.{u} α 1 (One.one.{u} α (AddMonoidWithOne.toOne.{u} α (AddGroupWithOne.toAddMonoidWithOne.{u} α (NonAssocRing.toAddGroupWithOne.{u} α _inst_1))))))) (OfNat.ofNat.{v} β 1 (OfNat.mk.{v} β 1 (One.one.{v} β _inst_3)))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toHasAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α (NonAssocRing.toNonUnitalNonAssocRing.{u} α _inst_1))))) x y)) (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β _inst_4) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (Distrib.toHasMul.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α (NonAssocRing.toNonUnitalNonAssocRing.{u} α _inst_1))))) x y)) (HMul.hMul.{v, v, v} β β β (instHMul.{v} β _inst_5) (f x) (f y))) -> (forall (x : α), Eq.{succ v} β (f (Neg.neg.{u} α (SubNegMonoid.toHasNeg.{u} α (AddGroup.toSubNegMonoid.{u} α (AddGroupWithOne.toAddGroup.{u} α (NonAssocRing.toAddGroupWithOne.{u} α _inst_1)))) x)) (Neg.neg.{v} β _inst_6 (f x))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HSub.hSub.{u, u, u} α α α (instHSub.{u} α (SubNegMonoid.toHasSub.{u} α (AddGroup.toSubNegMonoid.{u} α (AddGroupWithOne.toAddGroup.{u} α (NonAssocRing.toAddGroupWithOne.{u} α _inst_1))))) x y)) (HSub.hSub.{v, v, v} β β β (instHSub.{v} β _inst_7) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ v} β (f (HasSmul.smul.{0, u} Nat α (AddMonoid.hasSmulNat.{u} α (AddMonoidWithOne.toAddMonoid.{u} α (AddGroupWithOne.toAddMonoidWithOne.{u} α (NonAssocRing.toAddGroupWithOne.{u} α _inst_1)))) n x)) (HasSmul.smul.{0, v} Nat β _inst_8 n (f x))) -> (forall (x : α) (n : Int), Eq.{succ v} β (f (HasSmul.smul.{0, u} Int α (SubNegMonoid.hasSmulInt.{u} α (AddGroup.toSubNegMonoid.{u} α (AddGroupWithOne.toAddGroup.{u} α (NonAssocRing.toAddGroupWithOne.{u} α _inst_1)))) n x)) (HasSmul.smul.{0, v} Int β _inst_9 n (f x))) -> (forall (n : Nat), Eq.{succ v} β (f ((fun (a : Type) (b : Type.{u}) [self : HasLiftT.{1, succ u} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u} Nat α (CoeTCₓ.coe.{1, succ u} Nat α (Nat.castCoe.{u} α (AddMonoidWithOne.toNatCast.{u} α (AddGroupWithOne.toAddMonoidWithOne.{u} α (NonAssocRing.toAddGroupWithOne.{u} α _inst_1)))))) n)) ((fun (a : Type) (b : Type.{v}) [self : HasLiftT.{1, succ v} a b] => self.0) Nat β (HasLiftT.mk.{1, succ v} Nat β (CoeTCₓ.coe.{1, succ v} Nat β (Nat.castCoe.{v} β _inst_10))) n)) -> (forall (n : Int), Eq.{succ v} β (f ((fun (a : Type) (b : Type.{u}) [self : HasLiftT.{1, succ u} a b] => self.0) Int α (HasLiftT.mk.{1, succ u} Int α (CoeTCₓ.coe.{1, succ u} Int α (Int.castCoe.{u} α (AddGroupWithOne.toHasIntCast.{u} α (NonAssocRing.toAddGroupWithOne.{u} α _inst_1))))) n)) ((fun (a : Type) (b : Type.{v}) [self : HasLiftT.{1, succ v} a b] => self.0) Int β (HasLiftT.mk.{1, succ v} Int β (CoeTCₓ.coe.{1, succ v} Int β (Int.castCoe.{v} β _inst_11))) n)) -> (NonAssocRing.{v} β)
but is expected to have type
  forall {α : Type.{u}} {β : Type.{v}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4028 : NonAssocRing.{u} α] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4031 : Zero.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4034 : One.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4037 : Add.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4040 : Mul.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4043 : Neg.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4046 : Sub.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4049 : SMul.{0, v} Nat β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4055 : SMul.{0, v} Int β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4061 : NatCast.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4064 : IntCast.{v} β] (f : α -> β), (Function.Surjective.{succ u, succ v} α β f) -> (Eq.{succ v} β (f (OfNat.ofNat.{u} α 0 (Zero.toOfNat0.{u} α (MulZeroOneClass.toZero.{u} α (NonAssocSemiring.toMulZeroOneClass.{u} α (NonAssocRing.toNonAssocSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4028)))))) (OfNat.ofNat.{v} β 0 (Zero.toOfNat0.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4031))) -> (Eq.{succ v} β (f (OfNat.ofNat.{u} α 1 (One.toOfNat1.{u} α (NonAssocRing.toOne.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4028)))) (OfNat.ofNat.{v} β 1 (One.toOfNat1.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4034))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α (NonAssocRing.toNonUnitalNonAssocRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4028))))) x y)) (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4037) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (NonUnitalNonAssocRing.toMul.{u} α (NonAssocRing.toNonUnitalNonAssocRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4028))) x y)) (HMul.hMul.{v, v, v} β β β (instHMul.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4040) (f x) (f y))) -> (forall (x : α), Eq.{succ v} β (f (Neg.neg.{u} α (AddGroupWithOne.toNeg.{u} α (NonAssocRing.toAddGroupWithOne.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4028)) x)) (Neg.neg.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4043 (f x))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HSub.hSub.{u, u, u} α α α (instHSub.{u} α (AddGroupWithOne.toSub.{u} α (NonAssocRing.toAddGroupWithOne.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4028))) x y)) (HSub.hSub.{v, v, v} β β β (instHSub.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4046) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ v} β (f (HSMul.hSMul.{0, u, u} Nat α α (instHSMul.{0, u} Nat α (AddMonoid.SMul.{u} α (AddMonoidWithOne.toAddMonoid.{u} α (AddGroupWithOne.toAddMonoidWithOne.{u} α (NonAssocRing.toAddGroupWithOne.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4028))))) n x)) (HSMul.hSMul.{0, v, v} Nat β β (instHSMul.{0, v} Nat β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4049) n (f x))) -> (forall (x : α) (n : Int), Eq.{succ v} β (f (HSMul.hSMul.{0, u, u} Int α α (instHSMul.{0, u} Int α (SubNegMonoid.SMulInt.{u} α (AddGroup.toSubNegMonoid.{u} α (AddGroupWithOne.toAddGroup.{u} α (NonAssocRing.toAddGroupWithOne.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4028))))) n x)) (HSMul.hSMul.{0, v, v} Int β β (instHSMul.{0, v} Int β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4055) n (f x))) -> (forall (n : Nat), Eq.{succ v} β (f (Nat.cast.{u} α (NonAssocRing.toNatCast.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4028) n)) (Nat.cast.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4061 n)) -> (forall (n : Int), Eq.{succ v} β (f (Int.cast.{u} α (NonAssocRing.toIntCast.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4028) n)) (Int.cast.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4064 n)) -> (NonAssocRing.{v} β)
Case conversion may be inaccurate. Consider using '#align function.surjective.non_assoc_ring Function.Surjective.nonAssocRingₓ'. -/
/-- Pushforward a `non_unital_ring` instance along a surjective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Surjective.nonAssocRing [Zero β] [One β] [Add β] [Mul β] [Neg β] [Sub β]
    [HasSmul ℕ β] [HasSmul ℤ β] [NatCast β] [IntCast β] (f : α → β) (hf : Surjective f)
    (zero : f 0 = 0) (one : f 1 = 1) (add : ∀ x y, f (x + y) = f x + f y)
    (mul : ∀ x y, f (x * y) = f x * f y) (neg : ∀ x, f (-x) = -f x)
    (sub : ∀ x y, f (x - y) = f x - f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x)
    (gsmul : ∀ (x) (n : ℤ), f (n • x) = n • f x) (nat_cast : ∀ n : ℕ, f n = n)
    (int_cast : ∀ n : ℤ, f n = n) : NonAssocRing β :=
  { hf.AddCommGroup f zero add neg sub nsmul gsmul, hf.MulZeroClass f zero mul,
    hf.AddGroupWithOne f zero one add neg sub nsmul gsmul nat_cast int_cast, hf.Distrib f add mul,
    hf.MulOneClass f one mul with }
#align function.surjective.non_assoc_ring Function.Surjective.nonAssocRing

end NonAssocRing

section Ring

variable [Ring α] {a b c d e : α}

/- warning: function.injective.ring -> Function.Injective.ring is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u}} {β : Type.{v}} [_inst_1 : Ring.{u} α] [_inst_2 : Zero.{v} β] [_inst_3 : One.{v} β] [_inst_4 : Add.{v} β] [_inst_5 : Mul.{v} β] [_inst_6 : Neg.{v} β] [_inst_7 : Sub.{v} β] [_inst_8 : HasSmul.{0, v} Nat β] [_inst_9 : HasSmul.{0, v} Int β] [_inst_10 : Pow.{v, 0} β Nat] [_inst_11 : NatCast.{v} β] [_inst_12 : IntCast.{v} β] (f : β -> α), (Function.Injective.{succ v, succ u} β α f) -> (Eq.{succ u} α (f (OfNat.ofNat.{v} β 0 (OfNat.mk.{v} β 0 (Zero.zero.{v} β _inst_2)))) (OfNat.ofNat.{u} α 0 (OfNat.mk.{u} α 0 (Zero.zero.{u} α (MulZeroClass.toHasZero.{u} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α (NonAssocRing.toNonUnitalNonAssocRing.{u} α (Ring.toNonAssocRing.{u} α _inst_1))))))))) -> (Eq.{succ u} α (f (OfNat.ofNat.{v} β 1 (OfNat.mk.{v} β 1 (One.one.{v} β _inst_3)))) (OfNat.ofNat.{u} α 1 (OfNat.mk.{u} α 1 (One.one.{u} α (AddMonoidWithOne.toOne.{u} α (AddGroupWithOne.toAddMonoidWithOne.{u} α (NonAssocRing.toAddGroupWithOne.{u} α (Ring.toNonAssocRing.{u} α _inst_1)))))))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β _inst_4) x y)) (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toHasAdd.{u} α (Ring.toDistrib.{u} α _inst_1))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HMul.hMul.{v, v, v} β β β (instHMul.{v} β _inst_5) x y)) (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (Distrib.toHasMul.{u} α (Ring.toDistrib.{u} α _inst_1))) (f x) (f y))) -> (forall (x : β), Eq.{succ u} α (f (Neg.neg.{v} β _inst_6 x)) (Neg.neg.{u} α (SubNegMonoid.toHasNeg.{u} α (AddGroup.toSubNegMonoid.{u} α (AddGroupWithOne.toAddGroup.{u} α (NonAssocRing.toAddGroupWithOne.{u} α (Ring.toNonAssocRing.{u} α _inst_1))))) (f x))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HSub.hSub.{v, v, v} β β β (instHSub.{v} β _inst_7) x y)) (HSub.hSub.{u, u, u} α α α (instHSub.{u} α (SubNegMonoid.toHasSub.{u} α (AddGroup.toSubNegMonoid.{u} α (AddGroupWithOne.toAddGroup.{u} α (NonAssocRing.toAddGroupWithOne.{u} α (Ring.toNonAssocRing.{u} α _inst_1)))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u} α (f (HasSmul.smul.{0, v} Nat β _inst_8 n x)) (HasSmul.smul.{0, u} Nat α (AddMonoid.hasSmulNat.{u} α (AddMonoidWithOne.toAddMonoid.{u} α (AddGroupWithOne.toAddMonoidWithOne.{u} α (NonAssocRing.toAddGroupWithOne.{u} α (Ring.toNonAssocRing.{u} α _inst_1))))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u} α (f (HasSmul.smul.{0, v} Int β _inst_9 n x)) (HasSmul.smul.{0, u} Int α (SubNegMonoid.hasSmulInt.{u} α (AddGroup.toSubNegMonoid.{u} α (AddGroupWithOne.toAddGroup.{u} α (NonAssocRing.toAddGroupWithOne.{u} α (Ring.toNonAssocRing.{u} α _inst_1))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u} α (f (HPow.hPow.{v, 0, v} β Nat β (instHPow.{v, 0} β Nat _inst_10) x n)) (HPow.hPow.{u, 0, u} α Nat α (instHPow.{u, 0} α Nat (Monoid.hasPow.{u} α (Ring.toMonoid.{u} α _inst_1))) (f x) n)) -> (forall (n : Nat), Eq.{succ u} α (f ((fun (a : Type) (b : Type.{v}) [self : HasLiftT.{1, succ v} a b] => self.0) Nat β (HasLiftT.mk.{1, succ v} Nat β (CoeTCₓ.coe.{1, succ v} Nat β (Nat.castCoe.{v} β _inst_11))) n)) ((fun (a : Type) (b : Type.{u}) [self : HasLiftT.{1, succ u} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u} Nat α (CoeTCₓ.coe.{1, succ u} Nat α (Nat.castCoe.{u} α (AddMonoidWithOne.toNatCast.{u} α (AddGroupWithOne.toAddMonoidWithOne.{u} α (NonAssocRing.toAddGroupWithOne.{u} α (Ring.toNonAssocRing.{u} α _inst_1))))))) n)) -> (forall (n : Int), Eq.{succ u} α (f ((fun (a : Type) (b : Type.{v}) [self : HasLiftT.{1, succ v} a b] => self.0) Int β (HasLiftT.mk.{1, succ v} Int β (CoeTCₓ.coe.{1, succ v} Int β (Int.castCoe.{v} β _inst_12))) n)) ((fun (a : Type) (b : Type.{u}) [self : HasLiftT.{1, succ u} a b] => self.0) Int α (HasLiftT.mk.{1, succ u} Int α (CoeTCₓ.coe.{1, succ u} Int α (Int.castCoe.{u} α (AddGroupWithOne.toHasIntCast.{u} α (NonAssocRing.toAddGroupWithOne.{u} α (Ring.toNonAssocRing.{u} α _inst_1)))))) n)) -> (Ring.{v} β)
but is expected to have type
  forall {α : Type.{u}} {β : Type.{v}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4337 : Ring.{u} α] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4345 : Zero.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4348 : One.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4351 : Add.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4354 : Mul.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4357 : Neg.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4360 : Sub.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4363 : SMul.{0, v} Nat β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4369 : SMul.{0, v} Int β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4375 : Pow.{v, 0} β Nat] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4381 : NatCast.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4384 : IntCast.{v} β] (f : β -> α), (Function.Injective.{succ v, succ u} β α f) -> (Eq.{succ u} α (f (OfNat.ofNat.{v} β 0 (Zero.toOfNat0.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4345))) (OfNat.ofNat.{u} α 0 (Zero.toOfNat0.{u} α (MonoidWithZero.toZero.{u} α (Semiring.toMonoidWithZero.{u} α (Ring.toSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4337)))))) -> (Eq.{succ u} α (f (OfNat.ofNat.{v} β 1 (One.toOfNat1.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4348))) (OfNat.ofNat.{u} α 1 (One.toOfNat1.{u} α (NonAssocRing.toOne.{u} α (Ring.toNonAssocRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4337))))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4351) x y)) (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α (NonAssocRing.toNonUnitalNonAssocRing.{u} α (Ring.toNonAssocRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4337)))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HMul.hMul.{v, v, v} β β β (instHMul.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4354) x y)) (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (NonUnitalNonAssocRing.toMul.{u} α (NonAssocRing.toNonUnitalNonAssocRing.{u} α (Ring.toNonAssocRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4337)))) (f x) (f y))) -> (forall (x : β), Eq.{succ u} α (f (Neg.neg.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4357 x)) (Neg.neg.{u} α (Ring.toNeg.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4337) (f x))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HSub.hSub.{v, v, v} β β β (instHSub.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4360) x y)) (HSub.hSub.{u, u, u} α α α (instHSub.{u} α (Ring.toSub.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4337)) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u} α (f (HSMul.hSMul.{0, v, v} Nat β β (instHSMul.{0, v} Nat β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4363) n x)) (HSMul.hSMul.{0, u, u} Nat α α (instHSMul.{0, u} Nat α (AddMonoid.SMul.{u} α (AddMonoidWithOne.toAddMonoid.{u} α (AddGroupWithOne.toAddMonoidWithOne.{u} α (Ring.toAddGroupWithOne.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4337))))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u} α (f (HSMul.hSMul.{0, v, v} Int β β (instHSMul.{0, v} Int β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4369) n x)) (HSMul.hSMul.{0, u, u} Int α α (instHSMul.{0, u} Int α (SubNegMonoid.SMulInt.{u} α (AddGroup.toSubNegMonoid.{u} α (AddGroupWithOne.toAddGroup.{u} α (Ring.toAddGroupWithOne.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4337))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u} α (f (HPow.hPow.{v, 0, v} β Nat β (instHPow.{v, 0} β Nat inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4375) x n)) (HPow.hPow.{u, 0, u} α Nat α (instHPow.{u, 0} α Nat (Monoid.Pow.{u} α (MonoidWithZero.toMonoid.{u} α (Semiring.toMonoidWithZero.{u} α (Ring.toSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4337))))) (f x) n)) -> (forall (n : Nat), Eq.{succ u} α (f (Nat.cast.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4381 n)) (Nat.cast.{u} α (NonAssocRing.toNatCast.{u} α (Ring.toNonAssocRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4337)) n)) -> (forall (n : Int), Eq.{succ u} α (f (Int.cast.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4384 n)) (Int.cast.{u} α (Ring.toIntCast.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4337) n)) -> (Ring.{v} β)
Case conversion may be inaccurate. Consider using '#align function.injective.ring Function.Injective.ringₓ'. -/
/-- Pullback a `ring` instance along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.ring [Zero β] [One β] [Add β] [Mul β] [Neg β] [Sub β] [HasSmul ℕ β]
    [HasSmul ℤ β] [Pow β ℕ] [NatCast β] [IntCast β] (f : β → α) (hf : Injective f) (zero : f 0 = 0)
    (one : f 1 = 1) (add : ∀ x y, f (x + y) = f x + f y) (mul : ∀ x y, f (x * y) = f x * f y)
    (neg : ∀ x, f (-x) = -f x) (sub : ∀ x y, f (x - y) = f x - f y)
    (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) (zsmul : ∀ (x) (n : ℤ), f (n • x) = n • f x)
    (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n) (nat_cast : ∀ n : ℕ, f n = n)
    (int_cast : ∀ n : ℤ, f n = n) : Ring β :=
  { hf.AddGroupWithOne f zero one add neg sub nsmul zsmul nat_cast int_cast,
    hf.AddCommGroup f zero add neg sub nsmul zsmul, hf.Monoid f one mul npow,
    hf.Distrib f add mul with }
#align function.injective.ring Function.Injective.ring

/- warning: function.surjective.ring -> Function.Surjective.ring is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u}} {β : Type.{v}} [_inst_1 : Ring.{u} α] [_inst_2 : Zero.{v} β] [_inst_3 : One.{v} β] [_inst_4 : Add.{v} β] [_inst_5 : Mul.{v} β] [_inst_6 : Neg.{v} β] [_inst_7 : Sub.{v} β] [_inst_8 : HasSmul.{0, v} Nat β] [_inst_9 : HasSmul.{0, v} Int β] [_inst_10 : Pow.{v, 0} β Nat] [_inst_11 : NatCast.{v} β] [_inst_12 : IntCast.{v} β] (f : α -> β), (Function.Surjective.{succ u, succ v} α β f) -> (Eq.{succ v} β (f (OfNat.ofNat.{u} α 0 (OfNat.mk.{u} α 0 (Zero.zero.{u} α (MulZeroClass.toHasZero.{u} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α (NonAssocRing.toNonUnitalNonAssocRing.{u} α (Ring.toNonAssocRing.{u} α _inst_1))))))))) (OfNat.ofNat.{v} β 0 (OfNat.mk.{v} β 0 (Zero.zero.{v} β _inst_2)))) -> (Eq.{succ v} β (f (OfNat.ofNat.{u} α 1 (OfNat.mk.{u} α 1 (One.one.{u} α (AddMonoidWithOne.toOne.{u} α (AddGroupWithOne.toAddMonoidWithOne.{u} α (NonAssocRing.toAddGroupWithOne.{u} α (Ring.toNonAssocRing.{u} α _inst_1)))))))) (OfNat.ofNat.{v} β 1 (OfNat.mk.{v} β 1 (One.one.{v} β _inst_3)))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toHasAdd.{u} α (Ring.toDistrib.{u} α _inst_1))) x y)) (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β _inst_4) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (Distrib.toHasMul.{u} α (Ring.toDistrib.{u} α _inst_1))) x y)) (HMul.hMul.{v, v, v} β β β (instHMul.{v} β _inst_5) (f x) (f y))) -> (forall (x : α), Eq.{succ v} β (f (Neg.neg.{u} α (SubNegMonoid.toHasNeg.{u} α (AddGroup.toSubNegMonoid.{u} α (AddGroupWithOne.toAddGroup.{u} α (NonAssocRing.toAddGroupWithOne.{u} α (Ring.toNonAssocRing.{u} α _inst_1))))) x)) (Neg.neg.{v} β _inst_6 (f x))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HSub.hSub.{u, u, u} α α α (instHSub.{u} α (SubNegMonoid.toHasSub.{u} α (AddGroup.toSubNegMonoid.{u} α (AddGroupWithOne.toAddGroup.{u} α (NonAssocRing.toAddGroupWithOne.{u} α (Ring.toNonAssocRing.{u} α _inst_1)))))) x y)) (HSub.hSub.{v, v, v} β β β (instHSub.{v} β _inst_7) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ v} β (f (HasSmul.smul.{0, u} Nat α (AddMonoid.hasSmulNat.{u} α (AddMonoidWithOne.toAddMonoid.{u} α (AddGroupWithOne.toAddMonoidWithOne.{u} α (NonAssocRing.toAddGroupWithOne.{u} α (Ring.toNonAssocRing.{u} α _inst_1))))) n x)) (HasSmul.smul.{0, v} Nat β _inst_8 n (f x))) -> (forall (x : α) (n : Int), Eq.{succ v} β (f (HasSmul.smul.{0, u} Int α (SubNegMonoid.hasSmulInt.{u} α (AddGroup.toSubNegMonoid.{u} α (AddGroupWithOne.toAddGroup.{u} α (NonAssocRing.toAddGroupWithOne.{u} α (Ring.toNonAssocRing.{u} α _inst_1))))) n x)) (HasSmul.smul.{0, v} Int β _inst_9 n (f x))) -> (forall (x : α) (n : Nat), Eq.{succ v} β (f (HPow.hPow.{u, 0, u} α Nat α (instHPow.{u, 0} α Nat (Monoid.hasPow.{u} α (Ring.toMonoid.{u} α _inst_1))) x n)) (HPow.hPow.{v, 0, v} β Nat β (instHPow.{v, 0} β Nat _inst_10) (f x) n)) -> (forall (n : Nat), Eq.{succ v} β (f ((fun (a : Type) (b : Type.{u}) [self : HasLiftT.{1, succ u} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u} Nat α (CoeTCₓ.coe.{1, succ u} Nat α (Nat.castCoe.{u} α (AddMonoidWithOne.toNatCast.{u} α (AddGroupWithOne.toAddMonoidWithOne.{u} α (NonAssocRing.toAddGroupWithOne.{u} α (Ring.toNonAssocRing.{u} α _inst_1))))))) n)) ((fun (a : Type) (b : Type.{v}) [self : HasLiftT.{1, succ v} a b] => self.0) Nat β (HasLiftT.mk.{1, succ v} Nat β (CoeTCₓ.coe.{1, succ v} Nat β (Nat.castCoe.{v} β _inst_11))) n)) -> (forall (n : Int), Eq.{succ v} β (f ((fun (a : Type) (b : Type.{u}) [self : HasLiftT.{1, succ u} a b] => self.0) Int α (HasLiftT.mk.{1, succ u} Int α (CoeTCₓ.coe.{1, succ u} Int α (Int.castCoe.{u} α (AddGroupWithOne.toHasIntCast.{u} α (NonAssocRing.toAddGroupWithOne.{u} α (Ring.toNonAssocRing.{u} α _inst_1)))))) n)) ((fun (a : Type) (b : Type.{v}) [self : HasLiftT.{1, succ v} a b] => self.0) Int β (HasLiftT.mk.{1, succ v} Int β (CoeTCₓ.coe.{1, succ v} Int β (Int.castCoe.{v} β _inst_12))) n)) -> (Ring.{v} β)
but is expected to have type
  forall {α : Type.{u}} {β : Type.{v}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4670 : Ring.{u} α] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4678 : Zero.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4681 : One.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4684 : Add.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4687 : Mul.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4690 : Neg.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4693 : Sub.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4696 : SMul.{0, v} Nat β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4702 : SMul.{0, v} Int β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4708 : Pow.{v, 0} β Nat] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4714 : NatCast.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4717 : IntCast.{v} β] (f : α -> β), (Function.Surjective.{succ u, succ v} α β f) -> (Eq.{succ v} β (f (OfNat.ofNat.{u} α 0 (Zero.toOfNat0.{u} α (MonoidWithZero.toZero.{u} α (Semiring.toMonoidWithZero.{u} α (Ring.toSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4670)))))) (OfNat.ofNat.{v} β 0 (Zero.toOfNat0.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4678))) -> (Eq.{succ v} β (f (OfNat.ofNat.{u} α 1 (One.toOfNat1.{u} α (NonAssocRing.toOne.{u} α (Ring.toNonAssocRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4670))))) (OfNat.ofNat.{v} β 1 (One.toOfNat1.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4681))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α (NonAssocRing.toNonUnitalNonAssocRing.{u} α (Ring.toNonAssocRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4670)))))) x y)) (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4684) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (NonUnitalNonAssocRing.toMul.{u} α (NonAssocRing.toNonUnitalNonAssocRing.{u} α (Ring.toNonAssocRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4670)))) x y)) (HMul.hMul.{v, v, v} β β β (instHMul.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4687) (f x) (f y))) -> (forall (x : α), Eq.{succ v} β (f (Neg.neg.{u} α (Ring.toNeg.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4670) x)) (Neg.neg.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4690 (f x))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HSub.hSub.{u, u, u} α α α (instHSub.{u} α (Ring.toSub.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4670)) x y)) (HSub.hSub.{v, v, v} β β β (instHSub.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4693) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ v} β (f (HSMul.hSMul.{0, u, u} Nat α α (instHSMul.{0, u} Nat α (AddMonoid.SMul.{u} α (AddMonoidWithOne.toAddMonoid.{u} α (AddGroupWithOne.toAddMonoidWithOne.{u} α (Ring.toAddGroupWithOne.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4670))))) n x)) (HSMul.hSMul.{0, v, v} Nat β β (instHSMul.{0, v} Nat β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4696) n (f x))) -> (forall (x : α) (n : Int), Eq.{succ v} β (f (HSMul.hSMul.{0, u, u} Int α α (instHSMul.{0, u} Int α (SubNegMonoid.SMulInt.{u} α (AddGroup.toSubNegMonoid.{u} α (AddGroupWithOne.toAddGroup.{u} α (Ring.toAddGroupWithOne.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4670))))) n x)) (HSMul.hSMul.{0, v, v} Int β β (instHSMul.{0, v} Int β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4702) n (f x))) -> (forall (x : α) (n : Nat), Eq.{succ v} β (f (HPow.hPow.{u, 0, u} α Nat α (instHPow.{u, 0} α Nat (Monoid.Pow.{u} α (MonoidWithZero.toMonoid.{u} α (Semiring.toMonoidWithZero.{u} α (Ring.toSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4670))))) x n)) (HPow.hPow.{v, 0, v} β Nat β (instHPow.{v, 0} β Nat inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4708) (f x) n)) -> (forall (n : Nat), Eq.{succ v} β (f (Nat.cast.{u} α (NonAssocRing.toNatCast.{u} α (Ring.toNonAssocRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4670)) n)) (Nat.cast.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4714 n)) -> (forall (n : Int), Eq.{succ v} β (f (Int.cast.{u} α (Ring.toIntCast.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4670) n)) (Int.cast.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.4717 n)) -> (Ring.{v} β)
Case conversion may be inaccurate. Consider using '#align function.surjective.ring Function.Surjective.ringₓ'. -/
/-- Pushforward a `ring` instance along a surjective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Surjective.ring [Zero β] [One β] [Add β] [Mul β] [Neg β] [Sub β]
    [HasSmul ℕ β] [HasSmul ℤ β] [Pow β ℕ] [NatCast β] [IntCast β] (f : α → β) (hf : Surjective f)
    (zero : f 0 = 0) (one : f 1 = 1) (add : ∀ x y, f (x + y) = f x + f y)
    (mul : ∀ x y, f (x * y) = f x * f y) (neg : ∀ x, f (-x) = -f x)
    (sub : ∀ x y, f (x - y) = f x - f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x)
    (zsmul : ∀ (x) (n : ℤ), f (n • x) = n • f x) (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n)
    (nat_cast : ∀ n : ℕ, f n = n) (int_cast : ∀ n : ℤ, f n = n) : Ring β :=
  { hf.AddGroupWithOne f zero one add neg sub nsmul zsmul nat_cast int_cast,
    hf.AddCommGroup f zero add neg sub nsmul zsmul, hf.Monoid f one mul npow,
    hf.Distrib f add mul with }
#align function.surjective.ring Function.Surjective.ring

end Ring

section NonUnitalCommRing

variable [NonUnitalCommRing α] {a b c : α}

/- warning: function.injective.non_unital_comm_ring -> Function.Injective.nonUnitalCommRing is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u}} {β : Type.{v}} [_inst_1 : NonUnitalCommRing.{u} α] [_inst_2 : Zero.{v} β] [_inst_3 : Add.{v} β] [_inst_4 : Mul.{v} β] [_inst_5 : Neg.{v} β] [_inst_6 : Sub.{v} β] [_inst_7 : HasSmul.{0, v} Nat β] [_inst_8 : HasSmul.{0, v} Int β] (f : β -> α), (Function.Injective.{succ v, succ u} β α f) -> (Eq.{succ u} α (f (OfNat.ofNat.{v} β 0 (OfNat.mk.{v} β 0 (Zero.zero.{v} β _inst_2)))) (OfNat.ofNat.{u} α 0 (OfNat.mk.{u} α 0 (Zero.zero.{u} α (MulZeroClass.toHasZero.{u} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α (NonUnitalCommRing.toNonUnitalRing.{u} α _inst_1))))))))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β _inst_3) x y)) (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toHasAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α (NonUnitalCommRing.toNonUnitalRing.{u} α _inst_1)))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HMul.hMul.{v, v, v} β β β (instHMul.{v} β _inst_4) x y)) (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (Distrib.toHasMul.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α (NonUnitalCommRing.toNonUnitalRing.{u} α _inst_1)))))) (f x) (f y))) -> (forall (x : β), Eq.{succ u} α (f (Neg.neg.{v} β _inst_5 x)) (Neg.neg.{u} α (SubNegMonoid.toHasNeg.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α (NonUnitalCommRing.toNonUnitalRing.{u} α _inst_1)))))) (f x))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HSub.hSub.{v, v, v} β β β (instHSub.{v} β _inst_6) x y)) (HSub.hSub.{u, u, u} α α α (instHSub.{u} α (SubNegMonoid.toHasSub.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α (NonUnitalCommRing.toNonUnitalRing.{u} α _inst_1))))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u} α (f (HasSmul.smul.{0, v} Nat β _inst_7 n x)) (HasSmul.smul.{0, u} Nat α (AddMonoid.hasSmulNat.{u} α (SubNegMonoid.toAddMonoid.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α (NonUnitalCommRing.toNonUnitalRing.{u} α _inst_1))))))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u} α (f (HasSmul.smul.{0, v} Int β _inst_8 n x)) (HasSmul.smul.{0, u} Int α (SubNegMonoid.hasSmulInt.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α (NonUnitalCommRing.toNonUnitalRing.{u} α _inst_1)))))) n (f x))) -> (NonUnitalCommRing.{v} β)
but is expected to have type
  forall {α : Type.{u}} {β : Type.{v}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5020 : NonUnitalCommRing.{u} α] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5026 : Zero.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5029 : Add.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5032 : Mul.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5035 : Neg.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5038 : Sub.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5041 : SMul.{0, v} Nat β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5047 : SMul.{0, v} Int β] (f : β -> α), (Function.Injective.{succ v, succ u} β α f) -> (Eq.{succ u} α (f (OfNat.ofNat.{v} β 0 (Zero.toOfNat0.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5026))) (OfNat.ofNat.{u} α 0 (Zero.toOfNat0.{u} α (SemigroupWithZero.toZero.{u} α (NonUnitalSemiring.toSemigroupWithZero.{u} α (NonUnitalRing.toNonUnitalSemiring.{u} α (NonUnitalCommRing.toNonUnitalRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5020))))))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5029) x y)) (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α (NonUnitalCommRing.toNonUnitalRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5020)))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HMul.hMul.{v, v, v} β β β (instHMul.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5032) x y)) (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (NonUnitalNonAssocRing.toMul.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α (NonUnitalCommRing.toNonUnitalRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5020)))) (f x) (f y))) -> (forall (x : β), Eq.{succ u} α (f (Neg.neg.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5035 x)) (Neg.neg.{u} α (NegZeroClass.toNeg.{u} α (SubNegZeroMonoid.toNegZeroClass.{u} α (SubtractionMonoid.toSubNegZeroMonoid.{u} α (SubtractionCommMonoid.toSubtractionMonoid.{u} α (AddCommGroup.toSubtractionCommMonoid.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α (NonUnitalCommRing.toNonUnitalRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5020)))))))) (f x))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HSub.hSub.{v, v, v} β β β (instHSub.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5038) x y)) (HSub.hSub.{u, u, u} α α α (instHSub.{u} α (SubNegMonoid.toSub.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α (NonUnitalCommRing.toNonUnitalRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5020))))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u} α (f (HSMul.hSMul.{0, v, v} Nat β β (instHSMul.{0, v} Nat β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5041) n x)) (HSMul.hSMul.{0, u, u} Nat α α (instHSMul.{0, u} Nat α (AddMonoid.SMul.{u} α (SubNegMonoid.toAddMonoid.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α (NonUnitalCommRing.toNonUnitalRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5020)))))))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u} α (f (HSMul.hSMul.{0, v, v} Int β β (instHSMul.{0, v} Int β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5047) n x)) (HSMul.hSMul.{0, u, u} Int α α (instHSMul.{0, u} Int α (SubNegMonoid.SMulInt.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α (NonUnitalCommRing.toNonUnitalRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5020))))))) n (f x))) -> (NonUnitalCommRing.{v} β)
Case conversion may be inaccurate. Consider using '#align function.injective.non_unital_comm_ring Function.Injective.nonUnitalCommRingₓ'. -/
/-- Pullback a `comm_ring` instance along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.nonUnitalCommRing [Zero β] [Add β] [Mul β] [Neg β] [Sub β]
    [HasSmul ℕ β] [HasSmul ℤ β] (f : β → α) (hf : Injective f) (zero : f 0 = 0)
    (add : ∀ x y, f (x + y) = f x + f y) (mul : ∀ x y, f (x * y) = f x * f y)
    (neg : ∀ x, f (-x) = -f x) (sub : ∀ x y, f (x - y) = f x - f y)
    (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) (zsmul : ∀ (x) (n : ℤ), f (n • x) = n • f x) :
    NonUnitalCommRing β :=
  { hf.NonUnitalRing f zero add mul neg sub nsmul zsmul, hf.CommSemigroup f mul with }
#align function.injective.non_unital_comm_ring Function.Injective.nonUnitalCommRing

/- warning: function.surjective.non_unital_comm_ring -> Function.Surjective.nonUnitalCommRing is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u}} {β : Type.{v}} [_inst_1 : NonUnitalCommRing.{u} α] [_inst_2 : Zero.{v} β] [_inst_3 : Add.{v} β] [_inst_4 : Mul.{v} β] [_inst_5 : Neg.{v} β] [_inst_6 : Sub.{v} β] [_inst_7 : HasSmul.{0, v} Nat β] [_inst_8 : HasSmul.{0, v} Int β] (f : α -> β), (Function.Surjective.{succ u, succ v} α β f) -> (Eq.{succ v} β (f (OfNat.ofNat.{u} α 0 (OfNat.mk.{u} α 0 (Zero.zero.{u} α (MulZeroClass.toHasZero.{u} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α (NonUnitalCommRing.toNonUnitalRing.{u} α _inst_1))))))))) (OfNat.ofNat.{v} β 0 (OfNat.mk.{v} β 0 (Zero.zero.{v} β _inst_2)))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toHasAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α (NonUnitalCommRing.toNonUnitalRing.{u} α _inst_1)))))) x y)) (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β _inst_3) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (Distrib.toHasMul.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α (NonUnitalCommRing.toNonUnitalRing.{u} α _inst_1)))))) x y)) (HMul.hMul.{v, v, v} β β β (instHMul.{v} β _inst_4) (f x) (f y))) -> (forall (x : α), Eq.{succ v} β (f (Neg.neg.{u} α (SubNegMonoid.toHasNeg.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α (NonUnitalCommRing.toNonUnitalRing.{u} α _inst_1)))))) x)) (Neg.neg.{v} β _inst_5 (f x))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HSub.hSub.{u, u, u} α α α (instHSub.{u} α (SubNegMonoid.toHasSub.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α (NonUnitalCommRing.toNonUnitalRing.{u} α _inst_1))))))) x y)) (HSub.hSub.{v, v, v} β β β (instHSub.{v} β _inst_6) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ v} β (f (HasSmul.smul.{0, u} Nat α (AddMonoid.hasSmulNat.{u} α (SubNegMonoid.toAddMonoid.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α (NonUnitalCommRing.toNonUnitalRing.{u} α _inst_1))))))) n x)) (HasSmul.smul.{0, v} Nat β _inst_7 n (f x))) -> (forall (x : α) (n : Int), Eq.{succ v} β (f (HasSmul.smul.{0, u} Int α (SubNegMonoid.hasSmulInt.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α (NonUnitalCommRing.toNonUnitalRing.{u} α _inst_1)))))) n x)) (HasSmul.smul.{0, v} Int β _inst_8 n (f x))) -> (NonUnitalCommRing.{v} β)
but is expected to have type
  forall {α : Type.{u}} {β : Type.{v}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5229 : NonUnitalCommRing.{u} α] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5235 : Zero.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5238 : Add.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5241 : Mul.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5244 : Neg.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5247 : Sub.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5250 : SMul.{0, v} Nat β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5256 : SMul.{0, v} Int β] (f : α -> β), (Function.Surjective.{succ u, succ v} α β f) -> (Eq.{succ v} β (f (OfNat.ofNat.{u} α 0 (Zero.toOfNat0.{u} α (SemigroupWithZero.toZero.{u} α (NonUnitalSemiring.toSemigroupWithZero.{u} α (NonUnitalRing.toNonUnitalSemiring.{u} α (NonUnitalCommRing.toNonUnitalRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5229))))))) (OfNat.ofNat.{v} β 0 (Zero.toOfNat0.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5235))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α (NonUnitalCommRing.toNonUnitalRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5229)))))) x y)) (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5238) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (NonUnitalNonAssocRing.toMul.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α (NonUnitalCommRing.toNonUnitalRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5229)))) x y)) (HMul.hMul.{v, v, v} β β β (instHMul.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5241) (f x) (f y))) -> (forall (x : α), Eq.{succ v} β (f (Neg.neg.{u} α (NegZeroClass.toNeg.{u} α (SubNegZeroMonoid.toNegZeroClass.{u} α (SubtractionMonoid.toSubNegZeroMonoid.{u} α (SubtractionCommMonoid.toSubtractionMonoid.{u} α (AddCommGroup.toSubtractionCommMonoid.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α (NonUnitalCommRing.toNonUnitalRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5229)))))))) x)) (Neg.neg.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5244 (f x))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HSub.hSub.{u, u, u} α α α (instHSub.{u} α (SubNegMonoid.toSub.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α (NonUnitalCommRing.toNonUnitalRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5229))))))) x y)) (HSub.hSub.{v, v, v} β β β (instHSub.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5247) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ v} β (f (HSMul.hSMul.{0, u, u} Nat α α (instHSMul.{0, u} Nat α (AddMonoid.SMul.{u} α (SubNegMonoid.toAddMonoid.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α (NonUnitalCommRing.toNonUnitalRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5229)))))))) n x)) (HSMul.hSMul.{0, v, v} Nat β β (instHSMul.{0, v} Nat β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5250) n (f x))) -> (forall (x : α) (n : Int), Eq.{succ v} β (f (HSMul.hSMul.{0, u, u} Int α α (instHSMul.{0, u} Int α (SubNegMonoid.SMulInt.{u} α (AddGroup.toSubNegMonoid.{u} α (AddCommGroup.toAddGroup.{u} α (NonUnitalNonAssocRing.toAddCommGroup.{u} α (NonUnitalRing.toNonUnitalNonAssocRing.{u} α (NonUnitalCommRing.toNonUnitalRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5229))))))) n x)) (HSMul.hSMul.{0, v, v} Int β β (instHSMul.{0, v} Int β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5256) n (f x))) -> (NonUnitalCommRing.{v} β)
Case conversion may be inaccurate. Consider using '#align function.surjective.non_unital_comm_ring Function.Surjective.nonUnitalCommRingₓ'. -/
/-- Pushforward a `non_unital_comm_ring` instance along a surjective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Surjective.nonUnitalCommRing [Zero β] [Add β] [Mul β] [Neg β] [Sub β]
    [HasSmul ℕ β] [HasSmul ℤ β] (f : α → β) (hf : Surjective f) (zero : f 0 = 0)
    (add : ∀ x y, f (x + y) = f x + f y) (mul : ∀ x y, f (x * y) = f x * f y)
    (neg : ∀ x, f (-x) = -f x) (sub : ∀ x y, f (x - y) = f x - f y)
    (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) (zsmul : ∀ (x) (n : ℤ), f (n • x) = n • f x) :
    NonUnitalCommRing β :=
  { hf.NonUnitalRing f zero add mul neg sub nsmul zsmul, hf.CommSemigroup f mul with }
#align function.surjective.non_unital_comm_ring Function.Surjective.nonUnitalCommRing

end NonUnitalCommRing

section CommRing

variable [CommRing α] {a b c : α}

/- warning: function.injective.comm_ring -> Function.Injective.commRing is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u}} {β : Type.{v}} [_inst_1 : CommRing.{u} α] [_inst_2 : Zero.{v} β] [_inst_3 : One.{v} β] [_inst_4 : Add.{v} β] [_inst_5 : Mul.{v} β] [_inst_6 : Neg.{v} β] [_inst_7 : Sub.{v} β] [_inst_8 : HasSmul.{0, v} Nat β] [_inst_9 : HasSmul.{0, v} Int β] [_inst_10 : Pow.{v, 0} β Nat] [_inst_11 : NatCast.{v} β] [_inst_12 : IntCast.{v} β] (f : β -> α), (Function.Injective.{succ v, succ u} β α f) -> (Eq.{succ u} α (f (OfNat.ofNat.{v} β 0 (OfNat.mk.{v} β 0 (Zero.zero.{v} β _inst_2)))) (OfNat.ofNat.{u} α 0 (OfNat.mk.{u} α 0 (Zero.zero.{u} α (MulZeroClass.toHasZero.{u} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α (NonAssocRing.toNonUnitalNonAssocRing.{u} α (Ring.toNonAssocRing.{u} α (CommRing.toRing.{u} α _inst_1)))))))))) -> (Eq.{succ u} α (f (OfNat.ofNat.{v} β 1 (OfNat.mk.{v} β 1 (One.one.{v} β _inst_3)))) (OfNat.ofNat.{u} α 1 (OfNat.mk.{u} α 1 (One.one.{u} α (AddMonoidWithOne.toOne.{u} α (AddGroupWithOne.toAddMonoidWithOne.{u} α (NonAssocRing.toAddGroupWithOne.{u} α (Ring.toNonAssocRing.{u} α (CommRing.toRing.{u} α _inst_1))))))))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β _inst_4) x y)) (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toHasAdd.{u} α (Ring.toDistrib.{u} α (CommRing.toRing.{u} α _inst_1)))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HMul.hMul.{v, v, v} β β β (instHMul.{v} β _inst_5) x y)) (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (Distrib.toHasMul.{u} α (Ring.toDistrib.{u} α (CommRing.toRing.{u} α _inst_1)))) (f x) (f y))) -> (forall (x : β), Eq.{succ u} α (f (Neg.neg.{v} β _inst_6 x)) (Neg.neg.{u} α (SubNegMonoid.toHasNeg.{u} α (AddGroup.toSubNegMonoid.{u} α (AddGroupWithOne.toAddGroup.{u} α (NonAssocRing.toAddGroupWithOne.{u} α (Ring.toNonAssocRing.{u} α (CommRing.toRing.{u} α _inst_1)))))) (f x))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HSub.hSub.{v, v, v} β β β (instHSub.{v} β _inst_7) x y)) (HSub.hSub.{u, u, u} α α α (instHSub.{u} α (SubNegMonoid.toHasSub.{u} α (AddGroup.toSubNegMonoid.{u} α (AddGroupWithOne.toAddGroup.{u} α (NonAssocRing.toAddGroupWithOne.{u} α (Ring.toNonAssocRing.{u} α (CommRing.toRing.{u} α _inst_1))))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u} α (f (HasSmul.smul.{0, v} Nat β _inst_8 n x)) (HasSmul.smul.{0, u} Nat α (AddMonoid.hasSmulNat.{u} α (AddMonoidWithOne.toAddMonoid.{u} α (AddGroupWithOne.toAddMonoidWithOne.{u} α (NonAssocRing.toAddGroupWithOne.{u} α (Ring.toNonAssocRing.{u} α (CommRing.toRing.{u} α _inst_1)))))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u} α (f (HasSmul.smul.{0, v} Int β _inst_9 n x)) (HasSmul.smul.{0, u} Int α (SubNegMonoid.hasSmulInt.{u} α (AddGroup.toSubNegMonoid.{u} α (AddGroupWithOne.toAddGroup.{u} α (NonAssocRing.toAddGroupWithOne.{u} α (Ring.toNonAssocRing.{u} α (CommRing.toRing.{u} α _inst_1)))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u} α (f (HPow.hPow.{v, 0, v} β Nat β (instHPow.{v, 0} β Nat _inst_10) x n)) (HPow.hPow.{u, 0, u} α Nat α (instHPow.{u, 0} α Nat (Monoid.hasPow.{u} α (Ring.toMonoid.{u} α (CommRing.toRing.{u} α _inst_1)))) (f x) n)) -> (forall (n : Nat), Eq.{succ u} α (f ((fun (a : Type) (b : Type.{v}) [self : HasLiftT.{1, succ v} a b] => self.0) Nat β (HasLiftT.mk.{1, succ v} Nat β (CoeTCₓ.coe.{1, succ v} Nat β (Nat.castCoe.{v} β _inst_11))) n)) ((fun (a : Type) (b : Type.{u}) [self : HasLiftT.{1, succ u} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u} Nat α (CoeTCₓ.coe.{1, succ u} Nat α (Nat.castCoe.{u} α (AddMonoidWithOne.toNatCast.{u} α (AddGroupWithOne.toAddMonoidWithOne.{u} α (NonAssocRing.toAddGroupWithOne.{u} α (Ring.toNonAssocRing.{u} α (CommRing.toRing.{u} α _inst_1)))))))) n)) -> (forall (n : Int), Eq.{succ u} α (f ((fun (a : Type) (b : Type.{v}) [self : HasLiftT.{1, succ v} a b] => self.0) Int β (HasLiftT.mk.{1, succ v} Int β (CoeTCₓ.coe.{1, succ v} Int β (Int.castCoe.{v} β _inst_12))) n)) ((fun (a : Type) (b : Type.{u}) [self : HasLiftT.{1, succ u} a b] => self.0) Int α (HasLiftT.mk.{1, succ u} Int α (CoeTCₓ.coe.{1, succ u} Int α (Int.castCoe.{u} α (AddGroupWithOne.toHasIntCast.{u} α (NonAssocRing.toAddGroupWithOne.{u} α (Ring.toNonAssocRing.{u} α (CommRing.toRing.{u} α _inst_1))))))) n)) -> (CommRing.{v} β)
but is expected to have type
  forall {α : Type.{u}} {β : Type.{v}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5455 : CommRing.{u} α] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5461 : Zero.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5464 : One.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5467 : Add.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5470 : Mul.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5473 : Neg.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5476 : Sub.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5479 : SMul.{0, v} Nat β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5485 : SMul.{0, v} Int β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5491 : Pow.{v, 0} β Nat] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5497 : NatCast.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5500 : IntCast.{v} β] (f : β -> α), (Function.Injective.{succ v, succ u} β α f) -> (Eq.{succ u} α (f (OfNat.ofNat.{v} β 0 (Zero.toOfNat0.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5461))) (OfNat.ofNat.{u} α 0 (Zero.toOfNat0.{u} α (CommMonoidWithZero.toZero.{u} α (CommSemiring.toCommMonoidWithZero.{u} α (CommRing.toCommSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5455)))))) -> (Eq.{succ u} α (f (OfNat.ofNat.{v} β 1 (One.toOfNat1.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5464))) (OfNat.ofNat.{u} α 1 (One.toOfNat1.{u} α (NonAssocRing.toOne.{u} α (Ring.toNonAssocRing.{u} α (CommRing.toRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5455)))))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5467) x y)) (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α (NonAssocRing.toNonUnitalNonAssocRing.{u} α (Ring.toNonAssocRing.{u} α (CommRing.toRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5455))))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HMul.hMul.{v, v, v} β β β (instHMul.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5470) x y)) (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (NonUnitalNonAssocRing.toMul.{u} α (NonAssocRing.toNonUnitalNonAssocRing.{u} α (Ring.toNonAssocRing.{u} α (CommRing.toRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5455))))) (f x) (f y))) -> (forall (x : β), Eq.{succ u} α (f (Neg.neg.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5473 x)) (Neg.neg.{u} α (Ring.toNeg.{u} α (CommRing.toRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5455)) (f x))) -> (forall (x : β) (y : β), Eq.{succ u} α (f (HSub.hSub.{v, v, v} β β β (instHSub.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5476) x y)) (HSub.hSub.{u, u, u} α α α (instHSub.{u} α (Ring.toSub.{u} α (CommRing.toRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5455))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u} α (f (HSMul.hSMul.{0, v, v} Nat β β (instHSMul.{0, v} Nat β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5479) n x)) (HSMul.hSMul.{0, u, u} Nat α α (instHSMul.{0, u} Nat α (AddMonoid.SMul.{u} α (AddMonoidWithOne.toAddMonoid.{u} α (AddGroupWithOne.toAddMonoidWithOne.{u} α (Ring.toAddGroupWithOne.{u} α (CommRing.toRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5455)))))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u} α (f (HSMul.hSMul.{0, v, v} Int β β (instHSMul.{0, v} Int β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5485) n x)) (HSMul.hSMul.{0, u, u} Int α α (instHSMul.{0, u} Int α (SubNegMonoid.SMulInt.{u} α (AddGroup.toSubNegMonoid.{u} α (AddGroupWithOne.toAddGroup.{u} α (Ring.toAddGroupWithOne.{u} α (CommRing.toRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5455)))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u} α (f (HPow.hPow.{v, 0, v} β Nat β (instHPow.{v, 0} β Nat inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5491) x n)) (HPow.hPow.{u, 0, u} α Nat α (instHPow.{u, 0} α Nat (Monoid.Pow.{u} α (MonoidWithZero.toMonoid.{u} α (Semiring.toMonoidWithZero.{u} α (Ring.toSemiring.{u} α (CommRing.toRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5455)))))) (f x) n)) -> (forall (n : Nat), Eq.{succ u} α (f (Nat.cast.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5497 n)) (Nat.cast.{u} α (NonAssocRing.toNatCast.{u} α (Ring.toNonAssocRing.{u} α (CommRing.toRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5455))) n)) -> (forall (n : Int), Eq.{succ u} α (f (Int.cast.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5500 n)) (Int.cast.{u} α (Ring.toIntCast.{u} α (CommRing.toRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5455)) n)) -> (CommRing.{v} β)
Case conversion may be inaccurate. Consider using '#align function.injective.comm_ring Function.Injective.commRingₓ'. -/
/-- Pullback a `comm_ring` instance along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.commRing [Zero β] [One β] [Add β] [Mul β] [Neg β] [Sub β]
    [HasSmul ℕ β] [HasSmul ℤ β] [Pow β ℕ] [NatCast β] [IntCast β] (f : β → α) (hf : Injective f)
    (zero : f 0 = 0) (one : f 1 = 1) (add : ∀ x y, f (x + y) = f x + f y)
    (mul : ∀ x y, f (x * y) = f x * f y) (neg : ∀ x, f (-x) = -f x)
    (sub : ∀ x y, f (x - y) = f x - f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x)
    (zsmul : ∀ (x) (n : ℤ), f (n • x) = n • f x) (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n)
    (nat_cast : ∀ n : ℕ, f n = n) (int_cast : ∀ n : ℤ, f n = n) : CommRing β :=
  { hf.Ring f zero one add mul neg sub nsmul zsmul npow nat_cast int_cast,
    hf.CommSemigroup f mul with }
#align function.injective.comm_ring Function.Injective.commRing

/- warning: function.surjective.comm_ring -> Function.Surjective.commRing is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u}} {β : Type.{v}} [_inst_1 : CommRing.{u} α] [_inst_2 : Zero.{v} β] [_inst_3 : One.{v} β] [_inst_4 : Add.{v} β] [_inst_5 : Mul.{v} β] [_inst_6 : Neg.{v} β] [_inst_7 : Sub.{v} β] [_inst_8 : HasSmul.{0, v} Nat β] [_inst_9 : HasSmul.{0, v} Int β] [_inst_10 : Pow.{v, 0} β Nat] [_inst_11 : NatCast.{v} β] [_inst_12 : IntCast.{v} β] (f : α -> β), (Function.Surjective.{succ u, succ v} α β f) -> (Eq.{succ v} β (f (OfNat.ofNat.{u} α 0 (OfNat.mk.{u} α 0 (Zero.zero.{u} α (MulZeroClass.toHasZero.{u} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α (NonAssocRing.toNonUnitalNonAssocRing.{u} α (Ring.toNonAssocRing.{u} α (CommRing.toRing.{u} α _inst_1)))))))))) (OfNat.ofNat.{v} β 0 (OfNat.mk.{v} β 0 (Zero.zero.{v} β _inst_2)))) -> (Eq.{succ v} β (f (OfNat.ofNat.{u} α 1 (OfNat.mk.{u} α 1 (One.one.{u} α (AddMonoidWithOne.toOne.{u} α (AddGroupWithOne.toAddMonoidWithOne.{u} α (NonAssocRing.toAddGroupWithOne.{u} α (Ring.toNonAssocRing.{u} α (CommRing.toRing.{u} α _inst_1))))))))) (OfNat.ofNat.{v} β 1 (OfNat.mk.{v} β 1 (One.one.{v} β _inst_3)))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toHasAdd.{u} α (Ring.toDistrib.{u} α (CommRing.toRing.{u} α _inst_1)))) x y)) (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β _inst_4) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (Distrib.toHasMul.{u} α (Ring.toDistrib.{u} α (CommRing.toRing.{u} α _inst_1)))) x y)) (HMul.hMul.{v, v, v} β β β (instHMul.{v} β _inst_5) (f x) (f y))) -> (forall (x : α), Eq.{succ v} β (f (Neg.neg.{u} α (SubNegMonoid.toHasNeg.{u} α (AddGroup.toSubNegMonoid.{u} α (AddGroupWithOne.toAddGroup.{u} α (NonAssocRing.toAddGroupWithOne.{u} α (Ring.toNonAssocRing.{u} α (CommRing.toRing.{u} α _inst_1)))))) x)) (Neg.neg.{v} β _inst_6 (f x))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HSub.hSub.{u, u, u} α α α (instHSub.{u} α (SubNegMonoid.toHasSub.{u} α (AddGroup.toSubNegMonoid.{u} α (AddGroupWithOne.toAddGroup.{u} α (NonAssocRing.toAddGroupWithOne.{u} α (Ring.toNonAssocRing.{u} α (CommRing.toRing.{u} α _inst_1))))))) x y)) (HSub.hSub.{v, v, v} β β β (instHSub.{v} β _inst_7) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ v} β (f (HasSmul.smul.{0, u} Nat α (AddMonoid.hasSmulNat.{u} α (AddMonoidWithOne.toAddMonoid.{u} α (AddGroupWithOne.toAddMonoidWithOne.{u} α (NonAssocRing.toAddGroupWithOne.{u} α (Ring.toNonAssocRing.{u} α (CommRing.toRing.{u} α _inst_1)))))) n x)) (HasSmul.smul.{0, v} Nat β _inst_8 n (f x))) -> (forall (x : α) (n : Int), Eq.{succ v} β (f (HasSmul.smul.{0, u} Int α (SubNegMonoid.hasSmulInt.{u} α (AddGroup.toSubNegMonoid.{u} α (AddGroupWithOne.toAddGroup.{u} α (NonAssocRing.toAddGroupWithOne.{u} α (Ring.toNonAssocRing.{u} α (CommRing.toRing.{u} α _inst_1)))))) n x)) (HasSmul.smul.{0, v} Int β _inst_9 n (f x))) -> (forall (x : α) (n : Nat), Eq.{succ v} β (f (HPow.hPow.{u, 0, u} α Nat α (instHPow.{u, 0} α Nat (Monoid.hasPow.{u} α (Ring.toMonoid.{u} α (CommRing.toRing.{u} α _inst_1)))) x n)) (HPow.hPow.{v, 0, v} β Nat β (instHPow.{v, 0} β Nat _inst_10) (f x) n)) -> (forall (n : Nat), Eq.{succ v} β (f ((fun (a : Type) (b : Type.{u}) [self : HasLiftT.{1, succ u} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u} Nat α (CoeTCₓ.coe.{1, succ u} Nat α (Nat.castCoe.{u} α (AddMonoidWithOne.toNatCast.{u} α (AddGroupWithOne.toAddMonoidWithOne.{u} α (NonAssocRing.toAddGroupWithOne.{u} α (Ring.toNonAssocRing.{u} α (CommRing.toRing.{u} α _inst_1)))))))) n)) ((fun (a : Type) (b : Type.{v}) [self : HasLiftT.{1, succ v} a b] => self.0) Nat β (HasLiftT.mk.{1, succ v} Nat β (CoeTCₓ.coe.{1, succ v} Nat β (Nat.castCoe.{v} β _inst_11))) n)) -> (forall (n : Int), Eq.{succ v} β (f ((fun (a : Type) (b : Type.{u}) [self : HasLiftT.{1, succ u} a b] => self.0) Int α (HasLiftT.mk.{1, succ u} Int α (CoeTCₓ.coe.{1, succ u} Int α (Int.castCoe.{u} α (AddGroupWithOne.toHasIntCast.{u} α (NonAssocRing.toAddGroupWithOne.{u} α (Ring.toNonAssocRing.{u} α (CommRing.toRing.{u} α _inst_1))))))) n)) ((fun (a : Type) (b : Type.{v}) [self : HasLiftT.{1, succ v} a b] => self.0) Int β (HasLiftT.mk.{1, succ v} Int β (CoeTCₓ.coe.{1, succ v} Int β (Int.castCoe.{v} β _inst_12))) n)) -> (CommRing.{v} β)
but is expected to have type
  forall {α : Type.{u}} {β : Type.{v}} [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5746 : CommRing.{u} α] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5752 : Zero.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5755 : One.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5758 : Add.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5761 : Mul.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5764 : Neg.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5767 : Sub.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5770 : SMul.{0, v} Nat β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5776 : SMul.{0, v} Int β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5782 : Pow.{v, 0} β Nat] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5788 : NatCast.{v} β] [inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5791 : IntCast.{v} β] (f : α -> β), (Function.Surjective.{succ u, succ v} α β f) -> (Eq.{succ v} β (f (OfNat.ofNat.{u} α 0 (Zero.toOfNat0.{u} α (CommMonoidWithZero.toZero.{u} α (CommSemiring.toCommMonoidWithZero.{u} α (CommRing.toCommSemiring.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5746)))))) (OfNat.ofNat.{v} β 0 (Zero.toOfNat0.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5752))) -> (Eq.{succ v} β (f (OfNat.ofNat.{u} α 1 (One.toOfNat1.{u} α (NonAssocRing.toOne.{u} α (Ring.toNonAssocRing.{u} α (CommRing.toRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5746)))))) (OfNat.ofNat.{v} β 1 (One.toOfNat1.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5755))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HAdd.hAdd.{u, u, u} α α α (instHAdd.{u} α (Distrib.toAdd.{u} α (NonUnitalNonAssocSemiring.toDistrib.{u} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u} α (NonAssocRing.toNonUnitalNonAssocRing.{u} α (Ring.toNonAssocRing.{u} α (CommRing.toRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5746))))))) x y)) (HAdd.hAdd.{v, v, v} β β β (instHAdd.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5758) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HMul.hMul.{u, u, u} α α α (instHMul.{u} α (NonUnitalNonAssocRing.toMul.{u} α (NonAssocRing.toNonUnitalNonAssocRing.{u} α (Ring.toNonAssocRing.{u} α (CommRing.toRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5746))))) x y)) (HMul.hMul.{v, v, v} β β β (instHMul.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5761) (f x) (f y))) -> (forall (x : α), Eq.{succ v} β (f (Neg.neg.{u} α (Ring.toNeg.{u} α (CommRing.toRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5746)) x)) (Neg.neg.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5764 (f x))) -> (forall (x : α) (y : α), Eq.{succ v} β (f (HSub.hSub.{u, u, u} α α α (instHSub.{u} α (Ring.toSub.{u} α (CommRing.toRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5746))) x y)) (HSub.hSub.{v, v, v} β β β (instHSub.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5767) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ v} β (f (HSMul.hSMul.{0, u, u} Nat α α (instHSMul.{0, u} Nat α (AddMonoid.SMul.{u} α (AddMonoidWithOne.toAddMonoid.{u} α (AddGroupWithOne.toAddMonoidWithOne.{u} α (Ring.toAddGroupWithOne.{u} α (CommRing.toRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5746)))))) n x)) (HSMul.hSMul.{0, v, v} Nat β β (instHSMul.{0, v} Nat β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5770) n (f x))) -> (forall (x : α) (n : Int), Eq.{succ v} β (f (HSMul.hSMul.{0, u, u} Int α α (instHSMul.{0, u} Int α (SubNegMonoid.SMulInt.{u} α (AddGroup.toSubNegMonoid.{u} α (AddGroupWithOne.toAddGroup.{u} α (Ring.toAddGroupWithOne.{u} α (CommRing.toRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5746)))))) n x)) (HSMul.hSMul.{0, v, v} Int β β (instHSMul.{0, v} Int β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5776) n (f x))) -> (forall (x : α) (n : Nat), Eq.{succ v} β (f (HPow.hPow.{u, 0, u} α Nat α (instHPow.{u, 0} α Nat (Monoid.Pow.{u} α (MonoidWithZero.toMonoid.{u} α (Semiring.toMonoidWithZero.{u} α (Ring.toSemiring.{u} α (CommRing.toRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5746)))))) x n)) (HPow.hPow.{v, 0, v} β Nat β (instHPow.{v, 0} β Nat inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5782) (f x) n)) -> (forall (n : Nat), Eq.{succ v} β (f (Nat.cast.{u} α (NonAssocRing.toNatCast.{u} α (Ring.toNonAssocRing.{u} α (CommRing.toRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5746))) n)) (Nat.cast.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5788 n)) -> (forall (n : Int), Eq.{succ v} β (f (Int.cast.{u} α (Ring.toIntCast.{u} α (CommRing.toRing.{u} α inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5746)) n)) (Int.cast.{v} β inst._@.Mathlib.Algebra.Ring.InjSurj._hyg.5791 n)) -> (CommRing.{v} β)
Case conversion may be inaccurate. Consider using '#align function.surjective.comm_ring Function.Surjective.commRingₓ'. -/
/-- Pushforward a `comm_ring` instance along a surjective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Surjective.commRing [Zero β] [One β] [Add β] [Mul β] [Neg β] [Sub β]
    [HasSmul ℕ β] [HasSmul ℤ β] [Pow β ℕ] [NatCast β] [IntCast β] (f : α → β) (hf : Surjective f)
    (zero : f 0 = 0) (one : f 1 = 1) (add : ∀ x y, f (x + y) = f x + f y)
    (mul : ∀ x y, f (x * y) = f x * f y) (neg : ∀ x, f (-x) = -f x)
    (sub : ∀ x y, f (x - y) = f x - f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x)
    (zsmul : ∀ (x) (n : ℤ), f (n • x) = n • f x) (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n)
    (nat_cast : ∀ n : ℕ, f n = n) (int_cast : ∀ n : ℤ, f n = n) : CommRing β :=
  { hf.Ring f zero one add mul neg sub nsmul zsmul npow nat_cast int_cast,
    hf.CommSemigroup f mul with }
#align function.surjective.comm_ring Function.Surjective.commRing

end CommRing

