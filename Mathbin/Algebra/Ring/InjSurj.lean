/-
Copyright (c) 2014 Jeremy Avigad. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jeremy Avigad, Leonardo de Moura, Floris van Doorn, Yury Kudryashov, Neil Strickland

! This file was ported from Lean 3 source module algebra.ring.inj_surj
! leanprover-community/mathlib commit f7fc89d5d5ff1db2d1242c7bb0e9062ce47ef47c
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Ring.Defs
import Mathbin.Algebra.Opposites
import Mathbin.Algebra.GroupWithZero.InjSurj

/-!
# Pulling back rings along injective maps, and pushing them forward along surjective maps.

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.
-/


universe u v w x

variable {α : Type u} {β : Type v} {γ : Type w} {R : Type x}

open Function

/-!
### `distrib` class
-/


/- warning: function.injective.distrib -> Function.Injective.distrib is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Distrib.{u2} S] (f : R -> S), (Function.Injective.{succ u1, succ u2} R S f) -> (forall (x : R) (y : R), Eq.{succ u2} S (f (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R _inst_2) x y)) (HAdd.hAdd.{u2, u2, u2} S S S (instHAdd.{u2} S (Distrib.toHasAdd.{u2} S _inst_3)) (f x) (f y))) -> (forall (x : R) (y : R), Eq.{succ u2} S (f (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R _inst_1) x y)) (HMul.hMul.{u2, u2, u2} S S S (instHMul.{u2} S (Distrib.toHasMul.{u2} S _inst_3)) (f x) (f y))) -> (Distrib.{u1} R)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Distrib.{u2} S] (f : R -> S), (Function.Injective.{succ u1, succ u2} R S f) -> (forall (x : R) (y : R), Eq.{succ u2} S (f (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R _inst_2) x y)) (HAdd.hAdd.{u2, u2, u2} S S S (instHAdd.{u2} S (Distrib.toAdd.{u2} S _inst_3)) (f x) (f y))) -> (forall (x : R) (y : R), Eq.{succ u2} S (f (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R _inst_1) x y)) (HMul.hMul.{u2, u2, u2} S S S (instHMul.{u2} S (Distrib.toMul.{u2} S _inst_3)) (f x) (f y))) -> (Distrib.{u1} R)
Case conversion may be inaccurate. Consider using '#align function.injective.distrib Function.Injective.distribₓ'. -/
/-- Pullback a `distrib` instance along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.distrib {S} [Mul R] [Add R] [Distrib S] (f : R → S)
    (hf : Injective f) (add : ∀ x y, f (x + y) = f x + f y) (mul : ∀ x y, f (x * y) = f x * f y) :
    Distrib R where
  mul := (· * ·)
  add := (· + ·)
  left_distrib x y z := hf <| by simp only [*, left_distrib]
  right_distrib x y z := hf <| by simp only [*, right_distrib]
#align function.injective.distrib Function.Injective.distrib

/- warning: function.surjective.distrib -> Function.Surjective.distrib is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Distrib.{u1} R] [_inst_2 : Add.{u2} S] [_inst_3 : Mul.{u2} S] (f : R -> S), (Function.Surjective.{succ u1, succ u2} R S f) -> (forall (x : R) (y : R), Eq.{succ u2} S (f (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R _inst_1)) x y)) (HAdd.hAdd.{u2, u2, u2} S S S (instHAdd.{u2} S _inst_2) (f x) (f y))) -> (forall (x : R) (y : R), Eq.{succ u2} S (f (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R _inst_1)) x y)) (HMul.hMul.{u2, u2, u2} S S S (instHMul.{u2} S _inst_3) (f x) (f y))) -> (Distrib.{u2} S)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Distrib.{u1} R] [_inst_2 : Add.{u2} S] [_inst_3 : Mul.{u2} S] (f : R -> S), (Function.Surjective.{succ u1, succ u2} R S f) -> (forall (x : R) (y : R), Eq.{succ u2} S (f (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R _inst_1)) x y)) (HAdd.hAdd.{u2, u2, u2} S S S (instHAdd.{u2} S _inst_2) (f x) (f y))) -> (forall (x : R) (y : R), Eq.{succ u2} S (f (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toMul.{u1} R _inst_1)) x y)) (HMul.hMul.{u2, u2, u2} S S S (instHMul.{u2} S _inst_3) (f x) (f y))) -> (Distrib.{u2} S)
Case conversion may be inaccurate. Consider using '#align function.surjective.distrib Function.Surjective.distribₓ'. -/
/-- Pushforward a `distrib` instance along a surjective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Surjective.distrib {S} [Distrib R] [Add S] [Mul S] (f : R → S)
    (hf : Surjective f) (add : ∀ x y, f (x + y) = f x + f y) (mul : ∀ x y, f (x * y) = f x * f y) :
    Distrib S where
  mul := (· * ·)
  add := (· + ·)
  left_distrib := hf.forall₃.2 fun x y z => by simp only [← add, ← mul, left_distrib]
  right_distrib := hf.forall₃.2 fun x y z => by simp only [← add, ← mul, right_distrib]
#align function.surjective.distrib Function.Surjective.distrib

section InjectiveSurjectiveMaps

/-!
### Semirings
-/


variable [Zero β] [Add β] [Mul β] [SMul ℕ β]

/- warning: function.injective.non_unital_non_assoc_semiring -> Function.Injective.nonUnitalNonAssocSemiring is a dubious translation:
lean 3 declaration is
  forall {β : Type.{u2}} [_inst_1 : Zero.{u2} β] [_inst_2 : Add.{u2} β] [_inst_3 : Mul.{u2} β] [_inst_4 : SMul.{0, u2} Nat β] {α : Type.{u1}} [_inst_5 : NonUnitalNonAssocSemiring.{u1} α] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β _inst_1)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α _inst_5)))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_2) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α _inst_5))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_3) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α _inst_5))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (SMul.smul.{0, u2} Nat β _inst_4 n x)) (SMul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_5))) n (f x))) -> (NonUnitalNonAssocSemiring.{u2} β)
but is expected to have type
  forall {β : Type.{u2}} [_inst_1 : Zero.{u2} β] [_inst_2 : Add.{u2} β] [_inst_3 : Mul.{u2} β] [_inst_4 : SMul.{0, u2} Nat β] {α : Type.{u1}} [_inst_5 : NonUnitalNonAssocSemiring.{u1} α] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β _inst_1))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (MulZeroClass.toZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α _inst_5))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_2) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α _inst_5))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_3) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocSemiring.toMul.{u1} α _inst_5)) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Nat β β (instHSMul.{0, u2} Nat β _inst_4) n x)) (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_5)))) n (f x))) -> (NonUnitalNonAssocSemiring.{u2} β)
Case conversion may be inaccurate. Consider using '#align function.injective.non_unital_non_assoc_semiring Function.Injective.nonUnitalNonAssocSemiringₓ'. -/
/-- Pullback a `non_unital_non_assoc_semiring` instance along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.nonUnitalNonAssocSemiring {α : Type u}
    [NonUnitalNonAssocSemiring α] (f : β → α) (hf : Injective f) (zero : f 0 = 0)
    (add : ∀ x y, f (x + y) = f x + f y) (mul : ∀ x y, f (x * y) = f x * f y)
    (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) : NonUnitalNonAssocSemiring β :=
  { hf.MulZeroClass f zero mul, hf.AddCommMonoid f zero add nsmul, hf.Distrib f add mul with }
#align function.injective.non_unital_non_assoc_semiring Function.Injective.nonUnitalNonAssocSemiring

/- warning: function.injective.non_unital_semiring -> Function.Injective.nonUnitalSemiring is a dubious translation:
lean 3 declaration is
  forall {β : Type.{u2}} [_inst_1 : Zero.{u2} β] [_inst_2 : Add.{u2} β] [_inst_3 : Mul.{u2} β] [_inst_4 : SMul.{0, u2} Nat β] {α : Type.{u1}} [_inst_5 : NonUnitalSemiring.{u1} α] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β _inst_1)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_5))))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_2) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_5)))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_3) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_5)))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (SMul.smul.{0, u2} Nat β _inst_4 n x)) (SMul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_5)))) n (f x))) -> (NonUnitalSemiring.{u2} β)
but is expected to have type
  forall {β : Type.{u2}} [_inst_1 : Zero.{u2} β] [_inst_2 : Add.{u2} β] [_inst_3 : Mul.{u2} β] [_inst_4 : SMul.{0, u2} Nat β] {α : Type.{u1}} [_inst_5 : NonUnitalSemiring.{u1} α] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β _inst_1))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (SemigroupWithZero.toZero.{u1} α (NonUnitalSemiring.toSemigroupWithZero.{u1} α _inst_5))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_2) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_5)))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_3) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_5))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Nat β β (instHSMul.{0, u2} Nat β _inst_4) n x)) (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_5))))) n (f x))) -> (NonUnitalSemiring.{u2} β)
Case conversion may be inaccurate. Consider using '#align function.injective.non_unital_semiring Function.Injective.nonUnitalSemiringₓ'. -/
/-- Pullback a `non_unital_semiring` instance along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.nonUnitalSemiring {α : Type u} [NonUnitalSemiring α] (f : β → α)
    (hf : Injective f) (zero : f 0 = 0) (add : ∀ x y, f (x + y) = f x + f y)
    (mul : ∀ x y, f (x * y) = f x * f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) :
    NonUnitalSemiring β :=
  { hf.NonUnitalNonAssocSemiring f zero add mul nsmul, hf.SemigroupWithZero f zero mul with }
#align function.injective.non_unital_semiring Function.Injective.nonUnitalSemiring

/- warning: function.injective.non_assoc_semiring -> Function.Injective.nonAssocSemiring is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_5 : NonAssocSemiring.{u1} α] {β : Type.{u2}} [_inst_6 : Zero.{u2} β] [_inst_7 : One.{u2} β] [_inst_8 : Mul.{u2} β] [_inst_9 : Add.{u2} β] [_inst_10 : SMul.{0, u2} Nat β] [_inst_11 : NatCast.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β _inst_6)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_5))))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β _inst_7)))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_5))))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_9) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_5)))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_8) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_5)))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (SMul.smul.{0, u2} Nat β _inst_10 n x)) (SMul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_5)))) n (f x))) -> (forall (n : Nat), Eq.{succ u1} α (f ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat β (HasLiftT.mk.{1, succ u2} Nat β (CoeTCₓ.coe.{1, succ u2} Nat β (Nat.castCoe.{u2} β _inst_11))) n)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u1} Nat α (CoeTCₓ.coe.{1, succ u1} Nat α (Nat.castCoe.{u1} α (AddMonoidWithOne.toNatCast.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_5)))))) n)) -> (NonAssocSemiring.{u2} β)
but is expected to have type
  forall {α : Type.{u1}} [_inst_5 : NonAssocSemiring.{u1} α] {β : Type.{u2}} [_inst_6 : Zero.{u2} β] [_inst_7 : One.{u2} β] [_inst_8 : Mul.{u2} β] [_inst_9 : Add.{u2} β] [_inst_10 : SMul.{0, u2} Nat β] [_inst_11 : NatCast.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β _inst_6))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (MulZeroOneClass.toZero.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_5))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β _inst_7))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (NonAssocSemiring.toOne.{u1} α _inst_5)))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_9) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_5)))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_8) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_5))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Nat β β (instHSMul.{0, u2} Nat β _inst_10) n x)) (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_5))))) n (f x))) -> (forall (n : Nat), Eq.{succ u1} α (f (Nat.cast.{u2} β _inst_11 n)) (Nat.cast.{u1} α (NonAssocSemiring.toNatCast.{u1} α _inst_5) n)) -> (NonAssocSemiring.{u2} β)
Case conversion may be inaccurate. Consider using '#align function.injective.non_assoc_semiring Function.Injective.nonAssocSemiringₓ'. -/
/-- Pullback a `non_assoc_semiring` instance along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.nonAssocSemiring {α : Type u} [NonAssocSemiring α] {β : Type v}
    [Zero β] [One β] [Mul β] [Add β] [SMul ℕ β] [NatCast β] (f : β → α) (hf : Injective f)
    (zero : f 0 = 0) (one : f 1 = 1) (add : ∀ x y, f (x + y) = f x + f y)
    (mul : ∀ x y, f (x * y) = f x * f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x)
    (nat_cast : ∀ n : ℕ, f n = n) : NonAssocSemiring β :=
  { hf.AddMonoidWithOne f zero one add nsmul nat_cast,
    hf.NonUnitalNonAssocSemiring f zero add mul nsmul, hf.MulOneClass f one mul with }
#align function.injective.non_assoc_semiring Function.Injective.nonAssocSemiring

/- warning: function.injective.semiring -> Function.Injective.semiring is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_5 : Semiring.{u1} α] {β : Type.{u2}} [_inst_6 : Zero.{u2} β] [_inst_7 : One.{u2} β] [_inst_8 : Add.{u2} β] [_inst_9 : Mul.{u2} β] [_inst_10 : Pow.{u2, 0} β Nat] [_inst_11 : SMul.{0, u2} Nat β] [_inst_12 : NatCast.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β _inst_6)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_5)))))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β _inst_7)))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_5)))))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_8) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_5))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_9) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_5))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (SMul.smul.{0, u2} Nat β _inst_11 n x)) (SMul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_5))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_10) x n)) (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (MonoidWithZero.toMonoid.{u1} α (Semiring.toMonoidWithZero.{u1} α _inst_5)))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} α (f ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat β (HasLiftT.mk.{1, succ u2} Nat β (CoeTCₓ.coe.{1, succ u2} Nat β (Nat.castCoe.{u2} β _inst_12))) n)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u1} Nat α (CoeTCₓ.coe.{1, succ u1} Nat α (Nat.castCoe.{u1} α (AddMonoidWithOne.toNatCast.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_5))))))) n)) -> (Semiring.{u2} β)
but is expected to have type
  forall {α : Type.{u1}} [_inst_5 : Semiring.{u1} α] {β : Type.{u2}} [_inst_6 : Zero.{u2} β] [_inst_7 : One.{u2} β] [_inst_8 : Add.{u2} β] [_inst_9 : Mul.{u2} β] [_inst_10 : Pow.{u2, 0} β Nat] [_inst_11 : SMul.{0, u2} Nat β] [_inst_12 : NatCast.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β _inst_6))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α _inst_5))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β _inst_7))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (Semiring.toOne.{u1} α _inst_5)))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_8) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_5))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_9) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_5)))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Nat β β (instHSMul.{0, u2} Nat β _inst_11) n x)) (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_5)))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_10) x n)) (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (MonoidWithZero.toMonoid.{u1} α (Semiring.toMonoidWithZero.{u1} α _inst_5)))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} α (f (Nat.cast.{u2} β _inst_12 n)) (Nat.cast.{u1} α (Semiring.toNatCast.{u1} α _inst_5) n)) -> (Semiring.{u2} β)
Case conversion may be inaccurate. Consider using '#align function.injective.semiring Function.Injective.semiringₓ'. -/
/-- Pullback a `semiring` instance along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.semiring {α : Type u} [Semiring α] {β : Type v} [Zero β] [One β]
    [Add β] [Mul β] [Pow β ℕ] [SMul ℕ β] [NatCast β] (f : β → α) (hf : Injective f) (zero : f 0 = 0)
    (one : f 1 = 1) (add : ∀ x y, f (x + y) = f x + f y) (mul : ∀ x y, f (x * y) = f x * f y)
    (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n)
    (nat_cast : ∀ n : ℕ, f n = n) : Semiring β :=
  { hf.NonAssocSemiring f zero one add mul nsmul nat_cast, hf.MonoidWithZero f zero one mul npow,
    hf.Distrib f add mul with }
#align function.injective.semiring Function.Injective.semiring

/- warning: function.surjective.non_unital_non_assoc_semiring -> Function.Surjective.nonUnitalNonAssocSemiring is a dubious translation:
lean 3 declaration is
  forall {β : Type.{u2}} [_inst_1 : Zero.{u2} β] [_inst_2 : Add.{u2} β] [_inst_3 : Mul.{u2} β] [_inst_4 : SMul.{0, u2} Nat β] {α : Type.{u1}} [_inst_5 : NonUnitalNonAssocSemiring.{u1} α] (f : α -> β), (Function.Surjective.{succ u1, succ u2} α β f) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α _inst_5)))))) (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β _inst_1)))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α _inst_5))) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_2) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α _inst_5))) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_3) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ u2} β (f (SMul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_5))) n x)) (SMul.smul.{0, u2} Nat β _inst_4 n (f x))) -> (NonUnitalNonAssocSemiring.{u2} β)
but is expected to have type
  forall {β : Type.{u2}} [_inst_1 : Zero.{u2} β] [_inst_2 : Add.{u2} β] [_inst_3 : Mul.{u2} β] [_inst_4 : SMul.{0, u2} Nat β] {α : Type.{u1}} [_inst_5 : NonUnitalNonAssocSemiring.{u1} α] (f : α -> β), (Function.Surjective.{succ u1, succ u2} α β f) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (MulZeroClass.toZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α _inst_5))))) (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β _inst_1))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α _inst_5))) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_2) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocSemiring.toMul.{u1} α _inst_5)) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_3) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ u2} β (f (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_5)))) n x)) (HSMul.hSMul.{0, u2, u2} Nat β β (instHSMul.{0, u2} Nat β _inst_4) n (f x))) -> (NonUnitalNonAssocSemiring.{u2} β)
Case conversion may be inaccurate. Consider using '#align function.surjective.non_unital_non_assoc_semiring Function.Surjective.nonUnitalNonAssocSemiringₓ'. -/
/-- Pushforward a `non_unital_non_assoc_semiring` instance along a surjective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Surjective.nonUnitalNonAssocSemiring {α : Type u}
    [NonUnitalNonAssocSemiring α] (f : α → β) (hf : Surjective f) (zero : f 0 = 0)
    (add : ∀ x y, f (x + y) = f x + f y) (mul : ∀ x y, f (x * y) = f x * f y)
    (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) : NonUnitalNonAssocSemiring β :=
  { hf.MulZeroClass f zero mul, hf.AddCommMonoid f zero add nsmul, hf.Distrib f add mul with }
#align function.surjective.non_unital_non_assoc_semiring Function.Surjective.nonUnitalNonAssocSemiring

/- warning: function.surjective.non_unital_semiring -> Function.Surjective.nonUnitalSemiring is a dubious translation:
lean 3 declaration is
  forall {β : Type.{u2}} [_inst_1 : Zero.{u2} β] [_inst_2 : Add.{u2} β] [_inst_3 : Mul.{u2} β] [_inst_4 : SMul.{0, u2} Nat β] {α : Type.{u1}} [_inst_5 : NonUnitalSemiring.{u1} α] (f : α -> β), (Function.Surjective.{succ u1, succ u2} α β f) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_5))))))) (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β _inst_1)))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_5)))) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_2) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_5)))) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_3) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ u2} β (f (SMul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_5)))) n x)) (SMul.smul.{0, u2} Nat β _inst_4 n (f x))) -> (NonUnitalSemiring.{u2} β)
but is expected to have type
  forall {β : Type.{u2}} [_inst_1 : Zero.{u2} β] [_inst_2 : Add.{u2} β] [_inst_3 : Mul.{u2} β] [_inst_4 : SMul.{0, u2} Nat β] {α : Type.{u1}} [_inst_5 : NonUnitalSemiring.{u1} α] (f : α -> β), (Function.Surjective.{succ u1, succ u2} α β f) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (SemigroupWithZero.toZero.{u1} α (NonUnitalSemiring.toSemigroupWithZero.{u1} α _inst_5))))) (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β _inst_1))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_5)))) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_2) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_5))) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_3) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ u2} β (f (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_5))))) n x)) (HSMul.hSMul.{0, u2, u2} Nat β β (instHSMul.{0, u2} Nat β _inst_4) n (f x))) -> (NonUnitalSemiring.{u2} β)
Case conversion may be inaccurate. Consider using '#align function.surjective.non_unital_semiring Function.Surjective.nonUnitalSemiringₓ'. -/
/-- Pushforward a `non_unital_semiring` instance along a surjective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Surjective.nonUnitalSemiring {α : Type u} [NonUnitalSemiring α] (f : α → β)
    (hf : Surjective f) (zero : f 0 = 0) (add : ∀ x y, f (x + y) = f x + f y)
    (mul : ∀ x y, f (x * y) = f x * f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) :
    NonUnitalSemiring β :=
  { hf.NonUnitalNonAssocSemiring f zero add mul nsmul, hf.SemigroupWithZero f zero mul with }
#align function.surjective.non_unital_semiring Function.Surjective.nonUnitalSemiring

/- warning: function.surjective.non_assoc_semiring -> Function.Surjective.nonAssocSemiring is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_5 : NonAssocSemiring.{u1} α] {β : Type.{u2}} [_inst_6 : Zero.{u2} β] [_inst_7 : One.{u2} β] [_inst_8 : Add.{u2} β] [_inst_9 : Mul.{u2} β] [_inst_10 : SMul.{0, u2} Nat β] [_inst_11 : NatCast.{u2} β] (f : α -> β), (Function.Surjective.{succ u1, succ u2} α β f) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_5))))))) (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β _inst_6)))) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_5))))))) (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β _inst_7)))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_5)))) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_8) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_5)))) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_9) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ u2} β (f (SMul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_5)))) n x)) (SMul.smul.{0, u2} Nat β _inst_10 n (f x))) -> (forall (n : Nat), Eq.{succ u2} β (f ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u1} Nat α (CoeTCₓ.coe.{1, succ u1} Nat α (Nat.castCoe.{u1} α (AddMonoidWithOne.toNatCast.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_5)))))) n)) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat β (HasLiftT.mk.{1, succ u2} Nat β (CoeTCₓ.coe.{1, succ u2} Nat β (Nat.castCoe.{u2} β _inst_11))) n)) -> (NonAssocSemiring.{u2} β)
but is expected to have type
  forall {α : Type.{u1}} [_inst_5 : NonAssocSemiring.{u1} α] {β : Type.{u2}} [_inst_6 : Zero.{u2} β] [_inst_7 : One.{u2} β] [_inst_8 : Add.{u2} β] [_inst_9 : Mul.{u2} β] [_inst_10 : SMul.{0, u2} Nat β] [_inst_11 : NatCast.{u2} β] (f : α -> β), (Function.Surjective.{succ u1, succ u2} α β f) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (MulZeroOneClass.toZero.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_5))))) (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β _inst_6))) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (NonAssocSemiring.toOne.{u1} α _inst_5)))) (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β _inst_7))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_5)))) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_8) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_5))) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_9) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ u2} β (f (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_5))))) n x)) (HSMul.hSMul.{0, u2, u2} Nat β β (instHSMul.{0, u2} Nat β _inst_10) n (f x))) -> (forall (n : Nat), Eq.{succ u2} β (f (Nat.cast.{u1} α (NonAssocSemiring.toNatCast.{u1} α _inst_5) n)) (Nat.cast.{u2} β _inst_11 n)) -> (NonAssocSemiring.{u2} β)
Case conversion may be inaccurate. Consider using '#align function.surjective.non_assoc_semiring Function.Surjective.nonAssocSemiringₓ'. -/
/-- Pushforward a `non_assoc_semiring` instance along a surjective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Surjective.nonAssocSemiring {α : Type u} [NonAssocSemiring α] {β : Type v}
    [Zero β] [One β] [Add β] [Mul β] [SMul ℕ β] [NatCast β] (f : α → β) (hf : Surjective f)
    (zero : f 0 = 0) (one : f 1 = 1) (add : ∀ x y, f (x + y) = f x + f y)
    (mul : ∀ x y, f (x * y) = f x * f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x)
    (nat_cast : ∀ n : ℕ, f n = n) : NonAssocSemiring β :=
  { hf.AddMonoidWithOne f zero one add nsmul nat_cast,
    hf.NonUnitalNonAssocSemiring f zero add mul nsmul, hf.MulOneClass f one mul with }
#align function.surjective.non_assoc_semiring Function.Surjective.nonAssocSemiring

/- warning: function.surjective.semiring -> Function.Surjective.semiring is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_5 : Semiring.{u1} α] {β : Type.{u2}} [_inst_6 : Zero.{u2} β] [_inst_7 : One.{u2} β] [_inst_8 : Add.{u2} β] [_inst_9 : Mul.{u2} β] [_inst_10 : Pow.{u2, 0} β Nat] [_inst_11 : SMul.{0, u2} Nat β] [_inst_12 : NatCast.{u2} β] (f : α -> β), (Function.Surjective.{succ u1, succ u2} α β f) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_5)))))))) (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β _inst_6)))) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_5)))))))) (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β _inst_7)))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_5))))) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_8) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_5))))) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_9) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ u2} β (f (SMul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_5))))) n x)) (SMul.smul.{0, u2} Nat β _inst_11 n (f x))) -> (forall (x : α) (n : Nat), Eq.{succ u2} β (f (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (MonoidWithZero.toMonoid.{u1} α (Semiring.toMonoidWithZero.{u1} α _inst_5)))) x n)) (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_10) (f x) n)) -> (forall (n : Nat), Eq.{succ u2} β (f ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u1} Nat α (CoeTCₓ.coe.{1, succ u1} Nat α (Nat.castCoe.{u1} α (AddMonoidWithOne.toNatCast.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_5))))))) n)) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat β (HasLiftT.mk.{1, succ u2} Nat β (CoeTCₓ.coe.{1, succ u2} Nat β (Nat.castCoe.{u2} β _inst_12))) n)) -> (Semiring.{u2} β)
but is expected to have type
  forall {α : Type.{u1}} [_inst_5 : Semiring.{u1} α] {β : Type.{u2}} [_inst_6 : Zero.{u2} β] [_inst_7 : One.{u2} β] [_inst_8 : Add.{u2} β] [_inst_9 : Mul.{u2} β] [_inst_10 : Pow.{u2, 0} β Nat] [_inst_11 : SMul.{0, u2} Nat β] [_inst_12 : NatCast.{u2} β] (f : α -> β), (Function.Surjective.{succ u1, succ u2} α β f) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α _inst_5))))) (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β _inst_6))) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (Semiring.toOne.{u1} α _inst_5)))) (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β _inst_7))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_5))))) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_8) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_5)))) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_9) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ u2} β (f (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_5)))))) n x)) (HSMul.hSMul.{0, u2, u2} Nat β β (instHSMul.{0, u2} Nat β _inst_11) n (f x))) -> (forall (x : α) (n : Nat), Eq.{succ u2} β (f (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (MonoidWithZero.toMonoid.{u1} α (Semiring.toMonoidWithZero.{u1} α _inst_5)))) x n)) (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_10) (f x) n)) -> (forall (n : Nat), Eq.{succ u2} β (f (Nat.cast.{u1} α (Semiring.toNatCast.{u1} α _inst_5) n)) (Nat.cast.{u2} β _inst_12 n)) -> (Semiring.{u2} β)
Case conversion may be inaccurate. Consider using '#align function.surjective.semiring Function.Surjective.semiringₓ'. -/
/-- Pushforward a `semiring` instance along a surjective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Surjective.semiring {α : Type u} [Semiring α] {β : Type v} [Zero β] [One β]
    [Add β] [Mul β] [Pow β ℕ] [SMul ℕ β] [NatCast β] (f : α → β) (hf : Surjective f)
    (zero : f 0 = 0) (one : f 1 = 1) (add : ∀ x y, f (x + y) = f x + f y)
    (mul : ∀ x y, f (x * y) = f x * f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x)
    (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n) (nat_cast : ∀ n : ℕ, f n = n) : Semiring β :=
  { hf.NonAssocSemiring f zero one add mul nsmul nat_cast, hf.MonoidWithZero f zero one mul npow,
    hf.AddCommMonoid f zero add nsmul, hf.Distrib f add mul with }
#align function.surjective.semiring Function.Surjective.semiring

end InjectiveSurjectiveMaps

section NonUnitalCommSemiring

variable [NonUnitalCommSemiring α] [NonUnitalCommSemiring β] {a b c : α}

/- warning: function.injective.non_unital_comm_semiring -> Function.Injective.nonUnitalCommSemiring is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {γ : Type.{u2}} [_inst_1 : NonUnitalCommSemiring.{u1} α] [_inst_3 : Zero.{u2} γ] [_inst_4 : Add.{u2} γ] [_inst_5 : Mul.{u2} γ] [_inst_6 : SMul.{0, u2} Nat γ] (f : γ -> α), (Function.Injective.{succ u2, succ u1} γ α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} γ 0 (OfNat.mk.{u2} γ 0 (Zero.zero.{u2} γ _inst_3)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} α _inst_1)))))))) -> (forall (x : γ) (y : γ), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} γ γ γ (instHAdd.{u2} γ _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} α _inst_1))))) (f x) (f y))) -> (forall (x : γ) (y : γ), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} γ γ γ (instHMul.{u2} γ _inst_5) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} α _inst_1))))) (f x) (f y))) -> (forall (x : γ) (n : Nat), Eq.{succ u1} α (f (SMul.smul.{0, u2} Nat γ _inst_6 n x)) (SMul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} α _inst_1))))) n (f x))) -> (NonUnitalCommSemiring.{u2} γ)
but is expected to have type
  forall {α : Type.{u1}} {γ : Type.{u2}} [_inst_1 : NonUnitalCommSemiring.{u1} α] [_inst_3 : Zero.{u2} γ] [_inst_4 : Add.{u2} γ] [_inst_5 : Mul.{u2} γ] [_inst_6 : SMul.{0, u2} Nat γ] (f : γ -> α), (Function.Injective.{succ u2, succ u1} γ α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} γ 0 (Zero.toOfNat0.{u2} γ _inst_3))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (SemigroupWithZero.toZero.{u1} α (NonUnitalSemiring.toSemigroupWithZero.{u1} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} α _inst_1)))))) -> (forall (x : γ) (y : γ), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} γ γ γ (instHAdd.{u2} γ _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} α _inst_1))))) (f x) (f y))) -> (forall (x : γ) (y : γ), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} γ γ γ (instHMul.{u2} γ _inst_5) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} α _inst_1)))) (f x) (f y))) -> (forall (x : γ) (n : Nat), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Nat γ γ (instHSMul.{0, u2} Nat γ _inst_6) n x)) (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} α _inst_1)))))) n (f x))) -> (NonUnitalCommSemiring.{u2} γ)
Case conversion may be inaccurate. Consider using '#align function.injective.non_unital_comm_semiring Function.Injective.nonUnitalCommSemiringₓ'. -/
/-- Pullback a `non_unital_semiring` instance along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.nonUnitalCommSemiring [Zero γ] [Add γ] [Mul γ] [SMul ℕ γ]
    (f : γ → α) (hf : Injective f) (zero : f 0 = 0) (add : ∀ x y, f (x + y) = f x + f y)
    (mul : ∀ x y, f (x * y) = f x * f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) :
    NonUnitalCommSemiring γ :=
  { hf.NonUnitalSemiring f zero add mul nsmul, hf.CommSemigroup f mul with }
#align function.injective.non_unital_comm_semiring Function.Injective.nonUnitalCommSemiring

/- warning: function.surjective.non_unital_comm_semiring -> Function.Surjective.nonUnitalCommSemiring is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {γ : Type.{u2}} [_inst_1 : NonUnitalCommSemiring.{u1} α] [_inst_3 : Zero.{u2} γ] [_inst_4 : Add.{u2} γ] [_inst_5 : Mul.{u2} γ] [_inst_6 : SMul.{0, u2} Nat γ] (f : α -> γ), (Function.Surjective.{succ u1, succ u2} α γ f) -> (Eq.{succ u2} γ (f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} α _inst_1)))))))) (OfNat.ofNat.{u2} γ 0 (OfNat.mk.{u2} γ 0 (Zero.zero.{u2} γ _inst_3)))) -> (forall (x : α) (y : α), Eq.{succ u2} γ (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} α _inst_1))))) x y)) (HAdd.hAdd.{u2, u2, u2} γ γ γ (instHAdd.{u2} γ _inst_4) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ u2} γ (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} α _inst_1))))) x y)) (HMul.hMul.{u2, u2, u2} γ γ γ (instHMul.{u2} γ _inst_5) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ u2} γ (f (SMul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} α _inst_1))))) n x)) (SMul.smul.{0, u2} Nat γ _inst_6 n (f x))) -> (NonUnitalCommSemiring.{u2} γ)
but is expected to have type
  forall {α : Type.{u1}} {γ : Type.{u2}} [_inst_1 : NonUnitalCommSemiring.{u1} α] [_inst_3 : Zero.{u2} γ] [_inst_4 : Add.{u2} γ] [_inst_5 : Mul.{u2} γ] [_inst_6 : SMul.{0, u2} Nat γ] (f : α -> γ), (Function.Surjective.{succ u1, succ u2} α γ f) -> (Eq.{succ u2} γ (f (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (SemigroupWithZero.toZero.{u1} α (NonUnitalSemiring.toSemigroupWithZero.{u1} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} α _inst_1)))))) (OfNat.ofNat.{u2} γ 0 (Zero.toOfNat0.{u2} γ _inst_3))) -> (forall (x : α) (y : α), Eq.{succ u2} γ (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} α _inst_1))))) x y)) (HAdd.hAdd.{u2, u2, u2} γ γ γ (instHAdd.{u2} γ _inst_4) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ u2} γ (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} α _inst_1)))) x y)) (HMul.hMul.{u2, u2, u2} γ γ γ (instHMul.{u2} γ _inst_5) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ u2} γ (f (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} α _inst_1)))))) n x)) (HSMul.hSMul.{0, u2, u2} Nat γ γ (instHSMul.{0, u2} Nat γ _inst_6) n (f x))) -> (NonUnitalCommSemiring.{u2} γ)
Case conversion may be inaccurate. Consider using '#align function.surjective.non_unital_comm_semiring Function.Surjective.nonUnitalCommSemiringₓ'. -/
/-- Pushforward a `non_unital_semiring` instance along a surjective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Surjective.nonUnitalCommSemiring [Zero γ] [Add γ] [Mul γ] [SMul ℕ γ]
    (f : α → γ) (hf : Surjective f) (zero : f 0 = 0) (add : ∀ x y, f (x + y) = f x + f y)
    (mul : ∀ x y, f (x * y) = f x * f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) :
    NonUnitalCommSemiring γ :=
  { hf.NonUnitalSemiring f zero add mul nsmul, hf.CommSemigroup f mul with }
#align function.surjective.non_unital_comm_semiring Function.Surjective.nonUnitalCommSemiring

end NonUnitalCommSemiring

section CommSemiring

variable [CommSemiring α] [CommSemiring β] {a b c : α}

/- warning: function.injective.comm_semiring -> Function.Injective.commSemiring is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {γ : Type.{u2}} [_inst_1 : CommSemiring.{u1} α] [_inst_3 : Zero.{u2} γ] [_inst_4 : One.{u2} γ] [_inst_5 : Add.{u2} γ] [_inst_6 : Mul.{u2} γ] [_inst_7 : SMul.{0, u2} Nat γ] [_inst_8 : NatCast.{u2} γ] [_inst_9 : Pow.{u2, 0} γ Nat] (f : γ -> α), (Function.Injective.{succ u2, succ u1} γ α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} γ 0 (OfNat.mk.{u2} γ 0 (Zero.zero.{u2} γ _inst_3)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (CommSemiring.toSemiring.{u1} α _inst_1))))))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} γ 1 (OfNat.mk.{u2} γ 1 (One.one.{u2} γ _inst_4)))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (CommSemiring.toSemiring.{u1} α _inst_1))))))))) -> (forall (x : γ) (y : γ), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} γ γ γ (instHAdd.{u2} γ _inst_5) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (CommSemiring.toSemiring.{u1} α _inst_1)))))) (f x) (f y))) -> (forall (x : γ) (y : γ), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} γ γ γ (instHMul.{u2} γ _inst_6) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (CommSemiring.toSemiring.{u1} α _inst_1)))))) (f x) (f y))) -> (forall (x : γ) (n : Nat), Eq.{succ u1} α (f (SMul.smul.{0, u2} Nat γ _inst_7 n x)) (SMul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (CommSemiring.toSemiring.{u1} α _inst_1)))))) n (f x))) -> (forall (x : γ) (n : Nat), Eq.{succ u1} α (f (HPow.hPow.{u2, 0, u2} γ Nat γ (instHPow.{u2, 0} γ Nat _inst_9) x n)) (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (MonoidWithZero.toMonoid.{u1} α (Semiring.toMonoidWithZero.{u1} α (CommSemiring.toSemiring.{u1} α _inst_1))))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} α (f ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat γ (HasLiftT.mk.{1, succ u2} Nat γ (CoeTCₓ.coe.{1, succ u2} Nat γ (Nat.castCoe.{u2} γ _inst_8))) n)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u1} Nat α (CoeTCₓ.coe.{1, succ u1} Nat α (Nat.castCoe.{u1} α (AddMonoidWithOne.toNatCast.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (CommSemiring.toSemiring.{u1} α _inst_1)))))))) n)) -> (CommSemiring.{u2} γ)
but is expected to have type
  forall {α : Type.{u1}} {γ : Type.{u2}} [_inst_1 : CommSemiring.{u1} α] [_inst_3 : Zero.{u2} γ] [_inst_4 : One.{u2} γ] [_inst_5 : Add.{u2} γ] [_inst_6 : Mul.{u2} γ] [_inst_7 : SMul.{0, u2} Nat γ] [_inst_8 : NatCast.{u2} γ] [_inst_9 : Pow.{u2, 0} γ Nat] (f : γ -> α), (Function.Injective.{succ u2, succ u1} γ α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} γ 0 (Zero.toOfNat0.{u2} γ _inst_3))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (CommMonoidWithZero.toZero.{u1} α (CommSemiring.toCommMonoidWithZero.{u1} α _inst_1))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} γ 1 (One.toOfNat1.{u2} γ _inst_4))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (Semiring.toOne.{u1} α (CommSemiring.toSemiring.{u1} α _inst_1))))) -> (forall (x : γ) (y : γ), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} γ γ γ (instHAdd.{u2} γ _inst_5) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (CommSemiring.toSemiring.{u1} α _inst_1)))))) (f x) (f y))) -> (forall (x : γ) (y : γ), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} γ γ γ (instHMul.{u2} γ _inst_6) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (CommSemiring.toSemiring.{u1} α _inst_1))))) (f x) (f y))) -> (forall (x : γ) (n : Nat), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Nat γ γ (instHSMul.{0, u2} Nat γ _inst_7) n x)) (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (CommSemiring.toSemiring.{u1} α _inst_1))))))) n (f x))) -> (forall (x : γ) (n : Nat), Eq.{succ u1} α (f (HPow.hPow.{u2, 0, u2} γ Nat γ (instHPow.{u2, 0} γ Nat _inst_9) x n)) (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (MonoidWithZero.toMonoid.{u1} α (Semiring.toMonoidWithZero.{u1} α (CommSemiring.toSemiring.{u1} α _inst_1))))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} α (f (Nat.cast.{u2} γ _inst_8 n)) (Nat.cast.{u1} α (Semiring.toNatCast.{u1} α (CommSemiring.toSemiring.{u1} α _inst_1)) n)) -> (CommSemiring.{u2} γ)
Case conversion may be inaccurate. Consider using '#align function.injective.comm_semiring Function.Injective.commSemiringₓ'. -/
/-- Pullback a `semiring` instance along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.commSemiring [Zero γ] [One γ] [Add γ] [Mul γ] [SMul ℕ γ]
    [NatCast γ] [Pow γ ℕ] (f : γ → α) (hf : Injective f) (zero : f 0 = 0) (one : f 1 = 1)
    (add : ∀ x y, f (x + y) = f x + f y) (mul : ∀ x y, f (x * y) = f x * f y)
    (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n)
    (nat_cast : ∀ n : ℕ, f n = n) : CommSemiring γ :=
  { hf.Semiring f zero one add mul nsmul npow nat_cast, hf.CommSemigroup f mul with }
#align function.injective.comm_semiring Function.Injective.commSemiring

/- warning: function.surjective.comm_semiring -> Function.Surjective.commSemiring is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {γ : Type.{u2}} [_inst_1 : CommSemiring.{u1} α] [_inst_3 : Zero.{u2} γ] [_inst_4 : One.{u2} γ] [_inst_5 : Add.{u2} γ] [_inst_6 : Mul.{u2} γ] [_inst_7 : SMul.{0, u2} Nat γ] [_inst_8 : NatCast.{u2} γ] [_inst_9 : Pow.{u2, 0} γ Nat] (f : α -> γ), (Function.Surjective.{succ u1, succ u2} α γ f) -> (Eq.{succ u2} γ (f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (CommSemiring.toSemiring.{u1} α _inst_1))))))))) (OfNat.ofNat.{u2} γ 0 (OfNat.mk.{u2} γ 0 (Zero.zero.{u2} γ _inst_3)))) -> (Eq.{succ u2} γ (f (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (CommSemiring.toSemiring.{u1} α _inst_1))))))))) (OfNat.ofNat.{u2} γ 1 (OfNat.mk.{u2} γ 1 (One.one.{u2} γ _inst_4)))) -> (forall (x : α) (y : α), Eq.{succ u2} γ (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (CommSemiring.toSemiring.{u1} α _inst_1)))))) x y)) (HAdd.hAdd.{u2, u2, u2} γ γ γ (instHAdd.{u2} γ _inst_5) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ u2} γ (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (CommSemiring.toSemiring.{u1} α _inst_1)))))) x y)) (HMul.hMul.{u2, u2, u2} γ γ γ (instHMul.{u2} γ _inst_6) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ u2} γ (f (SMul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (CommSemiring.toSemiring.{u1} α _inst_1)))))) n x)) (SMul.smul.{0, u2} Nat γ _inst_7 n (f x))) -> (forall (x : α) (n : Nat), Eq.{succ u2} γ (f (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (MonoidWithZero.toMonoid.{u1} α (Semiring.toMonoidWithZero.{u1} α (CommSemiring.toSemiring.{u1} α _inst_1))))) x n)) (HPow.hPow.{u2, 0, u2} γ Nat γ (instHPow.{u2, 0} γ Nat _inst_9) (f x) n)) -> (forall (n : Nat), Eq.{succ u2} γ (f ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u1} Nat α (CoeTCₓ.coe.{1, succ u1} Nat α (Nat.castCoe.{u1} α (AddMonoidWithOne.toNatCast.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (CommSemiring.toSemiring.{u1} α _inst_1)))))))) n)) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat γ (HasLiftT.mk.{1, succ u2} Nat γ (CoeTCₓ.coe.{1, succ u2} Nat γ (Nat.castCoe.{u2} γ _inst_8))) n)) -> (CommSemiring.{u2} γ)
but is expected to have type
  forall {α : Type.{u1}} {γ : Type.{u2}} [_inst_1 : CommSemiring.{u1} α] [_inst_3 : Zero.{u2} γ] [_inst_4 : One.{u2} γ] [_inst_5 : Add.{u2} γ] [_inst_6 : Mul.{u2} γ] [_inst_7 : SMul.{0, u2} Nat γ] [_inst_8 : NatCast.{u2} γ] [_inst_9 : Pow.{u2, 0} γ Nat] (f : α -> γ), (Function.Surjective.{succ u1, succ u2} α γ f) -> (Eq.{succ u2} γ (f (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (CommMonoidWithZero.toZero.{u1} α (CommSemiring.toCommMonoidWithZero.{u1} α _inst_1))))) (OfNat.ofNat.{u2} γ 0 (Zero.toOfNat0.{u2} γ _inst_3))) -> (Eq.{succ u2} γ (f (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (Semiring.toOne.{u1} α (CommSemiring.toSemiring.{u1} α _inst_1))))) (OfNat.ofNat.{u2} γ 1 (One.toOfNat1.{u2} γ _inst_4))) -> (forall (x : α) (y : α), Eq.{succ u2} γ (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (CommSemiring.toSemiring.{u1} α _inst_1)))))) x y)) (HAdd.hAdd.{u2, u2, u2} γ γ γ (instHAdd.{u2} γ _inst_5) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ u2} γ (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (CommSemiring.toSemiring.{u1} α _inst_1))))) x y)) (HMul.hMul.{u2, u2, u2} γ γ γ (instHMul.{u2} γ _inst_6) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ u2} γ (f (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (CommSemiring.toSemiring.{u1} α _inst_1))))))) n x)) (HSMul.hSMul.{0, u2, u2} Nat γ γ (instHSMul.{0, u2} Nat γ _inst_7) n (f x))) -> (forall (x : α) (n : Nat), Eq.{succ u2} γ (f (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (MonoidWithZero.toMonoid.{u1} α (Semiring.toMonoidWithZero.{u1} α (CommSemiring.toSemiring.{u1} α _inst_1))))) x n)) (HPow.hPow.{u2, 0, u2} γ Nat γ (instHPow.{u2, 0} γ Nat _inst_9) (f x) n)) -> (forall (n : Nat), Eq.{succ u2} γ (f (Nat.cast.{u1} α (Semiring.toNatCast.{u1} α (CommSemiring.toSemiring.{u1} α _inst_1)) n)) (Nat.cast.{u2} γ _inst_8 n)) -> (CommSemiring.{u2} γ)
Case conversion may be inaccurate. Consider using '#align function.surjective.comm_semiring Function.Surjective.commSemiringₓ'. -/
/-- Pushforward a `semiring` instance along a surjective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Surjective.commSemiring [Zero γ] [One γ] [Add γ] [Mul γ] [SMul ℕ γ]
    [NatCast γ] [Pow γ ℕ] (f : α → γ) (hf : Surjective f) (zero : f 0 = 0) (one : f 1 = 1)
    (add : ∀ x y, f (x + y) = f x + f y) (mul : ∀ x y, f (x * y) = f x * f y)
    (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n)
    (nat_cast : ∀ n : ℕ, f n = n) : CommSemiring γ :=
  { hf.Semiring f zero one add mul nsmul npow nat_cast, hf.CommSemigroup f mul with }
#align function.surjective.comm_semiring Function.Surjective.commSemiring

end CommSemiring

section HasDistribNeg

section Mul

variable [Mul α] [HasDistribNeg α]

/- warning: function.injective.has_distrib_neg -> Function.Injective.hasDistribNeg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Mul.{u1} α] [_inst_2 : HasDistribNeg.{u1} α _inst_1] [_inst_3 : Neg.{u2} β] [_inst_4 : Mul.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (forall (a : β), Eq.{succ u1} α (f (Neg.neg.{u2} β _inst_3 a)) (Neg.neg.{u1} α (InvolutiveNeg.toHasNeg.{u1} α (HasDistribNeg.toHasInvolutiveNeg.{u1} α _inst_1 _inst_2)) (f a))) -> (forall (a : β) (b : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_4) a b)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α _inst_1) (f a) (f b))) -> (HasDistribNeg.{u2} β _inst_4)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Mul.{u1} α] [_inst_2 : HasDistribNeg.{u1} α _inst_1] [_inst_3 : Neg.{u2} β] [_inst_4 : Mul.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (forall (a : β), Eq.{succ u1} α (f (Neg.neg.{u2} β _inst_3 a)) (Neg.neg.{u1} α (InvolutiveNeg.toNeg.{u1} α (HasDistribNeg.toInvolutiveNeg.{u1} α _inst_1 _inst_2)) (f a))) -> (forall (a : β) (b : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_4) a b)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α _inst_1) (f a) (f b))) -> (HasDistribNeg.{u2} β _inst_4)
Case conversion may be inaccurate. Consider using '#align function.injective.has_distrib_neg Function.Injective.hasDistribNegₓ'. -/
-- See note [reducible non-instances]
/-- A type endowed with `-` and `*` has distributive negation, if it admits an injective map that
preserves `-` and `*` to a type which has distributive negation. -/
@[reducible]
protected def Function.Injective.hasDistribNeg [Neg β] [Mul β] (f : β → α) (hf : Injective f)
    (neg : ∀ a, f (-a) = -f a) (mul : ∀ a b, f (a * b) = f a * f b) : HasDistribNeg β :=
  { hf.HasInvolutiveNeg _ neg,
    ‹Mul β› with
    neg_mul := fun x y => hf <| by erw [neg, mul, neg, neg_mul, mul]
    mul_neg := fun x y => hf <| by erw [neg, mul, neg, mul_neg, mul] }
#align function.injective.has_distrib_neg Function.Injective.hasDistribNeg

/- warning: function.surjective.has_distrib_neg -> Function.Surjective.hasDistribNeg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Mul.{u1} α] [_inst_2 : HasDistribNeg.{u1} α _inst_1] [_inst_3 : Neg.{u2} β] [_inst_4 : Mul.{u2} β] (f : α -> β), (Function.Surjective.{succ u1, succ u2} α β f) -> (forall (a : α), Eq.{succ u2} β (f (Neg.neg.{u1} α (InvolutiveNeg.toHasNeg.{u1} α (HasDistribNeg.toHasInvolutiveNeg.{u1} α _inst_1 _inst_2)) a)) (Neg.neg.{u2} β _inst_3 (f a))) -> (forall (a : α) (b : α), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α _inst_1) a b)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_4) (f a) (f b))) -> (HasDistribNeg.{u2} β _inst_4)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Mul.{u1} α] [_inst_2 : HasDistribNeg.{u1} α _inst_1] [_inst_3 : Neg.{u2} β] [_inst_4 : Mul.{u2} β] (f : α -> β), (Function.Surjective.{succ u1, succ u2} α β f) -> (forall (a : α), Eq.{succ u2} β (f (Neg.neg.{u1} α (InvolutiveNeg.toNeg.{u1} α (HasDistribNeg.toInvolutiveNeg.{u1} α _inst_1 _inst_2)) a)) (Neg.neg.{u2} β _inst_3 (f a))) -> (forall (a : α) (b : α), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α _inst_1) a b)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_4) (f a) (f b))) -> (HasDistribNeg.{u2} β _inst_4)
Case conversion may be inaccurate. Consider using '#align function.surjective.has_distrib_neg Function.Surjective.hasDistribNegₓ'. -/
-- See note [reducible non-instances]
/-- A type endowed with `-` and `*` has distributive negation, if it admits a surjective map that
preserves `-` and `*` from a type which has distributive negation. -/
@[reducible]
protected def Function.Surjective.hasDistribNeg [Neg β] [Mul β] (f : α → β) (hf : Surjective f)
    (neg : ∀ a, f (-a) = -f a) (mul : ∀ a b, f (a * b) = f a * f b) : HasDistribNeg β :=
  { hf.HasInvolutiveNeg _ neg,
    ‹Mul
        β› with
    neg_mul :=
      hf.Forall₂.2 fun x y => by
        erw [← neg, ← mul, neg_mul, neg, mul]
        rfl
    mul_neg :=
      hf.Forall₂.2 fun x y => by
        erw [← neg, ← mul, mul_neg, neg, mul]
        rfl }
#align function.surjective.has_distrib_neg Function.Surjective.hasDistribNeg

namespace AddOpposite

instance : HasDistribNeg αᵃᵒᵖ :=
  unop_injective.HasDistribNeg _ unop_neg unop_mul

end AddOpposite

end Mul

end HasDistribNeg

/-!
### Rings
-/


section NonUnitalNonAssocRing

variable [NonUnitalNonAssocRing α]

/- warning: function.injective.non_unital_non_assoc_ring -> Function.Injective.nonUnitalNonAssocRing is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonUnitalNonAssocRing.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : Add.{u2} β] [_inst_4 : Mul.{u2} β] [_inst_5 : Neg.{u2} β] [_inst_6 : Sub.{u2} β] [_inst_7 : SMul.{0, u2} Nat β] [_inst_8 : SMul.{0, u2} Int β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β _inst_2)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_3) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_4) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) (f x) (f y))) -> (forall (x : β), Eq.{succ u1} α (f (Neg.neg.{u2} β _inst_5 x)) (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α _inst_1)))) (f x))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_6) x y)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α _inst_1))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (SMul.smul.{0, u2} Nat β _inst_7 n x)) (SMul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α _inst_1))))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u1} α (f (SMul.smul.{0, u2} Int β _inst_8 n x)) (SMul.smul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α _inst_1)))) n (f x))) -> (NonUnitalNonAssocRing.{u2} β)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonUnitalNonAssocRing.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : Add.{u2} β] [_inst_4 : Mul.{u2} β] [_inst_5 : Neg.{u2} β] [_inst_6 : Sub.{u2} β] [_inst_7 : SMul.{0, u2} Nat β] [_inst_8 : SMul.{0, u2} Int β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β _inst_2))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (MulZeroClass.toZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_3) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_4) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α _inst_1)) (f x) (f y))) -> (forall (x : β), Eq.{succ u1} α (f (Neg.neg.{u2} β _inst_5 x)) (Neg.neg.{u1} α (NegZeroClass.toNeg.{u1} α (SubNegZeroMonoid.toNegZeroClass.{u1} α (SubtractionMonoid.toSubNegZeroMonoid.{u1} α (SubtractionCommMonoid.toSubtractionMonoid.{u1} α (AddCommGroup.toDivisionAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α _inst_1)))))) (f x))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_6) x y)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α _inst_1))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Nat β β (instHSMul.{0, u2} Nat β _inst_7) n x)) (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α _inst_1)))))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Int β β (instHSMul.{0, u2} Int β _inst_8) n x)) (HSMul.hSMul.{0, u1, u1} Int α α (instHSMul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α _inst_1))))) n (f x))) -> (NonUnitalNonAssocRing.{u2} β)
Case conversion may be inaccurate. Consider using '#align function.injective.non_unital_non_assoc_ring Function.Injective.nonUnitalNonAssocRingₓ'. -/
/-- Pullback a `non_unital_non_assoc_ring` instance along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.nonUnitalNonAssocRing [Zero β] [Add β] [Mul β] [Neg β] [Sub β]
    [SMul ℕ β] [SMul ℤ β] (f : β → α) (hf : Injective f) (zero : f 0 = 0)
    (add : ∀ x y, f (x + y) = f x + f y) (mul : ∀ x y, f (x * y) = f x * f y)
    (neg : ∀ x, f (-x) = -f x) (sub : ∀ x y, f (x - y) = f x - f y)
    (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) (zsmul : ∀ (x) (n : ℤ), f (n • x) = n • f x) :
    NonUnitalNonAssocRing β :=
  { hf.AddCommGroup f zero add neg sub nsmul zsmul, hf.MulZeroClass f zero mul,
    hf.Distrib f add mul with }
#align function.injective.non_unital_non_assoc_ring Function.Injective.nonUnitalNonAssocRing

/- warning: function.surjective.non_unital_non_assoc_ring -> Function.Surjective.nonUnitalNonAssocRing is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonUnitalNonAssocRing.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : Add.{u2} β] [_inst_4 : Mul.{u2} β] [_inst_5 : Neg.{u2} β] [_inst_6 : Sub.{u2} β] [_inst_7 : SMul.{0, u2} Nat β] [_inst_8 : SMul.{0, u2} Int β] (f : α -> β), (Function.Surjective.{succ u1, succ u2} α β f) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))))) (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β _inst_2)))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_3) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_4) (f x) (f y))) -> (forall (x : α), Eq.{succ u2} β (f (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α _inst_1)))) x)) (Neg.neg.{u2} β _inst_5 (f x))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α _inst_1))))) x y)) (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_6) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ u2} β (f (SMul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α _inst_1))))) n x)) (SMul.smul.{0, u2} Nat β _inst_7 n (f x))) -> (forall (x : α) (n : Int), Eq.{succ u2} β (f (SMul.smul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α _inst_1)))) n x)) (SMul.smul.{0, u2} Int β _inst_8 n (f x))) -> (NonUnitalNonAssocRing.{u2} β)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonUnitalNonAssocRing.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : Add.{u2} β] [_inst_4 : Mul.{u2} β] [_inst_5 : Neg.{u2} β] [_inst_6 : Sub.{u2} β] [_inst_7 : SMul.{0, u2} Nat β] [_inst_8 : SMul.{0, u2} Int β] (f : α -> β), (Function.Surjective.{succ u1, succ u2} α β f) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (MulZeroClass.toZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))))) (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β _inst_2))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_3) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α _inst_1)) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_4) (f x) (f y))) -> (forall (x : α), Eq.{succ u2} β (f (Neg.neg.{u1} α (NegZeroClass.toNeg.{u1} α (SubNegZeroMonoid.toNegZeroClass.{u1} α (SubtractionMonoid.toSubNegZeroMonoid.{u1} α (SubtractionCommMonoid.toSubtractionMonoid.{u1} α (AddCommGroup.toDivisionAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α _inst_1)))))) x)) (Neg.neg.{u2} β _inst_5 (f x))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α _inst_1))))) x y)) (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_6) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ u2} β (f (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α _inst_1)))))) n x)) (HSMul.hSMul.{0, u2, u2} Nat β β (instHSMul.{0, u2} Nat β _inst_7) n (f x))) -> (forall (x : α) (n : Int), Eq.{succ u2} β (f (HSMul.hSMul.{0, u1, u1} Int α α (instHSMul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α _inst_1))))) n x)) (HSMul.hSMul.{0, u2, u2} Int β β (instHSMul.{0, u2} Int β _inst_8) n (f x))) -> (NonUnitalNonAssocRing.{u2} β)
Case conversion may be inaccurate. Consider using '#align function.surjective.non_unital_non_assoc_ring Function.Surjective.nonUnitalNonAssocRingₓ'. -/
/-- Pushforward a `non_unital_non_assoc_ring` instance along a surjective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Surjective.nonUnitalNonAssocRing [Zero β] [Add β] [Mul β] [Neg β] [Sub β]
    [SMul ℕ β] [SMul ℤ β] (f : α → β) (hf : Surjective f) (zero : f 0 = 0)
    (add : ∀ x y, f (x + y) = f x + f y) (mul : ∀ x y, f (x * y) = f x * f y)
    (neg : ∀ x, f (-x) = -f x) (sub : ∀ x y, f (x - y) = f x - f y)
    (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) (zsmul : ∀ (x) (n : ℤ), f (n • x) = n • f x) :
    NonUnitalNonAssocRing β :=
  { hf.AddCommGroup f zero add neg sub nsmul zsmul, hf.MulZeroClass f zero mul,
    hf.Distrib f add mul with }
#align function.surjective.non_unital_non_assoc_ring Function.Surjective.nonUnitalNonAssocRing

end NonUnitalNonAssocRing

section NonUnitalRing

variable [NonUnitalRing α]

/- warning: function.injective.non_unital_ring -> Function.Injective.nonUnitalRing is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonUnitalRing.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : Add.{u2} β] [_inst_4 : Mul.{u2} β] [_inst_5 : Neg.{u2} β] [_inst_6 : Sub.{u2} β] [_inst_7 : SMul.{0, u2} Nat β] [_inst_8 : SMul.{0, u2} Int β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β _inst_2)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1)))))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_3) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_4) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1))))) (f x) (f y))) -> (forall (x : β), Eq.{succ u1} α (f (Neg.neg.{u2} β _inst_5 x)) (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1))))) (f x))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_6) x y)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1)))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (SMul.smul.{0, u2} Nat β _inst_7 n x)) (SMul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1)))))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u1} α (f (SMul.smul.{0, u2} Int β _inst_8 n x)) (SMul.smul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1))))) n (f x))) -> (NonUnitalRing.{u2} β)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonUnitalRing.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : Add.{u2} β] [_inst_4 : Mul.{u2} β] [_inst_5 : Neg.{u2} β] [_inst_6 : Sub.{u2} β] [_inst_7 : SMul.{0, u2} Nat β] [_inst_8 : SMul.{0, u2} Int β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β _inst_2))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (SemigroupWithZero.toZero.{u1} α (NonUnitalSemiring.toSemigroupWithZero.{u1} α (NonUnitalRing.toNonUnitalSemiring.{u1} α _inst_1)))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_3) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_4) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1))) (f x) (f y))) -> (forall (x : β), Eq.{succ u1} α (f (Neg.neg.{u2} β _inst_5 x)) (Neg.neg.{u1} α (NegZeroClass.toNeg.{u1} α (SubNegZeroMonoid.toNegZeroClass.{u1} α (SubtractionMonoid.toSubNegZeroMonoid.{u1} α (SubtractionCommMonoid.toSubtractionMonoid.{u1} α (AddCommGroup.toDivisionAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1))))))) (f x))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_6) x y)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1)))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Nat β β (instHSMul.{0, u2} Nat β _inst_7) n x)) (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1))))))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Int β β (instHSMul.{0, u2} Int β _inst_8) n x)) (HSMul.hSMul.{0, u1, u1} Int α α (instHSMul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1)))))) n (f x))) -> (NonUnitalRing.{u2} β)
Case conversion may be inaccurate. Consider using '#align function.injective.non_unital_ring Function.Injective.nonUnitalRingₓ'. -/
/-- Pullback a `non_unital_ring` instance along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.nonUnitalRing [Zero β] [Add β] [Mul β] [Neg β] [Sub β] [SMul ℕ β]
    [SMul ℤ β] (f : β → α) (hf : Injective f) (zero : f 0 = 0) (add : ∀ x y, f (x + y) = f x + f y)
    (mul : ∀ x y, f (x * y) = f x * f y) (neg : ∀ x, f (-x) = -f x)
    (sub : ∀ x y, f (x - y) = f x - f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x)
    (gsmul : ∀ (x) (n : ℤ), f (n • x) = n • f x) : NonUnitalRing β :=
  { hf.AddCommGroup f zero add neg sub nsmul gsmul, hf.MulZeroClass f zero mul,
    hf.Distrib f add mul, hf.Semigroup f mul with }
#align function.injective.non_unital_ring Function.Injective.nonUnitalRing

/- warning: function.surjective.non_unital_ring -> Function.Surjective.nonUnitalRing is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonUnitalRing.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : Add.{u2} β] [_inst_4 : Mul.{u2} β] [_inst_5 : Neg.{u2} β] [_inst_6 : Sub.{u2} β] [_inst_7 : SMul.{0, u2} Nat β] [_inst_8 : SMul.{0, u2} Int β] (f : α -> β), (Function.Surjective.{succ u1, succ u2} α β f) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1)))))))) (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β _inst_2)))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1))))) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_3) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1))))) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_4) (f x) (f y))) -> (forall (x : α), Eq.{succ u2} β (f (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1))))) x)) (Neg.neg.{u2} β _inst_5 (f x))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1)))))) x y)) (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_6) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ u2} β (f (SMul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1)))))) n x)) (SMul.smul.{0, u2} Nat β _inst_7 n (f x))) -> (forall (x : α) (n : Int), Eq.{succ u2} β (f (SMul.smul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1))))) n x)) (SMul.smul.{0, u2} Int β _inst_8 n (f x))) -> (NonUnitalRing.{u2} β)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonUnitalRing.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : Add.{u2} β] [_inst_4 : Mul.{u2} β] [_inst_5 : Neg.{u2} β] [_inst_6 : Sub.{u2} β] [_inst_7 : SMul.{0, u2} Nat β] [_inst_8 : SMul.{0, u2} Int β] (f : α -> β), (Function.Surjective.{succ u1, succ u2} α β f) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (SemigroupWithZero.toZero.{u1} α (NonUnitalSemiring.toSemigroupWithZero.{u1} α (NonUnitalRing.toNonUnitalSemiring.{u1} α _inst_1)))))) (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β _inst_2))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1))))) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_3) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1))) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_4) (f x) (f y))) -> (forall (x : α), Eq.{succ u2} β (f (Neg.neg.{u1} α (NegZeroClass.toNeg.{u1} α (SubNegZeroMonoid.toNegZeroClass.{u1} α (SubtractionMonoid.toSubNegZeroMonoid.{u1} α (SubtractionCommMonoid.toSubtractionMonoid.{u1} α (AddCommGroup.toDivisionAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1))))))) x)) (Neg.neg.{u2} β _inst_5 (f x))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1)))))) x y)) (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_6) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ u2} β (f (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1))))))) n x)) (HSMul.hSMul.{0, u2, u2} Nat β β (instHSMul.{0, u2} Nat β _inst_7) n (f x))) -> (forall (x : α) (n : Int), Eq.{succ u2} β (f (HSMul.hSMul.{0, u1, u1} Int α α (instHSMul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1)))))) n x)) (HSMul.hSMul.{0, u2, u2} Int β β (instHSMul.{0, u2} Int β _inst_8) n (f x))) -> (NonUnitalRing.{u2} β)
Case conversion may be inaccurate. Consider using '#align function.surjective.non_unital_ring Function.Surjective.nonUnitalRingₓ'. -/
/-- Pushforward a `non_unital_ring` instance along a surjective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Surjective.nonUnitalRing [Zero β] [Add β] [Mul β] [Neg β] [Sub β] [SMul ℕ β]
    [SMul ℤ β] (f : α → β) (hf : Surjective f) (zero : f 0 = 0) (add : ∀ x y, f (x + y) = f x + f y)
    (mul : ∀ x y, f (x * y) = f x * f y) (neg : ∀ x, f (-x) = -f x)
    (sub : ∀ x y, f (x - y) = f x - f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x)
    (gsmul : ∀ (x) (n : ℤ), f (n • x) = n • f x) : NonUnitalRing β :=
  { hf.AddCommGroup f zero add neg sub nsmul gsmul, hf.MulZeroClass f zero mul,
    hf.Distrib f add mul, hf.Semigroup f mul with }
#align function.surjective.non_unital_ring Function.Surjective.nonUnitalRing

end NonUnitalRing

section NonAssocRing

variable [NonAssocRing α]

/- warning: function.injective.non_assoc_ring -> Function.Injective.nonAssocRing is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonAssocRing.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Neg.{u2} β] [_inst_7 : Sub.{u2} β] [_inst_8 : SMul.{0, u2} Nat β] [_inst_9 : SMul.{0, u2} Int β] [_inst_10 : NatCast.{u2} β] [_inst_11 : IntCast.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β _inst_2)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α _inst_1)))))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β _inst_3)))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α _inst_1))))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α _inst_1))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α _inst_1))))) (f x) (f y))) -> (forall (x : β), Eq.{succ u1} α (f (Neg.neg.{u2} β _inst_6 x)) (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α _inst_1)))) (f x))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_7) x y)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α _inst_1))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (SMul.smul.{0, u2} Nat β _inst_8 n x)) (SMul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α _inst_1)))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u1} α (f (SMul.smul.{0, u2} Int β _inst_9 n x)) (SMul.smul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α _inst_1)))) n (f x))) -> (forall (n : Nat), Eq.{succ u1} α (f ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat β (HasLiftT.mk.{1, succ u2} Nat β (CoeTCₓ.coe.{1, succ u2} Nat β (Nat.castCoe.{u2} β _inst_10))) n)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u1} Nat α (CoeTCₓ.coe.{1, succ u1} Nat α (Nat.castCoe.{u1} α (AddMonoidWithOne.toNatCast.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α _inst_1)))))) n)) -> (forall (n : Int), Eq.{succ u1} α (f ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Int β (HasLiftT.mk.{1, succ u2} Int β (CoeTCₓ.coe.{1, succ u2} Int β (Int.castCoe.{u2} β _inst_11))) n)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int α (HasLiftT.mk.{1, succ u1} Int α (CoeTCₓ.coe.{1, succ u1} Int α (Int.castCoe.{u1} α (AddGroupWithOne.toHasIntCast.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α _inst_1))))) n)) -> (NonAssocRing.{u2} β)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonAssocRing.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Neg.{u2} β] [_inst_7 : Sub.{u2} β] [_inst_8 : SMul.{0, u2} Nat β] [_inst_9 : SMul.{0, u2} Int β] [_inst_10 : NatCast.{u2} β] [_inst_11 : IntCast.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β _inst_2))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (MulZeroOneClass.toZero.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α (NonAssocRing.toNonAssocSemiring.{u1} α _inst_1)))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β _inst_3))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (NonAssocRing.toOne.{u1} α _inst_1)))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α _inst_1))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α _inst_1))) (f x) (f y))) -> (forall (x : β), Eq.{succ u1} α (f (Neg.neg.{u2} β _inst_6 x)) (Neg.neg.{u1} α (AddGroupWithOne.toNeg.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α _inst_1)) (f x))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_7) x y)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (AddGroupWithOne.toSub.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α _inst_1))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Nat β β (instHSMul.{0, u2} Nat β _inst_8) n x)) (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α _inst_1))))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Int β β (instHSMul.{0, u2} Int β _inst_9) n x)) (HSMul.hSMul.{0, u1, u1} Int α α (instHSMul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α _inst_1))))) n (f x))) -> (forall (n : Nat), Eq.{succ u1} α (f (Nat.cast.{u2} β _inst_10 n)) (Nat.cast.{u1} α (NonAssocRing.toNatCast.{u1} α _inst_1) n)) -> (forall (n : Int), Eq.{succ u1} α (f (Int.cast.{u2} β _inst_11 n)) (Int.cast.{u1} α (NonAssocRing.toIntCast.{u1} α _inst_1) n)) -> (NonAssocRing.{u2} β)
Case conversion may be inaccurate. Consider using '#align function.injective.non_assoc_ring Function.Injective.nonAssocRingₓ'. -/
/-- Pullback a `non_assoc_ring` instance along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.nonAssocRing [Zero β] [One β] [Add β] [Mul β] [Neg β] [Sub β]
    [SMul ℕ β] [SMul ℤ β] [NatCast β] [IntCast β] (f : β → α) (hf : Injective f) (zero : f 0 = 0)
    (one : f 1 = 1) (add : ∀ x y, f (x + y) = f x + f y) (mul : ∀ x y, f (x * y) = f x * f y)
    (neg : ∀ x, f (-x) = -f x) (sub : ∀ x y, f (x - y) = f x - f y)
    (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) (gsmul : ∀ (x) (n : ℤ), f (n • x) = n • f x)
    (nat_cast : ∀ n : ℕ, f n = n) (int_cast : ∀ n : ℤ, f n = n) : NonAssocRing β :=
  { hf.AddCommGroup f zero add neg sub nsmul gsmul,
    hf.AddGroupWithOne f zero one add neg sub nsmul gsmul nat_cast int_cast,
    hf.MulZeroClass f zero mul, hf.Distrib f add mul, hf.MulOneClass f one mul with }
#align function.injective.non_assoc_ring Function.Injective.nonAssocRing

/- warning: function.surjective.non_assoc_ring -> Function.Surjective.nonAssocRing is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonAssocRing.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Neg.{u2} β] [_inst_7 : Sub.{u2} β] [_inst_8 : SMul.{0, u2} Nat β] [_inst_9 : SMul.{0, u2} Int β] [_inst_10 : NatCast.{u2} β] [_inst_11 : IntCast.{u2} β] (f : α -> β), (Function.Surjective.{succ u1, succ u2} α β f) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α _inst_1)))))))) (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β _inst_2)))) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α _inst_1))))))) (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β _inst_3)))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α _inst_1))))) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α _inst_1))))) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) (f x) (f y))) -> (forall (x : α), Eq.{succ u2} β (f (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α _inst_1)))) x)) (Neg.neg.{u2} β _inst_6 (f x))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α _inst_1))))) x y)) (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_7) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ u2} β (f (SMul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α _inst_1)))) n x)) (SMul.smul.{0, u2} Nat β _inst_8 n (f x))) -> (forall (x : α) (n : Int), Eq.{succ u2} β (f (SMul.smul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α _inst_1)))) n x)) (SMul.smul.{0, u2} Int β _inst_9 n (f x))) -> (forall (n : Nat), Eq.{succ u2} β (f ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u1} Nat α (CoeTCₓ.coe.{1, succ u1} Nat α (Nat.castCoe.{u1} α (AddMonoidWithOne.toNatCast.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α _inst_1)))))) n)) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat β (HasLiftT.mk.{1, succ u2} Nat β (CoeTCₓ.coe.{1, succ u2} Nat β (Nat.castCoe.{u2} β _inst_10))) n)) -> (forall (n : Int), Eq.{succ u2} β (f ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int α (HasLiftT.mk.{1, succ u1} Int α (CoeTCₓ.coe.{1, succ u1} Int α (Int.castCoe.{u1} α (AddGroupWithOne.toHasIntCast.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α _inst_1))))) n)) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Int β (HasLiftT.mk.{1, succ u2} Int β (CoeTCₓ.coe.{1, succ u2} Int β (Int.castCoe.{u2} β _inst_11))) n)) -> (NonAssocRing.{u2} β)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonAssocRing.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Neg.{u2} β] [_inst_7 : Sub.{u2} β] [_inst_8 : SMul.{0, u2} Nat β] [_inst_9 : SMul.{0, u2} Int β] [_inst_10 : NatCast.{u2} β] [_inst_11 : IntCast.{u2} β] (f : α -> β), (Function.Surjective.{succ u1, succ u2} α β f) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (MulZeroOneClass.toZero.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α (NonAssocRing.toNonAssocSemiring.{u1} α _inst_1)))))) (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β _inst_2))) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (NonAssocRing.toOne.{u1} α _inst_1)))) (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β _inst_3))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α _inst_1))))) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α _inst_1))) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) (f x) (f y))) -> (forall (x : α), Eq.{succ u2} β (f (Neg.neg.{u1} α (AddGroupWithOne.toNeg.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α _inst_1)) x)) (Neg.neg.{u2} β _inst_6 (f x))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (AddGroupWithOne.toSub.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α _inst_1))) x y)) (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_7) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ u2} β (f (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α _inst_1))))) n x)) (HSMul.hSMul.{0, u2, u2} Nat β β (instHSMul.{0, u2} Nat β _inst_8) n (f x))) -> (forall (x : α) (n : Int), Eq.{succ u2} β (f (HSMul.hSMul.{0, u1, u1} Int α α (instHSMul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α _inst_1))))) n x)) (HSMul.hSMul.{0, u2, u2} Int β β (instHSMul.{0, u2} Int β _inst_9) n (f x))) -> (forall (n : Nat), Eq.{succ u2} β (f (Nat.cast.{u1} α (NonAssocRing.toNatCast.{u1} α _inst_1) n)) (Nat.cast.{u2} β _inst_10 n)) -> (forall (n : Int), Eq.{succ u2} β (f (Int.cast.{u1} α (NonAssocRing.toIntCast.{u1} α _inst_1) n)) (Int.cast.{u2} β _inst_11 n)) -> (NonAssocRing.{u2} β)
Case conversion may be inaccurate. Consider using '#align function.surjective.non_assoc_ring Function.Surjective.nonAssocRingₓ'. -/
/-- Pushforward a `non_unital_ring` instance along a surjective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Surjective.nonAssocRing [Zero β] [One β] [Add β] [Mul β] [Neg β] [Sub β]
    [SMul ℕ β] [SMul ℤ β] [NatCast β] [IntCast β] (f : α → β) (hf : Surjective f) (zero : f 0 = 0)
    (one : f 1 = 1) (add : ∀ x y, f (x + y) = f x + f y) (mul : ∀ x y, f (x * y) = f x * f y)
    (neg : ∀ x, f (-x) = -f x) (sub : ∀ x y, f (x - y) = f x - f y)
    (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) (gsmul : ∀ (x) (n : ℤ), f (n • x) = n • f x)
    (nat_cast : ∀ n : ℕ, f n = n) (int_cast : ∀ n : ℤ, f n = n) : NonAssocRing β :=
  { hf.AddCommGroup f zero add neg sub nsmul gsmul, hf.MulZeroClass f zero mul,
    hf.AddGroupWithOne f zero one add neg sub nsmul gsmul nat_cast int_cast, hf.Distrib f add mul,
    hf.MulOneClass f one mul with }
#align function.surjective.non_assoc_ring Function.Surjective.nonAssocRing

end NonAssocRing

section Ring

variable [Ring α] {a b c d e : α}

/- warning: function.injective.ring -> Function.Injective.ring is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Ring.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Neg.{u2} β] [_inst_7 : Sub.{u2} β] [_inst_8 : SMul.{0, u2} Nat β] [_inst_9 : SMul.{0, u2} Int β] [_inst_10 : Pow.{u2, 0} β Nat] [_inst_11 : NatCast.{u2} β] [_inst_12 : IntCast.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β _inst_2)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))))))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β _inst_3)))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)))))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α _inst_1))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α _inst_1))) (f x) (f y))) -> (forall (x : β), Eq.{succ u1} α (f (Neg.neg.{u2} β _inst_6 x)) (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))))) (f x))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_7) x y)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (SMul.smul.{0, u2} Nat β _inst_8 n x)) (SMul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u1} α (f (SMul.smul.{0, u2} Int β _inst_9 n x)) (SMul.smul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_10) x n)) (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (Ring.toMonoid.{u1} α _inst_1))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} α (f ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat β (HasLiftT.mk.{1, succ u2} Nat β (CoeTCₓ.coe.{1, succ u2} Nat β (Nat.castCoe.{u2} β _inst_11))) n)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u1} Nat α (CoeTCₓ.coe.{1, succ u1} Nat α (Nat.castCoe.{u1} α (AddMonoidWithOne.toNatCast.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))))))) n)) -> (forall (n : Int), Eq.{succ u1} α (f ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Int β (HasLiftT.mk.{1, succ u2} Int β (CoeTCₓ.coe.{1, succ u2} Int β (Int.castCoe.{u2} β _inst_12))) n)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int α (HasLiftT.mk.{1, succ u1} Int α (CoeTCₓ.coe.{1, succ u1} Int α (Int.castCoe.{u1} α (AddGroupWithOne.toHasIntCast.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)))))) n)) -> (Ring.{u2} β)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Ring.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Neg.{u2} β] [_inst_7 : Sub.{u2} β] [_inst_8 : SMul.{0, u2} Nat β] [_inst_9 : SMul.{0, u2} Int β] [_inst_10 : Pow.{u2, 0} β Nat] [_inst_11 : NatCast.{u2} β] [_inst_12 : IntCast.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β _inst_2))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α _inst_1)))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β _inst_3))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (NonAssocRing.toOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)))) (f x) (f y))) -> (forall (x : β), Eq.{succ u1} α (f (Neg.neg.{u2} β _inst_6 x)) (Neg.neg.{u1} α (Ring.toNeg.{u1} α _inst_1) (f x))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_7) x y)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (Ring.toSub.{u1} α _inst_1)) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Nat β β (instHSMul.{0, u2} Nat β _inst_8) n x)) (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α _inst_1))))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Int β β (instHSMul.{0, u2} Int β _inst_9) n x)) (HSMul.hSMul.{0, u1, u1} Int α α (instHSMul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (Ring.toAddGroupWithOne.{u1} α _inst_1))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_10) x n)) (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (MonoidWithZero.toMonoid.{u1} α (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α _inst_1))))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} α (f (Nat.cast.{u2} β _inst_11 n)) (Nat.cast.{u1} α (NonAssocRing.toNatCast.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)) n)) -> (forall (n : Int), Eq.{succ u1} α (f (Int.cast.{u2} β _inst_12 n)) (Int.cast.{u1} α (Ring.toIntCast.{u1} α _inst_1) n)) -> (Ring.{u2} β)
Case conversion may be inaccurate. Consider using '#align function.injective.ring Function.Injective.ringₓ'. -/
/-- Pullback a `ring` instance along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.ring [Zero β] [One β] [Add β] [Mul β] [Neg β] [Sub β] [SMul ℕ β]
    [SMul ℤ β] [Pow β ℕ] [NatCast β] [IntCast β] (f : β → α) (hf : Injective f) (zero : f 0 = 0)
    (one : f 1 = 1) (add : ∀ x y, f (x + y) = f x + f y) (mul : ∀ x y, f (x * y) = f x * f y)
    (neg : ∀ x, f (-x) = -f x) (sub : ∀ x y, f (x - y) = f x - f y)
    (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) (zsmul : ∀ (x) (n : ℤ), f (n • x) = n • f x)
    (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n) (nat_cast : ∀ n : ℕ, f n = n)
    (int_cast : ∀ n : ℤ, f n = n) : Ring β :=
  { hf.AddGroupWithOne f zero one add neg sub nsmul zsmul nat_cast int_cast,
    hf.AddCommGroup f zero add neg sub nsmul zsmul, hf.Monoid f one mul npow,
    hf.Distrib f add mul with }
#align function.injective.ring Function.Injective.ring

/- warning: function.surjective.ring -> Function.Surjective.ring is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Ring.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Neg.{u2} β] [_inst_7 : Sub.{u2} β] [_inst_8 : SMul.{0, u2} Nat β] [_inst_9 : SMul.{0, u2} Int β] [_inst_10 : Pow.{u2, 0} β Nat] [_inst_11 : NatCast.{u2} β] [_inst_12 : IntCast.{u2} β] (f : α -> β), (Function.Surjective.{succ u1, succ u2} α β f) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))))))))) (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β _inst_2)))) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)))))))) (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β _inst_3)))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α _inst_1))) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α _inst_1))) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) (f x) (f y))) -> (forall (x : α), Eq.{succ u2} β (f (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))))) x)) (Neg.neg.{u2} β _inst_6 (f x))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)))))) x y)) (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_7) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ u2} β (f (SMul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))))) n x)) (SMul.smul.{0, u2} Nat β _inst_8 n (f x))) -> (forall (x : α) (n : Int), Eq.{succ u2} β (f (SMul.smul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))))) n x)) (SMul.smul.{0, u2} Int β _inst_9 n (f x))) -> (forall (x : α) (n : Nat), Eq.{succ u2} β (f (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (Ring.toMonoid.{u1} α _inst_1))) x n)) (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_10) (f x) n)) -> (forall (n : Nat), Eq.{succ u2} β (f ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u1} Nat α (CoeTCₓ.coe.{1, succ u1} Nat α (Nat.castCoe.{u1} α (AddMonoidWithOne.toNatCast.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))))))) n)) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat β (HasLiftT.mk.{1, succ u2} Nat β (CoeTCₓ.coe.{1, succ u2} Nat β (Nat.castCoe.{u2} β _inst_11))) n)) -> (forall (n : Int), Eq.{succ u2} β (f ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int α (HasLiftT.mk.{1, succ u1} Int α (CoeTCₓ.coe.{1, succ u1} Int α (Int.castCoe.{u1} α (AddGroupWithOne.toHasIntCast.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)))))) n)) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Int β (HasLiftT.mk.{1, succ u2} Int β (CoeTCₓ.coe.{1, succ u2} Int β (Int.castCoe.{u2} β _inst_12))) n)) -> (Ring.{u2} β)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Ring.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Neg.{u2} β] [_inst_7 : Sub.{u2} β] [_inst_8 : SMul.{0, u2} Nat β] [_inst_9 : SMul.{0, u2} Int β] [_inst_10 : Pow.{u2, 0} β Nat] [_inst_11 : NatCast.{u2} β] [_inst_12 : IntCast.{u2} β] (f : α -> β), (Function.Surjective.{succ u1, succ u2} α β f) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α _inst_1)))))) (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β _inst_2))) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (NonAssocRing.toOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))))) (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β _inst_3))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)))))) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)))) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) (f x) (f y))) -> (forall (x : α), Eq.{succ u2} β (f (Neg.neg.{u1} α (Ring.toNeg.{u1} α _inst_1) x)) (Neg.neg.{u2} β _inst_6 (f x))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (Ring.toSub.{u1} α _inst_1)) x y)) (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_7) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ u2} β (f (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α _inst_1))))) n x)) (HSMul.hSMul.{0, u2, u2} Nat β β (instHSMul.{0, u2} Nat β _inst_8) n (f x))) -> (forall (x : α) (n : Int), Eq.{succ u2} β (f (HSMul.hSMul.{0, u1, u1} Int α α (instHSMul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (Ring.toAddGroupWithOne.{u1} α _inst_1))))) n x)) (HSMul.hSMul.{0, u2, u2} Int β β (instHSMul.{0, u2} Int β _inst_9) n (f x))) -> (forall (x : α) (n : Nat), Eq.{succ u2} β (f (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (MonoidWithZero.toMonoid.{u1} α (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α _inst_1))))) x n)) (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_10) (f x) n)) -> (forall (n : Nat), Eq.{succ u2} β (f (Nat.cast.{u1} α (NonAssocRing.toNatCast.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)) n)) (Nat.cast.{u2} β _inst_11 n)) -> (forall (n : Int), Eq.{succ u2} β (f (Int.cast.{u1} α (Ring.toIntCast.{u1} α _inst_1) n)) (Int.cast.{u2} β _inst_12 n)) -> (Ring.{u2} β)
Case conversion may be inaccurate. Consider using '#align function.surjective.ring Function.Surjective.ringₓ'. -/
/-- Pushforward a `ring` instance along a surjective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Surjective.ring [Zero β] [One β] [Add β] [Mul β] [Neg β] [Sub β] [SMul ℕ β]
    [SMul ℤ β] [Pow β ℕ] [NatCast β] [IntCast β] (f : α → β) (hf : Surjective f) (zero : f 0 = 0)
    (one : f 1 = 1) (add : ∀ x y, f (x + y) = f x + f y) (mul : ∀ x y, f (x * y) = f x * f y)
    (neg : ∀ x, f (-x) = -f x) (sub : ∀ x y, f (x - y) = f x - f y)
    (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) (zsmul : ∀ (x) (n : ℤ), f (n • x) = n • f x)
    (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n) (nat_cast : ∀ n : ℕ, f n = n)
    (int_cast : ∀ n : ℤ, f n = n) : Ring β :=
  { hf.AddGroupWithOne f zero one add neg sub nsmul zsmul nat_cast int_cast,
    hf.AddCommGroup f zero add neg sub nsmul zsmul, hf.Monoid f one mul npow,
    hf.Distrib f add mul with }
#align function.surjective.ring Function.Surjective.ring

end Ring

section NonUnitalCommRing

variable [NonUnitalCommRing α] {a b c : α}

/- warning: function.injective.non_unital_comm_ring -> Function.Injective.nonUnitalCommRing is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonUnitalCommRing.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : Add.{u2} β] [_inst_4 : Mul.{u2} β] [_inst_5 : Neg.{u2} β] [_inst_6 : Sub.{u2} β] [_inst_7 : SMul.{0, u2} Nat β] [_inst_8 : SMul.{0, u2} Int β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β _inst_2)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α (NonUnitalCommRing.toNonUnitalRing.{u1} α _inst_1))))))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_3) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α (NonUnitalCommRing.toNonUnitalRing.{u1} α _inst_1)))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_4) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α (NonUnitalCommRing.toNonUnitalRing.{u1} α _inst_1)))))) (f x) (f y))) -> (forall (x : β), Eq.{succ u1} α (f (Neg.neg.{u2} β _inst_5 x)) (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α (NonUnitalCommRing.toNonUnitalRing.{u1} α _inst_1)))))) (f x))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_6) x y)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α (NonUnitalCommRing.toNonUnitalRing.{u1} α _inst_1))))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (SMul.smul.{0, u2} Nat β _inst_7 n x)) (SMul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α (NonUnitalCommRing.toNonUnitalRing.{u1} α _inst_1))))))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u1} α (f (SMul.smul.{0, u2} Int β _inst_8 n x)) (SMul.smul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α (NonUnitalCommRing.toNonUnitalRing.{u1} α _inst_1)))))) n (f x))) -> (NonUnitalCommRing.{u2} β)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonUnitalCommRing.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : Add.{u2} β] [_inst_4 : Mul.{u2} β] [_inst_5 : Neg.{u2} β] [_inst_6 : Sub.{u2} β] [_inst_7 : SMul.{0, u2} Nat β] [_inst_8 : SMul.{0, u2} Int β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β _inst_2))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (SemigroupWithZero.toZero.{u1} α (NonUnitalSemiring.toSemigroupWithZero.{u1} α (NonUnitalRing.toNonUnitalSemiring.{u1} α (NonUnitalCommRing.toNonUnitalRing.{u1} α _inst_1))))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_3) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α (NonUnitalCommRing.toNonUnitalRing.{u1} α _inst_1)))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_4) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α (NonUnitalCommRing.toNonUnitalRing.{u1} α _inst_1)))) (f x) (f y))) -> (forall (x : β), Eq.{succ u1} α (f (Neg.neg.{u2} β _inst_5 x)) (Neg.neg.{u1} α (NegZeroClass.toNeg.{u1} α (SubNegZeroMonoid.toNegZeroClass.{u1} α (SubtractionMonoid.toSubNegZeroMonoid.{u1} α (SubtractionCommMonoid.toSubtractionMonoid.{u1} α (AddCommGroup.toDivisionAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α (NonUnitalCommRing.toNonUnitalRing.{u1} α _inst_1)))))))) (f x))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_6) x y)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α (NonUnitalCommRing.toNonUnitalRing.{u1} α _inst_1))))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Nat β β (instHSMul.{0, u2} Nat β _inst_7) n x)) (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α (NonUnitalCommRing.toNonUnitalRing.{u1} α _inst_1)))))))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Int β β (instHSMul.{0, u2} Int β _inst_8) n x)) (HSMul.hSMul.{0, u1, u1} Int α α (instHSMul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α (NonUnitalCommRing.toNonUnitalRing.{u1} α _inst_1))))))) n (f x))) -> (NonUnitalCommRing.{u2} β)
Case conversion may be inaccurate. Consider using '#align function.injective.non_unital_comm_ring Function.Injective.nonUnitalCommRingₓ'. -/
/-- Pullback a `comm_ring` instance along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.nonUnitalCommRing [Zero β] [Add β] [Mul β] [Neg β] [Sub β]
    [SMul ℕ β] [SMul ℤ β] (f : β → α) (hf : Injective f) (zero : f 0 = 0)
    (add : ∀ x y, f (x + y) = f x + f y) (mul : ∀ x y, f (x * y) = f x * f y)
    (neg : ∀ x, f (-x) = -f x) (sub : ∀ x y, f (x - y) = f x - f y)
    (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) (zsmul : ∀ (x) (n : ℤ), f (n • x) = n • f x) :
    NonUnitalCommRing β :=
  { hf.NonUnitalRing f zero add mul neg sub nsmul zsmul, hf.CommSemigroup f mul with }
#align function.injective.non_unital_comm_ring Function.Injective.nonUnitalCommRing

/- warning: function.surjective.non_unital_comm_ring -> Function.Surjective.nonUnitalCommRing is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonUnitalCommRing.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : Add.{u2} β] [_inst_4 : Mul.{u2} β] [_inst_5 : Neg.{u2} β] [_inst_6 : Sub.{u2} β] [_inst_7 : SMul.{0, u2} Nat β] [_inst_8 : SMul.{0, u2} Int β] (f : α -> β), (Function.Surjective.{succ u1, succ u2} α β f) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α (NonUnitalCommRing.toNonUnitalRing.{u1} α _inst_1))))))))) (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β _inst_2)))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α (NonUnitalCommRing.toNonUnitalRing.{u1} α _inst_1)))))) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_3) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α (NonUnitalCommRing.toNonUnitalRing.{u1} α _inst_1)))))) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_4) (f x) (f y))) -> (forall (x : α), Eq.{succ u2} β (f (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α (NonUnitalCommRing.toNonUnitalRing.{u1} α _inst_1)))))) x)) (Neg.neg.{u2} β _inst_5 (f x))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α (NonUnitalCommRing.toNonUnitalRing.{u1} α _inst_1))))))) x y)) (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_6) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ u2} β (f (SMul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α (NonUnitalCommRing.toNonUnitalRing.{u1} α _inst_1))))))) n x)) (SMul.smul.{0, u2} Nat β _inst_7 n (f x))) -> (forall (x : α) (n : Int), Eq.{succ u2} β (f (SMul.smul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α (NonUnitalCommRing.toNonUnitalRing.{u1} α _inst_1)))))) n x)) (SMul.smul.{0, u2} Int β _inst_8 n (f x))) -> (NonUnitalCommRing.{u2} β)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonUnitalCommRing.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : Add.{u2} β] [_inst_4 : Mul.{u2} β] [_inst_5 : Neg.{u2} β] [_inst_6 : Sub.{u2} β] [_inst_7 : SMul.{0, u2} Nat β] [_inst_8 : SMul.{0, u2} Int β] (f : α -> β), (Function.Surjective.{succ u1, succ u2} α β f) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (SemigroupWithZero.toZero.{u1} α (NonUnitalSemiring.toSemigroupWithZero.{u1} α (NonUnitalRing.toNonUnitalSemiring.{u1} α (NonUnitalCommRing.toNonUnitalRing.{u1} α _inst_1))))))) (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β _inst_2))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α (NonUnitalCommRing.toNonUnitalRing.{u1} α _inst_1)))))) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_3) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α (NonUnitalCommRing.toNonUnitalRing.{u1} α _inst_1)))) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_4) (f x) (f y))) -> (forall (x : α), Eq.{succ u2} β (f (Neg.neg.{u1} α (NegZeroClass.toNeg.{u1} α (SubNegZeroMonoid.toNegZeroClass.{u1} α (SubtractionMonoid.toSubNegZeroMonoid.{u1} α (SubtractionCommMonoid.toSubtractionMonoid.{u1} α (AddCommGroup.toDivisionAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α (NonUnitalCommRing.toNonUnitalRing.{u1} α _inst_1)))))))) x)) (Neg.neg.{u2} β _inst_5 (f x))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α (NonUnitalCommRing.toNonUnitalRing.{u1} α _inst_1))))))) x y)) (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_6) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ u2} β (f (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α (NonUnitalCommRing.toNonUnitalRing.{u1} α _inst_1)))))))) n x)) (HSMul.hSMul.{0, u2, u2} Nat β β (instHSMul.{0, u2} Nat β _inst_7) n (f x))) -> (forall (x : α) (n : Int), Eq.{succ u2} β (f (HSMul.hSMul.{0, u1, u1} Int α α (instHSMul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α (NonUnitalCommRing.toNonUnitalRing.{u1} α _inst_1))))))) n x)) (HSMul.hSMul.{0, u2, u2} Int β β (instHSMul.{0, u2} Int β _inst_8) n (f x))) -> (NonUnitalCommRing.{u2} β)
Case conversion may be inaccurate. Consider using '#align function.surjective.non_unital_comm_ring Function.Surjective.nonUnitalCommRingₓ'. -/
/-- Pushforward a `non_unital_comm_ring` instance along a surjective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Surjective.nonUnitalCommRing [Zero β] [Add β] [Mul β] [Neg β] [Sub β]
    [SMul ℕ β] [SMul ℤ β] (f : α → β) (hf : Surjective f) (zero : f 0 = 0)
    (add : ∀ x y, f (x + y) = f x + f y) (mul : ∀ x y, f (x * y) = f x * f y)
    (neg : ∀ x, f (-x) = -f x) (sub : ∀ x y, f (x - y) = f x - f y)
    (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) (zsmul : ∀ (x) (n : ℤ), f (n • x) = n • f x) :
    NonUnitalCommRing β :=
  { hf.NonUnitalRing f zero add mul neg sub nsmul zsmul, hf.CommSemigroup f mul with }
#align function.surjective.non_unital_comm_ring Function.Surjective.nonUnitalCommRing

end NonUnitalCommRing

section CommRing

variable [CommRing α] {a b c : α}

/- warning: function.injective.comm_ring -> Function.Injective.commRing is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : CommRing.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Neg.{u2} β] [_inst_7 : Sub.{u2} β] [_inst_8 : SMul.{0, u2} Nat β] [_inst_9 : SMul.{0, u2} Int β] [_inst_10 : Pow.{u2, 0} β Nat] [_inst_11 : NatCast.{u2} β] [_inst_12 : IntCast.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β _inst_2)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1)))))))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β _inst_3)))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (CommRing.toRing.{u1} α _inst_1)))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α (CommRing.toRing.{u1} α _inst_1)))) (f x) (f y))) -> (forall (x : β), Eq.{succ u1} α (f (Neg.neg.{u2} β _inst_6 x)) (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1)))))) (f x))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_7) x y)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (SMul.smul.{0, u2} Nat β _inst_8 n x)) (SMul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1)))))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u1} α (f (SMul.smul.{0, u2} Int β _inst_9 n x)) (SMul.smul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1)))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_10) x n)) (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (Ring.toMonoid.{u1} α (CommRing.toRing.{u1} α _inst_1)))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} α (f ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat β (HasLiftT.mk.{1, succ u2} Nat β (CoeTCₓ.coe.{1, succ u2} Nat β (Nat.castCoe.{u2} β _inst_11))) n)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u1} Nat α (CoeTCₓ.coe.{1, succ u1} Nat α (Nat.castCoe.{u1} α (AddMonoidWithOne.toNatCast.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1)))))))) n)) -> (forall (n : Int), Eq.{succ u1} α (f ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Int β (HasLiftT.mk.{1, succ u2} Int β (CoeTCₓ.coe.{1, succ u2} Int β (Int.castCoe.{u2} β _inst_12))) n)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int α (HasLiftT.mk.{1, succ u1} Int α (CoeTCₓ.coe.{1, succ u1} Int α (Int.castCoe.{u1} α (AddGroupWithOne.toHasIntCast.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) n)) -> (CommRing.{u2} β)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : CommRing.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Neg.{u2} β] [_inst_7 : Sub.{u2} β] [_inst_8 : SMul.{0, u2} Nat β] [_inst_9 : SMul.{0, u2} Int β] [_inst_10 : Pow.{u2, 0} β Nat] [_inst_11 : NatCast.{u2} β] [_inst_12 : IntCast.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β _inst_2))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (CommMonoidWithZero.toZero.{u1} α (CommSemiring.toCommMonoidWithZero.{u1} α (CommRing.toCommSemiring.{u1} α _inst_1)))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β _inst_3))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (NonAssocRing.toOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1)))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))) (f x) (f y))) -> (forall (x : β), Eq.{succ u1} α (f (Neg.neg.{u2} β _inst_6 x)) (Neg.neg.{u1} α (Ring.toNeg.{u1} α (CommRing.toRing.{u1} α _inst_1)) (f x))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_7) x y)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (Ring.toSub.{u1} α (CommRing.toRing.{u1} α _inst_1))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Nat β β (instHSMul.{0, u2} Nat β _inst_8) n x)) (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_1)))))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Int β β (instHSMul.{0, u2} Int β _inst_9) n x)) (HSMul.hSMul.{0, u1, u1} Int α α (instHSMul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (Ring.toAddGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_1)))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_10) x n)) (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (MonoidWithZero.toMonoid.{u1} α (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α _inst_1)))))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} α (f (Nat.cast.{u2} β _inst_11 n)) (Nat.cast.{u1} α (NonAssocRing.toNatCast.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))) n)) -> (forall (n : Int), Eq.{succ u1} α (f (Int.cast.{u2} β _inst_12 n)) (Int.cast.{u1} α (Ring.toIntCast.{u1} α (CommRing.toRing.{u1} α _inst_1)) n)) -> (CommRing.{u2} β)
Case conversion may be inaccurate. Consider using '#align function.injective.comm_ring Function.Injective.commRingₓ'. -/
/-- Pullback a `comm_ring` instance along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.commRing [Zero β] [One β] [Add β] [Mul β] [Neg β] [Sub β]
    [SMul ℕ β] [SMul ℤ β] [Pow β ℕ] [NatCast β] [IntCast β] (f : β → α) (hf : Injective f)
    (zero : f 0 = 0) (one : f 1 = 1) (add : ∀ x y, f (x + y) = f x + f y)
    (mul : ∀ x y, f (x * y) = f x * f y) (neg : ∀ x, f (-x) = -f x)
    (sub : ∀ x y, f (x - y) = f x - f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x)
    (zsmul : ∀ (x) (n : ℤ), f (n • x) = n • f x) (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n)
    (nat_cast : ∀ n : ℕ, f n = n) (int_cast : ∀ n : ℤ, f n = n) : CommRing β :=
  { hf.Ring f zero one add mul neg sub nsmul zsmul npow nat_cast int_cast,
    hf.CommSemigroup f mul with }
#align function.injective.comm_ring Function.Injective.commRing

/- warning: function.surjective.comm_ring -> Function.Surjective.commRing is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : CommRing.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Neg.{u2} β] [_inst_7 : Sub.{u2} β] [_inst_8 : SMul.{0, u2} Nat β] [_inst_9 : SMul.{0, u2} Int β] [_inst_10 : Pow.{u2, 0} β Nat] [_inst_11 : NatCast.{u2} β] [_inst_12 : IntCast.{u2} β] (f : α -> β), (Function.Surjective.{succ u1, succ u2} α β f) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1)))))))))) (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β _inst_2)))) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))))) (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β _inst_3)))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (CommRing.toRing.{u1} α _inst_1)))) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α (CommRing.toRing.{u1} α _inst_1)))) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) (f x) (f y))) -> (forall (x : α), Eq.{succ u2} β (f (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1)))))) x)) (Neg.neg.{u2} β _inst_6 (f x))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) x y)) (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_7) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ u2} β (f (SMul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1)))))) n x)) (SMul.smul.{0, u2} Nat β _inst_8 n (f x))) -> (forall (x : α) (n : Int), Eq.{succ u2} β (f (SMul.smul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1)))))) n x)) (SMul.smul.{0, u2} Int β _inst_9 n (f x))) -> (forall (x : α) (n : Nat), Eq.{succ u2} β (f (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (Ring.toMonoid.{u1} α (CommRing.toRing.{u1} α _inst_1)))) x n)) (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_10) (f x) n)) -> (forall (n : Nat), Eq.{succ u2} β (f ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u1} Nat α (CoeTCₓ.coe.{1, succ u1} Nat α (Nat.castCoe.{u1} α (AddMonoidWithOne.toNatCast.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1)))))))) n)) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat β (HasLiftT.mk.{1, succ u2} Nat β (CoeTCₓ.coe.{1, succ u2} Nat β (Nat.castCoe.{u2} β _inst_11))) n)) -> (forall (n : Int), Eq.{succ u2} β (f ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int α (HasLiftT.mk.{1, succ u1} Int α (CoeTCₓ.coe.{1, succ u1} Int α (Int.castCoe.{u1} α (AddGroupWithOne.toHasIntCast.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) n)) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Int β (HasLiftT.mk.{1, succ u2} Int β (CoeTCₓ.coe.{1, succ u2} Int β (Int.castCoe.{u2} β _inst_12))) n)) -> (CommRing.{u2} β)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : CommRing.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Neg.{u2} β] [_inst_7 : Sub.{u2} β] [_inst_8 : SMul.{0, u2} Nat β] [_inst_9 : SMul.{0, u2} Int β] [_inst_10 : Pow.{u2, 0} β Nat] [_inst_11 : NatCast.{u2} β] [_inst_12 : IntCast.{u2} β] (f : α -> β), (Function.Surjective.{succ u1, succ u2} α β f) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (CommMonoidWithZero.toZero.{u1} α (CommSemiring.toCommMonoidWithZero.{u1} α (CommRing.toCommSemiring.{u1} α _inst_1)))))) (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β _inst_2))) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (NonAssocRing.toOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1)))))) (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β _inst_3))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) (f x) (f y))) -> (forall (x : α), Eq.{succ u2} β (f (Neg.neg.{u1} α (Ring.toNeg.{u1} α (CommRing.toRing.{u1} α _inst_1)) x)) (Neg.neg.{u2} β _inst_6 (f x))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (Ring.toSub.{u1} α (CommRing.toRing.{u1} α _inst_1))) x y)) (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_7) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ u2} β (f (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_1)))))) n x)) (HSMul.hSMul.{0, u2, u2} Nat β β (instHSMul.{0, u2} Nat β _inst_8) n (f x))) -> (forall (x : α) (n : Int), Eq.{succ u2} β (f (HSMul.hSMul.{0, u1, u1} Int α α (instHSMul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (Ring.toAddGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_1)))))) n x)) (HSMul.hSMul.{0, u2, u2} Int β β (instHSMul.{0, u2} Int β _inst_9) n (f x))) -> (forall (x : α) (n : Nat), Eq.{succ u2} β (f (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (MonoidWithZero.toMonoid.{u1} α (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α _inst_1)))))) x n)) (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_10) (f x) n)) -> (forall (n : Nat), Eq.{succ u2} β (f (Nat.cast.{u1} α (NonAssocRing.toNatCast.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))) n)) (Nat.cast.{u2} β _inst_11 n)) -> (forall (n : Int), Eq.{succ u2} β (f (Int.cast.{u1} α (Ring.toIntCast.{u1} α (CommRing.toRing.{u1} α _inst_1)) n)) (Int.cast.{u2} β _inst_12 n)) -> (CommRing.{u2} β)
Case conversion may be inaccurate. Consider using '#align function.surjective.comm_ring Function.Surjective.commRingₓ'. -/
/-- Pushforward a `comm_ring` instance along a surjective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Surjective.commRing [Zero β] [One β] [Add β] [Mul β] [Neg β] [Sub β]
    [SMul ℕ β] [SMul ℤ β] [Pow β ℕ] [NatCast β] [IntCast β] (f : α → β) (hf : Surjective f)
    (zero : f 0 = 0) (one : f 1 = 1) (add : ∀ x y, f (x + y) = f x + f y)
    (mul : ∀ x y, f (x * y) = f x * f y) (neg : ∀ x, f (-x) = -f x)
    (sub : ∀ x y, f (x - y) = f x - f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x)
    (zsmul : ∀ (x) (n : ℤ), f (n • x) = n • f x) (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n)
    (nat_cast : ∀ n : ℕ, f n = n) (int_cast : ∀ n : ℤ, f n = n) : CommRing β :=
  { hf.Ring f zero one add mul neg sub nsmul zsmul npow nat_cast int_cast,
    hf.CommSemigroup f mul with }
#align function.surjective.comm_ring Function.Surjective.commRing

end CommRing

