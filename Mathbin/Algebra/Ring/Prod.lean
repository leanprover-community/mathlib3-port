/-
Copyright (c) 2020 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes Hölzl, Chris Hughes, Mario Carneiro, Yury Kudryashov

! This file was ported from Lean 3 source module algebra.ring.prod
! leanprover-community/mathlib commit 369525b73f229ccd76a6ec0e0e0bf2be57599768
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Int.Cast.Prod
import Mathbin.Algebra.Group.Prod
import Mathbin.Algebra.Ring.Equiv
import Mathbin.Algebra.Order.Monoid.Prod

/-!
# Semiring, ring etc structures on `R × S`

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file we define two-binop (`semiring`, `ring` etc) structures on `R × S`. We also prove
trivial `simp` lemmas, and define the following operations on `ring_hom`s and similarly for
`non_unital_ring_hom`s:

* `fst R S : R × S →+* R`, `snd R S : R × S →+* S`: projections `prod.fst` and `prod.snd`
  as `ring_hom`s;
* `f.prod g : `R →+* S × T`: sends `x` to `(f x, g x)`;
* `f.prod_map g : `R × S → R' × S'`: `prod.map f g` as a `ring_hom`,
  sends `(x, y)` to `(f x, g y)`.
-/


variable {α β R R' S S' T T' : Type _}

namespace Prod

/-- Product of two distributive types is distributive. -/
instance [Distrib R] [Distrib S] : Distrib (R × S) :=
  { Prod.hasAdd,
    Prod.hasMul with
    left_distrib := fun a b c => mk.inj_iff.mpr ⟨left_distrib _ _ _, left_distrib _ _ _⟩
    right_distrib := fun a b c => mk.inj_iff.mpr ⟨right_distrib _ _ _, right_distrib _ _ _⟩ }

/-- Product of two `non_unital_non_assoc_semiring`s is a `non_unital_non_assoc_semiring`. -/
instance [NonUnitalNonAssocSemiring R] [NonUnitalNonAssocSemiring S] :
    NonUnitalNonAssocSemiring (R × S) :=
  { Prod.addCommMonoid, Prod.mulZeroClass, Prod.distrib with }

/-- Product of two `non_unital_semiring`s is a `non_unital_semiring`. -/
instance [NonUnitalSemiring R] [NonUnitalSemiring S] : NonUnitalSemiring (R × S) :=
  { Prod.nonUnitalNonAssocSemiring, Prod.semigroup with }

/-- Product of two `non_assoc_semiring`s is a `non_assoc_semiring`. -/
instance [NonAssocSemiring R] [NonAssocSemiring S] : NonAssocSemiring (R × S) :=
  { Prod.nonUnitalNonAssocSemiring, Prod.mulOneClass, Prod.addMonoidWithOne with }

/-- Product of two semirings is a semiring. -/
instance [Semiring R] [Semiring S] : Semiring (R × S) :=
  { Prod.addCommMonoid, Prod.monoidWithZero, Prod.distrib, Prod.addMonoidWithOne with }

/-- Product of two `non_unital_comm_semiring`s is a `non_unital_comm_semiring`. -/
instance [NonUnitalCommSemiring R] [NonUnitalCommSemiring S] : NonUnitalCommSemiring (R × S) :=
  { Prod.nonUnitalSemiring, Prod.commSemigroup with }

/-- Product of two commutative semirings is a commutative semiring. -/
instance [CommSemiring R] [CommSemiring S] : CommSemiring (R × S) :=
  { Prod.semiring, Prod.commMonoid with }

instance [NonUnitalNonAssocRing R] [NonUnitalNonAssocRing S] : NonUnitalNonAssocRing (R × S) :=
  { Prod.addCommGroup, Prod.nonUnitalNonAssocSemiring with }

instance [NonUnitalRing R] [NonUnitalRing S] : NonUnitalRing (R × S) :=
  { Prod.addCommGroup, Prod.nonUnitalSemiring with }

instance [NonAssocRing R] [NonAssocRing S] : NonAssocRing (R × S) :=
  { Prod.addCommGroup, Prod.nonAssocSemiring, Prod.addGroupWithOne with }

/-- Product of two rings is a ring. -/
instance [Ring R] [Ring S] : Ring (R × S) :=
  { Prod.addCommGroup, Prod.addGroupWithOne, Prod.semiring with }

/-- Product of two `non_unital_comm_ring`s is a `non_unital_comm_ring`. -/
instance [NonUnitalCommRing R] [NonUnitalCommRing S] : NonUnitalCommRing (R × S) :=
  { Prod.nonUnitalRing, Prod.commSemigroup with }

/-- Product of two commutative rings is a commutative ring. -/
instance [CommRing R] [CommRing S] : CommRing (R × S) :=
  { Prod.ring, Prod.commMonoid with }

end Prod

namespace NonUnitalRingHom

variable (R S) [NonUnitalNonAssocSemiring R] [NonUnitalNonAssocSemiring S]

/- warning: non_unital_ring_hom.fst -> NonUnitalRingHom.fst is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (S : Type.{u2}) [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S], NonUnitalRingHom.{max u1 u2, u1} (Prod.{u1, u2} R S) R (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) _inst_1
but is expected to have type
  forall (R : Type.{u1}) (S : Type.{u2}) [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S], NonUnitalRingHom.{max u2 u1, u1} (Prod.{u1, u2} R S) R (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2) _inst_1
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.fst NonUnitalRingHom.fstₓ'. -/
/-- Given non-unital semirings `R`, `S`, the natural projection homomorphism from `R × S` to `R`.-/
def fst : R × S →ₙ+* R :=
  { MulHom.fst R S, AddMonoidHom.fst R S with toFun := Prod.fst }
#align non_unital_ring_hom.fst NonUnitalRingHom.fst

/- warning: non_unital_ring_hom.snd -> NonUnitalRingHom.snd is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (S : Type.{u2}) [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S], NonUnitalRingHom.{max u1 u2, u2} (Prod.{u1, u2} R S) S (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) _inst_2
but is expected to have type
  forall (R : Type.{u1}) (S : Type.{u2}) [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S], NonUnitalRingHom.{max u2 u1, u2} (Prod.{u1, u2} R S) S (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2) _inst_2
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.snd NonUnitalRingHom.sndₓ'. -/
/-- Given non-unital semirings `R`, `S`, the natural projection homomorphism from `R × S` to `S`.-/
def snd : R × S →ₙ+* S :=
  { MulHom.snd R S, AddMonoidHom.snd R S with toFun := Prod.snd }
#align non_unital_ring_hom.snd NonUnitalRingHom.snd

variable {R S}

/- warning: non_unital_ring_hom.coe_fst -> NonUnitalRingHom.coe_fst is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S], Eq.{max (succ (max u1 u2)) (succ u1)} ((Prod.{u1, u2} R S) -> R) (coeFn.{max (succ (max u1 u2)) (succ u1), max (succ (max u1 u2)) (succ u1)} (NonUnitalRingHom.{max u1 u2, u1} (Prod.{u1, u2} R S) R (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) _inst_1) (fun (_x : NonUnitalRingHom.{max u1 u2, u1} (Prod.{u1, u2} R S) R (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) _inst_1) => (Prod.{u1, u2} R S) -> R) (NonUnitalRingHom.hasCoeToFun.{max u1 u2, u1} (Prod.{u1, u2} R S) R (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) _inst_1) (NonUnitalRingHom.fst.{u1, u2} R S _inst_1 _inst_2)) (Prod.fst.{u1, u2} R S)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u1} S], Eq.{max (succ u2) (succ u1)} (forall (ᾰ : Prod.{u2, u1} R S), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Prod.{u2, u1} R S) => R) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), succ u2} (NonUnitalRingHom.{max u1 u2, u2} (Prod.{u2, u1} R S) R (Prod.instNonUnitalNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2) _inst_1) (Prod.{u2, u1} R S) (fun (_x : Prod.{u2, u1} R S) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Prod.{u2, u1} R S) => R) _x) (MulHomClass.toFunLike.{max u2 u1, max u2 u1, u2} (NonUnitalRingHom.{max u1 u2, u2} (Prod.{u2, u1} R S) R (Prod.instNonUnitalNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2) _inst_1) (Prod.{u2, u1} R S) R (NonUnitalNonAssocSemiring.toMul.{max u2 u1} (Prod.{u2, u1} R S) (Prod.instNonUnitalNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, max u2 u1, u2} (NonUnitalRingHom.{max u1 u2, u2} (Prod.{u2, u1} R S) R (Prod.instNonUnitalNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2) _inst_1) (Prod.{u2, u1} R S) R (Prod.instNonUnitalNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2) _inst_1 (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{max u2 u1, u2} (Prod.{u2, u1} R S) R (Prod.instNonUnitalNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2) _inst_1))) (NonUnitalRingHom.fst.{u2, u1} R S _inst_1 _inst_2)) (Prod.fst.{u2, u1} R S)
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.coe_fst NonUnitalRingHom.coe_fstₓ'. -/
@[simp]
theorem coe_fst : ⇑(fst R S) = Prod.fst :=
  rfl
#align non_unital_ring_hom.coe_fst NonUnitalRingHom.coe_fst

/- warning: non_unital_ring_hom.coe_snd -> NonUnitalRingHom.coe_snd is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S], Eq.{max (succ (max u1 u2)) (succ u2)} ((Prod.{u1, u2} R S) -> S) (coeFn.{max (succ (max u1 u2)) (succ u2), max (succ (max u1 u2)) (succ u2)} (NonUnitalRingHom.{max u1 u2, u2} (Prod.{u1, u2} R S) S (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) _inst_2) (fun (_x : NonUnitalRingHom.{max u1 u2, u2} (Prod.{u1, u2} R S) S (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) _inst_2) => (Prod.{u1, u2} R S) -> S) (NonUnitalRingHom.hasCoeToFun.{max u1 u2, u2} (Prod.{u1, u2} R S) S (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) _inst_2) (NonUnitalRingHom.snd.{u1, u2} R S _inst_1 _inst_2)) (Prod.snd.{u1, u2} R S)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u1} S], Eq.{max (succ u2) (succ u1)} (forall (ᾰ : Prod.{u2, u1} R S), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Prod.{u2, u1} R S) => S) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), succ u1} (NonUnitalRingHom.{max u1 u2, u1} (Prod.{u2, u1} R S) S (Prod.instNonUnitalNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2) _inst_2) (Prod.{u2, u1} R S) (fun (_x : Prod.{u2, u1} R S) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Prod.{u2, u1} R S) => S) _x) (MulHomClass.toFunLike.{max u2 u1, max u2 u1, u1} (NonUnitalRingHom.{max u1 u2, u1} (Prod.{u2, u1} R S) S (Prod.instNonUnitalNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2) _inst_2) (Prod.{u2, u1} R S) S (NonUnitalNonAssocSemiring.toMul.{max u2 u1} (Prod.{u2, u1} R S) (Prod.instNonUnitalNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, max u2 u1, u1} (NonUnitalRingHom.{max u1 u2, u1} (Prod.{u2, u1} R S) S (Prod.instNonUnitalNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2) _inst_2) (Prod.{u2, u1} R S) S (Prod.instNonUnitalNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2) _inst_2 (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{max u2 u1, u1} (Prod.{u2, u1} R S) S (Prod.instNonUnitalNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2) _inst_2))) (NonUnitalRingHom.snd.{u2, u1} R S _inst_1 _inst_2)) (Prod.snd.{u2, u1} R S)
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.coe_snd NonUnitalRingHom.coe_sndₓ'. -/
@[simp]
theorem coe_snd : ⇑(snd R S) = Prod.snd :=
  rfl
#align non_unital_ring_hom.coe_snd NonUnitalRingHom.coe_snd

section Prod

variable [NonUnitalNonAssocSemiring T] (f : R →ₙ+* S) (g : R →ₙ+* T)

/- warning: non_unital_ring_hom.prod -> NonUnitalRingHom.prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {T : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] [_inst_3 : NonUnitalNonAssocSemiring.{u3} T], (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) -> (NonUnitalRingHom.{u1, u3} R T _inst_1 _inst_3) -> (NonUnitalRingHom.{u1, max u2 u3} R (Prod.{u2, u3} S T) _inst_1 (Prod.nonUnitalNonAssocSemiring.{u2, u3} S T _inst_2 _inst_3))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} {T : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] [_inst_3 : NonUnitalNonAssocSemiring.{u3} T], (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) -> (NonUnitalRingHom.{u1, u3} R T _inst_1 _inst_3) -> (NonUnitalRingHom.{u1, max u3 u2} R (Prod.{u2, u3} S T) _inst_1 (Prod.instNonUnitalNonAssocSemiringProd.{u2, u3} S T _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.prod NonUnitalRingHom.prodₓ'. -/
/-- Combine two non-unital ring homomorphisms `f : R →ₙ+* S`, `g : R →ₙ+* T` into
`f.prod g : R →ₙ+* S × T` given by `(f.prod g) x = (f x, g x)` -/
protected def prod (f : R →ₙ+* S) (g : R →ₙ+* T) : R →ₙ+* S × T :=
  { MulHom.prod (f : MulHom R S) (g : MulHom R T), AddMonoidHom.prod (f : R →+ S) (g : R →+ T) with
    toFun := fun x => (f x, g x) }
#align non_unital_ring_hom.prod NonUnitalRingHom.prod

/- warning: non_unital_ring_hom.prod_apply -> NonUnitalRingHom.prod_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {T : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] [_inst_3 : NonUnitalNonAssocSemiring.{u3} T] (f : NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (g : NonUnitalRingHom.{u1, u3} R T _inst_1 _inst_3) (x : R), Eq.{max (succ u2) (succ u3)} (Prod.{u2, u3} S T) (coeFn.{max (succ u1) (succ (max u2 u3)), max (succ u1) (succ (max u2 u3))} (NonUnitalRingHom.{u1, max u2 u3} R (Prod.{u2, u3} S T) _inst_1 (Prod.nonUnitalNonAssocSemiring.{u2, u3} S T _inst_2 _inst_3)) (fun (_x : NonUnitalRingHom.{u1, max u2 u3} R (Prod.{u2, u3} S T) _inst_1 (Prod.nonUnitalNonAssocSemiring.{u2, u3} S T _inst_2 _inst_3)) => R -> (Prod.{u2, u3} S T)) (NonUnitalRingHom.hasCoeToFun.{u1, max u2 u3} R (Prod.{u2, u3} S T) _inst_1 (Prod.nonUnitalNonAssocSemiring.{u2, u3} S T _inst_2 _inst_3)) (NonUnitalRingHom.prod.{u1, u2, u3} R S T _inst_1 _inst_2 _inst_3 f g) x) (Prod.mk.{u2, u3} S T (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (fun (_x : NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) => R -> S) (NonUnitalRingHom.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2) f x) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (NonUnitalRingHom.{u1, u3} R T _inst_1 _inst_3) (fun (_x : NonUnitalRingHom.{u1, u3} R T _inst_1 _inst_3) => R -> T) (NonUnitalRingHom.hasCoeToFun.{u1, u3} R T _inst_1 _inst_3) g x))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u3}} {T : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u3} S] [_inst_3 : NonUnitalNonAssocSemiring.{u2} T] (f : NonUnitalRingHom.{u1, u3} R S _inst_1 _inst_2) (g : NonUnitalRingHom.{u1, u2} R T _inst_1 _inst_3) (x : R), Eq.{max (succ u3) (succ u2)} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => Prod.{u3, u2} S T) x) (FunLike.coe.{max (max (succ u1) (succ u3)) (succ u2), succ u1, max (succ u3) (succ u2)} (NonUnitalRingHom.{u1, max u2 u3} R (Prod.{u3, u2} S T) _inst_1 (Prod.instNonUnitalNonAssocSemiringProd.{u3, u2} S T _inst_2 _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => Prod.{u3, u2} S T) _x) (MulHomClass.toFunLike.{max (max u1 u3) u2, u1, max u3 u2} (NonUnitalRingHom.{u1, max u2 u3} R (Prod.{u3, u2} S T) _inst_1 (Prod.instNonUnitalNonAssocSemiringProd.{u3, u2} S T _inst_2 _inst_3)) R (Prod.{u3, u2} S T) (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{max u3 u2} (Prod.{u3, u2} S T) (Prod.instNonUnitalNonAssocSemiringProd.{u3, u2} S T _inst_2 _inst_3)) (NonUnitalRingHomClass.toMulHomClass.{max (max u1 u3) u2, u1, max u3 u2} (NonUnitalRingHom.{u1, max u2 u3} R (Prod.{u3, u2} S T) _inst_1 (Prod.instNonUnitalNonAssocSemiringProd.{u3, u2} S T _inst_2 _inst_3)) R (Prod.{u3, u2} S T) _inst_1 (Prod.instNonUnitalNonAssocSemiringProd.{u3, u2} S T _inst_2 _inst_3) (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, max u3 u2} R (Prod.{u3, u2} S T) _inst_1 (Prod.instNonUnitalNonAssocSemiringProd.{u3, u2} S T _inst_2 _inst_3)))) (NonUnitalRingHom.prod.{u1, u3, u2} R S T _inst_1 _inst_2 _inst_3 f g) x) (Prod.mk.{u3, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) x) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => T) x) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (NonUnitalRingHom.{u1, u3} R S _inst_1 _inst_2) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) _x) (MulHomClass.toFunLike.{max u1 u3, u1, u3} (NonUnitalRingHom.{u1, u3} R S _inst_1 _inst_2) R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u3} S _inst_2) (NonUnitalRingHomClass.toMulHomClass.{max u1 u3, u1, u3} (NonUnitalRingHom.{u1, u3} R S _inst_1 _inst_2) R S _inst_1 _inst_2 (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u3} R S _inst_1 _inst_2))) f x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (NonUnitalRingHom.{u1, u2} R T _inst_1 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => T) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (NonUnitalRingHom.{u1, u2} R T _inst_1 _inst_3) R T (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} T _inst_3) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (NonUnitalRingHom.{u1, u2} R T _inst_1 _inst_3) R T _inst_1 _inst_3 (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u2} R T _inst_1 _inst_3))) g x))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.prod_apply NonUnitalRingHom.prod_applyₓ'. -/
@[simp]
theorem prod_apply (x) : f.Prod g x = (f x, g x) :=
  rfl
#align non_unital_ring_hom.prod_apply NonUnitalRingHom.prod_apply

/- warning: non_unital_ring_hom.fst_comp_prod -> NonUnitalRingHom.fst_comp_prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {T : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] [_inst_3 : NonUnitalNonAssocSemiring.{u3} T] (f : NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (g : NonUnitalRingHom.{u1, u3} R T _inst_1 _inst_3), Eq.{max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (NonUnitalRingHom.comp.{u1, max u2 u3, u2} R (Prod.{u2, u3} S T) S _inst_1 (Prod.nonUnitalNonAssocSemiring.{u2, u3} S T _inst_2 _inst_3) _inst_2 (NonUnitalRingHom.fst.{u2, u3} S T _inst_2 _inst_3) (NonUnitalRingHom.prod.{u1, u2, u3} R S T _inst_1 _inst_2 _inst_3 f g)) f
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u2}} {T : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u3} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] [_inst_3 : NonUnitalNonAssocSemiring.{u1} T] (f : NonUnitalRingHom.{u3, u2} R S _inst_1 _inst_2) (g : NonUnitalRingHom.{u3, u1} R T _inst_1 _inst_3), Eq.{max (succ u3) (succ u2)} (NonUnitalRingHom.{u3, u2} R S _inst_1 _inst_2) (NonUnitalRingHom.comp.{u3, max u2 u1, u2} R (Prod.{u2, u1} S T) S _inst_1 (Prod.instNonUnitalNonAssocSemiringProd.{u2, u1} S T _inst_2 _inst_3) _inst_2 (NonUnitalRingHom.fst.{u2, u1} S T _inst_2 _inst_3) (NonUnitalRingHom.prod.{u3, u2, u1} R S T _inst_1 _inst_2 _inst_3 f g)) f
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.fst_comp_prod NonUnitalRingHom.fst_comp_prodₓ'. -/
@[simp]
theorem fst_comp_prod : (fst S T).comp (f.Prod g) = f :=
  ext fun x => rfl
#align non_unital_ring_hom.fst_comp_prod NonUnitalRingHom.fst_comp_prod

/- warning: non_unital_ring_hom.snd_comp_prod -> NonUnitalRingHom.snd_comp_prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {T : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] [_inst_3 : NonUnitalNonAssocSemiring.{u3} T] (f : NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (g : NonUnitalRingHom.{u1, u3} R T _inst_1 _inst_3), Eq.{max (succ u1) (succ u3)} (NonUnitalRingHom.{u1, u3} R T _inst_1 _inst_3) (NonUnitalRingHom.comp.{u1, max u2 u3, u3} R (Prod.{u2, u3} S T) T _inst_1 (Prod.nonUnitalNonAssocSemiring.{u2, u3} S T _inst_2 _inst_3) _inst_3 (NonUnitalRingHom.snd.{u2, u3} S T _inst_2 _inst_3) (NonUnitalRingHom.prod.{u1, u2, u3} R S T _inst_1 _inst_2 _inst_3 f g)) g
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u1}} {T : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u3} R] [_inst_2 : NonUnitalNonAssocSemiring.{u1} S] [_inst_3 : NonUnitalNonAssocSemiring.{u2} T] (f : NonUnitalRingHom.{u3, u1} R S _inst_1 _inst_2) (g : NonUnitalRingHom.{u3, u2} R T _inst_1 _inst_3), Eq.{max (succ u3) (succ u2)} (NonUnitalRingHom.{u3, u2} R T _inst_1 _inst_3) (NonUnitalRingHom.comp.{u3, max u1 u2, u2} R (Prod.{u1, u2} S T) T _inst_1 (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} S T _inst_2 _inst_3) _inst_3 (NonUnitalRingHom.snd.{u1, u2} S T _inst_2 _inst_3) (NonUnitalRingHom.prod.{u3, u1, u2} R S T _inst_1 _inst_2 _inst_3 f g)) g
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.snd_comp_prod NonUnitalRingHom.snd_comp_prodₓ'. -/
@[simp]
theorem snd_comp_prod : (snd S T).comp (f.Prod g) = g :=
  ext fun x => rfl
#align non_unital_ring_hom.snd_comp_prod NonUnitalRingHom.snd_comp_prod

/- warning: non_unital_ring_hom.prod_unique -> NonUnitalRingHom.prod_unique is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {T : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] [_inst_3 : NonUnitalNonAssocSemiring.{u3} T] (f : NonUnitalRingHom.{u1, max u2 u3} R (Prod.{u2, u3} S T) _inst_1 (Prod.nonUnitalNonAssocSemiring.{u2, u3} S T _inst_2 _inst_3)), Eq.{max (succ u1) (succ (max u2 u3))} (NonUnitalRingHom.{u1, max u2 u3} R (Prod.{u2, u3} S T) _inst_1 (Prod.nonUnitalNonAssocSemiring.{u2, u3} S T _inst_2 _inst_3)) (NonUnitalRingHom.prod.{u1, u2, u3} R S T _inst_1 _inst_2 _inst_3 (NonUnitalRingHom.comp.{u1, max u2 u3, u2} R (Prod.{u2, u3} S T) S _inst_1 (Prod.nonUnitalNonAssocSemiring.{u2, u3} S T _inst_2 _inst_3) _inst_2 (NonUnitalRingHom.fst.{u2, u3} S T _inst_2 _inst_3) f) (NonUnitalRingHom.comp.{u1, max u2 u3, u3} R (Prod.{u2, u3} S T) T _inst_1 (Prod.nonUnitalNonAssocSemiring.{u2, u3} S T _inst_2 _inst_3) _inst_3 (NonUnitalRingHom.snd.{u2, u3} S T _inst_2 _inst_3) f)) f
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u1}} {T : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u3} R] [_inst_2 : NonUnitalNonAssocSemiring.{u1} S] [_inst_3 : NonUnitalNonAssocSemiring.{u2} T] (f : NonUnitalRingHom.{u3, max u2 u1} R (Prod.{u1, u2} S T) _inst_1 (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} S T _inst_2 _inst_3)), Eq.{max (max (succ u3) (succ u1)) (succ u2)} (NonUnitalRingHom.{u3, max u2 u1} R (Prod.{u1, u2} S T) _inst_1 (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} S T _inst_2 _inst_3)) (NonUnitalRingHom.prod.{u3, u1, u2} R S T _inst_1 _inst_2 _inst_3 (NonUnitalRingHom.comp.{u3, max u1 u2, u1} R (Prod.{u1, u2} S T) S _inst_1 (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} S T _inst_2 _inst_3) _inst_2 (NonUnitalRingHom.fst.{u1, u2} S T _inst_2 _inst_3) f) (NonUnitalRingHom.comp.{u3, max u1 u2, u2} R (Prod.{u1, u2} S T) T _inst_1 (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} S T _inst_2 _inst_3) _inst_3 (NonUnitalRingHom.snd.{u1, u2} S T _inst_2 _inst_3) f)) f
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.prod_unique NonUnitalRingHom.prod_uniqueₓ'. -/
theorem prod_unique (f : R →ₙ+* S × T) : ((fst S T).comp f).Prod ((snd S T).comp f) = f :=
  ext fun x => by simp only [prod_apply, coe_fst, coe_snd, comp_apply, Prod.mk.eta]
#align non_unital_ring_hom.prod_unique NonUnitalRingHom.prod_unique

end Prod

section Prod_map

variable [NonUnitalNonAssocSemiring R'] [NonUnitalNonAssocSemiring S'] [NonUnitalNonAssocSemiring T]

variable (f : R →ₙ+* R') (g : S →ₙ+* S')

/- warning: non_unital_ring_hom.prod_map -> NonUnitalRingHom.prodMap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {R' : Type.{u2}} {S : Type.{u3}} {S' : Type.{u4}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u3} S] [_inst_3 : NonUnitalNonAssocSemiring.{u2} R'] [_inst_4 : NonUnitalNonAssocSemiring.{u4} S'], (NonUnitalRingHom.{u1, u2} R R' _inst_1 _inst_3) -> (NonUnitalRingHom.{u3, u4} S S' _inst_2 _inst_4) -> (NonUnitalRingHom.{max u1 u3, max u2 u4} (Prod.{u1, u3} R S) (Prod.{u2, u4} R' S') (Prod.nonUnitalNonAssocSemiring.{u1, u3} R S _inst_1 _inst_2) (Prod.nonUnitalNonAssocSemiring.{u2, u4} R' S' _inst_3 _inst_4))
but is expected to have type
  forall {R : Type.{u1}} {R' : Type.{u2}} {S : Type.{u3}} {S' : Type.{u4}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u3} S] [_inst_3 : NonUnitalNonAssocSemiring.{u2} R'] [_inst_4 : NonUnitalNonAssocSemiring.{u4} S'], (NonUnitalRingHom.{u1, u2} R R' _inst_1 _inst_3) -> (NonUnitalRingHom.{u3, u4} S S' _inst_2 _inst_4) -> (NonUnitalRingHom.{max u3 u1, max u4 u2} (Prod.{u1, u3} R S) (Prod.{u2, u4} R' S') (Prod.instNonUnitalNonAssocSemiringProd.{u1, u3} R S _inst_1 _inst_2) (Prod.instNonUnitalNonAssocSemiringProd.{u2, u4} R' S' _inst_3 _inst_4))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.prod_map NonUnitalRingHom.prodMapₓ'. -/
/-- `prod.map` as a `non_unital_ring_hom`. -/
def prodMap : R × S →ₙ+* R' × S' :=
  (f.comp (fst R S)).Prod (g.comp (snd R S))
#align non_unital_ring_hom.prod_map NonUnitalRingHom.prodMap

/- warning: non_unital_ring_hom.prod_map_def -> NonUnitalRingHom.prodMap_def is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {R' : Type.{u2}} {S : Type.{u3}} {S' : Type.{u4}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u3} S] [_inst_3 : NonUnitalNonAssocSemiring.{u2} R'] [_inst_4 : NonUnitalNonAssocSemiring.{u4} S'] (f : NonUnitalRingHom.{u1, u2} R R' _inst_1 _inst_3) (g : NonUnitalRingHom.{u3, u4} S S' _inst_2 _inst_4), Eq.{max (succ (max u1 u3)) (succ (max u2 u4))} (NonUnitalRingHom.{max u1 u3, max u2 u4} (Prod.{u1, u3} R S) (Prod.{u2, u4} R' S') (Prod.nonUnitalNonAssocSemiring.{u1, u3} R S _inst_1 _inst_2) (Prod.nonUnitalNonAssocSemiring.{u2, u4} R' S' _inst_3 _inst_4)) (NonUnitalRingHom.prodMap.{u1, u2, u3, u4} R R' S S' _inst_1 _inst_2 _inst_3 _inst_4 f g) (NonUnitalRingHom.prod.{max u1 u3, u2, u4} (Prod.{u1, u3} R S) R' S' (Prod.nonUnitalNonAssocSemiring.{u1, u3} R S _inst_1 _inst_2) _inst_3 _inst_4 (NonUnitalRingHom.comp.{max u1 u3, u1, u2} (Prod.{u1, u3} R S) R R' (Prod.nonUnitalNonAssocSemiring.{u1, u3} R S _inst_1 _inst_2) _inst_1 _inst_3 f (NonUnitalRingHom.fst.{u1, u3} R S _inst_1 _inst_2)) (NonUnitalRingHom.comp.{max u1 u3, u3, u4} (Prod.{u1, u3} R S) S S' (Prod.nonUnitalNonAssocSemiring.{u1, u3} R S _inst_1 _inst_2) _inst_2 _inst_4 g (NonUnitalRingHom.snd.{u1, u3} R S _inst_1 _inst_2)))
but is expected to have type
  forall {R : Type.{u4}} {R' : Type.{u3}} {S : Type.{u2}} {S' : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u4} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] [_inst_3 : NonUnitalNonAssocSemiring.{u3} R'] [_inst_4 : NonUnitalNonAssocSemiring.{u1} S'] (f : NonUnitalRingHom.{u4, u3} R R' _inst_1 _inst_3) (g : NonUnitalRingHom.{u2, u1} S S' _inst_2 _inst_4), Eq.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1)} (NonUnitalRingHom.{max u2 u4, max u1 u3} (Prod.{u4, u2} R S) (Prod.{u3, u1} R' S') (Prod.instNonUnitalNonAssocSemiringProd.{u4, u2} R S _inst_1 _inst_2) (Prod.instNonUnitalNonAssocSemiringProd.{u3, u1} R' S' _inst_3 _inst_4)) (NonUnitalRingHom.prodMap.{u4, u3, u2, u1} R R' S S' _inst_1 _inst_2 _inst_3 _inst_4 f g) (NonUnitalRingHom.prod.{max u4 u2, u3, u1} (Prod.{u4, u2} R S) R' S' (Prod.instNonUnitalNonAssocSemiringProd.{u4, u2} R S _inst_1 _inst_2) _inst_3 _inst_4 (NonUnitalRingHom.comp.{max u4 u2, u4, u3} (Prod.{u4, u2} R S) R R' (Prod.instNonUnitalNonAssocSemiringProd.{u4, u2} R S _inst_1 _inst_2) _inst_1 _inst_3 f (NonUnitalRingHom.fst.{u4, u2} R S _inst_1 _inst_2)) (NonUnitalRingHom.comp.{max u4 u2, u2, u1} (Prod.{u4, u2} R S) S S' (Prod.instNonUnitalNonAssocSemiringProd.{u4, u2} R S _inst_1 _inst_2) _inst_2 _inst_4 g (NonUnitalRingHom.snd.{u4, u2} R S _inst_1 _inst_2)))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.prod_map_def NonUnitalRingHom.prodMap_defₓ'. -/
theorem prodMap_def : prodMap f g = (f.comp (fst R S)).Prod (g.comp (snd R S)) :=
  rfl
#align non_unital_ring_hom.prod_map_def NonUnitalRingHom.prodMap_def

/- warning: non_unital_ring_hom.coe_prod_map -> NonUnitalRingHom.coe_prodMap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {R' : Type.{u2}} {S : Type.{u3}} {S' : Type.{u4}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u3} S] [_inst_3 : NonUnitalNonAssocSemiring.{u2} R'] [_inst_4 : NonUnitalNonAssocSemiring.{u4} S'] (f : NonUnitalRingHom.{u1, u2} R R' _inst_1 _inst_3) (g : NonUnitalRingHom.{u3, u4} S S' _inst_2 _inst_4), Eq.{max (succ (max u1 u3)) (succ (max u2 u4))} ((Prod.{u1, u3} R S) -> (Prod.{u2, u4} R' S')) (coeFn.{max (succ (max u1 u3)) (succ (max u2 u4)), max (succ (max u1 u3)) (succ (max u2 u4))} (NonUnitalRingHom.{max u1 u3, max u2 u4} (Prod.{u1, u3} R S) (Prod.{u2, u4} R' S') (Prod.nonUnitalNonAssocSemiring.{u1, u3} R S _inst_1 _inst_2) (Prod.nonUnitalNonAssocSemiring.{u2, u4} R' S' _inst_3 _inst_4)) (fun (_x : NonUnitalRingHom.{max u1 u3, max u2 u4} (Prod.{u1, u3} R S) (Prod.{u2, u4} R' S') (Prod.nonUnitalNonAssocSemiring.{u1, u3} R S _inst_1 _inst_2) (Prod.nonUnitalNonAssocSemiring.{u2, u4} R' S' _inst_3 _inst_4)) => (Prod.{u1, u3} R S) -> (Prod.{u2, u4} R' S')) (NonUnitalRingHom.hasCoeToFun.{max u1 u3, max u2 u4} (Prod.{u1, u3} R S) (Prod.{u2, u4} R' S') (Prod.nonUnitalNonAssocSemiring.{u1, u3} R S _inst_1 _inst_2) (Prod.nonUnitalNonAssocSemiring.{u2, u4} R' S' _inst_3 _inst_4)) (NonUnitalRingHom.prodMap.{u1, u2, u3, u4} R R' S S' _inst_1 _inst_2 _inst_3 _inst_4 f g)) (Prod.map.{u1, u2, u3, u4} R R' S S' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} R R' _inst_1 _inst_3) (fun (_x : NonUnitalRingHom.{u1, u2} R R' _inst_1 _inst_3) => R -> R') (NonUnitalRingHom.hasCoeToFun.{u1, u2} R R' _inst_1 _inst_3) f) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (NonUnitalRingHom.{u3, u4} S S' _inst_2 _inst_4) (fun (_x : NonUnitalRingHom.{u3, u4} S S' _inst_2 _inst_4) => S -> S') (NonUnitalRingHom.hasCoeToFun.{u3, u4} S S' _inst_2 _inst_4) g))
but is expected to have type
  forall {R : Type.{u4}} {R' : Type.{u3}} {S : Type.{u2}} {S' : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u4} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] [_inst_3 : NonUnitalNonAssocSemiring.{u3} R'] [_inst_4 : NonUnitalNonAssocSemiring.{u1} S'] (f : NonUnitalRingHom.{u4, u3} R R' _inst_1 _inst_3) (g : NonUnitalRingHom.{u2, u1} S S' _inst_2 _inst_4), Eq.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1)} (forall (ᾰ : Prod.{u4, u2} R S), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Prod.{u4, u2} R S) => Prod.{u3, u1} R' S') ᾰ) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), max (succ u4) (succ u2), max (succ u3) (succ u1)} (NonUnitalRingHom.{max u2 u4, max u1 u3} (Prod.{u4, u2} R S) (Prod.{u3, u1} R' S') (Prod.instNonUnitalNonAssocSemiringProd.{u4, u2} R S _inst_1 _inst_2) (Prod.instNonUnitalNonAssocSemiringProd.{u3, u1} R' S' _inst_3 _inst_4)) (Prod.{u4, u2} R S) (fun (_x : Prod.{u4, u2} R S) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Prod.{u4, u2} R S) => Prod.{u3, u1} R' S') _x) (MulHomClass.toFunLike.{max (max (max u4 u3) u2) u1, max u4 u2, max u3 u1} (NonUnitalRingHom.{max u2 u4, max u1 u3} (Prod.{u4, u2} R S) (Prod.{u3, u1} R' S') (Prod.instNonUnitalNonAssocSemiringProd.{u4, u2} R S _inst_1 _inst_2) (Prod.instNonUnitalNonAssocSemiringProd.{u3, u1} R' S' _inst_3 _inst_4)) (Prod.{u4, u2} R S) (Prod.{u3, u1} R' S') (NonUnitalNonAssocSemiring.toMul.{max u4 u2} (Prod.{u4, u2} R S) (Prod.instNonUnitalNonAssocSemiringProd.{u4, u2} R S _inst_1 _inst_2)) (NonUnitalNonAssocSemiring.toMul.{max u3 u1} (Prod.{u3, u1} R' S') (Prod.instNonUnitalNonAssocSemiringProd.{u3, u1} R' S' _inst_3 _inst_4)) (NonUnitalRingHomClass.toMulHomClass.{max (max (max u4 u3) u2) u1, max u4 u2, max u3 u1} (NonUnitalRingHom.{max u2 u4, max u1 u3} (Prod.{u4, u2} R S) (Prod.{u3, u1} R' S') (Prod.instNonUnitalNonAssocSemiringProd.{u4, u2} R S _inst_1 _inst_2) (Prod.instNonUnitalNonAssocSemiringProd.{u3, u1} R' S' _inst_3 _inst_4)) (Prod.{u4, u2} R S) (Prod.{u3, u1} R' S') (Prod.instNonUnitalNonAssocSemiringProd.{u4, u2} R S _inst_1 _inst_2) (Prod.instNonUnitalNonAssocSemiringProd.{u3, u1} R' S' _inst_3 _inst_4) (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{max u4 u2, max u3 u1} (Prod.{u4, u2} R S) (Prod.{u3, u1} R' S') (Prod.instNonUnitalNonAssocSemiringProd.{u4, u2} R S _inst_1 _inst_2) (Prod.instNonUnitalNonAssocSemiringProd.{u3, u1} R' S' _inst_3 _inst_4)))) (NonUnitalRingHom.prodMap.{u4, u3, u2, u1} R R' S S' _inst_1 _inst_2 _inst_3 _inst_4 f g)) (Prod.map.{u4, u3, u2, u1} R R' S S' (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (NonUnitalRingHom.{u4, u3} R R' _inst_1 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => R') _x) (MulHomClass.toFunLike.{max u4 u3, u4, u3} (NonUnitalRingHom.{u4, u3} R R' _inst_1 _inst_3) R R' (NonUnitalNonAssocSemiring.toMul.{u4} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u3} R' _inst_3) (NonUnitalRingHomClass.toMulHomClass.{max u4 u3, u4, u3} (NonUnitalRingHom.{u4, u3} R R' _inst_1 _inst_3) R R' _inst_1 _inst_3 (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u4, u3} R R' _inst_1 _inst_3))) f) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NonUnitalRingHom.{u2, u1} S S' _inst_2 _inst_4) S (fun (_x : S) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : S) => S') _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} S S' _inst_2 _inst_4) S S' (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (NonUnitalNonAssocSemiring.toMul.{u1} S' _inst_4) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} S S' _inst_2 _inst_4) S S' _inst_2 _inst_4 (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u2, u1} S S' _inst_2 _inst_4))) g))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.coe_prod_map NonUnitalRingHom.coe_prodMapₓ'. -/
@[simp]
theorem coe_prodMap : ⇑(prodMap f g) = Prod.map f g :=
  rfl
#align non_unital_ring_hom.coe_prod_map NonUnitalRingHom.coe_prodMap

/- warning: non_unital_ring_hom.prod_comp_prod_map -> NonUnitalRingHom.prod_comp_prodMap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {R' : Type.{u2}} {S : Type.{u3}} {S' : Type.{u4}} {T : Type.{u5}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u3} S] [_inst_3 : NonUnitalNonAssocSemiring.{u2} R'] [_inst_4 : NonUnitalNonAssocSemiring.{u4} S'] [_inst_5 : NonUnitalNonAssocSemiring.{u5} T] (f : NonUnitalRingHom.{u5, u1} T R _inst_5 _inst_1) (g : NonUnitalRingHom.{u5, u3} T S _inst_5 _inst_2) (f' : NonUnitalRingHom.{u1, u2} R R' _inst_1 _inst_3) (g' : NonUnitalRingHom.{u3, u4} S S' _inst_2 _inst_4), Eq.{max (succ u5) (succ (max u2 u4))} (NonUnitalRingHom.{u5, max u2 u4} T (Prod.{u2, u4} R' S') _inst_5 (Prod.nonUnitalNonAssocSemiring.{u2, u4} R' S' _inst_3 _inst_4)) (NonUnitalRingHom.comp.{u5, max u1 u3, max u2 u4} T (Prod.{u1, u3} R S) (Prod.{u2, u4} R' S') _inst_5 (Prod.nonUnitalNonAssocSemiring.{u1, u3} R S _inst_1 _inst_2) (Prod.nonUnitalNonAssocSemiring.{u2, u4} R' S' _inst_3 _inst_4) (NonUnitalRingHom.prodMap.{u1, u2, u3, u4} R R' S S' _inst_1 _inst_2 _inst_3 _inst_4 f' g') (NonUnitalRingHom.prod.{u5, u1, u3} T R S _inst_5 _inst_1 _inst_2 f g)) (NonUnitalRingHom.prod.{u5, u2, u4} T R' S' _inst_5 _inst_3 _inst_4 (NonUnitalRingHom.comp.{u5, u1, u2} T R R' _inst_5 _inst_1 _inst_3 f' f) (NonUnitalRingHom.comp.{u5, u3, u4} T S S' _inst_5 _inst_2 _inst_4 g' g))
but is expected to have type
  forall {R : Type.{u4}} {R' : Type.{u2}} {S : Type.{u3}} {S' : Type.{u1}} {T : Type.{u5}} [_inst_1 : NonUnitalNonAssocSemiring.{u4} R] [_inst_2 : NonUnitalNonAssocSemiring.{u3} S] [_inst_3 : NonUnitalNonAssocSemiring.{u2} R'] [_inst_4 : NonUnitalNonAssocSemiring.{u1} S'] [_inst_5 : NonUnitalNonAssocSemiring.{u5} T] (f : NonUnitalRingHom.{u5, u4} T R _inst_5 _inst_1) (g : NonUnitalRingHom.{u5, u3} T S _inst_5 _inst_2) (f' : NonUnitalRingHom.{u4, u2} R R' _inst_1 _inst_3) (g' : NonUnitalRingHom.{u3, u1} S S' _inst_2 _inst_4), Eq.{max (max (succ u2) (succ u1)) (succ u5)} (NonUnitalRingHom.{u5, max u2 u1} T (Prod.{u2, u1} R' S') _inst_5 (Prod.instNonUnitalNonAssocSemiringProd.{u2, u1} R' S' _inst_3 _inst_4)) (NonUnitalRingHom.comp.{u5, max u4 u3, max u2 u1} T (Prod.{u4, u3} R S) (Prod.{u2, u1} R' S') _inst_5 (Prod.instNonUnitalNonAssocSemiringProd.{u4, u3} R S _inst_1 _inst_2) (Prod.instNonUnitalNonAssocSemiringProd.{u2, u1} R' S' _inst_3 _inst_4) (NonUnitalRingHom.prodMap.{u4, u2, u3, u1} R R' S S' _inst_1 _inst_2 _inst_3 _inst_4 f' g') (NonUnitalRingHom.prod.{u5, u4, u3} T R S _inst_5 _inst_1 _inst_2 f g)) (NonUnitalRingHom.prod.{u5, u2, u1} T R' S' _inst_5 _inst_3 _inst_4 (NonUnitalRingHom.comp.{u5, u4, u2} T R R' _inst_5 _inst_1 _inst_3 f' f) (NonUnitalRingHom.comp.{u5, u3, u1} T S S' _inst_5 _inst_2 _inst_4 g' g))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.prod_comp_prod_map NonUnitalRingHom.prod_comp_prodMapₓ'. -/
theorem prod_comp_prodMap (f : T →ₙ+* R) (g : T →ₙ+* S) (f' : R →ₙ+* R') (g' : S →ₙ+* S') :
    (f'.Prod_map g').comp (f.Prod g) = (f'.comp f).Prod (g'.comp g) :=
  rfl
#align non_unital_ring_hom.prod_comp_prod_map NonUnitalRingHom.prod_comp_prodMap

end Prod_map

end NonUnitalRingHom

namespace RingHom

variable (R S) [NonAssocSemiring R] [NonAssocSemiring S]

/- warning: ring_hom.fst -> RingHom.fst is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (S : Type.{u2}) [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S], RingHom.{max u1 u2, u1} (Prod.{u1, u2} R S) R (Prod.nonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) _inst_1
but is expected to have type
  forall (R : Type.{u1}) (S : Type.{u2}) [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S], RingHom.{max u2 u1, u1} (Prod.{u1, u2} R S) R (Prod.instNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2) _inst_1
Case conversion may be inaccurate. Consider using '#align ring_hom.fst RingHom.fstₓ'. -/
/-- Given semirings `R`, `S`, the natural projection homomorphism from `R × S` to `R`.-/
def fst : R × S →+* R :=
  { MonoidHom.fst R S, AddMonoidHom.fst R S with toFun := Prod.fst }
#align ring_hom.fst RingHom.fst

/- warning: ring_hom.snd -> RingHom.snd is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (S : Type.{u2}) [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S], RingHom.{max u1 u2, u2} (Prod.{u1, u2} R S) S (Prod.nonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) _inst_2
but is expected to have type
  forall (R : Type.{u1}) (S : Type.{u2}) [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S], RingHom.{max u2 u1, u2} (Prod.{u1, u2} R S) S (Prod.instNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2) _inst_2
Case conversion may be inaccurate. Consider using '#align ring_hom.snd RingHom.sndₓ'. -/
/-- Given semirings `R`, `S`, the natural projection homomorphism from `R × S` to `S`.-/
def snd : R × S →+* S :=
  { MonoidHom.snd R S, AddMonoidHom.snd R S with toFun := Prod.snd }
#align ring_hom.snd RingHom.snd

variable {R S}

/- warning: ring_hom.coe_fst -> RingHom.coe_fst is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S], Eq.{max (succ (max u1 u2)) (succ u1)} ((Prod.{u1, u2} R S) -> R) (coeFn.{max (succ (max u1 u2)) (succ u1), max (succ (max u1 u2)) (succ u1)} (RingHom.{max u1 u2, u1} (Prod.{u1, u2} R S) R (Prod.nonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) _inst_1) (fun (_x : RingHom.{max u1 u2, u1} (Prod.{u1, u2} R S) R (Prod.nonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) _inst_1) => (Prod.{u1, u2} R S) -> R) (RingHom.hasCoeToFun.{max u1 u2, u1} (Prod.{u1, u2} R S) R (Prod.nonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) _inst_1) (RingHom.fst.{u1, u2} R S _inst_1 _inst_2)) (Prod.fst.{u1, u2} R S)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} R] [_inst_2 : NonAssocSemiring.{u1} S], Eq.{max (succ u2) (succ u1)} (forall (ᾰ : Prod.{u2, u1} R S), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Prod.{u2, u1} R S) => R) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), succ u2} (RingHom.{max u1 u2, u2} (Prod.{u2, u1} R S) R (Prod.instNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2) _inst_1) (Prod.{u2, u1} R S) (fun (_x : Prod.{u2, u1} R S) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Prod.{u2, u1} R S) => R) _x) (MulHomClass.toFunLike.{max u2 u1, max u2 u1, u2} (RingHom.{max u1 u2, u2} (Prod.{u2, u1} R S) R (Prod.instNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2) _inst_1) (Prod.{u2, u1} R S) R (NonUnitalNonAssocSemiring.toMul.{max u2 u1} (Prod.{u2, u1} R S) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (Prod.{u2, u1} R S) (Prod.instNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, max u2 u1, u2} (RingHom.{max u1 u2, u2} (Prod.{u2, u1} R S) R (Prod.instNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2) _inst_1) (Prod.{u2, u1} R S) R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (Prod.{u2, u1} R S) (Prod.instNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, max u2 u1, u2} (RingHom.{max u1 u2, u2} (Prod.{u2, u1} R S) R (Prod.instNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2) _inst_1) (Prod.{u2, u1} R S) R (Prod.instNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2) _inst_1 (RingHom.instRingHomClassRingHom.{max u2 u1, u2} (Prod.{u2, u1} R S) R (Prod.instNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2) _inst_1)))) (RingHom.fst.{u2, u1} R S _inst_1 _inst_2)) (Prod.fst.{u2, u1} R S)
Case conversion may be inaccurate. Consider using '#align ring_hom.coe_fst RingHom.coe_fstₓ'. -/
@[simp]
theorem coe_fst : ⇑(fst R S) = Prod.fst :=
  rfl
#align ring_hom.coe_fst RingHom.coe_fst

/- warning: ring_hom.coe_snd -> RingHom.coe_snd is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S], Eq.{max (succ (max u1 u2)) (succ u2)} ((Prod.{u1, u2} R S) -> S) (coeFn.{max (succ (max u1 u2)) (succ u2), max (succ (max u1 u2)) (succ u2)} (RingHom.{max u1 u2, u2} (Prod.{u1, u2} R S) S (Prod.nonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) _inst_2) (fun (_x : RingHom.{max u1 u2, u2} (Prod.{u1, u2} R S) S (Prod.nonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) _inst_2) => (Prod.{u1, u2} R S) -> S) (RingHom.hasCoeToFun.{max u1 u2, u2} (Prod.{u1, u2} R S) S (Prod.nonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) _inst_2) (RingHom.snd.{u1, u2} R S _inst_1 _inst_2)) (Prod.snd.{u1, u2} R S)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} R] [_inst_2 : NonAssocSemiring.{u1} S], Eq.{max (succ u2) (succ u1)} (forall (ᾰ : Prod.{u2, u1} R S), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Prod.{u2, u1} R S) => S) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), succ u1} (RingHom.{max u1 u2, u1} (Prod.{u2, u1} R S) S (Prod.instNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2) _inst_2) (Prod.{u2, u1} R S) (fun (_x : Prod.{u2, u1} R S) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Prod.{u2, u1} R S) => S) _x) (MulHomClass.toFunLike.{max u2 u1, max u2 u1, u1} (RingHom.{max u1 u2, u1} (Prod.{u2, u1} R S) S (Prod.instNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2) _inst_2) (Prod.{u2, u1} R S) S (NonUnitalNonAssocSemiring.toMul.{max u2 u1} (Prod.{u2, u1} R S) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (Prod.{u2, u1} R S) (Prod.instNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, max u2 u1, u1} (RingHom.{max u1 u2, u1} (Prod.{u2, u1} R S) S (Prod.instNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2) _inst_2) (Prod.{u2, u1} R S) S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (Prod.{u2, u1} R S) (Prod.instNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, max u2 u1, u1} (RingHom.{max u1 u2, u1} (Prod.{u2, u1} R S) S (Prod.instNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2) _inst_2) (Prod.{u2, u1} R S) S (Prod.instNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2) _inst_2 (RingHom.instRingHomClassRingHom.{max u2 u1, u1} (Prod.{u2, u1} R S) S (Prod.instNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2) _inst_2)))) (RingHom.snd.{u2, u1} R S _inst_1 _inst_2)) (Prod.snd.{u2, u1} R S)
Case conversion may be inaccurate. Consider using '#align ring_hom.coe_snd RingHom.coe_sndₓ'. -/
@[simp]
theorem coe_snd : ⇑(snd R S) = Prod.snd :=
  rfl
#align ring_hom.coe_snd RingHom.coe_snd

section Prod

variable [NonAssocSemiring T] (f : R →+* S) (g : R →+* T)

/- warning: ring_hom.prod -> RingHom.prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {T : Type.{u3}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S] [_inst_3 : NonAssocSemiring.{u3} T], (RingHom.{u1, u2} R S _inst_1 _inst_2) -> (RingHom.{u1, u3} R T _inst_1 _inst_3) -> (RingHom.{u1, max u2 u3} R (Prod.{u2, u3} S T) _inst_1 (Prod.nonAssocSemiring.{u2, u3} S T _inst_2 _inst_3))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} {T : Type.{u3}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S] [_inst_3 : NonAssocSemiring.{u3} T], (RingHom.{u1, u2} R S _inst_1 _inst_2) -> (RingHom.{u1, u3} R T _inst_1 _inst_3) -> (RingHom.{u1, max u3 u2} R (Prod.{u2, u3} S T) _inst_1 (Prod.instNonAssocSemiringProd.{u2, u3} S T _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align ring_hom.prod RingHom.prodₓ'. -/
/-- Combine two ring homomorphisms `f : R →+* S`, `g : R →+* T` into `f.prod g : R →+* S × T`
given by `(f.prod g) x = (f x, g x)` -/
protected def prod (f : R →+* S) (g : R →+* T) : R →+* S × T :=
  { MonoidHom.prod (f : R →* S) (g : R →* T), AddMonoidHom.prod (f : R →+ S) (g : R →+ T) with
    toFun := fun x => (f x, g x) }
#align ring_hom.prod RingHom.prod

/- warning: ring_hom.prod_apply -> RingHom.prod_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {T : Type.{u3}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S] [_inst_3 : NonAssocSemiring.{u3} T] (f : RingHom.{u1, u2} R S _inst_1 _inst_2) (g : RingHom.{u1, u3} R T _inst_1 _inst_3) (x : R), Eq.{max (succ u2) (succ u3)} (Prod.{u2, u3} S T) (coeFn.{max (succ u1) (succ (max u2 u3)), max (succ u1) (succ (max u2 u3))} (RingHom.{u1, max u2 u3} R (Prod.{u2, u3} S T) _inst_1 (Prod.nonAssocSemiring.{u2, u3} S T _inst_2 _inst_3)) (fun (_x : RingHom.{u1, max u2 u3} R (Prod.{u2, u3} S T) _inst_1 (Prod.nonAssocSemiring.{u2, u3} S T _inst_2 _inst_3)) => R -> (Prod.{u2, u3} S T)) (RingHom.hasCoeToFun.{u1, max u2 u3} R (Prod.{u2, u3} S T) _inst_1 (Prod.nonAssocSemiring.{u2, u3} S T _inst_2 _inst_3)) (RingHom.prod.{u1, u2, u3} R S T _inst_1 _inst_2 _inst_3 f g) x) (Prod.mk.{u2, u3} S T (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S _inst_1 _inst_2) (fun (_x : RingHom.{u1, u2} R S _inst_1 _inst_2) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2) f x) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (RingHom.{u1, u3} R T _inst_1 _inst_3) (fun (_x : RingHom.{u1, u3} R T _inst_1 _inst_3) => R -> T) (RingHom.hasCoeToFun.{u1, u3} R T _inst_1 _inst_3) g x))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u3}} {T : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u3} S] [_inst_3 : NonAssocSemiring.{u2} T] (f : RingHom.{u1, u3} R S _inst_1 _inst_2) (g : RingHom.{u1, u2} R T _inst_1 _inst_3) (x : R), Eq.{max (succ u3) (succ u2)} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => Prod.{u3, u2} S T) x) (FunLike.coe.{max (max (succ u1) (succ u3)) (succ u2), succ u1, max (succ u3) (succ u2)} (RingHom.{u1, max u2 u3} R (Prod.{u3, u2} S T) _inst_1 (Prod.instNonAssocSemiringProd.{u3, u2} S T _inst_2 _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => Prod.{u3, u2} S T) _x) (MulHomClass.toFunLike.{max (max u1 u3) u2, u1, max u3 u2} (RingHom.{u1, max u2 u3} R (Prod.{u3, u2} S T) _inst_1 (Prod.instNonAssocSemiringProd.{u3, u2} S T _inst_2 _inst_3)) R (Prod.{u3, u2} S T) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{max u3 u2} (Prod.{u3, u2} S T) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (Prod.{u3, u2} S T) (Prod.instNonAssocSemiringProd.{u3, u2} S T _inst_2 _inst_3))) (NonUnitalRingHomClass.toMulHomClass.{max (max u1 u3) u2, u1, max u3 u2} (RingHom.{u1, max u2 u3} R (Prod.{u3, u2} S T) _inst_1 (Prod.instNonAssocSemiringProd.{u3, u2} S T _inst_2 _inst_3)) R (Prod.{u3, u2} S T) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (Prod.{u3, u2} S T) (Prod.instNonAssocSemiringProd.{u3, u2} S T _inst_2 _inst_3)) (RingHomClass.toNonUnitalRingHomClass.{max (max u1 u3) u2, u1, max u3 u2} (RingHom.{u1, max u2 u3} R (Prod.{u3, u2} S T) _inst_1 (Prod.instNonAssocSemiringProd.{u3, u2} S T _inst_2 _inst_3)) R (Prod.{u3, u2} S T) _inst_1 (Prod.instNonAssocSemiringProd.{u3, u2} S T _inst_2 _inst_3) (RingHom.instRingHomClassRingHom.{u1, max u3 u2} R (Prod.{u3, u2} S T) _inst_1 (Prod.instNonAssocSemiringProd.{u3, u2} S T _inst_2 _inst_3))))) (RingHom.prod.{u1, u3, u2} R S T _inst_1 _inst_2 _inst_3 f g) x) (Prod.mk.{u3, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) x) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => T) x) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (RingHom.{u1, u3} R S _inst_1 _inst_2) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) _x) (MulHomClass.toFunLike.{max u1 u3, u1, u3} (RingHom.{u1, u3} R S _inst_1 _inst_2) R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S _inst_2)) (NonUnitalRingHomClass.toMulHomClass.{max u1 u3, u1, u3} (RingHom.{u1, u3} R S _inst_1 _inst_2) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S _inst_2) (RingHomClass.toNonUnitalRingHomClass.{max u1 u3, u1, u3} (RingHom.{u1, u3} R S _inst_1 _inst_2) R S _inst_1 _inst_2 (RingHom.instRingHomClassRingHom.{u1, u3} R S _inst_1 _inst_2)))) f x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R T _inst_1 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => T) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R T _inst_1 _inst_3) R T (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} T _inst_3)) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R T _inst_1 _inst_3) R T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} T _inst_3) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R T _inst_1 _inst_3) R T _inst_1 _inst_3 (RingHom.instRingHomClassRingHom.{u1, u2} R T _inst_1 _inst_3)))) g x))
Case conversion may be inaccurate. Consider using '#align ring_hom.prod_apply RingHom.prod_applyₓ'. -/
@[simp]
theorem prod_apply (x) : f.Prod g x = (f x, g x) :=
  rfl
#align ring_hom.prod_apply RingHom.prod_apply

/- warning: ring_hom.fst_comp_prod -> RingHom.fst_comp_prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {T : Type.{u3}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S] [_inst_3 : NonAssocSemiring.{u3} T] (f : RingHom.{u1, u2} R S _inst_1 _inst_2) (g : RingHom.{u1, u3} R T _inst_1 _inst_3), Eq.{max (succ u1) (succ u2)} (RingHom.{u1, u2} R S _inst_1 _inst_2) (RingHom.comp.{u1, max u2 u3, u2} R (Prod.{u2, u3} S T) S _inst_1 (Prod.nonAssocSemiring.{u2, u3} S T _inst_2 _inst_3) _inst_2 (RingHom.fst.{u2, u3} S T _inst_2 _inst_3) (RingHom.prod.{u1, u2, u3} R S T _inst_1 _inst_2 _inst_3 f g)) f
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u2}} {T : Type.{u1}} [_inst_1 : NonAssocSemiring.{u3} R] [_inst_2 : NonAssocSemiring.{u2} S] [_inst_3 : NonAssocSemiring.{u1} T] (f : RingHom.{u3, u2} R S _inst_1 _inst_2) (g : RingHom.{u3, u1} R T _inst_1 _inst_3), Eq.{max (succ u3) (succ u2)} (RingHom.{u3, u2} R S _inst_1 _inst_2) (RingHom.comp.{u3, max u2 u1, u2} R (Prod.{u2, u1} S T) S _inst_1 (Prod.instNonAssocSemiringProd.{u2, u1} S T _inst_2 _inst_3) _inst_2 (RingHom.fst.{u2, u1} S T _inst_2 _inst_3) (RingHom.prod.{u3, u2, u1} R S T _inst_1 _inst_2 _inst_3 f g)) f
Case conversion may be inaccurate. Consider using '#align ring_hom.fst_comp_prod RingHom.fst_comp_prodₓ'. -/
@[simp]
theorem fst_comp_prod : (fst S T).comp (f.Prod g) = f :=
  ext fun x => rfl
#align ring_hom.fst_comp_prod RingHom.fst_comp_prod

/- warning: ring_hom.snd_comp_prod -> RingHom.snd_comp_prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {T : Type.{u3}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S] [_inst_3 : NonAssocSemiring.{u3} T] (f : RingHom.{u1, u2} R S _inst_1 _inst_2) (g : RingHom.{u1, u3} R T _inst_1 _inst_3), Eq.{max (succ u1) (succ u3)} (RingHom.{u1, u3} R T _inst_1 _inst_3) (RingHom.comp.{u1, max u2 u3, u3} R (Prod.{u2, u3} S T) T _inst_1 (Prod.nonAssocSemiring.{u2, u3} S T _inst_2 _inst_3) _inst_3 (RingHom.snd.{u2, u3} S T _inst_2 _inst_3) (RingHom.prod.{u1, u2, u3} R S T _inst_1 _inst_2 _inst_3 f g)) g
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u1}} {T : Type.{u2}} [_inst_1 : NonAssocSemiring.{u3} R] [_inst_2 : NonAssocSemiring.{u1} S] [_inst_3 : NonAssocSemiring.{u2} T] (f : RingHom.{u3, u1} R S _inst_1 _inst_2) (g : RingHom.{u3, u2} R T _inst_1 _inst_3), Eq.{max (succ u3) (succ u2)} (RingHom.{u3, u2} R T _inst_1 _inst_3) (RingHom.comp.{u3, max u1 u2, u2} R (Prod.{u1, u2} S T) T _inst_1 (Prod.instNonAssocSemiringProd.{u1, u2} S T _inst_2 _inst_3) _inst_3 (RingHom.snd.{u1, u2} S T _inst_2 _inst_3) (RingHom.prod.{u3, u1, u2} R S T _inst_1 _inst_2 _inst_3 f g)) g
Case conversion may be inaccurate. Consider using '#align ring_hom.snd_comp_prod RingHom.snd_comp_prodₓ'. -/
@[simp]
theorem snd_comp_prod : (snd S T).comp (f.Prod g) = g :=
  ext fun x => rfl
#align ring_hom.snd_comp_prod RingHom.snd_comp_prod

/- warning: ring_hom.prod_unique -> RingHom.prod_unique is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {T : Type.{u3}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S] [_inst_3 : NonAssocSemiring.{u3} T] (f : RingHom.{u1, max u2 u3} R (Prod.{u2, u3} S T) _inst_1 (Prod.nonAssocSemiring.{u2, u3} S T _inst_2 _inst_3)), Eq.{max (succ u1) (succ (max u2 u3))} (RingHom.{u1, max u2 u3} R (Prod.{u2, u3} S T) _inst_1 (Prod.nonAssocSemiring.{u2, u3} S T _inst_2 _inst_3)) (RingHom.prod.{u1, u2, u3} R S T _inst_1 _inst_2 _inst_3 (RingHom.comp.{u1, max u2 u3, u2} R (Prod.{u2, u3} S T) S _inst_1 (Prod.nonAssocSemiring.{u2, u3} S T _inst_2 _inst_3) _inst_2 (RingHom.fst.{u2, u3} S T _inst_2 _inst_3) f) (RingHom.comp.{u1, max u2 u3, u3} R (Prod.{u2, u3} S T) T _inst_1 (Prod.nonAssocSemiring.{u2, u3} S T _inst_2 _inst_3) _inst_3 (RingHom.snd.{u2, u3} S T _inst_2 _inst_3) f)) f
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u1}} {T : Type.{u2}} [_inst_1 : NonAssocSemiring.{u3} R] [_inst_2 : NonAssocSemiring.{u1} S] [_inst_3 : NonAssocSemiring.{u2} T] (f : RingHom.{u3, max u2 u1} R (Prod.{u1, u2} S T) _inst_1 (Prod.instNonAssocSemiringProd.{u1, u2} S T _inst_2 _inst_3)), Eq.{max (max (succ u3) (succ u1)) (succ u2)} (RingHom.{u3, max u2 u1} R (Prod.{u1, u2} S T) _inst_1 (Prod.instNonAssocSemiringProd.{u1, u2} S T _inst_2 _inst_3)) (RingHom.prod.{u3, u1, u2} R S T _inst_1 _inst_2 _inst_3 (RingHom.comp.{u3, max u1 u2, u1} R (Prod.{u1, u2} S T) S _inst_1 (Prod.instNonAssocSemiringProd.{u1, u2} S T _inst_2 _inst_3) _inst_2 (RingHom.fst.{u1, u2} S T _inst_2 _inst_3) f) (RingHom.comp.{u3, max u1 u2, u2} R (Prod.{u1, u2} S T) T _inst_1 (Prod.instNonAssocSemiringProd.{u1, u2} S T _inst_2 _inst_3) _inst_3 (RingHom.snd.{u1, u2} S T _inst_2 _inst_3) f)) f
Case conversion may be inaccurate. Consider using '#align ring_hom.prod_unique RingHom.prod_uniqueₓ'. -/
theorem prod_unique (f : R →+* S × T) : ((fst S T).comp f).Prod ((snd S T).comp f) = f :=
  ext fun x => by simp only [prod_apply, coe_fst, coe_snd, comp_apply, Prod.mk.eta]
#align ring_hom.prod_unique RingHom.prod_unique

end Prod

section Prod_map

variable [NonAssocSemiring R'] [NonAssocSemiring S'] [NonAssocSemiring T]

variable (f : R →+* R') (g : S →+* S')

/- warning: ring_hom.prod_map -> RingHom.prodMap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {R' : Type.{u2}} {S : Type.{u3}} {S' : Type.{u4}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u3} S] [_inst_3 : NonAssocSemiring.{u2} R'] [_inst_4 : NonAssocSemiring.{u4} S'], (RingHom.{u1, u2} R R' _inst_1 _inst_3) -> (RingHom.{u3, u4} S S' _inst_2 _inst_4) -> (RingHom.{max u1 u3, max u2 u4} (Prod.{u1, u3} R S) (Prod.{u2, u4} R' S') (Prod.nonAssocSemiring.{u1, u3} R S _inst_1 _inst_2) (Prod.nonAssocSemiring.{u2, u4} R' S' _inst_3 _inst_4))
but is expected to have type
  forall {R : Type.{u1}} {R' : Type.{u2}} {S : Type.{u3}} {S' : Type.{u4}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u3} S] [_inst_3 : NonAssocSemiring.{u2} R'] [_inst_4 : NonAssocSemiring.{u4} S'], (RingHom.{u1, u2} R R' _inst_1 _inst_3) -> (RingHom.{u3, u4} S S' _inst_2 _inst_4) -> (RingHom.{max u3 u1, max u4 u2} (Prod.{u1, u3} R S) (Prod.{u2, u4} R' S') (Prod.instNonAssocSemiringProd.{u1, u3} R S _inst_1 _inst_2) (Prod.instNonAssocSemiringProd.{u2, u4} R' S' _inst_3 _inst_4))
Case conversion may be inaccurate. Consider using '#align ring_hom.prod_map RingHom.prodMapₓ'. -/
/-- `prod.map` as a `ring_hom`. -/
def prodMap : R × S →+* R' × S' :=
  (f.comp (fst R S)).Prod (g.comp (snd R S))
#align ring_hom.prod_map RingHom.prodMap

/- warning: ring_hom.prod_map_def -> RingHom.prodMap_def is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {R' : Type.{u2}} {S : Type.{u3}} {S' : Type.{u4}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u3} S] [_inst_3 : NonAssocSemiring.{u2} R'] [_inst_4 : NonAssocSemiring.{u4} S'] (f : RingHom.{u1, u2} R R' _inst_1 _inst_3) (g : RingHom.{u3, u4} S S' _inst_2 _inst_4), Eq.{max (succ (max u1 u3)) (succ (max u2 u4))} (RingHom.{max u1 u3, max u2 u4} (Prod.{u1, u3} R S) (Prod.{u2, u4} R' S') (Prod.nonAssocSemiring.{u1, u3} R S _inst_1 _inst_2) (Prod.nonAssocSemiring.{u2, u4} R' S' _inst_3 _inst_4)) (RingHom.prodMap.{u1, u2, u3, u4} R R' S S' _inst_1 _inst_2 _inst_3 _inst_4 f g) (RingHom.prod.{max u1 u3, u2, u4} (Prod.{u1, u3} R S) R' S' (Prod.nonAssocSemiring.{u1, u3} R S _inst_1 _inst_2) _inst_3 _inst_4 (RingHom.comp.{max u1 u3, u1, u2} (Prod.{u1, u3} R S) R R' (Prod.nonAssocSemiring.{u1, u3} R S _inst_1 _inst_2) _inst_1 _inst_3 f (RingHom.fst.{u1, u3} R S _inst_1 _inst_2)) (RingHom.comp.{max u1 u3, u3, u4} (Prod.{u1, u3} R S) S S' (Prod.nonAssocSemiring.{u1, u3} R S _inst_1 _inst_2) _inst_2 _inst_4 g (RingHom.snd.{u1, u3} R S _inst_1 _inst_2)))
but is expected to have type
  forall {R : Type.{u4}} {R' : Type.{u3}} {S : Type.{u2}} {S' : Type.{u1}} [_inst_1 : NonAssocSemiring.{u4} R] [_inst_2 : NonAssocSemiring.{u2} S] [_inst_3 : NonAssocSemiring.{u3} R'] [_inst_4 : NonAssocSemiring.{u1} S'] (f : RingHom.{u4, u3} R R' _inst_1 _inst_3) (g : RingHom.{u2, u1} S S' _inst_2 _inst_4), Eq.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1)} (RingHom.{max u2 u4, max u1 u3} (Prod.{u4, u2} R S) (Prod.{u3, u1} R' S') (Prod.instNonAssocSemiringProd.{u4, u2} R S _inst_1 _inst_2) (Prod.instNonAssocSemiringProd.{u3, u1} R' S' _inst_3 _inst_4)) (RingHom.prodMap.{u4, u3, u2, u1} R R' S S' _inst_1 _inst_2 _inst_3 _inst_4 f g) (RingHom.prod.{max u4 u2, u3, u1} (Prod.{u4, u2} R S) R' S' (Prod.instNonAssocSemiringProd.{u4, u2} R S _inst_1 _inst_2) _inst_3 _inst_4 (RingHom.comp.{max u4 u2, u4, u3} (Prod.{u4, u2} R S) R R' (Prod.instNonAssocSemiringProd.{u4, u2} R S _inst_1 _inst_2) _inst_1 _inst_3 f (RingHom.fst.{u4, u2} R S _inst_1 _inst_2)) (RingHom.comp.{max u4 u2, u2, u1} (Prod.{u4, u2} R S) S S' (Prod.instNonAssocSemiringProd.{u4, u2} R S _inst_1 _inst_2) _inst_2 _inst_4 g (RingHom.snd.{u4, u2} R S _inst_1 _inst_2)))
Case conversion may be inaccurate. Consider using '#align ring_hom.prod_map_def RingHom.prodMap_defₓ'. -/
theorem prodMap_def : prodMap f g = (f.comp (fst R S)).Prod (g.comp (snd R S)) :=
  rfl
#align ring_hom.prod_map_def RingHom.prodMap_def

/- warning: ring_hom.coe_prod_map -> RingHom.coe_prodMap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {R' : Type.{u2}} {S : Type.{u3}} {S' : Type.{u4}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u3} S] [_inst_3 : NonAssocSemiring.{u2} R'] [_inst_4 : NonAssocSemiring.{u4} S'] (f : RingHom.{u1, u2} R R' _inst_1 _inst_3) (g : RingHom.{u3, u4} S S' _inst_2 _inst_4), Eq.{max (succ (max u1 u3)) (succ (max u2 u4))} ((Prod.{u1, u3} R S) -> (Prod.{u2, u4} R' S')) (coeFn.{max (succ (max u1 u3)) (succ (max u2 u4)), max (succ (max u1 u3)) (succ (max u2 u4))} (RingHom.{max u1 u3, max u2 u4} (Prod.{u1, u3} R S) (Prod.{u2, u4} R' S') (Prod.nonAssocSemiring.{u1, u3} R S _inst_1 _inst_2) (Prod.nonAssocSemiring.{u2, u4} R' S' _inst_3 _inst_4)) (fun (_x : RingHom.{max u1 u3, max u2 u4} (Prod.{u1, u3} R S) (Prod.{u2, u4} R' S') (Prod.nonAssocSemiring.{u1, u3} R S _inst_1 _inst_2) (Prod.nonAssocSemiring.{u2, u4} R' S' _inst_3 _inst_4)) => (Prod.{u1, u3} R S) -> (Prod.{u2, u4} R' S')) (RingHom.hasCoeToFun.{max u1 u3, max u2 u4} (Prod.{u1, u3} R S) (Prod.{u2, u4} R' S') (Prod.nonAssocSemiring.{u1, u3} R S _inst_1 _inst_2) (Prod.nonAssocSemiring.{u2, u4} R' S' _inst_3 _inst_4)) (RingHom.prodMap.{u1, u2, u3, u4} R R' S S' _inst_1 _inst_2 _inst_3 _inst_4 f g)) (Prod.map.{u1, u2, u3, u4} R R' S S' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R R' _inst_1 _inst_3) (fun (_x : RingHom.{u1, u2} R R' _inst_1 _inst_3) => R -> R') (RingHom.hasCoeToFun.{u1, u2} R R' _inst_1 _inst_3) f) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (RingHom.{u3, u4} S S' _inst_2 _inst_4) (fun (_x : RingHom.{u3, u4} S S' _inst_2 _inst_4) => S -> S') (RingHom.hasCoeToFun.{u3, u4} S S' _inst_2 _inst_4) g))
but is expected to have type
  forall {R : Type.{u4}} {R' : Type.{u3}} {S : Type.{u2}} {S' : Type.{u1}} [_inst_1 : NonAssocSemiring.{u4} R] [_inst_2 : NonAssocSemiring.{u2} S] [_inst_3 : NonAssocSemiring.{u3} R'] [_inst_4 : NonAssocSemiring.{u1} S'] (f : RingHom.{u4, u3} R R' _inst_1 _inst_3) (g : RingHom.{u2, u1} S S' _inst_2 _inst_4), Eq.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1)} (forall (ᾰ : Prod.{u4, u2} R S), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Prod.{u4, u2} R S) => Prod.{u3, u1} R' S') ᾰ) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), max (succ u4) (succ u2), max (succ u3) (succ u1)} (RingHom.{max u2 u4, max u1 u3} (Prod.{u4, u2} R S) (Prod.{u3, u1} R' S') (Prod.instNonAssocSemiringProd.{u4, u2} R S _inst_1 _inst_2) (Prod.instNonAssocSemiringProd.{u3, u1} R' S' _inst_3 _inst_4)) (Prod.{u4, u2} R S) (fun (_x : Prod.{u4, u2} R S) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Prod.{u4, u2} R S) => Prod.{u3, u1} R' S') _x) (MulHomClass.toFunLike.{max (max (max u4 u3) u2) u1, max u4 u2, max u3 u1} (RingHom.{max u2 u4, max u1 u3} (Prod.{u4, u2} R S) (Prod.{u3, u1} R' S') (Prod.instNonAssocSemiringProd.{u4, u2} R S _inst_1 _inst_2) (Prod.instNonAssocSemiringProd.{u3, u1} R' S' _inst_3 _inst_4)) (Prod.{u4, u2} R S) (Prod.{u3, u1} R' S') (NonUnitalNonAssocSemiring.toMul.{max u4 u2} (Prod.{u4, u2} R S) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u4 u2} (Prod.{u4, u2} R S) (Prod.instNonAssocSemiringProd.{u4, u2} R S _inst_1 _inst_2))) (NonUnitalNonAssocSemiring.toMul.{max u3 u1} (Prod.{u3, u1} R' S') (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Prod.{u3, u1} R' S') (Prod.instNonAssocSemiringProd.{u3, u1} R' S' _inst_3 _inst_4))) (NonUnitalRingHomClass.toMulHomClass.{max (max (max u4 u3) u2) u1, max u4 u2, max u3 u1} (RingHom.{max u2 u4, max u1 u3} (Prod.{u4, u2} R S) (Prod.{u3, u1} R' S') (Prod.instNonAssocSemiringProd.{u4, u2} R S _inst_1 _inst_2) (Prod.instNonAssocSemiringProd.{u3, u1} R' S' _inst_3 _inst_4)) (Prod.{u4, u2} R S) (Prod.{u3, u1} R' S') (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u4 u2} (Prod.{u4, u2} R S) (Prod.instNonAssocSemiringProd.{u4, u2} R S _inst_1 _inst_2)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Prod.{u3, u1} R' S') (Prod.instNonAssocSemiringProd.{u3, u1} R' S' _inst_3 _inst_4)) (RingHomClass.toNonUnitalRingHomClass.{max (max (max u4 u3) u2) u1, max u4 u2, max u3 u1} (RingHom.{max u2 u4, max u1 u3} (Prod.{u4, u2} R S) (Prod.{u3, u1} R' S') (Prod.instNonAssocSemiringProd.{u4, u2} R S _inst_1 _inst_2) (Prod.instNonAssocSemiringProd.{u3, u1} R' S' _inst_3 _inst_4)) (Prod.{u4, u2} R S) (Prod.{u3, u1} R' S') (Prod.instNonAssocSemiringProd.{u4, u2} R S _inst_1 _inst_2) (Prod.instNonAssocSemiringProd.{u3, u1} R' S' _inst_3 _inst_4) (RingHom.instRingHomClassRingHom.{max u4 u2, max u3 u1} (Prod.{u4, u2} R S) (Prod.{u3, u1} R' S') (Prod.instNonAssocSemiringProd.{u4, u2} R S _inst_1 _inst_2) (Prod.instNonAssocSemiringProd.{u3, u1} R' S' _inst_3 _inst_4))))) (RingHom.prodMap.{u4, u3, u2, u1} R R' S S' _inst_1 _inst_2 _inst_3 _inst_4 f g)) (Prod.map.{u4, u3, u2, u1} R R' S S' (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (RingHom.{u4, u3} R R' _inst_1 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => R') _x) (MulHomClass.toFunLike.{max u4 u3, u4, u3} (RingHom.{u4, u3} R R' _inst_1 _inst_3) R R' (NonUnitalNonAssocSemiring.toMul.{u4} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u3} R' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R' _inst_3)) (NonUnitalRingHomClass.toMulHomClass.{max u4 u3, u4, u3} (RingHom.{u4, u3} R R' _inst_1 _inst_3) R R' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R' _inst_3) (RingHomClass.toNonUnitalRingHomClass.{max u4 u3, u4, u3} (RingHom.{u4, u3} R R' _inst_1 _inst_3) R R' _inst_1 _inst_3 (RingHom.instRingHomClassRingHom.{u4, u3} R R' _inst_1 _inst_3)))) f) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} S S' _inst_2 _inst_4) S (fun (_x : S) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : S) => S') _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} S S' _inst_2 _inst_4) S S' (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u1} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S' _inst_4)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} S S' _inst_2 _inst_4) S S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S' _inst_4) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} S S' _inst_2 _inst_4) S S' _inst_2 _inst_4 (RingHom.instRingHomClassRingHom.{u2, u1} S S' _inst_2 _inst_4)))) g))
Case conversion may be inaccurate. Consider using '#align ring_hom.coe_prod_map RingHom.coe_prodMapₓ'. -/
@[simp]
theorem coe_prodMap : ⇑(prodMap f g) = Prod.map f g :=
  rfl
#align ring_hom.coe_prod_map RingHom.coe_prodMap

/- warning: ring_hom.prod_comp_prod_map -> RingHom.prod_comp_prodMap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {R' : Type.{u2}} {S : Type.{u3}} {S' : Type.{u4}} {T : Type.{u5}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u3} S] [_inst_3 : NonAssocSemiring.{u2} R'] [_inst_4 : NonAssocSemiring.{u4} S'] [_inst_5 : NonAssocSemiring.{u5} T] (f : RingHom.{u5, u1} T R _inst_5 _inst_1) (g : RingHom.{u5, u3} T S _inst_5 _inst_2) (f' : RingHom.{u1, u2} R R' _inst_1 _inst_3) (g' : RingHom.{u3, u4} S S' _inst_2 _inst_4), Eq.{max (succ u5) (succ (max u2 u4))} (RingHom.{u5, max u2 u4} T (Prod.{u2, u4} R' S') _inst_5 (Prod.nonAssocSemiring.{u2, u4} R' S' _inst_3 _inst_4)) (RingHom.comp.{u5, max u1 u3, max u2 u4} T (Prod.{u1, u3} R S) (Prod.{u2, u4} R' S') _inst_5 (Prod.nonAssocSemiring.{u1, u3} R S _inst_1 _inst_2) (Prod.nonAssocSemiring.{u2, u4} R' S' _inst_3 _inst_4) (RingHom.prodMap.{u1, u2, u3, u4} R R' S S' _inst_1 _inst_2 _inst_3 _inst_4 f' g') (RingHom.prod.{u5, u1, u3} T R S _inst_5 _inst_1 _inst_2 f g)) (RingHom.prod.{u5, u2, u4} T R' S' _inst_5 _inst_3 _inst_4 (RingHom.comp.{u5, u1, u2} T R R' _inst_5 _inst_1 _inst_3 f' f) (RingHom.comp.{u5, u3, u4} T S S' _inst_5 _inst_2 _inst_4 g' g))
but is expected to have type
  forall {R : Type.{u4}} {R' : Type.{u2}} {S : Type.{u3}} {S' : Type.{u1}} {T : Type.{u5}} [_inst_1 : NonAssocSemiring.{u4} R] [_inst_2 : NonAssocSemiring.{u3} S] [_inst_3 : NonAssocSemiring.{u2} R'] [_inst_4 : NonAssocSemiring.{u1} S'] [_inst_5 : NonAssocSemiring.{u5} T] (f : RingHom.{u5, u4} T R _inst_5 _inst_1) (g : RingHom.{u5, u3} T S _inst_5 _inst_2) (f' : RingHom.{u4, u2} R R' _inst_1 _inst_3) (g' : RingHom.{u3, u1} S S' _inst_2 _inst_4), Eq.{max (max (succ u2) (succ u1)) (succ u5)} (RingHom.{u5, max u2 u1} T (Prod.{u2, u1} R' S') _inst_5 (Prod.instNonAssocSemiringProd.{u2, u1} R' S' _inst_3 _inst_4)) (RingHom.comp.{u5, max u4 u3, max u2 u1} T (Prod.{u4, u3} R S) (Prod.{u2, u1} R' S') _inst_5 (Prod.instNonAssocSemiringProd.{u4, u3} R S _inst_1 _inst_2) (Prod.instNonAssocSemiringProd.{u2, u1} R' S' _inst_3 _inst_4) (RingHom.prodMap.{u4, u2, u3, u1} R R' S S' _inst_1 _inst_2 _inst_3 _inst_4 f' g') (RingHom.prod.{u5, u4, u3} T R S _inst_5 _inst_1 _inst_2 f g)) (RingHom.prod.{u5, u2, u1} T R' S' _inst_5 _inst_3 _inst_4 (RingHom.comp.{u5, u4, u2} T R R' _inst_5 _inst_1 _inst_3 f' f) (RingHom.comp.{u5, u3, u1} T S S' _inst_5 _inst_2 _inst_4 g' g))
Case conversion may be inaccurate. Consider using '#align ring_hom.prod_comp_prod_map RingHom.prod_comp_prodMapₓ'. -/
theorem prod_comp_prodMap (f : T →+* R) (g : T →+* S) (f' : R →+* R') (g' : S →+* S') :
    (f'.Prod_map g').comp (f.Prod g) = (f'.comp f).Prod (g'.comp g) :=
  rfl
#align ring_hom.prod_comp_prod_map RingHom.prod_comp_prodMap

end Prod_map

end RingHom

namespace RingEquiv

variable {R S} [NonAssocSemiring R] [NonAssocSemiring S]

/- warning: ring_equiv.prod_comm -> RingEquiv.prodComm is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S], RingEquiv.{max u1 u2, max u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.hasMul.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasAdd.{u1, u2} R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasMul.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (Prod.hasAdd.{u2, u1} S R (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S], RingEquiv.{max u2 u1, max u1 u2} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.instMulProd.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Prod.instMulProd.{u2, u1} S R (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Prod.instAddSum.{u1, u2} R S (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.instAddSum.{u2, u1} S R (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align ring_equiv.prod_comm RingEquiv.prodCommₓ'. -/
/-- Swapping components as an equivalence of (semi)rings. -/
def prodComm : R × S ≃+* S × R :=
  { AddEquiv.prodComm, MulEquiv.prodComm with }
#align ring_equiv.prod_comm RingEquiv.prodComm

/- warning: ring_equiv.coe_prod_comm -> RingEquiv.coe_prod_comm is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S], Eq.{max (succ (max u1 u2)) (succ (max u2 u1))} ((Prod.{u1, u2} R S) -> (Prod.{u2, u1} S R)) (coeFn.{max (succ (max u1 u2)) (succ (max u2 u1)), max (succ (max u1 u2)) (succ (max u2 u1))} (RingEquiv.{max u1 u2, max u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.hasMul.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasAdd.{u1, u2} R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasMul.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (Prod.hasAdd.{u2, u1} S R (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))))) (fun (_x : RingEquiv.{max u1 u2, max u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.hasMul.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasAdd.{u1, u2} R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasMul.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (Prod.hasAdd.{u2, u1} S R (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))))) => (Prod.{u1, u2} R S) -> (Prod.{u2, u1} S R)) (RingEquiv.hasCoeToFun.{max u1 u2, max u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.hasMul.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasAdd.{u1, u2} R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasMul.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (Prod.hasAdd.{u2, u1} S R (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))))) (RingEquiv.prodComm.{u1, u2} R S _inst_1 _inst_2)) (Prod.swap.{u1, u2} R S)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} R] [_inst_2 : NonAssocSemiring.{u1} S], Eq.{max (succ u2) (succ u1)} (forall (ᾰ : Prod.{u2, u1} R S), (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Prod.{u2, u1} R S) => Prod.{u1, u2} S R) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingEquiv.{max u1 u2, max u2 u1} (Prod.{u2, u1} R S) (Prod.{u1, u2} S R) (Prod.instMulProd.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Prod.instMulProd.{u1, u2} S R (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Prod.instAddSum.{u2, u1} R S (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) (Prod.instAddSum.{u1, u2} S R (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))))) (Prod.{u2, u1} R S) (fun (_x : Prod.{u2, u1} R S) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Prod.{u2, u1} R S) => Prod.{u1, u2} S R) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingEquiv.{max u1 u2, max u2 u1} (Prod.{u2, u1} R S) (Prod.{u1, u2} S R) (Prod.instMulProd.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Prod.instMulProd.{u1, u2} S R (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Prod.instAddSum.{u2, u1} R S (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) (Prod.instAddSum.{u1, u2} S R (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))))) (Prod.{u2, u1} R S) (Prod.{u1, u2} S R) (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingEquiv.{max u1 u2, max u2 u1} (Prod.{u2, u1} R S) (Prod.{u1, u2} S R) (Prod.instMulProd.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Prod.instMulProd.{u1, u2} S R (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Prod.instAddSum.{u2, u1} R S (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) (Prod.instAddSum.{u1, u2} S R (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))))) (Prod.{u2, u1} R S) (Prod.{u1, u2} S R) (MulEquivClass.toEquivLike.{max u2 u1, max u2 u1, max u2 u1} (RingEquiv.{max u1 u2, max u2 u1} (Prod.{u2, u1} R S) (Prod.{u1, u2} S R) (Prod.instMulProd.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Prod.instMulProd.{u1, u2} S R (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Prod.instAddSum.{u2, u1} R S (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) (Prod.instAddSum.{u1, u2} S R (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))))) (Prod.{u2, u1} R S) (Prod.{u1, u2} S R) (Prod.instMulProd.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Prod.instMulProd.{u1, u2} S R (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (RingEquivClass.toMulEquivClass.{max u2 u1, max u2 u1, max u2 u1} (RingEquiv.{max u1 u2, max u2 u1} (Prod.{u2, u1} R S) (Prod.{u1, u2} S R) (Prod.instMulProd.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Prod.instMulProd.{u1, u2} S R (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Prod.instAddSum.{u2, u1} R S (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) (Prod.instAddSum.{u1, u2} S R (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))))) (Prod.{u2, u1} R S) (Prod.{u1, u2} S R) (Prod.instMulProd.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Prod.instAddSum.{u2, u1} R S (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) (Prod.instMulProd.{u1, u2} S R (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Prod.instAddSum.{u1, u2} S R (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)))) (RingEquiv.instRingEquivClassRingEquiv.{max u2 u1, max u2 u1} (Prod.{u2, u1} R S) (Prod.{u1, u2} S R) (Prod.instMulProd.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Prod.instMulProd.{u1, u2} S R (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Prod.instAddSum.{u2, u1} R S (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) (Prod.instAddSum.{u1, u2} S R (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))))))))) (RingEquiv.prodComm.{u2, u1} R S _inst_1 _inst_2)) (Prod.swap.{u2, u1} R S)
Case conversion may be inaccurate. Consider using '#align ring_equiv.coe_prod_comm RingEquiv.coe_prod_commₓ'. -/
@[simp]
theorem coe_prod_comm : ⇑(prodComm : R × S ≃+* S × R) = Prod.swap :=
  rfl
#align ring_equiv.coe_prod_comm RingEquiv.coe_prod_comm

/- warning: ring_equiv.coe_prod_comm_symm -> RingEquiv.coe_prod_comm_symm is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S], Eq.{max (succ (max u2 u1)) (succ (max u1 u2))} ((Prod.{u2, u1} S R) -> (Prod.{u1, u2} R S)) (coeFn.{max (succ (max u2 u1)) (succ (max u1 u2)), max (succ (max u2 u1)) (succ (max u1 u2))} (RingEquiv.{max u2 u1, max u1 u2} (Prod.{u2, u1} S R) (Prod.{u1, u2} R S) (Prod.hasMul.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (Prod.hasAdd.{u2, u1} S R (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (Prod.hasMul.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasAdd.{u1, u2} R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))))) (fun (_x : RingEquiv.{max u2 u1, max u1 u2} (Prod.{u2, u1} S R) (Prod.{u1, u2} R S) (Prod.hasMul.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (Prod.hasAdd.{u2, u1} S R (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (Prod.hasMul.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasAdd.{u1, u2} R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))))) => (Prod.{u2, u1} S R) -> (Prod.{u1, u2} R S)) (RingEquiv.hasCoeToFun.{max u2 u1, max u1 u2} (Prod.{u2, u1} S R) (Prod.{u1, u2} R S) (Prod.hasMul.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (Prod.hasAdd.{u2, u1} S R (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (Prod.hasMul.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasAdd.{u1, u2} R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))))) (RingEquiv.symm.{max u1 u2, max u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.hasMul.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasAdd.{u1, u2} R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasMul.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (Prod.hasAdd.{u2, u1} S R (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (RingEquiv.prodComm.{u1, u2} R S _inst_1 _inst_2))) (Prod.swap.{u2, u1} S R)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} R] [_inst_2 : NonAssocSemiring.{u1} S], Eq.{max (succ u2) (succ u1)} (forall (ᾰ : Prod.{u1, u2} S R), (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Prod.{u1, u2} S R) => Prod.{u2, u1} R S) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingEquiv.{max u2 u1, max u2 u1} (Prod.{u1, u2} S R) (Prod.{u2, u1} R S) (Prod.instMulProd.{u1, u2} S R (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Prod.instMulProd.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Prod.instAddSum.{u1, u2} S R (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)))) (Prod.instAddSum.{u2, u1} R S (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))))) (Prod.{u1, u2} S R) (fun (_x : Prod.{u1, u2} S R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Prod.{u1, u2} S R) => Prod.{u2, u1} R S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingEquiv.{max u2 u1, max u2 u1} (Prod.{u1, u2} S R) (Prod.{u2, u1} R S) (Prod.instMulProd.{u1, u2} S R (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Prod.instMulProd.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Prod.instAddSum.{u1, u2} S R (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)))) (Prod.instAddSum.{u2, u1} R S (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))))) (Prod.{u1, u2} S R) (Prod.{u2, u1} R S) (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingEquiv.{max u2 u1, max u2 u1} (Prod.{u1, u2} S R) (Prod.{u2, u1} R S) (Prod.instMulProd.{u1, u2} S R (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Prod.instMulProd.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Prod.instAddSum.{u1, u2} S R (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)))) (Prod.instAddSum.{u2, u1} R S (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))))) (Prod.{u1, u2} S R) (Prod.{u2, u1} R S) (MulEquivClass.toEquivLike.{max u2 u1, max u2 u1, max u2 u1} (RingEquiv.{max u2 u1, max u2 u1} (Prod.{u1, u2} S R) (Prod.{u2, u1} R S) (Prod.instMulProd.{u1, u2} S R (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Prod.instMulProd.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Prod.instAddSum.{u1, u2} S R (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)))) (Prod.instAddSum.{u2, u1} R S (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))))) (Prod.{u1, u2} S R) (Prod.{u2, u1} R S) (Prod.instMulProd.{u1, u2} S R (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Prod.instMulProd.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (RingEquivClass.toMulEquivClass.{max u2 u1, max u2 u1, max u2 u1} (RingEquiv.{max u2 u1, max u2 u1} (Prod.{u1, u2} S R) (Prod.{u2, u1} R S) (Prod.instMulProd.{u1, u2} S R (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Prod.instMulProd.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Prod.instAddSum.{u1, u2} S R (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)))) (Prod.instAddSum.{u2, u1} R S (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))))) (Prod.{u1, u2} S R) (Prod.{u2, u1} R S) (Prod.instMulProd.{u1, u2} S R (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Prod.instAddSum.{u1, u2} S R (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)))) (Prod.instMulProd.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Prod.instAddSum.{u2, u1} R S (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) (RingEquiv.instRingEquivClassRingEquiv.{max u2 u1, max u2 u1} (Prod.{u1, u2} S R) (Prod.{u2, u1} R S) (Prod.instMulProd.{u1, u2} S R (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Prod.instMulProd.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Prod.instAddSum.{u1, u2} S R (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)))) (Prod.instAddSum.{u2, u1} R S (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))))))))) (RingEquiv.symm.{max u2 u1, max u2 u1} (Prod.{u2, u1} R S) (Prod.{u1, u2} S R) (Prod.instMulProd.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Prod.instMulProd.{u1, u2} S R (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Prod.instAddSum.{u2, u1} R S (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) (Prod.instAddSum.{u1, u2} S R (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)))) (RingEquiv.prodComm.{u2, u1} R S _inst_1 _inst_2))) (Prod.swap.{u1, u2} S R)
Case conversion may be inaccurate. Consider using '#align ring_equiv.coe_prod_comm_symm RingEquiv.coe_prod_comm_symmₓ'. -/
@[simp]
theorem coe_prod_comm_symm : ⇑(prodComm : R × S ≃+* S × R).symm = Prod.swap :=
  rfl
#align ring_equiv.coe_prod_comm_symm RingEquiv.coe_prod_comm_symm

/- warning: ring_equiv.fst_comp_coe_prod_comm -> RingEquiv.fst_comp_coe_prod_comm is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S], Eq.{max (succ (max u1 u2)) (succ u2)} (RingHom.{max u1 u2, u2} (Prod.{u1, u2} R S) S (Prod.nonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) _inst_2) (RingHom.comp.{max u1 u2, max u2 u1, u2} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) S (Prod.nonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) (Prod.nonAssocSemiring.{u2, u1} S R _inst_2 _inst_1) _inst_2 (RingHom.fst.{u2, u1} S R _inst_2 _inst_1) ((fun (a : Sort.{max (succ (max u1 u2)) (succ (max u2 u1))}) (b : Sort.{max (succ (max u1 u2)) (succ (max u2 u1))}) [self : HasLiftT.{max (succ (max u1 u2)) (succ (max u2 u1)), max (succ (max u1 u2)) (succ (max u2 u1))} a b] => self.0) (RingEquiv.{max u1 u2, max u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.hasMul.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasAdd.{u1, u2} R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasMul.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (Prod.hasAdd.{u2, u1} S R (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))))) (RingHom.{max u1 u2, max u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.nonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) (Prod.nonAssocSemiring.{u2, u1} S R _inst_2 _inst_1)) (HasLiftT.mk.{max (succ (max u1 u2)) (succ (max u2 u1)), max (succ (max u1 u2)) (succ (max u2 u1))} (RingEquiv.{max u1 u2, max u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.hasMul.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasAdd.{u1, u2} R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasMul.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (Prod.hasAdd.{u2, u1} S R (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))))) (RingHom.{max u1 u2, max u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.nonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) (Prod.nonAssocSemiring.{u2, u1} S R _inst_2 _inst_1)) (CoeTCₓ.coe.{max (succ (max u1 u2)) (succ (max u2 u1)), max (succ (max u1 u2)) (succ (max u2 u1))} (RingEquiv.{max u1 u2, max u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.hasMul.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasAdd.{u1, u2} R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasMul.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (Prod.hasAdd.{u2, u1} S R (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))))) (RingHom.{max u1 u2, max u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.nonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) (Prod.nonAssocSemiring.{u2, u1} S R _inst_2 _inst_1)) (RingHom.hasCoeT.{max (max u1 u2) u2 u1, max u1 u2, max u2 u1} (RingEquiv.{max u1 u2, max u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.hasMul.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasAdd.{u1, u2} R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasMul.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (Prod.hasAdd.{u2, u1} S R (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))))) (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.nonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) (Prod.nonAssocSemiring.{u2, u1} S R _inst_2 _inst_1) (RingEquivClass.toRingHomClass.{max (max u1 u2) u2 u1, max u1 u2, max u2 u1} (RingEquiv.{max u1 u2, max u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.hasMul.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasAdd.{u1, u2} R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasMul.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (Prod.hasAdd.{u2, u1} S R (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))))) (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.nonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) (Prod.nonAssocSemiring.{u2, u1} S R _inst_2 _inst_1) (RingEquiv.ringEquivClass.{max u1 u2, max u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.hasMul.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasAdd.{u1, u2} R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasMul.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (Prod.hasAdd.{u2, u1} S R (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))))))))) (RingEquiv.prodComm.{u1, u2} R S _inst_1 _inst_2))) (RingHom.snd.{u1, u2} R S _inst_1 _inst_2)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} R] [_inst_2 : NonAssocSemiring.{u1} S], Eq.{max (succ u2) (succ u1)} (RingHom.{max u2 u1, u1} (Prod.{u2, u1} R S) S (Prod.instNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2) _inst_2) (RingHom.comp.{max u2 u1, max u2 u1, u1} (Prod.{u2, u1} R S) (Prod.{u1, u2} S R) S (Prod.instNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2) (Prod.instNonAssocSemiringProd.{u1, u2} S R _inst_2 _inst_1) _inst_2 (RingHom.fst.{u1, u2} S R _inst_2 _inst_1) (RingHomClass.toRingHom.{max u2 u1, max u2 u1, max u2 u1} (RingEquiv.{max u1 u2, max u2 u1} (Prod.{u2, u1} R S) (Prod.{u1, u2} S R) (Prod.instMulProd.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Prod.instMulProd.{u1, u2} S R (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Prod.instAddSum.{u2, u1} R S (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) (Prod.instAddSum.{u1, u2} S R (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))))) (Prod.{u2, u1} R S) (Prod.{u1, u2} S R) (Prod.instNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2) (Prod.instNonAssocSemiringProd.{u1, u2} S R _inst_2 _inst_1) (RingEquivClass.toRingHomClass.{max u2 u1, max u2 u1, max u2 u1} (RingEquiv.{max u1 u2, max u2 u1} (Prod.{u2, u1} R S) (Prod.{u1, u2} S R) (Prod.instMulProd.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Prod.instMulProd.{u1, u2} S R (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Prod.instAddSum.{u2, u1} R S (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) (Prod.instAddSum.{u1, u2} S R (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))))) (Prod.{u2, u1} R S) (Prod.{u1, u2} S R) (Prod.instNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2) (Prod.instNonAssocSemiringProd.{u1, u2} S R _inst_2 _inst_1) (RingEquiv.instRingEquivClassRingEquiv.{max u2 u1, max u2 u1} (Prod.{u2, u1} R S) (Prod.{u1, u2} S R) (Prod.instMulProd.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Prod.instMulProd.{u1, u2} S R (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Prod.instAddSum.{u2, u1} R S (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) (Prod.instAddSum.{u1, u2} S R (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)))))) (RingEquiv.prodComm.{u2, u1} R S _inst_1 _inst_2))) (RingHom.snd.{u2, u1} R S _inst_1 _inst_2)
Case conversion may be inaccurate. Consider using '#align ring_equiv.fst_comp_coe_prod_comm RingEquiv.fst_comp_coe_prod_commₓ'. -/
@[simp]
theorem fst_comp_coe_prod_comm :
    (RingHom.fst S R).comp ↑(prodComm : R × S ≃+* S × R) = RingHom.snd R S :=
  RingHom.ext fun _ => rfl
#align ring_equiv.fst_comp_coe_prod_comm RingEquiv.fst_comp_coe_prod_comm

/- warning: ring_equiv.snd_comp_coe_prod_comm -> RingEquiv.snd_comp_coe_prod_comm is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S], Eq.{max (succ (max u1 u2)) (succ u1)} (RingHom.{max u1 u2, u1} (Prod.{u1, u2} R S) R (Prod.nonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) _inst_1) (RingHom.comp.{max u1 u2, max u2 u1, u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) R (Prod.nonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) (Prod.nonAssocSemiring.{u2, u1} S R _inst_2 _inst_1) _inst_1 (RingHom.snd.{u2, u1} S R _inst_2 _inst_1) ((fun (a : Sort.{max (succ (max u1 u2)) (succ (max u2 u1))}) (b : Sort.{max (succ (max u1 u2)) (succ (max u2 u1))}) [self : HasLiftT.{max (succ (max u1 u2)) (succ (max u2 u1)), max (succ (max u1 u2)) (succ (max u2 u1))} a b] => self.0) (RingEquiv.{max u1 u2, max u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.hasMul.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasAdd.{u1, u2} R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasMul.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (Prod.hasAdd.{u2, u1} S R (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))))) (RingHom.{max u1 u2, max u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.nonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) (Prod.nonAssocSemiring.{u2, u1} S R _inst_2 _inst_1)) (HasLiftT.mk.{max (succ (max u1 u2)) (succ (max u2 u1)), max (succ (max u1 u2)) (succ (max u2 u1))} (RingEquiv.{max u1 u2, max u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.hasMul.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasAdd.{u1, u2} R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasMul.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (Prod.hasAdd.{u2, u1} S R (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))))) (RingHom.{max u1 u2, max u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.nonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) (Prod.nonAssocSemiring.{u2, u1} S R _inst_2 _inst_1)) (CoeTCₓ.coe.{max (succ (max u1 u2)) (succ (max u2 u1)), max (succ (max u1 u2)) (succ (max u2 u1))} (RingEquiv.{max u1 u2, max u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.hasMul.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasAdd.{u1, u2} R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasMul.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (Prod.hasAdd.{u2, u1} S R (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))))) (RingHom.{max u1 u2, max u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.nonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) (Prod.nonAssocSemiring.{u2, u1} S R _inst_2 _inst_1)) (RingHom.hasCoeT.{max (max u1 u2) u2 u1, max u1 u2, max u2 u1} (RingEquiv.{max u1 u2, max u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.hasMul.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasAdd.{u1, u2} R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasMul.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (Prod.hasAdd.{u2, u1} S R (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))))) (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.nonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) (Prod.nonAssocSemiring.{u2, u1} S R _inst_2 _inst_1) (RingEquivClass.toRingHomClass.{max (max u1 u2) u2 u1, max u1 u2, max u2 u1} (RingEquiv.{max u1 u2, max u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.hasMul.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasAdd.{u1, u2} R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasMul.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (Prod.hasAdd.{u2, u1} S R (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))))) (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.nonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) (Prod.nonAssocSemiring.{u2, u1} S R _inst_2 _inst_1) (RingEquiv.ringEquivClass.{max u1 u2, max u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.hasMul.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasAdd.{u1, u2} R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasMul.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (Prod.hasAdd.{u2, u1} S R (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))))))))) (RingEquiv.prodComm.{u1, u2} R S _inst_1 _inst_2))) (RingHom.fst.{u1, u2} R S _inst_1 _inst_2)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} R] [_inst_2 : NonAssocSemiring.{u1} S], Eq.{max (succ u2) (succ u1)} (RingHom.{max u2 u1, u2} (Prod.{u2, u1} R S) R (Prod.instNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2) _inst_1) (RingHom.comp.{max u2 u1, max u2 u1, u2} (Prod.{u2, u1} R S) (Prod.{u1, u2} S R) R (Prod.instNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2) (Prod.instNonAssocSemiringProd.{u1, u2} S R _inst_2 _inst_1) _inst_1 (RingHom.snd.{u1, u2} S R _inst_2 _inst_1) (RingHomClass.toRingHom.{max u2 u1, max u2 u1, max u2 u1} (RingEquiv.{max u1 u2, max u2 u1} (Prod.{u2, u1} R S) (Prod.{u1, u2} S R) (Prod.instMulProd.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Prod.instMulProd.{u1, u2} S R (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Prod.instAddSum.{u2, u1} R S (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) (Prod.instAddSum.{u1, u2} S R (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))))) (Prod.{u2, u1} R S) (Prod.{u1, u2} S R) (Prod.instNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2) (Prod.instNonAssocSemiringProd.{u1, u2} S R _inst_2 _inst_1) (RingEquivClass.toRingHomClass.{max u2 u1, max u2 u1, max u2 u1} (RingEquiv.{max u1 u2, max u2 u1} (Prod.{u2, u1} R S) (Prod.{u1, u2} S R) (Prod.instMulProd.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Prod.instMulProd.{u1, u2} S R (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Prod.instAddSum.{u2, u1} R S (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) (Prod.instAddSum.{u1, u2} S R (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))))) (Prod.{u2, u1} R S) (Prod.{u1, u2} S R) (Prod.instNonAssocSemiringProd.{u2, u1} R S _inst_1 _inst_2) (Prod.instNonAssocSemiringProd.{u1, u2} S R _inst_2 _inst_1) (RingEquiv.instRingEquivClassRingEquiv.{max u2 u1, max u2 u1} (Prod.{u2, u1} R S) (Prod.{u1, u2} S R) (Prod.instMulProd.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Prod.instMulProd.{u1, u2} S R (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Prod.instAddSum.{u2, u1} R S (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) (Prod.instAddSum.{u1, u2} S R (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)))))) (RingEquiv.prodComm.{u2, u1} R S _inst_1 _inst_2))) (RingHom.fst.{u2, u1} R S _inst_1 _inst_2)
Case conversion may be inaccurate. Consider using '#align ring_equiv.snd_comp_coe_prod_comm RingEquiv.snd_comp_coe_prod_commₓ'. -/
@[simp]
theorem snd_comp_coe_prod_comm :
    (RingHom.snd S R).comp ↑(prodComm : R × S ≃+* S × R) = RingHom.fst R S :=
  RingHom.ext fun _ => rfl
#align ring_equiv.snd_comp_coe_prod_comm RingEquiv.snd_comp_coe_prod_comm

variable (R S) [Subsingleton S]

/- warning: ring_equiv.prod_zero_ring -> RingEquiv.prodZeroRing is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (S : Type.{u2}) [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S] [_inst_3 : Subsingleton.{succ u2} S], RingEquiv.{u1, max u1 u2} R (Prod.{u1, u2} R S) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Prod.hasMul.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (Prod.hasAdd.{u1, u2} R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))))
but is expected to have type
  forall (R : Type.{u1}) (S : Type.{u2}) [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S] [_inst_3 : Subsingleton.{succ u2} S], RingEquiv.{u1, max u2 u1} R (Prod.{u1, u2} R S) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (Prod.instMulProd.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Prod.instAddSum.{u1, u2} R S (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))))
Case conversion may be inaccurate. Consider using '#align ring_equiv.prod_zero_ring RingEquiv.prodZeroRingₓ'. -/
/-- A ring `R` is isomorphic to `R × S` when `S` is the zero ring -/
@[simps]
def prodZeroRing : R ≃+* R × S where
  toFun x := (x, 0)
  invFun := Prod.fst
  map_add' := by simp
  map_mul' := by simp
  left_inv x := rfl
  right_inv x := by cases x <;> simp
#align ring_equiv.prod_zero_ring RingEquiv.prodZeroRing

/- warning: ring_equiv.zero_ring_prod -> RingEquiv.zeroRingProd is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (S : Type.{u2}) [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S] [_inst_3 : Subsingleton.{succ u2} S], RingEquiv.{u1, max u2 u1} R (Prod.{u2, u1} S R) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Prod.hasMul.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (Prod.hasAdd.{u2, u1} S R (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))))
but is expected to have type
  forall (R : Type.{u1}) (S : Type.{u2}) [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S] [_inst_3 : Subsingleton.{succ u2} S], RingEquiv.{u1, max u1 u2} R (Prod.{u2, u1} S R) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (Prod.instMulProd.{u2, u1} S R (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Prod.instAddSum.{u2, u1} S R (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align ring_equiv.zero_ring_prod RingEquiv.zeroRingProdₓ'. -/
/-- A ring `R` is isomorphic to `S × R` when `S` is the zero ring -/
@[simps]
def zeroRingProd : R ≃+* S × R where
  toFun x := (0, x)
  invFun := Prod.snd
  map_add' := by simp
  map_mul' := by simp
  left_inv x := rfl
  right_inv x := by cases x <;> simp
#align ring_equiv.zero_ring_prod RingEquiv.zeroRingProd

end RingEquiv

/- warning: false_of_nontrivial_of_product_domain -> false_of_nontrivial_of_product_domain is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (S : Type.{u2}) [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] [_inst_3 : IsDomain.{max u1 u2} (Prod.{u1, u2} R S) (Prod.semiring.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2))] [_inst_4 : Nontrivial.{u1} R] [_inst_5 : Nontrivial.{u2} S], False
but is expected to have type
  forall (R : Type.{u2}) (S : Type.{u1}) [_inst_1 : Ring.{u2} R] [_inst_2 : Ring.{u1} S] [_inst_3 : IsDomain.{max u1 u2} (Prod.{u2, u1} R S) (Prod.instSemiringProd.{u2, u1} R S (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} S _inst_2))] [_inst_4 : Nontrivial.{u2} R] [_inst_5 : Nontrivial.{u1} S], False
Case conversion may be inaccurate. Consider using '#align false_of_nontrivial_of_product_domain false_of_nontrivial_of_product_domainₓ'. -/
/-- The product of two nontrivial rings is not a domain -/
theorem false_of_nontrivial_of_product_domain (R S : Type _) [Ring R] [Ring S] [IsDomain (R × S)]
    [Nontrivial R] [Nontrivial S] : False :=
  by
  have :=
    NoZeroDivisors.eq_zero_or_eq_zero_of_mul_eq_zero (show ((0 : R), (1 : S)) * (1, 0) = 0 by simp)
  rw [Prod.mk_eq_zero, Prod.mk_eq_zero] at this
  rcases this with (⟨_, h⟩ | ⟨h, _⟩)
  · exact zero_ne_one h.symm
  · exact zero_ne_one h.symm
#align false_of_nontrivial_of_product_domain false_of_nontrivial_of_product_domain

/-! ### Order -/


instance [OrderedSemiring α] [OrderedSemiring β] : OrderedSemiring (α × β) :=
  { Prod.semiring,
    Prod.partialOrder _ _ with
    add_le_add_left := fun _ _ => add_le_add_left
    zero_le_one := ⟨zero_le_one, zero_le_one⟩
    mul_le_mul_of_nonneg_left := fun a b c hab hc =>
      ⟨mul_le_mul_of_nonneg_left hab.1 hc.1, mul_le_mul_of_nonneg_left hab.2 hc.2⟩
    mul_le_mul_of_nonneg_right := fun a b c hab hc =>
      ⟨mul_le_mul_of_nonneg_right hab.1 hc.1, mul_le_mul_of_nonneg_right hab.2 hc.2⟩ }

instance [OrderedCommSemiring α] [OrderedCommSemiring β] : OrderedCommSemiring (α × β) :=
  { Prod.commSemiring, Prod.orderedSemiring with }

instance [OrderedRing α] [OrderedRing β] : OrderedRing (α × β) :=
  { Prod.ring, Prod.orderedSemiring with
    mul_nonneg := fun a b ha hb => ⟨mul_nonneg ha.1 hb.1, mul_nonneg ha.2 hb.2⟩ }

instance [OrderedCommRing α] [OrderedCommRing β] : OrderedCommRing (α × β) :=
  { Prod.commRing, Prod.orderedRing with }

