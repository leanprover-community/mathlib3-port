/-
Copyright (c) 2018 Johannes Hölzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes Hölzl, Callum Sutton, Yury Kudryashov

! This file was ported from Lean 3 source module algebra.ring.equiv
! leanprover-community/mathlib commit d3e8e0a0237c10c2627bf52c246b15ff8e7df4c0
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Group.Opposite
import Mathbin.Algebra.Hom.Ring
import Mathbin.Logic.Equiv.Set
import Mathbin.Tactic.AssertExists

/-!
# (Semi)ring equivs

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file we define extension of `equiv` called `ring_equiv`, which is a datatype representing an
isomorphism of `semiring`s, `ring`s, `division_ring`s, or `field`s. We also introduce the
corresponding group of automorphisms `ring_aut`.

## Notations

* ``infix ` ≃+* `:25 := ring_equiv``

The extended equiv have coercions to functions, and the coercion is the canonical notation when
treating the isomorphism as maps.

## Implementation notes

The fields for `ring_equiv` now avoid the unbundled `is_mul_hom` and `is_add_hom`, as these are
deprecated.

Definition of multiplication in the groups of automorphisms agrees with function composition,
multiplication in `equiv.perm`, and multiplication in `category_theory.End`, not with
`category_theory.comp`.

## Tags

equiv, mul_equiv, add_equiv, ring_equiv, mul_aut, add_aut, ring_aut
-/


variable {F α β R S S' : Type _}

/- warning: ring_equiv -> RingEquiv is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (S : Type.{u2}) [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Mul.{u2} S] [_inst_4 : Add.{u2} S], Sort.{max (succ u1) (succ u2)}
but is expected to have type
  forall (R : Type.{u1}) (S : Type.{u2}) [_inst_1 : Mul.{u1} R] [_inst_2 : Mul.{u2} S] [_inst_3 : Add.{u1} R] [_inst_4 : Add.{u2} S], Sort.{max (succ u1) (succ u2)}
Case conversion may be inaccurate. Consider using '#align ring_equiv RingEquivₓ'. -/
/-- An equivalence between two (non-unital non-associative semi)rings that preserves the
algebraic structure. -/
structure RingEquiv (R S : Type _) [Mul R] [Add R] [Mul S] [Add S] extends R ≃ S, R ≃* S, R ≃+ S
#align ring_equiv RingEquiv

-- mathport name: «expr ≃+* »
infixl:25 " ≃+* " => RingEquiv

/-- The "plain" equivalence of types underlying an equivalence of (semi)rings. -/
add_decl_doc RingEquiv.toEquiv

/-- The equivalence of additive monoids underlying an equivalence of (semi)rings. -/
add_decl_doc RingEquiv.toAddEquiv

/-- The equivalence of multiplicative monoids underlying an equivalence of (semi)rings. -/
add_decl_doc RingEquiv.toMulEquiv

#print RingEquivClass /-
/-- `ring_equiv_class F R S` states that `F` is a type of ring structure preserving equivalences.
You should extend this class when you extend `ring_equiv`. -/
class RingEquivClass (F : Type _) (R S : outParam (Type _)) [Mul R] [Add R] [Mul S] [Add S] extends
  MulEquivClass F R S where
  map_add : ∀ (f : F) (a b), f (a + b) = f a + f b
#align ring_equiv_class RingEquivClass
-/

namespace RingEquivClass

#print RingEquivClass.toAddEquivClass /-
-- See note [lower instance priority]
instance (priority := 100) toAddEquivClass (F R S : Type _) [Mul R] [Add R] [Mul S] [Add S]
    [h : RingEquivClass F R S] : AddEquivClass F R S :=
  { h with coe := coeFn }
#align ring_equiv_class.to_add_equiv_class RingEquivClass.toAddEquivClass
-/

/- warning: ring_equiv_class.to_ring_hom_class -> RingEquivClass.toRingHomClass is a dubious translation:
lean 3 declaration is
  forall (F : Type.{u1}) (R : Type.{u2}) (S : Type.{u3}) [_inst_1 : NonAssocSemiring.{u2} R] [_inst_2 : NonAssocSemiring.{u3} S] [h : RingEquivClass.{u1, u2, u3} F R S (Distrib.toHasMul.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toHasAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toHasMul.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S _inst_2))) (Distrib.toHasAdd.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S _inst_2)))], RingHomClass.{u1, u2, u3} F R S _inst_1 _inst_2
but is expected to have type
  forall {F : Type.{u1}} {R : Type.{u2}} {S : Type.{u3}} {_inst_1 : NonAssocSemiring.{u2} R} {_inst_2 : NonAssocSemiring.{u3} S} [h : RingEquivClass.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S _inst_2)) (Distrib.toAdd.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S _inst_2)))], RingHomClass.{u1, u2, u3} F R S _inst_1 _inst_2
Case conversion may be inaccurate. Consider using '#align ring_equiv_class.to_ring_hom_class RingEquivClass.toRingHomClassₓ'. -/
-- See note [lower instance priority]
instance (priority := 100) toRingHomClass (F R S : Type _) [NonAssocSemiring R] [NonAssocSemiring S]
    [h : RingEquivClass F R S] : RingHomClass F R S :=
  { h with
    coe := coeFn
    coe_injective' := FunLike.coe_injective
    map_zero := map_zero
    map_one := map_one }
#align ring_equiv_class.to_ring_hom_class RingEquivClass.toRingHomClass

/- warning: ring_equiv_class.to_non_unital_ring_hom_class -> RingEquivClass.toNonUnitalRingHomClass is a dubious translation:
lean 3 declaration is
  forall (F : Type.{u1}) (R : Type.{u2}) (S : Type.{u3}) [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u3} S] [h : RingEquivClass.{u1, u2, u3} F R S (Distrib.toHasMul.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toHasAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toHasMul.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S _inst_2)) (Distrib.toHasAdd.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S _inst_2))], NonUnitalRingHomClass.{u1, u2, u3} F R S _inst_1 _inst_2
but is expected to have type
  forall {F : Type.{u1}} {R : Type.{u2}} {S : Type.{u3}} {_inst_1 : NonUnitalNonAssocSemiring.{u2} R} {_inst_2 : NonUnitalNonAssocSemiring.{u3} S} [h : RingEquivClass.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u3} S _inst_2) (Distrib.toAdd.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S _inst_2))], NonUnitalRingHomClass.{u1, u2, u3} F R S _inst_1 _inst_2
Case conversion may be inaccurate. Consider using '#align ring_equiv_class.to_non_unital_ring_hom_class RingEquivClass.toNonUnitalRingHomClassₓ'. -/
-- See note [lower instance priority]
instance (priority := 100) toNonUnitalRingHomClass (F R S : Type _) [NonUnitalNonAssocSemiring R]
    [NonUnitalNonAssocSemiring S] [h : RingEquivClass F R S] : NonUnitalRingHomClass F R S :=
  { h with
    coe := coeFn
    coe_injective' := FunLike.coe_injective
    map_zero := map_zero }
#align ring_equiv_class.to_non_unital_ring_hom_class RingEquivClass.toNonUnitalRingHomClass

end RingEquivClass

instance [Mul α] [Add α] [Mul β] [Add β] [RingEquivClass F α β] : CoeTC F (α ≃+* β) :=
  ⟨fun f =>
    { toFun := f
      invFun := EquivLike.inv f
      left_inv := EquivLike.left_inv f
      right_inv := EquivLike.right_inv f
      map_mul' := map_mul f
      map_add' := map_add f }⟩

namespace RingEquiv

section Basic

variable [Mul R] [Add R] [Mul S] [Add S] [Mul S'] [Add S']

instance : RingEquivClass (R ≃+* S) R S where
  coe := toFun
  inv := invFun
  coe_injective' e f h₁ h₂ := by
    cases e
    cases f
    congr
  map_add := map_add'
  map_mul := map_mul'
  left_inv := RingEquiv.left_inv
  right_inv := RingEquiv.right_inv

instance : CoeFun (R ≃+* S) fun _ => R → S :=
  ⟨RingEquiv.toFun⟩

/- warning: ring_equiv.to_equiv_eq_coe clashes with [anonymous] -> [anonymous]
warning: ring_equiv.to_equiv_eq_coe -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u_4}} {S : Type.{u_5}} [_inst_1 : Mul.{u_4} R] [_inst_2 : Add.{u_4} R] [_inst_3 : Mul.{u_5} S] [_inst_4 : Add.{u_5} S] (f : RingEquiv.{u_4, u_5} R S _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max 1 (max (succ u_4) (succ u_5)) (succ u_5) (succ u_4)} (Equiv.{succ u_4, succ u_5} R S) (RingEquiv.toEquiv.{u_4, u_5} R S _inst_1 _inst_2 _inst_3 _inst_4 f) ((fun (a : Sort.{max (succ u_4) (succ u_5)}) (b : Sort.{max 1 (max (succ u_4) (succ u_5)) (succ u_5) (succ u_4)}) [self : HasLiftT.{max (succ u_4) (succ u_5), max 1 (max (succ u_4) (succ u_5)) (succ u_5) (succ u_4)} a b] => self.0) (RingEquiv.{u_4, u_5} R S _inst_1 _inst_2 _inst_3 _inst_4) (Equiv.{succ u_4, succ u_5} R S) (HasLiftT.mk.{max (succ u_4) (succ u_5), max 1 (max (succ u_4) (succ u_5)) (succ u_5) (succ u_4)} (RingEquiv.{u_4, u_5} R S _inst_1 _inst_2 _inst_3 _inst_4) (Equiv.{succ u_4, succ u_5} R S) (CoeTCₓ.coe.{max (succ u_4) (succ u_5), max 1 (max (succ u_4) (succ u_5)) (succ u_5) (succ u_4)} (RingEquiv.{u_4, u_5} R S _inst_1 _inst_2 _inst_3 _inst_4) (Equiv.{succ u_4, succ u_5} R S) (Equiv.hasCoeT.{succ u_4, succ u_5, max (succ u_4) (succ u_5)} R S (RingEquiv.{u_4, u_5} R S _inst_1 _inst_2 _inst_3 _inst_4) (MulEquivClass.toEquivLike.{max u_4 u_5, u_4, u_5} (RingEquiv.{u_4, u_5} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 (RingEquivClass.toMulEquivClass.{max u_4 u_5, u_4, u_5} (RingEquiv.{u_4, u_5} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 _inst_3 _inst_4 (RingEquiv.ringEquivClass.{u_4, u_5} R S _inst_1 _inst_2 _inst_3 _inst_4)))))) f)
but is expected to have type
  forall {R : Sort.{u}} {S : Nat}, ((Eq.{1} Nat S (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) -> R) -> (forall (m : Nat), (Eq.{1} Nat S (Nat.succ m)) -> R) -> R
Case conversion may be inaccurate. Consider using '#align ring_equiv.to_equiv_eq_coe [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] (f : R ≃+* S) : f.toEquiv = f :=
  rfl
#align ring_equiv.to_equiv_eq_coe[anonymous]

/- warning: ring_equiv.to_fun_eq_coe clashes with [anonymous] -> [anonymous]
warning: ring_equiv.to_fun_eq_coe -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u_4}} {S : Type.{u_5}} [_inst_1 : Mul.{u_4} R] [_inst_2 : Add.{u_4} R] [_inst_3 : Mul.{u_5} S] [_inst_4 : Add.{u_5} S] (f : RingEquiv.{u_4, u_5} R S _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u_4) (succ u_5)} (R -> S) (RingEquiv.toFun.{u_4, u_5} R S _inst_1 _inst_2 _inst_3 _inst_4 f) (coeFn.{max (succ u_4) (succ u_5), max (succ u_4) (succ u_5)} (RingEquiv.{u_4, u_5} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u_4, u_5} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u_4, u_5} R S _inst_1 _inst_2 _inst_3 _inst_4) f)
but is expected to have type
  forall {R : Sort.{u}} {S : Nat}, ((Eq.{1} Nat S (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) -> R) -> (forall (m : Nat), (Eq.{1} Nat S (Nat.succ m)) -> R) -> R
Case conversion may be inaccurate. Consider using '#align ring_equiv.to_fun_eq_coe [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] (f : R ≃+* S) : f.toFun = f :=
  rfl
#align ring_equiv.to_fun_eq_coe[anonymous]

/- warning: ring_equiv.coe_to_equiv clashes with [anonymous] -> [anonymous]
warning: ring_equiv.coe_to_equiv -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u_4}} {S : Type.{u_5}} [_inst_1 : Mul.{u_4} R] [_inst_2 : Add.{u_4} R] [_inst_3 : Mul.{u_5} S] [_inst_4 : Add.{u_5} S] (f : RingEquiv.{u_4, u_5} R S _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u_4) (succ u_5)} (R -> S) (coeFn.{max 1 (max (succ u_4) (succ u_5)) (succ u_5) (succ u_4), max (succ u_4) (succ u_5)} (Equiv.{succ u_4, succ u_5} R S) (fun (_x : Equiv.{succ u_4, succ u_5} R S) => R -> S) (Equiv.hasCoeToFun.{succ u_4, succ u_5} R S) ((fun (a : Sort.{max (succ u_4) (succ u_5)}) (b : Sort.{max 1 (max (succ u_4) (succ u_5)) (succ u_5) (succ u_4)}) [self : HasLiftT.{max (succ u_4) (succ u_5), max 1 (max (succ u_4) (succ u_5)) (succ u_5) (succ u_4)} a b] => self.0) (RingEquiv.{u_4, u_5} R S _inst_1 _inst_2 _inst_3 _inst_4) (Equiv.{succ u_4, succ u_5} R S) (HasLiftT.mk.{max (succ u_4) (succ u_5), max 1 (max (succ u_4) (succ u_5)) (succ u_5) (succ u_4)} (RingEquiv.{u_4, u_5} R S _inst_1 _inst_2 _inst_3 _inst_4) (Equiv.{succ u_4, succ u_5} R S) (CoeTCₓ.coe.{max (succ u_4) (succ u_5), max 1 (max (succ u_4) (succ u_5)) (succ u_5) (succ u_4)} (RingEquiv.{u_4, u_5} R S _inst_1 _inst_2 _inst_3 _inst_4) (Equiv.{succ u_4, succ u_5} R S) (Equiv.hasCoeT.{succ u_4, succ u_5, max (succ u_4) (succ u_5)} R S (RingEquiv.{u_4, u_5} R S _inst_1 _inst_2 _inst_3 _inst_4) (MulEquivClass.toEquivLike.{max u_4 u_5, u_4, u_5} (RingEquiv.{u_4, u_5} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 (RingEquivClass.toMulEquivClass.{max u_4 u_5, u_4, u_5} (RingEquiv.{u_4, u_5} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 _inst_3 _inst_4 (RingEquiv.ringEquivClass.{u_4, u_5} R S _inst_1 _inst_2 _inst_3 _inst_4)))))) f)) (coeFn.{max (succ u_4) (succ u_5), max (succ u_4) (succ u_5)} (RingEquiv.{u_4, u_5} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u_4, u_5} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u_4, u_5} R S _inst_1 _inst_2 _inst_3 _inst_4) f)
but is expected to have type
  forall {R : Sort.{u}} {S : Nat}, ((Eq.{1} Nat S (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) -> R) -> (forall (m : Nat), (Eq.{1} Nat S (Nat.succ m)) -> R) -> R
Case conversion may be inaccurate. Consider using '#align ring_equiv.coe_to_equiv [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] (f : R ≃+* S) : ⇑(f : R ≃ S) = f :=
  rfl
#align ring_equiv.coe_to_equiv[anonymous]

/- warning: ring_equiv.map_mul -> RingEquiv.map_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Mul.{u2} S] [_inst_4 : Add.{u2} S] (e : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (x : R) (y : R), Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) e (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R _inst_1) x y)) (HMul.hMul.{u2, u2, u2} S S S (instHMul.{u2} S _inst_3) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) e x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) e y))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Mul.{u2} R] [_inst_2 : Mul.{u1} S] [_inst_3 : Add.{u2} R] [_inst_4 : Add.{u1} S] (e : RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) (x : R) (y : R), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) (HMul.hMul.{u2, u2, u2} R R R (instHMul.{u2} R _inst_1) x y)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e (HMul.hMul.{u2, u2, u2} R R R (instHMul.{u2} R _inst_1) x y)) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) y) ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) (instHMul.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) _inst_2) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e y))
Case conversion may be inaccurate. Consider using '#align ring_equiv.map_mul RingEquiv.map_mulₓ'. -/
/-- A ring isomorphism preserves multiplication. -/
protected theorem map_mul (e : R ≃+* S) (x y : R) : e (x * y) = e x * e y :=
  map_mul e x y
#align ring_equiv.map_mul RingEquiv.map_mul

/- warning: ring_equiv.map_add -> RingEquiv.map_add is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Mul.{u2} S] [_inst_4 : Add.{u2} S] (e : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (x : R) (y : R), Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) e (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R _inst_2) x y)) (HAdd.hAdd.{u2, u2, u2} S S S (instHAdd.{u2} S _inst_4) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) e x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) e y))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Mul.{u2} R] [_inst_2 : Mul.{u1} S] [_inst_3 : Add.{u2} R] [_inst_4 : Add.{u1} S] (e : RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) (x : R) (y : R), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) (HAdd.hAdd.{u2, u2, u2} R R R (instHAdd.{u2} R _inst_3) x y)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e (HAdd.hAdd.{u2, u2, u2} R R R (instHAdd.{u2} R _inst_3) x y)) (HAdd.hAdd.{u1, u1, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) y) ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) (instHAdd.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) _inst_4) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e y))
Case conversion may be inaccurate. Consider using '#align ring_equiv.map_add RingEquiv.map_addₓ'. -/
/-- A ring isomorphism preserves addition. -/
protected theorem map_add (e : R ≃+* S) (x y : R) : e (x + y) = e x + e y :=
  map_add e x y
#align ring_equiv.map_add RingEquiv.map_add

/- warning: ring_equiv.ext -> RingEquiv.ext is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Mul.{u2} S] [_inst_4 : Add.{u2} S] {f : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4} {g : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4}, (forall (x : R), Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) g x)) -> (Eq.{max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) f g)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Mul.{u2} R] [_inst_2 : Mul.{u1} S] [_inst_3 : Add.{u2} R] [_inst_4 : Add.{u1} S] {f : RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4} {g : RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4}, (forall (x : R), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) g x)) -> (Eq.{max (succ u2) (succ u1)} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) f g)
Case conversion may be inaccurate. Consider using '#align ring_equiv.ext RingEquiv.extₓ'. -/
/-- Two ring isomorphisms agree if they are defined by the
    same underlying function. -/
@[ext]
theorem ext {f g : R ≃+* S} (h : ∀ x, f x = g x) : f = g :=
  FunLike.ext f g h
#align ring_equiv.ext RingEquiv.ext

/- warning: ring_equiv.coe_mk clashes with [anonymous] -> [anonymous]
warning: ring_equiv.coe_mk -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u_4}} {S : Type.{u_5}} [_inst_1 : Mul.{u_4} R] [_inst_2 : Add.{u_4} R] [_inst_3 : Mul.{u_5} S] [_inst_4 : Add.{u_5} S] (e : R -> S) (e' : S -> R) (h₁ : Function.LeftInverse.{succ u_4, succ u_5} R S e' e) (h₂ : Function.RightInverse.{succ u_4, succ u_5} R S e' e) (h₃ : forall (x : R) (y : R), Eq.{succ u_5} S (e (HMul.hMul.{u_4, u_4, u_4} R R R (instHMul.{u_4} R _inst_1) x y)) (HMul.hMul.{u_5, u_5, u_5} S S S (instHMul.{u_5} S _inst_3) (e x) (e y))) (h₄ : forall (x : R) (y : R), Eq.{succ u_5} S (e (HAdd.hAdd.{u_4, u_4, u_4} R R R (instHAdd.{u_4} R _inst_2) x y)) (HAdd.hAdd.{u_5, u_5, u_5} S S S (instHAdd.{u_5} S _inst_4) (e x) (e y))), Eq.{max (succ u_4) (succ u_5)} (R -> S) (coeFn.{max (succ u_4) (succ u_5), max (succ u_4) (succ u_5)} (RingEquiv.{u_4, u_5} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u_4, u_5} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u_4, u_5} R S _inst_1 _inst_2 _inst_3 _inst_4) (RingEquiv.mk.{u_4, u_5} R S _inst_1 _inst_2 _inst_3 _inst_4 e e' h₁ h₂ h₃ h₄)) e
but is expected to have type
  forall {R : Sort.{u}} {S : Nat}, ((Eq.{1} Nat S (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) -> R) -> (forall (m : Nat), (Eq.{1} Nat S (Nat.succ m)) -> R) -> R
Case conversion may be inaccurate. Consider using '#align ring_equiv.coe_mk [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] (e e' h₁ h₂ h₃ h₄) : ⇑(⟨e, e', h₁, h₂, h₃, h₄⟩ : R ≃+* S) = e :=
  rfl
#align ring_equiv.coe_mk[anonymous]

/- warning: ring_equiv.mk_coe -> RingEquiv.mk_coe is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Mul.{u2} S] [_inst_4 : Add.{u2} S] (e : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (e' : S -> R) (h₁ : Function.LeftInverse.{succ u1, succ u2} R S e' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) e)) (h₂ : Function.RightInverse.{succ u1, succ u2} R S e' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) e)) (h₃ : forall (x : R) (y : R), Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) e (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R _inst_1) x y)) (HMul.hMul.{u2, u2, u2} S S S (instHMul.{u2} S _inst_3) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) e x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) e y))) (h₄ : forall (x : R) (y : R), Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) e (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R _inst_2) x y)) (HAdd.hAdd.{u2, u2, u2} S S S (instHAdd.{u2} S _inst_4) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) e x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) e y))), Eq.{max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (RingEquiv.mk.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) e) e' h₁ h₂ h₃ h₄) e
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Mul.{u2} R] [_inst_2 : Mul.{u1} S] [_inst_3 : Add.{u2} R] [_inst_4 : Add.{u1} S] (e : RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) (e' : S -> R) (h₁ : Function.LeftInverse.{succ u2, succ u1} R S e' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e)) (h₂ : Function.RightInverse.{succ u2, succ u1} R S e' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e)) (h₃ : forall (x : R) (y : R), Eq.{succ u1} S (Equiv.toFun.{succ u2, succ u1} R S (Equiv.mk.{succ u2, succ u1} R S (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (a : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) a) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e) e' h₁ h₂) (HMul.hMul.{u2, u2, u2} R R R (instHMul.{u2} R _inst_1) x y)) (HMul.hMul.{u1, u1, u1} S S S (instHMul.{u1} S _inst_2) (Equiv.toFun.{succ u2, succ u1} R S (Equiv.mk.{succ u2, succ u1} R S (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (a : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) a) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e) e' h₁ h₂) x) (Equiv.toFun.{succ u2, succ u1} R S (Equiv.mk.{succ u2, succ u1} R S (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (a : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) a) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e) e' h₁ h₂) y))) (h₄ : forall (x : R) (y : R), Eq.{succ u1} S (Equiv.toFun.{succ u2, succ u1} R S (Equiv.mk.{succ u2, succ u1} R S (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (a : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) a) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e) e' h₁ h₂) (HAdd.hAdd.{u2, u2, u2} R R R (instHAdd.{u2} R _inst_3) x y)) (HAdd.hAdd.{u1, u1, u1} S S S (instHAdd.{u1} S _inst_4) (Equiv.toFun.{succ u2, succ u1} R S (Equiv.mk.{succ u2, succ u1} R S (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (a : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) a) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e) e' h₁ h₂) x) (Equiv.toFun.{succ u2, succ u1} R S (Equiv.mk.{succ u2, succ u1} R S (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (a : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) a) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e) e' h₁ h₂) y))), Eq.{max (succ u2) (succ u1)} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) (RingEquiv.mk.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4 (Equiv.mk.{succ u2, succ u1} R S (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (a : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) a) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e) e' h₁ h₂) h₃ h₄) e
Case conversion may be inaccurate. Consider using '#align ring_equiv.mk_coe RingEquiv.mk_coeₓ'. -/
@[simp]
theorem mk_coe (e : R ≃+* S) (e' h₁ h₂ h₃ h₄) : (⟨e, e', h₁, h₂, h₃, h₄⟩ : R ≃+* S) = e :=
  ext fun _ => rfl
#align ring_equiv.mk_coe RingEquiv.mk_coe

/- warning: ring_equiv.congr_arg -> RingEquiv.congr_arg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Mul.{u2} S] [_inst_4 : Add.{u2} S] {f : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4} {x : R} {x' : R}, (Eq.{succ u1} R x x') -> (Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) f x'))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Mul.{u2} R] [_inst_2 : Mul.{u1} S] [_inst_3 : Add.{u2} R] [_inst_4 : Add.{u1} S] {f : RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4} {x : R} {x' : R}, (Eq.{succ u2} R x x') -> (Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) f x'))
Case conversion may be inaccurate. Consider using '#align ring_equiv.congr_arg RingEquiv.congr_argₓ'. -/
protected theorem congr_arg {f : R ≃+* S} {x x' : R} : x = x' → f x = f x' :=
  FunLike.congr_arg f
#align ring_equiv.congr_arg RingEquiv.congr_arg

/- warning: ring_equiv.congr_fun -> RingEquiv.congr_fun is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Mul.{u2} S] [_inst_4 : Add.{u2} S] {f : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4} {g : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4}, (Eq.{max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) f g) -> (forall (x : R), Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) g x))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Mul.{u2} R] [_inst_2 : Mul.{u1} S] [_inst_3 : Add.{u2} R] [_inst_4 : Add.{u1} S] {f : RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4} {g : RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4}, (Eq.{max (succ u2) (succ u1)} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) f g) -> (forall (x : R), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) g x))
Case conversion may be inaccurate. Consider using '#align ring_equiv.congr_fun RingEquiv.congr_funₓ'. -/
protected theorem congr_fun {f g : R ≃+* S} (h : f = g) (x : R) : f x = g x :=
  FunLike.congr_fun h x
#align ring_equiv.congr_fun RingEquiv.congr_fun

/- warning: ring_equiv.ext_iff -> RingEquiv.ext_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Mul.{u2} S] [_inst_4 : Add.{u2} S] {f : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4} {g : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4}, Iff (Eq.{max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) f g) (forall (x : R), Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) g x))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Mul.{u2} R] [_inst_2 : Mul.{u1} S] [_inst_3 : Add.{u2} R] [_inst_4 : Add.{u1} S] {f : RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4} {g : RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4}, Iff (Eq.{max (succ u2) (succ u1)} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) f g) (forall (x : R), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) g x))
Case conversion may be inaccurate. Consider using '#align ring_equiv.ext_iff RingEquiv.ext_iffₓ'. -/
protected theorem ext_iff {f g : R ≃+* S} : f = g ↔ ∀ x, f x = g x :=
  FunLike.ext_iff
#align ring_equiv.ext_iff RingEquiv.ext_iff

/- warning: ring_equiv.to_add_equiv_eq_coe -> RingEquiv.toAddEquiv_eq_coe is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Mul.{u2} S] [_inst_4 : Add.{u2} S] (f : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u1) (succ u2)} (AddEquiv.{u1, u2} R S _inst_2 _inst_4) (RingEquiv.toAddEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4 f) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (AddEquiv.{u1, u2} R S _inst_2 _inst_4) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (AddEquiv.{u1, u2} R S _inst_2 _inst_4) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (AddEquiv.{u1, u2} R S _inst_2 _inst_4) (AddEquiv.hasCoeT.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_2 _inst_4 (RingEquivClass.toAddEquivClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 _inst_3 _inst_4 (RingEquiv.ringEquivClass.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4))))) f)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Mul.{u2} R] [_inst_2 : Mul.{u1} S] [_inst_3 : Add.{u2} R] [_inst_4 : Add.{u1} S] (f : RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u2) (succ u1)} (AddEquiv.{u2, u1} R S _inst_3 _inst_4) (RingEquiv.toAddEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4 f) (AddEquivClass.toAddEquiv.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_3 _inst_4 (RingEquivClass.toAddEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4)) f)
Case conversion may be inaccurate. Consider using '#align ring_equiv.to_add_equiv_eq_coe RingEquiv.toAddEquiv_eq_coeₓ'. -/
@[simp]
theorem toAddEquiv_eq_coe (f : R ≃+* S) : f.toAddEquiv = ↑f :=
  rfl
#align ring_equiv.to_add_equiv_eq_coe RingEquiv.toAddEquiv_eq_coe

/- warning: ring_equiv.to_mul_equiv_eq_coe -> RingEquiv.toMulEquiv_eq_coe is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Mul.{u2} S] [_inst_4 : Add.{u2} S] (f : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u1) (succ u2)} (MulEquiv.{u1, u2} R S _inst_1 _inst_3) (RingEquiv.toMulEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4 f) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (MulEquiv.{u1, u2} R S _inst_1 _inst_3) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (MulEquiv.{u1, u2} R S _inst_1 _inst_3) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (MulEquiv.{u1, u2} R S _inst_1 _inst_3) (MulEquiv.hasCoeT.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 (RingEquivClass.toMulEquivClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 _inst_3 _inst_4 (RingEquiv.ringEquivClass.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4))))) f)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Mul.{u2} R] [_inst_2 : Mul.{u1} S] [_inst_3 : Add.{u2} R] [_inst_4 : Add.{u1} S] (f : RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u2) (succ u1)} (MulEquiv.{u2, u1} R S _inst_1 _inst_2) (RingEquiv.toMulEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4 f) (MulEquivClass.toMulEquiv.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4)) f)
Case conversion may be inaccurate. Consider using '#align ring_equiv.to_mul_equiv_eq_coe RingEquiv.toMulEquiv_eq_coeₓ'. -/
@[simp]
theorem toMulEquiv_eq_coe (f : R ≃+* S) : f.toMulEquiv = ↑f :=
  rfl
#align ring_equiv.to_mul_equiv_eq_coe RingEquiv.toMulEquiv_eq_coe

/- warning: ring_equiv.coe_to_mul_equiv -> RingEquiv.coe_toMulEquiv is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Mul.{u2} S] [_inst_4 : Add.{u2} S] (f : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u1) (succ u2)} (R -> S) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (MulEquiv.{u1, u2} R S _inst_1 _inst_3) (fun (_x : MulEquiv.{u1, u2} R S _inst_1 _inst_3) => R -> S) (MulEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_3) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (MulEquiv.{u1, u2} R S _inst_1 _inst_3) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (MulEquiv.{u1, u2} R S _inst_1 _inst_3) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (MulEquiv.{u1, u2} R S _inst_1 _inst_3) (MulEquiv.hasCoeT.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 (RingEquivClass.toMulEquivClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 _inst_3 _inst_4 (RingEquiv.ringEquivClass.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4))))) f)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) f)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Mul.{u2} R] [_inst_2 : Mul.{u1} S] [_inst_3 : Add.{u2} R] [_inst_4 : Add.{u1} S] (f : RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : R), (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulEquiv.{u2, u1} R S _inst_1 _inst_2) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (MulEquiv.{u2, u1} R S _inst_1 _inst_2) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (MulEquiv.{u2, u1} R S _inst_1 _inst_2) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} R S _inst_1 _inst_2) R S _inst_1 _inst_2 (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} R S _inst_1 _inst_2)))) (MulEquivClass.toMulEquiv.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4)) f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) f)
Case conversion may be inaccurate. Consider using '#align ring_equiv.coe_to_mul_equiv RingEquiv.coe_toMulEquivₓ'. -/
@[simp, norm_cast]
theorem coe_toMulEquiv (f : R ≃+* S) : ⇑(f : R ≃* S) = f :=
  rfl
#align ring_equiv.coe_to_mul_equiv RingEquiv.coe_toMulEquiv

/- warning: ring_equiv.coe_to_add_equiv -> RingEquiv.coe_toAddEquiv is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Mul.{u2} S] [_inst_4 : Add.{u2} S] (f : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u1) (succ u2)} (R -> S) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddEquiv.{u1, u2} R S _inst_2 _inst_4) (fun (_x : AddEquiv.{u1, u2} R S _inst_2 _inst_4) => R -> S) (AddEquiv.hasCoeToFun.{u1, u2} R S _inst_2 _inst_4) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (AddEquiv.{u1, u2} R S _inst_2 _inst_4) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (AddEquiv.{u1, u2} R S _inst_2 _inst_4) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (AddEquiv.{u1, u2} R S _inst_2 _inst_4) (AddEquiv.hasCoeT.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_2 _inst_4 (RingEquivClass.toAddEquivClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 _inst_3 _inst_4 (RingEquiv.ringEquivClass.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4))))) f)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) f)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Mul.{u2} R] [_inst_2 : Mul.{u1} S] [_inst_3 : Add.{u2} R] [_inst_4 : Add.{u1} S] (f : RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : R), (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AddEquiv.{u2, u1} R S _inst_3 _inst_4) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (AddEquiv.{u2, u1} R S _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (AddEquiv.{u2, u1} R S _inst_3 _inst_4) R S (AddEquivClass.toEquivLike.{max u2 u1, u2, u1} (AddEquiv.{u2, u1} R S _inst_3 _inst_4) R S _inst_3 _inst_4 (AddEquiv.instAddEquivClassAddEquiv.{u2, u1} R S _inst_3 _inst_4)))) (AddEquivClass.toAddEquiv.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_3 _inst_4 (RingEquivClass.toAddEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4)) f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) f)
Case conversion may be inaccurate. Consider using '#align ring_equiv.coe_to_add_equiv RingEquiv.coe_toAddEquivₓ'. -/
@[simp, norm_cast]
theorem coe_toAddEquiv (f : R ≃+* S) : ⇑(f : R ≃+ S) = f :=
  rfl
#align ring_equiv.coe_to_add_equiv RingEquiv.coe_toAddEquiv

/- warning: ring_equiv.ring_equiv_of_unique -> RingEquiv.ringEquivOfUnique is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {N : Type.{u2}} [_inst_7 : Unique.{succ u1} M] [_inst_8 : Unique.{succ u2} N] [_inst_9 : Add.{u1} M] [_inst_10 : Mul.{u1} M] [_inst_11 : Add.{u2} N] [_inst_12 : Mul.{u2} N], RingEquiv.{u1, u2} M N _inst_10 _inst_9 _inst_12 _inst_11
but is expected to have type
  forall {M : Type.{u1}} {N : Type.{u2}} [_inst_7 : Unique.{succ u1} M] [_inst_8 : Unique.{succ u2} N] [_inst_9 : Add.{u1} M] [_inst_10 : Mul.{u1} M] [_inst_11 : Add.{u2} N] [_inst_12 : Mul.{u2} N], RingEquiv.{u1, u2} M N _inst_10 _inst_12 _inst_9 _inst_11
Case conversion may be inaccurate. Consider using '#align ring_equiv.ring_equiv_of_unique RingEquiv.ringEquivOfUniqueₓ'. -/
/-- The `ring_equiv` between two semirings with a unique element. -/
def ringEquivOfUnique {M N} [Unique M] [Unique N] [Add M] [Mul M] [Add N] [Mul N] : M ≃+* N :=
  { AddEquiv.addEquivOfUnique, MulEquiv.mulEquivOfUnique with }
#align ring_equiv.ring_equiv_of_unique RingEquiv.ringEquivOfUnique

instance {M N} [Unique M] [Unique N] [Add M] [Mul M] [Add N] [Mul N] : Unique (M ≃+* N)
    where
  default := ringEquivOfUnique
  uniq _ := ext fun x => Subsingleton.elim _ _

variable (R)

/- warning: ring_equiv.refl -> RingEquiv.refl is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R], RingEquiv.{u1, u1} R R _inst_1 _inst_2 _inst_1 _inst_2
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R], RingEquiv.{u1, u1} R R _inst_1 _inst_1 _inst_2 _inst_2
Case conversion may be inaccurate. Consider using '#align ring_equiv.refl RingEquiv.reflₓ'. -/
/-- The identity map is a ring isomorphism. -/
@[refl]
protected def refl : R ≃+* R :=
  { MulEquiv.refl R, AddEquiv.refl R with }
#align ring_equiv.refl RingEquiv.refl

#print RingEquiv.refl_apply /-
@[simp]
theorem refl_apply (x : R) : RingEquiv.refl R x = x :=
  rfl
#align ring_equiv.refl_apply RingEquiv.refl_apply
-/

/- warning: ring_equiv.coe_add_equiv_refl -> RingEquiv.coe_addEquiv_refl is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R], Eq.{succ u1} (AddEquiv.{u1, u1} R R _inst_2 _inst_2) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (RingEquiv.{u1, u1} R R _inst_1 _inst_2 _inst_1 _inst_2) (AddEquiv.{u1, u1} R R _inst_2 _inst_2) (HasLiftT.mk.{succ u1, succ u1} (RingEquiv.{u1, u1} R R _inst_1 _inst_2 _inst_1 _inst_2) (AddEquiv.{u1, u1} R R _inst_2 _inst_2) (CoeTCₓ.coe.{succ u1, succ u1} (RingEquiv.{u1, u1} R R _inst_1 _inst_2 _inst_1 _inst_2) (AddEquiv.{u1, u1} R R _inst_2 _inst_2) (AddEquiv.hasCoeT.{u1, u1, u1} (RingEquiv.{u1, u1} R R _inst_1 _inst_2 _inst_1 _inst_2) R R _inst_2 _inst_2 (RingEquivClass.toAddEquivClass.{u1, u1, u1} (RingEquiv.{u1, u1} R R _inst_1 _inst_2 _inst_1 _inst_2) R R _inst_1 _inst_2 _inst_1 _inst_2 (RingEquiv.ringEquivClass.{u1, u1} R R _inst_1 _inst_2 _inst_1 _inst_2))))) (RingEquiv.refl.{u1} R _inst_1 _inst_2)) (AddEquiv.refl.{u1} R _inst_2)
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R], Eq.{succ u1} (AddEquiv.{u1, u1} R R _inst_2 _inst_2) (AddEquivClass.toAddEquiv.{u1, u1, u1} (RingEquiv.{u1, u1} R R _inst_1 _inst_1 _inst_2 _inst_2) R R _inst_2 _inst_2 (RingEquivClass.toAddEquivClass.{u1, u1, u1} (RingEquiv.{u1, u1} R R _inst_1 _inst_1 _inst_2 _inst_2) R R _inst_1 _inst_2 _inst_1 _inst_2 (RingEquiv.instRingEquivClassRingEquiv.{u1, u1} R R _inst_1 _inst_1 _inst_2 _inst_2)) (RingEquiv.refl.{u1} R _inst_1 _inst_2)) (AddEquiv.refl.{u1} R _inst_2)
Case conversion may be inaccurate. Consider using '#align ring_equiv.coe_add_equiv_refl RingEquiv.coe_addEquiv_reflₓ'. -/
@[simp]
theorem coe_addEquiv_refl : (RingEquiv.refl R : R ≃+ R) = AddEquiv.refl R :=
  rfl
#align ring_equiv.coe_add_equiv_refl RingEquiv.coe_addEquiv_refl

/- warning: ring_equiv.coe_mul_equiv_refl -> RingEquiv.coe_mulEquiv_refl is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R], Eq.{succ u1} (MulEquiv.{u1, u1} R R _inst_1 _inst_1) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (RingEquiv.{u1, u1} R R _inst_1 _inst_2 _inst_1 _inst_2) (MulEquiv.{u1, u1} R R _inst_1 _inst_1) (HasLiftT.mk.{succ u1, succ u1} (RingEquiv.{u1, u1} R R _inst_1 _inst_2 _inst_1 _inst_2) (MulEquiv.{u1, u1} R R _inst_1 _inst_1) (CoeTCₓ.coe.{succ u1, succ u1} (RingEquiv.{u1, u1} R R _inst_1 _inst_2 _inst_1 _inst_2) (MulEquiv.{u1, u1} R R _inst_1 _inst_1) (MulEquiv.hasCoeT.{u1, u1, u1} (RingEquiv.{u1, u1} R R _inst_1 _inst_2 _inst_1 _inst_2) R R _inst_1 _inst_1 (RingEquivClass.toMulEquivClass.{u1, u1, u1} (RingEquiv.{u1, u1} R R _inst_1 _inst_2 _inst_1 _inst_2) R R _inst_1 _inst_2 _inst_1 _inst_2 (RingEquiv.ringEquivClass.{u1, u1} R R _inst_1 _inst_2 _inst_1 _inst_2))))) (RingEquiv.refl.{u1} R _inst_1 _inst_2)) (MulEquiv.refl.{u1} R _inst_1)
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R], Eq.{succ u1} (MulEquiv.{u1, u1} R R _inst_1 _inst_1) (MulEquivClass.toMulEquiv.{u1, u1, u1} (RingEquiv.{u1, u1} R R _inst_1 _inst_1 _inst_2 _inst_2) R R _inst_1 _inst_1 (RingEquivClass.toMulEquivClass.{u1, u1, u1} (RingEquiv.{u1, u1} R R _inst_1 _inst_1 _inst_2 _inst_2) R R _inst_1 _inst_2 _inst_1 _inst_2 (RingEquiv.instRingEquivClassRingEquiv.{u1, u1} R R _inst_1 _inst_1 _inst_2 _inst_2)) (RingEquiv.refl.{u1} R _inst_1 _inst_2)) (MulEquiv.refl.{u1} R _inst_1)
Case conversion may be inaccurate. Consider using '#align ring_equiv.coe_mul_equiv_refl RingEquiv.coe_mulEquiv_reflₓ'. -/
@[simp]
theorem coe_mulEquiv_refl : (RingEquiv.refl R : R ≃* R) = MulEquiv.refl R :=
  rfl
#align ring_equiv.coe_mul_equiv_refl RingEquiv.coe_mulEquiv_refl

instance : Inhabited (R ≃+* R) :=
  ⟨RingEquiv.refl R⟩

variable {R}

/- warning: ring_equiv.symm -> RingEquiv.symm is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Mul.{u2} S] [_inst_4 : Add.{u2} S], (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) -> (RingEquiv.{u2, u1} S R _inst_3 _inst_4 _inst_1 _inst_2)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Mul.{u1} R] [_inst_2 : Mul.{u2} S] [_inst_3 : Add.{u1} R] [_inst_4 : Add.{u2} S], (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) -> (RingEquiv.{u2, u1} S R _inst_2 _inst_1 _inst_4 _inst_3)
Case conversion may be inaccurate. Consider using '#align ring_equiv.symm RingEquiv.symmₓ'. -/
/-- The inverse of a ring isomorphism is a ring isomorphism. -/
@[symm]
protected def symm (e : R ≃+* S) : S ≃+* R :=
  { e.toMulEquiv.symm, e.toAddEquiv.symm with }
#align ring_equiv.symm RingEquiv.symm

/- warning: ring_equiv.simps.symm_apply -> RingEquiv.Simps.symmApply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Mul.{u2} S] [_inst_4 : Add.{u2} S], (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) -> S -> R
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Mul.{u1} R] [_inst_2 : Mul.{u2} S] [_inst_3 : Add.{u1} R] [_inst_4 : Add.{u2} S], (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) -> S -> R
Case conversion may be inaccurate. Consider using '#align ring_equiv.simps.symm_apply RingEquiv.Simps.symmApplyₓ'. -/
/-- See Note [custom simps projection] -/
def Simps.symmApply (e : R ≃+* S) : S → R :=
  e.symm
#align ring_equiv.simps.symm_apply RingEquiv.Simps.symmApply

initialize_simps_projections RingEquiv (toFun → apply, invFun → symmApply)

/- warning: ring_equiv.inv_fun_eq_symm -> RingEquiv.invFun_eq_symm is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Mul.{u2} S] [_inst_4 : Add.{u2} S] (f : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u2) (succ u1)} (S -> R) (RingEquiv.invFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4 f) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingEquiv.{u2, u1} S R _inst_3 _inst_4 _inst_1 _inst_2) (fun (_x : RingEquiv.{u2, u1} S R _inst_3 _inst_4 _inst_1 _inst_2) => S -> R) (RingEquiv.hasCoeToFun.{u2, u1} S R _inst_3 _inst_4 _inst_1 _inst_2) (RingEquiv.symm.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4 f))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Mul.{u2} R] [_inst_2 : Mul.{u1} S] [_inst_3 : Add.{u2} R] [_inst_4 : Add.{u1} S] (f : RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u2) (succ u1)} (S -> R) (EquivLike.inv.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))) f) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (RingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3) S (fun (_x : S) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : S) => R) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u1, succ u2} (RingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3) S R (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u1, succ u2} (RingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3) S R (MulEquivClass.toEquivLike.{max u2 u1, u1, u2} (RingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3) S R _inst_2 _inst_1 (RingEquivClass.toMulEquivClass.{max u2 u1, u1, u2} (RingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3) S R _inst_2 _inst_4 _inst_1 _inst_3 (RingEquiv.instRingEquivClassRingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3))))) (RingEquiv.symm.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4 f))
Case conversion may be inaccurate. Consider using '#align ring_equiv.inv_fun_eq_symm RingEquiv.invFun_eq_symmₓ'. -/
@[simp]
theorem invFun_eq_symm (f : R ≃+* S) : f.invFun = f.symm :=
  rfl
#align ring_equiv.inv_fun_eq_symm RingEquiv.invFun_eq_symm

/- warning: ring_equiv.symm_symm -> RingEquiv.symm_symm is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Mul.{u2} S] [_inst_4 : Add.{u2} S] (e : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (RingEquiv.symm.{u2, u1} S R _inst_3 _inst_4 _inst_1 _inst_2 (RingEquiv.symm.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4 e)) e
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Mul.{u2} R] [_inst_2 : Mul.{u1} S] [_inst_3 : Add.{u2} R] [_inst_4 : Add.{u1} S] (e : RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u2) (succ u1)} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) (RingEquiv.symm.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3 (RingEquiv.symm.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4 e)) e
Case conversion may be inaccurate. Consider using '#align ring_equiv.symm_symm RingEquiv.symm_symmₓ'. -/
@[simp]
theorem symm_symm (e : R ≃+* S) : e.symm.symm = e :=
  ext fun x => rfl
#align ring_equiv.symm_symm RingEquiv.symm_symm

/- warning: ring_equiv.coe_to_equiv_symm -> RingEquiv.coe_toEquiv_symm is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Mul.{u2} S] [_inst_4 : Add.{u2} S] (e : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max 1 (max (succ u2) (succ u1)) (succ u1) (succ u2)} (Equiv.{succ u2, succ u1} S R) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Sort.{max 1 (max (succ u2) (succ u1)) (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u2) (succ u1), max 1 (max (succ u2) (succ u1)) (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u2, u1} S R _inst_3 _inst_4 _inst_1 _inst_2) (Equiv.{succ u2, succ u1} S R) (HasLiftT.mk.{max (succ u2) (succ u1), max 1 (max (succ u2) (succ u1)) (succ u1) (succ u2)} (RingEquiv.{u2, u1} S R _inst_3 _inst_4 _inst_1 _inst_2) (Equiv.{succ u2, succ u1} S R) (CoeTCₓ.coe.{max (succ u2) (succ u1), max 1 (max (succ u2) (succ u1)) (succ u1) (succ u2)} (RingEquiv.{u2, u1} S R _inst_3 _inst_4 _inst_1 _inst_2) (Equiv.{succ u2, succ u1} S R) (Equiv.hasCoeT.{succ u2, succ u1, max (succ u2) (succ u1)} S R (RingEquiv.{u2, u1} S R _inst_3 _inst_4 _inst_1 _inst_2) (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} S R _inst_3 _inst_4 _inst_1 _inst_2) S R _inst_3 _inst_1 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} S R _inst_3 _inst_4 _inst_1 _inst_2) S R _inst_3 _inst_4 _inst_1 _inst_2 (RingEquiv.ringEquivClass.{u2, u1} S R _inst_3 _inst_4 _inst_1 _inst_2)))))) (RingEquiv.symm.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4 e)) (Equiv.symm.{succ u1, succ u2} R S ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max 1 (max (succ u1) (succ u2)) (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max 1 (max (succ u1) (succ u2)) (succ u2) (succ u1)} a b] => self.0) (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (Equiv.{succ u1, succ u2} R S) (HasLiftT.mk.{max (succ u1) (succ u2), max 1 (max (succ u1) (succ u2)) (succ u2) (succ u1)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (Equiv.{succ u1, succ u2} R S) (CoeTCₓ.coe.{max (succ u1) (succ u2), max 1 (max (succ u1) (succ u2)) (succ u2) (succ u1)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (Equiv.{succ u1, succ u2} R S) (Equiv.hasCoeT.{succ u1, succ u2, max (succ u1) (succ u2)} R S (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (MulEquivClass.toEquivLike.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 (RingEquivClass.toMulEquivClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 _inst_3 _inst_4 (RingEquiv.ringEquivClass.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4)))))) e))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Mul.{u2} R] [_inst_2 : Mul.{u1} S] [_inst_3 : Add.{u2} R] [_inst_4 : Add.{u1} S] (e : RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u2) (succ u1)} (Equiv.{succ u1, succ u2} S R) (EquivLike.toEquiv.{succ u1, succ u2, max (succ u2) (succ u1)} S R (RingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3) (MulEquivClass.toEquivLike.{max u2 u1, u1, u2} (RingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3) S R _inst_2 _inst_1 (RingEquivClass.toMulEquivClass.{max u2 u1, u1, u2} (RingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3) S R _inst_2 _inst_4 _inst_1 _inst_3 (RingEquiv.instRingEquivClassRingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3))) (RingEquiv.symm.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4 e)) (Equiv.symm.{succ u2, succ u1} R S (EquivLike.toEquiv.{succ u2, succ u1, max (succ u2) (succ u1)} R S (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))) e))
Case conversion may be inaccurate. Consider using '#align ring_equiv.coe_to_equiv_symm RingEquiv.coe_toEquiv_symmₓ'. -/
@[simp]
theorem coe_toEquiv_symm (e : R ≃+* S) : (e.symm : S ≃ R) = (e : R ≃ S).symm :=
  rfl
#align ring_equiv.coe_to_equiv_symm RingEquiv.coe_toEquiv_symm

/- warning: ring_equiv.symm_bijective -> RingEquiv.symm_bijective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Mul.{u2} S] [_inst_4 : Add.{u2} S], Function.Bijective.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (RingEquiv.{u2, u1} S R _inst_3 _inst_4 _inst_1 _inst_2) (RingEquiv.symm.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Mul.{u2} R] [_inst_2 : Mul.{u1} S] [_inst_3 : Add.{u2} R] [_inst_4 : Add.{u1} S], Function.Bijective.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) (RingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3) (RingEquiv.symm.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4)
Case conversion may be inaccurate. Consider using '#align ring_equiv.symm_bijective RingEquiv.symm_bijectiveₓ'. -/
theorem symm_bijective : Function.Bijective (RingEquiv.symm : R ≃+* S → S ≃+* R) :=
  Equiv.bijective ⟨RingEquiv.symm, RingEquiv.symm, symm_symm, symm_symm⟩
#align ring_equiv.symm_bijective RingEquiv.symm_bijective

/- warning: ring_equiv.mk_coe' -> RingEquiv.mk_coe' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Mul.{u2} S] [_inst_4 : Add.{u2} S] (e : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (f : S -> R) (h₁ : Function.LeftInverse.{succ u2, succ u1} S R (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (e : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) e) f) (h₂ : Function.RightInverse.{succ u2, succ u1} S R (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (e : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) e) f) (h₃ : forall (x : S) (y : S), Eq.{succ u1} R (f (HMul.hMul.{u2, u2, u2} S S S (instHMul.{u2} S _inst_3) x y)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R _inst_1) (f x) (f y))) (h₄ : forall (x : S) (y : S), Eq.{succ u1} R (f (HAdd.hAdd.{u2, u2, u2} S S S (instHAdd.{u2} S _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R _inst_2) (f x) (f y))), Eq.{max (succ u2) (succ u1)} (RingEquiv.{u2, u1} S R _inst_3 _inst_4 _inst_1 _inst_2) (RingEquiv.mk.{u2, u1} S R _inst_3 _inst_4 _inst_1 _inst_2 f (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (e : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) e) h₁ h₂ h₃ h₄) (RingEquiv.symm.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4 e)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Mul.{u2} R] [_inst_2 : Mul.{u1} S] [_inst_3 : Add.{u2} R] [_inst_4 : Add.{u1} S] (e : RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) (f : S -> R) (h₁ : Function.LeftInverse.{succ u1, succ u2} S R (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (e : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) e) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e) f) (h₂ : Function.RightInverse.{succ u1, succ u2} S R (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (e : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) e) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e) f) (h₃ : forall (x : S) (y : S), Eq.{succ u2} R (Equiv.toFun.{succ u1, succ u2} S R (Equiv.mk.{succ u1, succ u2} S R f (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (a : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) a) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e) h₁ h₂) (HMul.hMul.{u1, u1, u1} S S S (instHMul.{u1} S _inst_2) x y)) (HMul.hMul.{u2, u2, u2} R R R (instHMul.{u2} R _inst_1) (Equiv.toFun.{succ u1, succ u2} S R (Equiv.mk.{succ u1, succ u2} S R f (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (a : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) a) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e) h₁ h₂) x) (Equiv.toFun.{succ u1, succ u2} S R (Equiv.mk.{succ u1, succ u2} S R f (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (a : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) a) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e) h₁ h₂) y))) (h₄ : forall (x : S) (y : S), Eq.{succ u2} R (Equiv.toFun.{succ u1, succ u2} S R (Equiv.mk.{succ u1, succ u2} S R f (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (a : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) a) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e) h₁ h₂) (HAdd.hAdd.{u1, u1, u1} S S S (instHAdd.{u1} S _inst_4) x y)) (HAdd.hAdd.{u2, u2, u2} R R R (instHAdd.{u2} R _inst_3) (Equiv.toFun.{succ u1, succ u2} S R (Equiv.mk.{succ u1, succ u2} S R f (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (a : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) a) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e) h₁ h₂) x) (Equiv.toFun.{succ u1, succ u2} S R (Equiv.mk.{succ u1, succ u2} S R f (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (a : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) a) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e) h₁ h₂) y))), Eq.{max (succ u2) (succ u1)} (RingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3) (RingEquiv.mk.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3 (Equiv.mk.{succ u1, succ u2} S R f (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (a : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) a) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e) h₁ h₂) h₃ h₄) (RingEquiv.symm.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4 e)
Case conversion may be inaccurate. Consider using '#align ring_equiv.mk_coe' RingEquiv.mk_coe'ₓ'. -/
@[simp]
theorem mk_coe' (e : R ≃+* S) (f h₁ h₂ h₃ h₄) :
    (RingEquiv.mk f (⇑e) h₁ h₂ h₃ h₄ : S ≃+* R) = e.symm :=
  symm_bijective.Injective <| ext fun x => rfl
#align ring_equiv.mk_coe' RingEquiv.mk_coe'

/- warning: ring_equiv.symm_mk -> RingEquiv.symm_mk is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Mul.{u2} S] [_inst_4 : Add.{u2} S] (f : R -> S) (g : S -> R) (h₁ : Function.LeftInverse.{succ u1, succ u2} R S g f) (h₂ : Function.RightInverse.{succ u1, succ u2} R S g f) (h₃ : forall (x : R) (y : R), Eq.{succ u2} S (f (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R _inst_1) x y)) (HMul.hMul.{u2, u2, u2} S S S (instHMul.{u2} S _inst_3) (f x) (f y))) (h₄ : forall (x : R) (y : R), Eq.{succ u2} S (f (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R _inst_2) x y)) (HAdd.hAdd.{u2, u2, u2} S S S (instHAdd.{u2} S _inst_4) (f x) (f y))), Eq.{max (succ u2) (succ u1)} (RingEquiv.{u2, u1} S R _inst_3 _inst_4 _inst_1 _inst_2) (RingEquiv.symm.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4 (RingEquiv.mk.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4 f g h₁ h₂ h₃ h₄)) (RingEquiv.mk.{u2, u1} S R _inst_3 _inst_4 _inst_1 _inst_2 g f (RingEquiv.left_inv.{u2, u1} S R _inst_3 _inst_4 _inst_1 _inst_2 (RingEquiv.symm.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4 (RingEquiv.mk.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4 f g h₁ h₂ h₃ h₄))) (RingEquiv.right_inv.{u2, u1} S R _inst_3 _inst_4 _inst_1 _inst_2 (RingEquiv.symm.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4 (RingEquiv.mk.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4 f g h₁ h₂ h₃ h₄))) (RingEquiv.map_mul'.{u2, u1} S R _inst_3 _inst_4 _inst_1 _inst_2 (RingEquiv.symm.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4 (RingEquiv.mk.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4 f g h₁ h₂ h₃ h₄))) (RingEquiv.map_add'.{u2, u1} S R _inst_3 _inst_4 _inst_1 _inst_2 (RingEquiv.symm.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4 (RingEquiv.mk.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4 f g h₁ h₂ h₃ h₄))))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Mul.{u2} R] [_inst_2 : Mul.{u1} S] [_inst_3 : Add.{u2} R] [_inst_4 : Add.{u1} S] (f : R -> S) (g : S -> R) (h₁ : Function.LeftInverse.{succ u2, succ u1} R S g f) (h₂ : Function.RightInverse.{succ u2, succ u1} R S g f) (h₃ : forall (x : R) (y : R), Eq.{succ u1} S (Equiv.toFun.{succ u2, succ u1} R S (Equiv.mk.{succ u2, succ u1} R S f g h₁ h₂) (HMul.hMul.{u2, u2, u2} R R R (instHMul.{u2} R _inst_1) x y)) (HMul.hMul.{u1, u1, u1} S S S (instHMul.{u1} S _inst_2) (Equiv.toFun.{succ u2, succ u1} R S (Equiv.mk.{succ u2, succ u1} R S f g h₁ h₂) x) (Equiv.toFun.{succ u2, succ u1} R S (Equiv.mk.{succ u2, succ u1} R S f g h₁ h₂) y))) (h₄ : forall (x : R) (y : R), Eq.{succ u1} S (Equiv.toFun.{succ u2, succ u1} R S (Equiv.mk.{succ u2, succ u1} R S f g h₁ h₂) (HAdd.hAdd.{u2, u2, u2} R R R (instHAdd.{u2} R _inst_3) x y)) (HAdd.hAdd.{u1, u1, u1} S S S (instHAdd.{u1} S _inst_4) (Equiv.toFun.{succ u2, succ u1} R S (Equiv.mk.{succ u2, succ u1} R S f g h₁ h₂) x) (Equiv.toFun.{succ u2, succ u1} R S (Equiv.mk.{succ u2, succ u1} R S f g h₁ h₂) y))), Eq.{max (succ u2) (succ u1)} (RingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3) (RingEquiv.symm.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4 (RingEquiv.mk.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4 (Equiv.mk.{succ u2, succ u1} R S f g h₁ h₂) h₃ h₄)) (let src._@.Mathlib.Algebra.Ring.Equiv._hyg.2533 : RingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3 := RingEquiv.symm.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4 (RingEquiv.mk.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4 (Equiv.mk.{succ u2, succ u1} R S f g h₁ h₂) h₃ h₄); RingEquiv.mk.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3 (Equiv.mk.{succ u1, succ u2} S R g f (Equiv.left_inv.{succ u1, succ u2} S R (RingEquiv.toEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3 src._@.Mathlib.Algebra.Ring.Equiv._hyg.2533)) (Equiv.right_inv.{succ u1, succ u2} S R (RingEquiv.toEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3 src._@.Mathlib.Algebra.Ring.Equiv._hyg.2533))) (RingEquiv.map_mul'.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3 src._@.Mathlib.Algebra.Ring.Equiv._hyg.2533) (RingEquiv.map_add'.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3 src._@.Mathlib.Algebra.Ring.Equiv._hyg.2533))
Case conversion may be inaccurate. Consider using '#align ring_equiv.symm_mk RingEquiv.symm_mkₓ'. -/
@[simp]
theorem symm_mk (f : R → S) (g h₁ h₂ h₃ h₄) :
    (mk f g h₁ h₂ h₃ h₄).symm =
      { (mk f g h₁ h₂ h₃ h₄).symm with
        toFun := g
        invFun := f } :=
  rfl
#align ring_equiv.symm_mk RingEquiv.symm_mk

/- warning: ring_equiv.trans -> RingEquiv.trans is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {S' : Type.{u3}} [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Mul.{u2} S] [_inst_4 : Add.{u2} S] [_inst_5 : Mul.{u3} S'] [_inst_6 : Add.{u3} S'], (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) -> (RingEquiv.{u2, u3} S S' _inst_3 _inst_4 _inst_5 _inst_6) -> (RingEquiv.{u1, u3} R S' _inst_1 _inst_2 _inst_5 _inst_6)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} {S' : Type.{u3}} [_inst_1 : Mul.{u1} R] [_inst_2 : Mul.{u2} S] [_inst_3 : Add.{u1} R] [_inst_4 : Add.{u2} S] [_inst_5 : Mul.{u3} S'] [_inst_6 : Add.{u3} S'], (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) -> (RingEquiv.{u2, u3} S S' _inst_2 _inst_5 _inst_4 _inst_6) -> (RingEquiv.{u1, u3} R S' _inst_1 _inst_5 _inst_3 _inst_6)
Case conversion may be inaccurate. Consider using '#align ring_equiv.trans RingEquiv.transₓ'. -/
/-- Transitivity of `ring_equiv`. -/
@[trans]
protected def trans (e₁ : R ≃+* S) (e₂ : S ≃+* S') : R ≃+* S' :=
  { e₁.toMulEquiv.trans e₂.toMulEquiv, e₁.toAddEquiv.trans e₂.toAddEquiv with }
#align ring_equiv.trans RingEquiv.trans

/- warning: ring_equiv.trans_apply -> RingEquiv.trans_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {S' : Type.{u3}} [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Mul.{u2} S] [_inst_4 : Add.{u2} S] [_inst_5 : Mul.{u3} S'] [_inst_6 : Add.{u3} S'] (e₁ : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (e₂ : RingEquiv.{u2, u3} S S' _inst_3 _inst_4 _inst_5 _inst_6) (a : R), Eq.{succ u3} S' (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (RingEquiv.{u1, u3} R S' _inst_1 _inst_2 _inst_5 _inst_6) (fun (_x : RingEquiv.{u1, u3} R S' _inst_1 _inst_2 _inst_5 _inst_6) => R -> S') (RingEquiv.hasCoeToFun.{u1, u3} R S' _inst_1 _inst_2 _inst_5 _inst_6) (RingEquiv.trans.{u1, u2, u3} R S S' _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 e₁ e₂) a) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (RingEquiv.{u2, u3} S S' _inst_3 _inst_4 _inst_5 _inst_6) (fun (_x : RingEquiv.{u2, u3} S S' _inst_3 _inst_4 _inst_5 _inst_6) => S -> S') (RingEquiv.hasCoeToFun.{u2, u3} S S' _inst_3 _inst_4 _inst_5 _inst_6) e₂ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) e₁ a))
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u2}} {S' : Type.{u1}} [_inst_1 : Mul.{u3} R] [_inst_2 : Mul.{u2} S] [_inst_3 : Add.{u3} R] [_inst_4 : Add.{u2} S] [_inst_5 : Mul.{u1} S'] [_inst_6 : Add.{u1} S'] (e₁ : RingEquiv.{u3, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (e₂ : RingEquiv.{u2, u1} S S' _inst_2 _inst_5 _inst_4 _inst_6) (a : R), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S') a) (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (RingEquiv.{u3, u1} R S' _inst_1 _inst_5 _inst_3 _inst_6) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S') _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u1), succ u3, succ u1} (RingEquiv.{u3, u1} R S' _inst_1 _inst_5 _inst_3 _inst_6) R S' (EquivLike.toEmbeddingLike.{max (succ u3) (succ u1), succ u3, succ u1} (RingEquiv.{u3, u1} R S' _inst_1 _inst_5 _inst_3 _inst_6) R S' (MulEquivClass.toEquivLike.{max u3 u1, u3, u1} (RingEquiv.{u3, u1} R S' _inst_1 _inst_5 _inst_3 _inst_6) R S' _inst_1 _inst_5 (RingEquivClass.toMulEquivClass.{max u3 u1, u3, u1} (RingEquiv.{u3, u1} R S' _inst_1 _inst_5 _inst_3 _inst_6) R S' _inst_1 _inst_3 _inst_5 _inst_6 (RingEquiv.instRingEquivClassRingEquiv.{u3, u1} R S' _inst_1 _inst_5 _inst_3 _inst_6))))) (RingEquiv.trans.{u3, u2, u1} R S S' _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 e₁ e₂) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} S S' _inst_2 _inst_5 _inst_4 _inst_6) S (fun (_x : S) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : S) => S') _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} S S' _inst_2 _inst_5 _inst_4 _inst_6) S S' (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} S S' _inst_2 _inst_5 _inst_4 _inst_6) S S' (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} S S' _inst_2 _inst_5 _inst_4 _inst_6) S S' _inst_2 _inst_5 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} S S' _inst_2 _inst_5 _inst_4 _inst_6) S S' _inst_2 _inst_4 _inst_5 _inst_6 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} S S' _inst_2 _inst_5 _inst_4 _inst_6))))) e₂ (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (RingEquiv.{u3, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u2), succ u3, succ u2} (RingEquiv.{u3, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u3) (succ u2), succ u3, succ u2} (RingEquiv.{u3, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u3 u2, u3, u2} (RingEquiv.{u3, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u3 u2, u3, u2} (RingEquiv.{u3, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u3, u2} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e₁ a))
Case conversion may be inaccurate. Consider using '#align ring_equiv.trans_apply RingEquiv.trans_applyₓ'. -/
theorem trans_apply (e₁ : R ≃+* S) (e₂ : S ≃+* S') (a : R) : e₁.trans e₂ a = e₂ (e₁ a) :=
  rfl
#align ring_equiv.trans_apply RingEquiv.trans_apply

/- warning: ring_equiv.coe_trans -> RingEquiv.coe_trans is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {S' : Type.{u3}} [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Mul.{u2} S] [_inst_4 : Add.{u2} S] [_inst_5 : Mul.{u3} S'] [_inst_6 : Add.{u3} S'] (e₁ : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (e₂ : RingEquiv.{u2, u3} S S' _inst_3 _inst_4 _inst_5 _inst_6), Eq.{max (succ u1) (succ u3)} ((fun (_x : RingEquiv.{u1, u3} R S' _inst_1 _inst_2 _inst_5 _inst_6) => R -> S') (RingEquiv.trans.{u1, u2, u3} R S S' _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 e₁ e₂)) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (RingEquiv.{u1, u3} R S' _inst_1 _inst_2 _inst_5 _inst_6) (fun (_x : RingEquiv.{u1, u3} R S' _inst_1 _inst_2 _inst_5 _inst_6) => R -> S') (RingEquiv.hasCoeToFun.{u1, u3} R S' _inst_1 _inst_2 _inst_5 _inst_6) (RingEquiv.trans.{u1, u2, u3} R S S' _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 e₁ e₂)) (Function.comp.{succ u1, succ u2, succ u3} R S S' (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (RingEquiv.{u2, u3} S S' _inst_3 _inst_4 _inst_5 _inst_6) (fun (_x : RingEquiv.{u2, u3} S S' _inst_3 _inst_4 _inst_5 _inst_6) => S -> S') (RingEquiv.hasCoeToFun.{u2, u3} S S' _inst_3 _inst_4 _inst_5 _inst_6) e₂) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) e₁))
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u2}} {S' : Type.{u1}} [_inst_1 : Mul.{u3} R] [_inst_2 : Mul.{u2} S] [_inst_3 : Add.{u3} R] [_inst_4 : Add.{u2} S] [_inst_5 : Mul.{u1} S'] [_inst_6 : Add.{u1} S'] (e₁ : RingEquiv.{u3, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (e₂ : RingEquiv.{u2, u1} S S' _inst_2 _inst_5 _inst_4 _inst_6), Eq.{max (succ u3) (succ u1)} (forall (a : R), (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S') a) (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (RingEquiv.{u3, u1} R S' _inst_1 _inst_5 _inst_3 _inst_6) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S') _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u1), succ u3, succ u1} (RingEquiv.{u3, u1} R S' _inst_1 _inst_5 _inst_3 _inst_6) R S' (EquivLike.toEmbeddingLike.{max (succ u3) (succ u1), succ u3, succ u1} (RingEquiv.{u3, u1} R S' _inst_1 _inst_5 _inst_3 _inst_6) R S' (MulEquivClass.toEquivLike.{max u3 u1, u3, u1} (RingEquiv.{u3, u1} R S' _inst_1 _inst_5 _inst_3 _inst_6) R S' _inst_1 _inst_5 (RingEquivClass.toMulEquivClass.{max u3 u1, u3, u1} (RingEquiv.{u3, u1} R S' _inst_1 _inst_5 _inst_3 _inst_6) R S' _inst_1 _inst_3 _inst_5 _inst_6 (RingEquiv.instRingEquivClassRingEquiv.{u3, u1} R S' _inst_1 _inst_5 _inst_3 _inst_6))))) (RingEquiv.trans.{u3, u2, u1} R S S' _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 e₁ e₂)) (Function.comp.{succ u3, succ u2, succ u1} R S S' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} S S' _inst_2 _inst_5 _inst_4 _inst_6) S (fun (_x : S) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : S) => S') _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} S S' _inst_2 _inst_5 _inst_4 _inst_6) S S' (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} S S' _inst_2 _inst_5 _inst_4 _inst_6) S S' (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} S S' _inst_2 _inst_5 _inst_4 _inst_6) S S' _inst_2 _inst_5 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} S S' _inst_2 _inst_5 _inst_4 _inst_6) S S' _inst_2 _inst_4 _inst_5 _inst_6 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} S S' _inst_2 _inst_5 _inst_4 _inst_6))))) e₂) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (RingEquiv.{u3, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u2), succ u3, succ u2} (RingEquiv.{u3, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u3) (succ u2), succ u3, succ u2} (RingEquiv.{u3, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u3 u2, u3, u2} (RingEquiv.{u3, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u3 u2, u3, u2} (RingEquiv.{u3, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u3, u2} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e₁))
Case conversion may be inaccurate. Consider using '#align ring_equiv.coe_trans RingEquiv.coe_transₓ'. -/
@[simp]
theorem coe_trans (e₁ : R ≃+* S) (e₂ : S ≃+* S') : (e₁.trans e₂ : R → S') = e₂ ∘ e₁ :=
  rfl
#align ring_equiv.coe_trans RingEquiv.coe_trans

/- warning: ring_equiv.symm_trans_apply -> RingEquiv.symm_trans_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {S' : Type.{u3}} [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Mul.{u2} S] [_inst_4 : Add.{u2} S] [_inst_5 : Mul.{u3} S'] [_inst_6 : Add.{u3} S'] (e₁ : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (e₂ : RingEquiv.{u2, u3} S S' _inst_3 _inst_4 _inst_5 _inst_6) (a : S'), Eq.{succ u1} R (coeFn.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (RingEquiv.{u3, u1} S' R _inst_5 _inst_6 _inst_1 _inst_2) (fun (_x : RingEquiv.{u3, u1} S' R _inst_5 _inst_6 _inst_1 _inst_2) => S' -> R) (RingEquiv.hasCoeToFun.{u3, u1} S' R _inst_5 _inst_6 _inst_1 _inst_2) (RingEquiv.symm.{u1, u3} R S' _inst_1 _inst_2 _inst_5 _inst_6 (RingEquiv.trans.{u1, u2, u3} R S S' _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 e₁ e₂)) a) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingEquiv.{u2, u1} S R _inst_3 _inst_4 _inst_1 _inst_2) (fun (_x : RingEquiv.{u2, u1} S R _inst_3 _inst_4 _inst_1 _inst_2) => S -> R) (RingEquiv.hasCoeToFun.{u2, u1} S R _inst_3 _inst_4 _inst_1 _inst_2) (RingEquiv.symm.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4 e₁) (coeFn.{max (succ u3) (succ u2), max (succ u3) (succ u2)} (RingEquiv.{u3, u2} S' S _inst_5 _inst_6 _inst_3 _inst_4) (fun (_x : RingEquiv.{u3, u2} S' S _inst_5 _inst_6 _inst_3 _inst_4) => S' -> S) (RingEquiv.hasCoeToFun.{u3, u2} S' S _inst_5 _inst_6 _inst_3 _inst_4) (RingEquiv.symm.{u2, u3} S S' _inst_3 _inst_4 _inst_5 _inst_6 e₂) a))
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u2}} {S' : Type.{u1}} [_inst_1 : Mul.{u3} R] [_inst_2 : Mul.{u2} S] [_inst_3 : Add.{u3} R] [_inst_4 : Add.{u2} S] [_inst_5 : Mul.{u1} S'] [_inst_6 : Add.{u1} S'] (e₁ : RingEquiv.{u3, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (e₂ : RingEquiv.{u2, u1} S S' _inst_2 _inst_5 _inst_4 _inst_6) (a : S'), Eq.{succ u3} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : S') => R) a) (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (RingEquiv.{u1, u3} S' R _inst_5 _inst_1 _inst_6 _inst_3) S' (fun (_x : S') => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : S') => R) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u1), succ u1, succ u3} (RingEquiv.{u1, u3} S' R _inst_5 _inst_1 _inst_6 _inst_3) S' R (EquivLike.toEmbeddingLike.{max (succ u3) (succ u1), succ u1, succ u3} (RingEquiv.{u1, u3} S' R _inst_5 _inst_1 _inst_6 _inst_3) S' R (MulEquivClass.toEquivLike.{max u3 u1, u1, u3} (RingEquiv.{u1, u3} S' R _inst_5 _inst_1 _inst_6 _inst_3) S' R _inst_5 _inst_1 (RingEquivClass.toMulEquivClass.{max u3 u1, u1, u3} (RingEquiv.{u1, u3} S' R _inst_5 _inst_1 _inst_6 _inst_3) S' R _inst_5 _inst_6 _inst_1 _inst_3 (RingEquiv.instRingEquivClassRingEquiv.{u1, u3} S' R _inst_5 _inst_1 _inst_6 _inst_3))))) (RingEquiv.symm.{u3, u1} R S' _inst_1 _inst_5 _inst_3 _inst_6 (RingEquiv.trans.{u3, u2, u1} R S S' _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 e₁ e₂)) a) (FunLike.coe.{max (succ u3) (succ u2), succ u2, succ u3} (RingEquiv.{u2, u3} S R _inst_2 _inst_1 _inst_4 _inst_3) S (fun (_x : S) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : S) => R) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u2), succ u2, succ u3} (RingEquiv.{u2, u3} S R _inst_2 _inst_1 _inst_4 _inst_3) S R (EquivLike.toEmbeddingLike.{max (succ u3) (succ u2), succ u2, succ u3} (RingEquiv.{u2, u3} S R _inst_2 _inst_1 _inst_4 _inst_3) S R (MulEquivClass.toEquivLike.{max u3 u2, u2, u3} (RingEquiv.{u2, u3} S R _inst_2 _inst_1 _inst_4 _inst_3) S R _inst_2 _inst_1 (RingEquivClass.toMulEquivClass.{max u3 u2, u2, u3} (RingEquiv.{u2, u3} S R _inst_2 _inst_1 _inst_4 _inst_3) S R _inst_2 _inst_4 _inst_1 _inst_3 (RingEquiv.instRingEquivClassRingEquiv.{u2, u3} S R _inst_2 _inst_1 _inst_4 _inst_3))))) (RingEquiv.symm.{u3, u2} R S _inst_1 _inst_2 _inst_3 _inst_4 e₁) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (RingEquiv.{u1, u2} S' S _inst_5 _inst_2 _inst_6 _inst_4) S' (fun (_x : S') => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : S') => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u1, succ u2} (RingEquiv.{u1, u2} S' S _inst_5 _inst_2 _inst_6 _inst_4) S' S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u1, succ u2} (RingEquiv.{u1, u2} S' S _inst_5 _inst_2 _inst_6 _inst_4) S' S (MulEquivClass.toEquivLike.{max u2 u1, u1, u2} (RingEquiv.{u1, u2} S' S _inst_5 _inst_2 _inst_6 _inst_4) S' S _inst_5 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u1, u2} (RingEquiv.{u1, u2} S' S _inst_5 _inst_2 _inst_6 _inst_4) S' S _inst_5 _inst_6 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u1, u2} S' S _inst_5 _inst_2 _inst_6 _inst_4))))) (RingEquiv.symm.{u2, u1} S S' _inst_2 _inst_5 _inst_4 _inst_6 e₂) a))
Case conversion may be inaccurate. Consider using '#align ring_equiv.symm_trans_apply RingEquiv.symm_trans_applyₓ'. -/
@[simp]
theorem symm_trans_apply (e₁ : R ≃+* S) (e₂ : S ≃+* S') (a : S') :
    (e₁.trans e₂).symm a = e₁.symm (e₂.symm a) :=
  rfl
#align ring_equiv.symm_trans_apply RingEquiv.symm_trans_apply

/- warning: ring_equiv.symm_trans -> RingEquiv.symm_trans is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {S' : Type.{u3}} [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Mul.{u2} S] [_inst_4 : Add.{u2} S] [_inst_5 : Mul.{u3} S'] [_inst_6 : Add.{u3} S'] (e₁ : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (e₂ : RingEquiv.{u2, u3} S S' _inst_3 _inst_4 _inst_5 _inst_6), Eq.{max (succ u3) (succ u1)} (RingEquiv.{u3, u1} S' R _inst_5 _inst_6 _inst_1 _inst_2) (RingEquiv.symm.{u1, u3} R S' _inst_1 _inst_2 _inst_5 _inst_6 (RingEquiv.trans.{u1, u2, u3} R S S' _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 e₁ e₂)) (RingEquiv.trans.{u3, u2, u1} S' S R _inst_5 _inst_6 _inst_3 _inst_4 _inst_1 _inst_2 (RingEquiv.symm.{u2, u3} S S' _inst_3 _inst_4 _inst_5 _inst_6 e₂) (RingEquiv.symm.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4 e₁))
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u2}} {S' : Type.{u1}} [_inst_1 : Mul.{u3} R] [_inst_2 : Mul.{u2} S] [_inst_3 : Add.{u3} R] [_inst_4 : Add.{u2} S] [_inst_5 : Mul.{u1} S'] [_inst_6 : Add.{u1} S'] (e₁ : RingEquiv.{u3, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (e₂ : RingEquiv.{u2, u1} S S' _inst_2 _inst_5 _inst_4 _inst_6), Eq.{max (succ u3) (succ u1)} (RingEquiv.{u1, u3} S' R _inst_5 _inst_1 _inst_6 _inst_3) (RingEquiv.symm.{u3, u1} R S' _inst_1 _inst_5 _inst_3 _inst_6 (RingEquiv.trans.{u3, u2, u1} R S S' _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 e₁ e₂)) (RingEquiv.trans.{u1, u2, u3} S' S R _inst_5 _inst_2 _inst_6 _inst_4 _inst_1 _inst_3 (RingEquiv.symm.{u2, u1} S S' _inst_2 _inst_5 _inst_4 _inst_6 e₂) (RingEquiv.symm.{u3, u2} R S _inst_1 _inst_2 _inst_3 _inst_4 e₁))
Case conversion may be inaccurate. Consider using '#align ring_equiv.symm_trans RingEquiv.symm_transₓ'. -/
theorem symm_trans (e₁ : R ≃+* S) (e₂ : S ≃+* S') : (e₁.trans e₂).symm = e₂.symm.trans e₁.symm :=
  rfl
#align ring_equiv.symm_trans RingEquiv.symm_trans

/- warning: ring_equiv.bijective -> RingEquiv.bijective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Mul.{u2} S] [_inst_4 : Add.{u2} S] (e : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4), Function.Bijective.{succ u1, succ u2} R S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) e)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Mul.{u2} R] [_inst_2 : Mul.{u1} S] [_inst_3 : Add.{u2} R] [_inst_4 : Add.{u1} S] (e : RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4), Function.Bijective.{succ u2, succ u1} R S (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e)
Case conversion may be inaccurate. Consider using '#align ring_equiv.bijective RingEquiv.bijectiveₓ'. -/
protected theorem bijective (e : R ≃+* S) : Function.Bijective e :=
  EquivLike.bijective e
#align ring_equiv.bijective RingEquiv.bijective

/- warning: ring_equiv.injective -> RingEquiv.injective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Mul.{u2} S] [_inst_4 : Add.{u2} S] (e : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4), Function.Injective.{succ u1, succ u2} R S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) e)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Mul.{u2} R] [_inst_2 : Mul.{u1} S] [_inst_3 : Add.{u2} R] [_inst_4 : Add.{u1} S] (e : RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4), Function.Injective.{succ u2, succ u1} R S (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e)
Case conversion may be inaccurate. Consider using '#align ring_equiv.injective RingEquiv.injectiveₓ'. -/
protected theorem injective (e : R ≃+* S) : Function.Injective e :=
  EquivLike.injective e
#align ring_equiv.injective RingEquiv.injective

/- warning: ring_equiv.surjective -> RingEquiv.surjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Mul.{u2} S] [_inst_4 : Add.{u2} S] (e : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4), Function.Surjective.{succ u1, succ u2} R S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) e)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Mul.{u2} R] [_inst_2 : Mul.{u1} S] [_inst_3 : Add.{u2} R] [_inst_4 : Add.{u1} S] (e : RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4), Function.Surjective.{succ u2, succ u1} R S (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e)
Case conversion may be inaccurate. Consider using '#align ring_equiv.surjective RingEquiv.surjectiveₓ'. -/
protected theorem surjective (e : R ≃+* S) : Function.Surjective e :=
  EquivLike.surjective e
#align ring_equiv.surjective RingEquiv.surjective

/- warning: ring_equiv.apply_symm_apply -> RingEquiv.apply_symm_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Mul.{u2} S] [_inst_4 : Add.{u2} S] (e : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (x : S), Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) e (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingEquiv.{u2, u1} S R _inst_3 _inst_4 _inst_1 _inst_2) (fun (_x : RingEquiv.{u2, u1} S R _inst_3 _inst_4 _inst_1 _inst_2) => S -> R) (RingEquiv.hasCoeToFun.{u2, u1} S R _inst_3 _inst_4 _inst_1 _inst_2) (RingEquiv.symm.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4 e) x)) x
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Mul.{u2} R] [_inst_2 : Mul.{u1} S] [_inst_3 : Add.{u2} R] [_inst_4 : Add.{u1} S] (e : RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) (x : S), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (RingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3) S (fun (a : S) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : S) => R) a) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u1, succ u2} (RingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3) S R (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u1, succ u2} (RingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3) S R (MulEquivClass.toEquivLike.{max u2 u1, u1, u2} (RingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3) S R _inst_2 _inst_1 (RingEquivClass.toMulEquivClass.{max u2 u1, u1, u2} (RingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3) S R _inst_2 _inst_4 _inst_1 _inst_3 (RingEquiv.instRingEquivClassRingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3))))) (RingEquiv.symm.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4 e) x)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (RingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3) S (fun (_x : S) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : S) => R) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u1, succ u2} (RingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3) S R (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u1, succ u2} (RingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3) S R (MulEquivClass.toEquivLike.{max u2 u1, u1, u2} (RingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3) S R _inst_2 _inst_1 (RingEquivClass.toMulEquivClass.{max u2 u1, u1, u2} (RingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3) S R _inst_2 _inst_4 _inst_1 _inst_3 (RingEquiv.instRingEquivClassRingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3))))) (RingEquiv.symm.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4 e) x)) x
Case conversion may be inaccurate. Consider using '#align ring_equiv.apply_symm_apply RingEquiv.apply_symm_applyₓ'. -/
@[simp]
theorem apply_symm_apply (e : R ≃+* S) : ∀ x, e (e.symm x) = x :=
  e.toEquiv.apply_symm_apply
#align ring_equiv.apply_symm_apply RingEquiv.apply_symm_apply

/- warning: ring_equiv.symm_apply_apply -> RingEquiv.symm_apply_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Mul.{u2} S] [_inst_4 : Add.{u2} S] (e : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (x : R), Eq.{succ u1} R (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingEquiv.{u2, u1} S R _inst_3 _inst_4 _inst_1 _inst_2) (fun (_x : RingEquiv.{u2, u1} S R _inst_3 _inst_4 _inst_1 _inst_2) => S -> R) (RingEquiv.hasCoeToFun.{u2, u1} S R _inst_3 _inst_4 _inst_1 _inst_2) (RingEquiv.symm.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4 e) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) e x)) x
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Mul.{u2} R] [_inst_2 : Mul.{u1} S] [_inst_3 : Add.{u2} R] [_inst_4 : Add.{u1} S] (e : RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) (x : R), Eq.{succ u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : S) => R) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (a : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) a) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e x)) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (RingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3) S (fun (_x : S) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : S) => R) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u1, succ u2} (RingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3) S R (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u1, succ u2} (RingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3) S R (MulEquivClass.toEquivLike.{max u2 u1, u1, u2} (RingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3) S R _inst_2 _inst_1 (RingEquivClass.toMulEquivClass.{max u2 u1, u1, u2} (RingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3) S R _inst_2 _inst_4 _inst_1 _inst_3 (RingEquiv.instRingEquivClassRingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3))))) (RingEquiv.symm.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4 e) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e x)) x
Case conversion may be inaccurate. Consider using '#align ring_equiv.symm_apply_apply RingEquiv.symm_apply_applyₓ'. -/
@[simp]
theorem symm_apply_apply (e : R ≃+* S) : ∀ x, e.symm (e x) = x :=
  e.toEquiv.symm_apply_apply
#align ring_equiv.symm_apply_apply RingEquiv.symm_apply_apply

/- warning: ring_equiv.image_eq_preimage -> RingEquiv.image_eq_preimage is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Mul.{u2} S] [_inst_4 : Add.{u2} S] (e : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (s : Set.{u1} R), Eq.{succ u2} (Set.{u2} S) (Set.image.{u1, u2} R S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) e) s) (Set.preimage.{u2, u1} S R (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingEquiv.{u2, u1} S R _inst_3 _inst_4 _inst_1 _inst_2) (fun (_x : RingEquiv.{u2, u1} S R _inst_3 _inst_4 _inst_1 _inst_2) => S -> R) (RingEquiv.hasCoeToFun.{u2, u1} S R _inst_3 _inst_4 _inst_1 _inst_2) (RingEquiv.symm.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4 e)) s)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Mul.{u2} R] [_inst_2 : Mul.{u1} S] [_inst_3 : Add.{u2} R] [_inst_4 : Add.{u1} S] (e : RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) (s : Set.{u2} R), Eq.{succ u1} (Set.{u1} S) (Set.image.{u2, u1} R S (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e) s) (Set.preimage.{u1, u2} S R (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (RingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3) S (fun (_x : S) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : S) => R) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u1, succ u2} (RingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3) S R (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u1, succ u2} (RingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3) S R (MulEquivClass.toEquivLike.{max u2 u1, u1, u2} (RingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3) S R _inst_2 _inst_1 (RingEquivClass.toMulEquivClass.{max u2 u1, u1, u2} (RingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3) S R _inst_2 _inst_4 _inst_1 _inst_3 (RingEquiv.instRingEquivClassRingEquiv.{u1, u2} S R _inst_2 _inst_1 _inst_4 _inst_3))))) (RingEquiv.symm.{u2, u1} R S _inst_1 _inst_2 _inst_3 _inst_4 e)) s)
Case conversion may be inaccurate. Consider using '#align ring_equiv.image_eq_preimage RingEquiv.image_eq_preimageₓ'. -/
theorem image_eq_preimage (e : R ≃+* S) (s : Set R) : e '' s = e.symm ⁻¹' s :=
  e.toEquiv.image_eq_preimage s
#align ring_equiv.image_eq_preimage RingEquiv.image_eq_preimage

/- warning: ring_equiv.coe_mul_equiv_trans -> RingEquiv.coe_mulEquiv_trans is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {S' : Type.{u3}} [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Mul.{u2} S] [_inst_4 : Add.{u2} S] [_inst_5 : Mul.{u3} S'] [_inst_6 : Add.{u3} S'] (e₁ : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (e₂ : RingEquiv.{u2, u3} S S' _inst_3 _inst_4 _inst_5 _inst_6), Eq.{max (succ u1) (succ u3)} (MulEquiv.{u1, u3} R S' _inst_1 _inst_5) ((fun (a : Sort.{max (succ u1) (succ u3)}) (b : Sort.{max (succ u1) (succ u3)}) [self : HasLiftT.{max (succ u1) (succ u3), max (succ u1) (succ u3)} a b] => self.0) (RingEquiv.{u1, u3} R S' _inst_1 _inst_2 _inst_5 _inst_6) (MulEquiv.{u1, u3} R S' _inst_1 _inst_5) (HasLiftT.mk.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (RingEquiv.{u1, u3} R S' _inst_1 _inst_2 _inst_5 _inst_6) (MulEquiv.{u1, u3} R S' _inst_1 _inst_5) (CoeTCₓ.coe.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (RingEquiv.{u1, u3} R S' _inst_1 _inst_2 _inst_5 _inst_6) (MulEquiv.{u1, u3} R S' _inst_1 _inst_5) (MulEquiv.hasCoeT.{max u1 u3, u1, u3} (RingEquiv.{u1, u3} R S' _inst_1 _inst_2 _inst_5 _inst_6) R S' _inst_1 _inst_5 (RingEquivClass.toMulEquivClass.{max u1 u3, u1, u3} (RingEquiv.{u1, u3} R S' _inst_1 _inst_2 _inst_5 _inst_6) R S' _inst_1 _inst_2 _inst_5 _inst_6 (RingEquiv.ringEquivClass.{u1, u3} R S' _inst_1 _inst_2 _inst_5 _inst_6))))) (RingEquiv.trans.{u1, u2, u3} R S S' _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 e₁ e₂)) (MulEquiv.trans.{u1, u2, u3} R S S' _inst_1 _inst_3 _inst_5 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (MulEquiv.{u1, u2} R S _inst_1 _inst_3) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (MulEquiv.{u1, u2} R S _inst_1 _inst_3) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (MulEquiv.{u1, u2} R S _inst_1 _inst_3) (MulEquiv.hasCoeT.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 (RingEquivClass.toMulEquivClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 _inst_3 _inst_4 (RingEquiv.ringEquivClass.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e₁) ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u2) (succ u3)} a b] => self.0) (RingEquiv.{u2, u3} S S' _inst_3 _inst_4 _inst_5 _inst_6) (MulEquiv.{u2, u3} S S' _inst_3 _inst_5) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (RingEquiv.{u2, u3} S S' _inst_3 _inst_4 _inst_5 _inst_6) (MulEquiv.{u2, u3} S S' _inst_3 _inst_5) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (RingEquiv.{u2, u3} S S' _inst_3 _inst_4 _inst_5 _inst_6) (MulEquiv.{u2, u3} S S' _inst_3 _inst_5) (MulEquiv.hasCoeT.{max u2 u3, u2, u3} (RingEquiv.{u2, u3} S S' _inst_3 _inst_4 _inst_5 _inst_6) S S' _inst_3 _inst_5 (RingEquivClass.toMulEquivClass.{max u2 u3, u2, u3} (RingEquiv.{u2, u3} S S' _inst_3 _inst_4 _inst_5 _inst_6) S S' _inst_3 _inst_4 _inst_5 _inst_6 (RingEquiv.ringEquivClass.{u2, u3} S S' _inst_3 _inst_4 _inst_5 _inst_6))))) e₂))
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u2}} {S' : Type.{u1}} [_inst_1 : Mul.{u3} R] [_inst_2 : Mul.{u2} S] [_inst_3 : Add.{u3} R] [_inst_4 : Add.{u2} S] [_inst_5 : Mul.{u1} S'] [_inst_6 : Add.{u1} S'] (e₁ : RingEquiv.{u3, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (e₂ : RingEquiv.{u2, u1} S S' _inst_2 _inst_5 _inst_4 _inst_6), Eq.{max (succ u3) (succ u1)} (MulEquiv.{u3, u1} R S' _inst_1 _inst_5) (MulEquivClass.toMulEquiv.{max u3 u1, u3, u1} (RingEquiv.{u3, u1} R S' _inst_1 _inst_5 _inst_3 _inst_6) R S' _inst_1 _inst_5 (RingEquivClass.toMulEquivClass.{max u3 u1, u3, u1} (RingEquiv.{u3, u1} R S' _inst_1 _inst_5 _inst_3 _inst_6) R S' _inst_1 _inst_3 _inst_5 _inst_6 (RingEquiv.instRingEquivClassRingEquiv.{u3, u1} R S' _inst_1 _inst_5 _inst_3 _inst_6)) (RingEquiv.trans.{u3, u2, u1} R S S' _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 e₁ e₂)) (MulEquiv.trans.{u3, u2, u1} R S S' _inst_1 _inst_2 _inst_5 (MulEquivClass.toMulEquiv.{max u3 u2, u3, u2} (RingEquiv.{u3, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 (RingEquivClass.toMulEquivClass.{max u3 u2, u3, u2} (RingEquiv.{u3, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u3, u2} R S _inst_1 _inst_2 _inst_3 _inst_4)) e₁) (MulEquivClass.toMulEquiv.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} S S' _inst_2 _inst_5 _inst_4 _inst_6) S S' _inst_2 _inst_5 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} S S' _inst_2 _inst_5 _inst_4 _inst_6) S S' _inst_2 _inst_4 _inst_5 _inst_6 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} S S' _inst_2 _inst_5 _inst_4 _inst_6)) e₂))
Case conversion may be inaccurate. Consider using '#align ring_equiv.coe_mul_equiv_trans RingEquiv.coe_mulEquiv_transₓ'. -/
@[simp]
theorem coe_mulEquiv_trans (e₁ : R ≃+* S) (e₂ : S ≃+* S') :
    (e₁.trans e₂ : R ≃* S') = (e₁ : R ≃* S).trans ↑e₂ :=
  rfl
#align ring_equiv.coe_mul_equiv_trans RingEquiv.coe_mulEquiv_trans

/- warning: ring_equiv.coe_add_equiv_trans -> RingEquiv.coe_addEquiv_trans is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {S' : Type.{u3}} [_inst_1 : Mul.{u1} R] [_inst_2 : Add.{u1} R] [_inst_3 : Mul.{u2} S] [_inst_4 : Add.{u2} S] [_inst_5 : Mul.{u3} S'] [_inst_6 : Add.{u3} S'] (e₁ : RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (e₂ : RingEquiv.{u2, u3} S S' _inst_3 _inst_4 _inst_5 _inst_6), Eq.{max (succ u1) (succ u3)} (AddEquiv.{u1, u3} R S' _inst_2 _inst_6) ((fun (a : Sort.{max (succ u1) (succ u3)}) (b : Sort.{max (succ u1) (succ u3)}) [self : HasLiftT.{max (succ u1) (succ u3), max (succ u1) (succ u3)} a b] => self.0) (RingEquiv.{u1, u3} R S' _inst_1 _inst_2 _inst_5 _inst_6) (AddEquiv.{u1, u3} R S' _inst_2 _inst_6) (HasLiftT.mk.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (RingEquiv.{u1, u3} R S' _inst_1 _inst_2 _inst_5 _inst_6) (AddEquiv.{u1, u3} R S' _inst_2 _inst_6) (CoeTCₓ.coe.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (RingEquiv.{u1, u3} R S' _inst_1 _inst_2 _inst_5 _inst_6) (AddEquiv.{u1, u3} R S' _inst_2 _inst_6) (AddEquiv.hasCoeT.{max u1 u3, u1, u3} (RingEquiv.{u1, u3} R S' _inst_1 _inst_2 _inst_5 _inst_6) R S' _inst_2 _inst_6 (RingEquivClass.toAddEquivClass.{max u1 u3, u1, u3} (RingEquiv.{u1, u3} R S' _inst_1 _inst_2 _inst_5 _inst_6) R S' _inst_1 _inst_2 _inst_5 _inst_6 (RingEquiv.ringEquivClass.{u1, u3} R S' _inst_1 _inst_2 _inst_5 _inst_6))))) (RingEquiv.trans.{u1, u2, u3} R S S' _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 e₁ e₂)) (AddEquiv.trans.{u1, u2, u3} R S S' _inst_2 _inst_4 _inst_6 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (AddEquiv.{u1, u2} R S _inst_2 _inst_4) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (AddEquiv.{u1, u2} R S _inst_2 _inst_4) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (AddEquiv.{u1, u2} R S _inst_2 _inst_4) (AddEquiv.hasCoeT.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_2 _inst_4 (RingEquivClass.toAddEquivClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_2 _inst_3 _inst_4 (RingEquiv.ringEquivClass.{u1, u2} R S _inst_1 _inst_2 _inst_3 _inst_4))))) e₁) ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u2) (succ u3)} a b] => self.0) (RingEquiv.{u2, u3} S S' _inst_3 _inst_4 _inst_5 _inst_6) (AddEquiv.{u2, u3} S S' _inst_4 _inst_6) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (RingEquiv.{u2, u3} S S' _inst_3 _inst_4 _inst_5 _inst_6) (AddEquiv.{u2, u3} S S' _inst_4 _inst_6) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (RingEquiv.{u2, u3} S S' _inst_3 _inst_4 _inst_5 _inst_6) (AddEquiv.{u2, u3} S S' _inst_4 _inst_6) (AddEquiv.hasCoeT.{max u2 u3, u2, u3} (RingEquiv.{u2, u3} S S' _inst_3 _inst_4 _inst_5 _inst_6) S S' _inst_4 _inst_6 (RingEquivClass.toAddEquivClass.{max u2 u3, u2, u3} (RingEquiv.{u2, u3} S S' _inst_3 _inst_4 _inst_5 _inst_6) S S' _inst_3 _inst_4 _inst_5 _inst_6 (RingEquiv.ringEquivClass.{u2, u3} S S' _inst_3 _inst_4 _inst_5 _inst_6))))) e₂))
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u2}} {S' : Type.{u1}} [_inst_1 : Mul.{u3} R] [_inst_2 : Mul.{u2} S] [_inst_3 : Add.{u3} R] [_inst_4 : Add.{u2} S] [_inst_5 : Mul.{u1} S'] [_inst_6 : Add.{u1} S'] (e₁ : RingEquiv.{u3, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) (e₂ : RingEquiv.{u2, u1} S S' _inst_2 _inst_5 _inst_4 _inst_6), Eq.{max (succ u3) (succ u1)} (AddEquiv.{u3, u1} R S' _inst_3 _inst_6) (AddEquivClass.toAddEquiv.{max u3 u1, u3, u1} (RingEquiv.{u3, u1} R S' _inst_1 _inst_5 _inst_3 _inst_6) R S' _inst_3 _inst_6 (RingEquivClass.toAddEquivClass.{max u3 u1, u3, u1} (RingEquiv.{u3, u1} R S' _inst_1 _inst_5 _inst_3 _inst_6) R S' _inst_1 _inst_3 _inst_5 _inst_6 (RingEquiv.instRingEquivClassRingEquiv.{u3, u1} R S' _inst_1 _inst_5 _inst_3 _inst_6)) (RingEquiv.trans.{u3, u2, u1} R S S' _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 e₁ e₂)) (AddEquiv.trans.{u3, u2, u1} R S S' _inst_3 _inst_4 _inst_6 (AddEquivClass.toAddEquiv.{max u3 u2, u3, u2} (RingEquiv.{u3, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_3 _inst_4 (RingEquivClass.toAddEquivClass.{max u3 u2, u3, u2} (RingEquiv.{u3, u2} R S _inst_1 _inst_2 _inst_3 _inst_4) R S _inst_1 _inst_3 _inst_2 _inst_4 (RingEquiv.instRingEquivClassRingEquiv.{u3, u2} R S _inst_1 _inst_2 _inst_3 _inst_4)) e₁) (AddEquivClass.toAddEquiv.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} S S' _inst_2 _inst_5 _inst_4 _inst_6) S S' _inst_4 _inst_6 (RingEquivClass.toAddEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} S S' _inst_2 _inst_5 _inst_4 _inst_6) S S' _inst_2 _inst_4 _inst_5 _inst_6 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} S S' _inst_2 _inst_5 _inst_4 _inst_6)) e₂))
Case conversion may be inaccurate. Consider using '#align ring_equiv.coe_add_equiv_trans RingEquiv.coe_addEquiv_transₓ'. -/
@[simp]
theorem coe_addEquiv_trans (e₁ : R ≃+* S) (e₂ : S ≃+* S') :
    (e₁.trans e₂ : R ≃+ S') = (e₁ : R ≃+ S).trans ↑e₂ :=
  rfl
#align ring_equiv.coe_add_equiv_trans RingEquiv.coe_addEquiv_trans

end Basic

section Opposite

open MulOpposite

/- warning: ring_equiv.op -> RingEquiv.op is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Add.{u1} α] [_inst_2 : Mul.{u1} α] [_inst_3 : Add.{u2} β] [_inst_4 : Mul.{u2} β], Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} α β _inst_2 _inst_1 _inst_4 _inst_3) (RingEquiv.{u1, u2} (MulOpposite.{u1} α) (MulOpposite.{u2} β) (MulOpposite.hasMul.{u1} α _inst_2) (MulOpposite.hasAdd.{u1} α _inst_1) (MulOpposite.hasMul.{u2} β _inst_4) (MulOpposite.hasAdd.{u2} β _inst_3))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Add.{u1} α] [_inst_2 : Mul.{u1} α] [_inst_3 : Add.{u2} β] [_inst_4 : Mul.{u2} β], Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingEquiv.{u1, u2} α β _inst_2 _inst_4 _inst_1 _inst_3) (RingEquiv.{u1, u2} (MulOpposite.{u1} α) (MulOpposite.{u2} β) (MulOpposite.instMulMulOpposite.{u1} α _inst_2) (MulOpposite.instMulMulOpposite.{u2} β _inst_4) (MulOpposite.instAddMulOpposite.{u1} α _inst_1) (MulOpposite.instAddMulOpposite.{u2} β _inst_3))
Case conversion may be inaccurate. Consider using '#align ring_equiv.op RingEquiv.opₓ'. -/
/-- A ring iso `α ≃+* β` can equivalently be viewed as a ring iso `αᵐᵒᵖ ≃+* βᵐᵒᵖ`. -/
@[simps]
protected def op {α β} [Add α] [Mul α] [Add β] [Mul β] : α ≃+* β ≃ (αᵐᵒᵖ ≃+* βᵐᵒᵖ)
    where
  toFun f := { f.toAddEquiv.mulOp, f.toMulEquiv.op with }
  invFun f := { AddEquiv.mulOp.symm f.toAddEquiv, MulEquiv.op.symm f.toMulEquiv with }
  left_inv f := by
    ext
    rfl
  right_inv f := by
    ext
    rfl
#align ring_equiv.op RingEquiv.op

/- warning: ring_equiv.unop -> RingEquiv.unop is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Add.{u1} α] [_inst_2 : Mul.{u1} α] [_inst_3 : Add.{u2} β] [_inst_4 : Mul.{u2} β], Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} (MulOpposite.{u1} α) (MulOpposite.{u2} β) (MulOpposite.hasMul.{u1} α _inst_2) (MulOpposite.hasAdd.{u1} α _inst_1) (MulOpposite.hasMul.{u2} β _inst_4) (MulOpposite.hasAdd.{u2} β _inst_3)) (RingEquiv.{u1, u2} α β _inst_2 _inst_1 _inst_4 _inst_3)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Add.{u1} α] [_inst_2 : Mul.{u1} α] [_inst_3 : Add.{u2} β] [_inst_4 : Mul.{u2} β], Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingEquiv.{u1, u2} (MulOpposite.{u1} α) (MulOpposite.{u2} β) (MulOpposite.instMulMulOpposite.{u1} α _inst_2) (MulOpposite.instMulMulOpposite.{u2} β _inst_4) (MulOpposite.instAddMulOpposite.{u1} α _inst_1) (MulOpposite.instAddMulOpposite.{u2} β _inst_3)) (RingEquiv.{u1, u2} α β _inst_2 _inst_4 _inst_1 _inst_3)
Case conversion may be inaccurate. Consider using '#align ring_equiv.unop RingEquiv.unopₓ'. -/
/-- The 'unopposite' of a ring iso `αᵐᵒᵖ ≃+* βᵐᵒᵖ`. Inverse to `ring_equiv.op`. -/
@[simp]
protected def unop {α β} [Add α] [Mul α] [Add β] [Mul β] : αᵐᵒᵖ ≃+* βᵐᵒᵖ ≃ (α ≃+* β) :=
  RingEquiv.op.symm
#align ring_equiv.unop RingEquiv.unop

section NonUnitalCommSemiring

variable (R) [NonUnitalCommSemiring R]

/- warning: ring_equiv.to_opposite -> RingEquiv.toOpposite is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : NonUnitalCommSemiring.{u1} R], RingEquiv.{u1, u1} R (MulOpposite.{u1} R) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} R _inst_1)))) (MulOpposite.hasMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} R _inst_1))))) (MulOpposite.hasAdd.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} R _inst_1)))))
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : NonUnitalCommSemiring.{u1} R], RingEquiv.{u1, u1} R (MulOpposite.{u1} R) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} R _inst_1))) (MulOpposite.instMulMulOpposite.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} R _inst_1)))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} R _inst_1)))) (MulOpposite.instAddMulOpposite.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align ring_equiv.to_opposite RingEquiv.toOppositeₓ'. -/
/-- A non-unital commutative ring is isomorphic to its opposite. -/
def toOpposite : R ≃+* Rᵐᵒᵖ :=
  { MulOpposite.opEquiv with
    map_add' := fun x y => rfl
    map_mul' := fun x y => mul_comm (op y) (op x) }
#align ring_equiv.to_opposite RingEquiv.toOpposite

#print RingEquiv.toOpposite_apply /-
@[simp]
theorem toOpposite_apply (r : R) : toOpposite R r = op r :=
  rfl
#align ring_equiv.to_opposite_apply RingEquiv.toOpposite_apply
-/

#print RingEquiv.toOpposite_symm_apply /-
@[simp]
theorem toOpposite_symm_apply (r : Rᵐᵒᵖ) : (toOpposite R).symm r = unop r :=
  rfl
#align ring_equiv.to_opposite_symm_apply RingEquiv.toOpposite_symm_apply
-/

end NonUnitalCommSemiring

end Opposite

section NonUnitalSemiring

variable [NonUnitalNonAssocSemiring R] [NonUnitalNonAssocSemiring S] (f : R ≃+* S) (x y : R)

/- warning: ring_equiv.map_zero -> RingEquiv.map_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] (f : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))), Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) (fun (_x : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) f (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R _inst_1)))))) (OfNat.ofNat.{u2} S 0 (OfNat.mk.{u2} S 0 (Zero.zero.{u2} S (MulZeroClass.toHasZero.{u2} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} S _inst_2)))))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] (f : RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))), Eq.{succ u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MulZeroClass.toZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R _inst_1))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) R S (EquivLike.toEmbeddingLike.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) R S (MulEquivClass.toEquivLike.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (RingEquivClass.toMulEquivClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (RingEquiv.instRingEquivClassRingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))))))) f (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MulZeroClass.toZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R _inst_1))))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MulZeroClass.toZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R _inst_1))))) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MulZeroClass.toZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R _inst_1))))) (MulZeroClass.toZero.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MulZeroClass.toZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MulZeroClass.toZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R _inst_1))))) _inst_2))))
Case conversion may be inaccurate. Consider using '#align ring_equiv.map_zero RingEquiv.map_zeroₓ'. -/
/-- A ring isomorphism sends zero to zero. -/
protected theorem map_zero : f 0 = 0 :=
  map_zero f
#align ring_equiv.map_zero RingEquiv.map_zero

variable {x}

/- warning: ring_equiv.map_eq_zero_iff -> RingEquiv.map_eq_zero_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] (f : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) {x : R}, Iff (Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) (fun (_x : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) f x) (OfNat.ofNat.{u2} S 0 (OfNat.mk.{u2} S 0 (Zero.zero.{u2} S (MulZeroClass.toHasZero.{u2} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} S _inst_2)))))) (Eq.{succ u1} R x (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R _inst_1))))))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] (f : RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) {x : R}, Iff (Eq.{succ u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) R S (EquivLike.toEmbeddingLike.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) R S (MulEquivClass.toEquivLike.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (RingEquivClass.toMulEquivClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (RingEquiv.instRingEquivClassRingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))))))) f x) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) (MulZeroClass.toZero.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) _inst_2))))) (Eq.{succ u1} R x (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MulZeroClass.toZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align ring_equiv.map_eq_zero_iff RingEquiv.map_eq_zero_iffₓ'. -/
protected theorem map_eq_zero_iff : f x = 0 ↔ x = 0 :=
  AddEquivClass.map_eq_zero_iff f
#align ring_equiv.map_eq_zero_iff RingEquiv.map_eq_zero_iff

/- warning: ring_equiv.map_ne_zero_iff -> RingEquiv.map_ne_zero_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] (f : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) {x : R}, Iff (Ne.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) (fun (_x : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) f x) (OfNat.ofNat.{u2} S 0 (OfNat.mk.{u2} S 0 (Zero.zero.{u2} S (MulZeroClass.toHasZero.{u2} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} S _inst_2)))))) (Ne.{succ u1} R x (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R _inst_1))))))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] (f : RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) {x : R}, Iff (Ne.{succ u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) R S (EquivLike.toEmbeddingLike.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) R S (MulEquivClass.toEquivLike.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (RingEquivClass.toMulEquivClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (RingEquiv.instRingEquivClassRingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))))))) f x) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) (MulZeroClass.toZero.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) _inst_2))))) (Ne.{succ u1} R x (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MulZeroClass.toZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align ring_equiv.map_ne_zero_iff RingEquiv.map_ne_zero_iffₓ'. -/
theorem map_ne_zero_iff : f x ≠ 0 ↔ x ≠ 0 :=
  AddEquivClass.map_ne_zero_iff f
#align ring_equiv.map_ne_zero_iff RingEquiv.map_ne_zero_iff

/- warning: ring_equiv.of_bijective -> RingEquiv.ofBijective is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u3} S] [_inst_3 : NonUnitalRingHomClass.{u1, u2, u3} F R S _inst_1 _inst_2] (f : F), (Function.Bijective.{succ u2, succ u3} R S (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u1, u2, u3} F R S (Distrib.toHasMul.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toHasMul.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S _inst_2)) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S _inst_1 _inst_2 _inst_3))) f)) -> (RingEquiv.{u2, u3} R S (Distrib.toHasMul.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toHasAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toHasMul.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S _inst_2)) (Distrib.toHasAdd.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S _inst_2)))
but is expected to have type
  forall {F : Type.{u1}} {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u3} S] [_inst_3 : NonUnitalRingHomClass.{u1, u2, u3} F R S _inst_1 _inst_2] (f : F), (Function.Bijective.{succ u2, succ u3} R S (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u3} S _inst_2) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S _inst_1 _inst_2 _inst_3)) f)) -> (RingEquiv.{u2, u3} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u3} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S _inst_2)))
Case conversion may be inaccurate. Consider using '#align ring_equiv.of_bijective RingEquiv.ofBijectiveₓ'. -/
/-- Produce a ring isomorphism from a bijective ring homomorphism. -/
noncomputable def ofBijective [NonUnitalRingHomClass F R S] (f : F) (hf : Function.Bijective f) :
    R ≃+* S :=
  { Equiv.ofBijective f hf with
    map_mul' := map_mul f
    map_add' := map_add f }
#align ring_equiv.of_bijective RingEquiv.ofBijective

/- warning: ring_equiv.coe_of_bijective -> RingEquiv.coe_ofBijective is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u3} S] [_inst_3 : NonUnitalRingHomClass.{u1, u2, u3} F R S _inst_1 _inst_2] (f : F) (hf : Function.Bijective.{succ u2, succ u3} R S (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u1, u2, u3} F R S (Distrib.toHasMul.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toHasMul.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S _inst_2)) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S _inst_1 _inst_2 _inst_3))) f)), Eq.{max (succ u2) (succ u3)} ((fun (_x : RingEquiv.{u2, u3} R S (Distrib.toHasMul.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toHasAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toHasMul.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S _inst_2)) (Distrib.toHasAdd.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S _inst_2))) => R -> S) (RingEquiv.ofBijective.{u1, u2, u3} F R S _inst_1 _inst_2 _inst_3 f hf)) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (RingEquiv.{u2, u3} R S (Distrib.toHasMul.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toHasAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toHasMul.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S _inst_2)) (Distrib.toHasAdd.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S _inst_2))) (fun (_x : RingEquiv.{u2, u3} R S (Distrib.toHasMul.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toHasAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toHasMul.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S _inst_2)) (Distrib.toHasAdd.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S _inst_2))) => R -> S) (RingEquiv.hasCoeToFun.{u2, u3} R S (Distrib.toHasMul.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toHasAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toHasMul.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S _inst_2)) (Distrib.toHasAdd.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S _inst_2))) (RingEquiv.ofBijective.{u1, u2, u3} F R S _inst_1 _inst_2 _inst_3 f hf)) (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u1, u2, u3} F R S (Distrib.toHasMul.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toHasMul.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S _inst_2)) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S _inst_1 _inst_2 _inst_3))) f)
but is expected to have type
  forall {F : Type.{u3}} {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u1} S] [_inst_3 : NonUnitalRingHomClass.{u3, u2, u1} F R S _inst_1 _inst_2] (f : F) (hf : Function.Bijective.{succ u2, succ u1} R S (FunLike.coe.{succ u3, succ u2, succ u1} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : R) => S) _x) (MulHomClass.toFunLike.{u3, u2, u1} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (NonUnitalRingHomClass.toMulHomClass.{u3, u2, u1} F R S _inst_1 _inst_2 _inst_3)) f)), Eq.{max (succ u2) (succ u1)} (forall (a : R), (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2))) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2))) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2))) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2))) R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2))) R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2)) (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2))))))) (RingEquiv.ofBijective.{u3, u2, u1} F R S _inst_1 _inst_2 _inst_3 f hf)) (FunLike.coe.{succ u3, succ u2, succ u1} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : R) => S) _x) (MulHomClass.toFunLike.{u3, u2, u1} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (NonUnitalRingHomClass.toMulHomClass.{u3, u2, u1} F R S _inst_1 _inst_2 _inst_3)) f)
Case conversion may be inaccurate. Consider using '#align ring_equiv.coe_of_bijective RingEquiv.coe_ofBijectiveₓ'. -/
@[simp]
theorem coe_ofBijective [NonUnitalRingHomClass F R S] (f : F) (hf : Function.Bijective f) :
    (ofBijective f hf : R → S) = f :=
  rfl
#align ring_equiv.coe_of_bijective RingEquiv.coe_ofBijective

/- warning: ring_equiv.of_bijective_apply -> RingEquiv.ofBijective_apply is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u3} S] [_inst_3 : NonUnitalRingHomClass.{u1, u2, u3} F R S _inst_1 _inst_2] (f : F) (hf : Function.Bijective.{succ u2, succ u3} R S (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u1, u2, u3} F R S (Distrib.toHasMul.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toHasMul.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S _inst_2)) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S _inst_1 _inst_2 _inst_3))) f)) (x : R), Eq.{succ u3} S (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (RingEquiv.{u2, u3} R S (Distrib.toHasMul.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toHasAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toHasMul.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S _inst_2)) (Distrib.toHasAdd.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S _inst_2))) (fun (_x : RingEquiv.{u2, u3} R S (Distrib.toHasMul.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toHasAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toHasMul.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S _inst_2)) (Distrib.toHasAdd.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S _inst_2))) => R -> S) (RingEquiv.hasCoeToFun.{u2, u3} R S (Distrib.toHasMul.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toHasAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toHasMul.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S _inst_2)) (Distrib.toHasAdd.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S _inst_2))) (RingEquiv.ofBijective.{u1, u2, u3} F R S _inst_1 _inst_2 _inst_3 f hf) x) (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u1, u2, u3} F R S (Distrib.toHasMul.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toHasMul.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S _inst_2)) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S _inst_1 _inst_2 _inst_3))) f x)
but is expected to have type
  forall {F : Type.{u3}} {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u1} S] [_inst_3 : NonUnitalRingHomClass.{u3, u2, u1} F R S _inst_1 _inst_2] (f : F) (hf : Function.Bijective.{succ u2, succ u1} R S (FunLike.coe.{succ u3, succ u2, succ u1} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : R) => S) _x) (MulHomClass.toFunLike.{u3, u2, u1} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (NonUnitalRingHomClass.toMulHomClass.{u3, u2, u1} F R S _inst_1 _inst_2 _inst_3)) f)) (x : R), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2))) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2))) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2))) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2))) R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2))) R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2)) (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2))))))) (RingEquiv.ofBijective.{u3, u2, u1} F R S _inst_1 _inst_2 _inst_3 f hf) x) (FunLike.coe.{succ u3, succ u2, succ u1} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : R) => S) _x) (MulHomClass.toFunLike.{u3, u2, u1} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (NonUnitalRingHomClass.toMulHomClass.{u3, u2, u1} F R S _inst_1 _inst_2 _inst_3)) f x)
Case conversion may be inaccurate. Consider using '#align ring_equiv.of_bijective_apply RingEquiv.ofBijective_applyₓ'. -/
theorem ofBijective_apply [NonUnitalRingHomClass F R S] (f : F) (hf : Function.Bijective f)
    (x : R) : ofBijective f hf x = f x :=
  rfl
#align ring_equiv.of_bijective_apply RingEquiv.ofBijective_apply

/- warning: ring_equiv.Pi_congr_right -> RingEquiv.piCongrRight is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : ι -> Type.{u2}} {S : ι -> Type.{u3}} [_inst_3 : forall (i : ι), NonUnitalNonAssocSemiring.{u2} (R i)] [_inst_4 : forall (i : ι), NonUnitalNonAssocSemiring.{u3} (S i)], (forall (i : ι), RingEquiv.{u2, u3} (R i) (S i) (Distrib.toHasMul.{u2} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (R i) (_inst_3 i))) (Distrib.toHasAdd.{u2} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (R i) (_inst_3 i))) (Distrib.toHasMul.{u3} (S i) (NonUnitalNonAssocSemiring.toDistrib.{u3} (S i) (_inst_4 i))) (Distrib.toHasAdd.{u3} (S i) (NonUnitalNonAssocSemiring.toDistrib.{u3} (S i) (_inst_4 i)))) -> (RingEquiv.{max u1 u2, max u1 u3} (forall (i : ι), R i) (forall (i : ι), S i) (Pi.instMul.{u1, u2} ι (fun (i : ι) => R i) (fun (i : ι) => Distrib.toHasMul.{u2} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (R i) (_inst_3 i)))) (Pi.instAdd.{u1, u2} ι (fun (i : ι) => R i) (fun (i : ι) => Distrib.toHasAdd.{u2} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (R i) (_inst_3 i)))) (Pi.instMul.{u1, u3} ι (fun (i : ι) => S i) (fun (i : ι) => Distrib.toHasMul.{u3} (S i) (NonUnitalNonAssocSemiring.toDistrib.{u3} (S i) (_inst_4 i)))) (Pi.instAdd.{u1, u3} ι (fun (i : ι) => S i) (fun (i : ι) => Distrib.toHasAdd.{u3} (S i) (NonUnitalNonAssocSemiring.toDistrib.{u3} (S i) (_inst_4 i)))))
but is expected to have type
  forall {ι : Type.{u1}} {R : ι -> Type.{u2}} {S : ι -> Type.{u3}} [_inst_3 : forall (i : ι), NonUnitalNonAssocSemiring.{u2} (R i)] [_inst_4 : forall (i : ι), NonUnitalNonAssocSemiring.{u3} (S i)], (forall (i : ι), RingEquiv.{u2, u3} (R i) (S i) (NonUnitalNonAssocSemiring.toMul.{u2} (R i) (_inst_3 i)) (NonUnitalNonAssocSemiring.toMul.{u3} (S i) (_inst_4 i)) (Distrib.toAdd.{u2} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (R i) (_inst_3 i))) (Distrib.toAdd.{u3} (S i) (NonUnitalNonAssocSemiring.toDistrib.{u3} (S i) (_inst_4 i)))) -> (RingEquiv.{max u1 u2, max u1 u3} (forall (i : ι), R i) (forall (i : ι), S i) (Pi.instMul.{u1, u2} ι (fun (i : ι) => R i) (fun (i : ι) => NonUnitalNonAssocSemiring.toMul.{u2} (R i) (_inst_3 i))) (Pi.instMul.{u1, u3} ι (fun (i : ι) => S i) (fun (i : ι) => NonUnitalNonAssocSemiring.toMul.{u3} (S i) (_inst_4 i))) (Pi.instAdd.{u1, u2} ι (fun (i : ι) => R i) (fun (i : ι) => Distrib.toAdd.{u2} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (R i) (_inst_3 i)))) (Pi.instAdd.{u1, u3} ι (fun (i : ι) => S i) (fun (i : ι) => Distrib.toAdd.{u3} (S i) (NonUnitalNonAssocSemiring.toDistrib.{u3} (S i) (_inst_4 i)))))
Case conversion may be inaccurate. Consider using '#align ring_equiv.Pi_congr_right RingEquiv.piCongrRightₓ'. -/
/-- A family of ring isomorphisms `Π j, (R j ≃+* S j)` generates a
ring isomorphisms between `Π j, R j` and `Π j, S j`.

This is the `ring_equiv` version of `equiv.Pi_congr_right`, and the dependent version of
`ring_equiv.arrow_congr`.
-/
@[simps apply]
def piCongrRight {ι : Type _} {R S : ι → Type _} [∀ i, NonUnitalNonAssocSemiring (R i)]
    [∀ i, NonUnitalNonAssocSemiring (S i)] (e : ∀ i, R i ≃+* S i) : (∀ i, R i) ≃+* ∀ i, S i :=
  { @MulEquiv.piCongrRight ι R S _ _ fun i => (e i).toMulEquiv,
    @AddEquiv.piCongrRight ι R S _ _ fun i =>
      (e i).toAddEquiv with
    toFun := fun x j => e j (x j)
    invFun := fun x j => (e j).symm (x j) }
#align ring_equiv.Pi_congr_right RingEquiv.piCongrRight

/- warning: ring_equiv.Pi_congr_right_refl -> RingEquiv.piCongrRight_refl is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : ι -> Type.{u2}} [_inst_3 : forall (i : ι), NonUnitalNonAssocSemiring.{u2} (R i)], Eq.{succ (max u1 u2)} (RingEquiv.{max u1 u2, max u1 u2} (forall (i : ι), R i) (forall (i : ι), R i) (Pi.instMul.{u1, u2} ι (fun (i : ι) => R i) (fun (i : ι) => Distrib.toHasMul.{u2} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (R i) (_inst_3 i)))) (Pi.instAdd.{u1, u2} ι (fun (i : ι) => R i) (fun (i : ι) => Distrib.toHasAdd.{u2} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (R i) (_inst_3 i)))) (Pi.instMul.{u1, u2} ι (fun (i : ι) => R i) (fun (i : ι) => Distrib.toHasMul.{u2} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (R i) (_inst_3 i)))) (Pi.instAdd.{u1, u2} ι (fun (i : ι) => R i) (fun (i : ι) => Distrib.toHasAdd.{u2} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (R i) (_inst_3 i))))) (RingEquiv.piCongrRight.{u1, u2, u2} ι (fun (i : ι) => R i) (fun (i : ι) => R i) (fun (i : ι) => _inst_3 i) (fun (i : ι) => _inst_3 i) (fun (i : ι) => RingEquiv.refl.{u2} (R i) (Distrib.toHasMul.{u2} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (R i) (_inst_3 i))) (Distrib.toHasAdd.{u2} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (R i) (_inst_3 i))))) (RingEquiv.refl.{max u1 u2} (forall (i : ι), R i) (Pi.instMul.{u1, u2} ι (fun (i : ι) => R i) (fun (i : ι) => Distrib.toHasMul.{u2} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (R i) (_inst_3 i)))) (Pi.instAdd.{u1, u2} ι (fun (i : ι) => R i) (fun (i : ι) => Distrib.toHasAdd.{u2} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (R i) (_inst_3 i)))))
but is expected to have type
  forall {ι : Type.{u2}} {R : ι -> Type.{u1}} [_inst_3 : forall (i : ι), NonUnitalNonAssocSemiring.{u1} (R i)], Eq.{max (succ u2) (succ u1)} (RingEquiv.{max u2 u1, max u2 u1} (forall (i : ι), R i) (forall (i : ι), R i) (Pi.instMul.{u2, u1} ι (fun (i : ι) => R i) (fun (i : ι) => NonUnitalNonAssocSemiring.toMul.{u1} (R i) (_inst_3 i))) (Pi.instMul.{u2, u1} ι (fun (i : ι) => R i) (fun (i : ι) => NonUnitalNonAssocSemiring.toMul.{u1} (R i) (_inst_3 i))) (Pi.instAdd.{u2, u1} ι (fun (i : ι) => R i) (fun (i : ι) => Distrib.toAdd.{u1} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u1} (R i) (_inst_3 i)))) (Pi.instAdd.{u2, u1} ι (fun (i : ι) => R i) (fun (i : ι) => Distrib.toAdd.{u1} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u1} (R i) (_inst_3 i))))) (RingEquiv.piCongrRight.{u2, u1, u1} ι (fun (i : ι) => R i) (fun (i : ι) => R i) (fun (i : ι) => _inst_3 i) (fun (i : ι) => _inst_3 i) (fun (i : ι) => RingEquiv.refl.{u1} (R i) (NonUnitalNonAssocSemiring.toMul.{u1} (R i) (_inst_3 i)) (Distrib.toAdd.{u1} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u1} (R i) (_inst_3 i))))) (RingEquiv.refl.{max u2 u1} (forall (i : ι), R i) (Pi.instMul.{u2, u1} ι (fun (i : ι) => R i) (fun (i : ι) => NonUnitalNonAssocSemiring.toMul.{u1} (R i) (_inst_3 i))) (Pi.instAdd.{u2, u1} ι (fun (i : ι) => R i) (fun (i : ι) => Distrib.toAdd.{u1} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u1} (R i) (_inst_3 i)))))
Case conversion may be inaccurate. Consider using '#align ring_equiv.Pi_congr_right_refl RingEquiv.piCongrRight_reflₓ'. -/
@[simp]
theorem piCongrRight_refl {ι : Type _} {R : ι → Type _} [∀ i, NonUnitalNonAssocSemiring (R i)] :
    (piCongrRight fun i => RingEquiv.refl (R i)) = RingEquiv.refl _ :=
  rfl
#align ring_equiv.Pi_congr_right_refl RingEquiv.piCongrRight_refl

/- warning: ring_equiv.Pi_congr_right_symm -> RingEquiv.piCongrRight_symm is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : ι -> Type.{u2}} {S : ι -> Type.{u3}} [_inst_3 : forall (i : ι), NonUnitalNonAssocSemiring.{u2} (R i)] [_inst_4 : forall (i : ι), NonUnitalNonAssocSemiring.{u3} (S i)] (e : forall (i : ι), RingEquiv.{u2, u3} (R i) (S i) (Distrib.toHasMul.{u2} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (R i) (_inst_3 i))) (Distrib.toHasAdd.{u2} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (R i) (_inst_3 i))) (Distrib.toHasMul.{u3} (S i) (NonUnitalNonAssocSemiring.toDistrib.{u3} (S i) (_inst_4 i))) (Distrib.toHasAdd.{u3} (S i) (NonUnitalNonAssocSemiring.toDistrib.{u3} (S i) (_inst_4 i)))), Eq.{max (succ (max u1 u3)) (succ (max u1 u2))} (RingEquiv.{max u1 u3, max u1 u2} (forall (i : ι), S i) (forall (i : ι), R i) (Pi.instMul.{u1, u3} ι (fun (i : ι) => S i) (fun (i : ι) => Distrib.toHasMul.{u3} (S i) (NonUnitalNonAssocSemiring.toDistrib.{u3} (S i) (_inst_4 i)))) (Pi.instAdd.{u1, u3} ι (fun (i : ι) => S i) (fun (i : ι) => Distrib.toHasAdd.{u3} (S i) (NonUnitalNonAssocSemiring.toDistrib.{u3} (S i) (_inst_4 i)))) (Pi.instMul.{u1, u2} ι (fun (i : ι) => R i) (fun (i : ι) => Distrib.toHasMul.{u2} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (R i) (_inst_3 i)))) (Pi.instAdd.{u1, u2} ι (fun (i : ι) => R i) (fun (i : ι) => Distrib.toHasAdd.{u2} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (R i) (_inst_3 i))))) (RingEquiv.symm.{max u1 u2, max u1 u3} (forall (i : ι), R i) (forall (i : ι), S i) (Pi.instMul.{u1, u2} ι (fun (i : ι) => R i) (fun (i : ι) => Distrib.toHasMul.{u2} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (R i) (_inst_3 i)))) (Pi.instAdd.{u1, u2} ι (fun (i : ι) => R i) (fun (i : ι) => Distrib.toHasAdd.{u2} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (R i) (_inst_3 i)))) (Pi.instMul.{u1, u3} ι (fun (i : ι) => S i) (fun (i : ι) => Distrib.toHasMul.{u3} (S i) (NonUnitalNonAssocSemiring.toDistrib.{u3} (S i) (_inst_4 i)))) (Pi.instAdd.{u1, u3} ι (fun (i : ι) => S i) (fun (i : ι) => Distrib.toHasAdd.{u3} (S i) (NonUnitalNonAssocSemiring.toDistrib.{u3} (S i) (_inst_4 i)))) (RingEquiv.piCongrRight.{u1, u2, u3} ι (fun (i : ι) => R i) (fun (i : ι) => S i) (fun (i : ι) => _inst_3 i) (fun (i : ι) => _inst_4 i) e)) (RingEquiv.piCongrRight.{u1, u3, u2} ι (fun (i : ι) => S i) (fun (i : ι) => R i) (fun (i : ι) => _inst_4 i) (fun (i : ι) => _inst_3 i) (fun (i : ι) => RingEquiv.symm.{u2, u3} (R i) (S i) (Distrib.toHasMul.{u2} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (R i) (_inst_3 i))) (Distrib.toHasAdd.{u2} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (R i) (_inst_3 i))) (Distrib.toHasMul.{u3} (S i) (NonUnitalNonAssocSemiring.toDistrib.{u3} (S i) (_inst_4 i))) (Distrib.toHasAdd.{u3} (S i) (NonUnitalNonAssocSemiring.toDistrib.{u3} (S i) (_inst_4 i))) (e i)))
but is expected to have type
  forall {ι : Type.{u3}} {R : ι -> Type.{u2}} {S : ι -> Type.{u1}} [_inst_3 : forall (i : ι), NonUnitalNonAssocSemiring.{u2} (R i)] [_inst_4 : forall (i : ι), NonUnitalNonAssocSemiring.{u1} (S i)] (e : forall (i : ι), RingEquiv.{u2, u1} (R i) (S i) (NonUnitalNonAssocSemiring.toMul.{u2} (R i) (_inst_3 i)) (NonUnitalNonAssocSemiring.toMul.{u1} (S i) (_inst_4 i)) (Distrib.toAdd.{u2} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (R i) (_inst_3 i))) (Distrib.toAdd.{u1} (S i) (NonUnitalNonAssocSemiring.toDistrib.{u1} (S i) (_inst_4 i)))), Eq.{max (max (succ u3) (succ u2)) (succ u1)} (RingEquiv.{max u3 u1, max u3 u2} (forall (i : ι), S i) (forall (i : ι), R i) (Pi.instMul.{u3, u1} ι (fun (i : ι) => S i) (fun (i : ι) => NonUnitalNonAssocSemiring.toMul.{u1} (S i) (_inst_4 i))) (Pi.instMul.{u3, u2} ι (fun (i : ι) => R i) (fun (i : ι) => NonUnitalNonAssocSemiring.toMul.{u2} (R i) (_inst_3 i))) (Pi.instAdd.{u3, u1} ι (fun (i : ι) => S i) (fun (i : ι) => Distrib.toAdd.{u1} (S i) (NonUnitalNonAssocSemiring.toDistrib.{u1} (S i) (_inst_4 i)))) (Pi.instAdd.{u3, u2} ι (fun (i : ι) => R i) (fun (i : ι) => Distrib.toAdd.{u2} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (R i) (_inst_3 i))))) (RingEquiv.symm.{max u3 u2, max u3 u1} (forall (i : ι), R i) (forall (i : ι), S i) (Pi.instMul.{u3, u2} ι (fun (i : ι) => R i) (fun (i : ι) => NonUnitalNonAssocSemiring.toMul.{u2} (R i) (_inst_3 i))) (Pi.instMul.{u3, u1} ι (fun (i : ι) => S i) (fun (i : ι) => NonUnitalNonAssocSemiring.toMul.{u1} (S i) (_inst_4 i))) (Pi.instAdd.{u3, u2} ι (fun (i : ι) => R i) (fun (i : ι) => Distrib.toAdd.{u2} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (R i) (_inst_3 i)))) (Pi.instAdd.{u3, u1} ι (fun (i : ι) => S i) (fun (i : ι) => Distrib.toAdd.{u1} (S i) (NonUnitalNonAssocSemiring.toDistrib.{u1} (S i) (_inst_4 i)))) (RingEquiv.piCongrRight.{u3, u2, u1} ι (fun (i : ι) => R i) (fun (i : ι) => S i) (fun (i : ι) => _inst_3 i) (fun (i : ι) => _inst_4 i) e)) (RingEquiv.piCongrRight.{u3, u1, u2} ι (fun (i : ι) => S i) (fun (i : ι) => R i) (fun (i : ι) => _inst_4 i) (fun (i : ι) => _inst_3 i) (fun (i : ι) => RingEquiv.symm.{u2, u1} (R i) (S i) (NonUnitalNonAssocSemiring.toMul.{u2} (R i) (_inst_3 i)) (NonUnitalNonAssocSemiring.toMul.{u1} (S i) (_inst_4 i)) (Distrib.toAdd.{u2} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (R i) (_inst_3 i))) (Distrib.toAdd.{u1} (S i) (NonUnitalNonAssocSemiring.toDistrib.{u1} (S i) (_inst_4 i))) (e i)))
Case conversion may be inaccurate. Consider using '#align ring_equiv.Pi_congr_right_symm RingEquiv.piCongrRight_symmₓ'. -/
@[simp]
theorem piCongrRight_symm {ι : Type _} {R S : ι → Type _} [∀ i, NonUnitalNonAssocSemiring (R i)]
    [∀ i, NonUnitalNonAssocSemiring (S i)] (e : ∀ i, R i ≃+* S i) :
    (piCongrRight e).symm = Pi_congr_right fun i => (e i).symm :=
  rfl
#align ring_equiv.Pi_congr_right_symm RingEquiv.piCongrRight_symm

/- warning: ring_equiv.Pi_congr_right_trans -> RingEquiv.piCongrRight_trans is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : ι -> Type.{u2}} {S : ι -> Type.{u3}} {T : ι -> Type.{u4}} [_inst_3 : forall (i : ι), NonUnitalNonAssocSemiring.{u2} (R i)] [_inst_4 : forall (i : ι), NonUnitalNonAssocSemiring.{u3} (S i)] [_inst_5 : forall (i : ι), NonUnitalNonAssocSemiring.{u4} (T i)] (e : forall (i : ι), RingEquiv.{u2, u3} (R i) (S i) (Distrib.toHasMul.{u2} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (R i) (_inst_3 i))) (Distrib.toHasAdd.{u2} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (R i) (_inst_3 i))) (Distrib.toHasMul.{u3} (S i) (NonUnitalNonAssocSemiring.toDistrib.{u3} (S i) (_inst_4 i))) (Distrib.toHasAdd.{u3} (S i) (NonUnitalNonAssocSemiring.toDistrib.{u3} (S i) (_inst_4 i)))) (f : forall (i : ι), RingEquiv.{u3, u4} (S i) (T i) (Distrib.toHasMul.{u3} (S i) (NonUnitalNonAssocSemiring.toDistrib.{u3} (S i) (_inst_4 i))) (Distrib.toHasAdd.{u3} (S i) (NonUnitalNonAssocSemiring.toDistrib.{u3} (S i) (_inst_4 i))) (Distrib.toHasMul.{u4} (T i) (NonUnitalNonAssocSemiring.toDistrib.{u4} (T i) (_inst_5 i))) (Distrib.toHasAdd.{u4} (T i) (NonUnitalNonAssocSemiring.toDistrib.{u4} (T i) (_inst_5 i)))), Eq.{max (succ (max u1 u2)) (succ (max u1 u4))} (RingEquiv.{max u1 u2, max u1 u4} (forall (i : ι), R i) (forall (i : ι), T i) (Pi.instMul.{u1, u2} ι (fun (i : ι) => R i) (fun (i : ι) => Distrib.toHasMul.{u2} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (R i) (_inst_3 i)))) (Pi.instAdd.{u1, u2} ι (fun (i : ι) => R i) (fun (i : ι) => Distrib.toHasAdd.{u2} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (R i) (_inst_3 i)))) (Pi.instMul.{u1, u4} ι (fun (i : ι) => T i) (fun (i : ι) => Distrib.toHasMul.{u4} (T i) (NonUnitalNonAssocSemiring.toDistrib.{u4} (T i) (_inst_5 i)))) (Pi.instAdd.{u1, u4} ι (fun (i : ι) => T i) (fun (i : ι) => Distrib.toHasAdd.{u4} (T i) (NonUnitalNonAssocSemiring.toDistrib.{u4} (T i) (_inst_5 i))))) (RingEquiv.trans.{max u1 u2, max u1 u3, max u1 u4} (forall (i : ι), R i) (forall (i : ι), S i) (forall (i : ι), T i) (Pi.instMul.{u1, u2} ι (fun (i : ι) => R i) (fun (i : ι) => Distrib.toHasMul.{u2} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (R i) (_inst_3 i)))) (Pi.instAdd.{u1, u2} ι (fun (i : ι) => R i) (fun (i : ι) => Distrib.toHasAdd.{u2} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (R i) (_inst_3 i)))) (Pi.instMul.{u1, u3} ι (fun (i : ι) => S i) (fun (i : ι) => Distrib.toHasMul.{u3} (S i) (NonUnitalNonAssocSemiring.toDistrib.{u3} (S i) (_inst_4 i)))) (Pi.instAdd.{u1, u3} ι (fun (i : ι) => S i) (fun (i : ι) => Distrib.toHasAdd.{u3} (S i) (NonUnitalNonAssocSemiring.toDistrib.{u3} (S i) (_inst_4 i)))) (Pi.instMul.{u1, u4} ι (fun (i : ι) => T i) (fun (i : ι) => Distrib.toHasMul.{u4} (T i) (NonUnitalNonAssocSemiring.toDistrib.{u4} (T i) (_inst_5 i)))) (Pi.instAdd.{u1, u4} ι (fun (i : ι) => T i) (fun (i : ι) => Distrib.toHasAdd.{u4} (T i) (NonUnitalNonAssocSemiring.toDistrib.{u4} (T i) (_inst_5 i)))) (RingEquiv.piCongrRight.{u1, u2, u3} ι (fun (i : ι) => R i) (fun (i : ι) => S i) (fun (i : ι) => _inst_3 i) (fun (i : ι) => _inst_4 i) e) (RingEquiv.piCongrRight.{u1, u3, u4} ι (fun (i : ι) => S i) (fun (i : ι) => T i) (fun (i : ι) => _inst_4 i) (fun (i : ι) => _inst_5 i) f)) (RingEquiv.piCongrRight.{u1, u2, u4} ι (fun (i : ι) => R i) (fun (i : ι) => T i) (fun (i : ι) => _inst_3 i) (fun (i : ι) => _inst_5 i) (fun (i : ι) => RingEquiv.trans.{u2, u3, u4} (R i) (S i) (T i) (Distrib.toHasMul.{u2} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (R i) (_inst_3 i))) (Distrib.toHasAdd.{u2} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (R i) (_inst_3 i))) (Distrib.toHasMul.{u3} (S i) (NonUnitalNonAssocSemiring.toDistrib.{u3} (S i) (_inst_4 i))) (Distrib.toHasAdd.{u3} (S i) (NonUnitalNonAssocSemiring.toDistrib.{u3} (S i) (_inst_4 i))) (Distrib.toHasMul.{u4} (T i) (NonUnitalNonAssocSemiring.toDistrib.{u4} (T i) (_inst_5 i))) (Distrib.toHasAdd.{u4} (T i) (NonUnitalNonAssocSemiring.toDistrib.{u4} (T i) (_inst_5 i))) (e i) (f i)))
but is expected to have type
  forall {ι : Type.{u4}} {R : ι -> Type.{u3}} {S : ι -> Type.{u2}} {T : ι -> Type.{u1}} [_inst_3 : forall (i : ι), NonUnitalNonAssocSemiring.{u3} (R i)] [_inst_4 : forall (i : ι), NonUnitalNonAssocSemiring.{u2} (S i)] [_inst_5 : forall (i : ι), NonUnitalNonAssocSemiring.{u1} (T i)] (e : forall (i : ι), RingEquiv.{u3, u2} (R i) (S i) (NonUnitalNonAssocSemiring.toMul.{u3} (R i) (_inst_3 i)) (NonUnitalNonAssocSemiring.toMul.{u2} (S i) (_inst_4 i)) (Distrib.toAdd.{u3} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u3} (R i) (_inst_3 i))) (Distrib.toAdd.{u2} (S i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (S i) (_inst_4 i)))) (f : forall (i : ι), RingEquiv.{u2, u1} (S i) (T i) (NonUnitalNonAssocSemiring.toMul.{u2} (S i) (_inst_4 i)) (NonUnitalNonAssocSemiring.toMul.{u1} (T i) (_inst_5 i)) (Distrib.toAdd.{u2} (S i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (S i) (_inst_4 i))) (Distrib.toAdd.{u1} (T i) (NonUnitalNonAssocSemiring.toDistrib.{u1} (T i) (_inst_5 i)))), Eq.{max (max (succ u4) (succ u3)) (succ u1)} (RingEquiv.{max u4 u3, max u4 u1} (forall (i : ι), R i) (forall (i : ι), T i) (Pi.instMul.{u4, u3} ι (fun (i : ι) => R i) (fun (i : ι) => NonUnitalNonAssocSemiring.toMul.{u3} (R i) (_inst_3 i))) (Pi.instMul.{u4, u1} ι (fun (i : ι) => T i) (fun (i : ι) => NonUnitalNonAssocSemiring.toMul.{u1} (T i) (_inst_5 i))) (Pi.instAdd.{u4, u3} ι (fun (i : ι) => R i) (fun (i : ι) => Distrib.toAdd.{u3} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u3} (R i) (_inst_3 i)))) (Pi.instAdd.{u4, u1} ι (fun (i : ι) => T i) (fun (i : ι) => Distrib.toAdd.{u1} (T i) (NonUnitalNonAssocSemiring.toDistrib.{u1} (T i) (_inst_5 i))))) (RingEquiv.trans.{max u4 u3, max u4 u2, max u4 u1} (forall (i : ι), R i) (forall (i : ι), S i) (forall (i : ι), T i) (Pi.instMul.{u4, u3} ι (fun (i : ι) => R i) (fun (i : ι) => NonUnitalNonAssocSemiring.toMul.{u3} (R i) (_inst_3 i))) (Pi.instMul.{u4, u2} ι (fun (i : ι) => S i) (fun (i : ι) => NonUnitalNonAssocSemiring.toMul.{u2} (S i) (_inst_4 i))) (Pi.instAdd.{u4, u3} ι (fun (i : ι) => R i) (fun (i : ι) => Distrib.toAdd.{u3} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u3} (R i) (_inst_3 i)))) (Pi.instAdd.{u4, u2} ι (fun (i : ι) => S i) (fun (i : ι) => Distrib.toAdd.{u2} (S i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (S i) (_inst_4 i)))) (Pi.instMul.{u4, u1} ι (fun (i : ι) => T i) (fun (i : ι) => NonUnitalNonAssocSemiring.toMul.{u1} (T i) (_inst_5 i))) (Pi.instAdd.{u4, u1} ι (fun (i : ι) => T i) (fun (i : ι) => Distrib.toAdd.{u1} (T i) (NonUnitalNonAssocSemiring.toDistrib.{u1} (T i) (_inst_5 i)))) (RingEquiv.piCongrRight.{u4, u3, u2} ι (fun (i : ι) => R i) (fun (i : ι) => S i) (fun (i : ι) => _inst_3 i) (fun (i : ι) => _inst_4 i) e) (RingEquiv.piCongrRight.{u4, u2, u1} ι (fun (i : ι) => S i) (fun (i : ι) => T i) (fun (i : ι) => _inst_4 i) (fun (i : ι) => _inst_5 i) f)) (RingEquiv.piCongrRight.{u4, u3, u1} ι (fun (i : ι) => R i) (fun (i : ι) => T i) (fun (i : ι) => _inst_3 i) (fun (i : ι) => _inst_5 i) (fun (i : ι) => RingEquiv.trans.{u3, u2, u1} (R i) (S i) (T i) (NonUnitalNonAssocSemiring.toMul.{u3} (R i) (_inst_3 i)) (NonUnitalNonAssocSemiring.toMul.{u2} (S i) (_inst_4 i)) (Distrib.toAdd.{u3} (R i) (NonUnitalNonAssocSemiring.toDistrib.{u3} (R i) (_inst_3 i))) (Distrib.toAdd.{u2} (S i) (NonUnitalNonAssocSemiring.toDistrib.{u2} (S i) (_inst_4 i))) (NonUnitalNonAssocSemiring.toMul.{u1} (T i) (_inst_5 i)) (Distrib.toAdd.{u1} (T i) (NonUnitalNonAssocSemiring.toDistrib.{u1} (T i) (_inst_5 i))) (e i) (f i)))
Case conversion may be inaccurate. Consider using '#align ring_equiv.Pi_congr_right_trans RingEquiv.piCongrRight_transₓ'. -/
@[simp]
theorem piCongrRight_trans {ι : Type _} {R S T : ι → Type _} [∀ i, NonUnitalNonAssocSemiring (R i)]
    [∀ i, NonUnitalNonAssocSemiring (S i)] [∀ i, NonUnitalNonAssocSemiring (T i)]
    (e : ∀ i, R i ≃+* S i) (f : ∀ i, S i ≃+* T i) :
    (piCongrRight e).trans (piCongrRight f) = Pi_congr_right fun i => (e i).trans (f i) :=
  rfl
#align ring_equiv.Pi_congr_right_trans RingEquiv.piCongrRight_trans

end NonUnitalSemiring

section Semiring

variable [NonAssocSemiring R] [NonAssocSemiring S] (f : R ≃+* S) (x y : R)

/- warning: ring_equiv.map_one -> RingEquiv.map_one is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S] (f : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))), Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (fun (_x : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) f (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R _inst_1))))))) (OfNat.ofNat.{u2} S 1 (OfNat.mk.{u2} S 1 (One.one.{u2} S (AddMonoidWithOne.toOne.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S _inst_2))))))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S] (f : RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))), Eq.{succ u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocSemiring.toOne.{u1} R _inst_1)))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (EquivLike.toEmbeddingLike.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (MulEquivClass.toEquivLike.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (RingEquivClass.toMulEquivClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (RingEquiv.instRingEquivClassRingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))))))) f (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocSemiring.toOne.{u1} R _inst_1)))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocSemiring.toOne.{u1} R _inst_1)))) 1 (One.toOfNat1.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocSemiring.toOne.{u1} R _inst_1)))) (NonAssocSemiring.toOne.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocSemiring.toOne.{u1} R _inst_1)))) _inst_2)))
Case conversion may be inaccurate. Consider using '#align ring_equiv.map_one RingEquiv.map_oneₓ'. -/
/-- A ring isomorphism sends one to one. -/
protected theorem map_one : f 1 = 1 :=
  map_one f
#align ring_equiv.map_one RingEquiv.map_one

variable {x}

/- warning: ring_equiv.map_eq_one_iff -> RingEquiv.map_eq_one_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S] (f : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) {x : R}, Iff (Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (fun (_x : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) f x) (OfNat.ofNat.{u2} S 1 (OfNat.mk.{u2} S 1 (One.one.{u2} S (AddMonoidWithOne.toOne.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S _inst_2))))))) (Eq.{succ u1} R x (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R _inst_1)))))))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S] (f : RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) {x : R}, Iff (Eq.{succ u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (EquivLike.toEmbeddingLike.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (MulEquivClass.toEquivLike.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (RingEquivClass.toMulEquivClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (RingEquiv.instRingEquivClassRingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))))))) f x) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) 1 (One.toOfNat1.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) (NonAssocSemiring.toOne.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) _inst_2)))) (Eq.{succ u1} R x (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocSemiring.toOne.{u1} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align ring_equiv.map_eq_one_iff RingEquiv.map_eq_one_iffₓ'. -/
protected theorem map_eq_one_iff : f x = 1 ↔ x = 1 :=
  MulEquivClass.map_eq_one_iff f
#align ring_equiv.map_eq_one_iff RingEquiv.map_eq_one_iff

/- warning: ring_equiv.map_ne_one_iff -> RingEquiv.map_ne_one_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S] (f : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) {x : R}, Iff (Ne.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (fun (_x : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) f x) (OfNat.ofNat.{u2} S 1 (OfNat.mk.{u2} S 1 (One.one.{u2} S (AddMonoidWithOne.toOne.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S _inst_2))))))) (Ne.{succ u1} R x (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R _inst_1)))))))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S] (f : RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) {x : R}, Iff (Ne.{succ u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (EquivLike.toEmbeddingLike.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (MulEquivClass.toEquivLike.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (RingEquivClass.toMulEquivClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (RingEquiv.instRingEquivClassRingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))))))) f x) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) 1 (One.toOfNat1.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) (NonAssocSemiring.toOne.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) _inst_2)))) (Ne.{succ u1} R x (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocSemiring.toOne.{u1} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align ring_equiv.map_ne_one_iff RingEquiv.map_ne_one_iffₓ'. -/
theorem map_ne_one_iff : f x ≠ 1 ↔ x ≠ 1 :=
  MulEquivClass.map_ne_one_iff f
#align ring_equiv.map_ne_one_iff RingEquiv.map_ne_one_iff

/- warning: ring_equiv.coe_monoid_hom_refl -> RingEquiv.coe_monoidHom_refl is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonAssocSemiring.{u1} R], Eq.{succ u1} (MonoidHom.{u1, u1} R R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (RingEquiv.{u1, u1} R R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (MonoidHom.{u1, u1} R R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1))) (HasLiftT.mk.{succ u1, succ u1} (RingEquiv.{u1, u1} R R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (MonoidHom.{u1, u1} R R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1))) (CoeTCₓ.coe.{succ u1, succ u1} (RingEquiv.{u1, u1} R R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (MonoidHom.{u1, u1} R R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1))) (MonoidHom.hasCoeT.{u1, u1, u1} R R (RingEquiv.{u1, u1} R R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (RingHomClass.toMonoidHomClass.{u1, u1, u1} (RingEquiv.{u1, u1} R R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) R R _inst_1 _inst_1 (RingEquivClass.toRingHomClass.{u1, u1, u1} (RingEquiv.{u1, u1} R R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) R R _inst_1 _inst_1 (RingEquiv.ringEquivClass.{u1, u1} R R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))))))))) (RingEquiv.refl.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))))) (MonoidHom.id.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonAssocSemiring.{u1} R], Eq.{succ u1} (MonoidHom.{u1, u1} R R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1))) (MonoidHomClass.toMonoidHom.{u1, u1, u1} R R (RingEquiv.{u1, u1} R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (RingHomClass.toMonoidHomClass.{u1, u1, u1} (RingEquiv.{u1, u1} R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) R R _inst_1 _inst_1 (RingEquivClass.toRingHomClass.{u1, u1, u1} (RingEquiv.{u1, u1} R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) R R _inst_1 _inst_1 (RingEquiv.instRingEquivClassRingEquiv.{u1, u1} R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))))) (RingEquiv.refl.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))))) (MonoidHom.id.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)))
Case conversion may be inaccurate. Consider using '#align ring_equiv.coe_monoid_hom_refl RingEquiv.coe_monoidHom_reflₓ'. -/
theorem coe_monoidHom_refl : (RingEquiv.refl R : R →* R) = MonoidHom.id R :=
  rfl
#align ring_equiv.coe_monoid_hom_refl RingEquiv.coe_monoidHom_refl

/- warning: ring_equiv.coe_add_monoid_hom_refl -> RingEquiv.coe_addMonoidHom_refl is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonAssocSemiring.{u1} R], Eq.{succ u1} (AddMonoidHom.{u1, u1} R R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R _inst_1)))) (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R _inst_1))))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (RingEquiv.{u1, u1} R R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (AddMonoidHom.{u1, u1} R R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R _inst_1)))) (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R _inst_1))))) (HasLiftT.mk.{succ u1, succ u1} (RingEquiv.{u1, u1} R R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (AddMonoidHom.{u1, u1} R R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R _inst_1)))) (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R _inst_1))))) (CoeTCₓ.coe.{succ u1, succ u1} (RingEquiv.{u1, u1} R R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (AddMonoidHom.{u1, u1} R R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R _inst_1)))) (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R _inst_1))))) (AddMonoidHom.hasCoeT.{u1, u1, u1} R R (RingEquiv.{u1, u1} R R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R _inst_1)))) (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R _inst_1)))) (RingHomClass.toAddMonoidHomClass.{u1, u1, u1} (RingEquiv.{u1, u1} R R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) R R _inst_1 _inst_1 (RingEquivClass.toRingHomClass.{u1, u1, u1} (RingEquiv.{u1, u1} R R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) R R _inst_1 _inst_1 (RingEquiv.ringEquivClass.{u1, u1} R R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))))))))) (RingEquiv.refl.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))))) (AddMonoidHom.id.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R _inst_1)))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonAssocSemiring.{u1} R], Eq.{succ u1} (AddMonoidHom.{u1, u1} R R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R _inst_1)))) (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R _inst_1))))) (AddMonoidHomClass.toAddMonoidHom.{u1, u1, u1} R R (RingEquiv.{u1, u1} R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R _inst_1)))) (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R _inst_1)))) (RingHomClass.toAddMonoidHomClass.{u1, u1, u1} (RingEquiv.{u1, u1} R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) R R _inst_1 _inst_1 (RingEquivClass.toRingHomClass.{u1, u1, u1} (RingEquiv.{u1, u1} R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) R R _inst_1 _inst_1 (RingEquiv.instRingEquivClassRingEquiv.{u1, u1} R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))))) (RingEquiv.refl.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))))) (AddMonoidHom.id.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align ring_equiv.coe_add_monoid_hom_refl RingEquiv.coe_addMonoidHom_reflₓ'. -/
@[simp]
theorem coe_addMonoidHom_refl : (RingEquiv.refl R : R →+ R) = AddMonoidHom.id R :=
  rfl
#align ring_equiv.coe_add_monoid_hom_refl RingEquiv.coe_addMonoidHom_refl

/-! `ring_equiv.coe_mul_equiv_refl` and `ring_equiv.coe_add_equiv_refl` are proved above
in higher generality -/


/- warning: ring_equiv.coe_ring_hom_refl -> RingEquiv.coe_ringHom_refl is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonAssocSemiring.{u1} R], Eq.{succ u1} (MonoidHom.{u1, u1} R R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (RingEquiv.{u1, u1} R R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (MonoidHom.{u1, u1} R R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1))) (HasLiftT.mk.{succ u1, succ u1} (RingEquiv.{u1, u1} R R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (MonoidHom.{u1, u1} R R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1))) (CoeTCₓ.coe.{succ u1, succ u1} (RingEquiv.{u1, u1} R R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (MonoidHom.{u1, u1} R R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1))) (MonoidHom.hasCoeT.{u1, u1, u1} R R (RingEquiv.{u1, u1} R R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (RingHomClass.toMonoidHomClass.{u1, u1, u1} (RingEquiv.{u1, u1} R R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) R R _inst_1 _inst_1 (RingEquivClass.toRingHomClass.{u1, u1, u1} (RingEquiv.{u1, u1} R R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) R R _inst_1 _inst_1 (RingEquiv.ringEquivClass.{u1, u1} R R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))))))))) (RingEquiv.refl.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (RingHom.{u1, u1} R R _inst_1 _inst_1) (MonoidHom.{u1, u1} R R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1))) (HasLiftT.mk.{succ u1, succ u1} (RingHom.{u1, u1} R R _inst_1 _inst_1) (MonoidHom.{u1, u1} R R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1))) (CoeTCₓ.coe.{succ u1, succ u1} (RingHom.{u1, u1} R R _inst_1 _inst_1) (MonoidHom.{u1, u1} R R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1))) (MonoidHom.hasCoeT.{u1, u1, u1} R R (RingHom.{u1, u1} R R _inst_1 _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (RingHomClass.toMonoidHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R _inst_1 _inst_1) R R _inst_1 _inst_1 (RingHom.ringHomClass.{u1, u1} R R _inst_1 _inst_1))))) (RingHom.id.{u1} R _inst_1))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonAssocSemiring.{u1} R], Eq.{succ u1} (MonoidHom.{u1, u1} R R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1))) (MonoidHomClass.toMonoidHom.{u1, u1, u1} R R (RingEquiv.{u1, u1} R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (RingHomClass.toMonoidHomClass.{u1, u1, u1} (RingEquiv.{u1, u1} R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) R R _inst_1 _inst_1 (RingEquivClass.toRingHomClass.{u1, u1, u1} (RingEquiv.{u1, u1} R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) R R _inst_1 _inst_1 (RingEquiv.instRingEquivClassRingEquiv.{u1, u1} R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))))) (RingEquiv.refl.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))))) (MonoidHomClass.toMonoidHom.{u1, u1, u1} R R (RingHom.{u1, u1} R R _inst_1 _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (RingHomClass.toMonoidHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R _inst_1 _inst_1) R R _inst_1 _inst_1 (RingHom.instRingHomClassRingHom.{u1, u1} R R _inst_1 _inst_1)) (RingHom.id.{u1} R _inst_1))
Case conversion may be inaccurate. Consider using '#align ring_equiv.coe_ring_hom_refl RingEquiv.coe_ringHom_reflₓ'. -/
@[simp]
theorem coe_ringHom_refl : (RingEquiv.refl R : R →* R) = RingHom.id R :=
  rfl
#align ring_equiv.coe_ring_hom_refl RingEquiv.coe_ringHom_refl

/- warning: ring_equiv.coe_monoid_hom_trans -> RingEquiv.coe_monoidHom_trans is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {S' : Type.{u3}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S] [_inst_3 : NonAssocSemiring.{u3} S'] (e₁ : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (e₂ : RingEquiv.{u2, u3} S S' (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))), Eq.{max (succ u3) (succ u1)} (MonoidHom.{u1, u3} R S' (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u3} S' (NonAssocSemiring.toMulZeroOneClass.{u3} S' _inst_3))) ((fun (a : Sort.{max (succ u1) (succ u3)}) (b : Sort.{max (succ u3) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u3), max (succ u3) (succ u1)} a b] => self.0) (RingEquiv.{u1, u3} R S' (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) (MonoidHom.{u1, u3} R S' (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u3} S' (NonAssocSemiring.toMulZeroOneClass.{u3} S' _inst_3))) (HasLiftT.mk.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (RingEquiv.{u1, u3} R S' (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) (MonoidHom.{u1, u3} R S' (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u3} S' (NonAssocSemiring.toMulZeroOneClass.{u3} S' _inst_3))) (CoeTCₓ.coe.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (RingEquiv.{u1, u3} R S' (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) (MonoidHom.{u1, u3} R S' (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u3} S' (NonAssocSemiring.toMulZeroOneClass.{u3} S' _inst_3))) (MonoidHom.hasCoeT.{u1, u3, max u1 u3} R S' (RingEquiv.{u1, u3} R S' (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u3} S' (NonAssocSemiring.toMulZeroOneClass.{u3} S' _inst_3)) (RingHomClass.toMonoidHomClass.{max u1 u3, u1, u3} (RingEquiv.{u1, u3} R S' (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) R S' _inst_1 _inst_3 (RingEquivClass.toRingHomClass.{max u1 u3, u1, u3} (RingEquiv.{u1, u3} R S' (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) R S' _inst_1 _inst_3 (RingEquiv.ringEquivClass.{u1, u3} R S' (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))))))))) (RingEquiv.trans.{u1, u2, u3} R S S' (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) e₁ e₂)) (MonoidHom.comp.{u1, u2, u3} R S S' (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S _inst_2)) (MulZeroOneClass.toMulOneClass.{u3} S' (NonAssocSemiring.toMulZeroOneClass.{u3} S' _inst_3)) ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u3) (succ u2)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u3) (succ u2)} a b] => self.0) (RingEquiv.{u2, u3} S S' (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) (MonoidHom.{u2, u3} S S' (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S _inst_2)) (MulZeroOneClass.toMulOneClass.{u3} S' (NonAssocSemiring.toMulZeroOneClass.{u3} S' _inst_3))) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (RingEquiv.{u2, u3} S S' (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) (MonoidHom.{u2, u3} S S' (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S _inst_2)) (MulZeroOneClass.toMulOneClass.{u3} S' (NonAssocSemiring.toMulZeroOneClass.{u3} S' _inst_3))) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (RingEquiv.{u2, u3} S S' (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) (MonoidHom.{u2, u3} S S' (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S _inst_2)) (MulZeroOneClass.toMulOneClass.{u3} S' (NonAssocSemiring.toMulZeroOneClass.{u3} S' _inst_3))) (MonoidHom.hasCoeT.{u2, u3, max u2 u3} S S' (RingEquiv.{u2, u3} S S' (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S _inst_2)) (MulZeroOneClass.toMulOneClass.{u3} S' (NonAssocSemiring.toMulZeroOneClass.{u3} S' _inst_3)) (RingHomClass.toMonoidHomClass.{max u2 u3, u2, u3} (RingEquiv.{u2, u3} S S' (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) S S' _inst_2 _inst_3 (RingEquivClass.toRingHomClass.{max u2 u3, u2, u3} (RingEquiv.{u2, u3} S S' (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) S S' _inst_2 _inst_3 (RingEquiv.ringEquivClass.{u2, u3} S S' (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))))))))) e₂) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (MonoidHom.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S _inst_2))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (MonoidHom.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S _inst_2))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (MonoidHom.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S _inst_2))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} R S (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S _inst_2)) (RingHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S _inst_1 _inst_2 (RingEquivClass.toRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S _inst_1 _inst_2 (RingEquiv.ringEquivClass.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))))))))) e₁))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {S' : Type.{u3}} [_inst_1 : NonAssocSemiring.{u2} R] [_inst_2 : NonAssocSemiring.{u1} S] [_inst_3 : NonAssocSemiring.{u3} S'] (e₁ : RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) (e₂ : RingEquiv.{u1, u3} S S' (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))), Eq.{max (succ u2) (succ u3)} (MonoidHom.{u2, u3} R S' (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u3} S' (NonAssocSemiring.toMulZeroOneClass.{u3} S' _inst_3))) (MonoidHomClass.toMonoidHom.{u2, u3, max u2 u3} R S' (RingEquiv.{u2, u3} R S' (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u3} S' (NonAssocSemiring.toMulZeroOneClass.{u3} S' _inst_3)) (RingHomClass.toMonoidHomClass.{max u2 u3, u2, u3} (RingEquiv.{u2, u3} R S' (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) R S' _inst_1 _inst_3 (RingEquivClass.toRingHomClass.{max u2 u3, u2, u3} (RingEquiv.{u2, u3} R S' (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) R S' _inst_1 _inst_3 (RingEquiv.instRingEquivClassRingEquiv.{u2, u3} R S' (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))))) (RingEquiv.trans.{u2, u1, u3} R S S' (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)) (Distrib.toAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) e₁ e₂)) (MonoidHom.comp.{u2, u1, u3} R S S' (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u1} S (NonAssocSemiring.toMulZeroOneClass.{u1} S _inst_2)) (MulZeroOneClass.toMulOneClass.{u3} S' (NonAssocSemiring.toMulZeroOneClass.{u3} S' _inst_3)) (MonoidHomClass.toMonoidHom.{u1, u3, max u1 u3} S S' (RingEquiv.{u1, u3} S S' (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) (MulZeroOneClass.toMulOneClass.{u1} S (NonAssocSemiring.toMulZeroOneClass.{u1} S _inst_2)) (MulZeroOneClass.toMulOneClass.{u3} S' (NonAssocSemiring.toMulZeroOneClass.{u3} S' _inst_3)) (RingHomClass.toMonoidHomClass.{max u1 u3, u1, u3} (RingEquiv.{u1, u3} S S' (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) S S' _inst_2 _inst_3 (RingEquivClass.toRingHomClass.{max u1 u3, u1, u3} (RingEquiv.{u1, u3} S S' (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) S S' _inst_2 _inst_3 (RingEquiv.instRingEquivClassRingEquiv.{u1, u3} S S' (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))))) e₂) (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} R S (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u1} S (NonAssocSemiring.toMulZeroOneClass.{u1} S _inst_2)) (RingHomClass.toMonoidHomClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R S _inst_1 _inst_2 (RingEquivClass.toRingHomClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R S _inst_1 _inst_2 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))))) e₁))
Case conversion may be inaccurate. Consider using '#align ring_equiv.coe_monoid_hom_trans RingEquiv.coe_monoidHom_transₓ'. -/
@[simp]
theorem coe_monoidHom_trans [NonAssocSemiring S'] (e₁ : R ≃+* S) (e₂ : S ≃+* S') :
    (e₁.trans e₂ : R →* S') = (e₂ : S →* S').comp ↑e₁ :=
  rfl
#align ring_equiv.coe_monoid_hom_trans RingEquiv.coe_monoidHom_trans

/- warning: ring_equiv.coe_add_monoid_hom_trans -> RingEquiv.coe_addMonoidHom_trans is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {S' : Type.{u3}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S] [_inst_3 : NonAssocSemiring.{u3} S'] (e₁ : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (e₂ : RingEquiv.{u2, u3} S S' (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))), Eq.{max (succ u3) (succ u1)} (AddMonoidHom.{u1, u3} R S' (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R _inst_1)))) (AddMonoid.toAddZeroClass.{u3} S' (AddMonoidWithOne.toAddMonoid.{u3} S' (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S' (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S' _inst_3))))) ((fun (a : Sort.{max (succ u1) (succ u3)}) (b : Sort.{max (succ u3) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u3), max (succ u3) (succ u1)} a b] => self.0) (RingEquiv.{u1, u3} R S' (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) (AddMonoidHom.{u1, u3} R S' (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R _inst_1)))) (AddMonoid.toAddZeroClass.{u3} S' (AddMonoidWithOne.toAddMonoid.{u3} S' (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S' (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S' _inst_3))))) (HasLiftT.mk.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (RingEquiv.{u1, u3} R S' (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) (AddMonoidHom.{u1, u3} R S' (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R _inst_1)))) (AddMonoid.toAddZeroClass.{u3} S' (AddMonoidWithOne.toAddMonoid.{u3} S' (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S' (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S' _inst_3))))) (CoeTCₓ.coe.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (RingEquiv.{u1, u3} R S' (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) (AddMonoidHom.{u1, u3} R S' (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R _inst_1)))) (AddMonoid.toAddZeroClass.{u3} S' (AddMonoidWithOne.toAddMonoid.{u3} S' (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S' (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S' _inst_3))))) (AddMonoidHom.hasCoeT.{u1, u3, max u1 u3} R S' (RingEquiv.{u1, u3} R S' (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R _inst_1)))) (AddMonoid.toAddZeroClass.{u3} S' (AddMonoidWithOne.toAddMonoid.{u3} S' (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S' (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S' _inst_3)))) (RingHomClass.toAddMonoidHomClass.{max u1 u3, u1, u3} (RingEquiv.{u1, u3} R S' (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) R S' _inst_1 _inst_3 (RingEquivClass.toRingHomClass.{max u1 u3, u1, u3} (RingEquiv.{u1, u3} R S' (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) R S' _inst_1 _inst_3 (RingEquiv.ringEquivClass.{u1, u3} R S' (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))))))))) (RingEquiv.trans.{u1, u2, u3} R S S' (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) e₁ e₂)) (AddMonoidHom.comp.{u1, u2, u3} R S S' (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R _inst_1)))) (AddMonoid.toAddZeroClass.{u2} S (AddMonoidWithOne.toAddMonoid.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S _inst_2)))) (AddMonoid.toAddZeroClass.{u3} S' (AddMonoidWithOne.toAddMonoid.{u3} S' (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S' (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S' _inst_3)))) ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u3) (succ u2)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u3) (succ u2)} a b] => self.0) (RingEquiv.{u2, u3} S S' (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) (AddMonoidHom.{u2, u3} S S' (AddMonoid.toAddZeroClass.{u2} S (AddMonoidWithOne.toAddMonoid.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S _inst_2)))) (AddMonoid.toAddZeroClass.{u3} S' (AddMonoidWithOne.toAddMonoid.{u3} S' (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S' (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S' _inst_3))))) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (RingEquiv.{u2, u3} S S' (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) (AddMonoidHom.{u2, u3} S S' (AddMonoid.toAddZeroClass.{u2} S (AddMonoidWithOne.toAddMonoid.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S _inst_2)))) (AddMonoid.toAddZeroClass.{u3} S' (AddMonoidWithOne.toAddMonoid.{u3} S' (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S' (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S' _inst_3))))) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (RingEquiv.{u2, u3} S S' (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) (AddMonoidHom.{u2, u3} S S' (AddMonoid.toAddZeroClass.{u2} S (AddMonoidWithOne.toAddMonoid.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S _inst_2)))) (AddMonoid.toAddZeroClass.{u3} S' (AddMonoidWithOne.toAddMonoid.{u3} S' (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S' (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S' _inst_3))))) (AddMonoidHom.hasCoeT.{u2, u3, max u2 u3} S S' (RingEquiv.{u2, u3} S S' (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) (AddMonoid.toAddZeroClass.{u2} S (AddMonoidWithOne.toAddMonoid.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S _inst_2)))) (AddMonoid.toAddZeroClass.{u3} S' (AddMonoidWithOne.toAddMonoid.{u3} S' (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S' (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S' _inst_3)))) (RingHomClass.toAddMonoidHomClass.{max u2 u3, u2, u3} (RingEquiv.{u2, u3} S S' (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) S S' _inst_2 _inst_3 (RingEquivClass.toRingHomClass.{max u2 u3, u2, u3} (RingEquiv.{u2, u3} S S' (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) S S' _inst_2 _inst_3 (RingEquiv.ringEquivClass.{u2, u3} S S' (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))))))))) e₂) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (AddMonoidHom.{u1, u2} R S (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R _inst_1)))) (AddMonoid.toAddZeroClass.{u2} S (AddMonoidWithOne.toAddMonoid.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S _inst_2))))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (AddMonoidHom.{u1, u2} R S (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R _inst_1)))) (AddMonoid.toAddZeroClass.{u2} S (AddMonoidWithOne.toAddMonoid.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S _inst_2))))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (AddMonoidHom.{u1, u2} R S (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R _inst_1)))) (AddMonoid.toAddZeroClass.{u2} S (AddMonoidWithOne.toAddMonoid.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S _inst_2))))) (AddMonoidHom.hasCoeT.{u1, u2, max u1 u2} R S (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R _inst_1)))) (AddMonoid.toAddZeroClass.{u2} S (AddMonoidWithOne.toAddMonoid.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S _inst_2)))) (RingHomClass.toAddMonoidHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S _inst_1 _inst_2 (RingEquivClass.toRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S _inst_1 _inst_2 (RingEquiv.ringEquivClass.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))))))))) e₁))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {S' : Type.{u3}} [_inst_1 : NonAssocSemiring.{u2} R] [_inst_2 : NonAssocSemiring.{u1} S] [_inst_3 : NonAssocSemiring.{u3} S'] (e₁ : RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) (e₂ : RingEquiv.{u1, u3} S S' (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))), Eq.{max (succ u2) (succ u3)} (AddMonoidHom.{u2, u3} R S' (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R _inst_1)))) (AddMonoid.toAddZeroClass.{u3} S' (AddMonoidWithOne.toAddMonoid.{u3} S' (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S' (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S' _inst_3))))) (AddMonoidHomClass.toAddMonoidHom.{u2, u3, max u2 u3} R S' (RingEquiv.{u2, u3} R S' (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R _inst_1)))) (AddMonoid.toAddZeroClass.{u3} S' (AddMonoidWithOne.toAddMonoid.{u3} S' (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S' (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S' _inst_3)))) (RingHomClass.toAddMonoidHomClass.{max u2 u3, u2, u3} (RingEquiv.{u2, u3} R S' (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) R S' _inst_1 _inst_3 (RingEquivClass.toRingHomClass.{max u2 u3, u2, u3} (RingEquiv.{u2, u3} R S' (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) R S' _inst_1 _inst_3 (RingEquiv.instRingEquivClassRingEquiv.{u2, u3} R S' (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))))) (RingEquiv.trans.{u2, u1, u3} R S S' (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)) (Distrib.toAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) e₁ e₂)) (AddMonoidHom.comp.{u2, u1, u3} R S S' (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R _inst_1)))) (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S _inst_2)))) (AddMonoid.toAddZeroClass.{u3} S' (AddMonoidWithOne.toAddMonoid.{u3} S' (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S' (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S' _inst_3)))) (AddMonoidHomClass.toAddMonoidHom.{u1, u3, max u1 u3} S S' (RingEquiv.{u1, u3} S S' (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S _inst_2)))) (AddMonoid.toAddZeroClass.{u3} S' (AddMonoidWithOne.toAddMonoid.{u3} S' (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S' (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S' _inst_3)))) (RingHomClass.toAddMonoidHomClass.{max u1 u3, u1, u3} (RingEquiv.{u1, u3} S S' (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) S S' _inst_2 _inst_3 (RingEquivClass.toRingHomClass.{max u1 u3, u1, u3} (RingEquiv.{u1, u3} S S' (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) S S' _inst_2 _inst_3 (RingEquiv.instRingEquivClassRingEquiv.{u1, u3} S S' (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))))) e₂) (AddMonoidHomClass.toAddMonoidHom.{u2, u1, max u2 u1} R S (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R _inst_1)))) (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S _inst_2)))) (RingHomClass.toAddMonoidHomClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R S _inst_1 _inst_2 (RingEquivClass.toRingHomClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R S _inst_1 _inst_2 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))))) e₁))
Case conversion may be inaccurate. Consider using '#align ring_equiv.coe_add_monoid_hom_trans RingEquiv.coe_addMonoidHom_transₓ'. -/
@[simp]
theorem coe_addMonoidHom_trans [NonAssocSemiring S'] (e₁ : R ≃+* S) (e₂ : S ≃+* S') :
    (e₁.trans e₂ : R →+ S') = (e₂ : S →+ S').comp ↑e₁ :=
  rfl
#align ring_equiv.coe_add_monoid_hom_trans RingEquiv.coe_addMonoidHom_trans

/-! `ring_equiv.coe_mul_equiv_trans` and `ring_equiv.coe_add_equiv_trans` are proved above
in higher generality -/


/- warning: ring_equiv.coe_ring_hom_trans -> RingEquiv.coe_ringHom_trans is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {S' : Type.{u3}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S] [_inst_3 : NonAssocSemiring.{u3} S'] (e₁ : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (e₂ : RingEquiv.{u2, u3} S S' (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))), Eq.{max (succ u1) (succ u3)} (RingHom.{u1, u3} R S' _inst_1 _inst_3) ((fun (a : Sort.{max (succ u1) (succ u3)}) (b : Sort.{max (succ u1) (succ u3)}) [self : HasLiftT.{max (succ u1) (succ u3), max (succ u1) (succ u3)} a b] => self.0) (RingEquiv.{u1, u3} R S' (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) (RingHom.{u1, u3} R S' _inst_1 _inst_3) (HasLiftT.mk.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (RingEquiv.{u1, u3} R S' (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) (RingHom.{u1, u3} R S' _inst_1 _inst_3) (CoeTCₓ.coe.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (RingEquiv.{u1, u3} R S' (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) (RingHom.{u1, u3} R S' _inst_1 _inst_3) (RingHom.hasCoeT.{max u1 u3, u1, u3} (RingEquiv.{u1, u3} R S' (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) R S' _inst_1 _inst_3 (RingEquivClass.toRingHomClass.{max u1 u3, u1, u3} (RingEquiv.{u1, u3} R S' (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) R S' _inst_1 _inst_3 (RingEquiv.ringEquivClass.{u1, u3} R S' (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))))))) (RingEquiv.trans.{u1, u2, u3} R S S' (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) e₁ e₂)) (RingHom.comp.{u1, u2, u3} R S S' _inst_1 _inst_2 _inst_3 ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u2) (succ u3)} a b] => self.0) (RingEquiv.{u2, u3} S S' (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) (RingHom.{u2, u3} S S' _inst_2 _inst_3) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (RingEquiv.{u2, u3} S S' (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) (RingHom.{u2, u3} S S' _inst_2 _inst_3) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (RingEquiv.{u2, u3} S S' (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) (RingHom.{u2, u3} S S' _inst_2 _inst_3) (RingHom.hasCoeT.{max u2 u3, u2, u3} (RingEquiv.{u2, u3} S S' (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) S S' _inst_2 _inst_3 (RingEquivClass.toRingHomClass.{max u2 u3, u2, u3} (RingEquiv.{u2, u3} S S' (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) S S' _inst_2 _inst_3 (RingEquiv.ringEquivClass.{u2, u3} S S' (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))))))) e₂) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (RingHom.{u1, u2} R S _inst_1 _inst_2) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (RingHom.{u1, u2} R S _inst_1 _inst_2) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (RingHom.{u1, u2} R S _inst_1 _inst_2) (RingHom.hasCoeT.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S _inst_1 _inst_2 (RingEquivClass.toRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S _inst_1 _inst_2 (RingEquiv.ringEquivClass.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))))))) e₁))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} {S' : Type.{u3}} [_inst_1 : NonAssocSemiring.{u2} R] [_inst_2 : NonAssocSemiring.{u1} S] [_inst_3 : NonAssocSemiring.{u3} S'] (e₁ : RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) (e₂ : RingEquiv.{u1, u3} S S' (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))), Eq.{max (succ u2) (succ u3)} (RingHom.{u2, u3} R S' _inst_1 _inst_3) (RingHomClass.toRingHom.{max u2 u3, u2, u3} (RingEquiv.{u2, u3} R S' (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) R S' _inst_1 _inst_3 (RingEquivClass.toRingHomClass.{max u2 u3, u2, u3} (RingEquiv.{u2, u3} R S' (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) R S' _inst_1 _inst_3 (RingEquiv.instRingEquivClassRingEquiv.{u2, u3} R S' (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))))) (RingEquiv.trans.{u2, u1, u3} R S S' (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)) (Distrib.toAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) e₁ e₂)) (RingHom.comp.{u2, u1, u3} R S S' _inst_1 _inst_2 _inst_3 (RingHomClass.toRingHom.{max u1 u3, u1, u3} (RingEquiv.{u1, u3} S S' (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) S S' _inst_2 _inst_3 (RingEquivClass.toRingHomClass.{max u1 u3, u1, u3} (RingEquiv.{u1, u3} S S' (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))) S S' _inst_2 _inst_3 (RingEquiv.instRingEquivClassRingEquiv.{u1, u3} S S' (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))))) e₂) (RingHomClass.toRingHom.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R S _inst_1 _inst_2 (RingEquivClass.toRingHomClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R S _inst_1 _inst_2 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))))) e₁))
Case conversion may be inaccurate. Consider using '#align ring_equiv.coe_ring_hom_trans RingEquiv.coe_ringHom_transₓ'. -/
@[simp]
theorem coe_ringHom_trans [NonAssocSemiring S'] (e₁ : R ≃+* S) (e₂ : S ≃+* S') :
    (e₁.trans e₂ : R →+* S') = (e₂ : S →+* S').comp ↑e₁ :=
  rfl
#align ring_equiv.coe_ring_hom_trans RingEquiv.coe_ringHom_trans

/- warning: ring_equiv.comp_symm -> RingEquiv.comp_symm is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S] (e : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))), Eq.{succ u2} (RingHom.{u2, u2} S S _inst_2 _inst_2) (RingHom.comp.{u2, u1, u2} S R S _inst_2 _inst_1 _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (RingHom.{u1, u2} R S _inst_1 _inst_2) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (RingHom.{u1, u2} R S _inst_1 _inst_2) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (RingHom.{u1, u2} R S _inst_1 _inst_2) (RingHom.hasCoeT.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S _inst_1 _inst_2 (RingEquivClass.toRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S _inst_1 _inst_2 (RingEquiv.ringEquivClass.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))))))) e) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u2) (succ u1), max (succ u2) (succ u1)} a b] => self.0) (RingEquiv.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (RingHom.{u2, u1} S R _inst_2 _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingEquiv.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (RingHom.{u2, u1} S R _inst_2 _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingEquiv.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (RingHom.{u2, u1} S R _inst_2 _inst_1) (RingHom.hasCoeT.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) S R _inst_2 _inst_1 (RingEquivClass.toRingHomClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) S R _inst_2 _inst_1 (RingEquiv.ringEquivClass.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))))))) (RingEquiv.symm.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) e))) (RingHom.id.{u2} S _inst_2)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} R] [_inst_2 : NonAssocSemiring.{u1} S] (e : RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))), Eq.{succ u1} (RingHom.{u1, u1} S S _inst_2 _inst_2) (RingHom.comp.{u1, u2, u1} S R S _inst_2 _inst_1 _inst_2 (RingHomClass.toRingHom.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R S _inst_1 _inst_2 (RingEquivClass.toRingHomClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R S _inst_1 _inst_2 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))))) e) (RingHomClass.toRingHom.{max u2 u1, u1, u2} (RingEquiv.{u1, u2} S R (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)))) S R _inst_2 _inst_1 (RingEquivClass.toRingHomClass.{max u2 u1, u1, u2} (RingEquiv.{u1, u2} S R (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)))) S R _inst_2 _inst_1 (RingEquiv.instRingEquivClassRingEquiv.{u1, u2} S R (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))))) (RingEquiv.symm.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) e))) (RingHom.id.{u1} S _inst_2)
Case conversion may be inaccurate. Consider using '#align ring_equiv.comp_symm RingEquiv.comp_symmₓ'. -/
@[simp]
theorem comp_symm (e : R ≃+* S) : (e : R →+* S).comp (e.symm : S →+* R) = RingHom.id S :=
  RingHom.ext e.apply_symm_apply
#align ring_equiv.comp_symm RingEquiv.comp_symm

/- warning: ring_equiv.symm_comp -> RingEquiv.symm_comp is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S] (e : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))), Eq.{succ u1} (RingHom.{u1, u1} R R _inst_1 _inst_1) (RingHom.comp.{u1, u2, u1} R S R _inst_1 _inst_2 _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u2) (succ u1), max (succ u2) (succ u1)} a b] => self.0) (RingEquiv.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (RingHom.{u2, u1} S R _inst_2 _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingEquiv.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (RingHom.{u2, u1} S R _inst_2 _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingEquiv.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (RingHom.{u2, u1} S R _inst_2 _inst_1) (RingHom.hasCoeT.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) S R _inst_2 _inst_1 (RingEquivClass.toRingHomClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) S R _inst_2 _inst_1 (RingEquiv.ringEquivClass.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))))))) (RingEquiv.symm.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) e)) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (RingHom.{u1, u2} R S _inst_1 _inst_2) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (RingHom.{u1, u2} R S _inst_1 _inst_2) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (RingHom.{u1, u2} R S _inst_1 _inst_2) (RingHom.hasCoeT.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S _inst_1 _inst_2 (RingEquivClass.toRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S _inst_1 _inst_2 (RingEquiv.ringEquivClass.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))))))) e)) (RingHom.id.{u1} R _inst_1)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} R] [_inst_2 : NonAssocSemiring.{u1} S] (e : RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))), Eq.{succ u2} (RingHom.{u2, u2} R R _inst_1 _inst_1) (RingHom.comp.{u2, u1, u2} R S R _inst_1 _inst_2 _inst_1 (RingHomClass.toRingHom.{max u2 u1, u1, u2} (RingEquiv.{u1, u2} S R (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)))) S R _inst_2 _inst_1 (RingEquivClass.toRingHomClass.{max u2 u1, u1, u2} (RingEquiv.{u1, u2} S R (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)))) S R _inst_2 _inst_1 (RingEquiv.instRingEquivClassRingEquiv.{u1, u2} S R (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))))) (RingEquiv.symm.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) e)) (RingHomClass.toRingHom.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R S _inst_1 _inst_2 (RingEquivClass.toRingHomClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R S _inst_1 _inst_2 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))))) e)) (RingHom.id.{u2} R _inst_1)
Case conversion may be inaccurate. Consider using '#align ring_equiv.symm_comp RingEquiv.symm_compₓ'. -/
@[simp]
theorem symm_comp (e : R ≃+* S) : (e.symm : S →+* R).comp (e : R →+* S) = RingHom.id R :=
  RingHom.ext e.symm_apply_apply
#align ring_equiv.symm_comp RingEquiv.symm_comp

end Semiring

section NonUnitalRing

variable [NonUnitalNonAssocRing R] [NonUnitalNonAssocRing S] (f : R ≃+* S) (x y : R)

/- warning: ring_equiv.map_neg -> RingEquiv.map_neg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocRing.{u1} R] [_inst_2 : NonUnitalNonAssocRing.{u2} S] (f : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (x : R), Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (fun (_x : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) f (Neg.neg.{u1} R (SubNegMonoid.toHasNeg.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R _inst_1)))) x)) (Neg.neg.{u2} S (SubNegMonoid.toHasNeg.{u2} S (AddGroup.toSubNegMonoid.{u2} S (AddCommGroup.toAddGroup.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S _inst_2)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (fun (_x : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) f x))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocRing.{u1} R] [_inst_2 : NonUnitalNonAssocRing.{u2} S] (f : RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (x : R), Eq.{succ u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) (Neg.neg.{u1} R (NegZeroClass.toNeg.{u1} R (SubNegZeroMonoid.toNegZeroClass.{u1} R (SubtractionMonoid.toSubNegZeroMonoid.{u1} R (SubtractionCommMonoid.toSubtractionMonoid.{u1} R (AddCommGroup.toDivisionAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R _inst_1)))))) x)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (EquivLike.toEmbeddingLike.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (MulEquivClass.toEquivLike.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (RingEquivClass.toMulEquivClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (RingEquiv.instRingEquivClassRingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))))))) f (Neg.neg.{u1} R (NegZeroClass.toNeg.{u1} R (SubNegZeroMonoid.toNegZeroClass.{u1} R (SubtractionMonoid.toSubNegZeroMonoid.{u1} R (SubtractionCommMonoid.toSubtractionMonoid.{u1} R (AddCommGroup.toDivisionAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R _inst_1)))))) x)) (Neg.neg.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) (NegZeroClass.toNeg.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) (SubtractionCommMonoid.toSubtractionMonoid.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) (AddCommGroup.toDivisionAddCommMonoid.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) (NonUnitalNonAssocRing.toAddCommGroup.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) _inst_2)))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (EquivLike.toEmbeddingLike.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (MulEquivClass.toEquivLike.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (RingEquivClass.toMulEquivClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (RingEquiv.instRingEquivClassRingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))))))) f x))
Case conversion may be inaccurate. Consider using '#align ring_equiv.map_neg RingEquiv.map_negₓ'. -/
protected theorem map_neg : f (-x) = -f x :=
  map_neg f x
#align ring_equiv.map_neg RingEquiv.map_neg

/- warning: ring_equiv.map_sub -> RingEquiv.map_sub is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocRing.{u1} R] [_inst_2 : NonUnitalNonAssocRing.{u2} S] (f : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (x : R) (y : R), Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (fun (_x : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) f (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (SubNegMonoid.toHasSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R _inst_1))))) x y)) (HSub.hSub.{u2, u2, u2} S S S (instHSub.{u2} S (SubNegMonoid.toHasSub.{u2} S (AddGroup.toSubNegMonoid.{u2} S (AddCommGroup.toAddGroup.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S _inst_2))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (fun (_x : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (fun (_x : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) f y))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocRing.{u1} R] [_inst_2 : NonUnitalNonAssocRing.{u2} S] (f : RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (x : R) (y : R), Eq.{succ u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (SubNegMonoid.toSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R _inst_1))))) x y)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (EquivLike.toEmbeddingLike.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (MulEquivClass.toEquivLike.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (RingEquivClass.toMulEquivClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (RingEquiv.instRingEquivClassRingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))))))) f (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (SubNegMonoid.toSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R _inst_1))))) x y)) (HSub.hSub.{u2, u2, u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) y) ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) (instHSub.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) (SubNegMonoid.toSub.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) (AddGroup.toSubNegMonoid.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) (AddCommGroup.toAddGroup.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) (NonUnitalNonAssocRing.toAddCommGroup.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) _inst_2))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (EquivLike.toEmbeddingLike.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (MulEquivClass.toEquivLike.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (RingEquivClass.toMulEquivClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (RingEquiv.instRingEquivClassRingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))))))) f x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (EquivLike.toEmbeddingLike.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (MulEquivClass.toEquivLike.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (RingEquivClass.toMulEquivClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (RingEquiv.instRingEquivClassRingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R _inst_1) (NonUnitalNonAssocRing.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))))))) f y))
Case conversion may be inaccurate. Consider using '#align ring_equiv.map_sub RingEquiv.map_subₓ'. -/
protected theorem map_sub : f (x - y) = f x - f y :=
  map_sub f x y
#align ring_equiv.map_sub RingEquiv.map_sub

end NonUnitalRing

section Ring

variable [NonAssocRing R] [NonAssocRing S] (f : R ≃+* S) (x y : R)

/- warning: ring_equiv.map_neg_one -> RingEquiv.map_neg_one is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocRing.{u1} R] [_inst_2 : NonAssocRing.{u2} S] (f : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S _inst_2))))), Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S _inst_2))))) (fun (_x : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S _inst_2))))) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S _inst_2))))) f (Neg.neg.{u1} R (SubNegMonoid.toHasNeg.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R _inst_1)))))))) (Neg.neg.{u2} S (SubNegMonoid.toHasNeg.{u2} S (AddGroup.toSubNegMonoid.{u2} S (AddGroupWithOne.toAddGroup.{u2} S (NonAssocRing.toAddGroupWithOne.{u2} S _inst_2)))) (OfNat.ofNat.{u2} S 1 (OfNat.mk.{u2} S 1 (One.one.{u2} S (AddMonoidWithOne.toOne.{u2} S (AddGroupWithOne.toAddMonoidWithOne.{u2} S (NonAssocRing.toAddGroupWithOne.{u2} S _inst_2)))))))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocRing.{u1} R] [_inst_2 : NonAssocRing.{u2} S] (f : RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1)) (NonUnitalNonAssocRing.toMul.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1)))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S _inst_2))))), Eq.{succ u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) (Neg.neg.{u1} R (AddGroupWithOne.toNeg.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R _inst_1))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1)) (NonUnitalNonAssocRing.toMul.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1)))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S _inst_2))))) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1)) (NonUnitalNonAssocRing.toMul.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1)))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S _inst_2))))) R S (EquivLike.toEmbeddingLike.{max (succ u1) (succ u2), succ u1, succ u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1)) (NonUnitalNonAssocRing.toMul.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1)))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S _inst_2))))) R S (MulEquivClass.toEquivLike.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1)) (NonUnitalNonAssocRing.toMul.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1)))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S _inst_2))))) R S (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1)) (NonUnitalNonAssocRing.toMul.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S _inst_2)) (RingEquivClass.toMulEquivClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1)) (NonUnitalNonAssocRing.toMul.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1)))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S _inst_2))))) R S (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1)))) (NonUnitalNonAssocRing.toMul.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S _inst_2)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S _inst_2)))) (RingEquiv.instRingEquivClassRingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1)) (NonUnitalNonAssocRing.toMul.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1)))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S _inst_2))))))))) f (Neg.neg.{u1} R (AddGroupWithOne.toNeg.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R _inst_1))))) (Neg.neg.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) (Neg.neg.{u1} R (AddGroupWithOne.toNeg.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R _inst_1))))) (AddGroupWithOne.toNeg.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) (Neg.neg.{u1} R (AddGroupWithOne.toNeg.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R _inst_1))))) (NonAssocRing.toAddGroupWithOne.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) (Neg.neg.{u1} R (AddGroupWithOne.toNeg.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R _inst_1))))) _inst_2)) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) (Neg.neg.{u1} R (AddGroupWithOne.toNeg.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R _inst_1))))) 1 (One.toOfNat1.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) (Neg.neg.{u1} R (AddGroupWithOne.toNeg.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R _inst_1))))) (NonAssocRing.toOne.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) (Neg.neg.{u1} R (AddGroupWithOne.toNeg.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R _inst_1))))) _inst_2))))
Case conversion may be inaccurate. Consider using '#align ring_equiv.map_neg_one RingEquiv.map_neg_oneₓ'. -/
@[simp]
theorem map_neg_one : f (-1) = -1 :=
  f.map_one ▸ f.map_neg 1
#align ring_equiv.map_neg_one RingEquiv.map_neg_one

end Ring

section NonUnitalSemiringHom

variable [NonUnitalNonAssocSemiring R] [NonUnitalNonAssocSemiring S] [NonUnitalNonAssocSemiring S']

/- warning: ring_equiv.to_non_unital_ring_hom -> RingEquiv.toNonUnitalRingHom is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S], (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) -> (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S], (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) -> (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2)
Case conversion may be inaccurate. Consider using '#align ring_equiv.to_non_unital_ring_hom RingEquiv.toNonUnitalRingHomₓ'. -/
/-- Reinterpret a ring equivalence as a non-unital ring homomorphism. -/
def toNonUnitalRingHom (e : R ≃+* S) : R →ₙ+* S :=
  { e.toMulEquiv.toMulHom, e.toAddEquiv.toAddMonoidHom with }
#align ring_equiv.to_non_unital_ring_hom RingEquiv.toNonUnitalRingHom

/- warning: ring_equiv.to_non_unital_ring_hom_injective -> RingEquiv.toNonUnitalRingHom_injective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S], Function.Injective.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (RingEquiv.toNonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u1} S], Function.Injective.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2))) (NonUnitalRingHom.{u2, u1} R S _inst_1 _inst_2) (RingEquiv.toNonUnitalRingHom.{u2, u1} R S _inst_1 _inst_2)
Case conversion may be inaccurate. Consider using '#align ring_equiv.to_non_unital_ring_hom_injective RingEquiv.toNonUnitalRingHom_injectiveₓ'. -/
theorem toNonUnitalRingHom_injective :
    Function.Injective (toNonUnitalRingHom : R ≃+* S → R →ₙ+* S) := fun f g h =>
  RingEquiv.ext (NonUnitalRingHom.ext_iff.1 h)
#align ring_equiv.to_non_unital_ring_hom_injective RingEquiv.toNonUnitalRingHom_injective

/- warning: ring_equiv.has_coe_to_non_unital_ring_hom -> RingEquiv.instCoeToNonUnitalRingHom is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S], Coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S], Coe.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2)
Case conversion may be inaccurate. Consider using '#align ring_equiv.has_coe_to_non_unital_ring_hom RingEquiv.instCoeToNonUnitalRingHomₓ'. -/
/- The instance priority is lowered here so that in the case when `R` and `S` are both unital, Lean
will first find and use `ring_equiv.has_coe_to_ring_hom`. -/
instance (priority := 900) instCoeToNonUnitalRingHom : Coe (R ≃+* S) (R →ₙ+* S) :=
  ⟨RingEquiv.toNonUnitalRingHom⟩
#align ring_equiv.has_coe_to_non_unital_ring_hom RingEquiv.instCoeToNonUnitalRingHom

/- warning: ring_equiv.to_non_unital_ring_hom_eq_coe -> RingEquiv.toNonUnitalRingHom_eq_coe is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] (f : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))), Eq.{max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (RingEquiv.toNonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2 f) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (NonUnitalRingHom.hasCoeT.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) R S _inst_1 _inst_2 (RingEquivClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) R S _inst_1 _inst_2 (RingEquiv.ringEquivClass.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))))))) f)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u1} S] (f : RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2))), Eq.{max (succ u2) (succ u1)} (NonUnitalRingHom.{u2, u1} R S _inst_1 _inst_2) (RingEquiv.toNonUnitalRingHom.{u2, u1} R S _inst_1 _inst_2 f) (NonUnitalRingHomClass.toNonUnitalRingHom.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2))) R S _inst_1 _inst_2 (RingEquivClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2))) R S _inst_1 _inst_2 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2)))) f)
Case conversion may be inaccurate. Consider using '#align ring_equiv.to_non_unital_ring_hom_eq_coe RingEquiv.toNonUnitalRingHom_eq_coeₓ'. -/
theorem toNonUnitalRingHom_eq_coe (f : R ≃+* S) : f.toNonUnitalRingHom = ↑f :=
  rfl
#align ring_equiv.to_non_unital_ring_hom_eq_coe RingEquiv.toNonUnitalRingHom_eq_coe

/- warning: ring_equiv.coe_to_non_unital_ring_hom -> RingEquiv.coe_toNonUnitalRingHom is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] (f : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))), Eq.{max (succ u1) (succ u2)} (R -> S) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (fun (_x : NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) => R -> S) (NonUnitalRingHom.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (NonUnitalRingHom.hasCoeT.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) R S _inst_1 _inst_2 (RingEquivClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) R S _inst_1 _inst_2 (RingEquiv.ringEquivClass.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))))))) f)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) (fun (_x : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) f)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u1} S] (f : RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2))), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : R), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : R) => S) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NonUnitalRingHom.{u2, u1} R S _inst_1 _inst_2) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : R) => S) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} R S _inst_1 _inst_2) R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} R S _inst_1 _inst_2) R S _inst_1 _inst_2 (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u2, u1} R S _inst_1 _inst_2))) (NonUnitalRingHomClass.toNonUnitalRingHom.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2))) R S _inst_1 _inst_2 (RingEquivClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2))) R S _inst_1 _inst_2 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2)))) f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2))) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2))) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2))) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2))) R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2))) R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2)) (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2))))))) f)
Case conversion may be inaccurate. Consider using '#align ring_equiv.coe_to_non_unital_ring_hom RingEquiv.coe_toNonUnitalRingHomₓ'. -/
@[simp, norm_cast]
theorem coe_toNonUnitalRingHom (f : R ≃+* S) : ⇑(f : R →ₙ+* S) = f :=
  rfl
#align ring_equiv.coe_to_non_unital_ring_hom RingEquiv.coe_toNonUnitalRingHom

/- warning: ring_equiv.coe_non_unital_ring_hom_inj_iff -> RingEquiv.coe_nonUnitalRingHom_inj_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_4 : NonUnitalNonAssocSemiring.{u1} R] [_inst_5 : NonUnitalNonAssocSemiring.{u2} S] (f : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_4)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_4)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_5)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_5))) (g : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_4)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_4)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_5)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_5))), Iff (Eq.{max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_4)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_4)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_5)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_5))) f g) (Eq.{max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} R S _inst_4 _inst_5) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_4)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_4)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_5)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_5))) (NonUnitalRingHom.{u1, u2} R S _inst_4 _inst_5) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_4)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_4)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_5)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_5))) (NonUnitalRingHom.{u1, u2} R S _inst_4 _inst_5) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_4)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_4)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_5)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_5))) (NonUnitalRingHom.{u1, u2} R S _inst_4 _inst_5) (NonUnitalRingHom.hasCoeT.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_4)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_4)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_5)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_5))) R S _inst_4 _inst_5 (RingEquivClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_4)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_4)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_5)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_5))) R S _inst_4 _inst_5 (RingEquiv.ringEquivClass.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_4)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_4)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_5)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_5))))))) f) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_4)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_4)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_5)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_5))) (NonUnitalRingHom.{u1, u2} R S _inst_4 _inst_5) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_4)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_4)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_5)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_5))) (NonUnitalRingHom.{u1, u2} R S _inst_4 _inst_5) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_4)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_4)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_5)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_5))) (NonUnitalRingHom.{u1, u2} R S _inst_4 _inst_5) (NonUnitalRingHom.hasCoeT.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_4)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_4)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_5)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_5))) R S _inst_4 _inst_5 (RingEquivClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_4)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_4)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_5)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_5))) R S _inst_4 _inst_5 (RingEquiv.ringEquivClass.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_4)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_4)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_5)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_5))))))) g))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_4 : NonUnitalNonAssocSemiring.{u2} R] [_inst_5 : NonUnitalNonAssocSemiring.{u1} S] (f : RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_4) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_5) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_4)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_5))) (g : RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_4) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_5) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_4)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_5))), Iff (Eq.{max (succ u2) (succ u1)} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_4) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_5) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_4)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_5))) f g) (Eq.{max (succ u2) (succ u1)} (NonUnitalRingHom.{u2, u1} R S _inst_4 _inst_5) (NonUnitalRingHomClass.toNonUnitalRingHom.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_4) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_5) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_4)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_5))) R S _inst_4 _inst_5 (RingEquivClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_4) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_5) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_4)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_5))) R S _inst_4 _inst_5 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_4) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_5) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_4)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_5)))) f) (NonUnitalRingHomClass.toNonUnitalRingHom.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_4) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_5) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_4)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_5))) R S _inst_4 _inst_5 (RingEquivClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_4) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_5) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_4)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_5))) R S _inst_4 _inst_5 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_4) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_5) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_4)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_5)))) g))
Case conversion may be inaccurate. Consider using '#align ring_equiv.coe_non_unital_ring_hom_inj_iff RingEquiv.coe_nonUnitalRingHom_inj_iffₓ'. -/
theorem coe_nonUnitalRingHom_inj_iff {R S : Type _} [NonUnitalNonAssocSemiring R]
    [NonUnitalNonAssocSemiring S] (f g : R ≃+* S) : f = g ↔ (f : R →ₙ+* S) = g :=
  ⟨congr_arg _, fun h => ext <| NonUnitalRingHom.ext_iff.mp h⟩
#align ring_equiv.coe_non_unital_ring_hom_inj_iff RingEquiv.coe_nonUnitalRingHom_inj_iff

#print RingEquiv.toNonUnitalRingHom_refl /-
@[simp]
theorem toNonUnitalRingHom_refl : (RingEquiv.refl R).toNonUnitalRingHom = NonUnitalRingHom.id R :=
  rfl
#align ring_equiv.to_non_unital_ring_hom_refl RingEquiv.toNonUnitalRingHom_refl
-/

/- warning: ring_equiv.to_non_unital_ring_hom_apply_symm_to_non_unital_ring_hom_apply -> RingEquiv.toNonUnitalRingHom_apply_symm_toNonUnitalRingHom_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] (e : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) (y : S), Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (fun (_x : NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) => R -> S) (NonUnitalRingHom.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2) (RingEquiv.toNonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2 e) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (NonUnitalRingHom.{u2, u1} S R _inst_2 _inst_1) (fun (_x : NonUnitalRingHom.{u2, u1} S R _inst_2 _inst_1) => S -> R) (NonUnitalRingHom.hasCoeToFun.{u2, u1} S R _inst_2 _inst_1) (RingEquiv.toNonUnitalRingHom.{u2, u1} S R _inst_2 _inst_1 (RingEquiv.symm.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) e)) y)) y
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u1} S] (e : RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2))) (y : S), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : R) => S) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (NonUnitalRingHom.{u1, u2} S R _inst_2 _inst_1) S (fun (a : S) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : S) => R) a) (MulHomClass.toFunLike.{max u2 u1, u1, u2} (NonUnitalRingHom.{u1, u2} S R _inst_2 _inst_1) S R (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u1, u2} (NonUnitalRingHom.{u1, u2} S R _inst_2 _inst_1) S R _inst_2 _inst_1 (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u2} S R _inst_2 _inst_1))) (RingEquiv.toNonUnitalRingHom.{u1, u2} S R _inst_2 _inst_1 (RingEquiv.symm.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2)) e)) y)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NonUnitalRingHom.{u2, u1} R S _inst_1 _inst_2) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : R) => S) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} R S _inst_1 _inst_2) R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} R S _inst_1 _inst_2) R S _inst_1 _inst_2 (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u2, u1} R S _inst_1 _inst_2))) (RingEquiv.toNonUnitalRingHom.{u2, u1} R S _inst_1 _inst_2 e) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (NonUnitalRingHom.{u1, u2} S R _inst_2 _inst_1) S (fun (_x : S) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : S) => R) _x) (MulHomClass.toFunLike.{max u2 u1, u1, u2} (NonUnitalRingHom.{u1, u2} S R _inst_2 _inst_1) S R (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u1, u2} (NonUnitalRingHom.{u1, u2} S R _inst_2 _inst_1) S R _inst_2 _inst_1 (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u2} S R _inst_2 _inst_1))) (RingEquiv.toNonUnitalRingHom.{u1, u2} S R _inst_2 _inst_1 (RingEquiv.symm.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2)) e)) y)) y
Case conversion may be inaccurate. Consider using '#align ring_equiv.to_non_unital_ring_hom_apply_symm_to_non_unital_ring_hom_apply RingEquiv.toNonUnitalRingHom_apply_symm_toNonUnitalRingHom_applyₓ'. -/
@[simp]
theorem toNonUnitalRingHom_apply_symm_toNonUnitalRingHom_apply (e : R ≃+* S) :
    ∀ y : S, e.toNonUnitalRingHom (e.symm.toNonUnitalRingHom y) = y :=
  e.toEquiv.apply_symm_apply
#align
  ring_equiv.to_non_unital_ring_hom_apply_symm_to_non_unital_ring_hom_apply RingEquiv.toNonUnitalRingHom_apply_symm_toNonUnitalRingHom_apply

/- warning: ring_equiv.symm_to_non_unital_ring_hom_apply_to_non_unital_ring_hom_apply -> RingEquiv.symm_toNonUnitalRingHom_apply_toNonUnitalRingHom_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] (e : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) (x : R), Eq.{succ u1} R (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (NonUnitalRingHom.{u2, u1} S R _inst_2 _inst_1) (fun (_x : NonUnitalRingHom.{u2, u1} S R _inst_2 _inst_1) => S -> R) (NonUnitalRingHom.hasCoeToFun.{u2, u1} S R _inst_2 _inst_1) (RingEquiv.toNonUnitalRingHom.{u2, u1} S R _inst_2 _inst_1 (RingEquiv.symm.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) e)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (fun (_x : NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) => R -> S) (NonUnitalRingHom.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2) (RingEquiv.toNonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2 e) x)) x
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u1} S] (e : RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2))) (x : R), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : S) => R) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NonUnitalRingHom.{u2, u1} R S _inst_1 _inst_2) R (fun (a : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : R) => S) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} R S _inst_1 _inst_2) R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} R S _inst_1 _inst_2) R S _inst_1 _inst_2 (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u2, u1} R S _inst_1 _inst_2))) (RingEquiv.toNonUnitalRingHom.{u2, u1} R S _inst_1 _inst_2 e) x)) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (NonUnitalRingHom.{u1, u2} S R _inst_2 _inst_1) S (fun (_x : S) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : S) => R) _x) (MulHomClass.toFunLike.{max u2 u1, u1, u2} (NonUnitalRingHom.{u1, u2} S R _inst_2 _inst_1) S R (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u1, u2} (NonUnitalRingHom.{u1, u2} S R _inst_2 _inst_1) S R _inst_2 _inst_1 (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u2} S R _inst_2 _inst_1))) (RingEquiv.toNonUnitalRingHom.{u1, u2} S R _inst_2 _inst_1 (RingEquiv.symm.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2)) e)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NonUnitalRingHom.{u2, u1} R S _inst_1 _inst_2) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : R) => S) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} R S _inst_1 _inst_2) R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} R S _inst_1 _inst_2) R S _inst_1 _inst_2 (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u2, u1} R S _inst_1 _inst_2))) (RingEquiv.toNonUnitalRingHom.{u2, u1} R S _inst_1 _inst_2 e) x)) x
Case conversion may be inaccurate. Consider using '#align ring_equiv.symm_to_non_unital_ring_hom_apply_to_non_unital_ring_hom_apply RingEquiv.symm_toNonUnitalRingHom_apply_toNonUnitalRingHom_applyₓ'. -/
@[simp]
theorem symm_toNonUnitalRingHom_apply_toNonUnitalRingHom_apply (e : R ≃+* S) :
    ∀ x : R, e.symm.toNonUnitalRingHom (e.toNonUnitalRingHom x) = x :=
  Equiv.symm_apply_apply e.toEquiv
#align
  ring_equiv.symm_to_non_unital_ring_hom_apply_to_non_unital_ring_hom_apply RingEquiv.symm_toNonUnitalRingHom_apply_toNonUnitalRingHom_apply

/- warning: ring_equiv.to_non_unital_ring_hom_trans -> RingEquiv.toNonUnitalRingHom_trans is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {S' : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] [_inst_3 : NonUnitalNonAssocSemiring.{u3} S'] (e₁ : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) (e₂ : RingEquiv.{u2, u3} S S' (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' _inst_3)) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' _inst_3))), Eq.{max (succ u1) (succ u3)} (NonUnitalRingHom.{u1, u3} R S' _inst_1 _inst_3) (RingEquiv.toNonUnitalRingHom.{u1, u3} R S' _inst_1 _inst_3 (RingEquiv.trans.{u1, u2, u3} R S S' (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' _inst_3)) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' _inst_3)) e₁ e₂)) (NonUnitalRingHom.comp.{u1, u2, u3} R S S' _inst_1 _inst_2 _inst_3 (RingEquiv.toNonUnitalRingHom.{u2, u3} S S' _inst_2 _inst_3 e₂) (RingEquiv.toNonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2 e₁))
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u2}} {S' : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u3} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] [_inst_3 : NonUnitalNonAssocSemiring.{u1} S'] (e₁ : RingEquiv.{u3, u2} R S (NonUnitalNonAssocSemiring.toMul.{u3} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u3} R (NonUnitalNonAssocSemiring.toDistrib.{u3} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) (e₂ : RingEquiv.{u2, u1} S S' (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (NonUnitalNonAssocSemiring.toMul.{u1} S' _inst_3) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toAdd.{u1} S' (NonUnitalNonAssocSemiring.toDistrib.{u1} S' _inst_3))), Eq.{max (succ u3) (succ u1)} (NonUnitalRingHom.{u3, u1} R S' _inst_1 _inst_3) (RingEquiv.toNonUnitalRingHom.{u3, u1} R S' _inst_1 _inst_3 (RingEquiv.trans.{u3, u2, u1} R S S' (NonUnitalNonAssocSemiring.toMul.{u3} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u3} R (NonUnitalNonAssocSemiring.toDistrib.{u3} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u1} S' _inst_3) (Distrib.toAdd.{u1} S' (NonUnitalNonAssocSemiring.toDistrib.{u1} S' _inst_3)) e₁ e₂)) (NonUnitalRingHom.comp.{u3, u2, u1} R S S' _inst_1 _inst_2 _inst_3 (RingEquiv.toNonUnitalRingHom.{u2, u1} S S' _inst_2 _inst_3 e₂) (RingEquiv.toNonUnitalRingHom.{u3, u2} R S _inst_1 _inst_2 e₁))
Case conversion may be inaccurate. Consider using '#align ring_equiv.to_non_unital_ring_hom_trans RingEquiv.toNonUnitalRingHom_transₓ'. -/
@[simp]
theorem toNonUnitalRingHom_trans (e₁ : R ≃+* S) (e₂ : S ≃+* S') :
    (e₁.trans e₂).toNonUnitalRingHom = e₂.toNonUnitalRingHom.comp e₁.toNonUnitalRingHom :=
  rfl
#align ring_equiv.to_non_unital_ring_hom_trans RingEquiv.toNonUnitalRingHom_trans

/- warning: ring_equiv.to_non_unital_ring_hom_comp_symm_to_non_unital_ring_hom -> RingEquiv.toNonUnitalRingHomm_comp_symm_toNonUnitalRingHom is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] (e : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))), Eq.{succ u2} (NonUnitalRingHom.{u2, u2} S S _inst_2 _inst_2) (NonUnitalRingHom.comp.{u2, u1, u2} S R S _inst_2 _inst_1 _inst_2 (RingEquiv.toNonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2 e) (RingEquiv.toNonUnitalRingHom.{u2, u1} S R _inst_2 _inst_1 (RingEquiv.symm.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) e))) (NonUnitalRingHom.id.{u2} S _inst_2)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u1} S] (e : RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2))), Eq.{succ u1} (NonUnitalRingHom.{u1, u1} S S _inst_2 _inst_2) (NonUnitalRingHom.comp.{u1, u2, u1} S R S _inst_2 _inst_1 _inst_2 (RingEquiv.toNonUnitalRingHom.{u2, u1} R S _inst_1 _inst_2 e) (RingEquiv.toNonUnitalRingHom.{u1, u2} S R _inst_2 _inst_1 (RingEquiv.symm.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2)) e))) (NonUnitalRingHom.id.{u1} S _inst_2)
Case conversion may be inaccurate. Consider using '#align ring_equiv.to_non_unital_ring_hom_comp_symm_to_non_unital_ring_hom RingEquiv.toNonUnitalRingHomm_comp_symm_toNonUnitalRingHomₓ'. -/
@[simp]
theorem toNonUnitalRingHomm_comp_symm_toNonUnitalRingHom (e : R ≃+* S) :
    e.toNonUnitalRingHom.comp e.symm.toNonUnitalRingHom = NonUnitalRingHom.id _ :=
  by
  ext
  simp
#align
  ring_equiv.to_non_unital_ring_hom_comp_symm_to_non_unital_ring_hom RingEquiv.toNonUnitalRingHomm_comp_symm_toNonUnitalRingHom

/- warning: ring_equiv.symm_to_non_unital_ring_hom_comp_to_non_unital_ring_hom -> RingEquiv.symm_toNonUnitalRingHom_comp_toNonUnitalRingHom is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] (e : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))), Eq.{succ u1} (NonUnitalRingHom.{u1, u1} R R _inst_1 _inst_1) (NonUnitalRingHom.comp.{u1, u2, u1} R S R _inst_1 _inst_2 _inst_1 (RingEquiv.toNonUnitalRingHom.{u2, u1} S R _inst_2 _inst_1 (RingEquiv.symm.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) e)) (RingEquiv.toNonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2 e)) (NonUnitalRingHom.id.{u1} R _inst_1)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u1} S] (e : RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2))), Eq.{succ u2} (NonUnitalRingHom.{u2, u2} R R _inst_1 _inst_1) (NonUnitalRingHom.comp.{u2, u1, u2} R S R _inst_1 _inst_2 _inst_1 (RingEquiv.toNonUnitalRingHom.{u1, u2} S R _inst_2 _inst_1 (RingEquiv.symm.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_2) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R _inst_1)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S _inst_2)) e)) (RingEquiv.toNonUnitalRingHom.{u2, u1} R S _inst_1 _inst_2 e)) (NonUnitalRingHom.id.{u2} R _inst_1)
Case conversion may be inaccurate. Consider using '#align ring_equiv.symm_to_non_unital_ring_hom_comp_to_non_unital_ring_hom RingEquiv.symm_toNonUnitalRingHom_comp_toNonUnitalRingHomₓ'. -/
@[simp]
theorem symm_toNonUnitalRingHom_comp_toNonUnitalRingHom (e : R ≃+* S) :
    e.symm.toNonUnitalRingHom.comp e.toNonUnitalRingHom = NonUnitalRingHom.id _ :=
  by
  ext
  simp
#align
  ring_equiv.symm_to_non_unital_ring_hom_comp_to_non_unital_ring_hom RingEquiv.symm_toNonUnitalRingHom_comp_toNonUnitalRingHom

end NonUnitalSemiringHom

section SemiringHom

variable [NonAssocSemiring R] [NonAssocSemiring S] [NonAssocSemiring S']

/- warning: ring_equiv.to_ring_hom -> RingEquiv.toRingHom is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S], (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) -> (RingHom.{u1, u2} R S _inst_1 _inst_2)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S], (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) -> (RingHom.{u1, u2} R S _inst_1 _inst_2)
Case conversion may be inaccurate. Consider using '#align ring_equiv.to_ring_hom RingEquiv.toRingHomₓ'. -/
/-- Reinterpret a ring equivalence as a ring homomorphism. -/
def toRingHom (e : R ≃+* S) : R →+* S :=
  { e.toMulEquiv.toMonoidHom, e.toAddEquiv.toAddMonoidHom with }
#align ring_equiv.to_ring_hom RingEquiv.toRingHom

/- warning: ring_equiv.to_ring_hom_injective -> RingEquiv.toRingHom_injective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S], Function.Injective.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (RingHom.{u1, u2} R S _inst_1 _inst_2) (RingEquiv.toRingHom.{u1, u2} R S _inst_1 _inst_2)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} R] [_inst_2 : NonAssocSemiring.{u1} S], Function.Injective.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) (RingHom.{u2, u1} R S _inst_1 _inst_2) (RingEquiv.toRingHom.{u2, u1} R S _inst_1 _inst_2)
Case conversion may be inaccurate. Consider using '#align ring_equiv.to_ring_hom_injective RingEquiv.toRingHom_injectiveₓ'. -/
theorem toRingHom_injective : Function.Injective (toRingHom : R ≃+* S → R →+* S) := fun f g h =>
  RingEquiv.ext (RingHom.ext_iff.1 h)
#align ring_equiv.to_ring_hom_injective RingEquiv.toRingHom_injective

/- warning: ring_equiv.has_coe_to_ring_hom -> RingEquiv.instCoeToRingHom is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S], Coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (RingHom.{u1, u2} R S _inst_1 _inst_2)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S], Coe.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (RingHom.{u1, u2} R S _inst_1 _inst_2)
Case conversion may be inaccurate. Consider using '#align ring_equiv.has_coe_to_ring_hom RingEquiv.instCoeToRingHomₓ'. -/
instance instCoeToRingHom : Coe (R ≃+* S) (R →+* S) :=
  ⟨RingEquiv.toRingHom⟩
#align ring_equiv.has_coe_to_ring_hom RingEquiv.instCoeToRingHom

/- warning: ring_equiv.to_ring_hom_eq_coe -> RingEquiv.toRingHom_eq_coe is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S] (f : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))), Eq.{max (succ u1) (succ u2)} (RingHom.{u1, u2} R S _inst_1 _inst_2) (RingEquiv.toRingHom.{u1, u2} R S _inst_1 _inst_2 f) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (RingHom.{u1, u2} R S _inst_1 _inst_2) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (RingHom.{u1, u2} R S _inst_1 _inst_2) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (RingHom.{u1, u2} R S _inst_1 _inst_2) (RingHom.hasCoeT.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S _inst_1 _inst_2 (RingEquivClass.toRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S _inst_1 _inst_2 (RingEquiv.ringEquivClass.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))))))) f)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} R] [_inst_2 : NonAssocSemiring.{u1} S] (f : RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))), Eq.{max (succ u2) (succ u1)} (RingHom.{u2, u1} R S _inst_1 _inst_2) (RingEquiv.toRingHom.{u2, u1} R S _inst_1 _inst_2 f) (RingHomClass.toRingHom.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R S _inst_1 _inst_2 (RingEquivClass.toRingHomClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R S _inst_1 _inst_2 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))))) f)
Case conversion may be inaccurate. Consider using '#align ring_equiv.to_ring_hom_eq_coe RingEquiv.toRingHom_eq_coeₓ'. -/
theorem toRingHom_eq_coe (f : R ≃+* S) : f.toRingHom = ↑f :=
  rfl
#align ring_equiv.to_ring_hom_eq_coe RingEquiv.toRingHom_eq_coe

/- warning: ring_equiv.coe_to_ring_hom -> RingEquiv.coe_toRingHom is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S] (f : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))), Eq.{max (succ u1) (succ u2)} (R -> S) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S _inst_1 _inst_2) (fun (_x : RingHom.{u1, u2} R S _inst_1 _inst_2) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (RingHom.{u1, u2} R S _inst_1 _inst_2) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (RingHom.{u1, u2} R S _inst_1 _inst_2) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (RingHom.{u1, u2} R S _inst_1 _inst_2) (RingHom.hasCoeT.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S _inst_1 _inst_2 (RingEquivClass.toRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S _inst_1 _inst_2 (RingEquiv.ringEquivClass.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))))))) f)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (fun (_x : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) f)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} R] [_inst_2 : NonAssocSemiring.{u1} S] (f : RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : R), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : R) => S) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R S _inst_1 _inst_2) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : R) => S) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S _inst_1 _inst_2) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S _inst_1 _inst_2) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S _inst_1 _inst_2) R S _inst_1 _inst_2 (RingHom.instRingHomClassRingHom.{u2, u1} R S _inst_1 _inst_2)))) (RingHomClass.toRingHom.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R S _inst_1 _inst_2 (RingEquivClass.toRingHomClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R S _inst_1 _inst_2 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))))) f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))))))) f)
Case conversion may be inaccurate. Consider using '#align ring_equiv.coe_to_ring_hom RingEquiv.coe_toRingHomₓ'. -/
@[simp, norm_cast]
theorem coe_toRingHom (f : R ≃+* S) : ⇑(f : R →+* S) = f :=
  rfl
#align ring_equiv.coe_to_ring_hom RingEquiv.coe_toRingHom

/- warning: ring_equiv.coe_ring_hom_inj_iff -> RingEquiv.coe_ringHom_inj_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_4 : NonAssocSemiring.{u1} R] [_inst_5 : NonAssocSemiring.{u2} S] (f : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_5))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_5)))) (g : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_5))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_5)))), Iff (Eq.{max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_5))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_5)))) f g) (Eq.{max (succ u1) (succ u2)} (RingHom.{u1, u2} R S _inst_4 _inst_5) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_5))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_5)))) (RingHom.{u1, u2} R S _inst_4 _inst_5) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_5))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_5)))) (RingHom.{u1, u2} R S _inst_4 _inst_5) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_5))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_5)))) (RingHom.{u1, u2} R S _inst_4 _inst_5) (RingHom.hasCoeT.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_5))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_5)))) R S _inst_4 _inst_5 (RingEquivClass.toRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_5))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_5)))) R S _inst_4 _inst_5 (RingEquiv.ringEquivClass.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_5))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_5)))))))) f) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_5))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_5)))) (RingHom.{u1, u2} R S _inst_4 _inst_5) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_5))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_5)))) (RingHom.{u1, u2} R S _inst_4 _inst_5) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_5))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_5)))) (RingHom.{u1, u2} R S _inst_4 _inst_5) (RingHom.hasCoeT.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_5))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_5)))) R S _inst_4 _inst_5 (RingEquivClass.toRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_5))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_5)))) R S _inst_4 _inst_5 (RingEquiv.ringEquivClass.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_5))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_5)))))))) g))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_4 : NonAssocSemiring.{u2} R] [_inst_5 : NonAssocSemiring.{u1} S] (f : RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_4)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_5)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_4))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_5)))) (g : RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_4)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_5)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_4))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_5)))), Iff (Eq.{max (succ u2) (succ u1)} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_4)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_5)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_4))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_5)))) f g) (Eq.{max (succ u2) (succ u1)} (RingHom.{u2, u1} R S _inst_4 _inst_5) (RingHomClass.toRingHom.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_4)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_5)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_4))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_5)))) R S _inst_4 _inst_5 (RingEquivClass.toRingHomClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_4)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_5)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_4))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_5)))) R S _inst_4 _inst_5 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_4)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_5)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_4))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_5))))) f) (RingHomClass.toRingHom.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_4)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_5)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_4))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_5)))) R S _inst_4 _inst_5 (RingEquivClass.toRingHomClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_4)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_5)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_4))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_5)))) R S _inst_4 _inst_5 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_4)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_5)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_4))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_5))))) g))
Case conversion may be inaccurate. Consider using '#align ring_equiv.coe_ring_hom_inj_iff RingEquiv.coe_ringHom_inj_iffₓ'. -/
theorem coe_ringHom_inj_iff {R S : Type _} [NonAssocSemiring R] [NonAssocSemiring S]
    (f g : R ≃+* S) : f = g ↔ (f : R →+* S) = g :=
  ⟨congr_arg _, fun h => ext <| RingHom.ext_iff.mp h⟩
#align ring_equiv.coe_ring_hom_inj_iff RingEquiv.coe_ringHom_inj_iff

/- warning: ring_equiv.to_non_unital_ring_hom_commutes -> RingEquiv.toNonUnitalRingHom_commutes is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S] (f : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))), Eq.{max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingHom.{u1, u2} R S _inst_1 _inst_2) (NonUnitalRingHom.{u1, u2} R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S _inst_1 _inst_2) (NonUnitalRingHom.{u1, u2} R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S _inst_1 _inst_2) (NonUnitalRingHom.{u1, u2} R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (NonUnitalRingHom.hasCoeT.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S _inst_1 _inst_2) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S _inst_1 _inst_2) R S _inst_1 _inst_2 (RingHom.ringHomClass.{u1, u2} R S _inst_1 _inst_2))))) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (RingHom.{u1, u2} R S _inst_1 _inst_2) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (RingHom.{u1, u2} R S _inst_1 _inst_2) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (RingHom.{u1, u2} R S _inst_1 _inst_2) (RingHom.hasCoeT.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S _inst_1 _inst_2 (RingEquivClass.toRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S _inst_1 _inst_2 (RingEquiv.ringEquivClass.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))))))) f)) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (NonUnitalRingHom.{u1, u2} R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (NonUnitalRingHom.{u1, u2} R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (NonUnitalRingHom.{u1, u2} R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (NonUnitalRingHom.hasCoeT.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2) (RingEquivClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2) (RingEquiv.ringEquivClass.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))))))) f)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} R] [_inst_2 : NonAssocSemiring.{u1} S] (f : RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))), Eq.{max (succ u2) (succ u1)} (NonUnitalRingHom.{u2, u1} R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalRingHomClass.toNonUnitalRingHom.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S _inst_1 _inst_2) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S _inst_1 _inst_2) R S _inst_1 _inst_2 (RingHom.instRingHomClassRingHom.{u2, u1} R S _inst_1 _inst_2)) (RingHomClass.toRingHom.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R S _inst_1 _inst_2 (RingEquivClass.toRingHomClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R S _inst_1 _inst_2 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))))) f)) (NonUnitalRingHomClass.toNonUnitalRingHom.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2) (RingEquivClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2) (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))))) f)
Case conversion may be inaccurate. Consider using '#align ring_equiv.to_non_unital_ring_hom_commutes RingEquiv.toNonUnitalRingHom_commutesₓ'. -/
/-- The two paths coercion can take to a `non_unital_ring_hom` are equivalent -/
@[simp, norm_cast]
theorem toNonUnitalRingHom_commutes (f : R ≃+* S) : ((f : R →+* S) : R →ₙ+* S) = (f : R →ₙ+* S) :=
  rfl
#align ring_equiv.to_non_unital_ring_hom_commutes RingEquiv.toNonUnitalRingHom_commutes

/- warning: ring_equiv.to_monoid_hom -> RingEquiv.toMonoidHom is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S], (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) -> (MonoidHom.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S _inst_2)))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S], (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) -> (MonoidHom.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S _inst_2)))
Case conversion may be inaccurate. Consider using '#align ring_equiv.to_monoid_hom RingEquiv.toMonoidHomₓ'. -/
/-- Reinterpret a ring equivalence as a monoid homomorphism. -/
abbrev toMonoidHom (e : R ≃+* S) : R →* S :=
  e.toRingHom.toMonoidHom
#align ring_equiv.to_monoid_hom RingEquiv.toMonoidHom

/- warning: ring_equiv.to_add_monoid_hom -> RingEquiv.toAddMonoidHom is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S], (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) -> (AddMonoidHom.{u1, u2} R S (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R _inst_1)))) (AddMonoid.toAddZeroClass.{u2} S (AddMonoidWithOne.toAddMonoid.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S _inst_2)))))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S], (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) -> (AddMonoidHom.{u1, u2} R S (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R _inst_1)))) (AddMonoid.toAddZeroClass.{u2} S (AddMonoidWithOne.toAddMonoid.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S _inst_2)))))
Case conversion may be inaccurate. Consider using '#align ring_equiv.to_add_monoid_hom RingEquiv.toAddMonoidHomₓ'. -/
/-- Reinterpret a ring equivalence as an `add_monoid` homomorphism. -/
abbrev toAddMonoidHom (e : R ≃+* S) : R →+ S :=
  e.toRingHom.toAddMonoidHom
#align ring_equiv.to_add_monoid_hom RingEquiv.toAddMonoidHom

/- warning: ring_equiv.to_add_monoid_hom_commutes -> RingEquiv.toAddMonoidMom_commutes is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S] (f : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))), Eq.{max (succ u2) (succ u1)} (AddMonoidHom.{u1, u2} R S (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R _inst_1)))) (AddMonoid.toAddZeroClass.{u2} S (AddMonoidWithOne.toAddMonoid.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S _inst_2))))) (RingHom.toAddMonoidHom.{u1, u2} R S _inst_1 _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (RingHom.{u1, u2} R S _inst_1 _inst_2) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (RingHom.{u1, u2} R S _inst_1 _inst_2) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (RingHom.{u1, u2} R S _inst_1 _inst_2) (RingHom.hasCoeT.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S _inst_1 _inst_2 (RingEquivClass.toRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S _inst_1 _inst_2 (RingEquiv.ringEquivClass.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))))))) f)) (AddEquiv.toAddMonoidHom.{u1, u2} R S (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R _inst_1)))) (AddMonoid.toAddZeroClass.{u2} S (AddMonoidWithOne.toAddMonoid.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S _inst_2)))) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (AddEquiv.{u1, u2} R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (AddEquiv.{u1, u2} R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (AddEquiv.{u1, u2} R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (AddEquiv.hasCoeT.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (RingEquivClass.toAddEquivClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (RingEquiv.ringEquivClass.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))))))) f))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} R] [_inst_2 : NonAssocSemiring.{u1} S] (f : RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))), Eq.{max (succ u2) (succ u1)} (AddMonoidHom.{u2, u1} R S (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R _inst_1)))) (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S _inst_2))))) (RingHom.toAddMonoidHom.{u2, u1} R S _inst_1 _inst_2 (RingHomClass.toRingHom.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R S _inst_1 _inst_2 (RingEquivClass.toRingHomClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R S _inst_1 _inst_2 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))))) f)) (AddEquiv.toAddMonoidHom.{u2, u1} R S (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R _inst_1)))) (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S _inst_2)))) (AddEquivClass.toAddEquiv.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R S (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (RingEquivClass.toAddEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))))) f))
Case conversion may be inaccurate. Consider using '#align ring_equiv.to_add_monoid_hom_commutes RingEquiv.toAddMonoidMom_commutesₓ'. -/
/-- The two paths coercion can take to an `add_monoid_hom` are equivalent -/
theorem toAddMonoidMom_commutes (f : R ≃+* S) :
    (f : R →+* S).toAddMonoidHom = (f : R ≃+ S).toAddMonoidHom :=
  rfl
#align ring_equiv.to_add_monoid_hom_commutes RingEquiv.toAddMonoidMom_commutes

/- warning: ring_equiv.to_monoid_hom_commutes -> RingEquiv.toMonoidHom_commutes is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S] (f : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))), Eq.{max (succ u2) (succ u1)} (MonoidHom.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S _inst_2))) (RingHom.toMonoidHom.{u1, u2} R S _inst_1 _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (RingHom.{u1, u2} R S _inst_1 _inst_2) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (RingHom.{u1, u2} R S _inst_1 _inst_2) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (RingHom.{u1, u2} R S _inst_1 _inst_2) (RingHom.hasCoeT.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S _inst_1 _inst_2 (RingEquivClass.toRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S _inst_1 _inst_2 (RingEquiv.ringEquivClass.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))))))) f)) (MulEquiv.toMonoidHom.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S _inst_2)) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (MulEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (MulEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (MulEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (MulEquiv.hasCoeT.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (RingEquivClass.toMulEquivClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (RingEquiv.ringEquivClass.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))))))) f))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} R] [_inst_2 : NonAssocSemiring.{u1} S] (f : RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))), Eq.{max (succ u2) (succ u1)} (MonoidHom.{u2, u1} R S (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u1} S (NonAssocSemiring.toMulZeroOneClass.{u1} S _inst_2))) (RingHom.toMonoidHom.{u2, u1} R S _inst_1 _inst_2 (RingHomClass.toRingHom.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R S _inst_1 _inst_2 (RingEquivClass.toRingHomClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R S _inst_1 _inst_2 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))))) f)) (MulEquiv.toMonoidHom.{u2, u1} R S (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R _inst_1)) (MulZeroOneClass.toMulOneClass.{u1} S (NonAssocSemiring.toMulZeroOneClass.{u1} S _inst_2)) (MulEquivClass.toMulEquiv.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))))) f))
Case conversion may be inaccurate. Consider using '#align ring_equiv.to_monoid_hom_commutes RingEquiv.toMonoidHom_commutesₓ'. -/
/-- The two paths coercion can take to an `monoid_hom` are equivalent -/
theorem toMonoidHom_commutes (f : R ≃+* S) : (f : R →+* S).toMonoidHom = (f : R ≃* S).toMonoidHom :=
  rfl
#align ring_equiv.to_monoid_hom_commutes RingEquiv.toMonoidHom_commutes

/- warning: ring_equiv.to_equiv_commutes -> RingEquiv.toEquiv_commutes is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S] (f : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))), Eq.{max 1 (max (succ u1) (succ u2)) (succ u2) (succ u1)} (Equiv.{succ u1, succ u2} R S) (AddEquiv.toEquiv.{u1, u2} R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (AddEquiv.{u1, u2} R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (AddEquiv.{u1, u2} R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (AddEquiv.{u1, u2} R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (AddEquiv.hasCoeT.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (RingEquivClass.toAddEquivClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (RingEquiv.ringEquivClass.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))))))) f)) (MulEquiv.toEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (MulEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (MulEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (MulEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (MulEquiv.hasCoeT.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (RingEquivClass.toMulEquivClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (RingEquiv.ringEquivClass.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))))))) f))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} R] [_inst_2 : NonAssocSemiring.{u1} S] (f : RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))), Eq.{max (succ u2) (succ u1)} (Equiv.{succ u2, succ u1} R S) (AddEquiv.toEquiv.{u2, u1} R S (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (AddEquivClass.toAddEquiv.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R S (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (RingEquivClass.toAddEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))))) f)) (MulEquiv.toEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (MulEquivClass.toMulEquiv.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))))) f))
Case conversion may be inaccurate. Consider using '#align ring_equiv.to_equiv_commutes RingEquiv.toEquiv_commutesₓ'. -/
/-- The two paths coercion can take to an `equiv` are equivalent -/
theorem toEquiv_commutes (f : R ≃+* S) : (f : R ≃+ S).toEquiv = (f : R ≃* S).toEquiv :=
  rfl
#align ring_equiv.to_equiv_commutes RingEquiv.toEquiv_commutes

#print RingEquiv.toRingHom_refl /-
@[simp]
theorem toRingHom_refl : (RingEquiv.refl R).toRingHom = RingHom.id R :=
  rfl
#align ring_equiv.to_ring_hom_refl RingEquiv.toRingHom_refl
-/

#print RingEquiv.toMonoidHom_refl /-
@[simp]
theorem toMonoidHom_refl : (RingEquiv.refl R).toMonoidHom = MonoidHom.id R :=
  rfl
#align ring_equiv.to_monoid_hom_refl RingEquiv.toMonoidHom_refl
-/

#print RingEquiv.toAddMonoidHom_refl /-
@[simp]
theorem toAddMonoidHom_refl : (RingEquiv.refl R).toAddMonoidHom = AddMonoidHom.id R :=
  rfl
#align ring_equiv.to_add_monoid_hom_refl RingEquiv.toAddMonoidHom_refl
-/

/- warning: ring_equiv.to_ring_hom_apply_symm_to_ring_hom_apply -> RingEquiv.toRingHom_apply_symm_toRingHom_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S] (e : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (y : S), Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S _inst_1 _inst_2) (fun (_x : RingHom.{u1, u2} R S _inst_1 _inst_2) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2) (RingEquiv.toRingHom.{u1, u2} R S _inst_1 _inst_2 e) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingHom.{u2, u1} S R _inst_2 _inst_1) (fun (_x : RingHom.{u2, u1} S R _inst_2 _inst_1) => S -> R) (RingHom.hasCoeToFun.{u2, u1} S R _inst_2 _inst_1) (RingEquiv.toRingHom.{u2, u1} S R _inst_2 _inst_1 (RingEquiv.symm.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) e)) y)) y
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} R] [_inst_2 : NonAssocSemiring.{u1} S] (e : RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) (y : S), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : R) => S) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (RingHom.{u1, u2} S R _inst_2 _inst_1) S (fun (a : S) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : S) => R) a) (MulHomClass.toFunLike.{max u2 u1, u1, u2} (RingHom.{u1, u2} S R _inst_2 _inst_1) S R (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u1, u2} (RingHom.{u1, u2} S R _inst_2 _inst_1) S R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u1, u2} (RingHom.{u1, u2} S R _inst_2 _inst_1) S R _inst_2 _inst_1 (RingHom.instRingHomClassRingHom.{u1, u2} S R _inst_2 _inst_1)))) (RingEquiv.toRingHom.{u1, u2} S R _inst_2 _inst_1 (RingEquiv.symm.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) e)) y)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R S _inst_1 _inst_2) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : R) => S) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S _inst_1 _inst_2) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S _inst_1 _inst_2) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S _inst_1 _inst_2) R S _inst_1 _inst_2 (RingHom.instRingHomClassRingHom.{u2, u1} R S _inst_1 _inst_2)))) (RingEquiv.toRingHom.{u2, u1} R S _inst_1 _inst_2 e) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (RingHom.{u1, u2} S R _inst_2 _inst_1) S (fun (_x : S) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : S) => R) _x) (MulHomClass.toFunLike.{max u2 u1, u1, u2} (RingHom.{u1, u2} S R _inst_2 _inst_1) S R (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u1, u2} (RingHom.{u1, u2} S R _inst_2 _inst_1) S R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u1, u2} (RingHom.{u1, u2} S R _inst_2 _inst_1) S R _inst_2 _inst_1 (RingHom.instRingHomClassRingHom.{u1, u2} S R _inst_2 _inst_1)))) (RingEquiv.toRingHom.{u1, u2} S R _inst_2 _inst_1 (RingEquiv.symm.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) e)) y)) y
Case conversion may be inaccurate. Consider using '#align ring_equiv.to_ring_hom_apply_symm_to_ring_hom_apply RingEquiv.toRingHom_apply_symm_toRingHom_applyₓ'. -/
@[simp]
theorem toRingHom_apply_symm_toRingHom_apply (e : R ≃+* S) :
    ∀ y : S, e.toRingHom (e.symm.toRingHom y) = y :=
  e.toEquiv.apply_symm_apply
#align
  ring_equiv.to_ring_hom_apply_symm_to_ring_hom_apply RingEquiv.toRingHom_apply_symm_toRingHom_apply

/- warning: ring_equiv.symm_to_ring_hom_apply_to_ring_hom_apply -> RingEquiv.symm_toRingHom_apply_toRingHom_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S] (e : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (x : R), Eq.{succ u1} R (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingHom.{u2, u1} S R _inst_2 _inst_1) (fun (_x : RingHom.{u2, u1} S R _inst_2 _inst_1) => S -> R) (RingHom.hasCoeToFun.{u2, u1} S R _inst_2 _inst_1) (RingEquiv.toRingHom.{u2, u1} S R _inst_2 _inst_1 (RingEquiv.symm.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) e)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S _inst_1 _inst_2) (fun (_x : RingHom.{u1, u2} R S _inst_1 _inst_2) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2) (RingEquiv.toRingHom.{u1, u2} R S _inst_1 _inst_2 e) x)) x
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} R] [_inst_2 : NonAssocSemiring.{u1} S] (e : RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))) (x : R), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : S) => R) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R S _inst_1 _inst_2) R (fun (a : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : R) => S) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S _inst_1 _inst_2) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S _inst_1 _inst_2) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S _inst_1 _inst_2) R S _inst_1 _inst_2 (RingHom.instRingHomClassRingHom.{u2, u1} R S _inst_1 _inst_2)))) (RingEquiv.toRingHom.{u2, u1} R S _inst_1 _inst_2 e) x)) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (RingHom.{u1, u2} S R _inst_2 _inst_1) S (fun (_x : S) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : S) => R) _x) (MulHomClass.toFunLike.{max u2 u1, u1, u2} (RingHom.{u1, u2} S R _inst_2 _inst_1) S R (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u1, u2} (RingHom.{u1, u2} S R _inst_2 _inst_1) S R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u1, u2} (RingHom.{u1, u2} S R _inst_2 _inst_1) S R _inst_2 _inst_1 (RingHom.instRingHomClassRingHom.{u1, u2} S R _inst_2 _inst_1)))) (RingEquiv.toRingHom.{u1, u2} S R _inst_2 _inst_1 (RingEquiv.symm.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) e)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R S _inst_1 _inst_2) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : R) => S) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S _inst_1 _inst_2) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S _inst_1 _inst_2) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S _inst_1 _inst_2) R S _inst_1 _inst_2 (RingHom.instRingHomClassRingHom.{u2, u1} R S _inst_1 _inst_2)))) (RingEquiv.toRingHom.{u2, u1} R S _inst_1 _inst_2 e) x)) x
Case conversion may be inaccurate. Consider using '#align ring_equiv.symm_to_ring_hom_apply_to_ring_hom_apply RingEquiv.symm_toRingHom_apply_toRingHom_applyₓ'. -/
@[simp]
theorem symm_toRingHom_apply_toRingHom_apply (e : R ≃+* S) :
    ∀ x : R, e.symm.toRingHom (e.toRingHom x) = x :=
  Equiv.symm_apply_apply e.toEquiv
#align
  ring_equiv.symm_to_ring_hom_apply_to_ring_hom_apply RingEquiv.symm_toRingHom_apply_toRingHom_apply

/- warning: ring_equiv.to_ring_hom_trans -> RingEquiv.toRingHom_trans is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {S' : Type.{u3}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S] [_inst_3 : NonAssocSemiring.{u3} S'] (e₁ : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (e₂ : RingEquiv.{u2, u3} S S' (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3)))), Eq.{max (succ u1) (succ u3)} (RingHom.{u1, u3} R S' _inst_1 _inst_3) (RingEquiv.toRingHom.{u1, u3} R S' _inst_1 _inst_3 (RingEquiv.trans.{u1, u2, u3} R S S' (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasMul.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) (Distrib.toHasAdd.{u3} S' (NonUnitalNonAssocSemiring.toDistrib.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' _inst_3))) e₁ e₂)) (RingHom.comp.{u1, u2, u3} R S S' _inst_1 _inst_2 _inst_3 (RingEquiv.toRingHom.{u2, u3} S S' _inst_2 _inst_3 e₂) (RingEquiv.toRingHom.{u1, u2} R S _inst_1 _inst_2 e₁))
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u2}} {S' : Type.{u1}} [_inst_1 : NonAssocSemiring.{u3} R] [_inst_2 : NonAssocSemiring.{u2} S] [_inst_3 : NonAssocSemiring.{u1} S'] (e₁ : RingEquiv.{u3, u2} R S (NonUnitalNonAssocSemiring.toMul.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (Distrib.toAdd.{u3} R (NonUnitalNonAssocSemiring.toDistrib.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))) (e₂ : RingEquiv.{u2, u1} S S' (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u1} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S' _inst_3)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toAdd.{u1} S' (NonUnitalNonAssocSemiring.toDistrib.{u1} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S' _inst_3)))), Eq.{max (succ u3) (succ u1)} (RingHom.{u3, u1} R S' _inst_1 _inst_3) (RingEquiv.toRingHom.{u3, u1} R S' _inst_1 _inst_3 (RingEquiv.trans.{u3, u2, u1} R S S' (NonUnitalNonAssocSemiring.toMul.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)) (Distrib.toAdd.{u3} R (NonUnitalNonAssocSemiring.toDistrib.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u1} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S' _inst_3)) (Distrib.toAdd.{u1} S' (NonUnitalNonAssocSemiring.toDistrib.{u1} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S' _inst_3))) e₁ e₂)) (RingHom.comp.{u3, u2, u1} R S S' _inst_1 _inst_2 _inst_3 (RingEquiv.toRingHom.{u2, u1} S S' _inst_2 _inst_3 e₂) (RingEquiv.toRingHom.{u3, u2} R S _inst_1 _inst_2 e₁))
Case conversion may be inaccurate. Consider using '#align ring_equiv.to_ring_hom_trans RingEquiv.toRingHom_transₓ'. -/
@[simp]
theorem toRingHom_trans (e₁ : R ≃+* S) (e₂ : S ≃+* S') :
    (e₁.trans e₂).toRingHom = e₂.toRingHom.comp e₁.toRingHom :=
  rfl
#align ring_equiv.to_ring_hom_trans RingEquiv.toRingHom_trans

/- warning: ring_equiv.to_ring_hom_comp_symm_to_ring_hom -> RingEquiv.toRingHom_comp_symm_toRingHom is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S] (e : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))), Eq.{succ u2} (RingHom.{u2, u2} S S _inst_2 _inst_2) (RingHom.comp.{u2, u1, u2} S R S _inst_2 _inst_1 _inst_2 (RingEquiv.toRingHom.{u1, u2} R S _inst_1 _inst_2 e) (RingEquiv.toRingHom.{u2, u1} S R _inst_2 _inst_1 (RingEquiv.symm.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) e))) (RingHom.id.{u2} S _inst_2)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} R] [_inst_2 : NonAssocSemiring.{u1} S] (e : RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))), Eq.{succ u1} (RingHom.{u1, u1} S S _inst_2 _inst_2) (RingHom.comp.{u1, u2, u1} S R S _inst_2 _inst_1 _inst_2 (RingEquiv.toRingHom.{u2, u1} R S _inst_1 _inst_2 e) (RingEquiv.toRingHom.{u1, u2} S R _inst_2 _inst_1 (RingEquiv.symm.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) e))) (RingHom.id.{u1} S _inst_2)
Case conversion may be inaccurate. Consider using '#align ring_equiv.to_ring_hom_comp_symm_to_ring_hom RingEquiv.toRingHom_comp_symm_toRingHomₓ'. -/
@[simp]
theorem toRingHom_comp_symm_toRingHom (e : R ≃+* S) :
    e.toRingHom.comp e.symm.toRingHom = RingHom.id _ :=
  by
  ext
  simp
#align ring_equiv.to_ring_hom_comp_symm_to_ring_hom RingEquiv.toRingHom_comp_symm_toRingHom

/- warning: ring_equiv.symm_to_ring_hom_comp_to_ring_hom -> RingEquiv.symm_toRingHom_comp_toRingHom is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} R] [_inst_2 : NonAssocSemiring.{u2} S] (e : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2)))), Eq.{succ u1} (RingHom.{u1, u1} R R _inst_1 _inst_1) (RingHom.comp.{u1, u2, u1} R S R _inst_1 _inst_2 _inst_1 (RingEquiv.toRingHom.{u2, u1} S R _inst_2 _inst_1 (RingEquiv.symm.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_2))) e)) (RingEquiv.toRingHom.{u1, u2} R S _inst_1 _inst_2 e)) (RingHom.id.{u1} R _inst_1)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} R] [_inst_2 : NonAssocSemiring.{u1} S] (e : RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)))), Eq.{succ u2} (RingHom.{u2, u2} R R _inst_1 _inst_1) (RingHom.comp.{u2, u1, u2} R S R _inst_1 _inst_2 _inst_1 (RingEquiv.toRingHom.{u1, u2} S R _inst_2 _inst_1 (RingEquiv.symm.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2)) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_2))) e)) (RingEquiv.toRingHom.{u2, u1} R S _inst_1 _inst_2 e)) (RingHom.id.{u2} R _inst_1)
Case conversion may be inaccurate. Consider using '#align ring_equiv.symm_to_ring_hom_comp_to_ring_hom RingEquiv.symm_toRingHom_comp_toRingHomₓ'. -/
@[simp]
theorem symm_toRingHom_comp_toRingHom (e : R ≃+* S) :
    e.symm.toRingHom.comp e.toRingHom = RingHom.id _ :=
  by
  ext
  simp
#align ring_equiv.symm_to_ring_hom_comp_to_ring_hom RingEquiv.symm_toRingHom_comp_toRingHom

/- warning: ring_equiv.of_hom_inv' -> RingEquiv.ofHomInv' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} {G : Type.{u4}} [_inst_4 : NonUnitalNonAssocSemiring.{u1} R] [_inst_5 : NonUnitalNonAssocSemiring.{u2} S] [_inst_6 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_4 _inst_5] [_inst_7 : NonUnitalRingHomClass.{u4, u2, u1} G S R _inst_5 _inst_4] (hom : F) (inv : G), (Eq.{succ u1} (NonUnitalRingHom.{u1, u1} R R _inst_4 _inst_4) (NonUnitalRingHom.comp.{u1, u2, u1} R S R _inst_4 _inst_5 _inst_4 ((fun (a : Type.{u4}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{succ u4, max (succ u2) (succ u1)} a b] => self.0) G (NonUnitalRingHom.{u2, u1} S R _inst_5 _inst_4) (HasLiftT.mk.{succ u4, max (succ u2) (succ u1)} G (NonUnitalRingHom.{u2, u1} S R _inst_5 _inst_4) (CoeTCₓ.coe.{succ u4, max (succ u2) (succ u1)} G (NonUnitalRingHom.{u2, u1} S R _inst_5 _inst_4) (NonUnitalRingHom.hasCoeT.{u4, u2, u1} G S R _inst_5 _inst_4 _inst_7))) inv) ((fun (a : Type.{u3}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{succ u3, max (succ u1) (succ u2)} a b] => self.0) F (NonUnitalRingHom.{u1, u2} R S _inst_4 _inst_5) (HasLiftT.mk.{succ u3, max (succ u1) (succ u2)} F (NonUnitalRingHom.{u1, u2} R S _inst_4 _inst_5) (CoeTCₓ.coe.{succ u3, max (succ u1) (succ u2)} F (NonUnitalRingHom.{u1, u2} R S _inst_4 _inst_5) (NonUnitalRingHom.hasCoeT.{u3, u1, u2} F R S _inst_4 _inst_5 _inst_6))) hom)) (NonUnitalRingHom.id.{u1} R _inst_4)) -> (Eq.{succ u2} (NonUnitalRingHom.{u2, u2} S S _inst_5 _inst_5) (NonUnitalRingHom.comp.{u2, u1, u2} S R S _inst_5 _inst_4 _inst_5 ((fun (a : Type.{u3}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{succ u3, max (succ u1) (succ u2)} a b] => self.0) F (NonUnitalRingHom.{u1, u2} R S _inst_4 _inst_5) (HasLiftT.mk.{succ u3, max (succ u1) (succ u2)} F (NonUnitalRingHom.{u1, u2} R S _inst_4 _inst_5) (CoeTCₓ.coe.{succ u3, max (succ u1) (succ u2)} F (NonUnitalRingHom.{u1, u2} R S _inst_4 _inst_5) (NonUnitalRingHom.hasCoeT.{u3, u1, u2} F R S _inst_4 _inst_5 _inst_6))) hom) ((fun (a : Type.{u4}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{succ u4, max (succ u2) (succ u1)} a b] => self.0) G (NonUnitalRingHom.{u2, u1} S R _inst_5 _inst_4) (HasLiftT.mk.{succ u4, max (succ u2) (succ u1)} G (NonUnitalRingHom.{u2, u1} S R _inst_5 _inst_4) (CoeTCₓ.coe.{succ u4, max (succ u2) (succ u1)} G (NonUnitalRingHom.{u2, u1} S R _inst_5 _inst_4) (NonUnitalRingHom.hasCoeT.{u4, u2, u1} G S R _inst_5 _inst_4 _inst_7))) inv)) (NonUnitalRingHom.id.{u2} S _inst_5)) -> (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_4)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_4)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_5)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_5)))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} {G : Type.{u4}} [_inst_4 : NonUnitalNonAssocSemiring.{u1} R] [_inst_5 : NonUnitalNonAssocSemiring.{u2} S] [_inst_6 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_4 _inst_5] [_inst_7 : NonUnitalRingHomClass.{u4, u2, u1} G S R _inst_5 _inst_4] (hom : F) (inv : G), (Eq.{succ u1} (NonUnitalRingHom.{u1, u1} R R _inst_4 _inst_4) (NonUnitalRingHom.comp.{u1, u2, u1} R S R _inst_4 _inst_5 _inst_4 (NonUnitalRingHomClass.toNonUnitalRingHom.{u4, u2, u1} G S R _inst_5 _inst_4 _inst_7 inv) (NonUnitalRingHomClass.toNonUnitalRingHom.{u3, u1, u2} F R S _inst_4 _inst_5 _inst_6 hom)) (NonUnitalRingHom.id.{u1} R _inst_4)) -> (Eq.{succ u2} (NonUnitalRingHom.{u2, u2} S S _inst_5 _inst_5) (NonUnitalRingHom.comp.{u2, u1, u2} S R S _inst_5 _inst_4 _inst_5 (NonUnitalRingHomClass.toNonUnitalRingHom.{u3, u1, u2} F R S _inst_4 _inst_5 _inst_6 hom) (NonUnitalRingHomClass.toNonUnitalRingHom.{u4, u2, u1} G S R _inst_5 _inst_4 _inst_7 inv)) (NonUnitalRingHom.id.{u2} S _inst_5)) -> (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_4) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_5) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_4)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_5)))
Case conversion may be inaccurate. Consider using '#align ring_equiv.of_hom_inv' RingEquiv.ofHomInv'ₓ'. -/
/-- Construct an equivalence of rings from homomorphisms in both directions, which are inverses.
-/
@[simps]
def ofHomInv' {R S F G : Type _} [NonUnitalNonAssocSemiring R] [NonUnitalNonAssocSemiring S]
    [NonUnitalRingHomClass F R S] [NonUnitalRingHomClass G S R] (hom : F) (inv : G)
    (hom_inv_id : (inv : S →ₙ+* R).comp (hom : R →ₙ+* S) = NonUnitalRingHom.id R)
    (inv_hom_id : (hom : R →ₙ+* S).comp (inv : S →ₙ+* R) = NonUnitalRingHom.id S) : R ≃+* S
    where
  toFun := hom
  invFun := inv
  left_inv := FunLike.congr_fun hom_inv_id
  right_inv := FunLike.congr_fun inv_hom_id
  map_mul' := map_mul hom
  map_add' := map_add hom
#align ring_equiv.of_hom_inv' RingEquiv.ofHomInv'

/- warning: ring_equiv.of_hom_inv -> RingEquiv.ofHomInv is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} {G : Type.{u4}} [_inst_4 : NonAssocSemiring.{u1} R] [_inst_5 : NonAssocSemiring.{u2} S] [_inst_6 : RingHomClass.{u3, u1, u2} F R S _inst_4 _inst_5] [_inst_7 : RingHomClass.{u4, u2, u1} G S R _inst_5 _inst_4] (hom : F) (inv : G), (Eq.{succ u1} (RingHom.{u1, u1} R R _inst_4 _inst_4) (RingHom.comp.{u1, u2, u1} R S R _inst_4 _inst_5 _inst_4 ((fun (a : Type.{u4}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{succ u4, max (succ u2) (succ u1)} a b] => self.0) G (RingHom.{u2, u1} S R _inst_5 _inst_4) (HasLiftT.mk.{succ u4, max (succ u2) (succ u1)} G (RingHom.{u2, u1} S R _inst_5 _inst_4) (CoeTCₓ.coe.{succ u4, max (succ u2) (succ u1)} G (RingHom.{u2, u1} S R _inst_5 _inst_4) (RingHom.hasCoeT.{u4, u2, u1} G S R _inst_5 _inst_4 _inst_7))) inv) ((fun (a : Type.{u3}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{succ u3, max (succ u1) (succ u2)} a b] => self.0) F (RingHom.{u1, u2} R S _inst_4 _inst_5) (HasLiftT.mk.{succ u3, max (succ u1) (succ u2)} F (RingHom.{u1, u2} R S _inst_4 _inst_5) (CoeTCₓ.coe.{succ u3, max (succ u1) (succ u2)} F (RingHom.{u1, u2} R S _inst_4 _inst_5) (RingHom.hasCoeT.{u3, u1, u2} F R S _inst_4 _inst_5 _inst_6))) hom)) (RingHom.id.{u1} R _inst_4)) -> (Eq.{succ u2} (RingHom.{u2, u2} S S _inst_5 _inst_5) (RingHom.comp.{u2, u1, u2} S R S _inst_5 _inst_4 _inst_5 ((fun (a : Type.{u3}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{succ u3, max (succ u1) (succ u2)} a b] => self.0) F (RingHom.{u1, u2} R S _inst_4 _inst_5) (HasLiftT.mk.{succ u3, max (succ u1) (succ u2)} F (RingHom.{u1, u2} R S _inst_4 _inst_5) (CoeTCₓ.coe.{succ u3, max (succ u1) (succ u2)} F (RingHom.{u1, u2} R S _inst_4 _inst_5) (RingHom.hasCoeT.{u3, u1, u2} F R S _inst_4 _inst_5 _inst_6))) hom) ((fun (a : Type.{u4}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{succ u4, max (succ u2) (succ u1)} a b] => self.0) G (RingHom.{u2, u1} S R _inst_5 _inst_4) (HasLiftT.mk.{succ u4, max (succ u2) (succ u1)} G (RingHom.{u2, u1} S R _inst_5 _inst_4) (CoeTCₓ.coe.{succ u4, max (succ u2) (succ u1)} G (RingHom.{u2, u1} S R _inst_5 _inst_4) (RingHom.hasCoeT.{u4, u2, u1} G S R _inst_5 _inst_4 _inst_7))) inv)) (RingHom.id.{u2} S _inst_5)) -> (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_5))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_5))))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} {G : Type.{u4}} [_inst_4 : NonAssocSemiring.{u1} R] [_inst_5 : NonAssocSemiring.{u2} S] [_inst_6 : RingHomClass.{u3, u1, u2} F R S _inst_4 _inst_5] [_inst_7 : RingHomClass.{u4, u2, u1} G S R _inst_5 _inst_4] (hom : F) (inv : G), (Eq.{succ u1} (RingHom.{u1, u1} R R _inst_4 _inst_4) (RingHom.comp.{u1, u2, u1} R S R _inst_4 _inst_5 _inst_4 (RingHomClass.toRingHom.{u4, u2, u1} G S R _inst_5 _inst_4 _inst_7 inv) (RingHomClass.toRingHom.{u3, u1, u2} F R S _inst_4 _inst_5 _inst_6 hom)) (RingHom.id.{u1} R _inst_4)) -> (Eq.{succ u2} (RingHom.{u2, u2} S S _inst_5 _inst_5) (RingHom.comp.{u2, u1, u2} S R S _inst_5 _inst_4 _inst_5 (RingHomClass.toRingHom.{u3, u1, u2} F R S _inst_4 _inst_5 _inst_6 hom) (RingHomClass.toRingHom.{u4, u2, u1} G S R _inst_5 _inst_4 _inst_7 inv)) (RingHom.id.{u2} S _inst_5)) -> (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_5)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S _inst_5))))
Case conversion may be inaccurate. Consider using '#align ring_equiv.of_hom_inv RingEquiv.ofHomInvₓ'. -/
/--
Construct an equivalence of rings from unital homomorphisms in both directions, which are inverses.
-/
@[simps]
def ofHomInv {R S F G : Type _} [NonAssocSemiring R] [NonAssocSemiring S] [RingHomClass F R S]
    [RingHomClass G S R] (hom : F) (inv : G)
    (hom_inv_id : (inv : S →+* R).comp (hom : R →+* S) = RingHom.id R)
    (inv_hom_id : (hom : R →+* S).comp (inv : S →+* R) = RingHom.id S) : R ≃+* S
    where
  toFun := hom
  invFun := inv
  left_inv := FunLike.congr_fun hom_inv_id
  right_inv := FunLike.congr_fun inv_hom_id
  map_mul' := map_mul hom
  map_add' := map_add hom
#align ring_equiv.of_hom_inv RingEquiv.ofHomInv

end SemiringHom

section GroupPower

variable [Semiring R] [Semiring S]

/- warning: ring_equiv.map_pow -> RingEquiv.map_pow is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] (f : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))) (a : R) (n : Nat), Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))) (fun (_x : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))) f (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) a n)) (HPow.hPow.{u2, 0, u2} S Nat S (instHPow.{u2, 0} S Nat (Monoid.Pow.{u2} S (MonoidWithZero.toMonoid.{u2} S (Semiring.toMonoidWithZero.{u2} S _inst_2)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))) (fun (_x : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))) f a) n)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] (f : RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))))) (a : R) (n : Nat), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) (HPow.hPow.{u2, 0, u2} R Nat R (instHPow.{u2, 0} R Nat (Monoid.Pow.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) a n)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))))) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))))) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))))) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))))) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))) (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))))) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)))) (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))))))))) f (HPow.hPow.{u2, 0, u2} R Nat R (instHPow.{u2, 0} R Nat (Monoid.Pow.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) a n)) (HPow.hPow.{u1, 0, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) a) Nat ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) a) (instHPow.{u1, 0} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) a) Nat (Monoid.Pow.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) a) (MonoidWithZero.toMonoid.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) a) (Semiring.toMonoidWithZero.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) a) _inst_2)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))))) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))))) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))))) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))))) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))) (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))))) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)))) (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))))))))) f a) n)
Case conversion may be inaccurate. Consider using '#align ring_equiv.map_pow RingEquiv.map_powₓ'. -/
protected theorem map_pow (f : R ≃+* S) (a) : ∀ n : ℕ, f (a ^ n) = f a ^ n :=
  map_pow f a
#align ring_equiv.map_pow RingEquiv.map_pow

end GroupPower

end RingEquiv

namespace MulEquiv

/- warning: mul_equiv.to_ring_equiv -> MulEquiv.toRingEquiv is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Add.{u1} R] [_inst_2 : Add.{u2} S] [_inst_3 : Mul.{u1} R] [_inst_4 : Mul.{u2} S] [_inst_5 : MulEquivClass.{u3, u1, u2} F R S _inst_3 _inst_4] (f : F), (forall (x : R) (y : R), Eq.{succ u2} S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (EmbeddingLike.toFunLike.{succ u3, succ u1, succ u2} F R S (EquivLike.toEmbeddingLike.{succ u3, succ u1, succ u2} F R S (MulEquivClass.toEquivLike.{u3, u1, u2} F R S _inst_3 _inst_4 _inst_5)))) f (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R _inst_1) x y)) (HAdd.hAdd.{u2, u2, u2} S S S (instHAdd.{u2} S _inst_2) (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (EmbeddingLike.toFunLike.{succ u3, succ u1, succ u2} F R S (EquivLike.toEmbeddingLike.{succ u3, succ u1, succ u2} F R S (MulEquivClass.toEquivLike.{u3, u1, u2} F R S _inst_3 _inst_4 _inst_5)))) f x) (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (EmbeddingLike.toFunLike.{succ u3, succ u1, succ u2} F R S (EquivLike.toEmbeddingLike.{succ u3, succ u1, succ u2} F R S (MulEquivClass.toEquivLike.{u3, u1, u2} F R S _inst_3 _inst_4 _inst_5)))) f y))) -> (RingEquiv.{u1, u2} R S _inst_3 _inst_1 _inst_4 _inst_2)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Add.{u1} R] [_inst_2 : Add.{u2} S] [_inst_3 : Mul.{u1} R] [_inst_4 : Mul.{u2} S] [_inst_5 : MulEquivClass.{u3, u1, u2} F R S _inst_3 _inst_4] (f : F), (forall (x : R) (y : R), Eq.{succ u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R _inst_1) x y)) (FunLike.coe.{succ u3, succ u1, succ u2} F R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{succ u3, succ u1, succ u2} F R S (EquivLike.toEmbeddingLike.{succ u3, succ u1, succ u2} F R S (MulEquivClass.toEquivLike.{u3, u1, u2} F R S _inst_3 _inst_4 _inst_5))) f (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R _inst_1) x y)) (HAdd.hAdd.{u2, u2, u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) y) ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) (instHAdd.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) _inst_2) (FunLike.coe.{succ u3, succ u1, succ u2} F R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{succ u3, succ u1, succ u2} F R S (EquivLike.toEmbeddingLike.{succ u3, succ u1, succ u2} F R S (MulEquivClass.toEquivLike.{u3, u1, u2} F R S _inst_3 _inst_4 _inst_5))) f x) (FunLike.coe.{succ u3, succ u1, succ u2} F R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{succ u3, succ u1, succ u2} F R S (EquivLike.toEmbeddingLike.{succ u3, succ u1, succ u2} F R S (MulEquivClass.toEquivLike.{u3, u1, u2} F R S _inst_3 _inst_4 _inst_5))) f y))) -> (RingEquiv.{u1, u2} R S _inst_3 _inst_4 _inst_1 _inst_2)
Case conversion may be inaccurate. Consider using '#align mul_equiv.to_ring_equiv MulEquiv.toRingEquivₓ'. -/
/-- Gives a `ring_equiv` from an element of a `mul_equiv_class` preserving addition.-/
def toRingEquiv {R S F : Type _} [Add R] [Add S] [Mul R] [Mul S] [MulEquivClass F R S] (f : F)
    (H : ∀ x y : R, f (x + y) = f x + f y) : R ≃+* S :=
  { (f : R ≃* S).toEquiv, (f : R ≃* S), AddEquiv.mk' (f : R ≃* S).toEquiv H with }
#align mul_equiv.to_ring_equiv MulEquiv.toRingEquiv

end MulEquiv

namespace AddEquiv

/- warning: add_equiv.to_ring_equiv -> AddEquiv.toRingEquiv is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Add.{u1} R] [_inst_2 : Add.{u2} S] [_inst_3 : Mul.{u1} R] [_inst_4 : Mul.{u2} S] [_inst_5 : AddEquivClass.{u3, u1, u2} F R S _inst_1 _inst_2] (f : F), (forall (x : R) (y : R), Eq.{succ u2} S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (EmbeddingLike.toFunLike.{succ u3, succ u1, succ u2} F R S (EquivLike.toEmbeddingLike.{succ u3, succ u1, succ u2} F R S (AddEquivClass.toEquivLike.{u3, u1, u2} F R S _inst_1 _inst_2 _inst_5)))) f (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R _inst_3) x y)) (HMul.hMul.{u2, u2, u2} S S S (instHMul.{u2} S _inst_4) (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (EmbeddingLike.toFunLike.{succ u3, succ u1, succ u2} F R S (EquivLike.toEmbeddingLike.{succ u3, succ u1, succ u2} F R S (AddEquivClass.toEquivLike.{u3, u1, u2} F R S _inst_1 _inst_2 _inst_5)))) f x) (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (EmbeddingLike.toFunLike.{succ u3, succ u1, succ u2} F R S (EquivLike.toEmbeddingLike.{succ u3, succ u1, succ u2} F R S (AddEquivClass.toEquivLike.{u3, u1, u2} F R S _inst_1 _inst_2 _inst_5)))) f y))) -> (RingEquiv.{u1, u2} R S _inst_3 _inst_1 _inst_4 _inst_2)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Add.{u1} R] [_inst_2 : Add.{u2} S] [_inst_3 : Mul.{u1} R] [_inst_4 : Mul.{u2} S] [_inst_5 : AddEquivClass.{u3, u1, u2} F R S _inst_1 _inst_2] (f : F), (forall (x : R) (y : R), Eq.{succ u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R _inst_3) x y)) (FunLike.coe.{succ u3, succ u1, succ u2} F R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{succ u3, succ u1, succ u2} F R S (EquivLike.toEmbeddingLike.{succ u3, succ u1, succ u2} F R S (AddEquivClass.toEquivLike.{u3, u1, u2} F R S _inst_1 _inst_2 _inst_5))) f (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R _inst_3) x y)) (HMul.hMul.{u2, u2, u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) y) ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) (instHMul.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) x) _inst_4) (FunLike.coe.{succ u3, succ u1, succ u2} F R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{succ u3, succ u1, succ u2} F R S (EquivLike.toEmbeddingLike.{succ u3, succ u1, succ u2} F R S (AddEquivClass.toEquivLike.{u3, u1, u2} F R S _inst_1 _inst_2 _inst_5))) f x) (FunLike.coe.{succ u3, succ u1, succ u2} F R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : R) => S) _x) (EmbeddingLike.toFunLike.{succ u3, succ u1, succ u2} F R S (EquivLike.toEmbeddingLike.{succ u3, succ u1, succ u2} F R S (AddEquivClass.toEquivLike.{u3, u1, u2} F R S _inst_1 _inst_2 _inst_5))) f y))) -> (RingEquiv.{u1, u2} R S _inst_3 _inst_4 _inst_1 _inst_2)
Case conversion may be inaccurate. Consider using '#align add_equiv.to_ring_equiv AddEquiv.toRingEquivₓ'. -/
/-- Gives a `ring_equiv` from an element of an `add_equiv_class` preserving addition.-/
def toRingEquiv {R S F : Type _} [Add R] [Add S] [Mul R] [Mul S] [AddEquivClass F R S] (f : F)
    (H : ∀ x y : R, f (x * y) = f x * f y) : R ≃+* S :=
  { (f : R ≃+ S).toEquiv, (f : R ≃+ S), MulEquiv.mk' (f : R ≃+ S).toEquiv H with }
#align add_equiv.to_ring_equiv AddEquiv.toRingEquiv

end AddEquiv

namespace RingEquiv

variable [Add R] [Add S] [Mul R] [Mul S]

/- warning: ring_equiv.self_trans_symm -> RingEquiv.self_trans_symm is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Add.{u1} R] [_inst_2 : Add.{u2} S] [_inst_3 : Mul.{u1} R] [_inst_4 : Mul.{u2} S] (e : RingEquiv.{u1, u2} R S _inst_3 _inst_1 _inst_4 _inst_2), Eq.{succ u1} (RingEquiv.{u1, u1} R R _inst_3 _inst_1 _inst_3 _inst_1) (RingEquiv.trans.{u1, u2, u1} R S R _inst_3 _inst_1 _inst_4 _inst_2 _inst_3 _inst_1 e (RingEquiv.symm.{u1, u2} R S _inst_3 _inst_1 _inst_4 _inst_2 e)) (RingEquiv.refl.{u1} R _inst_3 _inst_1)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Add.{u2} R] [_inst_2 : Add.{u1} S] [_inst_3 : Mul.{u2} R] [_inst_4 : Mul.{u1} S] (e : RingEquiv.{u2, u1} R S _inst_3 _inst_4 _inst_1 _inst_2), Eq.{succ u2} (RingEquiv.{u2, u2} R R _inst_3 _inst_3 _inst_1 _inst_1) (RingEquiv.trans.{u2, u1, u2} R S R _inst_3 _inst_4 _inst_1 _inst_2 _inst_3 _inst_1 e (RingEquiv.symm.{u2, u1} R S _inst_3 _inst_4 _inst_1 _inst_2 e)) (RingEquiv.refl.{u2} R _inst_3 _inst_1)
Case conversion may be inaccurate. Consider using '#align ring_equiv.self_trans_symm RingEquiv.self_trans_symmₓ'. -/
@[simp]
theorem self_trans_symm (e : R ≃+* S) : e.trans e.symm = RingEquiv.refl R :=
  ext e.3
#align ring_equiv.self_trans_symm RingEquiv.self_trans_symm

/- warning: ring_equiv.symm_trans_self -> RingEquiv.symm_trans_self is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Add.{u1} R] [_inst_2 : Add.{u2} S] [_inst_3 : Mul.{u1} R] [_inst_4 : Mul.{u2} S] (e : RingEquiv.{u1, u2} R S _inst_3 _inst_1 _inst_4 _inst_2), Eq.{succ u2} (RingEquiv.{u2, u2} S S _inst_4 _inst_2 _inst_4 _inst_2) (RingEquiv.trans.{u2, u1, u2} S R S _inst_4 _inst_2 _inst_3 _inst_1 _inst_4 _inst_2 (RingEquiv.symm.{u1, u2} R S _inst_3 _inst_1 _inst_4 _inst_2 e) e) (RingEquiv.refl.{u2} S _inst_4 _inst_2)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Add.{u2} R] [_inst_2 : Add.{u1} S] [_inst_3 : Mul.{u2} R] [_inst_4 : Mul.{u1} S] (e : RingEquiv.{u2, u1} R S _inst_3 _inst_4 _inst_1 _inst_2), Eq.{succ u1} (RingEquiv.{u1, u1} S S _inst_4 _inst_4 _inst_2 _inst_2) (RingEquiv.trans.{u1, u2, u1} S R S _inst_4 _inst_3 _inst_2 _inst_1 _inst_4 _inst_2 (RingEquiv.symm.{u2, u1} R S _inst_3 _inst_4 _inst_1 _inst_2 e) e) (RingEquiv.refl.{u1} S _inst_4 _inst_2)
Case conversion may be inaccurate. Consider using '#align ring_equiv.symm_trans_self RingEquiv.symm_trans_selfₓ'. -/
@[simp]
theorem symm_trans_self (e : R ≃+* S) : e.symm.trans e = RingEquiv.refl S :=
  ext e.4
#align ring_equiv.symm_trans_self RingEquiv.symm_trans_self

/- warning: ring_equiv.no_zero_divisors -> RingEquiv.noZeroDivisors is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} (B : Type.{u2}) [_inst_5 : Ring.{u1} A] [_inst_6 : Ring.{u2} B] [_inst_7 : NoZeroDivisors.{u2} B (Distrib.toHasMul.{u2} B (Ring.toDistrib.{u2} B _inst_6)) (MulZeroClass.toHasZero.{u2} B (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} B (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} B (NonAssocRing.toNonUnitalNonAssocRing.{u2} B (Ring.toNonAssocRing.{u2} B _inst_6)))))], (RingEquiv.{u1, u2} A B (Distrib.toHasMul.{u1} A (Ring.toDistrib.{u1} A _inst_5)) (Distrib.toHasAdd.{u1} A (Ring.toDistrib.{u1} A _inst_5)) (Distrib.toHasMul.{u2} B (Ring.toDistrib.{u2} B _inst_6)) (Distrib.toHasAdd.{u2} B (Ring.toDistrib.{u2} B _inst_6))) -> (NoZeroDivisors.{u1} A (Distrib.toHasMul.{u1} A (Ring.toDistrib.{u1} A _inst_5)) (MulZeroClass.toHasZero.{u1} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A _inst_5))))))
but is expected to have type
  forall {A : Type.{u2}} (B : Type.{u1}) [_inst_5 : Ring.{u2} A] [_inst_6 : Ring.{u1} B] [_inst_7 : NoZeroDivisors.{u1} B (NonUnitalNonAssocRing.toMul.{u1} B (NonAssocRing.toNonUnitalNonAssocRing.{u1} B (Ring.toNonAssocRing.{u1} B _inst_6))) (MonoidWithZero.toZero.{u1} B (Semiring.toMonoidWithZero.{u1} B (Ring.toSemiring.{u1} B _inst_6)))], (RingEquiv.{u2, u1} A B (NonUnitalNonAssocRing.toMul.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A _inst_5))) (NonUnitalNonAssocRing.toMul.{u1} B (NonAssocRing.toNonUnitalNonAssocRing.{u1} B (Ring.toNonAssocRing.{u1} B _inst_6))) (Distrib.toAdd.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A _inst_5))))) (Distrib.toAdd.{u1} B (NonUnitalNonAssocSemiring.toDistrib.{u1} B (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} B (NonAssocRing.toNonUnitalNonAssocRing.{u1} B (Ring.toNonAssocRing.{u1} B _inst_6)))))) -> (NoZeroDivisors.{u2} A (NonUnitalNonAssocRing.toMul.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A _inst_5))) (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A (Ring.toSemiring.{u2} A _inst_5))))
Case conversion may be inaccurate. Consider using '#align ring_equiv.no_zero_divisors RingEquiv.noZeroDivisorsₓ'. -/
/-- If two rings are isomorphic, and the second doesn't have zero divisors,
then so does the first. -/
protected theorem noZeroDivisors {A : Type _} (B : Type _) [Ring A] [Ring B] [NoZeroDivisors B]
    (e : A ≃+* B) : NoZeroDivisors A :=
  {
    eq_zero_or_eq_zero_of_mul_eq_zero := fun x y hxy =>
      by
      have : e x * e y = 0 := by rw [← e.map_mul, hxy, e.map_zero]
      simpa using eq_zero_or_eq_zero_of_mul_eq_zero this }
#align ring_equiv.no_zero_divisors RingEquiv.noZeroDivisors

/- warning: ring_equiv.is_domain -> RingEquiv.isDomain is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} (B : Type.{u2}) [_inst_5 : Ring.{u1} A] [_inst_6 : Ring.{u2} B] [_inst_7 : IsDomain.{u2} B (Ring.toSemiring.{u2} B _inst_6)], (RingEquiv.{u1, u2} A B (Distrib.toHasMul.{u1} A (Ring.toDistrib.{u1} A _inst_5)) (Distrib.toHasAdd.{u1} A (Ring.toDistrib.{u1} A _inst_5)) (Distrib.toHasMul.{u2} B (Ring.toDistrib.{u2} B _inst_6)) (Distrib.toHasAdd.{u2} B (Ring.toDistrib.{u2} B _inst_6))) -> (IsDomain.{u1} A (Ring.toSemiring.{u1} A _inst_5))
but is expected to have type
  forall {A : Type.{u2}} (B : Type.{u1}) [_inst_5 : Ring.{u2} A] [_inst_6 : Ring.{u1} B] [_inst_7 : IsDomain.{u1} B (Ring.toSemiring.{u1} B _inst_6)], (RingEquiv.{u2, u1} A B (NonUnitalNonAssocRing.toMul.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A _inst_5))) (NonUnitalNonAssocRing.toMul.{u1} B (NonAssocRing.toNonUnitalNonAssocRing.{u1} B (Ring.toNonAssocRing.{u1} B _inst_6))) (Distrib.toAdd.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A _inst_5))))) (Distrib.toAdd.{u1} B (NonUnitalNonAssocSemiring.toDistrib.{u1} B (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} B (NonAssocRing.toNonUnitalNonAssocRing.{u1} B (Ring.toNonAssocRing.{u1} B _inst_6)))))) -> (IsDomain.{u2} A (Ring.toSemiring.{u2} A _inst_5))
Case conversion may be inaccurate. Consider using '#align ring_equiv.is_domain RingEquiv.isDomainₓ'. -/
/-- If two rings are isomorphic, and the second is a domain, then so is the first. -/
protected theorem isDomain {A : Type _} (B : Type _) [Ring A] [Ring B] [IsDomain B] (e : A ≃+* B) :
    IsDomain A :=
  by
  haveI : Nontrivial A := ⟨⟨e.symm 0, e.symm 1, e.symm.injective.ne zero_ne_one⟩⟩
  haveI := e.no_zero_divisors B
  exact NoZeroDivisors.to_isDomain _
#align ring_equiv.is_domain RingEquiv.isDomain

end RingEquiv

-- Guard against import creep
assert_not_exists fintype

