/-
Copyright (c) 2021 Eric Wieser. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Eric Wieser, Frédéric Dupuis

! This file was ported from Lean 3 source module algebra.star.module
! leanprover-community/mathlib commit 30413fc89f202a090a54d78e540963ed3de0056e
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Star.SelfAdjoint
import Mathbin.Algebra.Module.Equiv
import Mathbin.LinearAlgebra.Prod

/-!
# The star operation, bundled as a star-linear equiv

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

We define `star_linear_equiv`, which is the star operation bundled as a star-linear map.
It is defined on a star algebra `A` over the base ring `R`.

This file also provides some lemmas that need `algebra.module.basic` imported to prove.

## TODO

- Define `star_linear_equiv` for noncommutative `R`. We only the commutative case for now since,
  in the noncommutative case, the ring hom needs to reverse the order of multiplication. This
  requires a ring hom of type `R →+* Rᵐᵒᵖ`, which is very undesirable in the commutative case.
  One way out would be to define a new typeclass `is_op R S` and have an instance `is_op R R`
  for commutative `R`.
- Also note that such a definition involving `Rᵐᵒᵖ` or `is_op R S` would require adding
  the appropriate `ring_hom_inv_pair` instances to be able to define the semilinear
  equivalence.
-/


section SmulLemmas

variable {R M : Type _}

/- warning: star_nat_cast_smul -> star_nat_cast_smul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_4 : StarAddMonoid.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)] (n : Nat) (x : M), Eq.{succ u2} M (Star.star.{u2} M (InvolutiveStar.toHasStar.{u2} M (StarAddMonoid.toHasInvolutiveStar.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_4)) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u1} Nat R (CoeTCₓ.coe.{1, succ u1} Nat R (Nat.castCoe.{u1} R (AddMonoidWithOne.toNatCast.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) n) x)) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u1} Nat R (CoeTCₓ.coe.{1, succ u1} Nat R (Nat.castCoe.{u1} R (AddMonoidWithOne.toNatCast.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) n) (Star.star.{u2} M (InvolutiveStar.toHasStar.{u2} M (StarAddMonoid.toHasInvolutiveStar.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_4)) x))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] [_inst_4 : StarAddMonoid.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)] (n : Nat) (x : M), Eq.{succ u1} M (Star.star.{u1} M (InvolutiveStar.toStar.{u1} M (StarAddMonoid.toInvolutiveStar.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2) _inst_4)) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 _inst_3))))) (Nat.cast.{u2} R (Semiring.toNatCast.{u2} R _inst_1) n) x)) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 _inst_3))))) (Nat.cast.{u2} R (Semiring.toNatCast.{u2} R _inst_1) n) (Star.star.{u1} M (InvolutiveStar.toStar.{u1} M (StarAddMonoid.toInvolutiveStar.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2) _inst_4)) x))
Case conversion may be inaccurate. Consider using '#align star_nat_cast_smul star_nat_cast_smulₓ'. -/
@[simp]
theorem star_nat_cast_smul [Semiring R] [AddCommMonoid M] [Module R M] [StarAddMonoid M] (n : ℕ)
    (x : M) : star ((n : R) • x) = (n : R) • star x :=
  map_nat_cast_smul (starAddEquiv : M ≃+ M) R R n x
#align star_nat_cast_smul star_nat_cast_smul

/- warning: star_int_cast_smul -> star_int_cast_smul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] [_inst_4 : StarAddMonoid.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))] (n : Int) (x : M), Eq.{succ u2} M (Star.star.{u2} M (InvolutiveStar.toHasStar.{u2} M (StarAddMonoid.toHasInvolutiveStar.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))) _inst_4)) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int R (HasLiftT.mk.{1, succ u1} Int R (CoeTCₓ.coe.{1, succ u1} Int R (Int.castCoe.{u1} R (AddGroupWithOne.toHasIntCast.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))))) n) x)) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int R (HasLiftT.mk.{1, succ u1} Int R (CoeTCₓ.coe.{1, succ u1} Int R (Int.castCoe.{u1} R (AddGroupWithOne.toHasIntCast.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))))) n) (Star.star.{u2} M (InvolutiveStar.toHasStar.{u2} M (StarAddMonoid.toHasInvolutiveStar.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))) _inst_4)) x))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_3 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] [_inst_4 : StarAddMonoid.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2)))] (n : Int) (x : M), Eq.{succ u1} M (Star.star.{u1} M (InvolutiveStar.toStar.{u1} M (StarAddMonoid.toInvolutiveStar.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))) _inst_4)) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (Module.toMulActionWithZero.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))))) (Int.cast.{u2} R (Ring.toIntCast.{u2} R _inst_1) n) x)) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (Module.toMulActionWithZero.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))))) (Int.cast.{u2} R (Ring.toIntCast.{u2} R _inst_1) n) (Star.star.{u1} M (InvolutiveStar.toStar.{u1} M (StarAddMonoid.toInvolutiveStar.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))) _inst_4)) x))
Case conversion may be inaccurate. Consider using '#align star_int_cast_smul star_int_cast_smulₓ'. -/
@[simp]
theorem star_int_cast_smul [Ring R] [AddCommGroup M] [Module R M] [StarAddMonoid M] (n : ℤ)
    (x : M) : star ((n : R) • x) = (n : R) • star x :=
  map_int_cast_smul (starAddEquiv : M ≃+ M) R R n x
#align star_int_cast_smul star_int_cast_smul

/- warning: star_inv_nat_cast_smul -> star_inv_nat_cast_smul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : DivisionSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (DivisionSemiring.toSemiring.{u1} R _inst_1) _inst_2] [_inst_4 : StarAddMonoid.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)] (n : Nat) (x : M), Eq.{succ u2} M (Star.star.{u2} M (InvolutiveStar.toHasStar.{u2} M (StarAddMonoid.toHasInvolutiveStar.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_4)) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (DivisionSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (DivisionSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M (DivisionSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))) (Inv.inv.{u1} R (DivInvMonoid.toHasInv.{u1} R (GroupWithZero.toDivInvMonoid.{u1} R (DivisionSemiring.toGroupWithZero.{u1} R _inst_1))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u1} Nat R (CoeTCₓ.coe.{1, succ u1} Nat R (Nat.castCoe.{u1} R (AddMonoidWithOne.toNatCast.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (DivisionSemiring.toSemiring.{u1} R _inst_1)))))))) n)) x)) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (DivisionSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (DivisionSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M (DivisionSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))) (Inv.inv.{u1} R (DivInvMonoid.toHasInv.{u1} R (GroupWithZero.toDivInvMonoid.{u1} R (DivisionSemiring.toGroupWithZero.{u1} R _inst_1))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u1} Nat R (CoeTCₓ.coe.{1, succ u1} Nat R (Nat.castCoe.{u1} R (AddMonoidWithOne.toNatCast.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (DivisionSemiring.toSemiring.{u1} R _inst_1)))))))) n)) (Star.star.{u2} M (InvolutiveStar.toHasStar.{u2} M (StarAddMonoid.toHasInvolutiveStar.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_4)) x))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : DivisionSemiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M (DivisionSemiring.toSemiring.{u2} R _inst_1) _inst_2] [_inst_4 : StarAddMonoid.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)] (n : Nat) (x : M), Eq.{succ u1} M (Star.star.{u1} M (InvolutiveStar.toStar.{u1} M (StarAddMonoid.toInvolutiveStar.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2) _inst_4)) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (DivisionSemiring.toSemiring.{u2} R _inst_1))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R (DivisionSemiring.toSemiring.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M (DivisionSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3))))) (Inv.inv.{u2} R (DivisionSemiring.toInv.{u2} R _inst_1) (Nat.cast.{u2} R (Semiring.toNatCast.{u2} R (DivisionSemiring.toSemiring.{u2} R _inst_1)) n)) x)) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (DivisionSemiring.toSemiring.{u2} R _inst_1))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R (DivisionSemiring.toSemiring.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M (DivisionSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3))))) (Inv.inv.{u2} R (DivisionSemiring.toInv.{u2} R _inst_1) (Nat.cast.{u2} R (Semiring.toNatCast.{u2} R (DivisionSemiring.toSemiring.{u2} R _inst_1)) n)) (Star.star.{u1} M (InvolutiveStar.toStar.{u1} M (StarAddMonoid.toInvolutiveStar.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2) _inst_4)) x))
Case conversion may be inaccurate. Consider using '#align star_inv_nat_cast_smul star_inv_nat_cast_smulₓ'. -/
@[simp]
theorem star_inv_nat_cast_smul [DivisionSemiring R] [AddCommMonoid M] [Module R M] [StarAddMonoid M]
    (n : ℕ) (x : M) : star ((n⁻¹ : R) • x) = (n⁻¹ : R) • star x :=
  map_inv_nat_cast_smul (starAddEquiv : M ≃+ M) R R n x
#align star_inv_nat_cast_smul star_inv_nat_cast_smul

/- warning: star_inv_int_cast_smul -> star_inv_int_cast_smul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : DivisionRing.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] [_inst_4 : StarAddMonoid.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))] (n : Int) (x : M), Eq.{succ u2} M (Star.star.{u2} M (InvolutiveStar.toHasStar.{u2} M (StarAddMonoid.toHasInvolutiveStar.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))) _inst_4)) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)))) (Inv.inv.{u1} R (DivInvMonoid.toHasInv.{u1} R (DivisionRing.toDivInvMonoid.{u1} R _inst_1)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int R (HasLiftT.mk.{1, succ u1} Int R (CoeTCₓ.coe.{1, succ u1} Int R (Int.castCoe.{u1} R (AddGroupWithOne.toHasIntCast.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (DivisionRing.toRing.{u1} R _inst_1))))))) n)) x)) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)))) (Inv.inv.{u1} R (DivInvMonoid.toHasInv.{u1} R (DivisionRing.toDivInvMonoid.{u1} R _inst_1)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int R (HasLiftT.mk.{1, succ u1} Int R (CoeTCₓ.coe.{1, succ u1} Int R (Int.castCoe.{u1} R (AddGroupWithOne.toHasIntCast.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (DivisionRing.toRing.{u1} R _inst_1))))))) n)) (Star.star.{u2} M (InvolutiveStar.toHasStar.{u2} M (StarAddMonoid.toHasInvolutiveStar.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))) _inst_4)) x))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : DivisionRing.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_3 : Module.{u2, u1} R M (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] [_inst_4 : StarAddMonoid.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2)))] (n : Int) (x : M), Eq.{succ u1} M (Star.star.{u1} M (InvolutiveStar.toStar.{u1} M (StarAddMonoid.toInvolutiveStar.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))) _inst_4)) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_1)))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_1))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (Module.toMulActionWithZero.{u2, u1} R M (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))))) (Inv.inv.{u2} R (DivisionRing.toInv.{u2} R _inst_1) (Int.cast.{u2} R (Ring.toIntCast.{u2} R (DivisionRing.toRing.{u2} R _inst_1)) n)) x)) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_1)))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_1))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (Module.toMulActionWithZero.{u2, u1} R M (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))))) (Inv.inv.{u2} R (DivisionRing.toInv.{u2} R _inst_1) (Int.cast.{u2} R (Ring.toIntCast.{u2} R (DivisionRing.toRing.{u2} R _inst_1)) n)) (Star.star.{u1} M (InvolutiveStar.toStar.{u1} M (StarAddMonoid.toInvolutiveStar.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))) _inst_4)) x))
Case conversion may be inaccurate. Consider using '#align star_inv_int_cast_smul star_inv_int_cast_smulₓ'. -/
@[simp]
theorem star_inv_int_cast_smul [DivisionRing R] [AddCommGroup M] [Module R M] [StarAddMonoid M]
    (n : ℤ) (x : M) : star ((n⁻¹ : R) • x) = (n⁻¹ : R) • star x :=
  map_inv_int_cast_smul (starAddEquiv : M ≃+ M) R R n x
#align star_inv_int_cast_smul star_inv_int_cast_smul

/- warning: star_rat_cast_smul -> star_rat_cast_smul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : DivisionRing.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] [_inst_4 : StarAddMonoid.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))] (n : Rat) (x : M), Eq.{succ u2} M (Star.star.{u2} M (InvolutiveStar.toHasStar.{u2} M (StarAddMonoid.toHasInvolutiveStar.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))) _inst_4)) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Rat R (HasLiftT.mk.{1, succ u1} Rat R (CoeTCₓ.coe.{1, succ u1} Rat R (Rat.castCoe.{u1} R (DivisionRing.toHasRatCast.{u1} R _inst_1)))) n) x)) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Rat R (HasLiftT.mk.{1, succ u1} Rat R (CoeTCₓ.coe.{1, succ u1} Rat R (Rat.castCoe.{u1} R (DivisionRing.toHasRatCast.{u1} R _inst_1)))) n) (Star.star.{u2} M (InvolutiveStar.toHasStar.{u2} M (StarAddMonoid.toHasInvolutiveStar.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))) _inst_4)) x))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : DivisionRing.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_3 : Module.{u2, u1} R M (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] [_inst_4 : StarAddMonoid.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2)))] (n : Rat) (x : M), Eq.{succ u1} M (Star.star.{u1} M (InvolutiveStar.toStar.{u1} M (StarAddMonoid.toInvolutiveStar.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))) _inst_4)) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_1)))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_1))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (Module.toMulActionWithZero.{u2, u1} R M (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))))) (Rat.cast.{u2} R (DivisionRing.toRatCast.{u2} R _inst_1) n) x)) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_1)))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_1))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (Module.toMulActionWithZero.{u2, u1} R M (DivisionSemiring.toSemiring.{u2} R (DivisionRing.toDivisionSemiring.{u2} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))))) (Rat.cast.{u2} R (DivisionRing.toRatCast.{u2} R _inst_1) n) (Star.star.{u1} M (InvolutiveStar.toStar.{u1} M (StarAddMonoid.toInvolutiveStar.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))) _inst_4)) x))
Case conversion may be inaccurate. Consider using '#align star_rat_cast_smul star_rat_cast_smulₓ'. -/
@[simp]
theorem star_rat_cast_smul [DivisionRing R] [AddCommGroup M] [Module R M] [StarAddMonoid M] (n : ℚ)
    (x : M) : star ((n : R) • x) = (n : R) • star x :=
  map_rat_cast_smul (starAddEquiv : M ≃+ M) _ _ _ x
#align star_rat_cast_smul star_rat_cast_smul

#print star_rat_smul /-
@[simp]
theorem star_rat_smul {R : Type _} [AddCommGroup R] [StarAddMonoid R] [Module ℚ R] (x : R) (n : ℚ) :
    star (n • x) = n • star x :=
  map_rat_smul (starAddEquiv : R ≃+ R) _ _
#align star_rat_smul star_rat_smul
-/

end SmulLemmas

#print starLinearEquiv /-
/-- If `A` is a module over a commutative `R` with compatible actions,
then `star` is a semilinear equivalence. -/
@[simps]
def starLinearEquiv (R : Type _) {A : Type _} [CommRing R] [StarRing R] [Semiring A] [StarRing A]
    [Module R A] [StarModule R A] : A ≃ₗ⋆[R] A :=
  { starAddEquiv with
    toFun := star
    map_smul' := star_smul }
#align star_linear_equiv starLinearEquiv
-/

variable (R : Type _) (A : Type _) [Semiring R] [StarSemigroup R] [TrivialStar R] [AddCommGroup A]
  [Module R A] [StarAddMonoid A] [StarModule R A]

#print selfAdjoint.submodule /-
/-- The self-adjoint elements of a star module, as a submodule. -/
def selfAdjoint.submodule : Submodule R A :=
  { selfAdjoint A with smul_mem' := fun r x => (IsSelfAdjoint.all _).smul }
#align self_adjoint.submodule selfAdjoint.submodule
-/

#print skewAdjoint.submodule /-
/-- The skew-adjoint elements of a star module, as a submodule. -/
def skewAdjoint.submodule : Submodule R A :=
  { skewAdjoint A with smul_mem' := skewAdjoint.smul_mem }
#align skew_adjoint.submodule skewAdjoint.submodule
-/

variable {A} [Invertible (2 : R)]

/- warning: self_adjoint_part -> selfAdjointPart is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {A : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : StarSemigroup.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1)))] [_inst_3 : TrivialStar.{u1} R (InvolutiveStar.toHasStar.{u1} R (StarSemigroup.toHasInvolutiveStar.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1))) _inst_2))] [_inst_4 : AddCommGroup.{u2} A] [_inst_5 : Module.{u1, u2} R A _inst_1 (AddCommGroup.toAddCommMonoid.{u2} A _inst_4)] [_inst_6 : StarAddMonoid.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)))] [_inst_7 : StarModule.{u1, u2} R A (InvolutiveStar.toHasStar.{u1} R (StarSemigroup.toHasInvolutiveStar.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1))) _inst_2)) (InvolutiveStar.toHasStar.{u2} A (StarAddMonoid.toHasInvolutiveStar.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) _inst_6)) (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (AddCommGroup.toAddCommMonoid.{u2} A _inst_4)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (AddCommGroup.toAddCommMonoid.{u2} A _inst_4)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (AddCommGroup.toAddCommMonoid.{u2} A _inst_4)))) (Module.toMulActionWithZero.{u1, u2} R A _inst_1 (AddCommGroup.toAddCommMonoid.{u2} A _inst_4) _inst_5))))] [_inst_8 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))))], LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) A (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6)) (AddCommGroup.toAddCommMonoid.{u2} A _inst_4) (AddCommGroup.toAddCommMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6)) (AddSubgroup.toAddCommGroup.{u2} A _inst_4 (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6))) _inst_5 (selfAdjoint.module.{u1, u2} R A (InvolutiveStar.toHasStar.{u1} R (StarSemigroup.toHasInvolutiveStar.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1))) _inst_2)) _inst_3 _inst_4 _inst_6 _inst_1 _inst_5 _inst_7)
but is expected to have type
  forall (R : Type.{u1}) {A : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : StarSemigroup.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1)))] [_inst_3 : TrivialStar.{u1} R (InvolutiveStar.toStar.{u1} R (StarSemigroup.toInvolutiveStar.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1))) _inst_2))] [_inst_4 : AddCommGroup.{u2} A] [_inst_5 : Module.{u1, u2} R A _inst_1 (AddCommGroup.toAddCommMonoid.{u2} A _inst_4)] [_inst_6 : StarAddMonoid.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)))] [_inst_7 : StarModule.{u1, u2} R A (InvolutiveStar.toStar.{u1} R (StarSemigroup.toInvolutiveStar.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1))) _inst_2)) (InvolutiveStar.toStar.{u2} A (StarAddMonoid.toInvolutiveStar.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) _inst_6)) (SMulZeroClass.toSMul.{u1, u2} R A (NegZeroClass.toZero.{u2} A (SubNegZeroMonoid.toNegZeroClass.{u2} A (SubtractionMonoid.toSubNegZeroMonoid.{u2} A (SubtractionCommMonoid.toSubtractionMonoid.{u2} A (AddCommGroup.toDivisionAddCommMonoid.{u2} A _inst_4))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R A (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (NegZeroClass.toZero.{u2} A (SubNegZeroMonoid.toNegZeroClass.{u2} A (SubtractionMonoid.toSubNegZeroMonoid.{u2} A (SubtractionCommMonoid.toSubtractionMonoid.{u2} A (AddCommGroup.toDivisionAddCommMonoid.{u2} A _inst_4))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R _inst_1) (NegZeroClass.toZero.{u2} A (SubNegZeroMonoid.toNegZeroClass.{u2} A (SubtractionMonoid.toSubNegZeroMonoid.{u2} A (SubtractionCommMonoid.toSubtractionMonoid.{u2} A (AddCommGroup.toDivisionAddCommMonoid.{u2} A _inst_4))))) (Module.toMulActionWithZero.{u1, u2} R A _inst_1 (AddCommGroup.toAddCommMonoid.{u2} A _inst_4) _inst_5))))] [_inst_8 : Invertible.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toOne.{u1} R _inst_1) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R _inst_1) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))], LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) A (Subtype.{succ u2} A (fun (x : A) => Membership.mem.{u2, u2} A (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.instSetLikeAddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) x (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6))) (AddCommGroup.toAddCommMonoid.{u2} A _inst_4) (AddSubmonoid.toAddCommMonoid.{u2} A (AddCommGroup.toAddCommMonoid.{u2} A _inst_4) (AddSubgroup.toAddSubmonoid.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6))) _inst_5 (selfAdjoint.instModuleSubtypeMemAddSubgroupToAddGroupInstMembershipInstSetLikeAddSubgroupSelfAdjointToAddCommMonoidToAddCommMonoidToAddSubmonoid.{u1, u2} R A (InvolutiveStar.toStar.{u1} R (StarSemigroup.toInvolutiveStar.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1))) _inst_2)) _inst_3 _inst_4 _inst_6 _inst_1 _inst_5 _inst_7)
Case conversion may be inaccurate. Consider using '#align self_adjoint_part selfAdjointPartₓ'. -/
/-- The self-adjoint part of an element of a star module, as a linear map. -/
@[simps]
def selfAdjointPart : A →ₗ[R] selfAdjoint A
    where
  toFun x :=
    ⟨(⅟ 2 : R) • (x + star x), by
      simp only [selfAdjoint.mem_iff, star_smul, add_comm, StarAddMonoid.star_add, star_inv',
        star_bit0, star_one, star_star, star_invOf (2 : R), star_trivial]⟩
  map_add' x y := by
    ext
    simp [add_add_add_comm]
  map_smul' r x := by
    ext
    simp [← mul_smul, show ⅟ 2 * r = r * ⅟ 2 from Commute.invOf_left (Commute.one_left r).bit0_left]
#align self_adjoint_part selfAdjointPart

/- warning: skew_adjoint_part -> skewAdjointPart is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {A : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : StarSemigroup.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1)))] [_inst_3 : TrivialStar.{u1} R (InvolutiveStar.toHasStar.{u1} R (StarSemigroup.toHasInvolutiveStar.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1))) _inst_2))] [_inst_4 : AddCommGroup.{u2} A] [_inst_5 : Module.{u1, u2} R A _inst_1 (AddCommGroup.toAddCommMonoid.{u2} A _inst_4)] [_inst_6 : StarAddMonoid.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)))] [_inst_7 : StarModule.{u1, u2} R A (InvolutiveStar.toHasStar.{u1} R (StarSemigroup.toHasInvolutiveStar.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1))) _inst_2)) (InvolutiveStar.toHasStar.{u2} A (StarAddMonoid.toHasInvolutiveStar.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) _inst_6)) (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (AddCommGroup.toAddCommMonoid.{u2} A _inst_4)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (AddCommGroup.toAddCommMonoid.{u2} A _inst_4)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (AddCommGroup.toAddCommMonoid.{u2} A _inst_4)))) (Module.toMulActionWithZero.{u1, u2} R A _inst_1 (AddCommGroup.toAddCommMonoid.{u2} A _inst_4) _inst_5))))] [_inst_8 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))))], LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) A (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (skewAdjoint.{u2} A _inst_4 _inst_6)) (AddCommGroup.toAddCommMonoid.{u2} A _inst_4) (AddCommGroup.toAddCommMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (skewAdjoint.{u2} A _inst_4 _inst_6)) (AddSubgroup.toAddCommGroup.{u2} A _inst_4 (skewAdjoint.{u2} A _inst_4 _inst_6))) _inst_5 (skewAdjoint.module.{u1, u2} R A (InvolutiveStar.toHasStar.{u1} R (StarSemigroup.toHasInvolutiveStar.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1))) _inst_2)) _inst_3 _inst_4 _inst_6 _inst_1 _inst_5 _inst_7)
but is expected to have type
  forall (R : Type.{u1}) {A : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : StarSemigroup.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1)))] [_inst_3 : TrivialStar.{u1} R (InvolutiveStar.toStar.{u1} R (StarSemigroup.toInvolutiveStar.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1))) _inst_2))] [_inst_4 : AddCommGroup.{u2} A] [_inst_5 : Module.{u1, u2} R A _inst_1 (AddCommGroup.toAddCommMonoid.{u2} A _inst_4)] [_inst_6 : StarAddMonoid.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)))] [_inst_7 : StarModule.{u1, u2} R A (InvolutiveStar.toStar.{u1} R (StarSemigroup.toInvolutiveStar.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1))) _inst_2)) (InvolutiveStar.toStar.{u2} A (StarAddMonoid.toInvolutiveStar.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) _inst_6)) (SMulZeroClass.toSMul.{u1, u2} R A (NegZeroClass.toZero.{u2} A (SubNegZeroMonoid.toNegZeroClass.{u2} A (SubtractionMonoid.toSubNegZeroMonoid.{u2} A (SubtractionCommMonoid.toSubtractionMonoid.{u2} A (AddCommGroup.toDivisionAddCommMonoid.{u2} A _inst_4))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R A (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (NegZeroClass.toZero.{u2} A (SubNegZeroMonoid.toNegZeroClass.{u2} A (SubtractionMonoid.toSubNegZeroMonoid.{u2} A (SubtractionCommMonoid.toSubtractionMonoid.{u2} A (AddCommGroup.toDivisionAddCommMonoid.{u2} A _inst_4))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R _inst_1) (NegZeroClass.toZero.{u2} A (SubNegZeroMonoid.toNegZeroClass.{u2} A (SubtractionMonoid.toSubNegZeroMonoid.{u2} A (SubtractionCommMonoid.toSubtractionMonoid.{u2} A (AddCommGroup.toDivisionAddCommMonoid.{u2} A _inst_4))))) (Module.toMulActionWithZero.{u1, u2} R A _inst_1 (AddCommGroup.toAddCommMonoid.{u2} A _inst_4) _inst_5))))] [_inst_8 : Invertible.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toOne.{u1} R _inst_1) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R _inst_1) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))], LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) A (Subtype.{succ u2} A (fun (x : A) => Membership.mem.{u2, u2} A (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.instSetLikeAddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) x (skewAdjoint.{u2} A _inst_4 _inst_6))) (AddCommGroup.toAddCommMonoid.{u2} A _inst_4) (AddSubmonoid.toAddCommMonoid.{u2} A (AddCommGroup.toAddCommMonoid.{u2} A _inst_4) (AddSubgroup.toAddSubmonoid.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) (skewAdjoint.{u2} A _inst_4 _inst_6))) _inst_5 (skewAdjoint.instModuleSubtypeMemAddSubgroupToAddGroupInstMembershipInstSetLikeAddSubgroupSkewAdjointToAddCommMonoidToAddCommMonoidToAddSubmonoid.{u1, u2} R A (InvolutiveStar.toStar.{u1} R (StarSemigroup.toInvolutiveStar.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1))) _inst_2)) _inst_3 _inst_4 _inst_6 _inst_1 _inst_5 _inst_7)
Case conversion may be inaccurate. Consider using '#align skew_adjoint_part skewAdjointPartₓ'. -/
/-- The skew-adjoint part of an element of a star module, as a linear map. -/
@[simps]
def skewAdjointPart : A →ₗ[R] skewAdjoint A
    where
  toFun x :=
    ⟨(⅟ 2 : R) • (x - star x), by
      simp only [skewAdjoint.mem_iff, star_smul, star_sub, star_star, star_trivial, ← smul_neg,
        neg_sub]⟩
  map_add' x y := by
    ext
    simp only [sub_add, ← smul_add, sub_sub_eq_add_sub, star_add, AddSubgroup.coe_mk,
      AddSubgroup.coe_add]
  map_smul' r x := by
    ext
    simp [← mul_smul, ← smul_sub,
      show r * ⅟ 2 = ⅟ 2 * r from Commute.invOf_right (Commute.one_right r).bit0_right]
#align skew_adjoint_part skewAdjointPart

/- warning: star_module.self_adjoint_part_add_skew_adjoint_part -> StarModule.selfAdjointPart_add_skewAdjointPart is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {A : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : StarSemigroup.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1)))] [_inst_3 : TrivialStar.{u1} R (InvolutiveStar.toHasStar.{u1} R (StarSemigroup.toHasInvolutiveStar.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1))) _inst_2))] [_inst_4 : AddCommGroup.{u2} A] [_inst_5 : Module.{u1, u2} R A _inst_1 (AddCommGroup.toAddCommMonoid.{u2} A _inst_4)] [_inst_6 : StarAddMonoid.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)))] [_inst_7 : StarModule.{u1, u2} R A (InvolutiveStar.toHasStar.{u1} R (StarSemigroup.toHasInvolutiveStar.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1))) _inst_2)) (InvolutiveStar.toHasStar.{u2} A (StarAddMonoid.toHasInvolutiveStar.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) _inst_6)) (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (AddCommGroup.toAddCommMonoid.{u2} A _inst_4)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (AddCommGroup.toAddCommMonoid.{u2} A _inst_4)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (AddCommGroup.toAddCommMonoid.{u2} A _inst_4)))) (Module.toMulActionWithZero.{u1, u2} R A _inst_1 (AddCommGroup.toAddCommMonoid.{u2} A _inst_4) _inst_5))))] [_inst_8 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))))] (x : A), Eq.{succ u2} A (HAdd.hAdd.{u2, u2, u2} A A A (instHAdd.{u2} A (AddZeroClass.toHasAdd.{u2} A (AddMonoid.toAddZeroClass.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)))))) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6)) A (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6)) A (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6)) A (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6)) A (coeSubtype.{succ u2} A (fun (x : A) => Membership.Mem.{u2, u2} A (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) (SetLike.hasMem.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) x (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6)))))) (coeFn.{succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) A (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6)) (AddCommGroup.toAddCommMonoid.{u2} A _inst_4) (AddCommGroup.toAddCommMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6)) (AddSubgroup.toAddCommGroup.{u2} A _inst_4 (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6))) _inst_5 (selfAdjoint.module.{u1, u2} R A (InvolutiveStar.toHasStar.{u1} R (StarSemigroup.toHasInvolutiveStar.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1))) _inst_2)) _inst_3 _inst_4 _inst_6 _inst_1 _inst_5 _inst_7)) (fun (_x : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) A (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6)) (AddCommGroup.toAddCommMonoid.{u2} A _inst_4) (AddCommGroup.toAddCommMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6)) (AddSubgroup.toAddCommGroup.{u2} A _inst_4 (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6))) _inst_5 (selfAdjoint.module.{u1, u2} R A (InvolutiveStar.toHasStar.{u1} R (StarSemigroup.toHasInvolutiveStar.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1))) _inst_2)) _inst_3 _inst_4 _inst_6 _inst_1 _inst_5 _inst_7)) => A -> (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6))) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R A (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6)) _inst_1 _inst_1 (AddCommGroup.toAddCommMonoid.{u2} A _inst_4) (AddCommGroup.toAddCommMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6)) (AddSubgroup.toAddCommGroup.{u2} A _inst_4 (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6))) _inst_5 (selfAdjoint.module.{u1, u2} R A (InvolutiveStar.toHasStar.{u1} R (StarSemigroup.toHasInvolutiveStar.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1))) _inst_2)) _inst_3 _inst_4 _inst_6 _inst_1 _inst_5 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (selfAdjointPart.{u1, u2} R A _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8) x)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (skewAdjoint.{u2} A _inst_4 _inst_6)) A (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (skewAdjoint.{u2} A _inst_4 _inst_6)) A (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (skewAdjoint.{u2} A _inst_4 _inst_6)) A (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (skewAdjoint.{u2} A _inst_4 _inst_6)) A (coeSubtype.{succ u2} A (fun (x : A) => Membership.Mem.{u2, u2} A (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) (SetLike.hasMem.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) x (skewAdjoint.{u2} A _inst_4 _inst_6)))))) (coeFn.{succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) A (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (skewAdjoint.{u2} A _inst_4 _inst_6)) (AddCommGroup.toAddCommMonoid.{u2} A _inst_4) (AddCommGroup.toAddCommMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (skewAdjoint.{u2} A _inst_4 _inst_6)) (AddSubgroup.toAddCommGroup.{u2} A _inst_4 (skewAdjoint.{u2} A _inst_4 _inst_6))) _inst_5 (skewAdjoint.module.{u1, u2} R A (InvolutiveStar.toHasStar.{u1} R (StarSemigroup.toHasInvolutiveStar.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1))) _inst_2)) _inst_3 _inst_4 _inst_6 _inst_1 _inst_5 _inst_7)) (fun (_x : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) A (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (skewAdjoint.{u2} A _inst_4 _inst_6)) (AddCommGroup.toAddCommMonoid.{u2} A _inst_4) (AddCommGroup.toAddCommMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (skewAdjoint.{u2} A _inst_4 _inst_6)) (AddSubgroup.toAddCommGroup.{u2} A _inst_4 (skewAdjoint.{u2} A _inst_4 _inst_6))) _inst_5 (skewAdjoint.module.{u1, u2} R A (InvolutiveStar.toHasStar.{u1} R (StarSemigroup.toHasInvolutiveStar.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1))) _inst_2)) _inst_3 _inst_4 _inst_6 _inst_1 _inst_5 _inst_7)) => A -> (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (skewAdjoint.{u2} A _inst_4 _inst_6))) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R A (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (skewAdjoint.{u2} A _inst_4 _inst_6)) _inst_1 _inst_1 (AddCommGroup.toAddCommMonoid.{u2} A _inst_4) (AddCommGroup.toAddCommMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (skewAdjoint.{u2} A _inst_4 _inst_6)) (AddSubgroup.toAddCommGroup.{u2} A _inst_4 (skewAdjoint.{u2} A _inst_4 _inst_6))) _inst_5 (skewAdjoint.module.{u1, u2} R A (InvolutiveStar.toHasStar.{u1} R (StarSemigroup.toHasInvolutiveStar.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1))) _inst_2)) _inst_3 _inst_4 _inst_6 _inst_1 _inst_5 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (skewAdjointPart.{u1, u2} R A _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8) x))) x
but is expected to have type
  forall (R : Type.{u1}) {A : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : StarSemigroup.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1)))] [_inst_3 : TrivialStar.{u1} R (InvolutiveStar.toStar.{u1} R (StarSemigroup.toInvolutiveStar.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1))) _inst_2))] [_inst_4 : AddCommGroup.{u2} A] [_inst_5 : Module.{u1, u2} R A _inst_1 (AddCommGroup.toAddCommMonoid.{u2} A _inst_4)] [_inst_6 : StarAddMonoid.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)))] [_inst_7 : StarModule.{u1, u2} R A (InvolutiveStar.toStar.{u1} R (StarSemigroup.toInvolutiveStar.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1))) _inst_2)) (InvolutiveStar.toStar.{u2} A (StarAddMonoid.toInvolutiveStar.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) _inst_6)) (SMulZeroClass.toSMul.{u1, u2} R A (NegZeroClass.toZero.{u2} A (SubNegZeroMonoid.toNegZeroClass.{u2} A (SubtractionMonoid.toSubNegZeroMonoid.{u2} A (SubtractionCommMonoid.toSubtractionMonoid.{u2} A (AddCommGroup.toDivisionAddCommMonoid.{u2} A _inst_4))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R A (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (NegZeroClass.toZero.{u2} A (SubNegZeroMonoid.toNegZeroClass.{u2} A (SubtractionMonoid.toSubNegZeroMonoid.{u2} A (SubtractionCommMonoid.toSubtractionMonoid.{u2} A (AddCommGroup.toDivisionAddCommMonoid.{u2} A _inst_4))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R _inst_1) (NegZeroClass.toZero.{u2} A (SubNegZeroMonoid.toNegZeroClass.{u2} A (SubtractionMonoid.toSubNegZeroMonoid.{u2} A (SubtractionCommMonoid.toSubtractionMonoid.{u2} A (AddCommGroup.toDivisionAddCommMonoid.{u2} A _inst_4))))) (Module.toMulActionWithZero.{u1, u2} R A _inst_1 (AddCommGroup.toAddCommMonoid.{u2} A _inst_4) _inst_5))))] [_inst_8 : Invertible.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toOne.{u1} R _inst_1) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R _inst_1) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] (x : A), Eq.{succ u2} A (HAdd.hAdd.{u2, u2, u2} A A A (instHAdd.{u2} A (AddZeroClass.toAdd.{u2} A (AddMonoid.toAddZeroClass.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)))))) (Subtype.val.{succ u2} A (fun (x : A) => Membership.mem.{u2, u2} A (Set.{u2} A) (Set.instMembershipSet.{u2} A) x (SetLike.coe.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.instSetLikeAddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6))) (FunLike.coe.{succ u2, succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) A (Subtype.{succ u2} A (fun (x : A) => Membership.mem.{u2, u2} A (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.instSetLikeAddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) x (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6))) (AddCommGroup.toAddCommMonoid.{u2} A _inst_4) (AddSubmonoid.toAddCommMonoid.{u2} A (AddCommGroup.toAddCommMonoid.{u2} A _inst_4) (AddSubgroup.toAddSubmonoid.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6))) _inst_5 (selfAdjoint.instModuleSubtypeMemAddSubgroupToAddGroupInstMembershipInstSetLikeAddSubgroupSelfAdjointToAddCommMonoidToAddCommMonoidToAddSubmonoid.{u1, u2} R A (InvolutiveStar.toStar.{u1} R (StarSemigroup.toInvolutiveStar.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1))) _inst_2)) _inst_3 _inst_4 _inst_6 _inst_1 _inst_5 _inst_7)) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : A) => Subtype.{succ u2} A (fun (x : A) => Membership.mem.{u2, u2} A (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.instSetLikeAddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) x (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6))) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} R R A (Subtype.{succ u2} A (fun (x : A) => Membership.mem.{u2, u2} A (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.instSetLikeAddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) x (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6))) _inst_1 _inst_1 (AddCommGroup.toAddCommMonoid.{u2} A _inst_4) (AddSubmonoid.toAddCommMonoid.{u2} A (AddCommGroup.toAddCommMonoid.{u2} A _inst_4) (AddSubgroup.toAddSubmonoid.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6))) _inst_5 (selfAdjoint.instModuleSubtypeMemAddSubgroupToAddGroupInstMembershipInstSetLikeAddSubgroupSelfAdjointToAddCommMonoidToAddCommMonoidToAddSubmonoid.{u1, u2} R A (InvolutiveStar.toStar.{u1} R (StarSemigroup.toInvolutiveStar.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1))) _inst_2)) _inst_3 _inst_4 _inst_6 _inst_1 _inst_5 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (selfAdjointPart.{u1, u2} R A _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8) x)) (Subtype.val.{succ u2} A (fun (x : A) => Membership.mem.{u2, u2} A (Set.{u2} A) (Set.instMembershipSet.{u2} A) x (SetLike.coe.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.instSetLikeAddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) (skewAdjoint.{u2} A _inst_4 _inst_6))) (FunLike.coe.{succ u2, succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) A (Subtype.{succ u2} A (fun (x : A) => Membership.mem.{u2, u2} A (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.instSetLikeAddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) x (skewAdjoint.{u2} A _inst_4 _inst_6))) (AddCommGroup.toAddCommMonoid.{u2} A _inst_4) (AddSubmonoid.toAddCommMonoid.{u2} A (AddCommGroup.toAddCommMonoid.{u2} A _inst_4) (AddSubgroup.toAddSubmonoid.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) (skewAdjoint.{u2} A _inst_4 _inst_6))) _inst_5 (skewAdjoint.instModuleSubtypeMemAddSubgroupToAddGroupInstMembershipInstSetLikeAddSubgroupSkewAdjointToAddCommMonoidToAddCommMonoidToAddSubmonoid.{u1, u2} R A (InvolutiveStar.toStar.{u1} R (StarSemigroup.toInvolutiveStar.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1))) _inst_2)) _inst_3 _inst_4 _inst_6 _inst_1 _inst_5 _inst_7)) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : A) => Subtype.{succ u2} A (fun (x : A) => Membership.mem.{u2, u2} A (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.instSetLikeAddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) x (skewAdjoint.{u2} A _inst_4 _inst_6))) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} R R A (Subtype.{succ u2} A (fun (x : A) => Membership.mem.{u2, u2} A (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.instSetLikeAddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) x (skewAdjoint.{u2} A _inst_4 _inst_6))) _inst_1 _inst_1 (AddCommGroup.toAddCommMonoid.{u2} A _inst_4) (AddSubmonoid.toAddCommMonoid.{u2} A (AddCommGroup.toAddCommMonoid.{u2} A _inst_4) (AddSubgroup.toAddSubmonoid.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) (skewAdjoint.{u2} A _inst_4 _inst_6))) _inst_5 (skewAdjoint.instModuleSubtypeMemAddSubgroupToAddGroupInstMembershipInstSetLikeAddSubgroupSkewAdjointToAddCommMonoidToAddCommMonoidToAddSubmonoid.{u1, u2} R A (InvolutiveStar.toStar.{u1} R (StarSemigroup.toInvolutiveStar.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1))) _inst_2)) _inst_3 _inst_4 _inst_6 _inst_1 _inst_5 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (skewAdjointPart.{u1, u2} R A _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8) x))) x
Case conversion may be inaccurate. Consider using '#align star_module.self_adjoint_part_add_skew_adjoint_part StarModule.selfAdjointPart_add_skewAdjointPartₓ'. -/
theorem StarModule.selfAdjointPart_add_skewAdjointPart (x : A) :
    (selfAdjointPart R x : A) + skewAdjointPart R x = x := by
  simp only [smul_sub, selfAdjointPart_apply_coe, smul_add, skewAdjointPart_apply_coe,
    add_add_sub_cancel, invOf_two_smul_add_invOf_two_smul]
#align star_module.self_adjoint_part_add_skew_adjoint_part StarModule.selfAdjointPart_add_skewAdjointPart

variable (A)

/- warning: star_module.decompose_prod_adjoint -> StarModule.decomposeProdAdjoint is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (A : Type.{u2}) [_inst_1 : Semiring.{u1} R] [_inst_2 : StarSemigroup.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1)))] [_inst_3 : TrivialStar.{u1} R (InvolutiveStar.toHasStar.{u1} R (StarSemigroup.toHasInvolutiveStar.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1))) _inst_2))] [_inst_4 : AddCommGroup.{u2} A] [_inst_5 : Module.{u1, u2} R A _inst_1 (AddCommGroup.toAddCommMonoid.{u2} A _inst_4)] [_inst_6 : StarAddMonoid.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)))] [_inst_7 : StarModule.{u1, u2} R A (InvolutiveStar.toHasStar.{u1} R (StarSemigroup.toHasInvolutiveStar.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1))) _inst_2)) (InvolutiveStar.toHasStar.{u2} A (StarAddMonoid.toHasInvolutiveStar.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) _inst_6)) (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (AddCommGroup.toAddCommMonoid.{u2} A _inst_4)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (AddCommGroup.toAddCommMonoid.{u2} A _inst_4)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (AddCommGroup.toAddCommMonoid.{u2} A _inst_4)))) (Module.toMulActionWithZero.{u1, u2} R A _inst_1 (AddCommGroup.toAddCommMonoid.{u2} A _inst_4) _inst_5))))] [_inst_8 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))))], LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) A (Prod.{u2, u2} (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6)) (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (skewAdjoint.{u2} A _inst_4 _inst_6))) (AddCommGroup.toAddCommMonoid.{u2} A _inst_4) (Prod.addCommMonoid.{u2, u2} (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6)) (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (skewAdjoint.{u2} A _inst_4 _inst_6)) (AddCommGroup.toAddCommMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6)) (AddSubgroup.toAddCommGroup.{u2} A _inst_4 (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6))) (AddCommGroup.toAddCommMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (skewAdjoint.{u2} A _inst_4 _inst_6)) (AddSubgroup.toAddCommGroup.{u2} A _inst_4 (skewAdjoint.{u2} A _inst_4 _inst_6)))) _inst_5 (Prod.module.{u1, u2, u2} R (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6)) (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (skewAdjoint.{u2} A _inst_4 _inst_6)) _inst_1 (AddCommGroup.toAddCommMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6)) (AddSubgroup.toAddCommGroup.{u2} A _inst_4 (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6))) (AddCommGroup.toAddCommMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.setLike.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) (skewAdjoint.{u2} A _inst_4 _inst_6)) (AddSubgroup.toAddCommGroup.{u2} A _inst_4 (skewAdjoint.{u2} A _inst_4 _inst_6))) (selfAdjoint.module.{u1, u2} R A (InvolutiveStar.toHasStar.{u1} R (StarSemigroup.toHasInvolutiveStar.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1))) _inst_2)) _inst_3 _inst_4 _inst_6 _inst_1 _inst_5 _inst_7) (skewAdjoint.module.{u1, u2} R A (InvolutiveStar.toHasStar.{u1} R (StarSemigroup.toHasInvolutiveStar.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1))) _inst_2)) _inst_3 _inst_4 _inst_6 _inst_1 _inst_5 _inst_7))
but is expected to have type
  forall (R : Type.{u1}) (A : Type.{u2}) [_inst_1 : Semiring.{u1} R] [_inst_2 : StarSemigroup.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1)))] [_inst_3 : TrivialStar.{u1} R (InvolutiveStar.toStar.{u1} R (StarSemigroup.toInvolutiveStar.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1))) _inst_2))] [_inst_4 : AddCommGroup.{u2} A] [_inst_5 : Module.{u1, u2} R A _inst_1 (AddCommGroup.toAddCommMonoid.{u2} A _inst_4)] [_inst_6 : StarAddMonoid.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)))] [_inst_7 : StarModule.{u1, u2} R A (InvolutiveStar.toStar.{u1} R (StarSemigroup.toInvolutiveStar.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1))) _inst_2)) (InvolutiveStar.toStar.{u2} A (StarAddMonoid.toInvolutiveStar.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) _inst_6)) (SMulZeroClass.toSMul.{u1, u2} R A (NegZeroClass.toZero.{u2} A (SubNegZeroMonoid.toNegZeroClass.{u2} A (SubtractionMonoid.toSubNegZeroMonoid.{u2} A (SubtractionCommMonoid.toSubtractionMonoid.{u2} A (AddCommGroup.toDivisionAddCommMonoid.{u2} A _inst_4))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R A (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (NegZeroClass.toZero.{u2} A (SubNegZeroMonoid.toNegZeroClass.{u2} A (SubtractionMonoid.toSubNegZeroMonoid.{u2} A (SubtractionCommMonoid.toSubtractionMonoid.{u2} A (AddCommGroup.toDivisionAddCommMonoid.{u2} A _inst_4))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R _inst_1) (NegZeroClass.toZero.{u2} A (SubNegZeroMonoid.toNegZeroClass.{u2} A (SubtractionMonoid.toSubNegZeroMonoid.{u2} A (SubtractionCommMonoid.toSubtractionMonoid.{u2} A (AddCommGroup.toDivisionAddCommMonoid.{u2} A _inst_4))))) (Module.toMulActionWithZero.{u1, u2} R A _inst_1 (AddCommGroup.toAddCommMonoid.{u2} A _inst_4) _inst_5))))] [_inst_8 : Invertible.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toOne.{u1} R _inst_1) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R _inst_1) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))], LinearEquiv.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) A (Prod.{u2, u2} (Subtype.{succ u2} A (fun (x : A) => Membership.mem.{u2, u2} A (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.instSetLikeAddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) x (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6))) (Subtype.{succ u2} A (fun (x : A) => Membership.mem.{u2, u2} A (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.instSetLikeAddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) x (skewAdjoint.{u2} A _inst_4 _inst_6)))) (AddCommGroup.toAddCommMonoid.{u2} A _inst_4) (Prod.instAddCommMonoidSum.{u2, u2} (Subtype.{succ u2} A (fun (x : A) => Membership.mem.{u2, u2} A (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.instSetLikeAddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) x (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6))) (Subtype.{succ u2} A (fun (x : A) => Membership.mem.{u2, u2} A (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.instSetLikeAddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) x (skewAdjoint.{u2} A _inst_4 _inst_6))) (AddSubmonoid.toAddCommMonoid.{u2} A (AddCommGroup.toAddCommMonoid.{u2} A _inst_4) (AddSubgroup.toAddSubmonoid.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6))) (AddSubmonoid.toAddCommMonoid.{u2} A (AddCommGroup.toAddCommMonoid.{u2} A _inst_4) (AddSubgroup.toAddSubmonoid.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) (skewAdjoint.{u2} A _inst_4 _inst_6)))) _inst_5 (Prod.module.{u1, u2, u2} R (Subtype.{succ u2} A (fun (x : A) => Membership.mem.{u2, u2} A (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.instSetLikeAddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) x (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6))) (Subtype.{succ u2} A (fun (x : A) => Membership.mem.{u2, u2} A (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4)) A (AddSubgroup.instSetLikeAddSubgroup.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4))) x (skewAdjoint.{u2} A _inst_4 _inst_6))) _inst_1 (AddSubmonoid.toAddCommMonoid.{u2} A (AddCommGroup.toAddCommMonoid.{u2} A _inst_4) (AddSubgroup.toAddSubmonoid.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) (selfAdjoint.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) _inst_6))) (AddSubmonoid.toAddCommMonoid.{u2} A (AddCommGroup.toAddCommMonoid.{u2} A _inst_4) (AddSubgroup.toAddSubmonoid.{u2} A (AddCommGroup.toAddGroup.{u2} A _inst_4) (skewAdjoint.{u2} A _inst_4 _inst_6))) (selfAdjoint.instModuleSubtypeMemAddSubgroupToAddGroupInstMembershipInstSetLikeAddSubgroupSelfAdjointToAddCommMonoidToAddCommMonoidToAddSubmonoid.{u1, u2} R A (InvolutiveStar.toStar.{u1} R (StarSemigroup.toInvolutiveStar.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1))) _inst_2)) _inst_3 _inst_4 _inst_6 _inst_1 _inst_5 _inst_7) (skewAdjoint.instModuleSubtypeMemAddSubgroupToAddGroupInstMembershipInstSetLikeAddSubgroupSkewAdjointToAddCommMonoidToAddCommMonoidToAddSubmonoid.{u1, u2} R A (InvolutiveStar.toStar.{u1} R (StarSemigroup.toInvolutiveStar.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (Semiring.toNonUnitalSemiring.{u1} R _inst_1))) _inst_2)) _inst_3 _inst_4 _inst_6 _inst_1 _inst_5 _inst_7))
Case conversion may be inaccurate. Consider using '#align star_module.decompose_prod_adjoint StarModule.decomposeProdAdjointₓ'. -/
/-- The decomposition of elements of a star module into their self- and skew-adjoint parts,
as a linear equivalence. -/
@[simps]
def StarModule.decomposeProdAdjoint : A ≃ₗ[R] selfAdjoint A × skewAdjoint A :=
  LinearEquiv.ofLinear ((selfAdjointPart R).Prod (skewAdjointPart R))
    ((selfAdjoint.submodule R A).Subtype.coprod (skewAdjoint.submodule R A).Subtype)
    (by ext <;> simp) (LinearMap.ext <| StarModule.selfAdjointPart_add_skewAdjointPart R)
#align star_module.decompose_prod_adjoint StarModule.decomposeProdAdjoint

/- warning: algebra_map_star_comm -> algebraMap_star_comm is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_9 : CommSemiring.{u1} R] [_inst_10 : StarRing.{u1} R (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} R (CommSemiring.toNonUnitalCommSemiring.{u1} R _inst_9))] [_inst_11 : Semiring.{u2} A] [_inst_12 : StarSemigroup.{u2} A (SemigroupWithZero.toSemigroup.{u2} A (NonUnitalSemiring.toSemigroupWithZero.{u2} A (Semiring.toNonUnitalSemiring.{u2} A _inst_11)))] [_inst_13 : Algebra.{u1, u2} R A _inst_9 _inst_11] [_inst_14 : StarModule.{u1, u2} R A (InvolutiveStar.toHasStar.{u1} R (StarAddMonoid.toHasInvolutiveStar.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} R (CommSemiring.toNonUnitalCommSemiring.{u1} R _inst_9))))) (StarRing.toStarAddMonoid.{u1} R (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} R (CommSemiring.toNonUnitalCommSemiring.{u1} R _inst_9)) _inst_10))) (InvolutiveStar.toHasStar.{u2} A (StarSemigroup.toHasInvolutiveStar.{u2} A (SemigroupWithZero.toSemigroup.{u2} A (NonUnitalSemiring.toSemigroupWithZero.{u2} A (Semiring.toNonUnitalSemiring.{u2} A _inst_11))) _inst_12)) (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_11)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_9))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_11)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_9)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_11)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_9) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_11))) (Algebra.toModule.{u1, u2} R A _inst_9 _inst_11 _inst_13)))))] (r : R), Eq.{succ u2} A (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_9)) (Semiring.toNonAssocSemiring.{u2} A _inst_11)) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_9)) (Semiring.toNonAssocSemiring.{u2} A _inst_11)) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_9)) (Semiring.toNonAssocSemiring.{u2} A _inst_11)) (algebraMap.{u1, u2} R A _inst_9 _inst_11 _inst_13) (Star.star.{u1} R (InvolutiveStar.toHasStar.{u1} R (StarAddMonoid.toHasInvolutiveStar.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} R (CommSemiring.toNonUnitalCommSemiring.{u1} R _inst_9))))) (StarRing.toStarAddMonoid.{u1} R (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} R (CommSemiring.toNonUnitalCommSemiring.{u1} R _inst_9)) _inst_10))) r)) (Star.star.{u2} A (InvolutiveStar.toHasStar.{u2} A (StarSemigroup.toHasInvolutiveStar.{u2} A (SemigroupWithZero.toSemigroup.{u2} A (NonUnitalSemiring.toSemigroupWithZero.{u2} A (Semiring.toNonUnitalSemiring.{u2} A _inst_11))) _inst_12)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_9)) (Semiring.toNonAssocSemiring.{u2} A _inst_11)) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_9)) (Semiring.toNonAssocSemiring.{u2} A _inst_11)) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_9)) (Semiring.toNonAssocSemiring.{u2} A _inst_11)) (algebraMap.{u1, u2} R A _inst_9 _inst_11 _inst_13) r))
but is expected to have type
  forall {R : Type.{u2}} {A : Type.{u1}} [_inst_9 : CommSemiring.{u2} R] [_inst_10 : StarRing.{u2} R (NonUnitalCommSemiring.toNonUnitalSemiring.{u2} R (CommSemiring.toNonUnitalCommSemiring.{u2} R _inst_9))] [_inst_11 : Semiring.{u1} A] [_inst_12 : StarSemigroup.{u1} A (SemigroupWithZero.toSemigroup.{u1} A (NonUnitalSemiring.toSemigroupWithZero.{u1} A (Semiring.toNonUnitalSemiring.{u1} A _inst_11)))] [_inst_13 : Algebra.{u2, u1} R A _inst_9 _inst_11] [_inst_14 : StarModule.{u2, u1} R A (InvolutiveStar.toStar.{u2} R (StarAddMonoid.toInvolutiveStar.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_9))))) (StarRing.toStarAddMonoid.{u2} R (NonUnitalCommSemiring.toNonUnitalSemiring.{u2} R (CommSemiring.toNonUnitalCommSemiring.{u2} R _inst_9)) _inst_10))) (InvolutiveStar.toStar.{u1} A (StarSemigroup.toInvolutiveStar.{u1} A (SemigroupWithZero.toSemigroup.{u1} A (NonUnitalSemiring.toSemigroupWithZero.{u1} A (Semiring.toNonUnitalSemiring.{u1} A _inst_11))) _inst_12)) (Algebra.toSMul.{u2, u1} R A _inst_9 _inst_11 _inst_13)] (r : R), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) (Star.star.{u2} R (InvolutiveStar.toStar.{u2} R (StarAddMonoid.toInvolutiveStar.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_9))))) (StarRing.toStarAddMonoid.{u2} R (NonUnitalCommSemiring.toNonUnitalSemiring.{u2} R (CommSemiring.toNonUnitalCommSemiring.{u2} R _inst_9)) _inst_10))) r)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_9)) (Semiring.toNonAssocSemiring.{u1} A _inst_11)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_9)) (Semiring.toNonAssocSemiring.{u1} A _inst_11)) R A (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_9)))) (NonUnitalNonAssocSemiring.toMul.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_11))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_9)) (Semiring.toNonAssocSemiring.{u1} A _inst_11)) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_9))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_11)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_9)) (Semiring.toNonAssocSemiring.{u1} A _inst_11)) R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_9)) (Semiring.toNonAssocSemiring.{u1} A _inst_11) (RingHom.instRingHomClassRingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_9)) (Semiring.toNonAssocSemiring.{u1} A _inst_11))))) (algebraMap.{u2, u1} R A _inst_9 _inst_11 _inst_13) (Star.star.{u2} R (InvolutiveStar.toStar.{u2} R (StarAddMonoid.toInvolutiveStar.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_9))))) (StarRing.toStarAddMonoid.{u2} R (NonUnitalCommSemiring.toNonUnitalSemiring.{u2} R (CommSemiring.toNonUnitalCommSemiring.{u2} R _inst_9)) _inst_10))) r)) (Star.star.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (InvolutiveStar.toStar.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (StarSemigroup.toInvolutiveStar.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (SemigroupWithZero.toSemigroup.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (NonUnitalSemiring.toSemigroupWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (Semiring.toNonUnitalSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) _inst_11))) _inst_12)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_9)) (Semiring.toNonAssocSemiring.{u1} A _inst_11)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_9)) (Semiring.toNonAssocSemiring.{u1} A _inst_11)) R A (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_9)))) (NonUnitalNonAssocSemiring.toMul.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_11))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_9)) (Semiring.toNonAssocSemiring.{u1} A _inst_11)) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_9))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_11)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_9)) (Semiring.toNonAssocSemiring.{u1} A _inst_11)) R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_9)) (Semiring.toNonAssocSemiring.{u1} A _inst_11) (RingHom.instRingHomClassRingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_9)) (Semiring.toNonAssocSemiring.{u1} A _inst_11))))) (algebraMap.{u2, u1} R A _inst_9 _inst_11 _inst_13) r))
Case conversion may be inaccurate. Consider using '#align algebra_map_star_comm algebraMap_star_commₓ'. -/
@[simp]
theorem algebraMap_star_comm {R A : Type _} [CommSemiring R] [StarRing R] [Semiring A]
    [StarSemigroup A] [Algebra R A] [StarModule R A] (r : R) :
    algebraMap R A (star r) = star (algebraMap R A r) := by
  simp only [Algebra.algebraMap_eq_smul_one, star_smul, star_one]
#align algebra_map_star_comm algebraMap_star_comm

