/-
Copyright (c) 2022 Frédéric Dupuis. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Shing Tak Lam, Frédéric Dupuis

! This file was ported from Lean 3 source module algebra.star.unitary
! leanprover-community/mathlib commit 1f0096e6caa61e9c849ec2adbd227e960e9dff58
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Star.Basic
import Mathbin.GroupTheory.Submonoid.Operations

/-!
# Unitary elements of a star monoid

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file defines `unitary R`, where `R` is a star monoid, as the submonoid made of the elements
that satisfy `star U * U = 1` and `U * star U = 1`, and these form a group.
This includes, for instance, unitary operators on Hilbert spaces.

See also `matrix.unitary_group` for specializations to `unitary (matrix n n R)`.

## Tags

unitary
-/


#print unitary /-
/-- In a *-monoid, `unitary R` is the submonoid consisting of all the elements `U` of
`R` such that `star U * U = 1` and `U * star U = 1`.
-/
def unitary (R : Type _) [Monoid R] [StarSemigroup R] : Submonoid R
    where
  carrier := { U | star U * U = 1 ∧ U * star U = 1 }
  one_mem' := by simp only [mul_one, and_self_iff, Set.mem_setOf_eq, star_one]
  mul_mem' := fun U B ⟨hA₁, hA₂⟩ ⟨hB₁, hB₂⟩ =>
    by
    refine' ⟨_, _⟩
    ·
      calc
        star (U * B) * (U * B) = star B * star U * U * B := by simp only [mul_assoc, star_mul]
        _ = star B * (star U * U) * B := by rw [← mul_assoc]
        _ = 1 := by rw [hA₁, mul_one, hB₁]
        
    ·
      calc
        U * B * star (U * B) = U * B * (star B * star U) := by rw [star_mul]
        _ = U * (B * star B) * star U := by simp_rw [← mul_assoc]
        _ = 1 := by rw [hB₂, mul_one, hA₂]
        
#align unitary unitary
-/

variable {R : Type _}

namespace unitary

section Monoid

variable [Monoid R] [StarSemigroup R]

/- warning: unitary.mem_iff -> unitary.mem_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] [_inst_2 : StarSemigroup.{u1} R (Monoid.toSemigroup.{u1} R _inst_1)] {U : R}, Iff (Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) U (unitary.{u1} R _inst_1 _inst_2)) (And (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (Star.star.{u1} R (InvolutiveStar.toHasStar.{u1} R (StarSemigroup.toHasInvolutiveStar.{u1} R (Monoid.toSemigroup.{u1} R _inst_1) _inst_2)) U) U) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (MulOneClass.toHasOne.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)))))) (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) U (Star.star.{u1} R (InvolutiveStar.toHasStar.{u1} R (StarSemigroup.toHasInvolutiveStar.{u1} R (Monoid.toSemigroup.{u1} R _inst_1) _inst_2)) U)) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (MulOneClass.toHasOne.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] [_inst_2 : StarSemigroup.{u1} R (Monoid.toSemigroup.{u1} R _inst_1)] {U : R}, Iff (Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) U (unitary.{u1} R _inst_1 _inst_2)) (And (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (Star.star.{u1} R (InvolutiveStar.toStar.{u1} R (StarSemigroup.toInvolutiveStar.{u1} R (Monoid.toSemigroup.{u1} R _inst_1) _inst_2)) U) U) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Monoid.toOne.{u1} R _inst_1)))) (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) U (Star.star.{u1} R (InvolutiveStar.toStar.{u1} R (StarSemigroup.toInvolutiveStar.{u1} R (Monoid.toSemigroup.{u1} R _inst_1) _inst_2)) U)) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Monoid.toOne.{u1} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align unitary.mem_iff unitary.mem_iffₓ'. -/
theorem mem_iff {U : R} : U ∈ unitary R ↔ star U * U = 1 ∧ U * star U = 1 :=
  Iff.rfl
#align unitary.mem_iff unitary.mem_iff

/- warning: unitary.star_mul_self_of_mem -> unitary.star_mul_self_of_mem is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] [_inst_2 : StarSemigroup.{u1} R (Monoid.toSemigroup.{u1} R _inst_1)] {U : R}, (Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) U (unitary.{u1} R _inst_1 _inst_2)) -> (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (Star.star.{u1} R (InvolutiveStar.toHasStar.{u1} R (StarSemigroup.toHasInvolutiveStar.{u1} R (Monoid.toSemigroup.{u1} R _inst_1) _inst_2)) U) U) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (MulOneClass.toHasOne.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] [_inst_2 : StarSemigroup.{u1} R (Monoid.toSemigroup.{u1} R _inst_1)] {U : R}, (Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) U (unitary.{u1} R _inst_1 _inst_2)) -> (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (Star.star.{u1} R (InvolutiveStar.toStar.{u1} R (StarSemigroup.toInvolutiveStar.{u1} R (Monoid.toSemigroup.{u1} R _inst_1) _inst_2)) U) U) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Monoid.toOne.{u1} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align unitary.star_mul_self_of_mem unitary.star_mul_self_of_memₓ'. -/
@[simp]
theorem star_mul_self_of_mem {U : R} (hU : U ∈ unitary R) : star U * U = 1 :=
  hU.1
#align unitary.star_mul_self_of_mem unitary.star_mul_self_of_mem

/- warning: unitary.mul_star_self_of_mem -> unitary.mul_star_self_of_mem is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] [_inst_2 : StarSemigroup.{u1} R (Monoid.toSemigroup.{u1} R _inst_1)] {U : R}, (Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) U (unitary.{u1} R _inst_1 _inst_2)) -> (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) U (Star.star.{u1} R (InvolutiveStar.toHasStar.{u1} R (StarSemigroup.toHasInvolutiveStar.{u1} R (Monoid.toSemigroup.{u1} R _inst_1) _inst_2)) U)) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (MulOneClass.toHasOne.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] [_inst_2 : StarSemigroup.{u1} R (Monoid.toSemigroup.{u1} R _inst_1)] {U : R}, (Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) U (unitary.{u1} R _inst_1 _inst_2)) -> (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) U (Star.star.{u1} R (InvolutiveStar.toStar.{u1} R (StarSemigroup.toInvolutiveStar.{u1} R (Monoid.toSemigroup.{u1} R _inst_1) _inst_2)) U)) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Monoid.toOne.{u1} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align unitary.mul_star_self_of_mem unitary.mul_star_self_of_memₓ'. -/
@[simp]
theorem mul_star_self_of_mem {U : R} (hU : U ∈ unitary R) : U * star U = 1 :=
  hU.2
#align unitary.mul_star_self_of_mem unitary.mul_star_self_of_mem

/- warning: unitary.star_mem -> unitary.star_mem is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] [_inst_2 : StarSemigroup.{u1} R (Monoid.toSemigroup.{u1} R _inst_1)] {U : R}, (Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) U (unitary.{u1} R _inst_1 _inst_2)) -> (Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (Star.star.{u1} R (InvolutiveStar.toHasStar.{u1} R (StarSemigroup.toHasInvolutiveStar.{u1} R (Monoid.toSemigroup.{u1} R _inst_1) _inst_2)) U) (unitary.{u1} R _inst_1 _inst_2))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] [_inst_2 : StarSemigroup.{u1} R (Monoid.toSemigroup.{u1} R _inst_1)] {U : R}, (Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) U (unitary.{u1} R _inst_1 _inst_2)) -> (Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (Star.star.{u1} R (InvolutiveStar.toStar.{u1} R (StarSemigroup.toInvolutiveStar.{u1} R (Monoid.toSemigroup.{u1} R _inst_1) _inst_2)) U) (unitary.{u1} R _inst_1 _inst_2))
Case conversion may be inaccurate. Consider using '#align unitary.star_mem unitary.star_memₓ'. -/
theorem star_mem {U : R} (hU : U ∈ unitary R) : star U ∈ unitary R :=
  ⟨by rw [star_star, mul_star_self_of_mem hU], by rw [star_star, star_mul_self_of_mem hU]⟩
#align unitary.star_mem unitary.star_mem

/- warning: unitary.star_mem_iff -> unitary.star_mem_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] [_inst_2 : StarSemigroup.{u1} R (Monoid.toSemigroup.{u1} R _inst_1)] {U : R}, Iff (Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (Star.star.{u1} R (InvolutiveStar.toHasStar.{u1} R (StarSemigroup.toHasInvolutiveStar.{u1} R (Monoid.toSemigroup.{u1} R _inst_1) _inst_2)) U) (unitary.{u1} R _inst_1 _inst_2)) (Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) U (unitary.{u1} R _inst_1 _inst_2))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] [_inst_2 : StarSemigroup.{u1} R (Monoid.toSemigroup.{u1} R _inst_1)] {U : R}, Iff (Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (Star.star.{u1} R (InvolutiveStar.toStar.{u1} R (StarSemigroup.toInvolutiveStar.{u1} R (Monoid.toSemigroup.{u1} R _inst_1) _inst_2)) U) (unitary.{u1} R _inst_1 _inst_2)) (Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) U (unitary.{u1} R _inst_1 _inst_2))
Case conversion may be inaccurate. Consider using '#align unitary.star_mem_iff unitary.star_mem_iffₓ'. -/
@[simp]
theorem star_mem_iff {U : R} : star U ∈ unitary R ↔ U ∈ unitary R :=
  ⟨fun h => star_star U ▸ star_mem h, star_mem⟩
#align unitary.star_mem_iff unitary.star_mem_iff

instance : Star (unitary R) :=
  ⟨fun U => ⟨star U, star_mem U.Prop⟩⟩

/- warning: unitary.coe_star -> unitary.coe_star is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] [_inst_2 : StarSemigroup.{u1} R (Monoid.toSemigroup.{u1} R _inst_1)] {U : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)}, Eq.{succ u1} R ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2)))))) (Star.star.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) (unitary.hasStar.{u1} R _inst_1 _inst_2) U)) (Star.star.{u1} R (InvolutiveStar.toHasStar.{u1} R (StarSemigroup.toHasInvolutiveStar.{u1} R (Monoid.toSemigroup.{u1} R _inst_1) _inst_2)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2)))))) U))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] [_inst_2 : StarSemigroup.{u1} R (Monoid.toSemigroup.{u1} R _inst_1)] {U : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))}, Eq.{succ u1} R (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (unitary.{u1} R _inst_1 _inst_2))) (Star.star.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (unitary.instStarSubtypeMemSubmonoidToMulOneClassInstMembershipInstSetLikeSubmonoidUnitary.{u1} R _inst_1 _inst_2) U)) (Star.star.{u1} R (InvolutiveStar.toStar.{u1} R (StarSemigroup.toInvolutiveStar.{u1} R (Monoid.toSemigroup.{u1} R _inst_1) _inst_2)) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (unitary.{u1} R _inst_1 _inst_2))) U))
Case conversion may be inaccurate. Consider using '#align unitary.coe_star unitary.coe_starₓ'. -/
@[simp, norm_cast]
theorem coe_star {U : unitary R} : ↑(star U) = (star U : R) :=
  rfl
#align unitary.coe_star unitary.coe_star

/- warning: unitary.coe_star_mul_self -> unitary.coe_star_mul_self is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] [_inst_2 : StarSemigroup.{u1} R (Monoid.toSemigroup.{u1} R _inst_1)] (U : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)), Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (Star.star.{u1} R (InvolutiveStar.toHasStar.{u1} R (StarSemigroup.toHasInvolutiveStar.{u1} R (Monoid.toSemigroup.{u1} R _inst_1) _inst_2)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2)))))) U)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2)))))) U)) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (MulOneClass.toHasOne.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] [_inst_2 : StarSemigroup.{u1} R (Monoid.toSemigroup.{u1} R _inst_1)] (U : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))), Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (Star.star.{u1} R (InvolutiveStar.toStar.{u1} R (StarSemigroup.toInvolutiveStar.{u1} R (Monoid.toSemigroup.{u1} R _inst_1) _inst_2)) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (unitary.{u1} R _inst_1 _inst_2))) U)) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (unitary.{u1} R _inst_1 _inst_2))) U)) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Monoid.toOne.{u1} R _inst_1)))
Case conversion may be inaccurate. Consider using '#align unitary.coe_star_mul_self unitary.coe_star_mul_selfₓ'. -/
theorem coe_star_mul_self (U : unitary R) : (star U : R) * U = 1 :=
  star_mul_self_of_mem U.Prop
#align unitary.coe_star_mul_self unitary.coe_star_mul_self

/- warning: unitary.coe_mul_star_self -> unitary.coe_mul_star_self is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] [_inst_2 : StarSemigroup.{u1} R (Monoid.toSemigroup.{u1} R _inst_1)] (U : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)), Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2)))))) U) (Star.star.{u1} R (InvolutiveStar.toHasStar.{u1} R (StarSemigroup.toHasInvolutiveStar.{u1} R (Monoid.toSemigroup.{u1} R _inst_1) _inst_2)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2)))))) U))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (MulOneClass.toHasOne.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] [_inst_2 : StarSemigroup.{u1} R (Monoid.toSemigroup.{u1} R _inst_1)] (U : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))), Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (unitary.{u1} R _inst_1 _inst_2))) U) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (unitary.{u1} R _inst_1 _inst_2))) (Star.star.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (unitary.instStarSubtypeMemSubmonoidToMulOneClassInstMembershipInstSetLikeSubmonoidUnitary.{u1} R _inst_1 _inst_2) U))) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Monoid.toOne.{u1} R _inst_1)))
Case conversion may be inaccurate. Consider using '#align unitary.coe_mul_star_self unitary.coe_mul_star_selfₓ'. -/
theorem coe_mul_star_self (U : unitary R) : (U : R) * star U = 1 :=
  mul_star_self_of_mem U.Prop
#align unitary.coe_mul_star_self unitary.coe_mul_star_self

/- warning: unitary.star_mul_self -> unitary.star_mul_self is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] [_inst_2 : StarSemigroup.{u1} R (Monoid.toSemigroup.{u1} R _inst_1)] (U : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)), Eq.{succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) (HMul.hMul.{u1, u1, u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) (instHMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) (Submonoid.mul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) (unitary.{u1} R _inst_1 _inst_2))) (Star.star.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) (unitary.hasStar.{u1} R _inst_1 _inst_2) U) U) (OfNat.ofNat.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) 1 (OfNat.mk.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) 1 (One.one.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) (Submonoid.one.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) (unitary.{u1} R _inst_1 _inst_2)))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] [_inst_2 : StarSemigroup.{u1} R (Monoid.toSemigroup.{u1} R _inst_1)] (U : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))), Eq.{succ u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (HMul.hMul.{u1, u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (instHMul.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (Submonoid.mul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) (unitary.{u1} R _inst_1 _inst_2))) (Star.star.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (unitary.instStarSubtypeMemSubmonoidToMulOneClassInstMembershipInstSetLikeSubmonoidUnitary.{u1} R _inst_1 _inst_2) U) U) (OfNat.ofNat.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) 1 (One.toOfNat1.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (Submonoid.one.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) (unitary.{u1} R _inst_1 _inst_2))))
Case conversion may be inaccurate. Consider using '#align unitary.star_mul_self unitary.star_mul_selfₓ'. -/
@[simp]
theorem star_mul_self (U : unitary R) : star U * U = 1 :=
  Subtype.ext <| coe_star_mul_self U
#align unitary.star_mul_self unitary.star_mul_self

/- warning: unitary.mul_star_self -> unitary.mul_star_self is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] [_inst_2 : StarSemigroup.{u1} R (Monoid.toSemigroup.{u1} R _inst_1)] (U : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)), Eq.{succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) (HMul.hMul.{u1, u1, u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) (instHMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) (Submonoid.mul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) (unitary.{u1} R _inst_1 _inst_2))) U (Star.star.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) (unitary.hasStar.{u1} R _inst_1 _inst_2) U)) (OfNat.ofNat.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) 1 (OfNat.mk.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) 1 (One.one.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) (Submonoid.one.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) (unitary.{u1} R _inst_1 _inst_2)))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] [_inst_2 : StarSemigroup.{u1} R (Monoid.toSemigroup.{u1} R _inst_1)] (U : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))), Eq.{succ u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (HMul.hMul.{u1, u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (instHMul.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (Submonoid.mul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) (unitary.{u1} R _inst_1 _inst_2))) U (Star.star.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (unitary.instStarSubtypeMemSubmonoidToMulOneClassInstMembershipInstSetLikeSubmonoidUnitary.{u1} R _inst_1 _inst_2) U)) (OfNat.ofNat.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) 1 (One.toOfNat1.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (Submonoid.one.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) (unitary.{u1} R _inst_1 _inst_2))))
Case conversion may be inaccurate. Consider using '#align unitary.mul_star_self unitary.mul_star_selfₓ'. -/
@[simp]
theorem mul_star_self (U : unitary R) : U * star U = 1 :=
  Subtype.ext <| coe_mul_star_self U
#align unitary.mul_star_self unitary.mul_star_self

instance : Group (unitary R) :=
  { Submonoid.toMonoid _ with
    inv := star
    mul_left_inv := star_mul_self }

instance : InvolutiveStar (unitary R) :=
  ⟨fun _ => by
    ext
    simp only [coe_star, star_star]⟩

instance : StarSemigroup (unitary R) :=
  ⟨fun _ _ => by
    ext
    simp only [coe_star, Submonoid.coe_mul, star_mul]⟩

instance : Inhabited (unitary R) :=
  ⟨1⟩

/- warning: unitary.star_eq_inv -> unitary.star_eq_inv is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] [_inst_2 : StarSemigroup.{u1} R (Monoid.toSemigroup.{u1} R _inst_1)] (U : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)), Eq.{succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) (Star.star.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) (unitary.hasStar.{u1} R _inst_1 _inst_2) U) (Inv.inv.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) (DivInvMonoid.toHasInv.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) (unitary.group.{u1} R _inst_1 _inst_2))) U)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] [_inst_2 : StarSemigroup.{u1} R (Monoid.toSemigroup.{u1} R _inst_1)] (U : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))), Eq.{succ u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (Star.star.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (unitary.instStarSubtypeMemSubmonoidToMulOneClassInstMembershipInstSetLikeSubmonoidUnitary.{u1} R _inst_1 _inst_2) U) (Inv.inv.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (InvOneClass.toInv.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (DivInvOneMonoid.toInvOneClass.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (DivisionMonoid.toDivInvOneMonoid.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (Group.toDivisionMonoid.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (unitary.instGroupSubtypeMemSubmonoidToMulOneClassInstMembershipInstSetLikeSubmonoidUnitary.{u1} R _inst_1 _inst_2))))) U)
Case conversion may be inaccurate. Consider using '#align unitary.star_eq_inv unitary.star_eq_invₓ'. -/
theorem star_eq_inv (U : unitary R) : star U = U⁻¹ :=
  rfl
#align unitary.star_eq_inv unitary.star_eq_inv

/- warning: unitary.star_eq_inv' -> unitary.star_eq_inv' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] [_inst_2 : StarSemigroup.{u1} R (Monoid.toSemigroup.{u1} R _inst_1)], Eq.{succ u1} ((coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) -> (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2))) (Star.star.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) (unitary.hasStar.{u1} R _inst_1 _inst_2)) (Inv.inv.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) (DivInvMonoid.toHasInv.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) (unitary.group.{u1} R _inst_1 _inst_2))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] [_inst_2 : StarSemigroup.{u1} R (Monoid.toSemigroup.{u1} R _inst_1)], Eq.{succ u1} ((Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) -> (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2)))) (Star.star.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (unitary.instStarSubtypeMemSubmonoidToMulOneClassInstMembershipInstSetLikeSubmonoidUnitary.{u1} R _inst_1 _inst_2)) (Inv.inv.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (InvOneClass.toInv.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (DivInvOneMonoid.toInvOneClass.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (DivisionMonoid.toDivInvOneMonoid.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (Group.toDivisionMonoid.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (unitary.instGroupSubtypeMemSubmonoidToMulOneClassInstMembershipInstSetLikeSubmonoidUnitary.{u1} R _inst_1 _inst_2))))))
Case conversion may be inaccurate. Consider using '#align unitary.star_eq_inv' unitary.star_eq_inv'ₓ'. -/
theorem star_eq_inv' : (star : unitary R → unitary R) = Inv.inv :=
  rfl
#align unitary.star_eq_inv' unitary.star_eq_inv'

/- warning: unitary.to_units -> unitary.toUnits is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] [_inst_2 : StarSemigroup.{u1} R (Monoid.toSemigroup.{u1} R _inst_1)], MonoidHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) (Units.{u1} R _inst_1) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) (unitary.{u1} R _inst_1 _inst_2)) (Units.mulOneClass.{u1} R _inst_1)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] [_inst_2 : StarSemigroup.{u1} R (Monoid.toSemigroup.{u1} R _inst_1)], MonoidHom.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (Units.{u1} R _inst_1) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) (unitary.{u1} R _inst_1 _inst_2)) (Units.instMulOneClassUnits.{u1} R _inst_1)
Case conversion may be inaccurate. Consider using '#align unitary.to_units unitary.toUnitsₓ'. -/
/-- The unitary elements embed into the units. -/
@[simps]
def toUnits : unitary R →* Rˣ
    where
  toFun x := ⟨x, ↑x⁻¹, coe_mul_star_self x, coe_star_mul_self x⟩
  map_one' := Units.ext rfl
  map_mul' x y := Units.ext rfl
#align unitary.to_units unitary.toUnits

/- warning: unitary.to_units_injective -> unitary.to_units_injective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] [_inst_2 : StarSemigroup.{u1} R (Monoid.toSemigroup.{u1} R _inst_1)], Function.Injective.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) (Units.{u1} R _inst_1) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) (Units.{u1} R _inst_1) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) (unitary.{u1} R _inst_1 _inst_2)) (Units.mulOneClass.{u1} R _inst_1)) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) (Units.{u1} R _inst_1) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) (unitary.{u1} R _inst_1 _inst_2)) (Units.mulOneClass.{u1} R _inst_1)) => (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) -> (Units.{u1} R _inst_1)) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (unitary.{u1} R _inst_1 _inst_2)) (Units.{u1} R _inst_1) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) (unitary.{u1} R _inst_1 _inst_2)) (Units.mulOneClass.{u1} R _inst_1)) (unitary.toUnits.{u1} R _inst_1 _inst_2))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] [_inst_2 : StarSemigroup.{u1} R (Monoid.toSemigroup.{u1} R _inst_1)], Function.Injective.{succ u1, succ u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (Units.{u1} R _inst_1) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (Units.{u1} R _inst_1) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) (unitary.{u1} R _inst_1 _inst_2)) (Units.instMulOneClassUnits.{u1} R _inst_1)) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (fun (_x : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) => Units.{u1} R _inst_1) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (Units.{u1} R _inst_1) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) (unitary.{u1} R _inst_1 _inst_2)) (Units.instMulOneClassUnits.{u1} R _inst_1)) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (Units.{u1} R _inst_1) (MulOneClass.toMul.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) (unitary.{u1} R _inst_1 _inst_2))) (MulOneClass.toMul.{u1} (Units.{u1} R _inst_1) (Units.instMulOneClassUnits.{u1} R _inst_1)) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (Units.{u1} R _inst_1) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) (unitary.{u1} R _inst_1 _inst_2)) (Units.instMulOneClassUnits.{u1} R _inst_1)) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (Units.{u1} R _inst_1) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) (unitary.{u1} R _inst_1 _inst_2)) (Units.instMulOneClassUnits.{u1} R _inst_1) (MonoidHom.monoidHomClass.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x (unitary.{u1} R _inst_1 _inst_2))) (Units.{u1} R _inst_1) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) (unitary.{u1} R _inst_1 _inst_2)) (Units.instMulOneClassUnits.{u1} R _inst_1)))) (unitary.toUnits.{u1} R _inst_1 _inst_2))
Case conversion may be inaccurate. Consider using '#align unitary.to_units_injective unitary.to_units_injectiveₓ'. -/
theorem to_units_injective : Function.Injective (toUnits : unitary R → Rˣ) := fun x y h =>
  Subtype.ext <| Units.ext_iff.mp h
#align unitary.to_units_injective unitary.to_units_injective

end Monoid

section CommMonoid

variable [CommMonoid R] [StarSemigroup R]

instance : CommGroup (unitary R) :=
  { unitary.group, Submonoid.toCommMonoid _ with }

/- warning: unitary.mem_iff_star_mul_self -> unitary.mem_iff_star_mul_self is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommMonoid.{u1} R] [_inst_2 : StarSemigroup.{u1} R (Monoid.toSemigroup.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))] {U : R}, Iff (Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1)))) U (unitary.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1) _inst_2)) (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1)))) (Star.star.{u1} R (InvolutiveStar.toHasStar.{u1} R (StarSemigroup.toHasInvolutiveStar.{u1} R (Monoid.toSemigroup.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1)) _inst_2)) U) U) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (MulOneClass.toHasOne.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1)))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommMonoid.{u1} R] [_inst_2 : StarSemigroup.{u1} R (Monoid.toSemigroup.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))] {U : R}, Iff (Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1)))) U (unitary.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1) _inst_2)) (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1)))) (Star.star.{u1} R (InvolutiveStar.toStar.{u1} R (StarSemigroup.toInvolutiveStar.{u1} R (Monoid.toSemigroup.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1)) _inst_2)) U) U) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Monoid.toOne.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align unitary.mem_iff_star_mul_self unitary.mem_iff_star_mul_selfₓ'. -/
theorem mem_iff_star_mul_self {U : R} : U ∈ unitary R ↔ star U * U = 1 :=
  mem_iff.trans <| and_iff_left_of_imp fun h => mul_comm (star U) U ▸ h
#align unitary.mem_iff_star_mul_self unitary.mem_iff_star_mul_self

/- warning: unitary.mem_iff_self_mul_star -> unitary.mem_iff_self_mul_star is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommMonoid.{u1} R] [_inst_2 : StarSemigroup.{u1} R (Monoid.toSemigroup.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))] {U : R}, Iff (Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1)))) U (unitary.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1) _inst_2)) (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1)))) U (Star.star.{u1} R (InvolutiveStar.toHasStar.{u1} R (StarSemigroup.toHasInvolutiveStar.{u1} R (Monoid.toSemigroup.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1)) _inst_2)) U)) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (MulOneClass.toHasOne.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1)))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommMonoid.{u1} R] [_inst_2 : StarSemigroup.{u1} R (Monoid.toSemigroup.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))] {U : R}, Iff (Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1)))) U (unitary.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1) _inst_2)) (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1)))) U (Star.star.{u1} R (InvolutiveStar.toStar.{u1} R (StarSemigroup.toInvolutiveStar.{u1} R (Monoid.toSemigroup.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1)) _inst_2)) U)) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Monoid.toOne.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align unitary.mem_iff_self_mul_star unitary.mem_iff_self_mul_starₓ'. -/
theorem mem_iff_self_mul_star {U : R} : U ∈ unitary R ↔ U * star U = 1 :=
  mem_iff.trans <| and_iff_right_of_imp fun h => mul_comm U (star U) ▸ h
#align unitary.mem_iff_self_mul_star unitary.mem_iff_self_mul_star

end CommMonoid

section GroupWithZero

variable [GroupWithZero R] [StarSemigroup R]

/- warning: unitary.coe_inv -> unitary.coe_inv is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : GroupWithZero.{u1} R] [_inst_2 : StarSemigroup.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (MonoidWithZero.toSemigroupWithZero.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))] (U : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)), Eq.{succ u1} R ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) x (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)))))) (Inv.inv.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) (DivInvMonoid.toHasInv.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) (unitary.group.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2))) U)) (Inv.inv.{u1} R (DivInvMonoid.toHasInv.{u1} R (GroupWithZero.toDivInvMonoid.{u1} R _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) x (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)))))) U))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : GroupWithZero.{u1} R] [_inst_2 : StarSemigroup.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (MonoidWithZero.toSemigroupWithZero.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))] (U : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) x (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2))), Eq.{succ u1} R (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2))) (Inv.inv.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) x (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2))) (InvOneClass.toInv.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) x (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2))) (DivInvOneMonoid.toInvOneClass.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) x (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2))) (DivisionMonoid.toDivInvOneMonoid.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) x (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2))) (Group.toDivisionMonoid.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) x (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2))) (unitary.instGroupSubtypeMemSubmonoidToMulOneClassInstMembershipInstSetLikeSubmonoidUnitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2))))) U)) (Inv.inv.{u1} R (GroupWithZero.toInv.{u1} R _inst_1) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2))) U))
Case conversion may be inaccurate. Consider using '#align unitary.coe_inv unitary.coe_invₓ'. -/
@[norm_cast]
theorem coe_inv (U : unitary R) : ↑U⁻¹ = (U⁻¹ : R) :=
  eq_inv_of_mul_eq_one_right <| coe_mul_star_self _
#align unitary.coe_inv unitary.coe_inv

/- warning: unitary.coe_div -> unitary.coe_div is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : GroupWithZero.{u1} R] [_inst_2 : StarSemigroup.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (MonoidWithZero.toSemigroupWithZero.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))] (U₁ : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) (U₂ : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)), Eq.{succ u1} R ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) x (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)))))) (HDiv.hDiv.{u1, u1, u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) (instHDiv.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) (DivInvMonoid.toHasDiv.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) (unitary.group.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)))) U₁ U₂)) (HDiv.hDiv.{u1, u1, u1} R R R (instHDiv.{u1} R (DivInvMonoid.toHasDiv.{u1} R (GroupWithZero.toDivInvMonoid.{u1} R _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) x (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)))))) U₁) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) x (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)))))) U₂))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : GroupWithZero.{u1} R] [_inst_2 : StarSemigroup.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (MonoidWithZero.toSemigroupWithZero.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))] (U₁ : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) x (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2))) (U₂ : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) x (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2))), Eq.{succ u1} R (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2))) (HDiv.hDiv.{u1, u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) x (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2))) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) x (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2))) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) x (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2))) (instHDiv.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) x (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2))) (DivInvMonoid.toDiv.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) x (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2))) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) x (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2))) (unitary.instGroupSubtypeMemSubmonoidToMulOneClassInstMembershipInstSetLikeSubmonoidUnitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)))) U₁ U₂)) (HDiv.hDiv.{u1, u1, u1} R R R (instHDiv.{u1} R (GroupWithZero.toDiv.{u1} R _inst_1)) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2))) U₁) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2))) U₂))
Case conversion may be inaccurate. Consider using '#align unitary.coe_div unitary.coe_divₓ'. -/
@[norm_cast]
theorem coe_div (U₁ U₂ : unitary R) : ↑(U₁ / U₂) = (U₁ / U₂ : R) := by
  simp only [div_eq_mul_inv, coe_inv, Submonoid.coe_mul]
#align unitary.coe_div unitary.coe_div

/- warning: unitary.coe_zpow -> unitary.coe_zpow is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : GroupWithZero.{u1} R] [_inst_2 : StarSemigroup.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (MonoidWithZero.toSemigroupWithZero.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))] (U : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) (z : Int), Eq.{succ u1} R ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) x (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)))))) (HPow.hPow.{u1, 0, u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) Int (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) (instHPow.{u1, 0} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) Int (DivInvMonoid.Pow.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) (unitary.group.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)))) U z)) (HPow.hPow.{u1, 0, u1} R Int R (instHPow.{u1, 0} R Int (DivInvMonoid.Pow.{u1} R (GroupWithZero.toDivInvMonoid.{u1} R _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) x (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)))))) U) z)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : GroupWithZero.{u1} R] [_inst_2 : StarSemigroup.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (MonoidWithZero.toSemigroupWithZero.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))] (U : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) x (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2))) (z : Int), Eq.{succ u1} R (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2))) (HPow.hPow.{u1, 0, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) x (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2))) Int (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) x (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2))) (instHPow.{u1, 0} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) x (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2))) Int (DivInvMonoid.Pow.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) x (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2))) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1))))) x (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2))) (unitary.instGroupSubtypeMemSubmonoidToMulOneClassInstMembershipInstSetLikeSubmonoidUnitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2)))) U z)) (HPow.hPow.{u1, 0, u1} R Int R (instHPow.{u1, 0} R Int (DivInvMonoid.Pow.{u1} R (GroupWithZero.toDivInvMonoid.{u1} R _inst_1))) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (GroupWithZero.toMonoidWithZero.{u1} R _inst_1)) _inst_2))) U) z)
Case conversion may be inaccurate. Consider using '#align unitary.coe_zpow unitary.coe_zpowₓ'. -/
@[norm_cast]
theorem coe_zpow (U : unitary R) (z : ℤ) : ↑(U ^ z) = (U ^ z : R) :=
  by
  induction z
  · simp [SubmonoidClass.coe_pow]
  · simp [coe_inv]
#align unitary.coe_zpow unitary.coe_zpow

end GroupWithZero

section Ring

variable [Ring R] [StarRing R]

instance : Neg (unitary R)
    where neg U :=
    ⟨-U, by
      simp_rw [mem_iff, star_neg, neg_mul_neg]
      exact U.prop⟩

/- warning: unitary.coe_neg -> unitary.coe_neg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] [_inst_2 : StarRing.{u1} R (NonUnitalRing.toNonUnitalSemiring.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))] (U : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1)))) (unitary.{u1} R (Ring.toMonoid.{u1} R _inst_1) (StarRing.toStarSemigroup.{u1} R (NonUnitalRing.toNonUnitalSemiring.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1)) _inst_2))), Eq.{succ u1} R ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1)))) (unitary.{u1} R (Ring.toMonoid.{u1} R _inst_1) (StarRing.toStarSemigroup.{u1} R (NonUnitalRing.toNonUnitalSemiring.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1)) _inst_2))) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1)))) (unitary.{u1} R (Ring.toMonoid.{u1} R _inst_1) (StarRing.toStarSemigroup.{u1} R (NonUnitalRing.toNonUnitalSemiring.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1)) _inst_2))) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1)))) (unitary.{u1} R (Ring.toMonoid.{u1} R _inst_1) (StarRing.toStarSemigroup.{u1} R (NonUnitalRing.toNonUnitalSemiring.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1)) _inst_2))) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1)))) (unitary.{u1} R (Ring.toMonoid.{u1} R _inst_1) (StarRing.toStarSemigroup.{u1} R (NonUnitalRing.toNonUnitalSemiring.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1)) _inst_2))) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1)))) x (unitary.{u1} R (Ring.toMonoid.{u1} R _inst_1) (StarRing.toStarSemigroup.{u1} R (NonUnitalRing.toNonUnitalSemiring.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1)) _inst_2))))))) (Neg.neg.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1)))) (unitary.{u1} R (Ring.toMonoid.{u1} R _inst_1) (StarRing.toStarSemigroup.{u1} R (NonUnitalRing.toNonUnitalSemiring.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1)) _inst_2))) (unitary.hasNeg.{u1} R _inst_1 _inst_2) U)) (Neg.neg.{u1} R (SubNegMonoid.toHasNeg.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1)))) (unitary.{u1} R (Ring.toMonoid.{u1} R _inst_1) (StarRing.toStarSemigroup.{u1} R (NonUnitalRing.toNonUnitalSemiring.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1)) _inst_2))) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1)))) (unitary.{u1} R (Ring.toMonoid.{u1} R _inst_1) (StarRing.toStarSemigroup.{u1} R (NonUnitalRing.toNonUnitalSemiring.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1)) _inst_2))) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1)))) (unitary.{u1} R (Ring.toMonoid.{u1} R _inst_1) (StarRing.toStarSemigroup.{u1} R (NonUnitalRing.toNonUnitalSemiring.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1)) _inst_2))) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1)))) (unitary.{u1} R (Ring.toMonoid.{u1} R _inst_1) (StarRing.toStarSemigroup.{u1} R (NonUnitalRing.toNonUnitalSemiring.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1)) _inst_2))) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1)))) x (unitary.{u1} R (Ring.toMonoid.{u1} R _inst_1) (StarRing.toStarSemigroup.{u1} R (NonUnitalRing.toNonUnitalSemiring.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1)) _inst_2))))))) U))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] [_inst_2 : StarRing.{u1} R (NonUnitalRing.toNonUnitalSemiring.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))] (U : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))))) x (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (StarRing.toStarSemigroup.{u1} R (NonUnitalRing.toNonUnitalSemiring.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1)) _inst_2)))), Eq.{succ u1} R (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (StarRing.toStarSemigroup.{u1} R (NonUnitalRing.toNonUnitalSemiring.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1)) _inst_2)))) (Neg.neg.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))))) x (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (StarRing.toStarSemigroup.{u1} R (NonUnitalRing.toNonUnitalSemiring.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1)) _inst_2)))) (unitary.instNegSubtypeMemSubmonoidToMulOneClassToMonoidToMonoidWithZeroToSemiringInstMembershipInstSetLikeSubmonoidUnitaryToStarSemigroupToNonUnitalSemiringToNonUnitalRing.{u1} R _inst_1 _inst_2) U)) (Neg.neg.{u1} R (Ring.toNeg.{u1} R _inst_1) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (unitary.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (StarRing.toStarSemigroup.{u1} R (NonUnitalRing.toNonUnitalSemiring.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1)) _inst_2)))) U))
Case conversion may be inaccurate. Consider using '#align unitary.coe_neg unitary.coe_negₓ'. -/
@[norm_cast]
theorem coe_neg (U : unitary R) : ↑(-U) = (-U : R) :=
  rfl
#align unitary.coe_neg unitary.coe_neg

instance : HasDistribNeg (unitary R) :=
  Subtype.coe_injective.HasDistribNeg _ coe_neg (unitary R).coe_mul

end Ring

end unitary

