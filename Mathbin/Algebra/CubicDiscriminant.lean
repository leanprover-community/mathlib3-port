/-
Copyright (c) 2022 David Kurniadi Angdinata. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Kurniadi Angdinata

! This file was ported from Lean 3 source module algebra.cubic_discriminant
! leanprover-community/mathlib commit 31ca6f9cf5f90a6206092cd7f84b359dcb6d52e0
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Polynomial.Splits

/-!
# Cubics and discriminants

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file defines cubic polynomials over a semiring and their discriminants over a splitting field.

## Main definitions

 * `cubic`: the structure representing a cubic polynomial.
 * `cubic.disc`: the discriminant of a cubic polynomial.

## Main statements

 * `cubic.disc_ne_zero_iff_roots_nodup`: the cubic discriminant is not equal to zero if and only if
    the cubic has no duplicate roots.

## References

 * https://en.wikipedia.org/wiki/Cubic_equation
 * https://en.wikipedia.org/wiki/Discriminant

## Tags

cubic, discriminant, polynomial, root
-/


noncomputable section

#print Cubic /-
/-- The structure representing a cubic polynomial. -/
@[ext]
structure Cubic (R : Type _) where
  (a b c d : R)
#align cubic Cubic
-/

namespace Cubic

open Cubic Polynomial

open Polynomial

variable {R S F K : Type _}

instance [Inhabited R] : Inhabited (Cubic R) :=
  ⟨⟨default, default, default, default⟩⟩

instance [Zero R] : Zero (Cubic R) :=
  ⟨⟨0, 0, 0, 0⟩⟩

section Basic

variable {P Q : Cubic R} {a b c d a' b' c' d' : R} [Semiring R]

#print Cubic.toPoly /-
/-- Convert a cubic polynomial to a polynomial. -/
def toPoly (P : Cubic R) : R[X] :=
  C P.a * X ^ 3 + C P.b * X ^ 2 + C P.c * X + C P.d
#align cubic.to_poly Cubic.toPoly
-/

/- warning: cubic.C_mul_prod_X_sub_C_eq -> Cubic.C_mul_prod_X_sub_C_eq is a dubious translation:
lean 3 declaration is
  forall {S : Type.{u1}} [_inst_2 : CommRing.{u1} S] {w : S} {x : S} {y : S} {z : S}, Eq.{succ u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (instHMul.{u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.mul'.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)))) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (instHMul.{u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.mul'.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)))) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (instHMul.{u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.mul'.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (fun (_x : RingHom.{u1, u1} S (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))))) => S -> (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)))) (RingHom.hasCoeToFun.{u1, u1} S (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (Polynomial.C.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) w) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (instHSub.{u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.sub.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.X.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (fun (_x : RingHom.{u1, u1} S (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))))) => S -> (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)))) (RingHom.hasCoeToFun.{u1, u1} S (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (Polynomial.C.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) x))) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (instHSub.{u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.sub.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.X.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (fun (_x : RingHom.{u1, u1} S (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))))) => S -> (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)))) (RingHom.hasCoeToFun.{u1, u1} S (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (Polynomial.C.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) y))) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (instHSub.{u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.sub.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.X.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (fun (_x : RingHom.{u1, u1} S (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))))) => S -> (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)))) (RingHom.hasCoeToFun.{u1, u1} S (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (Polynomial.C.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) z))) (Cubic.toPoly.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)) (Cubic.mk.{u1} S w (HMul.hMul.{u1, u1, u1} S S S (instHMul.{u1} S (Distrib.toHasMul.{u1} S (Ring.toDistrib.{u1} S (CommRing.toRing.{u1} S _inst_2)))) w (Neg.neg.{u1} S (SubNegMonoid.toHasNeg.{u1} S (AddGroup.toSubNegMonoid.{u1} S (AddGroupWithOne.toAddGroup.{u1} S (AddCommGroupWithOne.toAddGroupWithOne.{u1} S (Ring.toAddCommGroupWithOne.{u1} S (CommRing.toRing.{u1} S _inst_2)))))) (HAdd.hAdd.{u1, u1, u1} S S S (instHAdd.{u1} S (Distrib.toHasAdd.{u1} S (Ring.toDistrib.{u1} S (CommRing.toRing.{u1} S _inst_2)))) (HAdd.hAdd.{u1, u1, u1} S S S (instHAdd.{u1} S (Distrib.toHasAdd.{u1} S (Ring.toDistrib.{u1} S (CommRing.toRing.{u1} S _inst_2)))) x y) z))) (HMul.hMul.{u1, u1, u1} S S S (instHMul.{u1} S (Distrib.toHasMul.{u1} S (Ring.toDistrib.{u1} S (CommRing.toRing.{u1} S _inst_2)))) w (HAdd.hAdd.{u1, u1, u1} S S S (instHAdd.{u1} S (Distrib.toHasAdd.{u1} S (Ring.toDistrib.{u1} S (CommRing.toRing.{u1} S _inst_2)))) (HAdd.hAdd.{u1, u1, u1} S S S (instHAdd.{u1} S (Distrib.toHasAdd.{u1} S (Ring.toDistrib.{u1} S (CommRing.toRing.{u1} S _inst_2)))) (HMul.hMul.{u1, u1, u1} S S S (instHMul.{u1} S (Distrib.toHasMul.{u1} S (Ring.toDistrib.{u1} S (CommRing.toRing.{u1} S _inst_2)))) x y) (HMul.hMul.{u1, u1, u1} S S S (instHMul.{u1} S (Distrib.toHasMul.{u1} S (Ring.toDistrib.{u1} S (CommRing.toRing.{u1} S _inst_2)))) x z)) (HMul.hMul.{u1, u1, u1} S S S (instHMul.{u1} S (Distrib.toHasMul.{u1} S (Ring.toDistrib.{u1} S (CommRing.toRing.{u1} S _inst_2)))) y z))) (HMul.hMul.{u1, u1, u1} S S S (instHMul.{u1} S (Distrib.toHasMul.{u1} S (Ring.toDistrib.{u1} S (CommRing.toRing.{u1} S _inst_2)))) w (Neg.neg.{u1} S (SubNegMonoid.toHasNeg.{u1} S (AddGroup.toSubNegMonoid.{u1} S (AddGroupWithOne.toAddGroup.{u1} S (AddCommGroupWithOne.toAddGroupWithOne.{u1} S (Ring.toAddCommGroupWithOne.{u1} S (CommRing.toRing.{u1} S _inst_2)))))) (HMul.hMul.{u1, u1, u1} S S S (instHMul.{u1} S (Distrib.toHasMul.{u1} S (Ring.toDistrib.{u1} S (CommRing.toRing.{u1} S _inst_2)))) (HMul.hMul.{u1, u1, u1} S S S (instHMul.{u1} S (Distrib.toHasMul.{u1} S (Ring.toDistrib.{u1} S (CommRing.toRing.{u1} S _inst_2)))) x y) z)))))
but is expected to have type
  forall {S : Type.{u1}} [_inst_2 : CommRing.{u1} S] {w : S} {x : S} {y : S} {z : S}, Eq.{succ u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : S) => Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) w) (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : S) => Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) w) (Polynomial.mul'.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : S) => Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) w) (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : S) => Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) w) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : S) => Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) w) (Polynomial.mul'.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : S) => Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) w) (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : S) => Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) w) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : S) => Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) w) (Polynomial.mul'.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) S (fun (_x : S) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : S) => Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) (RingHom.instRingHomClassRingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))))))) (Polynomial.C.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) w) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : S) => Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) x) (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (instHSub.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.sub.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.X.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) S (fun (_x : S) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : S) => Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) (RingHom.instRingHomClassRingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))))))) (Polynomial.C.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) x))) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : S) => Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) y) (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (instHSub.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.sub.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.X.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) S (fun (_x : S) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : S) => Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) (RingHom.instRingHomClassRingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))))))) (Polynomial.C.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) y))) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : S) => Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) z) (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (instHSub.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.sub.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.X.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) S (fun (_x : S) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : S) => Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) (RingHom.instRingHomClassRingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))))))) (Polynomial.C.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) z))) (Cubic.toPoly.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (Cubic.mk.{u1} S w (HMul.hMul.{u1, u1, u1} S S S (instHMul.{u1} S (NonUnitalNonAssocRing.toMul.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) w (Neg.neg.{u1} S (Ring.toNeg.{u1} S (CommRing.toRing.{u1} S _inst_2)) (HAdd.hAdd.{u1, u1, u1} S S S (instHAdd.{u1} S (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))))) (HAdd.hAdd.{u1, u1, u1} S S S (instHAdd.{u1} S (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))))) x y) z))) (HMul.hMul.{u1, u1, u1} S S S (instHMul.{u1} S (NonUnitalNonAssocRing.toMul.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) w (HAdd.hAdd.{u1, u1, u1} S S S (instHAdd.{u1} S (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))))) (HAdd.hAdd.{u1, u1, u1} S S S (instHAdd.{u1} S (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))))) (HMul.hMul.{u1, u1, u1} S S S (instHMul.{u1} S (NonUnitalNonAssocRing.toMul.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) x y) (HMul.hMul.{u1, u1, u1} S S S (instHMul.{u1} S (NonUnitalNonAssocRing.toMul.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) x z)) (HMul.hMul.{u1, u1, u1} S S S (instHMul.{u1} S (NonUnitalNonAssocRing.toMul.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) y z))) (HMul.hMul.{u1, u1, u1} S S S (instHMul.{u1} S (NonUnitalNonAssocRing.toMul.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) w (Neg.neg.{u1} S (Ring.toNeg.{u1} S (CommRing.toRing.{u1} S _inst_2)) (HMul.hMul.{u1, u1, u1} S S S (instHMul.{u1} S (NonUnitalNonAssocRing.toMul.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (HMul.hMul.{u1, u1, u1} S S S (instHMul.{u1} S (NonUnitalNonAssocRing.toMul.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) x y) z)))))
Case conversion may be inaccurate. Consider using '#align cubic.C_mul_prod_X_sub_C_eq Cubic.C_mul_prod_X_sub_C_eqₓ'. -/
theorem C_mul_prod_X_sub_C_eq [CommRing S] {w x y z : S} :
    C w * (X - C x) * (X - C y) * (X - C z) =
      toPoly ⟨w, w * -(x + y + z), w * (x * y + x * z + y * z), w * -(x * y * z)⟩ :=
  by
  simp only [to_poly, C_neg, C_add, C_mul]
  ring1
#align cubic.C_mul_prod_X_sub_C_eq Cubic.C_mul_prod_X_sub_C_eq

/- warning: cubic.prod_X_sub_C_eq -> Cubic.prod_X_sub_C_eq is a dubious translation:
lean 3 declaration is
  forall {S : Type.{u1}} [_inst_2 : CommRing.{u1} S] {x : S} {y : S} {z : S}, Eq.{succ u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (instHMul.{u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.mul'.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)))) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (instHMul.{u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.mul'.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)))) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (instHSub.{u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.sub.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.X.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (fun (_x : RingHom.{u1, u1} S (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))))) => S -> (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)))) (RingHom.hasCoeToFun.{u1, u1} S (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (Polynomial.C.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) x)) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (instHSub.{u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.sub.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.X.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (fun (_x : RingHom.{u1, u1} S (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))))) => S -> (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)))) (RingHom.hasCoeToFun.{u1, u1} S (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (Polynomial.C.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) y))) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (instHSub.{u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.sub.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.X.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (fun (_x : RingHom.{u1, u1} S (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))))) => S -> (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)))) (RingHom.hasCoeToFun.{u1, u1} S (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (Polynomial.C.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) z))) (Cubic.toPoly.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)) (Cubic.mk.{u1} S (OfNat.ofNat.{u1} S 1 (OfNat.mk.{u1} S 1 (One.one.{u1} S (AddMonoidWithOne.toOne.{u1} S (AddGroupWithOne.toAddMonoidWithOne.{u1} S (AddCommGroupWithOne.toAddGroupWithOne.{u1} S (Ring.toAddCommGroupWithOne.{u1} S (CommRing.toRing.{u1} S _inst_2)))))))) (Neg.neg.{u1} S (SubNegMonoid.toHasNeg.{u1} S (AddGroup.toSubNegMonoid.{u1} S (AddGroupWithOne.toAddGroup.{u1} S (AddCommGroupWithOne.toAddGroupWithOne.{u1} S (Ring.toAddCommGroupWithOne.{u1} S (CommRing.toRing.{u1} S _inst_2)))))) (HAdd.hAdd.{u1, u1, u1} S S S (instHAdd.{u1} S (Distrib.toHasAdd.{u1} S (Ring.toDistrib.{u1} S (CommRing.toRing.{u1} S _inst_2)))) (HAdd.hAdd.{u1, u1, u1} S S S (instHAdd.{u1} S (Distrib.toHasAdd.{u1} S (Ring.toDistrib.{u1} S (CommRing.toRing.{u1} S _inst_2)))) x y) z)) (HAdd.hAdd.{u1, u1, u1} S S S (instHAdd.{u1} S (Distrib.toHasAdd.{u1} S (Ring.toDistrib.{u1} S (CommRing.toRing.{u1} S _inst_2)))) (HAdd.hAdd.{u1, u1, u1} S S S (instHAdd.{u1} S (Distrib.toHasAdd.{u1} S (Ring.toDistrib.{u1} S (CommRing.toRing.{u1} S _inst_2)))) (HMul.hMul.{u1, u1, u1} S S S (instHMul.{u1} S (Distrib.toHasMul.{u1} S (Ring.toDistrib.{u1} S (CommRing.toRing.{u1} S _inst_2)))) x y) (HMul.hMul.{u1, u1, u1} S S S (instHMul.{u1} S (Distrib.toHasMul.{u1} S (Ring.toDistrib.{u1} S (CommRing.toRing.{u1} S _inst_2)))) x z)) (HMul.hMul.{u1, u1, u1} S S S (instHMul.{u1} S (Distrib.toHasMul.{u1} S (Ring.toDistrib.{u1} S (CommRing.toRing.{u1} S _inst_2)))) y z)) (Neg.neg.{u1} S (SubNegMonoid.toHasNeg.{u1} S (AddGroup.toSubNegMonoid.{u1} S (AddGroupWithOne.toAddGroup.{u1} S (AddCommGroupWithOne.toAddGroupWithOne.{u1} S (Ring.toAddCommGroupWithOne.{u1} S (CommRing.toRing.{u1} S _inst_2)))))) (HMul.hMul.{u1, u1, u1} S S S (instHMul.{u1} S (Distrib.toHasMul.{u1} S (Ring.toDistrib.{u1} S (CommRing.toRing.{u1} S _inst_2)))) (HMul.hMul.{u1, u1, u1} S S S (instHMul.{u1} S (Distrib.toHasMul.{u1} S (Ring.toDistrib.{u1} S (CommRing.toRing.{u1} S _inst_2)))) x y) z))))
but is expected to have type
  forall {S : Type.{u1}} [_inst_2 : CommRing.{u1} S] {x : S} {y : S} {z : S}, Eq.{succ u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (instHMul.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.mul'.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (instHMul.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.mul'.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : S) => Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) x) (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (instHSub.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.sub.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.X.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) S (fun (_x : S) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : S) => Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) (RingHom.instRingHomClassRingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))))))) (Polynomial.C.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) x)) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : S) => Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) y) (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (instHSub.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.sub.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.X.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) S (fun (_x : S) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : S) => Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) (RingHom.instRingHomClassRingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))))))) (Polynomial.C.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) y))) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : S) => Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) z) (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (instHSub.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.sub.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Polynomial.X.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) S (fun (_x : S) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : S) => Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) (RingHom.instRingHomClassRingHom.{u1, u1} S (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Polynomial.semiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))))))) (Polynomial.C.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) z))) (Cubic.toPoly.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (Cubic.mk.{u1} S (OfNat.ofNat.{u1} S 1 (One.toOfNat1.{u1} S (Semiring.toOne.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (Neg.neg.{u1} S (Ring.toNeg.{u1} S (CommRing.toRing.{u1} S _inst_2)) (HAdd.hAdd.{u1, u1, u1} S S S (instHAdd.{u1} S (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))))) (HAdd.hAdd.{u1, u1, u1} S S S (instHAdd.{u1} S (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))))) x y) z)) (HAdd.hAdd.{u1, u1, u1} S S S (instHAdd.{u1} S (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))))) (HAdd.hAdd.{u1, u1, u1} S S S (instHAdd.{u1} S (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))))) (HMul.hMul.{u1, u1, u1} S S S (instHMul.{u1} S (NonUnitalNonAssocRing.toMul.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) x y) (HMul.hMul.{u1, u1, u1} S S S (instHMul.{u1} S (NonUnitalNonAssocRing.toMul.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) x z)) (HMul.hMul.{u1, u1, u1} S S S (instHMul.{u1} S (NonUnitalNonAssocRing.toMul.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) y z)) (Neg.neg.{u1} S (Ring.toNeg.{u1} S (CommRing.toRing.{u1} S _inst_2)) (HMul.hMul.{u1, u1, u1} S S S (instHMul.{u1} S (NonUnitalNonAssocRing.toMul.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (HMul.hMul.{u1, u1, u1} S S S (instHMul.{u1} S (NonUnitalNonAssocRing.toMul.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) x y) z))))
Case conversion may be inaccurate. Consider using '#align cubic.prod_X_sub_C_eq Cubic.prod_X_sub_C_eqₓ'. -/
theorem prod_X_sub_C_eq [CommRing S] {x y z : S} :
    (X - C x) * (X - C y) * (X - C z) =
      toPoly ⟨1, -(x + y + z), x * y + x * z + y * z, -(x * y * z)⟩ :=
  by rw [← one_mul <| X - C x, ← C_1, C_mul_prod_X_sub_C_eq, one_mul, one_mul, one_mul]
#align cubic.prod_X_sub_C_eq Cubic.prod_X_sub_C_eq

/-! ### Coefficients -/


section Coeff

private theorem coeffs :
    (∀ n > 3, P.toPoly.coeff n = 0) ∧
      P.toPoly.coeff 3 = P.a ∧
        P.toPoly.coeff 2 = P.b ∧ P.toPoly.coeff 1 = P.c ∧ P.toPoly.coeff 0 = P.d :=
  by
  simp only [to_poly, coeff_add, coeff_C, coeff_C_mul_X, coeff_C_mul_X_pow]
  norm_num
  intro n hn
  repeat' rw [if_neg]
  any_goals linarith only [hn]
  repeat' rw [zero_add]
#align cubic.coeffs cubic.coeffs

/- warning: cubic.coeff_eq_zero -> Cubic.coeff_eq_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R] {n : Nat}, (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) n) -> (Eq.{succ u1} R (Polynomial.coeff.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P) n) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))))
but is expected to have type
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R] {n : Nat}, (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3)) n) -> (Eq.{succ u1} R (Polynomial.coeff.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P) n) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align cubic.coeff_eq_zero Cubic.coeff_eq_zeroₓ'. -/
@[simp]
theorem coeff_eq_zero {n : ℕ} (hn : 3 < n) : P.toPoly.coeff n = 0 :=
  coeffs.1 n hn
#align cubic.coeff_eq_zero Cubic.coeff_eq_zero

#print Cubic.coeff_eq_a /-
@[simp]
theorem coeff_eq_a : P.toPoly.coeff 3 = P.a :=
  coeffs.2.1
#align cubic.coeff_eq_a Cubic.coeff_eq_a
-/

#print Cubic.coeff_eq_b /-
@[simp]
theorem coeff_eq_b : P.toPoly.coeff 2 = P.b :=
  coeffs.2.2.1
#align cubic.coeff_eq_b Cubic.coeff_eq_b
-/

#print Cubic.coeff_eq_c /-
@[simp]
theorem coeff_eq_c : P.toPoly.coeff 1 = P.c :=
  coeffs.2.2.2.1
#align cubic.coeff_eq_c Cubic.coeff_eq_c
-/

#print Cubic.coeff_eq_d /-
@[simp]
theorem coeff_eq_d : P.toPoly.coeff 0 = P.d :=
  coeffs.2.2.2.2
#align cubic.coeff_eq_d Cubic.coeff_eq_d
-/

#print Cubic.a_of_eq /-
theorem a_of_eq (h : P.toPoly = Q.toPoly) : P.a = Q.a := by rw [← coeff_eq_a, h, coeff_eq_a]
#align cubic.a_of_eq Cubic.a_of_eq
-/

#print Cubic.b_of_eq /-
theorem b_of_eq (h : P.toPoly = Q.toPoly) : P.b = Q.b := by rw [← coeff_eq_b, h, coeff_eq_b]
#align cubic.b_of_eq Cubic.b_of_eq
-/

#print Cubic.c_of_eq /-
theorem c_of_eq (h : P.toPoly = Q.toPoly) : P.c = Q.c := by rw [← coeff_eq_c, h, coeff_eq_c]
#align cubic.c_of_eq Cubic.c_of_eq
-/

#print Cubic.d_of_eq /-
theorem d_of_eq (h : P.toPoly = Q.toPoly) : P.d = Q.d := by rw [← coeff_eq_d, h, coeff_eq_d]
#align cubic.d_of_eq Cubic.d_of_eq
-/

#print Cubic.toPoly_injective /-
theorem toPoly_injective (P Q : Cubic R) : P.toPoly = Q.toPoly ↔ P = Q :=
  ⟨fun h => ext P Q (a_of_eq h) (b_of_eq h) (c_of_eq h) (d_of_eq h), congr_arg toPoly⟩
#align cubic.to_poly_injective Cubic.toPoly_injective
-/

/- warning: cubic.of_a_eq_zero -> Cubic.of_a_eq_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} (Polynomial.{u1} R _inst_1) (Cubic.toPoly.{u1} R _inst_1 P) (HAdd.hAdd.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHAdd.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.add'.{u1} R _inst_1)) (HAdd.hAdd.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHAdd.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.add'.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHMul.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.mul'.{u1} R _inst_1)) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) => R -> (Polynomial.{u1} R _inst_1)) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (Polynomial.C.{u1} R _inst_1) (Cubic.b.{u1} R P)) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R _inst_1) Nat (Polynomial.{u1} R _inst_1) (instHPow.{u1, 0} (Polynomial.{u1} R _inst_1) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) (Polynomial.X.{u1} R _inst_1) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHMul.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.mul'.{u1} R _inst_1)) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) => R -> (Polynomial.{u1} R _inst_1)) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (Polynomial.C.{u1} R _inst_1) (Cubic.c.{u1} R P)) (Polynomial.X.{u1} R _inst_1))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) => R -> (Polynomial.{u1} R _inst_1)) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (Polynomial.C.{u1} R _inst_1) (Cubic.d.{u1} R P))))
but is expected to have type
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} (Polynomial.{u1} R _inst_1) (Cubic.toPoly.{u1} R _inst_1 P) (HAdd.hAdd.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) (Cubic.b.{u1} R P)) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) (Cubic.d.{u1} R P)) (Polynomial.{u1} R _inst_1) (instHAdd.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) (Cubic.b.{u1} R P)) (Polynomial.add'.{u1} R _inst_1)) (HAdd.hAdd.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) (Cubic.b.{u1} R P)) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) (Cubic.c.{u1} R P)) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) (Cubic.b.{u1} R P)) (instHAdd.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) (Cubic.b.{u1} R P)) (Polynomial.add'.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) (Cubic.b.{u1} R P)) (Polynomial.{u1} R _inst_1) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) (Cubic.b.{u1} R P)) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) (Cubic.b.{u1} R P)) (Polynomial.mul'.{u1} R _inst_1)) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (Polynomial.C.{u1} R _inst_1) (Cubic.b.{u1} R P)) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R _inst_1) Nat (Polynomial.{u1} R _inst_1) (instHPow.{u1, 0} (Polynomial.{u1} R _inst_1) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) (Polynomial.X.{u1} R _inst_1) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) (Cubic.c.{u1} R P)) (Polynomial.{u1} R _inst_1) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) (Cubic.c.{u1} R P)) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) (Cubic.c.{u1} R P)) (Polynomial.mul'.{u1} R _inst_1)) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (Polynomial.C.{u1} R _inst_1) (Cubic.c.{u1} R P)) (Polynomial.X.{u1} R _inst_1))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (Polynomial.C.{u1} R _inst_1) (Cubic.d.{u1} R P))))
Case conversion may be inaccurate. Consider using '#align cubic.of_a_eq_zero Cubic.of_a_eq_zeroₓ'. -/
theorem of_a_eq_zero (ha : P.a = 0) : P.toPoly = C P.b * X ^ 2 + C P.c * X + C P.d := by
  rw [to_poly, ha, C_0, MulZeroClass.zero_mul, zero_add]
#align cubic.of_a_eq_zero Cubic.of_a_eq_zero

/- warning: cubic.of_a_eq_zero' -> Cubic.of_a_eq_zero' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {b : R} {c : R} {d : R} [_inst_1 : Semiring.{u1} R], Eq.{succ u1} (Polynomial.{u1} R _inst_1) (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) b c d)) (HAdd.hAdd.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHAdd.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.add'.{u1} R _inst_1)) (HAdd.hAdd.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHAdd.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.add'.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHMul.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.mul'.{u1} R _inst_1)) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) => R -> (Polynomial.{u1} R _inst_1)) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (Polynomial.C.{u1} R _inst_1) b) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R _inst_1) Nat (Polynomial.{u1} R _inst_1) (instHPow.{u1, 0} (Polynomial.{u1} R _inst_1) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) (Polynomial.X.{u1} R _inst_1) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHMul.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.mul'.{u1} R _inst_1)) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) => R -> (Polynomial.{u1} R _inst_1)) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (Polynomial.C.{u1} R _inst_1) c) (Polynomial.X.{u1} R _inst_1))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) => R -> (Polynomial.{u1} R _inst_1)) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (Polynomial.C.{u1} R _inst_1) d))
but is expected to have type
  forall {R : Type.{u1}} {b : R} {c : R} {d : R} [_inst_1 : Semiring.{u1} R], Eq.{succ u1} (Polynomial.{u1} R _inst_1) (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) b c d)) (HAdd.hAdd.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) b) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) d) (Polynomial.{u1} R _inst_1) (instHAdd.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) b) (Polynomial.add'.{u1} R _inst_1)) (HAdd.hAdd.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) b) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) c) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) b) (instHAdd.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) b) (Polynomial.add'.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) b) (Polynomial.{u1} R _inst_1) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) b) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) b) (Polynomial.mul'.{u1} R _inst_1)) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (Polynomial.C.{u1} R _inst_1) b) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R _inst_1) Nat (Polynomial.{u1} R _inst_1) (instHPow.{u1, 0} (Polynomial.{u1} R _inst_1) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) (Polynomial.X.{u1} R _inst_1) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) c) (Polynomial.{u1} R _inst_1) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) c) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) c) (Polynomial.mul'.{u1} R _inst_1)) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (Polynomial.C.{u1} R _inst_1) c) (Polynomial.X.{u1} R _inst_1))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (Polynomial.C.{u1} R _inst_1) d))
Case conversion may be inaccurate. Consider using '#align cubic.of_a_eq_zero' Cubic.of_a_eq_zero'ₓ'. -/
theorem of_a_eq_zero' : toPoly ⟨0, b, c, d⟩ = C b * X ^ 2 + C c * X + C d :=
  of_a_eq_zero rfl
#align cubic.of_a_eq_zero' Cubic.of_a_eq_zero'

/- warning: cubic.of_b_eq_zero -> Cubic.of_b_eq_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} (Polynomial.{u1} R _inst_1) (Cubic.toPoly.{u1} R _inst_1 P) (HAdd.hAdd.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHAdd.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.add'.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHMul.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.mul'.{u1} R _inst_1)) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) => R -> (Polynomial.{u1} R _inst_1)) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (Polynomial.C.{u1} R _inst_1) (Cubic.c.{u1} R P)) (Polynomial.X.{u1} R _inst_1)) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) => R -> (Polynomial.{u1} R _inst_1)) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (Polynomial.C.{u1} R _inst_1) (Cubic.d.{u1} R P))))
but is expected to have type
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} (Polynomial.{u1} R _inst_1) (Cubic.toPoly.{u1} R _inst_1 P) (HAdd.hAdd.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) (Cubic.c.{u1} R P)) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) (Cubic.d.{u1} R P)) (Polynomial.{u1} R _inst_1) (instHAdd.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) (Cubic.c.{u1} R P)) (Polynomial.add'.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) (Cubic.c.{u1} R P)) (Polynomial.{u1} R _inst_1) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) (Cubic.c.{u1} R P)) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) (Cubic.c.{u1} R P)) (Polynomial.mul'.{u1} R _inst_1)) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (Polynomial.C.{u1} R _inst_1) (Cubic.c.{u1} R P)) (Polynomial.X.{u1} R _inst_1)) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (Polynomial.C.{u1} R _inst_1) (Cubic.d.{u1} R P))))
Case conversion may be inaccurate. Consider using '#align cubic.of_b_eq_zero Cubic.of_b_eq_zeroₓ'. -/
theorem of_b_eq_zero (ha : P.a = 0) (hb : P.b = 0) : P.toPoly = C P.c * X + C P.d := by
  rw [of_a_eq_zero ha, hb, C_0, MulZeroClass.zero_mul, zero_add]
#align cubic.of_b_eq_zero Cubic.of_b_eq_zero

/- warning: cubic.of_b_eq_zero' -> Cubic.of_b_eq_zero' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {c : R} {d : R} [_inst_1 : Semiring.{u1} R], Eq.{succ u1} (Polynomial.{u1} R _inst_1) (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) c d)) (HAdd.hAdd.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHAdd.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.add'.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHMul.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.mul'.{u1} R _inst_1)) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) => R -> (Polynomial.{u1} R _inst_1)) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (Polynomial.C.{u1} R _inst_1) c) (Polynomial.X.{u1} R _inst_1)) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) => R -> (Polynomial.{u1} R _inst_1)) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (Polynomial.C.{u1} R _inst_1) d))
but is expected to have type
  forall {R : Type.{u1}} {c : R} {d : R} [_inst_1 : Semiring.{u1} R], Eq.{succ u1} (Polynomial.{u1} R _inst_1) (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) c d)) (HAdd.hAdd.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) c) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) d) (Polynomial.{u1} R _inst_1) (instHAdd.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) c) (Polynomial.add'.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) c) (Polynomial.{u1} R _inst_1) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) c) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) c) (Polynomial.mul'.{u1} R _inst_1)) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (Polynomial.C.{u1} R _inst_1) c) (Polynomial.X.{u1} R _inst_1)) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (Polynomial.C.{u1} R _inst_1) d))
Case conversion may be inaccurate. Consider using '#align cubic.of_b_eq_zero' Cubic.of_b_eq_zero'ₓ'. -/
theorem of_b_eq_zero' : toPoly ⟨0, 0, c, d⟩ = C c * X + C d :=
  of_b_eq_zero rfl rfl
#align cubic.of_b_eq_zero' Cubic.of_b_eq_zero'

/- warning: cubic.of_c_eq_zero -> Cubic.of_c_eq_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Cubic.c.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} (Polynomial.{u1} R _inst_1) (Cubic.toPoly.{u1} R _inst_1 P) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) => R -> (Polynomial.{u1} R _inst_1)) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (Polynomial.C.{u1} R _inst_1) (Cubic.d.{u1} R P)))
but is expected to have type
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Cubic.c.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} (Polynomial.{u1} R _inst_1) (Cubic.toPoly.{u1} R _inst_1 P) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (Polynomial.C.{u1} R _inst_1) (Cubic.d.{u1} R P)))
Case conversion may be inaccurate. Consider using '#align cubic.of_c_eq_zero Cubic.of_c_eq_zeroₓ'. -/
theorem of_c_eq_zero (ha : P.a = 0) (hb : P.b = 0) (hc : P.c = 0) : P.toPoly = C P.d := by
  rw [of_b_eq_zero ha hb, hc, C_0, MulZeroClass.zero_mul, zero_add]
#align cubic.of_c_eq_zero Cubic.of_c_eq_zero

/- warning: cubic.of_c_eq_zero' -> Cubic.of_c_eq_zero' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {d : R} [_inst_1 : Semiring.{u1} R], Eq.{succ u1} (Polynomial.{u1} R _inst_1) (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) d)) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) => R -> (Polynomial.{u1} R _inst_1)) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (Polynomial.C.{u1} R _inst_1) d)
but is expected to have type
  forall {R : Type.{u1}} {d : R} [_inst_1 : Semiring.{u1} R], Eq.{succ u1} (Polynomial.{u1} R _inst_1) (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) d)) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (Polynomial.C.{u1} R _inst_1) d)
Case conversion may be inaccurate. Consider using '#align cubic.of_c_eq_zero' Cubic.of_c_eq_zero'ₓ'. -/
theorem of_c_eq_zero' : toPoly ⟨0, 0, 0, d⟩ = C d :=
  of_c_eq_zero rfl rfl rfl
#align cubic.of_c_eq_zero' Cubic.of_c_eq_zero'

/- warning: cubic.of_d_eq_zero -> Cubic.of_d_eq_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Cubic.c.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Cubic.d.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} (Polynomial.{u1} R _inst_1) (Cubic.toPoly.{u1} R _inst_1 P) (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (OfNat.mk.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.zero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1)))))
but is expected to have type
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Cubic.c.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Cubic.d.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} (Polynomial.{u1} R _inst_1) (Cubic.toPoly.{u1} R _inst_1 P) (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align cubic.of_d_eq_zero Cubic.of_d_eq_zeroₓ'. -/
theorem of_d_eq_zero (ha : P.a = 0) (hb : P.b = 0) (hc : P.c = 0) (hd : P.d = 0) : P.toPoly = 0 :=
  by rw [of_c_eq_zero ha hb hc, hd, C_0]
#align cubic.of_d_eq_zero Cubic.of_d_eq_zero

/- warning: cubic.of_d_eq_zero' -> Cubic.of_d_eq_zero' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R], Eq.{succ u1} (Polynomial.{u1} R _inst_1) (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))))) (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (OfNat.mk.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.zero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R], Eq.{succ u1} (Polynomial.{u1} R _inst_1) (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))))) (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1)))
Case conversion may be inaccurate. Consider using '#align cubic.of_d_eq_zero' Cubic.of_d_eq_zero'ₓ'. -/
theorem of_d_eq_zero' : (⟨0, 0, 0, 0⟩ : Cubic R).toPoly = 0 :=
  of_d_eq_zero rfl rfl rfl rfl
#align cubic.of_d_eq_zero' Cubic.of_d_eq_zero'

/- warning: cubic.zero -> Cubic.zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R], Eq.{succ u1} (Polynomial.{u1} R _inst_1) (Cubic.toPoly.{u1} R _inst_1 (OfNat.ofNat.{u1} (Cubic.{u1} R) 0 (OfNat.mk.{u1} (Cubic.{u1} R) 0 (Zero.zero.{u1} (Cubic.{u1} R) (Cubic.hasZero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))))) (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (OfNat.mk.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.zero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R], Eq.{succ u1} (Polynomial.{u1} R _inst_1) (Cubic.toPoly.{u1} R _inst_1 (OfNat.ofNat.{u1} (Cubic.{u1} R) 0 (Zero.toOfNat0.{u1} (Cubic.{u1} R) (Cubic.instZeroCubic.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))))) (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1)))
Case conversion may be inaccurate. Consider using '#align cubic.zero Cubic.zeroₓ'. -/
theorem zero : (0 : Cubic R).toPoly = 0 :=
  of_d_eq_zero'
#align cubic.zero Cubic.zero

/- warning: cubic.to_poly_eq_zero_iff -> Cubic.toPoly_eq_zero_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] (P : Cubic.{u1} R), Iff (Eq.{succ u1} (Polynomial.{u1} R _inst_1) (Cubic.toPoly.{u1} R _inst_1 P) (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (OfNat.mk.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.zero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1))))) (Eq.{succ u1} (Cubic.{u1} R) P (OfNat.ofNat.{u1} (Cubic.{u1} R) 0 (OfNat.mk.{u1} (Cubic.{u1} R) 0 (Zero.zero.{u1} (Cubic.{u1} R) (Cubic.hasZero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] (P : Cubic.{u1} R), Iff (Eq.{succ u1} (Polynomial.{u1} R _inst_1) (Cubic.toPoly.{u1} R _inst_1 P) (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1)))) (Eq.{succ u1} (Cubic.{u1} R) P (OfNat.ofNat.{u1} (Cubic.{u1} R) 0 (Zero.toOfNat0.{u1} (Cubic.{u1} R) (Cubic.instZeroCubic.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))))
Case conversion may be inaccurate. Consider using '#align cubic.to_poly_eq_zero_iff Cubic.toPoly_eq_zero_iffₓ'. -/
theorem toPoly_eq_zero_iff (P : Cubic R) : P.toPoly = 0 ↔ P = 0 := by rw [← zero, to_poly_injective]
#align cubic.to_poly_eq_zero_iff Cubic.toPoly_eq_zero_iff

private theorem ne_zero (h0 : P.a ≠ 0 ∨ P.b ≠ 0 ∨ P.c ≠ 0 ∨ P.d ≠ 0) : P.toPoly ≠ 0 :=
  by
  contrapose! h0
  rw [(to_poly_eq_zero_iff P).mp h0]
  exact ⟨rfl, rfl, rfl, rfl⟩
#align cubic.ne_zero cubic.ne_zero

/- warning: cubic.ne_zero_of_a_ne_zero -> Cubic.ne_zero_of_a_ne_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Ne.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Ne.{succ u1} (Polynomial.{u1} R _inst_1) (Cubic.toPoly.{u1} R _inst_1 P) (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (OfNat.mk.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.zero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1)))))
but is expected to have type
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Ne.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Ne.{succ u1} (Polynomial.{u1} R _inst_1) (Cubic.toPoly.{u1} R _inst_1 P) (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align cubic.ne_zero_of_a_ne_zero Cubic.ne_zero_of_a_ne_zeroₓ'. -/
theorem ne_zero_of_a_ne_zero (ha : P.a ≠ 0) : P.toPoly ≠ 0 :=
  (or_imp.mp NeZero).1 ha
#align cubic.ne_zero_of_a_ne_zero Cubic.ne_zero_of_a_ne_zero

/- warning: cubic.ne_zero_of_b_ne_zero -> Cubic.ne_zero_of_b_ne_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Ne.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Ne.{succ u1} (Polynomial.{u1} R _inst_1) (Cubic.toPoly.{u1} R _inst_1 P) (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (OfNat.mk.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.zero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1)))))
but is expected to have type
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Ne.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Ne.{succ u1} (Polynomial.{u1} R _inst_1) (Cubic.toPoly.{u1} R _inst_1 P) (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align cubic.ne_zero_of_b_ne_zero Cubic.ne_zero_of_b_ne_zeroₓ'. -/
theorem ne_zero_of_b_ne_zero (hb : P.b ≠ 0) : P.toPoly ≠ 0 :=
  (or_imp.mp (or_imp.mp NeZero).2).1 hb
#align cubic.ne_zero_of_b_ne_zero Cubic.ne_zero_of_b_ne_zero

/- warning: cubic.ne_zero_of_c_ne_zero -> Cubic.ne_zero_of_c_ne_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Ne.{succ u1} R (Cubic.c.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Ne.{succ u1} (Polynomial.{u1} R _inst_1) (Cubic.toPoly.{u1} R _inst_1 P) (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (OfNat.mk.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.zero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1)))))
but is expected to have type
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Ne.{succ u1} R (Cubic.c.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Ne.{succ u1} (Polynomial.{u1} R _inst_1) (Cubic.toPoly.{u1} R _inst_1 P) (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align cubic.ne_zero_of_c_ne_zero Cubic.ne_zero_of_c_ne_zeroₓ'. -/
theorem ne_zero_of_c_ne_zero (hc : P.c ≠ 0) : P.toPoly ≠ 0 :=
  (or_imp.mp (or_imp.mp (or_imp.mp NeZero).2).2).1 hc
#align cubic.ne_zero_of_c_ne_zero Cubic.ne_zero_of_c_ne_zero

/- warning: cubic.ne_zero_of_d_ne_zero -> Cubic.ne_zero_of_d_ne_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Ne.{succ u1} R (Cubic.d.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Ne.{succ u1} (Polynomial.{u1} R _inst_1) (Cubic.toPoly.{u1} R _inst_1 P) (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (OfNat.mk.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.zero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1)))))
but is expected to have type
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Ne.{succ u1} R (Cubic.d.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Ne.{succ u1} (Polynomial.{u1} R _inst_1) (Cubic.toPoly.{u1} R _inst_1 P) (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align cubic.ne_zero_of_d_ne_zero Cubic.ne_zero_of_d_ne_zeroₓ'. -/
theorem ne_zero_of_d_ne_zero (hd : P.d ≠ 0) : P.toPoly ≠ 0 :=
  (or_imp.mp (or_imp.mp (or_imp.mp NeZero).2).2).2 hd
#align cubic.ne_zero_of_d_ne_zero Cubic.ne_zero_of_d_ne_zero

/- warning: cubic.leading_coeff_of_a_ne_zero -> Cubic.leadingCoeff_of_a_ne_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Ne.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Polynomial.leadingCoeff.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (Cubic.a.{u1} R P))
but is expected to have type
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Ne.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Polynomial.leadingCoeff.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (Cubic.a.{u1} R P))
Case conversion may be inaccurate. Consider using '#align cubic.leading_coeff_of_a_ne_zero Cubic.leadingCoeff_of_a_ne_zeroₓ'. -/
@[simp]
theorem leadingCoeff_of_a_ne_zero (ha : P.a ≠ 0) : P.toPoly.leadingCoeff = P.a :=
  leadingCoeff_cubic ha
#align cubic.leading_coeff_of_a_ne_zero Cubic.leadingCoeff_of_a_ne_zero

/- warning: cubic.leading_coeff_of_a_ne_zero' -> Cubic.leadingCoeff_of_a_ne_zero' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {a : R} {b : R} {c : R} {d : R} [_inst_1 : Semiring.{u1} R], (Ne.{succ u1} R a (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Polynomial.leadingCoeff.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R a b c d))) a)
but is expected to have type
  forall {R : Type.{u1}} {a : R} {b : R} {c : R} {d : R} [_inst_1 : Semiring.{u1} R], (Ne.{succ u1} R a (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Polynomial.leadingCoeff.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R a b c d))) a)
Case conversion may be inaccurate. Consider using '#align cubic.leading_coeff_of_a_ne_zero' Cubic.leadingCoeff_of_a_ne_zero'ₓ'. -/
@[simp]
theorem leadingCoeff_of_a_ne_zero' (ha : a ≠ 0) : (toPoly ⟨a, b, c, d⟩).leadingCoeff = a :=
  leadingCoeff_of_a_ne_zero ha
#align cubic.leading_coeff_of_a_ne_zero' Cubic.leadingCoeff_of_a_ne_zero'

/- warning: cubic.leading_coeff_of_b_ne_zero -> Cubic.leadingCoeff_of_b_ne_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Ne.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Polynomial.leadingCoeff.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (Cubic.b.{u1} R P))
but is expected to have type
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Ne.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Polynomial.leadingCoeff.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (Cubic.b.{u1} R P))
Case conversion may be inaccurate. Consider using '#align cubic.leading_coeff_of_b_ne_zero Cubic.leadingCoeff_of_b_ne_zeroₓ'. -/
@[simp]
theorem leadingCoeff_of_b_ne_zero (ha : P.a = 0) (hb : P.b ≠ 0) : P.toPoly.leadingCoeff = P.b := by
  rw [of_a_eq_zero ha, leading_coeff_quadratic hb]
#align cubic.leading_coeff_of_b_ne_zero Cubic.leadingCoeff_of_b_ne_zero

/- warning: cubic.leading_coeff_of_b_ne_zero' -> Cubic.leadingCoeff_of_b_ne_zero' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {b : R} {c : R} {d : R} [_inst_1 : Semiring.{u1} R], (Ne.{succ u1} R b (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Polynomial.leadingCoeff.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) b c d))) b)
but is expected to have type
  forall {R : Type.{u1}} {b : R} {c : R} {d : R} [_inst_1 : Semiring.{u1} R], (Ne.{succ u1} R b (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Polynomial.leadingCoeff.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) b c d))) b)
Case conversion may be inaccurate. Consider using '#align cubic.leading_coeff_of_b_ne_zero' Cubic.leadingCoeff_of_b_ne_zero'ₓ'. -/
@[simp]
theorem leadingCoeff_of_b_ne_zero' (hb : b ≠ 0) : (toPoly ⟨0, b, c, d⟩).leadingCoeff = b :=
  leadingCoeff_of_b_ne_zero rfl hb
#align cubic.leading_coeff_of_b_ne_zero' Cubic.leadingCoeff_of_b_ne_zero'

/- warning: cubic.leading_coeff_of_c_ne_zero -> Cubic.leadingCoeff_of_c_ne_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Ne.{succ u1} R (Cubic.c.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Polynomial.leadingCoeff.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (Cubic.c.{u1} R P))
but is expected to have type
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Ne.{succ u1} R (Cubic.c.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Polynomial.leadingCoeff.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (Cubic.c.{u1} R P))
Case conversion may be inaccurate. Consider using '#align cubic.leading_coeff_of_c_ne_zero Cubic.leadingCoeff_of_c_ne_zeroₓ'. -/
@[simp]
theorem leadingCoeff_of_c_ne_zero (ha : P.a = 0) (hb : P.b = 0) (hc : P.c ≠ 0) :
    P.toPoly.leadingCoeff = P.c := by rw [of_b_eq_zero ha hb, leading_coeff_linear hc]
#align cubic.leading_coeff_of_c_ne_zero Cubic.leadingCoeff_of_c_ne_zero

/- warning: cubic.leading_coeff_of_c_ne_zero' -> Cubic.leadingCoeff_of_c_ne_zero' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {c : R} {d : R} [_inst_1 : Semiring.{u1} R], (Ne.{succ u1} R c (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Polynomial.leadingCoeff.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) c d))) c)
but is expected to have type
  forall {R : Type.{u1}} {c : R} {d : R} [_inst_1 : Semiring.{u1} R], (Ne.{succ u1} R c (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Polynomial.leadingCoeff.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) c d))) c)
Case conversion may be inaccurate. Consider using '#align cubic.leading_coeff_of_c_ne_zero' Cubic.leadingCoeff_of_c_ne_zero'ₓ'. -/
@[simp]
theorem leadingCoeff_of_c_ne_zero' (hc : c ≠ 0) : (toPoly ⟨0, 0, c, d⟩).leadingCoeff = c :=
  leadingCoeff_of_c_ne_zero rfl rfl hc
#align cubic.leading_coeff_of_c_ne_zero' Cubic.leadingCoeff_of_c_ne_zero'

/- warning: cubic.leading_coeff_of_c_eq_zero -> Cubic.leadingCoeff_of_c_eq_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Cubic.c.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Polynomial.leadingCoeff.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (Cubic.d.{u1} R P))
but is expected to have type
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Cubic.c.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Polynomial.leadingCoeff.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (Cubic.d.{u1} R P))
Case conversion may be inaccurate. Consider using '#align cubic.leading_coeff_of_c_eq_zero Cubic.leadingCoeff_of_c_eq_zeroₓ'. -/
@[simp]
theorem leadingCoeff_of_c_eq_zero (ha : P.a = 0) (hb : P.b = 0) (hc : P.c = 0) :
    P.toPoly.leadingCoeff = P.d := by rw [of_c_eq_zero ha hb hc, leading_coeff_C]
#align cubic.leading_coeff_of_c_eq_zero Cubic.leadingCoeff_of_c_eq_zero

/- warning: cubic.leading_coeff_of_c_eq_zero' -> Cubic.leadingCoeff_of_c_eq_zero' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {d : R} [_inst_1 : Semiring.{u1} R], Eq.{succ u1} R (Polynomial.leadingCoeff.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) d))) d
but is expected to have type
  forall {R : Type.{u1}} {d : R} [_inst_1 : Semiring.{u1} R], Eq.{succ u1} R (Polynomial.leadingCoeff.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) d))) d
Case conversion may be inaccurate. Consider using '#align cubic.leading_coeff_of_c_eq_zero' Cubic.leadingCoeff_of_c_eq_zero'ₓ'. -/
@[simp]
theorem leadingCoeff_of_c_eq_zero' : (toPoly ⟨0, 0, 0, d⟩).leadingCoeff = d :=
  leadingCoeff_of_c_eq_zero rfl rfl rfl
#align cubic.leading_coeff_of_c_eq_zero' Cubic.leadingCoeff_of_c_eq_zero'

#print Cubic.monic_of_a_eq_one /-
theorem monic_of_a_eq_one (ha : P.a = 1) : P.toPoly.Monic :=
  by
  nontriviality
  rw [monic,
    leading_coeff_of_a_ne_zero <| by
      rw [ha]
      exact one_ne_zero,
    ha]
#align cubic.monic_of_a_eq_one Cubic.monic_of_a_eq_one
-/

#print Cubic.monic_of_a_eq_one' /-
theorem monic_of_a_eq_one' : (toPoly ⟨1, b, c, d⟩).Monic :=
  monic_of_a_eq_one rfl
#align cubic.monic_of_a_eq_one' Cubic.monic_of_a_eq_one'
-/

/- warning: cubic.monic_of_b_eq_one -> Cubic.monic_of_b_eq_one is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Polynomial.Monic.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P))
but is expected to have type
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R _inst_1)))) -> (Polynomial.Monic.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P))
Case conversion may be inaccurate. Consider using '#align cubic.monic_of_b_eq_one Cubic.monic_of_b_eq_oneₓ'. -/
theorem monic_of_b_eq_one (ha : P.a = 0) (hb : P.b = 1) : P.toPoly.Monic :=
  by
  nontriviality
  rw [monic,
    leading_coeff_of_b_ne_zero ha <| by
      rw [hb]
      exact one_ne_zero,
    hb]
#align cubic.monic_of_b_eq_one Cubic.monic_of_b_eq_one

/- warning: cubic.monic_of_b_eq_one' -> Cubic.monic_of_b_eq_one' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {c : R} {d : R} [_inst_1 : Semiring.{u1} R], Polynomial.Monic.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) c d))
but is expected to have type
  forall {R : Type.{u1}} {c : R} {d : R} [_inst_1 : Semiring.{u1} R], Polynomial.Monic.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R _inst_1))) c d))
Case conversion may be inaccurate. Consider using '#align cubic.monic_of_b_eq_one' Cubic.monic_of_b_eq_one'ₓ'. -/
theorem monic_of_b_eq_one' : (toPoly ⟨0, 1, c, d⟩).Monic :=
  monic_of_b_eq_one rfl rfl
#align cubic.monic_of_b_eq_one' Cubic.monic_of_b_eq_one'

/- warning: cubic.monic_of_c_eq_one -> Cubic.monic_of_c_eq_one is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Cubic.c.{u1} R P) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Polynomial.Monic.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P))
but is expected to have type
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Cubic.c.{u1} R P) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R _inst_1)))) -> (Polynomial.Monic.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P))
Case conversion may be inaccurate. Consider using '#align cubic.monic_of_c_eq_one Cubic.monic_of_c_eq_oneₓ'. -/
theorem monic_of_c_eq_one (ha : P.a = 0) (hb : P.b = 0) (hc : P.c = 1) : P.toPoly.Monic :=
  by
  nontriviality
  rw [monic,
    leading_coeff_of_c_ne_zero ha hb <| by
      rw [hc]
      exact one_ne_zero,
    hc]
#align cubic.monic_of_c_eq_one Cubic.monic_of_c_eq_one

/- warning: cubic.monic_of_c_eq_one' -> Cubic.monic_of_c_eq_one' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {d : R} [_inst_1 : Semiring.{u1} R], Polynomial.Monic.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) d))
but is expected to have type
  forall {R : Type.{u1}} {d : R} [_inst_1 : Semiring.{u1} R], Polynomial.Monic.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R _inst_1))) d))
Case conversion may be inaccurate. Consider using '#align cubic.monic_of_c_eq_one' Cubic.monic_of_c_eq_one'ₓ'. -/
theorem monic_of_c_eq_one' : (toPoly ⟨0, 0, 1, d⟩).Monic :=
  monic_of_c_eq_one rfl rfl rfl
#align cubic.monic_of_c_eq_one' Cubic.monic_of_c_eq_one'

/- warning: cubic.monic_of_d_eq_one -> Cubic.monic_of_d_eq_one is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Cubic.c.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Cubic.d.{u1} R P) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Polynomial.Monic.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P))
but is expected to have type
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Cubic.c.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Cubic.d.{u1} R P) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R _inst_1)))) -> (Polynomial.Monic.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P))
Case conversion may be inaccurate. Consider using '#align cubic.monic_of_d_eq_one Cubic.monic_of_d_eq_oneₓ'. -/
theorem monic_of_d_eq_one (ha : P.a = 0) (hb : P.b = 0) (hc : P.c = 0) (hd : P.d = 1) :
    P.toPoly.Monic := by rw [monic, leading_coeff_of_c_eq_zero ha hb hc, hd]
#align cubic.monic_of_d_eq_one Cubic.monic_of_d_eq_one

#print Cubic.monic_of_d_eq_one' /-
theorem monic_of_d_eq_one' : (toPoly ⟨0, 0, 0, 1⟩).Monic :=
  monic_of_d_eq_one rfl rfl rfl rfl
#align cubic.monic_of_d_eq_one' Cubic.monic_of_d_eq_one'
-/

end Coeff

/-! ### Degrees -/


section Degree

#print Cubic.equiv /-
/-- The equivalence between cubic polynomials and polynomials of degree at most three. -/
@[simps]
def equiv : Cubic R ≃ { p : R[X] // p.degree ≤ 3 }
    where
  toFun P := ⟨P.toPoly, degree_cubic_le⟩
  invFun f := ⟨coeff f 3, coeff f 2, coeff f 1, coeff f 0⟩
  left_inv P := by ext <;> simp only [Subtype.coe_mk, coeffs]
  right_inv f := by
    ext (_ | _ | _ | _ | n) <;> simp only [Subtype.coe_mk, coeffs]
    have h3 : 3 < n + 4 := by linarith only
    rw [coeff_eq_zero h3,
      (degree_le_iff_coeff_zero (f : R[X]) 3).mp f.2 _ <| with_bot.coe_lt_coe.mpr h3]
#align cubic.equiv Cubic.equiv
-/

/- warning: cubic.degree_of_a_ne_zero -> Cubic.degree_of_a_ne_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Ne.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (OfNat.ofNat.{0} (WithBot.{0} Nat) 3 (OfNat.mk.{0} (WithBot.{0} Nat) 3 (bit1.{0} (WithBot.{0} Nat) (WithBot.hasOne.{0} Nat Nat.hasOne) (WithBot.hasAdd.{0} Nat Nat.hasAdd) (One.one.{0} (WithBot.{0} Nat) (WithBot.hasOne.{0} Nat Nat.hasOne))))))
but is expected to have type
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Ne.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (OfNat.ofNat.{0} (WithBot.{0} Nat) 3 (instOfNat.{0} (WithBot.{0} Nat) 3 (Semiring.toNatCast.{0} (WithBot.{0} Nat) (OrderedSemiring.toSemiring.{0} (WithBot.{0} Nat) (OrderedCommSemiring.toOrderedSemiring.{0} (WithBot.{0} Nat) (WithBot.orderedCommSemiring.{0} Nat (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.canonicallyOrderedCommSemiring Nat.nontrivial)))) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))))
Case conversion may be inaccurate. Consider using '#align cubic.degree_of_a_ne_zero Cubic.degree_of_a_ne_zeroₓ'. -/
@[simp]
theorem degree_of_a_ne_zero (ha : P.a ≠ 0) : P.toPoly.degree = 3 :=
  degree_cubic ha
#align cubic.degree_of_a_ne_zero Cubic.degree_of_a_ne_zero

/- warning: cubic.degree_of_a_ne_zero' -> Cubic.degree_of_a_ne_zero' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {a : R} {b : R} {c : R} {d : R} [_inst_1 : Semiring.{u1} R], (Ne.{succ u1} R a (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R a b c d))) (OfNat.ofNat.{0} (WithBot.{0} Nat) 3 (OfNat.mk.{0} (WithBot.{0} Nat) 3 (bit1.{0} (WithBot.{0} Nat) (WithBot.hasOne.{0} Nat Nat.hasOne) (WithBot.hasAdd.{0} Nat Nat.hasAdd) (One.one.{0} (WithBot.{0} Nat) (WithBot.hasOne.{0} Nat Nat.hasOne))))))
but is expected to have type
  forall {R : Type.{u1}} {a : R} {b : R} {c : R} {d : R} [_inst_1 : Semiring.{u1} R], (Ne.{succ u1} R a (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R a b c d))) (OfNat.ofNat.{0} (WithBot.{0} Nat) 3 (instOfNat.{0} (WithBot.{0} Nat) 3 (Semiring.toNatCast.{0} (WithBot.{0} Nat) (OrderedSemiring.toSemiring.{0} (WithBot.{0} Nat) (OrderedCommSemiring.toOrderedSemiring.{0} (WithBot.{0} Nat) (WithBot.orderedCommSemiring.{0} Nat (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.canonicallyOrderedCommSemiring Nat.nontrivial)))) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))))
Case conversion may be inaccurate. Consider using '#align cubic.degree_of_a_ne_zero' Cubic.degree_of_a_ne_zero'ₓ'. -/
@[simp]
theorem degree_of_a_ne_zero' (ha : a ≠ 0) : (toPoly ⟨a, b, c, d⟩).degree = 3 :=
  degree_of_a_ne_zero ha
#align cubic.degree_of_a_ne_zero' Cubic.degree_of_a_ne_zero'

/- warning: cubic.degree_of_a_eq_zero -> Cubic.degree_of_a_eq_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (LE.le.{0} (WithBot.{0} Nat) (Preorder.toLE.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (Polynomial.degree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (OfNat.ofNat.{0} (WithBot.{0} Nat) 2 (OfNat.mk.{0} (WithBot.{0} Nat) 2 (bit0.{0} (WithBot.{0} Nat) (WithBot.hasAdd.{0} Nat Nat.hasAdd) (One.one.{0} (WithBot.{0} Nat) (WithBot.hasOne.{0} Nat Nat.hasOne))))))
but is expected to have type
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (LE.le.{0} (WithBot.{0} Nat) (Preorder.toLE.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))) (Polynomial.degree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (OfNat.ofNat.{0} (WithBot.{0} Nat) 2 (instOfNat.{0} (WithBot.{0} Nat) 2 (Semiring.toNatCast.{0} (WithBot.{0} Nat) (OrderedSemiring.toSemiring.{0} (WithBot.{0} Nat) (OrderedCommSemiring.toOrderedSemiring.{0} (WithBot.{0} Nat) (WithBot.orderedCommSemiring.{0} Nat (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.canonicallyOrderedCommSemiring Nat.nontrivial)))) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))))
Case conversion may be inaccurate. Consider using '#align cubic.degree_of_a_eq_zero Cubic.degree_of_a_eq_zeroₓ'. -/
theorem degree_of_a_eq_zero (ha : P.a = 0) : P.toPoly.degree ≤ 2 := by
  simpa only [of_a_eq_zero ha] using degree_quadratic_le
#align cubic.degree_of_a_eq_zero Cubic.degree_of_a_eq_zero

/- warning: cubic.degree_of_a_eq_zero' -> Cubic.degree_of_a_eq_zero' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {b : R} {c : R} {d : R} [_inst_1 : Semiring.{u1} R], LE.le.{0} (WithBot.{0} Nat) (Preorder.toLE.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (Polynomial.degree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) b c d))) (OfNat.ofNat.{0} (WithBot.{0} Nat) 2 (OfNat.mk.{0} (WithBot.{0} Nat) 2 (bit0.{0} (WithBot.{0} Nat) (WithBot.hasAdd.{0} Nat Nat.hasAdd) (One.one.{0} (WithBot.{0} Nat) (WithBot.hasOne.{0} Nat Nat.hasOne)))))
but is expected to have type
  forall {R : Type.{u1}} {b : R} {c : R} {d : R} [_inst_1 : Semiring.{u1} R], LE.le.{0} (WithBot.{0} Nat) (Preorder.toLE.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))) (Polynomial.degree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) b c d))) (OfNat.ofNat.{0} (WithBot.{0} Nat) 2 (instOfNat.{0} (WithBot.{0} Nat) 2 (Semiring.toNatCast.{0} (WithBot.{0} Nat) (OrderedSemiring.toSemiring.{0} (WithBot.{0} Nat) (OrderedCommSemiring.toOrderedSemiring.{0} (WithBot.{0} Nat) (WithBot.orderedCommSemiring.{0} Nat (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.canonicallyOrderedCommSemiring Nat.nontrivial)))) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))
Case conversion may be inaccurate. Consider using '#align cubic.degree_of_a_eq_zero' Cubic.degree_of_a_eq_zero'ₓ'. -/
theorem degree_of_a_eq_zero' : (toPoly ⟨0, b, c, d⟩).degree ≤ 2 :=
  degree_of_a_eq_zero rfl
#align cubic.degree_of_a_eq_zero' Cubic.degree_of_a_eq_zero'

/- warning: cubic.degree_of_b_ne_zero -> Cubic.degree_of_b_ne_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Ne.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (OfNat.ofNat.{0} (WithBot.{0} Nat) 2 (OfNat.mk.{0} (WithBot.{0} Nat) 2 (bit0.{0} (WithBot.{0} Nat) (WithBot.hasAdd.{0} Nat Nat.hasAdd) (One.one.{0} (WithBot.{0} Nat) (WithBot.hasOne.{0} Nat Nat.hasOne))))))
but is expected to have type
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Ne.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (OfNat.ofNat.{0} (WithBot.{0} Nat) 2 (instOfNat.{0} (WithBot.{0} Nat) 2 (Semiring.toNatCast.{0} (WithBot.{0} Nat) (OrderedSemiring.toSemiring.{0} (WithBot.{0} Nat) (OrderedCommSemiring.toOrderedSemiring.{0} (WithBot.{0} Nat) (WithBot.orderedCommSemiring.{0} Nat (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.canonicallyOrderedCommSemiring Nat.nontrivial)))) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))))
Case conversion may be inaccurate. Consider using '#align cubic.degree_of_b_ne_zero Cubic.degree_of_b_ne_zeroₓ'. -/
@[simp]
theorem degree_of_b_ne_zero (ha : P.a = 0) (hb : P.b ≠ 0) : P.toPoly.degree = 2 := by
  rw [of_a_eq_zero ha, degree_quadratic hb]
#align cubic.degree_of_b_ne_zero Cubic.degree_of_b_ne_zero

/- warning: cubic.degree_of_b_ne_zero' -> Cubic.degree_of_b_ne_zero' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {b : R} {c : R} {d : R} [_inst_1 : Semiring.{u1} R], (Ne.{succ u1} R b (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) b c d))) (OfNat.ofNat.{0} (WithBot.{0} Nat) 2 (OfNat.mk.{0} (WithBot.{0} Nat) 2 (bit0.{0} (WithBot.{0} Nat) (WithBot.hasAdd.{0} Nat Nat.hasAdd) (One.one.{0} (WithBot.{0} Nat) (WithBot.hasOne.{0} Nat Nat.hasOne))))))
but is expected to have type
  forall {R : Type.{u1}} {b : R} {c : R} {d : R} [_inst_1 : Semiring.{u1} R], (Ne.{succ u1} R b (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) b c d))) (OfNat.ofNat.{0} (WithBot.{0} Nat) 2 (instOfNat.{0} (WithBot.{0} Nat) 2 (Semiring.toNatCast.{0} (WithBot.{0} Nat) (OrderedSemiring.toSemiring.{0} (WithBot.{0} Nat) (OrderedCommSemiring.toOrderedSemiring.{0} (WithBot.{0} Nat) (WithBot.orderedCommSemiring.{0} Nat (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.canonicallyOrderedCommSemiring Nat.nontrivial)))) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))))
Case conversion may be inaccurate. Consider using '#align cubic.degree_of_b_ne_zero' Cubic.degree_of_b_ne_zero'ₓ'. -/
@[simp]
theorem degree_of_b_ne_zero' (hb : b ≠ 0) : (toPoly ⟨0, b, c, d⟩).degree = 2 :=
  degree_of_b_ne_zero rfl hb
#align cubic.degree_of_b_ne_zero' Cubic.degree_of_b_ne_zero'

/- warning: cubic.degree_of_b_eq_zero -> Cubic.degree_of_b_eq_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (LE.le.{0} (WithBot.{0} Nat) (Preorder.toLE.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (Polynomial.degree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (OfNat.ofNat.{0} (WithBot.{0} Nat) 1 (OfNat.mk.{0} (WithBot.{0} Nat) 1 (One.one.{0} (WithBot.{0} Nat) (WithBot.hasOne.{0} Nat Nat.hasOne)))))
but is expected to have type
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (LE.le.{0} (WithBot.{0} Nat) (Preorder.toLE.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))) (Polynomial.degree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (OfNat.ofNat.{0} (WithBot.{0} Nat) 1 (One.toOfNat1.{0} (WithBot.{0} Nat) (WithBot.one.{0} Nat (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)))))
Case conversion may be inaccurate. Consider using '#align cubic.degree_of_b_eq_zero Cubic.degree_of_b_eq_zeroₓ'. -/
theorem degree_of_b_eq_zero (ha : P.a = 0) (hb : P.b = 0) : P.toPoly.degree ≤ 1 := by
  simpa only [of_b_eq_zero ha hb] using degree_linear_le
#align cubic.degree_of_b_eq_zero Cubic.degree_of_b_eq_zero

/- warning: cubic.degree_of_b_eq_zero' -> Cubic.degree_of_b_eq_zero' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {c : R} {d : R} [_inst_1 : Semiring.{u1} R], LE.le.{0} (WithBot.{0} Nat) (Preorder.toLE.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (Polynomial.degree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) c d))) (OfNat.ofNat.{0} (WithBot.{0} Nat) 1 (OfNat.mk.{0} (WithBot.{0} Nat) 1 (One.one.{0} (WithBot.{0} Nat) (WithBot.hasOne.{0} Nat Nat.hasOne))))
but is expected to have type
  forall {R : Type.{u1}} {c : R} {d : R} [_inst_1 : Semiring.{u1} R], LE.le.{0} (WithBot.{0} Nat) (Preorder.toLE.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))) (Polynomial.degree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) c d))) (OfNat.ofNat.{0} (WithBot.{0} Nat) 1 (One.toOfNat1.{0} (WithBot.{0} Nat) (WithBot.one.{0} Nat (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring))))
Case conversion may be inaccurate. Consider using '#align cubic.degree_of_b_eq_zero' Cubic.degree_of_b_eq_zero'ₓ'. -/
theorem degree_of_b_eq_zero' : (toPoly ⟨0, 0, c, d⟩).degree ≤ 1 :=
  degree_of_b_eq_zero rfl rfl
#align cubic.degree_of_b_eq_zero' Cubic.degree_of_b_eq_zero'

/- warning: cubic.degree_of_c_ne_zero -> Cubic.degree_of_c_ne_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Ne.{succ u1} R (Cubic.c.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (OfNat.ofNat.{0} (WithBot.{0} Nat) 1 (OfNat.mk.{0} (WithBot.{0} Nat) 1 (One.one.{0} (WithBot.{0} Nat) (WithBot.hasOne.{0} Nat Nat.hasOne)))))
but is expected to have type
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Ne.{succ u1} R (Cubic.c.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (OfNat.ofNat.{0} (WithBot.{0} Nat) 1 (One.toOfNat1.{0} (WithBot.{0} Nat) (WithBot.one.{0} Nat (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)))))
Case conversion may be inaccurate. Consider using '#align cubic.degree_of_c_ne_zero Cubic.degree_of_c_ne_zeroₓ'. -/
@[simp]
theorem degree_of_c_ne_zero (ha : P.a = 0) (hb : P.b = 0) (hc : P.c ≠ 0) : P.toPoly.degree = 1 := by
  rw [of_b_eq_zero ha hb, degree_linear hc]
#align cubic.degree_of_c_ne_zero Cubic.degree_of_c_ne_zero

/- warning: cubic.degree_of_c_ne_zero' -> Cubic.degree_of_c_ne_zero' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {c : R} {d : R} [_inst_1 : Semiring.{u1} R], (Ne.{succ u1} R c (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) c d))) (OfNat.ofNat.{0} (WithBot.{0} Nat) 1 (OfNat.mk.{0} (WithBot.{0} Nat) 1 (One.one.{0} (WithBot.{0} Nat) (WithBot.hasOne.{0} Nat Nat.hasOne)))))
but is expected to have type
  forall {R : Type.{u1}} {c : R} {d : R} [_inst_1 : Semiring.{u1} R], (Ne.{succ u1} R c (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) c d))) (OfNat.ofNat.{0} (WithBot.{0} Nat) 1 (One.toOfNat1.{0} (WithBot.{0} Nat) (WithBot.one.{0} Nat (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)))))
Case conversion may be inaccurate. Consider using '#align cubic.degree_of_c_ne_zero' Cubic.degree_of_c_ne_zero'ₓ'. -/
@[simp]
theorem degree_of_c_ne_zero' (hc : c ≠ 0) : (toPoly ⟨0, 0, c, d⟩).degree = 1 :=
  degree_of_c_ne_zero rfl rfl hc
#align cubic.degree_of_c_ne_zero' Cubic.degree_of_c_ne_zero'

/- warning: cubic.degree_of_c_eq_zero -> Cubic.degree_of_c_eq_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Cubic.c.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (LE.le.{0} (WithBot.{0} Nat) (Preorder.toLE.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (Polynomial.degree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (OfNat.mk.{0} (WithBot.{0} Nat) 0 (Zero.zero.{0} (WithBot.{0} Nat) (WithBot.hasZero.{0} Nat Nat.hasZero)))))
but is expected to have type
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Cubic.c.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (LE.le.{0} (WithBot.{0} Nat) (Preorder.toLE.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))) (Polynomial.degree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (Zero.toOfNat0.{0} (WithBot.{0} Nat) (WithBot.zero.{0} Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)))))
Case conversion may be inaccurate. Consider using '#align cubic.degree_of_c_eq_zero Cubic.degree_of_c_eq_zeroₓ'. -/
theorem degree_of_c_eq_zero (ha : P.a = 0) (hb : P.b = 0) (hc : P.c = 0) : P.toPoly.degree ≤ 0 := by
  simpa only [of_c_eq_zero ha hb hc] using degree_C_le
#align cubic.degree_of_c_eq_zero Cubic.degree_of_c_eq_zero

/- warning: cubic.degree_of_c_eq_zero' -> Cubic.degree_of_c_eq_zero' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {d : R} [_inst_1 : Semiring.{u1} R], LE.le.{0} (WithBot.{0} Nat) (Preorder.toLE.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (Polynomial.degree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) d))) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (OfNat.mk.{0} (WithBot.{0} Nat) 0 (Zero.zero.{0} (WithBot.{0} Nat) (WithBot.hasZero.{0} Nat Nat.hasZero))))
but is expected to have type
  forall {R : Type.{u1}} {d : R} [_inst_1 : Semiring.{u1} R], LE.le.{0} (WithBot.{0} Nat) (Preorder.toLE.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))) (Polynomial.degree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) d))) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (Zero.toOfNat0.{0} (WithBot.{0} Nat) (WithBot.zero.{0} Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))))
Case conversion may be inaccurate. Consider using '#align cubic.degree_of_c_eq_zero' Cubic.degree_of_c_eq_zero'ₓ'. -/
theorem degree_of_c_eq_zero' : (toPoly ⟨0, 0, 0, d⟩).degree ≤ 0 :=
  degree_of_c_eq_zero rfl rfl rfl
#align cubic.degree_of_c_eq_zero' Cubic.degree_of_c_eq_zero'

/- warning: cubic.degree_of_d_ne_zero -> Cubic.degree_of_d_ne_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Cubic.c.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Ne.{succ u1} R (Cubic.d.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (OfNat.mk.{0} (WithBot.{0} Nat) 0 (Zero.zero.{0} (WithBot.{0} Nat) (WithBot.hasZero.{0} Nat Nat.hasZero)))))
but is expected to have type
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Cubic.c.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Ne.{succ u1} R (Cubic.d.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (Zero.toOfNat0.{0} (WithBot.{0} Nat) (WithBot.zero.{0} Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)))))
Case conversion may be inaccurate. Consider using '#align cubic.degree_of_d_ne_zero Cubic.degree_of_d_ne_zeroₓ'. -/
@[simp]
theorem degree_of_d_ne_zero (ha : P.a = 0) (hb : P.b = 0) (hc : P.c = 0) (hd : P.d ≠ 0) :
    P.toPoly.degree = 0 := by rw [of_c_eq_zero ha hb hc, degree_C hd]
#align cubic.degree_of_d_ne_zero Cubic.degree_of_d_ne_zero

/- warning: cubic.degree_of_d_ne_zero' -> Cubic.degree_of_d_ne_zero' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {d : R} [_inst_1 : Semiring.{u1} R], (Ne.{succ u1} R d (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) d))) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (OfNat.mk.{0} (WithBot.{0} Nat) 0 (Zero.zero.{0} (WithBot.{0} Nat) (WithBot.hasZero.{0} Nat Nat.hasZero)))))
but is expected to have type
  forall {R : Type.{u1}} {d : R} [_inst_1 : Semiring.{u1} R], (Ne.{succ u1} R d (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) d))) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (Zero.toOfNat0.{0} (WithBot.{0} Nat) (WithBot.zero.{0} Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)))))
Case conversion may be inaccurate. Consider using '#align cubic.degree_of_d_ne_zero' Cubic.degree_of_d_ne_zero'ₓ'. -/
@[simp]
theorem degree_of_d_ne_zero' (hd : d ≠ 0) : (toPoly ⟨0, 0, 0, d⟩).degree = 0 :=
  degree_of_d_ne_zero rfl rfl rfl hd
#align cubic.degree_of_d_ne_zero' Cubic.degree_of_d_ne_zero'

/- warning: cubic.degree_of_d_eq_zero -> Cubic.degree_of_d_eq_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Cubic.c.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Cubic.d.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (Bot.bot.{0} (WithBot.{0} Nat) (WithBot.hasBot.{0} Nat)))
but is expected to have type
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Cubic.c.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Cubic.d.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (Bot.bot.{0} (WithBot.{0} Nat) (WithBot.bot.{0} Nat)))
Case conversion may be inaccurate. Consider using '#align cubic.degree_of_d_eq_zero Cubic.degree_of_d_eq_zeroₓ'. -/
@[simp]
theorem degree_of_d_eq_zero (ha : P.a = 0) (hb : P.b = 0) (hc : P.c = 0) (hd : P.d = 0) :
    P.toPoly.degree = ⊥ := by rw [of_d_eq_zero ha hb hc hd, degree_zero]
#align cubic.degree_of_d_eq_zero Cubic.degree_of_d_eq_zero

/- warning: cubic.degree_of_d_eq_zero' -> Cubic.degree_of_d_eq_zero' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R], Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))))) (Bot.bot.{0} (WithBot.{0} Nat) (WithBot.hasBot.{0} Nat))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R], Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))))) (Bot.bot.{0} (WithBot.{0} Nat) (WithBot.bot.{0} Nat))
Case conversion may be inaccurate. Consider using '#align cubic.degree_of_d_eq_zero' Cubic.degree_of_d_eq_zero'ₓ'. -/
@[simp]
theorem degree_of_d_eq_zero' : (⟨0, 0, 0, 0⟩ : Cubic R).toPoly.degree = ⊥ :=
  degree_of_d_eq_zero rfl rfl rfl rfl
#align cubic.degree_of_d_eq_zero' Cubic.degree_of_d_eq_zero'

/- warning: cubic.degree_of_zero -> Cubic.degree_of_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R], Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (OfNat.ofNat.{u1} (Cubic.{u1} R) 0 (OfNat.mk.{u1} (Cubic.{u1} R) 0 (Zero.zero.{u1} (Cubic.{u1} R) (Cubic.hasZero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))))) (Bot.bot.{0} (WithBot.{0} Nat) (WithBot.hasBot.{0} Nat))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R], Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (OfNat.ofNat.{u1} (Cubic.{u1} R) 0 (Zero.toOfNat0.{u1} (Cubic.{u1} R) (Cubic.instZeroCubic.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))))) (Bot.bot.{0} (WithBot.{0} Nat) (WithBot.bot.{0} Nat))
Case conversion may be inaccurate. Consider using '#align cubic.degree_of_zero Cubic.degree_of_zeroₓ'. -/
@[simp]
theorem degree_of_zero : (0 : Cubic R).toPoly.degree = ⊥ :=
  degree_of_d_eq_zero'
#align cubic.degree_of_zero Cubic.degree_of_zero

/- warning: cubic.nat_degree_of_a_ne_zero -> Cubic.natDegree_of_a_ne_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Ne.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{1} Nat (Polynomial.natDegree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))
but is expected to have type
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Ne.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{1} Nat (Polynomial.natDegree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3)))
Case conversion may be inaccurate. Consider using '#align cubic.nat_degree_of_a_ne_zero Cubic.natDegree_of_a_ne_zeroₓ'. -/
@[simp]
theorem natDegree_of_a_ne_zero (ha : P.a ≠ 0) : P.toPoly.natDegree = 3 :=
  natDegree_cubic ha
#align cubic.nat_degree_of_a_ne_zero Cubic.natDegree_of_a_ne_zero

/- warning: cubic.nat_degree_of_a_ne_zero' -> Cubic.natDegree_of_a_ne_zero' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {a : R} {b : R} {c : R} {d : R} [_inst_1 : Semiring.{u1} R], (Ne.{succ u1} R a (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{1} Nat (Polynomial.natDegree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R a b c d))) (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))
but is expected to have type
  forall {R : Type.{u1}} {a : R} {b : R} {c : R} {d : R} [_inst_1 : Semiring.{u1} R], (Ne.{succ u1} R a (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{1} Nat (Polynomial.natDegree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R a b c d))) (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3)))
Case conversion may be inaccurate. Consider using '#align cubic.nat_degree_of_a_ne_zero' Cubic.natDegree_of_a_ne_zero'ₓ'. -/
@[simp]
theorem natDegree_of_a_ne_zero' (ha : a ≠ 0) : (toPoly ⟨a, b, c, d⟩).natDegree = 3 :=
  natDegree_of_a_ne_zero ha
#align cubic.nat_degree_of_a_ne_zero' Cubic.natDegree_of_a_ne_zero'

/- warning: cubic.nat_degree_of_a_eq_zero -> Cubic.natDegree_of_a_eq_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (LE.le.{0} Nat Nat.hasLe (Polynomial.natDegree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))
but is expected to have type
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (LE.le.{0} Nat instLENat (Polynomial.natDegree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))
Case conversion may be inaccurate. Consider using '#align cubic.nat_degree_of_a_eq_zero Cubic.natDegree_of_a_eq_zeroₓ'. -/
theorem natDegree_of_a_eq_zero (ha : P.a = 0) : P.toPoly.natDegree ≤ 2 := by
  simpa only [of_a_eq_zero ha] using nat_degree_quadratic_le
#align cubic.nat_degree_of_a_eq_zero Cubic.natDegree_of_a_eq_zero

/- warning: cubic.nat_degree_of_a_eq_zero' -> Cubic.natDegree_of_a_eq_zero' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {b : R} {c : R} {d : R} [_inst_1 : Semiring.{u1} R], LE.le.{0} Nat Nat.hasLe (Polynomial.natDegree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) b c d))) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))
but is expected to have type
  forall {R : Type.{u1}} {b : R} {c : R} {d : R} [_inst_1 : Semiring.{u1} R], LE.le.{0} Nat instLENat (Polynomial.natDegree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) b c d))) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))
Case conversion may be inaccurate. Consider using '#align cubic.nat_degree_of_a_eq_zero' Cubic.natDegree_of_a_eq_zero'ₓ'. -/
theorem natDegree_of_a_eq_zero' : (toPoly ⟨0, b, c, d⟩).natDegree ≤ 2 :=
  natDegree_of_a_eq_zero rfl
#align cubic.nat_degree_of_a_eq_zero' Cubic.natDegree_of_a_eq_zero'

/- warning: cubic.nat_degree_of_b_ne_zero -> Cubic.natDegree_of_b_ne_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Ne.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{1} Nat (Polynomial.natDegree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))
but is expected to have type
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Ne.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{1} Nat (Polynomial.natDegree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))
Case conversion may be inaccurate. Consider using '#align cubic.nat_degree_of_b_ne_zero Cubic.natDegree_of_b_ne_zeroₓ'. -/
@[simp]
theorem natDegree_of_b_ne_zero (ha : P.a = 0) (hb : P.b ≠ 0) : P.toPoly.natDegree = 2 := by
  rw [of_a_eq_zero ha, nat_degree_quadratic hb]
#align cubic.nat_degree_of_b_ne_zero Cubic.natDegree_of_b_ne_zero

/- warning: cubic.nat_degree_of_b_ne_zero' -> Cubic.natDegree_of_b_ne_zero' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {b : R} {c : R} {d : R} [_inst_1 : Semiring.{u1} R], (Ne.{succ u1} R b (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{1} Nat (Polynomial.natDegree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) b c d))) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))
but is expected to have type
  forall {R : Type.{u1}} {b : R} {c : R} {d : R} [_inst_1 : Semiring.{u1} R], (Ne.{succ u1} R b (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{1} Nat (Polynomial.natDegree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) b c d))) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))
Case conversion may be inaccurate. Consider using '#align cubic.nat_degree_of_b_ne_zero' Cubic.natDegree_of_b_ne_zero'ₓ'. -/
@[simp]
theorem natDegree_of_b_ne_zero' (hb : b ≠ 0) : (toPoly ⟨0, b, c, d⟩).natDegree = 2 :=
  natDegree_of_b_ne_zero rfl hb
#align cubic.nat_degree_of_b_ne_zero' Cubic.natDegree_of_b_ne_zero'

/- warning: cubic.nat_degree_of_b_eq_zero -> Cubic.natDegree_of_b_eq_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (LE.le.{0} Nat Nat.hasLe (Polynomial.natDegree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))
but is expected to have type
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (LE.le.{0} Nat instLENat (Polynomial.natDegree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))
Case conversion may be inaccurate. Consider using '#align cubic.nat_degree_of_b_eq_zero Cubic.natDegree_of_b_eq_zeroₓ'. -/
theorem natDegree_of_b_eq_zero (ha : P.a = 0) (hb : P.b = 0) : P.toPoly.natDegree ≤ 1 := by
  simpa only [of_b_eq_zero ha hb] using nat_degree_linear_le
#align cubic.nat_degree_of_b_eq_zero Cubic.natDegree_of_b_eq_zero

/- warning: cubic.nat_degree_of_b_eq_zero' -> Cubic.natDegree_of_b_eq_zero' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {c : R} {d : R} [_inst_1 : Semiring.{u1} R], LE.le.{0} Nat Nat.hasLe (Polynomial.natDegree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) c d))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))
but is expected to have type
  forall {R : Type.{u1}} {c : R} {d : R} [_inst_1 : Semiring.{u1} R], LE.le.{0} Nat instLENat (Polynomial.natDegree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) c d))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))
Case conversion may be inaccurate. Consider using '#align cubic.nat_degree_of_b_eq_zero' Cubic.natDegree_of_b_eq_zero'ₓ'. -/
theorem natDegree_of_b_eq_zero' : (toPoly ⟨0, 0, c, d⟩).natDegree ≤ 1 :=
  natDegree_of_b_eq_zero rfl rfl
#align cubic.nat_degree_of_b_eq_zero' Cubic.natDegree_of_b_eq_zero'

/- warning: cubic.nat_degree_of_c_ne_zero -> Cubic.natDegree_of_c_ne_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Ne.{succ u1} R (Cubic.c.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{1} Nat (Polynomial.natDegree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))
but is expected to have type
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Ne.{succ u1} R (Cubic.c.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{1} Nat (Polynomial.natDegree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))
Case conversion may be inaccurate. Consider using '#align cubic.nat_degree_of_c_ne_zero Cubic.natDegree_of_c_ne_zeroₓ'. -/
@[simp]
theorem natDegree_of_c_ne_zero (ha : P.a = 0) (hb : P.b = 0) (hc : P.c ≠ 0) :
    P.toPoly.natDegree = 1 := by rw [of_b_eq_zero ha hb, nat_degree_linear hc]
#align cubic.nat_degree_of_c_ne_zero Cubic.natDegree_of_c_ne_zero

/- warning: cubic.nat_degree_of_c_ne_zero' -> Cubic.natDegree_of_c_ne_zero' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {c : R} {d : R} [_inst_1 : Semiring.{u1} R], (Ne.{succ u1} R c (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{1} Nat (Polynomial.natDegree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) c d))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))
but is expected to have type
  forall {R : Type.{u1}} {c : R} {d : R} [_inst_1 : Semiring.{u1} R], (Ne.{succ u1} R c (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{1} Nat (Polynomial.natDegree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) c d))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))
Case conversion may be inaccurate. Consider using '#align cubic.nat_degree_of_c_ne_zero' Cubic.natDegree_of_c_ne_zero'ₓ'. -/
@[simp]
theorem natDegree_of_c_ne_zero' (hc : c ≠ 0) : (toPoly ⟨0, 0, c, d⟩).natDegree = 1 :=
  natDegree_of_c_ne_zero rfl rfl hc
#align cubic.nat_degree_of_c_ne_zero' Cubic.natDegree_of_c_ne_zero'

/- warning: cubic.nat_degree_of_c_eq_zero -> Cubic.natDegree_of_c_eq_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{succ u1} R (Cubic.c.{u1} R P) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{1} Nat (Polynomial.natDegree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))))
but is expected to have type
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : Semiring.{u1} R], (Eq.{succ u1} R (Cubic.a.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Cubic.b.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{succ u1} R (Cubic.c.{u1} R P) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{1} Nat (Polynomial.natDegree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 P)) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))
Case conversion may be inaccurate. Consider using '#align cubic.nat_degree_of_c_eq_zero Cubic.natDegree_of_c_eq_zeroₓ'. -/
@[simp]
theorem natDegree_of_c_eq_zero (ha : P.a = 0) (hb : P.b = 0) (hc : P.c = 0) :
    P.toPoly.natDegree = 0 := by rw [of_c_eq_zero ha hb hc, nat_degree_C]
#align cubic.nat_degree_of_c_eq_zero Cubic.natDegree_of_c_eq_zero

/- warning: cubic.nat_degree_of_c_eq_zero' -> Cubic.natDegree_of_c_eq_zero' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {d : R} [_inst_1 : Semiring.{u1} R], Eq.{1} Nat (Polynomial.natDegree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) d))) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))
but is expected to have type
  forall {R : Type.{u1}} {d : R} [_inst_1 : Semiring.{u1} R], Eq.{1} Nat (Polynomial.natDegree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (Cubic.mk.{u1} R (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) d))) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))
Case conversion may be inaccurate. Consider using '#align cubic.nat_degree_of_c_eq_zero' Cubic.natDegree_of_c_eq_zero'ₓ'. -/
@[simp]
theorem natDegree_of_c_eq_zero' : (toPoly ⟨0, 0, 0, d⟩).natDegree = 0 :=
  natDegree_of_c_eq_zero rfl rfl rfl
#align cubic.nat_degree_of_c_eq_zero' Cubic.natDegree_of_c_eq_zero'

/- warning: cubic.nat_degree_of_zero -> Cubic.natDegree_of_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R], Eq.{1} Nat (Polynomial.natDegree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (OfNat.ofNat.{u1} (Cubic.{u1} R) 0 (OfNat.mk.{u1} (Cubic.{u1} R) 0 (Zero.zero.{u1} (Cubic.{u1} R) (Cubic.hasZero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))))) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R], Eq.{1} Nat (Polynomial.natDegree.{u1} R _inst_1 (Cubic.toPoly.{u1} R _inst_1 (OfNat.ofNat.{u1} (Cubic.{u1} R) 0 (Zero.toOfNat0.{u1} (Cubic.{u1} R) (Cubic.instZeroCubic.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))))) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))
Case conversion may be inaccurate. Consider using '#align cubic.nat_degree_of_zero Cubic.natDegree_of_zeroₓ'. -/
@[simp]
theorem natDegree_of_zero : (0 : Cubic R).toPoly.natDegree = 0 :=
  natDegree_of_c_eq_zero'
#align cubic.nat_degree_of_zero Cubic.natDegree_of_zero

end Degree

/-! ### Map across a homomorphism -/


section Map

variable [Semiring S] {φ : R →+* S}

#print Cubic.map /-
/-- Map a cubic polynomial across a semiring homomorphism. -/
def map (φ : R →+* S) (P : Cubic R) : Cubic S :=
  ⟨φ P.a, φ P.b, φ P.c, φ P.d⟩
#align cubic.map Cubic.map
-/

#print Cubic.map_toPoly /-
theorem map_toPoly : (map φ P).toPoly = Polynomial.map φ P.toPoly := by
  simp only [map, to_poly, map_C, map_X, Polynomial.map_add, Polynomial.map_mul, Polynomial.map_pow]
#align cubic.map_to_poly Cubic.map_toPoly
-/

end Map

end Basic

section Roots

open Multiset

/-! ### Roots over an extension -/


section Extension

variable {P : Cubic R} [CommRing R] [CommRing S] {φ : R →+* S}

#print Cubic.roots /-
/-- The roots of a cubic polynomial. -/
def roots [IsDomain R] (P : Cubic R) : Multiset R :=
  P.toPoly.roots
#align cubic.roots Cubic.roots
-/

#print Cubic.map_roots /-
theorem map_roots [IsDomain S] : (map φ P).roots = (Polynomial.map φ P.toPoly).roots := by
  rw [roots, map_to_poly]
#align cubic.map_roots Cubic.map_roots
-/

/- warning: cubic.mem_roots_iff -> Cubic.mem_roots_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : CommRing.{u1} R] [_inst_3 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))], (Ne.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Cubic.toPoly.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) P) (OfNat.ofNat.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (OfNat.mk.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (Zero.zero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.zero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) -> (forall (x : R), Iff (Membership.Mem.{u1, u1} R (Multiset.{u1} R) (Multiset.hasMem.{u1} R) x (Cubic.roots.{u1} R _inst_1 _inst_3 P)) (Eq.{succ u1} R (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (Cubic.a.{u1} R P) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)))) x (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (Cubic.b.{u1} R P) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)))) x (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (Cubic.c.{u1} R P) x)) (Cubic.d.{u1} R P)) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))))))
but is expected to have type
  forall {R : Type.{u1}} {P : Cubic.{u1} R} [_inst_1 : CommRing.{u1} R] [_inst_3 : IsDomain.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))], (Ne.{succ u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Cubic.toPoly.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) P) (OfNat.ofNat.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.zero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) -> (forall (x : R), Iff (Membership.mem.{u1, u1} R (Multiset.{u1} R) (Multiset.instMembershipMultiset.{u1} R) x (Cubic.roots.{u1} R _inst_1 _inst_3 P)) (Eq.{succ u1} R (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Cubic.a.{u1} R P) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) x (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3)))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Cubic.b.{u1} R P) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) x (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Cubic.c.{u1} R P) x)) (Cubic.d.{u1} R P)) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (CommMonoidWithZero.toZero.{u1} R (CancelCommMonoidWithZero.toCommMonoidWithZero.{u1} R (IsDomain.toCancelCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) _inst_3)))))))
Case conversion may be inaccurate. Consider using '#align cubic.mem_roots_iff Cubic.mem_roots_iffₓ'. -/
theorem mem_roots_iff [IsDomain R] (h0 : P.toPoly ≠ 0) (x : R) :
    x ∈ P.roots ↔ P.a * x ^ 3 + P.b * x ^ 2 + P.c * x + P.d = 0 :=
  by
  rw [roots, mem_roots h0, is_root, to_poly]
  simp only [eval_C, eval_X, eval_add, eval_mul, eval_pow]
#align cubic.mem_roots_iff Cubic.mem_roots_iff

#print Cubic.card_roots_le /-
theorem card_roots_le [IsDomain R] [DecidableEq R] : P.roots.toFinset.card ≤ 3 :=
  by
  apply (to_finset_card_le P.to_poly.roots).trans
  by_cases hP : P.to_poly = 0
  ·
    exact
      (card_roots' P.to_poly).trans
        (by
          rw [hP, nat_degree_zero]
          exact zero_le 3)
  · exact WithBot.coe_le_coe.1 ((card_roots hP).trans degree_cubic_le)
#align cubic.card_roots_le Cubic.card_roots_le
-/

end Extension

variable {P : Cubic F} [Field F] [Field K] {φ : F →+* K} {x y z : K}

/-! ### Roots over a splitting field -/


section Split

/- warning: cubic.splits_iff_card_roots -> Cubic.splits_iff_card_roots is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {K : Type.{u2}} {P : Cubic.{u1} F} [_inst_1 : Field.{u1} F] [_inst_2 : Field.{u2} K] {φ : RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))}, (Ne.{succ u1} F (Cubic.a.{u1} F P) (OfNat.ofNat.{u1} F 0 (OfNat.mk.{u1} F 0 (Zero.zero.{u1} F (MulZeroClass.toHasZero.{u1} F (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} F (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} F (NonAssocRing.toNonUnitalNonAssocRing.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))))))))))) -> (Iff (Polynomial.Splits.{u1, u2} F K (EuclideanDomain.toCommRing.{u1} F (Field.toEuclideanDomain.{u1} F _inst_1)) _inst_2 φ (Cubic.toPoly.{u1} F (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F (EuclideanDomain.toCommRing.{u1} F (Field.toEuclideanDomain.{u1} F _inst_1)))) P)) (Eq.{1} Nat (coeFn.{succ u2, succ u2} (AddMonoidHom.{u2, 0} (Multiset.{u2} K) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} K) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} K) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} K) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} K) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} K) (Multiset.orderedCancelAddCommMonoid.{u2} K)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (fun (_x : AddMonoidHom.{u2, 0} (Multiset.{u2} K) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} K) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} K) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} K) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} K) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} K) (Multiset.orderedCancelAddCommMonoid.{u2} K)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) => (Multiset.{u2} K) -> Nat) (AddMonoidHom.hasCoeToFun.{u2, 0} (Multiset.{u2} K) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} K) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} K) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} K) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} K) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} K) (Multiset.orderedCancelAddCommMonoid.{u2} K)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.card.{u2} K) (Cubic.roots.{u2} K (EuclideanDomain.toCommRing.{u2} K (Field.toEuclideanDomain.{u2} K _inst_2)) (Field.isDomain.{u2} K _inst_2) (Cubic.map.{u1, u2} F K (Ring.toSemiring.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))) φ P))) (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))
but is expected to have type
  forall {F : Type.{u2}} {K : Type.{u1}} {P : Cubic.{u2} F} [_inst_1 : Field.{u2} F] [_inst_2 : Field.{u1} K] {φ : RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))}, (Ne.{succ u2} F (Cubic.a.{u2} F P) (OfNat.ofNat.{u2} F 0 (Zero.toOfNat0.{u2} F (CommMonoidWithZero.toZero.{u2} F (CommGroupWithZero.toCommMonoidWithZero.{u2} F (Semifield.toCommGroupWithZero.{u2} F (Field.toSemifield.{u2} F _inst_1))))))) -> (Iff (Polynomial.Splits.{u2, u1} F K (EuclideanDomain.toCommRing.{u2} F (Field.toEuclideanDomain.{u2} F _inst_1)) _inst_2 φ (Cubic.toPoly.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) P)) (Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u1} K) => Nat) (Cubic.roots.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_2)) (EuclideanDomain.instIsDomainToSemiringToCommSemiringToCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_2)) (Cubic.map.{u2, u1} F K (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))) φ P))) (FunLike.coe.{succ u1, succ u1, 1} (AddMonoidHom.{u1, 0} (Multiset.{u1} K) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} K) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} K) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} K) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} K) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} K) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} K)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} K) (fun (_x : Multiset.{u1} K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u1} K) => Nat) _x) (AddHomClass.toFunLike.{u1, u1, 0} (AddMonoidHom.{u1, 0} (Multiset.{u1} K) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} K) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} K) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} K) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} K) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} K) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} K)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} K) Nat (AddZeroClass.toAdd.{u1} (Multiset.{u1} K) (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} K) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} K) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} K) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} K) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} K) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} K))))))) (AddZeroClass.toAdd.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoidHomClass.toAddHomClass.{u1, u1, 0} (AddMonoidHom.{u1, 0} (Multiset.{u1} K) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} K) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} K) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} K) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} K) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} K) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} K)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} K) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} K) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} K) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} K) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} K) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} K) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} K)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoidHom.addMonoidHomClass.{u1, 0} (Multiset.{u1} K) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} K) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} K) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} K) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} K) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} K) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} K)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)))) (Multiset.card.{u1} K) (Cubic.roots.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_2)) (EuclideanDomain.instIsDomainToSemiringToCommSemiringToCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_2)) (Cubic.map.{u2, u1} F K (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))) φ P))) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u1} K) => Nat) (Cubic.roots.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_2)) (EuclideanDomain.instIsDomainToSemiringToCommSemiringToCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_2)) (Cubic.map.{u2, u1} F K (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))) φ P))) 3 (instOfNatNat 3))))
Case conversion may be inaccurate. Consider using '#align cubic.splits_iff_card_roots Cubic.splits_iff_card_rootsₓ'. -/
theorem splits_iff_card_roots (ha : P.a ≠ 0) : Splits φ P.toPoly ↔ (map φ P).roots.card = 3 :=
  by
  replace ha : (map φ P).a ≠ 0 := (_root_.map_ne_zero φ).mpr ha
  nth_rw_lhs 1 [← RingHom.id_comp φ]
  rw [roots, ← splits_map_iff, ← map_to_poly, splits_iff_card_roots, ←
    ((degree_eq_iff_nat_degree_eq <| ne_zero_of_a_ne_zero ha).mp <| degree_of_a_ne_zero ha : _ = 3)]
#align cubic.splits_iff_card_roots Cubic.splits_iff_card_roots

/- warning: cubic.splits_iff_roots_eq_three -> Cubic.splits_iff_roots_eq_three is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {K : Type.{u2}} {P : Cubic.{u1} F} [_inst_1 : Field.{u1} F] [_inst_2 : Field.{u2} K] {φ : RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))}, (Ne.{succ u1} F (Cubic.a.{u1} F P) (OfNat.ofNat.{u1} F 0 (OfNat.mk.{u1} F 0 (Zero.zero.{u1} F (MulZeroClass.toHasZero.{u1} F (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} F (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} F (NonAssocRing.toNonUnitalNonAssocRing.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))))))))))) -> (Iff (Polynomial.Splits.{u1, u2} F K (EuclideanDomain.toCommRing.{u1} F (Field.toEuclideanDomain.{u1} F _inst_1)) _inst_2 φ (Cubic.toPoly.{u1} F (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F (EuclideanDomain.toCommRing.{u1} F (Field.toEuclideanDomain.{u1} F _inst_1)))) P)) (Exists.{succ u2} K (fun (x : K) => Exists.{succ u2} K (fun (y : K) => Exists.{succ u2} K (fun (z : K) => Eq.{succ u2} (Multiset.{u2} K) (Cubic.roots.{u2} K (EuclideanDomain.toCommRing.{u2} K (Field.toEuclideanDomain.{u2} K _inst_2)) (Field.isDomain.{u2} K _inst_2) (Cubic.map.{u1, u2} F K (Ring.toSemiring.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))) φ P)) (Insert.insert.{u2, u2} K (Multiset.{u2} K) (Multiset.hasInsert.{u2} K) x (Insert.insert.{u2, u2} K (Multiset.{u2} K) (Multiset.hasInsert.{u2} K) y (Singleton.singleton.{u2, u2} K (Multiset.{u2} K) (Multiset.hasSingleton.{u2} K) z))))))))
but is expected to have type
  forall {F : Type.{u2}} {K : Type.{u1}} {P : Cubic.{u2} F} [_inst_1 : Field.{u2} F] [_inst_2 : Field.{u1} K] {φ : RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))}, (Ne.{succ u2} F (Cubic.a.{u2} F P) (OfNat.ofNat.{u2} F 0 (Zero.toOfNat0.{u2} F (CommMonoidWithZero.toZero.{u2} F (CommGroupWithZero.toCommMonoidWithZero.{u2} F (Semifield.toCommGroupWithZero.{u2} F (Field.toSemifield.{u2} F _inst_1))))))) -> (Iff (Polynomial.Splits.{u2, u1} F K (EuclideanDomain.toCommRing.{u2} F (Field.toEuclideanDomain.{u2} F _inst_1)) _inst_2 φ (Cubic.toPoly.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) P)) (Exists.{succ u1} K (fun (x : K) => Exists.{succ u1} K (fun (y : K) => Exists.{succ u1} K (fun (z : K) => Eq.{succ u1} (Multiset.{u1} K) (Cubic.roots.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_2)) (EuclideanDomain.instIsDomainToSemiringToCommSemiringToCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_2)) (Cubic.map.{u2, u1} F K (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))) φ P)) (Insert.insert.{u1, u1} K (Multiset.{u1} K) (Multiset.instInsertMultiset.{u1} K) x (Insert.insert.{u1, u1} K (Multiset.{u1} K) (Multiset.instInsertMultiset.{u1} K) y (Singleton.singleton.{u1, u1} K (Multiset.{u1} K) (Multiset.instSingletonMultiset.{u1} K) z))))))))
Case conversion may be inaccurate. Consider using '#align cubic.splits_iff_roots_eq_three Cubic.splits_iff_roots_eq_threeₓ'. -/
theorem splits_iff_roots_eq_three (ha : P.a ≠ 0) :
    Splits φ P.toPoly ↔ ∃ x y z : K, (map φ P).roots = {x, y, z} := by
  rw [splits_iff_card_roots ha, card_eq_three]
#align cubic.splits_iff_roots_eq_three Cubic.splits_iff_roots_eq_three

/- warning: cubic.eq_prod_three_roots -> Cubic.eq_prod_three_roots is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {K : Type.{u2}} {P : Cubic.{u1} F} [_inst_1 : Field.{u1} F] [_inst_2 : Field.{u2} K] {φ : RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))} {x : K} {y : K} {z : K}, (Ne.{succ u1} F (Cubic.a.{u1} F P) (OfNat.ofNat.{u1} F 0 (OfNat.mk.{u1} F 0 (Zero.zero.{u1} F (MulZeroClass.toHasZero.{u1} F (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} F (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} F (NonAssocRing.toNonUnitalNonAssocRing.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))))))))))) -> (Eq.{succ u2} (Multiset.{u2} K) (Cubic.roots.{u2} K (EuclideanDomain.toCommRing.{u2} K (Field.toEuclideanDomain.{u2} K _inst_2)) (Field.isDomain.{u2} K _inst_2) (Cubic.map.{u1, u2} F K (Ring.toSemiring.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))) φ P)) (Insert.insert.{u2, u2} K (Multiset.{u2} K) (Multiset.hasInsert.{u2} K) x (Insert.insert.{u2, u2} K (Multiset.{u2} K) (Multiset.hasInsert.{u2} K) y (Singleton.singleton.{u2, u2} K (Multiset.{u2} K) (Multiset.hasSingleton.{u2} K) z)))) -> (Eq.{succ u2} (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Cubic.toPoly.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))) (Cubic.map.{u1, u2} F K (Ring.toSemiring.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))) φ P)) (HMul.hMul.{u2, u2, u2} (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (instHMul.{u2} (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Polynomial.mul'.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (HMul.hMul.{u2, u2, u2} (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (instHMul.{u2} (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Polynomial.mul'.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (HMul.hMul.{u2, u2, u2} (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (instHMul.{u2} (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Polynomial.mul'.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (coeFn.{succ u2, succ u2} (RingHom.{u2, u2} K (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Semiring.toNonAssocSemiring.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Polynomial.semiring.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))))) (fun (_x : RingHom.{u2, u2} K (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Semiring.toNonAssocSemiring.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Polynomial.semiring.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))))) => K -> (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (RingHom.hasCoeToFun.{u2, u2} K (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Semiring.toNonAssocSemiring.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Polynomial.semiring.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))))) (Polynomial.C.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (fun (_x : RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) => F -> K) (RingHom.hasCoeToFun.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) φ (Cubic.a.{u1} F P))) (HSub.hSub.{u2, u2, u2} (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (instHSub.{u2} (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Polynomial.sub.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Polynomial.X.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (coeFn.{succ u2, succ u2} (RingHom.{u2, u2} K (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Semiring.toNonAssocSemiring.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Polynomial.semiring.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))))) (fun (_x : RingHom.{u2, u2} K (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Semiring.toNonAssocSemiring.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Polynomial.semiring.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))))) => K -> (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (RingHom.hasCoeToFun.{u2, u2} K (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Semiring.toNonAssocSemiring.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Polynomial.semiring.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))))) (Polynomial.C.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) x))) (HSub.hSub.{u2, u2, u2} (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (instHSub.{u2} (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Polynomial.sub.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Polynomial.X.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (coeFn.{succ u2, succ u2} (RingHom.{u2, u2} K (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Semiring.toNonAssocSemiring.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Polynomial.semiring.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))))) (fun (_x : RingHom.{u2, u2} K (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Semiring.toNonAssocSemiring.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Polynomial.semiring.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))))) => K -> (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (RingHom.hasCoeToFun.{u2, u2} K (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Semiring.toNonAssocSemiring.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Polynomial.semiring.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))))) (Polynomial.C.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) y))) (HSub.hSub.{u2, u2, u2} (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (instHSub.{u2} (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Polynomial.sub.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Polynomial.X.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (coeFn.{succ u2, succ u2} (RingHom.{u2, u2} K (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Semiring.toNonAssocSemiring.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Polynomial.semiring.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))))) (fun (_x : RingHom.{u2, u2} K (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Semiring.toNonAssocSemiring.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Polynomial.semiring.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))))) => K -> (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (RingHom.hasCoeToFun.{u2, u2} K (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Semiring.toNonAssocSemiring.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) (Polynomial.semiring.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))))) (Polynomial.C.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) z))))
but is expected to have type
  forall {F : Type.{u2}} {K : Type.{u1}} {P : Cubic.{u2} F} [_inst_1 : Field.{u2} F] [_inst_2 : Field.{u1} K] {φ : RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))} {x : K} {y : K} {z : K}, (Ne.{succ u2} F (Cubic.a.{u2} F P) (OfNat.ofNat.{u2} F 0 (Zero.toOfNat0.{u2} F (CommMonoidWithZero.toZero.{u2} F (CommGroupWithZero.toCommMonoidWithZero.{u2} F (Semifield.toCommGroupWithZero.{u2} F (Field.toSemifield.{u2} F _inst_1))))))) -> (Eq.{succ u1} (Multiset.{u1} K) (Cubic.roots.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_2)) (EuclideanDomain.instIsDomainToSemiringToCommSemiringToCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_2)) (Cubic.map.{u2, u1} F K (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))) φ P)) (Insert.insert.{u1, u1} K (Multiset.{u1} K) (Multiset.instInsertMultiset.{u1} K) x (Insert.insert.{u1, u1} K (Multiset.{u1} K) (Multiset.instInsertMultiset.{u1} K) y (Singleton.singleton.{u1, u1} K (Multiset.{u1} K) (Multiset.instSingletonMultiset.{u1} K) z)))) -> (Eq.{succ u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Cubic.toPoly.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))) (Cubic.map.{u2, u1} F K (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))) φ P)) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) => Polynomial.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F (fun (a : F) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonUnitalNonAssocSemiring.toMul.{u2} F (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (RingHom.instRingHomClassRingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))))) φ (Cubic.a.{u2} F P))) (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) => Polynomial.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F (fun (a : F) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonUnitalNonAssocSemiring.toMul.{u2} F (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (RingHom.instRingHomClassRingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))))) φ (Cubic.a.{u2} F P))) (Polynomial.mul'.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2))))) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) => Polynomial.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F (fun (a : F) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonUnitalNonAssocSemiring.toMul.{u2} F (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (RingHom.instRingHomClassRingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))))) φ (Cubic.a.{u2} F P))) (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) => Polynomial.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F (fun (a : F) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonUnitalNonAssocSemiring.toMul.{u2} F (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (RingHom.instRingHomClassRingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))))) φ (Cubic.a.{u2} F P))) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) => Polynomial.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F (fun (a : F) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonUnitalNonAssocSemiring.toMul.{u2} F (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (RingHom.instRingHomClassRingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))))) φ (Cubic.a.{u2} F P))) (Polynomial.mul'.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2))))) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) => Polynomial.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F (fun (a : F) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonUnitalNonAssocSemiring.toMul.{u2} F (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (RingHom.instRingHomClassRingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))))) φ (Cubic.a.{u2} F P))) (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) => Polynomial.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F (fun (a : F) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonUnitalNonAssocSemiring.toMul.{u2} F (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (RingHom.instRingHomClassRingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))))) φ (Cubic.a.{u2} F P))) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) => Polynomial.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F (fun (a : F) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonUnitalNonAssocSemiring.toMul.{u2} F (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (RingHom.instRingHomClassRingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))))) φ (Cubic.a.{u2} F P))) (Polynomial.mul'.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2))))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Polynomial.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) (Semiring.toNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) (Polynomial.semiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (fun (_x : (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) => Polynomial.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Polynomial.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) (Semiring.toNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) (Polynomial.semiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Polynomial.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) (NonUnitalNonAssocSemiring.toMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semiring.toNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) (Polynomial.semiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2))))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Polynomial.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) (Semiring.toNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) (Polynomial.semiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Polynomial.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semiring.toNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) (Polynomial.semiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Polynomial.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) (Semiring.toNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) (Polynomial.semiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Polynomial.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) (Semiring.toNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) (Polynomial.semiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2))))) (RingHom.instRingHomClassRingHom.{u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Polynomial.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) (Semiring.toNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) (Polynomial.semiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2))))))))) (Polynomial.C.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F (fun (_x : F) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonUnitalNonAssocSemiring.toMul.{u2} F (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (RingHom.instRingHomClassRingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))))) φ (Cubic.a.{u2} F P))) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) x) (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (instHSub.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Polynomial.sub.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_2)))) (Polynomial.X.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} K (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Polynomial.semiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} K (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Polynomial.semiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) K (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Polynomial.semiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} K (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Polynomial.semiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) K (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Polynomial.semiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} K (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Polynomial.semiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) K (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Polynomial.semiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) (RingHom.instRingHomClassRingHom.{u1, u1} K (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Polynomial.semiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))))))) (Polynomial.C.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) x))) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) y) (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (instHSub.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Polynomial.sub.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_2)))) (Polynomial.X.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} K (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Polynomial.semiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} K (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Polynomial.semiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) K (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Polynomial.semiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} K (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Polynomial.semiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) K (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Polynomial.semiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} K (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Polynomial.semiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) K (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Polynomial.semiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) (RingHom.instRingHomClassRingHom.{u1, u1} K (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Polynomial.semiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))))))) (Polynomial.C.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) y))) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) z) (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (instHSub.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Polynomial.sub.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_2)))) (Polynomial.X.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} K (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Polynomial.semiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} K (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Polynomial.semiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) K (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Polynomial.semiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} K (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Polynomial.semiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) K (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Polynomial.semiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} K (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Polynomial.semiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) K (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Polynomial.semiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) (RingHom.instRingHomClassRingHom.{u1, u1} K (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (Polynomial.semiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))))))) (Polynomial.C.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) z))))
Case conversion may be inaccurate. Consider using '#align cubic.eq_prod_three_roots Cubic.eq_prod_three_rootsₓ'. -/
theorem eq_prod_three_roots (ha : P.a ≠ 0) (h3 : (map φ P).roots = {x, y, z}) :
    (map φ P).toPoly = C (φ P.a) * (X - C x) * (X - C y) * (X - C z) :=
  by
  rw [map_to_poly,
    eq_prod_roots_of_splits <|
      (splits_iff_roots_eq_three ha).mpr <| Exists.intro x <| Exists.intro y <| Exists.intro z h3,
    leading_coeff_of_a_ne_zero ha, ← map_roots, h3]
  change C (φ P.a) * ((X - C x) ::ₘ (X - C y) ::ₘ {X - C z}).Prod = _
  rw [prod_cons, prod_cons, prod_singleton, mul_assoc, mul_assoc]
#align cubic.eq_prod_three_roots Cubic.eq_prod_three_roots

/- warning: cubic.eq_sum_three_roots -> Cubic.eq_sum_three_roots is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {K : Type.{u2}} {P : Cubic.{u1} F} [_inst_1 : Field.{u1} F] [_inst_2 : Field.{u2} K] {φ : RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))} {x : K} {y : K} {z : K}, (Ne.{succ u1} F (Cubic.a.{u1} F P) (OfNat.ofNat.{u1} F 0 (OfNat.mk.{u1} F 0 (Zero.zero.{u1} F (MulZeroClass.toHasZero.{u1} F (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} F (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} F (NonAssocRing.toNonUnitalNonAssocRing.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))))))))))) -> (Eq.{succ u2} (Multiset.{u2} K) (Cubic.roots.{u2} K (EuclideanDomain.toCommRing.{u2} K (Field.toEuclideanDomain.{u2} K _inst_2)) (Field.isDomain.{u2} K _inst_2) (Cubic.map.{u1, u2} F K (Ring.toSemiring.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))) φ P)) (Insert.insert.{u2, u2} K (Multiset.{u2} K) (Multiset.hasInsert.{u2} K) x (Insert.insert.{u2, u2} K (Multiset.{u2} K) (Multiset.hasInsert.{u2} K) y (Singleton.singleton.{u2, u2} K (Multiset.{u2} K) (Multiset.hasSingleton.{u2} K) z)))) -> (Eq.{succ u2} (Cubic.{u2} K) (Cubic.map.{u1, u2} F K (Ring.toSemiring.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))) φ P) (Cubic.mk.{u2} K (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (fun (_x : RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) => F -> K) (RingHom.hasCoeToFun.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) φ (Cubic.a.{u1} F P)) (HMul.hMul.{u2, u2, u2} K K K (instHMul.{u2} K (Distrib.toHasMul.{u2} K (Ring.toDistrib.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (fun (_x : RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) => F -> K) (RingHom.hasCoeToFun.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) φ (Cubic.a.{u1} F P)) (Neg.neg.{u2} K (SubNegMonoid.toHasNeg.{u2} K (AddGroup.toSubNegMonoid.{u2} K (AddGroupWithOne.toAddGroup.{u2} K (AddCommGroupWithOne.toAddGroupWithOne.{u2} K (Ring.toAddCommGroupWithOne.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))))) (HAdd.hAdd.{u2, u2, u2} K K K (instHAdd.{u2} K (Distrib.toHasAdd.{u2} K (Ring.toDistrib.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (HAdd.hAdd.{u2, u2, u2} K K K (instHAdd.{u2} K (Distrib.toHasAdd.{u2} K (Ring.toDistrib.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) x y) z))) (HMul.hMul.{u2, u2, u2} K K K (instHMul.{u2} K (Distrib.toHasMul.{u2} K (Ring.toDistrib.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (fun (_x : RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) => F -> K) (RingHom.hasCoeToFun.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) φ (Cubic.a.{u1} F P)) (HAdd.hAdd.{u2, u2, u2} K K K (instHAdd.{u2} K (Distrib.toHasAdd.{u2} K (Ring.toDistrib.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (HAdd.hAdd.{u2, u2, u2} K K K (instHAdd.{u2} K (Distrib.toHasAdd.{u2} K (Ring.toDistrib.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (HMul.hMul.{u2, u2, u2} K K K (instHMul.{u2} K (Distrib.toHasMul.{u2} K (Ring.toDistrib.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) x y) (HMul.hMul.{u2, u2, u2} K K K (instHMul.{u2} K (Distrib.toHasMul.{u2} K (Ring.toDistrib.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) x z)) (HMul.hMul.{u2, u2, u2} K K K (instHMul.{u2} K (Distrib.toHasMul.{u2} K (Ring.toDistrib.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) y z))) (HMul.hMul.{u2, u2, u2} K K K (instHMul.{u2} K (Distrib.toHasMul.{u2} K (Ring.toDistrib.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (fun (_x : RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) => F -> K) (RingHom.hasCoeToFun.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) φ (Cubic.a.{u1} F P)) (Neg.neg.{u2} K (SubNegMonoid.toHasNeg.{u2} K (AddGroup.toSubNegMonoid.{u2} K (AddGroupWithOne.toAddGroup.{u2} K (AddCommGroupWithOne.toAddGroupWithOne.{u2} K (Ring.toAddCommGroupWithOne.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))))) (HMul.hMul.{u2, u2, u2} K K K (instHMul.{u2} K (Distrib.toHasMul.{u2} K (Ring.toDistrib.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (HMul.hMul.{u2, u2, u2} K K K (instHMul.{u2} K (Distrib.toHasMul.{u2} K (Ring.toDistrib.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) x y) z)))))
but is expected to have type
  forall {F : Type.{u2}} {K : Type.{u1}} {P : Cubic.{u2} F} [_inst_1 : Field.{u2} F] [_inst_2 : Field.{u1} K] {φ : RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))} {x : K} {y : K} {z : K}, (Ne.{succ u2} F (Cubic.a.{u2} F P) (OfNat.ofNat.{u2} F 0 (Zero.toOfNat0.{u2} F (CommMonoidWithZero.toZero.{u2} F (CommGroupWithZero.toCommMonoidWithZero.{u2} F (Semifield.toCommGroupWithZero.{u2} F (Field.toSemifield.{u2} F _inst_1))))))) -> (Eq.{succ u1} (Multiset.{u1} K) (Cubic.roots.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_2)) (EuclideanDomain.instIsDomainToSemiringToCommSemiringToCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_2)) (Cubic.map.{u2, u1} F K (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))) φ P)) (Insert.insert.{u1, u1} K (Multiset.{u1} K) (Multiset.instInsertMultiset.{u1} K) x (Insert.insert.{u1, u1} K (Multiset.{u1} K) (Multiset.instInsertMultiset.{u1} K) y (Singleton.singleton.{u1, u1} K (Multiset.{u1} K) (Multiset.instSingletonMultiset.{u1} K) z)))) -> (Eq.{succ u1} (Cubic.{u1} K) (Cubic.map.{u2, u1} F K (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))) φ P) (Cubic.mk.{u1} K (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F (fun (_x : F) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonUnitalNonAssocSemiring.toMul.{u2} F (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (RingHom.instRingHomClassRingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))))) φ (Cubic.a.{u2} F P)) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) K ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (NonUnitalNonAssocRing.toMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (NonAssocRing.toNonUnitalNonAssocRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Ring.toNonAssocRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionRing.toRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toDivisionRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F (fun (_x : F) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonUnitalNonAssocSemiring.toMul.{u2} F (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (RingHom.instRingHomClassRingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))))) φ (Cubic.a.{u2} F P)) (Neg.neg.{u1} K (Ring.toNeg.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_2))) (HAdd.hAdd.{u1, u1, u1} K K K (instHAdd.{u1} K (Distrib.toAdd.{u1} K (NonUnitalNonAssocSemiring.toDistrib.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_2)))))))) (HAdd.hAdd.{u1, u1, u1} K K K (instHAdd.{u1} K (Distrib.toAdd.{u1} K (NonUnitalNonAssocSemiring.toDistrib.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_2)))))))) x y) z))) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) K ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (NonUnitalNonAssocRing.toMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (NonAssocRing.toNonUnitalNonAssocRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Ring.toNonAssocRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionRing.toRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toDivisionRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F (fun (_x : F) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonUnitalNonAssocSemiring.toMul.{u2} F (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (RingHom.instRingHomClassRingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))))) φ (Cubic.a.{u2} F P)) (HAdd.hAdd.{u1, u1, u1} K K K (instHAdd.{u1} K (Distrib.toAdd.{u1} K (NonUnitalNonAssocSemiring.toDistrib.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_2)))))))) (HAdd.hAdd.{u1, u1, u1} K K K (instHAdd.{u1} K (Distrib.toAdd.{u1} K (NonUnitalNonAssocSemiring.toDistrib.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_2)))))))) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_2)))))) x y) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_2)))))) x z)) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_2)))))) y z))) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) K ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (NonUnitalNonAssocRing.toMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (NonAssocRing.toNonUnitalNonAssocRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Ring.toNonAssocRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionRing.toRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toDivisionRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F (fun (_x : F) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonUnitalNonAssocSemiring.toMul.{u2} F (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (RingHom.instRingHomClassRingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))))) φ (Cubic.a.{u2} F P)) (Neg.neg.{u1} K (Ring.toNeg.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_2))) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_2)))))) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_2)))))) x y) z)))))
Case conversion may be inaccurate. Consider using '#align cubic.eq_sum_three_roots Cubic.eq_sum_three_rootsₓ'. -/
theorem eq_sum_three_roots (ha : P.a ≠ 0) (h3 : (map φ P).roots = {x, y, z}) :
    map φ P =
      ⟨φ P.a, φ P.a * -(x + y + z), φ P.a * (x * y + x * z + y * z), φ P.a * -(x * y * z)⟩ :=
  by
  apply_fun to_poly
  any_goals exact fun P Q => (to_poly_injective P Q).mp
  rw [eq_prod_three_roots ha h3, C_mul_prod_X_sub_C_eq]
#align cubic.eq_sum_three_roots Cubic.eq_sum_three_roots

/- warning: cubic.b_eq_three_roots -> Cubic.b_eq_three_roots is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {K : Type.{u2}} {P : Cubic.{u1} F} [_inst_1 : Field.{u1} F] [_inst_2 : Field.{u2} K] {φ : RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))} {x : K} {y : K} {z : K}, (Ne.{succ u1} F (Cubic.a.{u1} F P) (OfNat.ofNat.{u1} F 0 (OfNat.mk.{u1} F 0 (Zero.zero.{u1} F (MulZeroClass.toHasZero.{u1} F (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} F (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} F (NonAssocRing.toNonUnitalNonAssocRing.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))))))))))) -> (Eq.{succ u2} (Multiset.{u2} K) (Cubic.roots.{u2} K (EuclideanDomain.toCommRing.{u2} K (Field.toEuclideanDomain.{u2} K _inst_2)) (Field.isDomain.{u2} K _inst_2) (Cubic.map.{u1, u2} F K (Ring.toSemiring.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))) φ P)) (Insert.insert.{u2, u2} K (Multiset.{u2} K) (Multiset.hasInsert.{u2} K) x (Insert.insert.{u2, u2} K (Multiset.{u2} K) (Multiset.hasInsert.{u2} K) y (Singleton.singleton.{u2, u2} K (Multiset.{u2} K) (Multiset.hasSingleton.{u2} K) z)))) -> (Eq.{succ u2} K (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (fun (_x : RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) => F -> K) (RingHom.hasCoeToFun.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) φ (Cubic.b.{u1} F P)) (HMul.hMul.{u2, u2, u2} K K K (instHMul.{u2} K (Distrib.toHasMul.{u2} K (Ring.toDistrib.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (fun (_x : RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) => F -> K) (RingHom.hasCoeToFun.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) φ (Cubic.a.{u1} F P)) (Neg.neg.{u2} K (SubNegMonoid.toHasNeg.{u2} K (AddGroup.toSubNegMonoid.{u2} K (AddGroupWithOne.toAddGroup.{u2} K (AddCommGroupWithOne.toAddGroupWithOne.{u2} K (Ring.toAddCommGroupWithOne.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))))) (HAdd.hAdd.{u2, u2, u2} K K K (instHAdd.{u2} K (Distrib.toHasAdd.{u2} K (Ring.toDistrib.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (HAdd.hAdd.{u2, u2, u2} K K K (instHAdd.{u2} K (Distrib.toHasAdd.{u2} K (Ring.toDistrib.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) x y) z))))
but is expected to have type
  forall {F : Type.{u2}} {K : Type.{u1}} {P : Cubic.{u2} F} [_inst_1 : Field.{u2} F] [_inst_2 : Field.{u1} K] {φ : RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))} {x : K} {y : K} {z : K}, (Ne.{succ u2} F (Cubic.a.{u2} F P) (OfNat.ofNat.{u2} F 0 (Zero.toOfNat0.{u2} F (CommMonoidWithZero.toZero.{u2} F (CommGroupWithZero.toCommMonoidWithZero.{u2} F (Semifield.toCommGroupWithZero.{u2} F (Field.toSemifield.{u2} F _inst_1))))))) -> (Eq.{succ u1} (Multiset.{u1} K) (Cubic.roots.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_2)) (EuclideanDomain.instIsDomainToSemiringToCommSemiringToCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_2)) (Cubic.map.{u2, u1} F K (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))) φ P)) (Insert.insert.{u1, u1} K (Multiset.{u1} K) (Multiset.instInsertMultiset.{u1} K) x (Insert.insert.{u1, u1} K (Multiset.{u1} K) (Multiset.instInsertMultiset.{u1} K) y (Singleton.singleton.{u1, u1} K (Multiset.{u1} K) (Multiset.instSingletonMultiset.{u1} K) z)))) -> (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.b.{u2} F P)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F (fun (_x : F) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonUnitalNonAssocSemiring.toMul.{u2} F (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (RingHom.instRingHomClassRingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))))) φ (Cubic.b.{u2} F P)) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) K ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (NonUnitalNonAssocRing.toMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (NonAssocRing.toNonUnitalNonAssocRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Ring.toNonAssocRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionRing.toRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toDivisionRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F (fun (_x : F) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonUnitalNonAssocSemiring.toMul.{u2} F (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (RingHom.instRingHomClassRingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))))) φ (Cubic.a.{u2} F P)) (Neg.neg.{u1} K (Ring.toNeg.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_2))) (HAdd.hAdd.{u1, u1, u1} K K K (instHAdd.{u1} K (Distrib.toAdd.{u1} K (NonUnitalNonAssocSemiring.toDistrib.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_2)))))))) (HAdd.hAdd.{u1, u1, u1} K K K (instHAdd.{u1} K (Distrib.toAdd.{u1} K (NonUnitalNonAssocSemiring.toDistrib.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_2)))))))) x y) z))))
Case conversion may be inaccurate. Consider using '#align cubic.b_eq_three_roots Cubic.b_eq_three_rootsₓ'. -/
theorem b_eq_three_roots (ha : P.a ≠ 0) (h3 : (map φ P).roots = {x, y, z}) :
    φ P.b = φ P.a * -(x + y + z) := by injection eq_sum_three_roots ha h3
#align cubic.b_eq_three_roots Cubic.b_eq_three_roots

/- warning: cubic.c_eq_three_roots -> Cubic.c_eq_three_roots is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {K : Type.{u2}} {P : Cubic.{u1} F} [_inst_1 : Field.{u1} F] [_inst_2 : Field.{u2} K] {φ : RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))} {x : K} {y : K} {z : K}, (Ne.{succ u1} F (Cubic.a.{u1} F P) (OfNat.ofNat.{u1} F 0 (OfNat.mk.{u1} F 0 (Zero.zero.{u1} F (MulZeroClass.toHasZero.{u1} F (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} F (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} F (NonAssocRing.toNonUnitalNonAssocRing.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))))))))))) -> (Eq.{succ u2} (Multiset.{u2} K) (Cubic.roots.{u2} K (EuclideanDomain.toCommRing.{u2} K (Field.toEuclideanDomain.{u2} K _inst_2)) (Field.isDomain.{u2} K _inst_2) (Cubic.map.{u1, u2} F K (Ring.toSemiring.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))) φ P)) (Insert.insert.{u2, u2} K (Multiset.{u2} K) (Multiset.hasInsert.{u2} K) x (Insert.insert.{u2, u2} K (Multiset.{u2} K) (Multiset.hasInsert.{u2} K) y (Singleton.singleton.{u2, u2} K (Multiset.{u2} K) (Multiset.hasSingleton.{u2} K) z)))) -> (Eq.{succ u2} K (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (fun (_x : RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) => F -> K) (RingHom.hasCoeToFun.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) φ (Cubic.c.{u1} F P)) (HMul.hMul.{u2, u2, u2} K K K (instHMul.{u2} K (Distrib.toHasMul.{u2} K (Ring.toDistrib.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (fun (_x : RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) => F -> K) (RingHom.hasCoeToFun.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) φ (Cubic.a.{u1} F P)) (HAdd.hAdd.{u2, u2, u2} K K K (instHAdd.{u2} K (Distrib.toHasAdd.{u2} K (Ring.toDistrib.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (HAdd.hAdd.{u2, u2, u2} K K K (instHAdd.{u2} K (Distrib.toHasAdd.{u2} K (Ring.toDistrib.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (HMul.hMul.{u2, u2, u2} K K K (instHMul.{u2} K (Distrib.toHasMul.{u2} K (Ring.toDistrib.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) x y) (HMul.hMul.{u2, u2, u2} K K K (instHMul.{u2} K (Distrib.toHasMul.{u2} K (Ring.toDistrib.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) x z)) (HMul.hMul.{u2, u2, u2} K K K (instHMul.{u2} K (Distrib.toHasMul.{u2} K (Ring.toDistrib.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) y z))))
but is expected to have type
  forall {F : Type.{u2}} {K : Type.{u1}} {P : Cubic.{u2} F} [_inst_1 : Field.{u2} F] [_inst_2 : Field.{u1} K] {φ : RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))} {x : K} {y : K} {z : K}, (Ne.{succ u2} F (Cubic.a.{u2} F P) (OfNat.ofNat.{u2} F 0 (Zero.toOfNat0.{u2} F (CommMonoidWithZero.toZero.{u2} F (CommGroupWithZero.toCommMonoidWithZero.{u2} F (Semifield.toCommGroupWithZero.{u2} F (Field.toSemifield.{u2} F _inst_1))))))) -> (Eq.{succ u1} (Multiset.{u1} K) (Cubic.roots.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_2)) (EuclideanDomain.instIsDomainToSemiringToCommSemiringToCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_2)) (Cubic.map.{u2, u1} F K (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))) φ P)) (Insert.insert.{u1, u1} K (Multiset.{u1} K) (Multiset.instInsertMultiset.{u1} K) x (Insert.insert.{u1, u1} K (Multiset.{u1} K) (Multiset.instInsertMultiset.{u1} K) y (Singleton.singleton.{u1, u1} K (Multiset.{u1} K) (Multiset.instSingletonMultiset.{u1} K) z)))) -> (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.c.{u2} F P)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F (fun (_x : F) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonUnitalNonAssocSemiring.toMul.{u2} F (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (RingHom.instRingHomClassRingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))))) φ (Cubic.c.{u2} F P)) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) K ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (NonUnitalNonAssocRing.toMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (NonAssocRing.toNonUnitalNonAssocRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Ring.toNonAssocRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionRing.toRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toDivisionRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F (fun (_x : F) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonUnitalNonAssocSemiring.toMul.{u2} F (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (RingHom.instRingHomClassRingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))))) φ (Cubic.a.{u2} F P)) (HAdd.hAdd.{u1, u1, u1} K K K (instHAdd.{u1} K (Distrib.toAdd.{u1} K (NonUnitalNonAssocSemiring.toDistrib.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_2)))))))) (HAdd.hAdd.{u1, u1, u1} K K K (instHAdd.{u1} K (Distrib.toAdd.{u1} K (NonUnitalNonAssocSemiring.toDistrib.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_2)))))))) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_2)))))) x y) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_2)))))) x z)) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_2)))))) y z))))
Case conversion may be inaccurate. Consider using '#align cubic.c_eq_three_roots Cubic.c_eq_three_rootsₓ'. -/
theorem c_eq_three_roots (ha : P.a ≠ 0) (h3 : (map φ P).roots = {x, y, z}) :
    φ P.c = φ P.a * (x * y + x * z + y * z) := by injection eq_sum_three_roots ha h3
#align cubic.c_eq_three_roots Cubic.c_eq_three_roots

/- warning: cubic.d_eq_three_roots -> Cubic.d_eq_three_roots is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {K : Type.{u2}} {P : Cubic.{u1} F} [_inst_1 : Field.{u1} F] [_inst_2 : Field.{u2} K] {φ : RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))} {x : K} {y : K} {z : K}, (Ne.{succ u1} F (Cubic.a.{u1} F P) (OfNat.ofNat.{u1} F 0 (OfNat.mk.{u1} F 0 (Zero.zero.{u1} F (MulZeroClass.toHasZero.{u1} F (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} F (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} F (NonAssocRing.toNonUnitalNonAssocRing.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))))))))))) -> (Eq.{succ u2} (Multiset.{u2} K) (Cubic.roots.{u2} K (EuclideanDomain.toCommRing.{u2} K (Field.toEuclideanDomain.{u2} K _inst_2)) (Field.isDomain.{u2} K _inst_2) (Cubic.map.{u1, u2} F K (Ring.toSemiring.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))) φ P)) (Insert.insert.{u2, u2} K (Multiset.{u2} K) (Multiset.hasInsert.{u2} K) x (Insert.insert.{u2, u2} K (Multiset.{u2} K) (Multiset.hasInsert.{u2} K) y (Singleton.singleton.{u2, u2} K (Multiset.{u2} K) (Multiset.hasSingleton.{u2} K) z)))) -> (Eq.{succ u2} K (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (fun (_x : RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) => F -> K) (RingHom.hasCoeToFun.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) φ (Cubic.d.{u1} F P)) (HMul.hMul.{u2, u2, u2} K K K (instHMul.{u2} K (Distrib.toHasMul.{u2} K (Ring.toDistrib.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (fun (_x : RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) => F -> K) (RingHom.hasCoeToFun.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) φ (Cubic.a.{u1} F P)) (Neg.neg.{u2} K (SubNegMonoid.toHasNeg.{u2} K (AddGroup.toSubNegMonoid.{u2} K (AddGroupWithOne.toAddGroup.{u2} K (AddCommGroupWithOne.toAddGroupWithOne.{u2} K (Ring.toAddCommGroupWithOne.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))))) (HMul.hMul.{u2, u2, u2} K K K (instHMul.{u2} K (Distrib.toHasMul.{u2} K (Ring.toDistrib.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (HMul.hMul.{u2, u2, u2} K K K (instHMul.{u2} K (Distrib.toHasMul.{u2} K (Ring.toDistrib.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) x y) z))))
but is expected to have type
  forall {F : Type.{u2}} {K : Type.{u1}} {P : Cubic.{u2} F} [_inst_1 : Field.{u2} F] [_inst_2 : Field.{u1} K] {φ : RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))} {x : K} {y : K} {z : K}, (Ne.{succ u2} F (Cubic.a.{u2} F P) (OfNat.ofNat.{u2} F 0 (Zero.toOfNat0.{u2} F (CommMonoidWithZero.toZero.{u2} F (CommGroupWithZero.toCommMonoidWithZero.{u2} F (Semifield.toCommGroupWithZero.{u2} F (Field.toSemifield.{u2} F _inst_1))))))) -> (Eq.{succ u1} (Multiset.{u1} K) (Cubic.roots.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_2)) (EuclideanDomain.instIsDomainToSemiringToCommSemiringToCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_2)) (Cubic.map.{u2, u1} F K (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))) φ P)) (Insert.insert.{u1, u1} K (Multiset.{u1} K) (Multiset.instInsertMultiset.{u1} K) x (Insert.insert.{u1, u1} K (Multiset.{u1} K) (Multiset.instInsertMultiset.{u1} K) y (Singleton.singleton.{u1, u1} K (Multiset.{u1} K) (Multiset.instSingletonMultiset.{u1} K) z)))) -> (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.d.{u2} F P)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F (fun (_x : F) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonUnitalNonAssocSemiring.toMul.{u2} F (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (RingHom.instRingHomClassRingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))))) φ (Cubic.d.{u2} F P)) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) K ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (NonUnitalNonAssocRing.toMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (NonAssocRing.toNonUnitalNonAssocRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Ring.toNonAssocRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionRing.toRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toDivisionRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F (fun (_x : F) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonUnitalNonAssocSemiring.toMul.{u2} F (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (RingHom.instRingHomClassRingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))))) φ (Cubic.a.{u2} F P)) (Neg.neg.{u1} K (Ring.toNeg.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_2))) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_2)))))) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_2)))))) x y) z))))
Case conversion may be inaccurate. Consider using '#align cubic.d_eq_three_roots Cubic.d_eq_three_rootsₓ'. -/
theorem d_eq_three_roots (ha : P.a ≠ 0) (h3 : (map φ P).roots = {x, y, z}) :
    φ P.d = φ P.a * -(x * y * z) := by injection eq_sum_three_roots ha h3
#align cubic.d_eq_three_roots Cubic.d_eq_three_roots

end Split

/-! ### Discriminant over a splitting field -/


section Discriminant

#print Cubic.disc /-
/-- The discriminant of a cubic polynomial. -/
def disc {R : Type _} [Ring R] (P : Cubic R) : R :=
  P.b ^ 2 * P.c ^ 2 - 4 * P.a * P.c ^ 3 - 4 * P.b ^ 3 * P.d - 27 * P.a ^ 2 * P.d ^ 2 +
    18 * P.a * P.b * P.c * P.d
#align cubic.disc Cubic.disc
-/

/- warning: cubic.disc_eq_prod_three_roots -> Cubic.disc_eq_prod_three_roots is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {K : Type.{u2}} {P : Cubic.{u1} F} [_inst_1 : Field.{u1} F] [_inst_2 : Field.{u2} K] {φ : RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))} {x : K} {y : K} {z : K}, (Ne.{succ u1} F (Cubic.a.{u1} F P) (OfNat.ofNat.{u1} F 0 (OfNat.mk.{u1} F 0 (Zero.zero.{u1} F (MulZeroClass.toHasZero.{u1} F (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} F (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} F (NonAssocRing.toNonUnitalNonAssocRing.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))))))))))) -> (Eq.{succ u2} (Multiset.{u2} K) (Cubic.roots.{u2} K (EuclideanDomain.toCommRing.{u2} K (Field.toEuclideanDomain.{u2} K _inst_2)) (Field.isDomain.{u2} K _inst_2) (Cubic.map.{u1, u2} F K (Ring.toSemiring.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))) φ P)) (Insert.insert.{u2, u2} K (Multiset.{u2} K) (Multiset.hasInsert.{u2} K) x (Insert.insert.{u2, u2} K (Multiset.{u2} K) (Multiset.hasInsert.{u2} K) y (Singleton.singleton.{u2, u2} K (Multiset.{u2} K) (Multiset.hasSingleton.{u2} K) z)))) -> (Eq.{succ u2} K (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (fun (_x : RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) => F -> K) (RingHom.hasCoeToFun.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) φ (Cubic.disc.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)) P)) (HPow.hPow.{u2, 0, u2} K Nat K (instHPow.{u2, 0} K Nat (Monoid.Pow.{u2} K (Ring.toMonoid.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (HMul.hMul.{u2, u2, u2} K K K (instHMul.{u2} K (Distrib.toHasMul.{u2} K (Ring.toDistrib.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (HMul.hMul.{u2, u2, u2} K K K (instHMul.{u2} K (Distrib.toHasMul.{u2} K (Ring.toDistrib.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (HMul.hMul.{u2, u2, u2} K K K (instHMul.{u2} K (Distrib.toHasMul.{u2} K (Ring.toDistrib.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (HMul.hMul.{u2, u2, u2} K K K (instHMul.{u2} K (Distrib.toHasMul.{u2} K (Ring.toDistrib.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (fun (_x : RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) => F -> K) (RingHom.hasCoeToFun.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) φ (Cubic.a.{u1} F P)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (fun (_x : RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) => F -> K) (RingHom.hasCoeToFun.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) φ (Cubic.a.{u1} F P))) (HSub.hSub.{u2, u2, u2} K K K (instHSub.{u2} K (SubNegMonoid.toHasSub.{u2} K (AddGroup.toSubNegMonoid.{u2} K (AddGroupWithOne.toAddGroup.{u2} K (AddCommGroupWithOne.toAddGroupWithOne.{u2} K (Ring.toAddCommGroupWithOne.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))))))) x y)) (HSub.hSub.{u2, u2, u2} K K K (instHSub.{u2} K (SubNegMonoid.toHasSub.{u2} K (AddGroup.toSubNegMonoid.{u2} K (AddGroupWithOne.toAddGroup.{u2} K (AddCommGroupWithOne.toAddGroupWithOne.{u2} K (Ring.toAddCommGroupWithOne.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))))))) x z)) (HSub.hSub.{u2, u2, u2} K K K (instHSub.{u2} K (SubNegMonoid.toHasSub.{u2} K (AddGroup.toSubNegMonoid.{u2} K (AddGroupWithOne.toAddGroup.{u2} K (AddCommGroupWithOne.toAddGroupWithOne.{u2} K (Ring.toAddCommGroupWithOne.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))))))) y z)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))
but is expected to have type
  forall {F : Type.{u2}} {K : Type.{u1}} {P : Cubic.{u2} F} [_inst_1 : Field.{u2} F] [_inst_2 : Field.{u1} K] {φ : RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))} {x : K} {y : K} {z : K}, (Ne.{succ u2} F (Cubic.a.{u2} F P) (OfNat.ofNat.{u2} F 0 (Zero.toOfNat0.{u2} F (CommMonoidWithZero.toZero.{u2} F (CommGroupWithZero.toCommMonoidWithZero.{u2} F (Semifield.toCommGroupWithZero.{u2} F (Field.toSemifield.{u2} F _inst_1))))))) -> (Eq.{succ u1} (Multiset.{u1} K) (Cubic.roots.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_2)) (EuclideanDomain.instIsDomainToSemiringToCommSemiringToCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_2)) (Cubic.map.{u2, u1} F K (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))) φ P)) (Insert.insert.{u1, u1} K (Multiset.{u1} K) (Multiset.instInsertMultiset.{u1} K) x (Insert.insert.{u1, u1} K (Multiset.{u1} K) (Multiset.instInsertMultiset.{u1} K) y (Singleton.singleton.{u1, u1} K (Multiset.{u1} K) (Multiset.instSingletonMultiset.{u1} K) z)))) -> (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.disc.{u2} F (DivisionRing.toRing.{u2} F (Field.toDivisionRing.{u2} F _inst_1)) P)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F (fun (_x : F) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonUnitalNonAssocSemiring.toMul.{u2} F (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (RingHom.instRingHomClassRingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))))) φ (Cubic.disc.{u2} F (DivisionRing.toRing.{u2} F (Field.toDivisionRing.{u2} F _inst_1)) P)) (HPow.hPow.{u1, 0, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) Nat ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.disc.{u2} F (DivisionRing.toRing.{u2} F (Field.toDivisionRing.{u2} F _inst_1)) P)) (instHPow.{u1, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) Nat (Monoid.Pow.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (MonoidWithZero.toMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semiring.toMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2))))))) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) K ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (NonUnitalNonAssocRing.toMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (NonAssocRing.toNonUnitalNonAssocRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Ring.toNonAssocRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionRing.toRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toDivisionRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))))) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) K ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (NonUnitalNonAssocRing.toMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (NonAssocRing.toNonUnitalNonAssocRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Ring.toNonAssocRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionRing.toRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toDivisionRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))))) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) K ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (NonUnitalNonAssocRing.toMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (NonAssocRing.toNonUnitalNonAssocRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Ring.toNonAssocRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionRing.toRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toDivisionRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))))) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (NonUnitalNonAssocRing.toMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (NonAssocRing.toNonUnitalNonAssocRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Ring.toNonAssocRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (DivisionRing.toRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) (Field.toDivisionRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) (Cubic.a.{u2} F P)) _inst_2)))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F (fun (_x : F) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonUnitalNonAssocSemiring.toMul.{u2} F (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (RingHom.instRingHomClassRingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))))) φ (Cubic.a.{u2} F P)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F (fun (_x : F) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : F) => K) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonUnitalNonAssocSemiring.toMul.{u2} F (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} F (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))) F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))) (RingHom.instRingHomClassRingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2)))))))) φ (Cubic.a.{u2} F P))) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_2)))) x y)) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_2)))) x z)) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_2)))) y z)) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))
Case conversion may be inaccurate. Consider using '#align cubic.disc_eq_prod_three_roots Cubic.disc_eq_prod_three_rootsₓ'. -/
theorem disc_eq_prod_three_roots (ha : P.a ≠ 0) (h3 : (map φ P).roots = {x, y, z}) :
    φ P.disc = (φ P.a * φ P.a * (x - y) * (x - z) * (y - z)) ^ 2 :=
  by
  simp only [disc, RingHom.map_add, RingHom.map_sub, RingHom.map_mul, map_pow]
  simp only [RingHom.map_one, map_bit0, map_bit1]
  rw [b_eq_three_roots ha h3, c_eq_three_roots ha h3, d_eq_three_roots ha h3]
  ring1
#align cubic.disc_eq_prod_three_roots Cubic.disc_eq_prod_three_roots

/- warning: cubic.disc_ne_zero_iff_roots_ne -> Cubic.disc_ne_zero_iff_roots_ne is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {K : Type.{u2}} {P : Cubic.{u1} F} [_inst_1 : Field.{u1} F] [_inst_2 : Field.{u2} K] {φ : RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))} {x : K} {y : K} {z : K}, (Ne.{succ u1} F (Cubic.a.{u1} F P) (OfNat.ofNat.{u1} F 0 (OfNat.mk.{u1} F 0 (Zero.zero.{u1} F (MulZeroClass.toHasZero.{u1} F (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} F (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} F (NonAssocRing.toNonUnitalNonAssocRing.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))))))))))) -> (Eq.{succ u2} (Multiset.{u2} K) (Cubic.roots.{u2} K (EuclideanDomain.toCommRing.{u2} K (Field.toEuclideanDomain.{u2} K _inst_2)) (Field.isDomain.{u2} K _inst_2) (Cubic.map.{u1, u2} F K (Ring.toSemiring.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))) φ P)) (Insert.insert.{u2, u2} K (Multiset.{u2} K) (Multiset.hasInsert.{u2} K) x (Insert.insert.{u2, u2} K (Multiset.{u2} K) (Multiset.hasInsert.{u2} K) y (Singleton.singleton.{u2, u2} K (Multiset.{u2} K) (Multiset.hasSingleton.{u2} K) z)))) -> (Iff (Ne.{succ u1} F (Cubic.disc.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)) P) (OfNat.ofNat.{u1} F 0 (OfNat.mk.{u1} F 0 (Zero.zero.{u1} F (MulZeroClass.toHasZero.{u1} F (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} F (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} F (NonAssocRing.toNonUnitalNonAssocRing.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))))))))))) (And (Ne.{succ u2} K x y) (And (Ne.{succ u2} K x z) (Ne.{succ u2} K y z))))
but is expected to have type
  forall {F : Type.{u2}} {K : Type.{u1}} {P : Cubic.{u2} F} [_inst_1 : Field.{u2} F] [_inst_2 : Field.{u1} K] {φ : RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))} {x : K} {y : K} {z : K}, (Ne.{succ u2} F (Cubic.a.{u2} F P) (OfNat.ofNat.{u2} F 0 (Zero.toOfNat0.{u2} F (CommMonoidWithZero.toZero.{u2} F (CommGroupWithZero.toCommMonoidWithZero.{u2} F (Semifield.toCommGroupWithZero.{u2} F (Field.toSemifield.{u2} F _inst_1))))))) -> (Eq.{succ u1} (Multiset.{u1} K) (Cubic.roots.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_2)) (EuclideanDomain.instIsDomainToSemiringToCommSemiringToCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_2)) (Cubic.map.{u2, u1} F K (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))) φ P)) (Insert.insert.{u1, u1} K (Multiset.{u1} K) (Multiset.instInsertMultiset.{u1} K) x (Insert.insert.{u1, u1} K (Multiset.{u1} K) (Multiset.instInsertMultiset.{u1} K) y (Singleton.singleton.{u1, u1} K (Multiset.{u1} K) (Multiset.instSingletonMultiset.{u1} K) z)))) -> (Iff (Ne.{succ u2} F (Cubic.disc.{u2} F (DivisionRing.toRing.{u2} F (Field.toDivisionRing.{u2} F _inst_1)) P) (OfNat.ofNat.{u2} F 0 (Zero.toOfNat0.{u2} F (CommMonoidWithZero.toZero.{u2} F (CommGroupWithZero.toCommMonoidWithZero.{u2} F (Semifield.toCommGroupWithZero.{u2} F (Field.toSemifield.{u2} F _inst_1))))))) (And (Ne.{succ u1} K x y) (And (Ne.{succ u1} K x z) (Ne.{succ u1} K y z))))
Case conversion may be inaccurate. Consider using '#align cubic.disc_ne_zero_iff_roots_ne Cubic.disc_ne_zero_iff_roots_neₓ'. -/
theorem disc_ne_zero_iff_roots_ne (ha : P.a ≠ 0) (h3 : (map φ P).roots = {x, y, z}) :
    P.disc ≠ 0 ↔ x ≠ y ∧ x ≠ z ∧ y ≠ z :=
  by
  rw [← _root_.map_ne_zero φ, disc_eq_prod_three_roots ha h3, pow_two]
  simp_rw [mul_ne_zero_iff, sub_ne_zero, _root_.map_ne_zero, and_self_iff, and_iff_right ha,
    and_assoc']
#align cubic.disc_ne_zero_iff_roots_ne Cubic.disc_ne_zero_iff_roots_ne

/- warning: cubic.disc_ne_zero_iff_roots_nodup -> Cubic.disc_ne_zero_iff_roots_nodup is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {K : Type.{u2}} {P : Cubic.{u1} F} [_inst_1 : Field.{u1} F] [_inst_2 : Field.{u2} K] {φ : RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))} {x : K} {y : K} {z : K}, (Ne.{succ u1} F (Cubic.a.{u1} F P) (OfNat.ofNat.{u1} F 0 (OfNat.mk.{u1} F 0 (Zero.zero.{u1} F (MulZeroClass.toHasZero.{u1} F (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} F (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} F (NonAssocRing.toNonUnitalNonAssocRing.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))))))))))) -> (Eq.{succ u2} (Multiset.{u2} K) (Cubic.roots.{u2} K (EuclideanDomain.toCommRing.{u2} K (Field.toEuclideanDomain.{u2} K _inst_2)) (Field.isDomain.{u2} K _inst_2) (Cubic.map.{u1, u2} F K (Ring.toSemiring.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))) φ P)) (Insert.insert.{u2, u2} K (Multiset.{u2} K) (Multiset.hasInsert.{u2} K) x (Insert.insert.{u2, u2} K (Multiset.{u2} K) (Multiset.hasInsert.{u2} K) y (Singleton.singleton.{u2, u2} K (Multiset.{u2} K) (Multiset.hasSingleton.{u2} K) z)))) -> (Iff (Ne.{succ u1} F (Cubic.disc.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)) P) (OfNat.ofNat.{u1} F 0 (OfNat.mk.{u1} F 0 (Zero.zero.{u1} F (MulZeroClass.toHasZero.{u1} F (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} F (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} F (NonAssocRing.toNonUnitalNonAssocRing.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))))))))))) (Multiset.Nodup.{u2} K (Cubic.roots.{u2} K (EuclideanDomain.toCommRing.{u2} K (Field.toEuclideanDomain.{u2} K _inst_2)) (Field.isDomain.{u2} K _inst_2) (Cubic.map.{u1, u2} F K (Ring.toSemiring.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))) φ P))))
but is expected to have type
  forall {F : Type.{u2}} {K : Type.{u1}} {P : Cubic.{u2} F} [_inst_1 : Field.{u2} F] [_inst_2 : Field.{u1} K] {φ : RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))))} {x : K} {y : K} {z : K}, (Ne.{succ u2} F (Cubic.a.{u2} F P) (OfNat.ofNat.{u2} F 0 (Zero.toOfNat0.{u2} F (CommMonoidWithZero.toZero.{u2} F (CommGroupWithZero.toCommMonoidWithZero.{u2} F (Semifield.toCommGroupWithZero.{u2} F (Field.toSemifield.{u2} F _inst_1))))))) -> (Eq.{succ u1} (Multiset.{u1} K) (Cubic.roots.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_2)) (EuclideanDomain.instIsDomainToSemiringToCommSemiringToCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_2)) (Cubic.map.{u2, u1} F K (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))) φ P)) (Insert.insert.{u1, u1} K (Multiset.{u1} K) (Multiset.instInsertMultiset.{u1} K) x (Insert.insert.{u1, u1} K (Multiset.{u1} K) (Multiset.instInsertMultiset.{u1} K) y (Singleton.singleton.{u1, u1} K (Multiset.{u1} K) (Multiset.instSingletonMultiset.{u1} K) z)))) -> (Iff (Ne.{succ u2} F (Cubic.disc.{u2} F (DivisionRing.toRing.{u2} F (Field.toDivisionRing.{u2} F _inst_1)) P) (OfNat.ofNat.{u2} F 0 (Zero.toOfNat0.{u2} F (CommMonoidWithZero.toZero.{u2} F (CommGroupWithZero.toCommMonoidWithZero.{u2} F (Semifield.toCommGroupWithZero.{u2} F (Field.toSemifield.{u2} F _inst_1))))))) (Multiset.Nodup.{u1} K (Cubic.roots.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_2)) (EuclideanDomain.instIsDomainToSemiringToCommSemiringToCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_2)) (Cubic.map.{u2, u1} F K (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_2))) φ P))))
Case conversion may be inaccurate. Consider using '#align cubic.disc_ne_zero_iff_roots_nodup Cubic.disc_ne_zero_iff_roots_nodupₓ'. -/
theorem disc_ne_zero_iff_roots_nodup (ha : P.a ≠ 0) (h3 : (map φ P).roots = {x, y, z}) :
    P.disc ≠ 0 ↔ (map φ P).roots.Nodup :=
  by
  rw [disc_ne_zero_iff_roots_ne ha h3, h3]
  change _ ↔ (x ::ₘ y ::ₘ {z}).Nodup
  rw [nodup_cons, nodup_cons, mem_cons, mem_singleton, mem_singleton]
  simp only [nodup_singleton]
  tauto
#align cubic.disc_ne_zero_iff_roots_nodup Cubic.disc_ne_zero_iff_roots_nodup

/- warning: cubic.card_roots_of_disc_ne_zero -> Cubic.card_roots_of_disc_ne_zero is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {K : Type.{u2}} {P : Cubic.{u1} F} [_inst_1 : Field.{u1} F] [_inst_2 : Field.{u2} K] {φ : RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))} {x : K} {y : K} {z : K} [_inst_3 : DecidableEq.{succ u2} K], (Ne.{succ u1} F (Cubic.a.{u1} F P) (OfNat.ofNat.{u1} F 0 (OfNat.mk.{u1} F 0 (Zero.zero.{u1} F (MulZeroClass.toHasZero.{u1} F (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} F (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} F (NonAssocRing.toNonUnitalNonAssocRing.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))))))))))) -> (Eq.{succ u2} (Multiset.{u2} K) (Cubic.roots.{u2} K (EuclideanDomain.toCommRing.{u2} K (Field.toEuclideanDomain.{u2} K _inst_2)) (Field.isDomain.{u2} K _inst_2) (Cubic.map.{u1, u2} F K (Ring.toSemiring.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))) φ P)) (Insert.insert.{u2, u2} K (Multiset.{u2} K) (Multiset.hasInsert.{u2} K) x (Insert.insert.{u2, u2} K (Multiset.{u2} K) (Multiset.hasInsert.{u2} K) y (Singleton.singleton.{u2, u2} K (Multiset.{u2} K) (Multiset.hasSingleton.{u2} K) z)))) -> (Ne.{succ u1} F (Cubic.disc.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)) P) (OfNat.ofNat.{u1} F 0 (OfNat.mk.{u1} F 0 (Zero.zero.{u1} F (MulZeroClass.toHasZero.{u1} F (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} F (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} F (NonAssocRing.toNonUnitalNonAssocRing.{u1} F (Ring.toNonAssocRing.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))))))))))) -> (Eq.{1} Nat (Finset.card.{u2} K (Multiset.toFinset.{u2} K (fun (a : K) (b : K) => _inst_3 a b) (Cubic.roots.{u2} K (EuclideanDomain.toCommRing.{u2} K (Field.toEuclideanDomain.{u2} K _inst_2)) (Field.isDomain.{u2} K _inst_2) (Cubic.map.{u1, u2} F K (Ring.toSemiring.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))) φ P)))) (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))
but is expected to have type
  forall {F : Type.{u1}} {K : Type.{u2}} {P : Cubic.{u1} F} [_inst_1 : Field.{u1} F] [_inst_2 : Field.{u2} K] {φ : RingHom.{u1, u2} F K (Semiring.toNonAssocSemiring.{u1} F (DivisionSemiring.toSemiring.{u1} F (Semifield.toDivisionSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)))) (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_2))))} {x : K} {y : K} {z : K} [_inst_3 : DecidableEq.{succ u2} K], (Ne.{succ u1} F (Cubic.a.{u1} F P) (OfNat.ofNat.{u1} F 0 (Zero.toOfNat0.{u1} F (CommMonoidWithZero.toZero.{u1} F (CommGroupWithZero.toCommMonoidWithZero.{u1} F (Semifield.toCommGroupWithZero.{u1} F (Field.toSemifield.{u1} F _inst_1))))))) -> (Eq.{succ u2} (Multiset.{u2} K) (Cubic.roots.{u2} K (EuclideanDomain.toCommRing.{u2} K (Field.toEuclideanDomain.{u2} K _inst_2)) (EuclideanDomain.instIsDomainToSemiringToCommSemiringToCommRing.{u2} K (Field.toEuclideanDomain.{u2} K _inst_2)) (Cubic.map.{u1, u2} F K (DivisionSemiring.toSemiring.{u1} F (Semifield.toDivisionSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_2))) φ P)) (Insert.insert.{u2, u2} K (Multiset.{u2} K) (Multiset.instInsertMultiset.{u2} K) x (Insert.insert.{u2, u2} K (Multiset.{u2} K) (Multiset.instInsertMultiset.{u2} K) y (Singleton.singleton.{u2, u2} K (Multiset.{u2} K) (Multiset.instSingletonMultiset.{u2} K) z)))) -> (Ne.{succ u1} F (Cubic.disc.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)) P) (OfNat.ofNat.{u1} F 0 (Zero.toOfNat0.{u1} F (CommMonoidWithZero.toZero.{u1} F (CommGroupWithZero.toCommMonoidWithZero.{u1} F (Semifield.toCommGroupWithZero.{u1} F (Field.toSemifield.{u1} F _inst_1))))))) -> (Eq.{1} Nat (Finset.card.{u2} K (Multiset.toFinset.{u2} K (fun (a : K) (b : K) => _inst_3 a b) (Cubic.roots.{u2} K (EuclideanDomain.toCommRing.{u2} K (Field.toEuclideanDomain.{u2} K _inst_2)) (EuclideanDomain.instIsDomainToSemiringToCommSemiringToCommRing.{u2} K (Field.toEuclideanDomain.{u2} K _inst_2)) (Cubic.map.{u1, u2} F K (DivisionSemiring.toSemiring.{u1} F (Semifield.toDivisionSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_2))) φ P)))) (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3)))
Case conversion may be inaccurate. Consider using '#align cubic.card_roots_of_disc_ne_zero Cubic.card_roots_of_disc_ne_zeroₓ'. -/
theorem card_roots_of_disc_ne_zero [DecidableEq K] (ha : P.a ≠ 0) (h3 : (map φ P).roots = {x, y, z})
    (hd : P.disc ≠ 0) : (map φ P).roots.toFinset.card = 3 :=
  by
  rw [to_finset_card_of_nodup <| (disc_ne_zero_iff_roots_nodup ha h3).mp hd, ←
    splits_iff_card_roots ha, splits_iff_roots_eq_three ha]
  exact ⟨x, ⟨y, ⟨z, h3⟩⟩⟩
#align cubic.card_roots_of_disc_ne_zero Cubic.card_roots_of_disc_ne_zero

end Discriminant

end Roots

end Cubic

