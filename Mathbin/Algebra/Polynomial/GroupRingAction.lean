/-
Copyright (c) 2020 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau

! This file was ported from Lean 3 source module algebra.polynomial.group_ring_action
! leanprover-community/mathlib commit afad8e438d03f9d89da2914aa06cb4964ba87a18
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.GroupRingAction.Basic
import Mathbin.Algebra.Hom.GroupAction
import Mathbin.Data.Polynomial.AlgebraMap
import Mathbin.Data.Polynomial.Monic
import Mathbin.GroupTheory.GroupAction.Quotient

/-!
# Group action on rings applied to polynomials

This file contains instances and definitions relating `mul_semiring_action` to `polynomial`.
-/


variable (M : Type _) [Monoid M]

open Polynomial

namespace Polynomial

variable (R : Type _) [Semiring R]

variable {M}

/- warning: polynomial.smul_eq_map -> Polynomial.smul_eq_map is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] (R : Type.{u2}) [_inst_2 : Semiring.{u2} R] [_inst_3 : MulSemiringAction.{u1, u2} M R _inst_1 _inst_2] (m : M), Eq.{succ u2} ((Polynomial.{u2} R _inst_2) -> (Polynomial.{u2} R _inst_2)) (SMul.smul.{u1, u2} M (Polynomial.{u2} R _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} M (Polynomial.{u2} R _inst_2) (Polynomial.zero.{u2} R _inst_2) (Polynomial.smulZeroClass.{u2, u1} R _inst_2 M (DistribSMul.toSmulZeroClass.{u1, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))))) (DistribMulAction.toDistribSMul.{u1, u2} M R _inst_1 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (MulSemiringAction.toDistribMulAction.{u1, u2} M R _inst_1 _inst_2 _inst_3))))) m) (Polynomial.map.{u2, u2} R R _inst_2 _inst_2 (MulSemiringAction.toRingHom.{u2, u1} M _inst_1 R _inst_2 _inst_3 m))
but is expected to have type
  forall {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] (R : Type.{u1}) [_inst_2 : Semiring.{u1} R] [_inst_3 : MulSemiringAction.{u2, u1} M R _inst_1 _inst_2] (m : M), Eq.{succ u1} ((Polynomial.{u1} R _inst_2) -> (Polynomial.{u1} R _inst_2)) (HSMul.hSMul.{u2, u1, u1} M (Polynomial.{u1} R _inst_2) (Polynomial.{u1} R _inst_2) (instHSMul.{u2, u1} M (Polynomial.{u1} R _inst_2) (SMulZeroClass.toSMul.{u2, u1} M (Polynomial.{u1} R _inst_2) (Polynomial.zero.{u1} R _inst_2) (Polynomial.smulZeroClass.{u1, u2} R _inst_2 M (DistribSMul.toSMulZeroClass.{u2, u1} M R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_2))))) (DistribMulAction.toDistribSMul.{u2, u1} M R _inst_1 (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_2)))) (MulSemiringAction.toDistribMulAction.{u2, u1} M R _inst_1 _inst_2 _inst_3)))))) m) (Polynomial.map.{u1, u1} R R _inst_2 _inst_2 (MulSemiringAction.toRingHom.{u1, u2} M _inst_1 R _inst_2 _inst_3 m))
Case conversion may be inaccurate. Consider using '#align polynomial.smul_eq_map Polynomial.smul_eq_mapₓ'. -/
theorem smul_eq_map [MulSemiringAction M R] (m : M) :
    (· • ·) m = map (MulSemiringAction.toRingHom M R m) :=
  by
  suffices
    DistribMulAction.toAddMonoidHom R[X] m =
      (map_ring_hom (MulSemiringAction.toRingHom M R m)).toAddMonoidHom
    by
    ext1 r
    exact AddMonoidHom.congr_fun this r
  ext (n r) : 2
  change m • monomial n r = map (MulSemiringAction.toRingHom M R m) (monomial n r)
  simpa only [Polynomial.map_monomial, Polynomial.smul_monomial]
#align polynomial.smul_eq_map Polynomial.smul_eq_map

variable (M)

noncomputable instance [MulSemiringAction M R] : MulSemiringAction M R[X] :=
  { Polynomial.distribMulAction with
    smul := (· • ·)
    smul_one := fun m =>
      (smul_eq_map R m).symm ▸ Polynomial.map_one (MulSemiringAction.toRingHom M R m)
    smul_mul := fun m p q =>
      (smul_eq_map R m).symm ▸ Polynomial.map_mul (MulSemiringAction.toRingHom M R m) }

variable {M R}

variable [MulSemiringAction M R]

/- warning: polynomial.smul_X -> Polynomial.smul_X is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] {R : Type.{u2}} [_inst_2 : Semiring.{u2} R] [_inst_3 : MulSemiringAction.{u1, u2} M R _inst_1 _inst_2] (m : M), Eq.{succ u2} (Polynomial.{u2} R _inst_2) (SMul.smul.{u1, u2} M (Polynomial.{u2} R _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} M (Polynomial.{u2} R _inst_2) (Polynomial.zero.{u2} R _inst_2) (Polynomial.smulZeroClass.{u2, u1} R _inst_2 M (DistribSMul.toSmulZeroClass.{u1, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))))) (DistribMulAction.toDistribSMul.{u1, u2} M R _inst_1 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (MulSemiringAction.toDistribMulAction.{u1, u2} M R _inst_1 _inst_2 _inst_3))))) m (Polynomial.X.{u2} R _inst_2)) (Polynomial.X.{u2} R _inst_2)
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] {R : Type.{u2}} [_inst_2 : Semiring.{u2} R] [_inst_3 : MulSemiringAction.{u1, u2} M R _inst_1 _inst_2] (m : M), Eq.{succ u2} (Polynomial.{u2} R _inst_2) (HSMul.hSMul.{u1, u2, u2} M (Polynomial.{u2} R _inst_2) (Polynomial.{u2} R _inst_2) (instHSMul.{u1, u2} M (Polynomial.{u2} R _inst_2) (SMulZeroClass.toSMul.{u1, u2} M (Polynomial.{u2} R _inst_2) (Polynomial.zero.{u2} R _inst_2) (Polynomial.smulZeroClass.{u2, u1} R _inst_2 M (DistribSMul.toSMulZeroClass.{u1, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))))) (DistribMulAction.toDistribSMul.{u1, u2} M R _inst_1 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (MulSemiringAction.toDistribMulAction.{u1, u2} M R _inst_1 _inst_2 _inst_3)))))) m (Polynomial.X.{u2} R _inst_2)) (Polynomial.X.{u2} R _inst_2)
Case conversion may be inaccurate. Consider using '#align polynomial.smul_X Polynomial.smul_Xₓ'. -/
@[simp]
theorem smul_X (m : M) : (m • X : R[X]) = X :=
  (smul_eq_map R m).symm ▸ map_X _
#align polynomial.smul_X Polynomial.smul_X

variable (S : Type _) [CommSemiring S] [MulSemiringAction M S]

/- warning: polynomial.smul_eval_smul -> Polynomial.smul_eval_smul is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] (S : Type.{u2}) [_inst_4 : CommSemiring.{u2} S] [_inst_5 : MulSemiringAction.{u1, u2} M S _inst_1 (CommSemiring.toSemiring.{u2} S _inst_4)] (m : M) (f : Polynomial.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)) (x : S), Eq.{succ u2} S (Polynomial.eval.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4) (SMul.smul.{u1, u2} M S (SMulZeroClass.toHasSmul.{u1, u2} M S (AddZeroClass.toHasZero.{u2} S (AddMonoid.toAddZeroClass.{u2} S (AddMonoidWithOne.toAddMonoid.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4))))))) (DistribSMul.toSmulZeroClass.{u1, u2} M S (AddMonoid.toAddZeroClass.{u2} S (AddMonoidWithOne.toAddMonoid.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)))))) (DistribMulAction.toDistribSMul.{u1, u2} M S _inst_1 (AddMonoidWithOne.toAddMonoid.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4))))) (MulSemiringAction.toDistribMulAction.{u1, u2} M S _inst_1 (CommSemiring.toSemiring.{u2} S _inst_4) _inst_5)))) m x) (SMul.smul.{u1, u2} M (Polynomial.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)) (SMulZeroClass.toHasSmul.{u1, u2} M (Polynomial.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)) (Polynomial.zero.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)) (Polynomial.smulZeroClass.{u2, u1} S (CommSemiring.toSemiring.{u2} S _inst_4) M (DistribSMul.toSmulZeroClass.{u1, u2} M S (AddMonoid.toAddZeroClass.{u2} S (AddMonoidWithOne.toAddMonoid.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)))))) (DistribMulAction.toDistribSMul.{u1, u2} M S _inst_1 (AddMonoidWithOne.toAddMonoid.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4))))) (MulSemiringAction.toDistribMulAction.{u1, u2} M S _inst_1 (CommSemiring.toSemiring.{u2} S _inst_4) _inst_5))))) m f)) (SMul.smul.{u1, u2} M S (SMulZeroClass.toHasSmul.{u1, u2} M S (AddZeroClass.toHasZero.{u2} S (AddMonoid.toAddZeroClass.{u2} S (AddMonoidWithOne.toAddMonoid.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4))))))) (DistribSMul.toSmulZeroClass.{u1, u2} M S (AddMonoid.toAddZeroClass.{u2} S (AddMonoidWithOne.toAddMonoid.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)))))) (DistribMulAction.toDistribSMul.{u1, u2} M S _inst_1 (AddMonoidWithOne.toAddMonoid.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4))))) (MulSemiringAction.toDistribMulAction.{u1, u2} M S _inst_1 (CommSemiring.toSemiring.{u2} S _inst_4) _inst_5)))) m (Polynomial.eval.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4) x f))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] (S : Type.{u2}) [_inst_4 : CommSemiring.{u2} S] [_inst_5 : MulSemiringAction.{u1, u2} M S _inst_1 (CommSemiring.toSemiring.{u2} S _inst_4)] (m : M) (f : Polynomial.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)) (x : S), Eq.{succ u2} S (Polynomial.eval.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4) (HSMul.hSMul.{u1, u2, u2} M S S (instHSMul.{u1, u2} M S (SMulZeroClass.toSMul.{u1, u2} M S (CommMonoidWithZero.toZero.{u2} S (CommSemiring.toCommMonoidWithZero.{u2} S _inst_4)) (DistribSMul.toSMulZeroClass.{u1, u2} M S (AddMonoid.toAddZeroClass.{u2} S (AddMonoidWithOne.toAddMonoid.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)))))) (DistribMulAction.toDistribSMul.{u1, u2} M S _inst_1 (AddMonoidWithOne.toAddMonoid.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4))))) (MulSemiringAction.toDistribMulAction.{u1, u2} M S _inst_1 (CommSemiring.toSemiring.{u2} S _inst_4) _inst_5))))) m x) (HSMul.hSMul.{u1, u2, u2} M (Polynomial.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)) (Polynomial.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)) (instHSMul.{u1, u2} M (Polynomial.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)) (SMulZeroClass.toSMul.{u1, u2} M (Polynomial.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)) (Polynomial.zero.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)) (Polynomial.smulZeroClass.{u2, u1} S (CommSemiring.toSemiring.{u2} S _inst_4) M (DistribSMul.toSMulZeroClass.{u1, u2} M S (AddMonoid.toAddZeroClass.{u2} S (AddMonoidWithOne.toAddMonoid.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)))))) (DistribMulAction.toDistribSMul.{u1, u2} M S _inst_1 (AddMonoidWithOne.toAddMonoid.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4))))) (MulSemiringAction.toDistribMulAction.{u1, u2} M S _inst_1 (CommSemiring.toSemiring.{u2} S _inst_4) _inst_5)))))) m f)) (HSMul.hSMul.{u1, u2, u2} M S S (instHSMul.{u1, u2} M S (SMulZeroClass.toSMul.{u1, u2} M S (CommMonoidWithZero.toZero.{u2} S (CommSemiring.toCommMonoidWithZero.{u2} S _inst_4)) (DistribSMul.toSMulZeroClass.{u1, u2} M S (AddMonoid.toAddZeroClass.{u2} S (AddMonoidWithOne.toAddMonoid.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)))))) (DistribMulAction.toDistribSMul.{u1, u2} M S _inst_1 (AddMonoidWithOne.toAddMonoid.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4))))) (MulSemiringAction.toDistribMulAction.{u1, u2} M S _inst_1 (CommSemiring.toSemiring.{u2} S _inst_4) _inst_5))))) m (Polynomial.eval.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4) x f))
Case conversion may be inaccurate. Consider using '#align polynomial.smul_eval_smul Polynomial.smul_eval_smulₓ'. -/
theorem smul_eval_smul (m : M) (f : S[X]) (x : S) : (m • f).eval (m • x) = m • f.eval x :=
  Polynomial.induction_on f (fun r => by rw [smul_C, eval_C, eval_C])
    (fun f g ihf ihg => by rw [smul_add, eval_add, ihf, ihg, eval_add, smul_add]) fun n r ih => by
    rw [smul_mul', smul_pow', smul_C, smul_X, eval_mul, eval_C, eval_pow, eval_X, eval_mul, eval_C,
      eval_pow, eval_X, smul_mul', smul_pow']
#align polynomial.smul_eval_smul Polynomial.smul_eval_smul

variable (G : Type _) [Group G]

/- warning: polynomial.eval_smul' -> Polynomial.eval_smul' is a dubious translation:
lean 3 declaration is
  forall (S : Type.{u1}) [_inst_4 : CommSemiring.{u1} S] (G : Type.{u2}) [_inst_6 : Group.{u2} G] [_inst_7 : MulSemiringAction.{u2, u1} G S (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_6)) (CommSemiring.toSemiring.{u1} S _inst_4)] (g : G) (f : Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)) (x : S), Eq.{succ u1} S (Polynomial.eval.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4) (SMul.smul.{u2, u1} G S (SMulZeroClass.toHasSmul.{u2, u1} G S (AddZeroClass.toHasZero.{u1} S (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4))))))) (DistribSMul.toSmulZeroClass.{u2, u1} G S (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)))))) (DistribMulAction.toDistribSMul.{u2, u1} G S (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_6)) (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4))))) (MulSemiringAction.toDistribMulAction.{u2, u1} G S (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_6)) (CommSemiring.toSemiring.{u1} S _inst_4) _inst_7)))) g x) f) (SMul.smul.{u2, u1} G S (SMulZeroClass.toHasSmul.{u2, u1} G S (AddZeroClass.toHasZero.{u1} S (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4))))))) (DistribSMul.toSmulZeroClass.{u2, u1} G S (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)))))) (DistribMulAction.toDistribSMul.{u2, u1} G S (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_6)) (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4))))) (MulSemiringAction.toDistribMulAction.{u2, u1} G S (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_6)) (CommSemiring.toSemiring.{u1} S _inst_4) _inst_7)))) g (Polynomial.eval.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4) x (SMul.smul.{u2, u1} G (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)) (SMulZeroClass.toHasSmul.{u2, u1} G (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)) (Polynomial.zero.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)) (Polynomial.smulZeroClass.{u1, u2} S (CommSemiring.toSemiring.{u1} S _inst_4) G (DistribSMul.toSmulZeroClass.{u2, u1} G S (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)))))) (DistribMulAction.toDistribSMul.{u2, u1} G S (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_6)) (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4))))) (MulSemiringAction.toDistribMulAction.{u2, u1} G S (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_6)) (CommSemiring.toSemiring.{u1} S _inst_4) _inst_7))))) (Inv.inv.{u2} G (DivInvMonoid.toHasInv.{u2} G (Group.toDivInvMonoid.{u2} G _inst_6)) g) f)))
but is expected to have type
  forall (S : Type.{u1}) [_inst_4 : CommSemiring.{u1} S] (G : Type.{u2}) [_inst_6 : Group.{u2} G] [_inst_7 : MulSemiringAction.{u2, u1} G S (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_6)) (CommSemiring.toSemiring.{u1} S _inst_4)] (g : G) (f : Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)) (x : S), Eq.{succ u1} S (Polynomial.eval.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4) (HSMul.hSMul.{u2, u1, u1} G S S (instHSMul.{u2, u1} G S (SMulZeroClass.toSMul.{u2, u1} G S (CommMonoidWithZero.toZero.{u1} S (CommSemiring.toCommMonoidWithZero.{u1} S _inst_4)) (DistribSMul.toSMulZeroClass.{u2, u1} G S (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)))))) (DistribMulAction.toDistribSMul.{u2, u1} G S (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_6)) (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4))))) (MulSemiringAction.toDistribMulAction.{u2, u1} G S (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_6)) (CommSemiring.toSemiring.{u1} S _inst_4) _inst_7))))) g x) f) (HSMul.hSMul.{u2, u1, u1} G S S (instHSMul.{u2, u1} G S (SMulZeroClass.toSMul.{u2, u1} G S (CommMonoidWithZero.toZero.{u1} S (CommSemiring.toCommMonoidWithZero.{u1} S _inst_4)) (DistribSMul.toSMulZeroClass.{u2, u1} G S (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)))))) (DistribMulAction.toDistribSMul.{u2, u1} G S (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_6)) (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4))))) (MulSemiringAction.toDistribMulAction.{u2, u1} G S (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_6)) (CommSemiring.toSemiring.{u1} S _inst_4) _inst_7))))) g (Polynomial.eval.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4) x (HSMul.hSMul.{u2, u1, u1} G (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)) (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)) (instHSMul.{u2, u1} G (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)) (SMulZeroClass.toSMul.{u2, u1} G (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)) (Polynomial.zero.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)) (Polynomial.smulZeroClass.{u1, u2} S (CommSemiring.toSemiring.{u1} S _inst_4) G (DistribSMul.toSMulZeroClass.{u2, u1} G S (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)))))) (DistribMulAction.toDistribSMul.{u2, u1} G S (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_6)) (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4))))) (MulSemiringAction.toDistribMulAction.{u2, u1} G S (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_6)) (CommSemiring.toSemiring.{u1} S _inst_4) _inst_7)))))) (Inv.inv.{u2} G (InvOneClass.toInv.{u2} G (DivInvOneMonoid.toInvOneClass.{u2} G (DivisionMonoid.toDivInvOneMonoid.{u2} G (Group.toDivisionMonoid.{u2} G _inst_6)))) g) f)))
Case conversion may be inaccurate. Consider using '#align polynomial.eval_smul' Polynomial.eval_smul'ₓ'. -/
theorem eval_smul' [MulSemiringAction G S] (g : G) (f : S[X]) (x : S) :
    f.eval (g • x) = g • (g⁻¹ • f).eval x := by rw [← smul_eval_smul, smul_inv_smul]
#align polynomial.eval_smul' Polynomial.eval_smul'

/- warning: polynomial.smul_eval -> Polynomial.smul_eval is a dubious translation:
lean 3 declaration is
  forall (S : Type.{u1}) [_inst_4 : CommSemiring.{u1} S] (G : Type.{u2}) [_inst_6 : Group.{u2} G] [_inst_7 : MulSemiringAction.{u2, u1} G S (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_6)) (CommSemiring.toSemiring.{u1} S _inst_4)] (g : G) (f : Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)) (x : S), Eq.{succ u1} S (Polynomial.eval.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4) x (SMul.smul.{u2, u1} G (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)) (SMulZeroClass.toHasSmul.{u2, u1} G (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)) (Polynomial.zero.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)) (Polynomial.smulZeroClass.{u1, u2} S (CommSemiring.toSemiring.{u1} S _inst_4) G (DistribSMul.toSmulZeroClass.{u2, u1} G S (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)))))) (DistribMulAction.toDistribSMul.{u2, u1} G S (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_6)) (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4))))) (MulSemiringAction.toDistribMulAction.{u2, u1} G S (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_6)) (CommSemiring.toSemiring.{u1} S _inst_4) _inst_7))))) g f)) (SMul.smul.{u2, u1} G S (SMulZeroClass.toHasSmul.{u2, u1} G S (AddZeroClass.toHasZero.{u1} S (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4))))))) (DistribSMul.toSmulZeroClass.{u2, u1} G S (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)))))) (DistribMulAction.toDistribSMul.{u2, u1} G S (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_6)) (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4))))) (MulSemiringAction.toDistribMulAction.{u2, u1} G S (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_6)) (CommSemiring.toSemiring.{u1} S _inst_4) _inst_7)))) g (Polynomial.eval.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4) (SMul.smul.{u2, u1} G S (SMulZeroClass.toHasSmul.{u2, u1} G S (AddZeroClass.toHasZero.{u1} S (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4))))))) (DistribSMul.toSmulZeroClass.{u2, u1} G S (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)))))) (DistribMulAction.toDistribSMul.{u2, u1} G S (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_6)) (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4))))) (MulSemiringAction.toDistribMulAction.{u2, u1} G S (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_6)) (CommSemiring.toSemiring.{u1} S _inst_4) _inst_7)))) (Inv.inv.{u2} G (DivInvMonoid.toHasInv.{u2} G (Group.toDivInvMonoid.{u2} G _inst_6)) g) x) f))
but is expected to have type
  forall (S : Type.{u1}) [_inst_4 : CommSemiring.{u1} S] (G : Type.{u2}) [_inst_6 : Group.{u2} G] [_inst_7 : MulSemiringAction.{u2, u1} G S (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_6)) (CommSemiring.toSemiring.{u1} S _inst_4)] (g : G) (f : Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)) (x : S), Eq.{succ u1} S (Polynomial.eval.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4) x (HSMul.hSMul.{u2, u1, u1} G (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)) (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)) (instHSMul.{u2, u1} G (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)) (SMulZeroClass.toSMul.{u2, u1} G (Polynomial.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)) (Polynomial.zero.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)) (Polynomial.smulZeroClass.{u1, u2} S (CommSemiring.toSemiring.{u1} S _inst_4) G (DistribSMul.toSMulZeroClass.{u2, u1} G S (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)))))) (DistribMulAction.toDistribSMul.{u2, u1} G S (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_6)) (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4))))) (MulSemiringAction.toDistribMulAction.{u2, u1} G S (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_6)) (CommSemiring.toSemiring.{u1} S _inst_4) _inst_7)))))) g f)) (HSMul.hSMul.{u2, u1, u1} G S S (instHSMul.{u2, u1} G S (SMulZeroClass.toSMul.{u2, u1} G S (CommMonoidWithZero.toZero.{u1} S (CommSemiring.toCommMonoidWithZero.{u1} S _inst_4)) (DistribSMul.toSMulZeroClass.{u2, u1} G S (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)))))) (DistribMulAction.toDistribSMul.{u2, u1} G S (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_6)) (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4))))) (MulSemiringAction.toDistribMulAction.{u2, u1} G S (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_6)) (CommSemiring.toSemiring.{u1} S _inst_4) _inst_7))))) g (Polynomial.eval.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4) (HSMul.hSMul.{u2, u1, u1} G S S (instHSMul.{u2, u1} G S (SMulZeroClass.toSMul.{u2, u1} G S (CommMonoidWithZero.toZero.{u1} S (CommSemiring.toCommMonoidWithZero.{u1} S _inst_4)) (DistribSMul.toSMulZeroClass.{u2, u1} G S (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)))))) (DistribMulAction.toDistribSMul.{u2, u1} G S (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_6)) (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4))))) (MulSemiringAction.toDistribMulAction.{u2, u1} G S (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_6)) (CommSemiring.toSemiring.{u1} S _inst_4) _inst_7))))) (Inv.inv.{u2} G (InvOneClass.toInv.{u2} G (DivInvOneMonoid.toInvOneClass.{u2} G (DivisionMonoid.toDivInvOneMonoid.{u2} G (Group.toDivisionMonoid.{u2} G _inst_6)))) g) x) f))
Case conversion may be inaccurate. Consider using '#align polynomial.smul_eval Polynomial.smul_evalₓ'. -/
theorem smul_eval [MulSemiringAction G S] (g : G) (f : S[X]) (x : S) :
    (g • f).eval x = g • f.eval (g⁻¹ • x) := by rw [← smul_eval_smul, smul_inv_smul]
#align polynomial.smul_eval Polynomial.smul_eval

end Polynomial

section CommRing

variable (G : Type _) [Group G] [Fintype G]

variable (R : Type _) [CommRing R] [MulSemiringAction G R]

open MulAction

open Classical

#print prodXSubSmul /-
/-- the product of `(X - g • x)` over distinct `g • x`. -/
noncomputable def prodXSubSmul (x : R) : R[X] :=
  (Finset.univ : Finset (G ⧸ MulAction.stabilizer G x)).Prod fun g =>
    Polynomial.X - Polynomial.C (ofQuotientStabilizer G x g)
#align prod_X_sub_smul prodXSubSmul
-/

#print prodXSubSmul.monic /-
theorem prodXSubSmul.monic (x : R) : (prodXSubSmul G R x).Monic :=
  Polynomial.monic_prod_of_monic _ _ fun g _ => Polynomial.monic_X_sub_C _
#align prod_X_sub_smul.monic prodXSubSmul.monic
-/

/- warning: prod_X_sub_smul.eval -> prodXSubSmul.eval is a dubious translation:
lean 3 declaration is
  forall (G : Type.{u1}) [_inst_2 : Group.{u1} G] [_inst_3 : Fintype.{u1} G] (R : Type.{u2}) [_inst_4 : CommRing.{u2} R] [_inst_5 : MulSemiringAction.{u1, u2} G R (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)) (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4))] (x : R), Eq.{succ u2} R (Polynomial.eval.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4)) x (prodXSubSmul.{u1, u2} G _inst_2 _inst_3 R _inst_4 _inst_5 x)) (OfNat.ofNat.{u2} R 0 (OfNat.mk.{u2} R 0 (Zero.zero.{u2} R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4)))))))))
but is expected to have type
  forall (G : Type.{u1}) [_inst_2 : Group.{u1} G] [_inst_3 : Fintype.{u1} G] (R : Type.{u2}) [_inst_4 : CommRing.{u2} R] [_inst_5 : MulSemiringAction.{u1, u2} G R (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)) (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4))] (x : R), Eq.{succ u2} R (Polynomial.eval.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4)) x (prodXSubSmul.{u1, u2} G _inst_2 _inst_3 R _inst_4 _inst_5 x)) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_4)))))
Case conversion may be inaccurate. Consider using '#align prod_X_sub_smul.eval prodXSubSmul.evalₓ'. -/
theorem prodXSubSmul.eval (x : R) : (prodXSubSmul G R x).eval x = 0 :=
  (MonoidHom.map_prod ((Polynomial.aeval x).toRingHom.toMonoidHom : R[X] →* R) _ _).trans <|
    Finset.prod_eq_zero (Finset.mem_univ <| QuotientGroup.mk 1) <| by simp
#align prod_X_sub_smul.eval prodXSubSmul.eval

/- warning: prod_X_sub_smul.smul -> prodXSubSmul.smul is a dubious translation:
lean 3 declaration is
  forall (G : Type.{u1}) [_inst_2 : Group.{u1} G] [_inst_3 : Fintype.{u1} G] (R : Type.{u2}) [_inst_4 : CommRing.{u2} R] [_inst_5 : MulSemiringAction.{u1, u2} G R (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)) (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4))] (x : R) (g : G), Eq.{succ u2} (Polynomial.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4))) (SMul.smul.{u1, u2} G (Polynomial.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4))) (SMulZeroClass.toHasSmul.{u1, u2} G (Polynomial.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4))) (Polynomial.zero.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4))) (Polynomial.smulZeroClass.{u2, u1} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4)) G (DistribSMul.toSmulZeroClass.{u1, u2} G R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (NonAssocRing.toAddGroupWithOne.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4)))))) (DistribMulAction.toDistribSMul.{u1, u2} G R (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)) (AddMonoidWithOne.toAddMonoid.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (NonAssocRing.toAddGroupWithOne.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4))))) (MulSemiringAction.toDistribMulAction.{u1, u2} G R (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)) (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4)) _inst_5))))) g (prodXSubSmul.{u1, u2} G _inst_2 _inst_3 R _inst_4 _inst_5 x)) (prodXSubSmul.{u1, u2} G _inst_2 _inst_3 R _inst_4 _inst_5 x)
but is expected to have type
  forall (G : Type.{u1}) [_inst_2 : Group.{u1} G] [_inst_3 : Fintype.{u1} G] (R : Type.{u2}) [_inst_4 : CommRing.{u2} R] [_inst_5 : MulSemiringAction.{u1, u2} G R (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)) (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4))] (x : R) (g : G), Eq.{succ u2} (Polynomial.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4))) (HSMul.hSMul.{u1, u2, u2} G (Polynomial.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4))) (Polynomial.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4))) (instHSMul.{u1, u2} G (Polynomial.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4))) (SMulZeroClass.toSMul.{u1, u2} G (Polynomial.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4))) (Polynomial.zero.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4))) (Polynomial.smulZeroClass.{u2, u1} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4)) G (DistribSMul.toSMulZeroClass.{u1, u2} G R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (Ring.toAddGroupWithOne.{u2} R (CommRing.toRing.{u2} R _inst_4))))) (DistribMulAction.toDistribSMul.{u1, u2} G R (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)) (AddMonoidWithOne.toAddMonoid.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (Ring.toAddGroupWithOne.{u2} R (CommRing.toRing.{u2} R _inst_4)))) (MulSemiringAction.toDistribMulAction.{u1, u2} G R (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)) (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4)) _inst_5)))))) g (prodXSubSmul.{u1, u2} G _inst_2 _inst_3 R _inst_4 _inst_5 x)) (prodXSubSmul.{u1, u2} G _inst_2 _inst_3 R _inst_4 _inst_5 x)
Case conversion may be inaccurate. Consider using '#align prod_X_sub_smul.smul prodXSubSmul.smulₓ'. -/
theorem prodXSubSmul.smul (x : R) (g : G) : g • prodXSubSmul G R x = prodXSubSmul G R x :=
  Finset.smul_prod.trans <|
    Fintype.prod_bijective _ (MulAction.bijective g) _ _ fun g' => by
      rw [of_quotient_stabilizer_smul, smul_sub, Polynomial.smul_X, Polynomial.smul_C]
#align prod_X_sub_smul.smul prodXSubSmul.smul

/- warning: prod_X_sub_smul.coeff -> prodXSubSmul.coeff is a dubious translation:
lean 3 declaration is
  forall (G : Type.{u1}) [_inst_2 : Group.{u1} G] [_inst_3 : Fintype.{u1} G] (R : Type.{u2}) [_inst_4 : CommRing.{u2} R] [_inst_5 : MulSemiringAction.{u1, u2} G R (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)) (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4))] (x : R) (g : G) (n : Nat), Eq.{succ u2} R (SMul.smul.{u1, u2} G R (SMulZeroClass.toHasSmul.{u1, u2} G R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4)))))))) (DistribSMul.toSmulZeroClass.{u1, u2} G R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4))))))) (DistribMulAction.toDistribSMul.{u1, u2} G R (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)) (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4)))))) (MulSemiringAction.toDistribMulAction.{u1, u2} G R (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)) (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4)) _inst_5)))) g (Polynomial.coeff.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4)) (prodXSubSmul.{u1, u2} G _inst_2 _inst_3 R _inst_4 _inst_5 x) n)) (Polynomial.coeff.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4)) (prodXSubSmul.{u1, u2} G _inst_2 _inst_3 R _inst_4 _inst_5 x) n)
but is expected to have type
  forall (G : Type.{u1}) [_inst_2 : Group.{u1} G] [_inst_3 : Fintype.{u1} G] (R : Type.{u2}) [_inst_4 : CommRing.{u2} R] [_inst_5 : MulSemiringAction.{u1, u2} G R (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)) (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4))] (x : R) (g : G) (n : Nat), Eq.{succ u2} R (HSMul.hSMul.{u1, u2, u2} G R R (instHSMul.{u1, u2} G R (SMulZeroClass.toSMul.{u1, u2} G R (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_4))) (DistribSMul.toSMulZeroClass.{u1, u2} G R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (Ring.toAddGroupWithOne.{u2} R (CommRing.toRing.{u2} R _inst_4))))) (DistribMulAction.toDistribSMul.{u1, u2} G R (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)) (AddMonoidWithOne.toAddMonoid.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (Ring.toAddGroupWithOne.{u2} R (CommRing.toRing.{u2} R _inst_4)))) (MulSemiringAction.toDistribMulAction.{u1, u2} G R (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)) (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4)) _inst_5))))) g (Polynomial.coeff.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4)) (prodXSubSmul.{u1, u2} G _inst_2 _inst_3 R _inst_4 _inst_5 x) n)) (Polynomial.coeff.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4)) (prodXSubSmul.{u1, u2} G _inst_2 _inst_3 R _inst_4 _inst_5 x) n)
Case conversion may be inaccurate. Consider using '#align prod_X_sub_smul.coeff prodXSubSmul.coeffₓ'. -/
theorem prodXSubSmul.coeff (x : R) (g : G) (n : ℕ) :
    g • (prodXSubSmul G R x).coeff n = (prodXSubSmul G R x).coeff n := by
  rw [← Polynomial.coeff_smul, prodXSubSmul.smul]
#align prod_X_sub_smul.coeff prodXSubSmul.coeff

end CommRing

namespace MulSemiringActionHom

variable {M}

variable {P : Type _} [CommSemiring P] [MulSemiringAction M P]

variable {Q : Type _} [CommSemiring Q] [MulSemiringAction M Q]

open Polynomial

/- warning: mul_semiring_action_hom.polynomial -> MulSemiringActionHom.polynomial is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] {P : Type.{u2}} [_inst_2 : CommSemiring.{u2} P] [_inst_3 : MulSemiringAction.{u1, u2} M P _inst_1 (CommSemiring.toSemiring.{u2} P _inst_2)] {Q : Type.{u3}} [_inst_4 : CommSemiring.{u3} Q] [_inst_5 : MulSemiringAction.{u1, u3} M Q _inst_1 (CommSemiring.toSemiring.{u3} Q _inst_4)], (MulSemiringActionHom.{u1, u2, u3} M _inst_1 P (CommSemiring.toSemiring.{u2} P _inst_2) _inst_3 Q (CommSemiring.toSemiring.{u3} Q _inst_4) _inst_5) -> (MulSemiringActionHom.{u1, u2, u3} M _inst_1 (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Polynomial.semiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Polynomial.mulSemiringAction.{u1, u2} M _inst_1 P (CommSemiring.toSemiring.{u2} P _inst_2) _inst_3) (Polynomial.{u3} Q (CommSemiring.toSemiring.{u3} Q _inst_4)) (Polynomial.semiring.{u3} Q (CommSemiring.toSemiring.{u3} Q _inst_4)) (Polynomial.mulSemiringAction.{u1, u3} M _inst_1 Q (CommSemiring.toSemiring.{u3} Q _inst_4) _inst_5))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] {P : Type.{u2}} [_inst_2 : CommSemiring.{u2} P] [_inst_3 : MulSemiringAction.{u1, u2} M P _inst_1 (CommSemiring.toSemiring.{u2} P _inst_2)] {Q : Type.{u3}} [_inst_4 : CommSemiring.{u3} Q] [_inst_5 : MulSemiringAction.{u1, u3} M Q _inst_1 (CommSemiring.toSemiring.{u3} Q _inst_4)], (MulSemiringActionHom.{u1, u2, u3} M _inst_1 P (CommSemiring.toSemiring.{u2} P _inst_2) _inst_3 Q (CommSemiring.toSemiring.{u3} Q _inst_4) _inst_5) -> (MulSemiringActionHom.{u1, u2, u3} M _inst_1 (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Polynomial.semiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Polynomial.instMulSemiringActionPolynomialSemiring.{u1, u2} M _inst_1 P (CommSemiring.toSemiring.{u2} P _inst_2) _inst_3) (Polynomial.{u3} Q (CommSemiring.toSemiring.{u3} Q _inst_4)) (Polynomial.semiring.{u3} Q (CommSemiring.toSemiring.{u3} Q _inst_4)) (Polynomial.instMulSemiringActionPolynomialSemiring.{u1, u3} M _inst_1 Q (CommSemiring.toSemiring.{u3} Q _inst_4) _inst_5))
Case conversion may be inaccurate. Consider using '#align mul_semiring_action_hom.polynomial MulSemiringActionHom.polynomialₓ'. -/
/-- An equivariant map induces an equivariant map on polynomials. -/
protected noncomputable def polynomial (g : P →+*[M] Q) : P[X] →+*[M] Q[X]
    where
  toFun := map g
  map_smul' m p :=
    Polynomial.induction_on p
      (fun b => by rw [smul_C, map_C, coe_fn_coe, g.map_smul, map_C, coe_fn_coe, smul_C])
      (fun p q ihp ihq => by
        rw [smul_add, Polynomial.map_add, ihp, ihq, Polynomial.map_add, smul_add])
      fun n b ih => by
      rw [smul_mul', smul_C, smul_pow', smul_X, Polynomial.map_mul, map_C, Polynomial.map_pow,
        map_X, coe_fn_coe, g.map_smul, Polynomial.map_mul, map_C, Polynomial.map_pow, map_X,
        smul_mul', smul_C, smul_pow', smul_X, coe_fn_coe]
  map_zero' := Polynomial.map_zero g
  map_add' p q := Polynomial.map_add g
  map_one' := Polynomial.map_one g
  map_mul' p q := Polynomial.map_mul g
#align mul_semiring_action_hom.polynomial MulSemiringActionHom.polynomial

/- warning: mul_semiring_action_hom.coe_polynomial -> MulSemiringActionHom.coe_polynomial is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] {P : Type.{u2}} [_inst_2 : CommSemiring.{u2} P] [_inst_3 : MulSemiringAction.{u1, u2} M P _inst_1 (CommSemiring.toSemiring.{u2} P _inst_2)] {Q : Type.{u3}} [_inst_4 : CommSemiring.{u3} Q] [_inst_5 : MulSemiringAction.{u1, u3} M Q _inst_1 (CommSemiring.toSemiring.{u3} Q _inst_4)] (g : MulSemiringActionHom.{u1, u2, u3} M _inst_1 P (CommSemiring.toSemiring.{u2} P _inst_2) _inst_3 Q (CommSemiring.toSemiring.{u3} Q _inst_4) _inst_5), Eq.{max (succ u2) (succ u3)} ((fun (_x : MulSemiringActionHom.{u1, u2, u3} M _inst_1 (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Polynomial.semiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Polynomial.mulSemiringAction.{u1, u2} M _inst_1 P (CommSemiring.toSemiring.{u2} P _inst_2) _inst_3) (Polynomial.{u3} Q (CommSemiring.toSemiring.{u3} Q _inst_4)) (Polynomial.semiring.{u3} Q (CommSemiring.toSemiring.{u3} Q _inst_4)) (Polynomial.mulSemiringAction.{u1, u3} M _inst_1 Q (CommSemiring.toSemiring.{u3} Q _inst_4) _inst_5)) => (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) -> (Polynomial.{u3} Q (CommSemiring.toSemiring.{u3} Q _inst_4))) (MulSemiringActionHom.polynomial.{u1, u2, u3} M _inst_1 P _inst_2 _inst_3 Q _inst_4 _inst_5 g)) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_1 (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Polynomial.semiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Polynomial.mulSemiringAction.{u1, u2} M _inst_1 P (CommSemiring.toSemiring.{u2} P _inst_2) _inst_3) (Polynomial.{u3} Q (CommSemiring.toSemiring.{u3} Q _inst_4)) (Polynomial.semiring.{u3} Q (CommSemiring.toSemiring.{u3} Q _inst_4)) (Polynomial.mulSemiringAction.{u1, u3} M _inst_1 Q (CommSemiring.toSemiring.{u3} Q _inst_4) _inst_5)) (fun (_x : MulSemiringActionHom.{u1, u2, u3} M _inst_1 (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Polynomial.semiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Polynomial.mulSemiringAction.{u1, u2} M _inst_1 P (CommSemiring.toSemiring.{u2} P _inst_2) _inst_3) (Polynomial.{u3} Q (CommSemiring.toSemiring.{u3} Q _inst_4)) (Polynomial.semiring.{u3} Q (CommSemiring.toSemiring.{u3} Q _inst_4)) (Polynomial.mulSemiringAction.{u1, u3} M _inst_1 Q (CommSemiring.toSemiring.{u3} Q _inst_4) _inst_5)) => (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) -> (Polynomial.{u3} Q (CommSemiring.toSemiring.{u3} Q _inst_4))) ([anonymous].{u1, u2, u3} M _inst_1 (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Polynomial.semiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Polynomial.mulSemiringAction.{u1, u2} M _inst_1 P (CommSemiring.toSemiring.{u2} P _inst_2) _inst_3) (Polynomial.{u3} Q (CommSemiring.toSemiring.{u3} Q _inst_4)) (Polynomial.semiring.{u3} Q (CommSemiring.toSemiring.{u3} Q _inst_4)) (Polynomial.mulSemiringAction.{u1, u3} M _inst_1 Q (CommSemiring.toSemiring.{u3} Q _inst_4) _inst_5)) (MulSemiringActionHom.polynomial.{u1, u2, u3} M _inst_1 P _inst_2 _inst_3 Q _inst_4 _inst_5 g)) (Polynomial.map.{u2, u3} P Q (CommSemiring.toSemiring.{u2} P _inst_2) (CommSemiring.toSemiring.{u3} Q _inst_4) ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u2) (succ u3)} a b] => self.0) (MulSemiringActionHom.{u1, u2, u3} M _inst_1 P (CommSemiring.toSemiring.{u2} P _inst_2) _inst_3 Q (CommSemiring.toSemiring.{u3} Q _inst_4) _inst_5) (RingHom.{u2, u3} P Q (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Semiring.toNonAssocSemiring.{u3} Q (CommSemiring.toSemiring.{u3} Q _inst_4))) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_1 P (CommSemiring.toSemiring.{u2} P _inst_2) _inst_3 Q (CommSemiring.toSemiring.{u3} Q _inst_4) _inst_5) (RingHom.{u2, u3} P Q (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Semiring.toNonAssocSemiring.{u3} Q (CommSemiring.toSemiring.{u3} Q _inst_4))) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_1 P (CommSemiring.toSemiring.{u2} P _inst_2) _inst_3 Q (CommSemiring.toSemiring.{u3} Q _inst_4) _inst_5) (RingHom.{u2, u3} P Q (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Semiring.toNonAssocSemiring.{u3} Q (CommSemiring.toSemiring.{u3} Q _inst_4))) (RingHom.hasCoeT.{max u2 u3, u2, u3} (MulSemiringActionHom.{u1, u2, u3} M _inst_1 P (CommSemiring.toSemiring.{u2} P _inst_2) _inst_3 Q (CommSemiring.toSemiring.{u3} Q _inst_4) _inst_5) P Q (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Semiring.toNonAssocSemiring.{u3} Q (CommSemiring.toSemiring.{u3} Q _inst_4)) (MulSemiringActionHomClass.toRingHomClass.{max u2 u3, u1, u2, u3} (MulSemiringActionHom.{u1, u2, u3} M _inst_1 P (CommSemiring.toSemiring.{u2} P _inst_2) _inst_3 Q (CommSemiring.toSemiring.{u3} Q _inst_4) _inst_5) M P Q _inst_1 (CommSemiring.toSemiring.{u2} P _inst_2) (CommSemiring.toSemiring.{u3} Q _inst_4) (MulSemiringAction.toDistribMulAction.{u1, u2} M P _inst_1 (CommSemiring.toSemiring.{u2} P _inst_2) _inst_3) (MulSemiringAction.toDistribMulAction.{u1, u3} M Q _inst_1 (CommSemiring.toSemiring.{u3} Q _inst_4) _inst_5) (MulSemiringActionHom.mulSemiringActionHomClass.{u1, u2, u3} M _inst_1 P (CommSemiring.toSemiring.{u2} P _inst_2) _inst_3 Q (CommSemiring.toSemiring.{u3} Q _inst_4) _inst_5))))) g))
but is expected to have type
  forall {M : Type.{u3}} [_inst_1 : Monoid.{u3} M] {P : Type.{u2}} [_inst_2 : CommSemiring.{u2} P] [_inst_3 : MulSemiringAction.{u3, u2} M P _inst_1 (CommSemiring.toSemiring.{u2} P _inst_2)] {Q : Type.{u1}} [_inst_4 : CommSemiring.{u1} Q] [_inst_5 : MulSemiringAction.{u3, u1} M Q _inst_1 (CommSemiring.toSemiring.{u1} Q _inst_4)] (g : MulSemiringActionHom.{u3, u2, u1} M _inst_1 P (CommSemiring.toSemiring.{u2} P _inst_2) _inst_3 Q (CommSemiring.toSemiring.{u1} Q _inst_4) _inst_5), Eq.{max (succ u2) (succ u1)} (forall (a : Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)), (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) => Polynomial.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_1 (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Polynomial.semiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Polynomial.instMulSemiringActionPolynomialSemiring.{u3, u2} M _inst_1 P (CommSemiring.toSemiring.{u2} P _inst_2) _inst_3) (Polynomial.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (Polynomial.semiring.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (Polynomial.instMulSemiringActionPolynomialSemiring.{u3, u1} M _inst_1 Q (CommSemiring.toSemiring.{u1} Q _inst_4) _inst_5)) (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (fun (_x : Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) => Polynomial.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_1 (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Polynomial.semiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Polynomial.instMulSemiringActionPolynomialSemiring.{u3, u2} M _inst_1 P (CommSemiring.toSemiring.{u2} P _inst_2) _inst_3) (Polynomial.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (Polynomial.semiring.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (Polynomial.instMulSemiringActionPolynomialSemiring.{u3, u1} M _inst_1 Q (CommSemiring.toSemiring.{u1} Q _inst_4) _inst_5)) M (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Polynomial.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (SMulZeroClass.toSMul.{u3, u2} M (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (AddMonoid.toZero.{u2} (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (AddMonoidWithOne.toAddMonoid.{u2} (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (NonAssocSemiring.toAddCommMonoidWithOne.{u2} (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Polynomial.semiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2))))))) (DistribSMul.toSMulZeroClass.{u3, u2} M (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (AddMonoid.toAddZeroClass.{u2} (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (AddMonoidWithOne.toAddMonoid.{u2} (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (NonAssocSemiring.toAddCommMonoidWithOne.{u2} (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Polynomial.semiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2))))))) (DistribMulAction.toDistribSMul.{u3, u2} M (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) _inst_1 (AddMonoidWithOne.toAddMonoid.{u2} (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (NonAssocSemiring.toAddCommMonoidWithOne.{u2} (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Polynomial.semiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)))))) (MulSemiringAction.toDistribMulAction.{u3, u2} M (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) _inst_1 (Polynomial.semiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Polynomial.instMulSemiringActionPolynomialSemiring.{u3, u2} M _inst_1 P (CommSemiring.toSemiring.{u2} P _inst_2) _inst_3))))) (SMulZeroClass.toSMul.{u3, u1} M (Polynomial.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (AddMonoid.toZero.{u1} (Polynomial.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (Polynomial.semiring.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4))))))) (DistribSMul.toSMulZeroClass.{u3, u1} M (Polynomial.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (Polynomial.semiring.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4))))))) (DistribMulAction.toDistribSMul.{u3, u1} M (Polynomial.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) _inst_1 (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (Polynomial.semiring.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)))))) (MulSemiringAction.toDistribMulAction.{u3, u1} M (Polynomial.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) _inst_1 (Polynomial.semiring.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (Polynomial.instMulSemiringActionPolynomialSemiring.{u3, u1} M _inst_1 Q (CommSemiring.toSemiring.{u1} Q _inst_4) _inst_5))))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_1 (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Polynomial.semiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Polynomial.instMulSemiringActionPolynomialSemiring.{u3, u2} M _inst_1 P (CommSemiring.toSemiring.{u2} P _inst_2) _inst_3) (Polynomial.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (Polynomial.semiring.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (Polynomial.instMulSemiringActionPolynomialSemiring.{u3, u1} M _inst_1 Q (CommSemiring.toSemiring.{u1} Q _inst_4) _inst_5)) M (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Polynomial.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) _inst_1 (AddMonoidWithOne.toAddMonoid.{u2} (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (NonAssocSemiring.toAddCommMonoidWithOne.{u2} (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Polynomial.semiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)))))) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (Polynomial.semiring.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)))))) (MulSemiringAction.toDistribMulAction.{u3, u2} M (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) _inst_1 (Polynomial.semiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Polynomial.instMulSemiringActionPolynomialSemiring.{u3, u2} M _inst_1 P (CommSemiring.toSemiring.{u2} P _inst_2) _inst_3)) (MulSemiringAction.toDistribMulAction.{u3, u1} M (Polynomial.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) _inst_1 (Polynomial.semiring.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (Polynomial.instMulSemiringActionPolynomialSemiring.{u3, u1} M _inst_1 Q (CommSemiring.toSemiring.{u1} Q _inst_4) _inst_5)) (MulSemiringActionHomClass.toDistribMulActionHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_1 (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Polynomial.semiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Polynomial.instMulSemiringActionPolynomialSemiring.{u3, u2} M _inst_1 P (CommSemiring.toSemiring.{u2} P _inst_2) _inst_3) (Polynomial.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (Polynomial.semiring.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (Polynomial.instMulSemiringActionPolynomialSemiring.{u3, u1} M _inst_1 Q (CommSemiring.toSemiring.{u1} Q _inst_4) _inst_5)) M (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Polynomial.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) _inst_1 (Polynomial.semiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Polynomial.semiring.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (MulSemiringAction.toDistribMulAction.{u3, u2} M (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) _inst_1 (Polynomial.semiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Polynomial.instMulSemiringActionPolynomialSemiring.{u3, u2} M _inst_1 P (CommSemiring.toSemiring.{u2} P _inst_2) _inst_3)) (MulSemiringAction.toDistribMulAction.{u3, u1} M (Polynomial.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) _inst_1 (Polynomial.semiring.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (Polynomial.instMulSemiringActionPolynomialSemiring.{u3, u1} M _inst_1 Q (CommSemiring.toSemiring.{u1} Q _inst_4) _inst_5)) (MulSemiringActionHom.instMulSemiringActionHomClassMulSemiringActionHomToDistribMulActionToDistribMulAction.{u3, u2, u1} M _inst_1 (Polynomial.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Polynomial.semiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Polynomial.instMulSemiringActionPolynomialSemiring.{u3, u2} M _inst_1 P (CommSemiring.toSemiring.{u2} P _inst_2) _inst_3) (Polynomial.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (Polynomial.semiring.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (Polynomial.instMulSemiringActionPolynomialSemiring.{u3, u1} M _inst_1 Q (CommSemiring.toSemiring.{u1} Q _inst_4) _inst_5))))) (MulSemiringActionHom.polynomial.{u3, u2, u1} M _inst_1 P _inst_2 _inst_3 Q _inst_4 _inst_5 g)) (Polynomial.map.{u2, u1} P Q (CommSemiring.toSemiring.{u2} P _inst_2) (CommSemiring.toSemiring.{u1} Q _inst_4) (RingHomClass.toRingHom.{max u2 u1, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_1 P (CommSemiring.toSemiring.{u2} P _inst_2) _inst_3 Q (CommSemiring.toSemiring.{u1} Q _inst_4) _inst_5) P Q (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_2)) (Semiring.toNonAssocSemiring.{u1} Q (CommSemiring.toSemiring.{u1} Q _inst_4)) (MulSemiringActionHomClass.toRingHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_1 P (CommSemiring.toSemiring.{u2} P _inst_2) _inst_3 Q (CommSemiring.toSemiring.{u1} Q _inst_4) _inst_5) M P Q _inst_1 (CommSemiring.toSemiring.{u2} P _inst_2) (CommSemiring.toSemiring.{u1} Q _inst_4) (MulSemiringAction.toDistribMulAction.{u3, u2} M P _inst_1 (CommSemiring.toSemiring.{u2} P _inst_2) _inst_3) (MulSemiringAction.toDistribMulAction.{u3, u1} M Q _inst_1 (CommSemiring.toSemiring.{u1} Q _inst_4) _inst_5) (MulSemiringActionHom.instMulSemiringActionHomClassMulSemiringActionHomToDistribMulActionToDistribMulAction.{u3, u2, u1} M _inst_1 P (CommSemiring.toSemiring.{u2} P _inst_2) _inst_3 Q (CommSemiring.toSemiring.{u1} Q _inst_4) _inst_5)) g))
Case conversion may be inaccurate. Consider using '#align mul_semiring_action_hom.coe_polynomial MulSemiringActionHom.coe_polynomialₓ'. -/
@[simp]
theorem coe_polynomial (g : P →+*[M] Q) : (g.Polynomial : P[X] → Q[X]) = map g :=
  rfl
#align mul_semiring_action_hom.coe_polynomial MulSemiringActionHom.coe_polynomial

end MulSemiringActionHom

