/-
Copyright (c) 2022 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov

! This file was ported from Lean 3 source module analysis.complex.unit_disc.basic
! leanprover-community/mathlib commit 0b7c740e25651db0ba63648fbae9f9d6f941e31b
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Analysis.Complex.Circle
import Mathbin.Analysis.NormedSpace.BallAction

/-!
# Poincar√© disc

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file we define `complex.unit_disc` to be the unit disc in the complex plane. We also
introduce some basic operations on this disc.
-/


open Set Function Metric

open BigOperators

noncomputable section

-- mathport name: exprconj'
local notation "conj'" => starRingEnd ‚ÑÇ

namespace Complex

/- ./././Mathport/Syntax/Translate/Command.lean:42:9: unsupported derive handler Œª Œ±,
has_coe[has_coe] Œ± expr‚ÑÇ() -/
#print Complex.UnitDisc /-
/-- Complex unit disc. -/
def UnitDisc : Type :=
  ball (0 : ‚ÑÇ) 1deriving CommSemigroup, HasDistribNeg,
  ¬´./././Mathport/Syntax/Translate/Command.lean:42:9: unsupported derive handler Œª Œ±,
  has_coe[has_coe] Œ± expr‚ÑÇ()¬ª, TopologicalSpace
#align complex.unit_disc Complex.UnitDisc
-/

-- mathport name: exprùîª
scoped[UnitDisc] notation "ùîª" => Complex.UnitDisc

namespace UnitDisc

/- warning: complex.unit_disc.coe_injective -> Complex.UnitDisc.coe_injective is a dubious translation:
lean 3 declaration is
  Function.Injective.{1, 1} Complex.UnitDisc Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Complex.UnitDisc Complex (HasLiftT.mk.{1, 1} Complex.UnitDisc Complex (CoeTC‚Çì.coe.{1, 1} Complex.UnitDisc Complex (coeBase.{1, 1} Complex.UnitDisc Complex Complex.UnitDisc.hasCoe))))
but is expected to have type
  Function.Injective.{1, 1} (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.ball.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))))) Complex (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.ball.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))))
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.coe_injective Complex.UnitDisc.coe_injective‚Çì'. -/
theorem coe_injective : Injective (coe : ùîª ‚Üí ‚ÑÇ) :=
  Subtype.coe_injective
#align complex.unit_disc.coe_injective Complex.UnitDisc.coe_injective

/- warning: complex.unit_disc.abs_lt_one -> Complex.UnitDisc.abs_lt_one is a dubious translation:
lean 3 declaration is
  forall (z : Complex.UnitDisc), LT.lt.{0} Real Real.hasLt (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.abs ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Complex.UnitDisc Complex (HasLiftT.mk.{1, 1} Complex.UnitDisc Complex (CoeTC‚Çì.coe.{1, 1} Complex.UnitDisc Complex (coeBase.{1, 1} Complex.UnitDisc Complex Complex.UnitDisc.hasCoe))) z)) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))
but is expected to have type
  forall (z : Complex.UnitDisc), LT.lt.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.ball.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) z)) Real.instLTReal (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real Complex.instSemiringComplex Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real Complex.instSemiringComplex Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real Complex.instSemiringComplex Real.orderedSemiring)) Complex.abs (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.ball.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) z)) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.ball.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) z)) 1 (One.toOfNat1.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.ball.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) z)) Real.instOneReal))
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.abs_lt_one Complex.UnitDisc.abs_lt_one‚Çì'. -/
theorem abs_lt_one (z : ùîª) : abs (z : ‚ÑÇ) < 1 :=
  mem_ball_zero_iff.1 z.2
#align complex.unit_disc.abs_lt_one Complex.UnitDisc.abs_lt_one

/- warning: complex.unit_disc.abs_ne_one -> Complex.UnitDisc.abs_ne_one is a dubious translation:
lean 3 declaration is
  forall (z : Complex.UnitDisc), Ne.{1} Real (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.abs ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Complex.UnitDisc Complex (HasLiftT.mk.{1, 1} Complex.UnitDisc Complex (CoeTC‚Çì.coe.{1, 1} Complex.UnitDisc Complex (coeBase.{1, 1} Complex.UnitDisc Complex Complex.UnitDisc.hasCoe))) z)) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))
but is expected to have type
  forall (z : Complex.UnitDisc), Ne.{1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.ball.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) z)) (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real Complex.instSemiringComplex Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real Complex.instSemiringComplex Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real Complex.instSemiringComplex Real.orderedSemiring)) Complex.abs (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.ball.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) z)) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.ball.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) z)) 1 (One.toOfNat1.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.ball.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) z)) Real.instOneReal))
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.abs_ne_one Complex.UnitDisc.abs_ne_one‚Çì'. -/
theorem abs_ne_one (z : ùîª) : abs (z : ‚ÑÇ) ‚â† 1 :=
  z.abs_lt_one.Ne
#align complex.unit_disc.abs_ne_one Complex.UnitDisc.abs_ne_one

/- warning: complex.unit_disc.norm_sq_lt_one -> Complex.UnitDisc.normSq_lt_one is a dubious translation:
lean 3 declaration is
  forall (z : Complex.UnitDisc), LT.lt.{0} Real Real.hasLt (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Complex.UnitDisc Complex (HasLiftT.mk.{1, 1} Complex.UnitDisc Complex (CoeTC‚Çì.coe.{1, 1} Complex.UnitDisc Complex (coeBase.{1, 1} Complex.UnitDisc Complex Complex.UnitDisc.hasCoe))) z)) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))
but is expected to have type
  forall (z : Complex.UnitDisc), LT.lt.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Complex) => Real) (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.ball.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) z)) Real.instLTReal (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)) (NonAssocSemiring.toMulZeroOneClass.{0} Real (Semiring.toNonAssocSemiring.{0} Real Real.semiring))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)) (NonAssocSemiring.toMulZeroOneClass.{0} Real (Semiring.toNonAssocSemiring.{0} Real Real.semiring))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (Semiring.toNonAssocSemiring.{0} Real Real.semiring)))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)) (NonAssocSemiring.toMulZeroOneClass.{0} Real (Semiring.toNonAssocSemiring.{0} Real Real.semiring))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (Semiring.toNonAssocSemiring.{0} Real Real.semiring))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)) (NonAssocSemiring.toMulZeroOneClass.{0} Real (Semiring.toNonAssocSemiring.{0} Real Real.semiring))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)) (NonAssocSemiring.toMulZeroOneClass.{0} Real (Semiring.toNonAssocSemiring.{0} Real Real.semiring)) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)) (NonAssocSemiring.toMulZeroOneClass.{0} Real (Semiring.toNonAssocSemiring.{0} Real Real.semiring)))))) Complex.normSq (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.ball.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) z)) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Complex) => Real) (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.ball.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) z)) 1 (One.toOfNat1.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Complex) => Real) (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.ball.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) z)) Real.instOneReal))
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.norm_sq_lt_one Complex.UnitDisc.normSq_lt_one‚Çì'. -/
theorem normSq_lt_one (z : ùîª) : normSq z < 1 :=
  @one_pow ‚Ñù _ 2 ‚ñ∏ (Real.sqrt_lt' one_pos).1 z.abs_lt_one
#align complex.unit_disc.norm_sq_lt_one Complex.UnitDisc.normSq_lt_one

/- warning: complex.unit_disc.coe_ne_one -> Complex.UnitDisc.coe_ne_one is a dubious translation:
lean 3 declaration is
  forall (z : Complex.UnitDisc), Ne.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Complex.UnitDisc Complex (HasLiftT.mk.{1, 1} Complex.UnitDisc Complex (CoeTC‚Çì.coe.{1, 1} Complex.UnitDisc Complex (coeBase.{1, 1} Complex.UnitDisc Complex Complex.UnitDisc.hasCoe))) z) (OfNat.ofNat.{0} Complex 1 (OfNat.mk.{0} Complex 1 (One.one.{0} Complex Complex.hasOne)))
but is expected to have type
  forall (z : Complex.UnitDisc), Ne.{1} Complex (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.ball.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) z) (OfNat.ofNat.{0} Complex 1 (One.toOfNat1.{0} Complex Complex.instOneComplex))
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.coe_ne_one Complex.UnitDisc.coe_ne_one‚Çì'. -/
theorem coe_ne_one (z : ùîª) : (z : ‚ÑÇ) ‚â† 1 :=
  ne_of_apply_ne abs <| (map_one abs).symm ‚ñ∏ z.abs_ne_one
#align complex.unit_disc.coe_ne_one Complex.UnitDisc.coe_ne_one

/- warning: complex.unit_disc.coe_ne_neg_one -> Complex.UnitDisc.coe_ne_neg_one is a dubious translation:
lean 3 declaration is
  forall (z : Complex.UnitDisc), Ne.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Complex.UnitDisc Complex (HasLiftT.mk.{1, 1} Complex.UnitDisc Complex (CoeTC‚Çì.coe.{1, 1} Complex.UnitDisc Complex (coeBase.{1, 1} Complex.UnitDisc Complex Complex.UnitDisc.hasCoe))) z) (Neg.neg.{0} Complex Complex.hasNeg (OfNat.ofNat.{0} Complex 1 (OfNat.mk.{0} Complex 1 (One.one.{0} Complex Complex.hasOne))))
but is expected to have type
  forall (z : Complex.UnitDisc), Ne.{1} Complex (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.ball.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) z) (Neg.neg.{0} Complex Complex.instNegComplex (OfNat.ofNat.{0} Complex 1 (One.toOfNat1.{0} Complex Complex.instOneComplex)))
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.coe_ne_neg_one Complex.UnitDisc.coe_ne_neg_one‚Çì'. -/
theorem coe_ne_neg_one (z : ùîª) : (z : ‚ÑÇ) ‚â† -1 :=
  ne_of_apply_ne abs <| by rw [abs.map_neg, map_one]; exact z.abs_ne_one
#align complex.unit_disc.coe_ne_neg_one Complex.UnitDisc.coe_ne_neg_one

/- warning: complex.unit_disc.one_add_coe_ne_zero -> Complex.UnitDisc.one_add_coe_ne_zero is a dubious translation:
lean 3 declaration is
  forall (z : Complex.UnitDisc), Ne.{1} Complex (HAdd.hAdd.{0, 0, 0} Complex Complex Complex (instHAdd.{0} Complex Complex.hasAdd) (OfNat.ofNat.{0} Complex 1 (OfNat.mk.{0} Complex 1 (One.one.{0} Complex Complex.hasOne))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Complex.UnitDisc Complex (HasLiftT.mk.{1, 1} Complex.UnitDisc Complex (CoeTC‚Çì.coe.{1, 1} Complex.UnitDisc Complex (coeBase.{1, 1} Complex.UnitDisc Complex Complex.UnitDisc.hasCoe))) z)) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero)))
but is expected to have type
  forall (z : Complex.UnitDisc), Ne.{1} Complex (HAdd.hAdd.{0, 0, 0} Complex Complex Complex (instHAdd.{0} Complex Complex.instAddComplex) (OfNat.ofNat.{0} Complex 1 (One.toOfNat1.{0} Complex Complex.instOneComplex)) (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.ball.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) z)) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex))
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.one_add_coe_ne_zero Complex.UnitDisc.one_add_coe_ne_zero‚Çì'. -/
theorem one_add_coe_ne_zero (z : ùîª) : (1 + z : ‚ÑÇ) ‚â† 0 :=
  mt neg_eq_iff_add_eq_zero.2 z.coe_ne_neg_one.symm
#align complex.unit_disc.one_add_coe_ne_zero Complex.UnitDisc.one_add_coe_ne_zero

/- warning: complex.unit_disc.coe_mul -> Complex.UnitDisc.coe_mul is a dubious translation:
lean 3 declaration is
  forall (z : Complex.UnitDisc) (w : Complex.UnitDisc), Eq.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Complex.UnitDisc Complex (HasLiftT.mk.{1, 1} Complex.UnitDisc Complex (CoeTC‚Çì.coe.{1, 1} Complex.UnitDisc Complex (coeBase.{1, 1} Complex.UnitDisc Complex Complex.UnitDisc.hasCoe))) (HMul.hMul.{0, 0, 0} Complex.UnitDisc Complex.UnitDisc Complex.UnitDisc (instHMul.{0} Complex.UnitDisc (Semigroup.toHasMul.{0} Complex.UnitDisc (CommSemigroup.toSemigroup.{0} Complex.UnitDisc Complex.UnitDisc.commSemigroup))) z w)) (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.hasMul) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Complex.UnitDisc Complex (HasLiftT.mk.{1, 1} Complex.UnitDisc Complex (CoeTC‚Çì.coe.{1, 1} Complex.UnitDisc Complex (coeBase.{1, 1} Complex.UnitDisc Complex Complex.UnitDisc.hasCoe))) z) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Complex.UnitDisc Complex (HasLiftT.mk.{1, 1} Complex.UnitDisc Complex (CoeTC‚Çì.coe.{1, 1} Complex.UnitDisc Complex (coeBase.{1, 1} Complex.UnitDisc Complex Complex.UnitDisc.hasCoe))) w))
but is expected to have type
  forall (z : Complex.UnitDisc) (w : Complex.UnitDisc), Eq.{1} Complex (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.ball.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (HMul.hMul.{0, 0, 0} Complex.UnitDisc Complex.UnitDisc Complex.UnitDisc (instHMul.{0} Complex.UnitDisc (Semigroup.toMul.{0} Complex.UnitDisc (CommSemigroup.toSemigroup.{0} Complex.UnitDisc Complex.instCommSemigroupUnitDisc))) z w)) (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.instMulComplex) (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.ball.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) z) (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.ball.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) w))
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.coe_mul Complex.UnitDisc.coe_mul‚Çì'. -/
@[simp, norm_cast]
theorem coe_mul (z w : ùîª) : ‚Üë(z * w) = (z * w : ‚ÑÇ) :=
  rfl
#align complex.unit_disc.coe_mul Complex.UnitDisc.coe_mul

/- warning: complex.unit_disc.mk -> Complex.UnitDisc.mk is a dubious translation:
lean 3 declaration is
  forall (z : Complex), (LT.lt.{0} Real Real.hasLt (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.abs z) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) -> Complex.UnitDisc
but is expected to have type
  forall (z : Complex), (LT.lt.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) Real.instLTReal (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real Complex.instSemiringComplex Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real Complex.instSemiringComplex Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real Complex.instSemiringComplex Real.orderedSemiring)) Complex.abs z) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) 1 (One.toOfNat1.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) Real.instOneReal))) -> Complex.UnitDisc
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.mk Complex.UnitDisc.mk‚Çì'. -/
/-- A constructor that assumes `abs z < 1` instead of `dist z 0 < 1` and returns an element 
of `ùîª` instead of `‚Ü•metric.ball (0 : ‚ÑÇ) 1`. -/
def mk (z : ‚ÑÇ) (hz : abs z < 1) : ùîª :=
  ‚ü®z, mem_ball_zero_iff.2 hz‚ü©
#align complex.unit_disc.mk Complex.UnitDisc.mk

/- warning: complex.unit_disc.coe_mk -> Complex.UnitDisc.coe_mk is a dubious translation:
lean 3 declaration is
  forall (z : Complex) (hz : LT.lt.{0} Real Real.hasLt (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.abs z) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))), Eq.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Complex.UnitDisc Complex (HasLiftT.mk.{1, 1} Complex.UnitDisc Complex (CoeTC‚Çì.coe.{1, 1} Complex.UnitDisc Complex (coeBase.{1, 1} Complex.UnitDisc Complex Complex.UnitDisc.hasCoe))) (Complex.UnitDisc.mk z hz)) z
but is expected to have type
  forall (z : Complex) (hz : LT.lt.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) Real.instLTReal (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real Complex.instSemiringComplex Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real Complex.instSemiringComplex Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real Complex.instSemiringComplex Real.orderedSemiring)) Complex.abs z) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) 1 (One.toOfNat1.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) Real.instOneReal))), Eq.{1} Complex (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.ball.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (Complex.UnitDisc.mk z hz)) z
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.coe_mk Complex.UnitDisc.coe_mk‚Çì'. -/
@[simp]
theorem coe_mk (z : ‚ÑÇ) (hz : abs z < 1) : (mk z hz : ‚ÑÇ) = z :=
  rfl
#align complex.unit_disc.coe_mk Complex.UnitDisc.coe_mk

/- warning: complex.unit_disc.mk_coe -> Complex.UnitDisc.mk_coe is a dubious translation:
lean 3 declaration is
  forall (z : Complex.UnitDisc) (hz : optParam.{0} (LT.lt.{0} Real Real.hasLt (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.abs ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Complex.UnitDisc Complex (HasLiftT.mk.{1, 1} Complex.UnitDisc Complex (CoeTC‚Çì.coe.{1, 1} Complex.UnitDisc Complex (coeBase.{1, 1} Complex.UnitDisc Complex Complex.UnitDisc.hasCoe))) z)) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) (Complex.UnitDisc.abs_lt_one z)), Eq.{1} Complex.UnitDisc (Complex.UnitDisc.mk ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Complex.UnitDisc Complex (HasLiftT.mk.{1, 1} Complex.UnitDisc Complex (CoeTC‚Çì.coe.{1, 1} Complex.UnitDisc Complex (coeBase.{1, 1} Complex.UnitDisc Complex Complex.UnitDisc.hasCoe))) z) hz) z
but is expected to have type
  forall (z : Complex.UnitDisc) (hz : optParam.{0} (LT.lt.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.ball.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) z)) Real.instLTReal (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real Complex.instSemiringComplex Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real Complex.instSemiringComplex Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real Complex.instSemiringComplex Real.orderedSemiring)) Complex.abs (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.ball.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) z)) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.ball.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) z)) 1 (One.toOfNat1.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.ball.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) z)) Real.instOneReal))) (Complex.UnitDisc.abs_lt_one z)), Eq.{1} Complex.UnitDisc (Complex.UnitDisc.mk (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.ball.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) z) hz) z
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.mk_coe Complex.UnitDisc.mk_coe‚Çì'. -/
@[simp]
theorem mk_coe (z : ùîª) (hz : abs (z : ‚ÑÇ) < 1 := z.abs_lt_one) : mk z hz = z :=
  Subtype.eta _ _
#align complex.unit_disc.mk_coe Complex.UnitDisc.mk_coe

/- warning: complex.unit_disc.mk_neg -> Complex.UnitDisc.mk_neg is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.mk_neg Complex.UnitDisc.mk_neg‚Çì'. -/
@[simp]
theorem mk_neg (z : ‚ÑÇ) (hz : abs (-z) < 1) : mk (-z) hz = -mk z (abs.map_neg z ‚ñ∏ hz) :=
  rfl
#align complex.unit_disc.mk_neg Complex.UnitDisc.mk_neg

instance : SemigroupWithZero ùîª :=
  {
    UnitDisc.commSemigroup with
    zero := mk 0 <| (map_zero _).trans_lt one_pos
    zero_mul := fun z => coe_injective <| MulZeroClass.zero_mul _
    mul_zero := fun z => coe_injective <| MulZeroClass.mul_zero _ }

/- warning: complex.unit_disc.coe_zero -> Complex.UnitDisc.coe_zero is a dubious translation:
lean 3 declaration is
  Eq.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Complex.UnitDisc Complex (HasLiftT.mk.{1, 1} Complex.UnitDisc Complex (CoeTC‚Çì.coe.{1, 1} Complex.UnitDisc Complex (coeBase.{1, 1} Complex.UnitDisc Complex Complex.UnitDisc.hasCoe))) (OfNat.ofNat.{0} Complex.UnitDisc 0 (OfNat.mk.{0} Complex.UnitDisc 0 (Zero.zero.{0} Complex.UnitDisc (MulZeroClass.toHasZero.{0} Complex.UnitDisc (SemigroupWithZero.toMulZeroClass.{0} Complex.UnitDisc Complex.UnitDisc.semigroupWithZero)))))) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero)))
but is expected to have type
  Eq.{1} Complex (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.ball.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (OfNat.ofNat.{0} Complex.UnitDisc 0 (Zero.toOfNat0.{0} Complex.UnitDisc (SemigroupWithZero.toZero.{0} Complex.UnitDisc Complex.UnitDisc.instSemigroupWithZeroUnitDisc)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex))
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.coe_zero Complex.UnitDisc.coe_zero‚Çì'. -/
@[simp]
theorem coe_zero : ((0 : ùîª) : ‚ÑÇ) = 0 :=
  rfl
#align complex.unit_disc.coe_zero Complex.UnitDisc.coe_zero

/- warning: complex.unit_disc.coe_eq_zero -> Complex.UnitDisc.coe_eq_zero is a dubious translation:
lean 3 declaration is
  forall {z : Complex.UnitDisc}, Iff (Eq.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Complex.UnitDisc Complex (HasLiftT.mk.{1, 1} Complex.UnitDisc Complex (CoeTC‚Çì.coe.{1, 1} Complex.UnitDisc Complex (coeBase.{1, 1} Complex.UnitDisc Complex Complex.UnitDisc.hasCoe))) z) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero)))) (Eq.{1} Complex.UnitDisc z (OfNat.ofNat.{0} Complex.UnitDisc 0 (OfNat.mk.{0} Complex.UnitDisc 0 (Zero.zero.{0} Complex.UnitDisc (MulZeroClass.toHasZero.{0} Complex.UnitDisc (SemigroupWithZero.toMulZeroClass.{0} Complex.UnitDisc Complex.UnitDisc.semigroupWithZero))))))
but is expected to have type
  forall {z : Complex.UnitDisc}, Iff (Eq.{1} Complex (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.ball.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) z) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex))) (Eq.{1} Complex.UnitDisc z (OfNat.ofNat.{0} Complex.UnitDisc 0 (Zero.toOfNat0.{0} Complex.UnitDisc (SemigroupWithZero.toZero.{0} Complex.UnitDisc Complex.UnitDisc.instSemigroupWithZeroUnitDisc))))
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.coe_eq_zero Complex.UnitDisc.coe_eq_zero‚Çì'. -/
@[simp]
theorem coe_eq_zero {z : ùîª} : (z : ‚ÑÇ) = 0 ‚Üî z = 0 :=
  coe_injective.eq_iff' coe_zero
#align complex.unit_disc.coe_eq_zero Complex.UnitDisc.coe_eq_zero

instance : Inhabited ùîª :=
  ‚ü®0‚ü©

/- warning: complex.unit_disc.circle_action -> Complex.UnitDisc.circleAction is a dubious translation:
lean 3 declaration is
  MulAction.{0, 0} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) Complex.UnitDisc (Submonoid.toMonoid.{0} Complex (Ring.toMonoid.{0} Complex Complex.ring) circle)
but is expected to have type
  MulAction.{0, 0} (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) Complex.UnitDisc (Submonoid.toMonoid.{0} Complex (MonoidWithZero.toMonoid.{0} Complex (Semiring.toMonoidWithZero.{0} Complex Complex.instSemiringComplex)) circle)
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.circle_action Complex.UnitDisc.circleAction‚Çì'. -/
instance circleAction : MulAction circle ùîª :=
  mulActionSphereBall
#align complex.unit_disc.circle_action Complex.UnitDisc.circleAction

/- warning: complex.unit_disc.is_scalar_tower_circle_circle -> Complex.UnitDisc.isScalarTower_circle_circle is a dubious translation:
lean 3 declaration is
  IsScalarTower.{0, 0, 0} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) Complex.UnitDisc (Mul.toSMul.{0} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) (Submonoid.mul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))) circle)) (MulAction.toHasSmul.{0, 0} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) Complex.UnitDisc (Submonoid.toMonoid.{0} Complex (Ring.toMonoid.{0} Complex Complex.ring) circle) Complex.UnitDisc.circleAction) (MulAction.toHasSmul.{0, 0} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) Complex.UnitDisc (Submonoid.toMonoid.{0} Complex (Ring.toMonoid.{0} Complex Complex.ring) circle) Complex.UnitDisc.circleAction)
but is expected to have type
  IsScalarTower.{0, 0, 0} (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) Complex.UnitDisc (MulAction.toSMul.{0, 0} (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) (Submonoid.toMonoid.{0} Complex (MonoidWithZero.toMonoid.{0} Complex (Semiring.toMonoidWithZero.{0} Complex Complex.instSemiringComplex)) circle) (Monoid.toMulAction.{0} (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) (Submonoid.toMonoid.{0} Complex (MonoidWithZero.toMonoid.{0} Complex (Semiring.toMonoidWithZero.{0} Complex Complex.instSemiringComplex)) circle))) (MulAction.toSMul.{0, 0} (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) Complex.UnitDisc (Submonoid.toMonoid.{0} Complex (MonoidWithZero.toMonoid.{0} Complex (Semiring.toMonoidWithZero.{0} Complex Complex.instSemiringComplex)) circle) Complex.UnitDisc.circleAction) (MulAction.toSMul.{0, 0} (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) Complex.UnitDisc (Submonoid.toMonoid.{0} Complex (MonoidWithZero.toMonoid.{0} Complex (Semiring.toMonoidWithZero.{0} Complex Complex.instSemiringComplex)) circle) Complex.UnitDisc.circleAction)
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.is_scalar_tower_circle_circle Complex.UnitDisc.isScalarTower_circle_circle‚Çì'. -/
instance isScalarTower_circle_circle : IsScalarTower circle circle ùîª :=
  isScalarTower_sphere_sphere_ball
#align complex.unit_disc.is_scalar_tower_circle_circle Complex.UnitDisc.isScalarTower_circle_circle

/- warning: complex.unit_disc.is_scalar_tower_circle -> Complex.UnitDisc.isScalarTower_circle is a dubious translation:
lean 3 declaration is
  IsScalarTower.{0, 0, 0} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) Complex.UnitDisc Complex.UnitDisc (MulAction.toHasSmul.{0, 0} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) Complex.UnitDisc (Submonoid.toMonoid.{0} Complex (Ring.toMonoid.{0} Complex Complex.ring) circle) Complex.UnitDisc.circleAction) (Mul.toSMul.{0} Complex.UnitDisc (MulZeroClass.toHasMul.{0} Complex.UnitDisc (SemigroupWithZero.toMulZeroClass.{0} Complex.UnitDisc Complex.UnitDisc.semigroupWithZero))) (MulAction.toHasSmul.{0, 0} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) Complex.UnitDisc (Submonoid.toMonoid.{0} Complex (Ring.toMonoid.{0} Complex Complex.ring) circle) Complex.UnitDisc.circleAction)
but is expected to have type
  IsScalarTower.{0, 0, 0} (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) Complex.UnitDisc Complex.UnitDisc (MulAction.toSMul.{0, 0} (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) Complex.UnitDisc (Submonoid.toMonoid.{0} Complex (MonoidWithZero.toMonoid.{0} Complex (Semiring.toMonoidWithZero.{0} Complex Complex.instSemiringComplex)) circle) Complex.UnitDisc.circleAction) (SMulZeroClass.toSMul.{0, 0} Complex.UnitDisc Complex.UnitDisc (SemigroupWithZero.toZero.{0} Complex.UnitDisc Complex.UnitDisc.instSemigroupWithZeroUnitDisc) (SMulWithZero.toSMulZeroClass.{0, 0} Complex.UnitDisc Complex.UnitDisc (SemigroupWithZero.toZero.{0} Complex.UnitDisc Complex.UnitDisc.instSemigroupWithZeroUnitDisc) (SemigroupWithZero.toZero.{0} Complex.UnitDisc Complex.UnitDisc.instSemigroupWithZeroUnitDisc) (MulZeroClass.toSMulWithZero.{0} Complex.UnitDisc (SemigroupWithZero.toMulZeroClass.{0} Complex.UnitDisc Complex.UnitDisc.instSemigroupWithZeroUnitDisc)))) (MulAction.toSMul.{0, 0} (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) Complex.UnitDisc (Submonoid.toMonoid.{0} Complex (MonoidWithZero.toMonoid.{0} Complex (Semiring.toMonoidWithZero.{0} Complex Complex.instSemiringComplex)) circle) Complex.UnitDisc.circleAction)
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.is_scalar_tower_circle Complex.UnitDisc.isScalarTower_circle‚Çì'. -/
instance isScalarTower_circle : IsScalarTower circle ùîª ùîª :=
  isScalarTower_sphere_ball_ball
#align complex.unit_disc.is_scalar_tower_circle Complex.UnitDisc.isScalarTower_circle

/- warning: complex.unit_disc.smul_comm_class_circle -> Complex.UnitDisc.sMulCommClass_circle is a dubious translation:
lean 3 declaration is
  SMulCommClass.{0, 0, 0} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) Complex.UnitDisc Complex.UnitDisc (MulAction.toHasSmul.{0, 0} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) Complex.UnitDisc (Submonoid.toMonoid.{0} Complex (Ring.toMonoid.{0} Complex Complex.ring) circle) Complex.UnitDisc.circleAction) (Mul.toSMul.{0} Complex.UnitDisc (MulZeroClass.toHasMul.{0} Complex.UnitDisc (SemigroupWithZero.toMulZeroClass.{0} Complex.UnitDisc Complex.UnitDisc.semigroupWithZero)))
but is expected to have type
  SMulCommClass.{0, 0, 0} (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) Complex.UnitDisc Complex.UnitDisc (MulAction.toSMul.{0, 0} (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) Complex.UnitDisc (Submonoid.toMonoid.{0} Complex (MonoidWithZero.toMonoid.{0} Complex (Semiring.toMonoidWithZero.{0} Complex Complex.instSemiringComplex)) circle) Complex.UnitDisc.circleAction) (SMulZeroClass.toSMul.{0, 0} Complex.UnitDisc Complex.UnitDisc (SemigroupWithZero.toZero.{0} Complex.UnitDisc Complex.UnitDisc.instSemigroupWithZeroUnitDisc) (SMulWithZero.toSMulZeroClass.{0, 0} Complex.UnitDisc Complex.UnitDisc (SemigroupWithZero.toZero.{0} Complex.UnitDisc Complex.UnitDisc.instSemigroupWithZeroUnitDisc) (SemigroupWithZero.toZero.{0} Complex.UnitDisc Complex.UnitDisc.instSemigroupWithZeroUnitDisc) (MulZeroClass.toSMulWithZero.{0} Complex.UnitDisc (SemigroupWithZero.toMulZeroClass.{0} Complex.UnitDisc Complex.UnitDisc.instSemigroupWithZeroUnitDisc))))
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.smul_comm_class_circle Complex.UnitDisc.sMulCommClass_circle‚Çì'. -/
instance sMulCommClass_circle : SMulCommClass circle ùîª ùîª :=
  sMulCommClass_sphere_ball_ball
#align complex.unit_disc.smul_comm_class_circle Complex.UnitDisc.sMulCommClass_circle

/- warning: complex.unit_disc.smul_comm_class_circle' -> Complex.UnitDisc.sMulCommClass_circle' is a dubious translation:
lean 3 declaration is
  SMulCommClass.{0, 0, 0} Complex.UnitDisc (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) Complex.UnitDisc (Mul.toSMul.{0} Complex.UnitDisc (MulZeroClass.toHasMul.{0} Complex.UnitDisc (SemigroupWithZero.toMulZeroClass.{0} Complex.UnitDisc Complex.UnitDisc.semigroupWithZero))) (MulAction.toHasSmul.{0, 0} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) Complex.UnitDisc (Submonoid.toMonoid.{0} Complex (Ring.toMonoid.{0} Complex Complex.ring) circle) Complex.UnitDisc.circleAction)
but is expected to have type
  SMulCommClass.{0, 0, 0} Complex.UnitDisc (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) Complex.UnitDisc (SMulZeroClass.toSMul.{0, 0} Complex.UnitDisc Complex.UnitDisc (SemigroupWithZero.toZero.{0} Complex.UnitDisc Complex.UnitDisc.instSemigroupWithZeroUnitDisc) (SMulWithZero.toSMulZeroClass.{0, 0} Complex.UnitDisc Complex.UnitDisc (SemigroupWithZero.toZero.{0} Complex.UnitDisc Complex.UnitDisc.instSemigroupWithZeroUnitDisc) (SemigroupWithZero.toZero.{0} Complex.UnitDisc Complex.UnitDisc.instSemigroupWithZeroUnitDisc) (MulZeroClass.toSMulWithZero.{0} Complex.UnitDisc (SemigroupWithZero.toMulZeroClass.{0} Complex.UnitDisc Complex.UnitDisc.instSemigroupWithZeroUnitDisc)))) (MulAction.toSMul.{0, 0} (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) Complex.UnitDisc (Submonoid.toMonoid.{0} Complex (MonoidWithZero.toMonoid.{0} Complex (Semiring.toMonoidWithZero.{0} Complex Complex.instSemiringComplex)) circle) Complex.UnitDisc.circleAction)
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.smul_comm_class_circle' Complex.UnitDisc.sMulCommClass_circle'‚Çì'. -/
instance sMulCommClass_circle' : SMulCommClass ùîª circle ùîª :=
  SMulCommClass.symm _ _ _
#align complex.unit_disc.smul_comm_class_circle' Complex.UnitDisc.sMulCommClass_circle'

/- warning: complex.unit_disc.coe_smul_circle -> Complex.UnitDisc.coe_smul_circle is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.coe_smul_circle Complex.UnitDisc.coe_smul_circle‚Çì'. -/
@[simp, norm_cast]
theorem coe_smul_circle (z : circle) (w : ùîª) : ‚Üë(z ‚Ä¢ w) = (z * w : ‚ÑÇ) :=
  rfl
#align complex.unit_disc.coe_smul_circle Complex.UnitDisc.coe_smul_circle

/- warning: complex.unit_disc.closed_ball_action -> Complex.UnitDisc.closedBallAction is a dubious translation:
lean 3 declaration is
  MulAction.{0, 0} (coeSort.{1, 2} (Set.{0} Complex) Type (Set.hasCoeToSort.{0} Complex) (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField)))) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) Complex.UnitDisc (Metric.closedBall.monoid.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField))) Complex.UnitDisc.closedBallAction._proof_1)
but is expected to have type
  MulAction.{0, 0} (Set.Elem.{0} Complex (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) Complex.UnitDisc (Metric.unitClosedBall.monoid.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex))) (NormedDivisionRing.to_normOneClass.{0} Complex (NormedField.toNormedDivisionRing.{0} Complex Complex.instNormedFieldComplex)))
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.closed_ball_action Complex.UnitDisc.closedBallAction‚Çì'. -/
instance closedBallAction : MulAction (closedBall (0 : ‚ÑÇ) 1) ùîª :=
  mulActionClosedBallBall
#align complex.unit_disc.closed_ball_action Complex.UnitDisc.closedBallAction

/- warning: complex.unit_disc.is_scalar_tower_closed_ball_closed_ball -> Complex.UnitDisc.isScalarTower_closedBall_closedBall is a dubious translation:
lean 3 declaration is
  IsScalarTower.{0, 0, 0} (coeSort.{1, 2} (Set.{0} Complex) Type (Set.hasCoeToSort.{0} Complex) (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField)))) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) (coeSort.{1, 2} (Set.{0} Complex) Type (Set.hasCoeToSort.{0} Complex) (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField)))) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) Complex.UnitDisc (Mul.toSMul.{0} (coeSort.{1, 2} (Set.{0} Complex) Type (Set.hasCoeToSort.{0} Complex) (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField)))) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) (MulOneClass.toHasMul.{0} (coeSort.{1, 2} (Set.{0} Complex) Type (Set.hasCoeToSort.{0} Complex) (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField)))) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) (Monoid.toMulOneClass.{0} (coeSort.{1, 2} (Set.{0} Complex) Type (Set.hasCoeToSort.{0} Complex) (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField)))) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) (Metric.closedBall.monoid.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField))) (NormedDivisionRing.to_normOneClass.{0} Complex (NormedField.toNormedDivisionRing.{0} Complex Complex.normedField)))))) (MulAction.toHasSmul.{0, 0} (coeSort.{1, 2} (Set.{0} Complex) Type (Set.hasCoeToSort.{0} Complex) (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField)))) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) Complex.UnitDisc (Metric.closedBall.monoid.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField))) Complex.UnitDisc.closedBallAction._proof_1) Complex.UnitDisc.closedBallAction) (MulAction.toHasSmul.{0, 0} (coeSort.{1, 2} (Set.{0} Complex) Type (Set.hasCoeToSort.{0} Complex) (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField)))) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) Complex.UnitDisc (Metric.closedBall.monoid.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField))) Complex.UnitDisc.closedBallAction._proof_1) Complex.UnitDisc.closedBallAction)
but is expected to have type
  IsScalarTower.{0, 0, 0} (Set.Elem.{0} Complex (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (Set.Elem.{0} Complex (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) Complex.UnitDisc (MulAction.toSMul.{0, 0} (Set.Elem.{0} Complex (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (Set.Elem.{0} Complex (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (Metric.unitClosedBall.monoid.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex))) (NormedDivisionRing.to_normOneClass.{0} Complex (NormedField.toNormedDivisionRing.{0} Complex Complex.instNormedFieldComplex))) (mulActionClosedBallClosedBall.{0, 0} Complex Complex Complex.instNormedFieldComplex (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{0} Complex (NonUnitalNormedRing.toNonUnitalSeminormedRing.{0} Complex (NormedRing.toNonUnitalNormedRing.{0} Complex (NormedCommRing.toNormedRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex))))) (NormedField.toNormedSpace.{0} Complex Complex.instNormedFieldComplex) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (MulAction.toSMul.{0, 0} (Set.Elem.{0} Complex (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) Complex.UnitDisc (Metric.unitClosedBall.monoid.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex))) (NormedDivisionRing.to_normOneClass.{0} Complex (NormedField.toNormedDivisionRing.{0} Complex Complex.instNormedFieldComplex))) Complex.UnitDisc.closedBallAction) (MulAction.toSMul.{0, 0} (Set.Elem.{0} Complex (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) Complex.UnitDisc (Metric.unitClosedBall.monoid.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex))) (NormedDivisionRing.to_normOneClass.{0} Complex (NormedField.toNormedDivisionRing.{0} Complex Complex.instNormedFieldComplex))) Complex.UnitDisc.closedBallAction)
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.is_scalar_tower_closed_ball_closed_ball Complex.UnitDisc.isScalarTower_closedBall_closedBall‚Çì'. -/
instance isScalarTower_closedBall_closedBall :
    IsScalarTower (closedBall (0 : ‚ÑÇ) 1) (closedBall (0 : ‚ÑÇ) 1) ùîª :=
  isScalarTower_closedBall_closedBall_ball
#align complex.unit_disc.is_scalar_tower_closed_ball_closed_ball Complex.UnitDisc.isScalarTower_closedBall_closedBall

/- warning: complex.unit_disc.is_scalar_tower_closed_ball -> Complex.UnitDisc.isScalarTower_closedBall is a dubious translation:
lean 3 declaration is
  IsScalarTower.{0, 0, 0} (coeSort.{1, 2} (Set.{0} Complex) Type (Set.hasCoeToSort.{0} Complex) (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField)))) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) Complex.UnitDisc Complex.UnitDisc (MulAction.toHasSmul.{0, 0} (coeSort.{1, 2} (Set.{0} Complex) Type (Set.hasCoeToSort.{0} Complex) (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField)))) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) Complex.UnitDisc (Metric.closedBall.monoid.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField))) Complex.UnitDisc.closedBallAction._proof_1) Complex.UnitDisc.closedBallAction) (Mul.toSMul.{0} Complex.UnitDisc (MulZeroClass.toHasMul.{0} Complex.UnitDisc (SemigroupWithZero.toMulZeroClass.{0} Complex.UnitDisc Complex.UnitDisc.semigroupWithZero))) (MulAction.toHasSmul.{0, 0} (coeSort.{1, 2} (Set.{0} Complex) Type (Set.hasCoeToSort.{0} Complex) (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField)))) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) Complex.UnitDisc (Metric.closedBall.monoid.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField))) Complex.UnitDisc.closedBallAction._proof_1) Complex.UnitDisc.closedBallAction)
but is expected to have type
  IsScalarTower.{0, 0, 0} (Set.Elem.{0} Complex (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) Complex.UnitDisc Complex.UnitDisc (MulAction.toSMul.{0, 0} (Set.Elem.{0} Complex (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) Complex.UnitDisc (Metric.unitClosedBall.monoid.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex))) (NormedDivisionRing.to_normOneClass.{0} Complex (NormedField.toNormedDivisionRing.{0} Complex Complex.instNormedFieldComplex))) Complex.UnitDisc.closedBallAction) (SMulZeroClass.toSMul.{0, 0} Complex.UnitDisc Complex.UnitDisc (SemigroupWithZero.toZero.{0} Complex.UnitDisc Complex.UnitDisc.instSemigroupWithZeroUnitDisc) (SMulWithZero.toSMulZeroClass.{0, 0} Complex.UnitDisc Complex.UnitDisc (SemigroupWithZero.toZero.{0} Complex.UnitDisc Complex.UnitDisc.instSemigroupWithZeroUnitDisc) (SemigroupWithZero.toZero.{0} Complex.UnitDisc Complex.UnitDisc.instSemigroupWithZeroUnitDisc) (MulZeroClass.toSMulWithZero.{0} Complex.UnitDisc (SemigroupWithZero.toMulZeroClass.{0} Complex.UnitDisc Complex.UnitDisc.instSemigroupWithZeroUnitDisc)))) (MulAction.toSMul.{0, 0} (Set.Elem.{0} Complex (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) Complex.UnitDisc (Metric.unitClosedBall.monoid.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex))) (NormedDivisionRing.to_normOneClass.{0} Complex (NormedField.toNormedDivisionRing.{0} Complex Complex.instNormedFieldComplex))) Complex.UnitDisc.closedBallAction)
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.is_scalar_tower_closed_ball Complex.UnitDisc.isScalarTower_closedBall‚Çì'. -/
instance isScalarTower_closedBall : IsScalarTower (closedBall (0 : ‚ÑÇ) 1) ùîª ùîª :=
  isScalarTower_closedBall_ball_ball
#align complex.unit_disc.is_scalar_tower_closed_ball Complex.UnitDisc.isScalarTower_closedBall

/- warning: complex.unit_disc.smul_comm_class_closed_ball -> Complex.UnitDisc.sMulCommClass_closedBall is a dubious translation:
lean 3 declaration is
  SMulCommClass.{0, 0, 0} (coeSort.{1, 2} (Set.{0} Complex) Type (Set.hasCoeToSort.{0} Complex) (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField)))) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) Complex.UnitDisc Complex.UnitDisc (MulAction.toHasSmul.{0, 0} (coeSort.{1, 2} (Set.{0} Complex) Type (Set.hasCoeToSort.{0} Complex) (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField)))) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) Complex.UnitDisc (Metric.closedBall.monoid.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField))) Complex.UnitDisc.closedBallAction._proof_1) Complex.UnitDisc.closedBallAction) (Mul.toSMul.{0} Complex.UnitDisc (MulZeroClass.toHasMul.{0} Complex.UnitDisc (SemigroupWithZero.toMulZeroClass.{0} Complex.UnitDisc Complex.UnitDisc.semigroupWithZero)))
but is expected to have type
  SMulCommClass.{0, 0, 0} (Set.Elem.{0} Complex (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) Complex.UnitDisc Complex.UnitDisc (MulAction.toSMul.{0, 0} (Set.Elem.{0} Complex (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) Complex.UnitDisc (Metric.unitClosedBall.monoid.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex))) (NormedDivisionRing.to_normOneClass.{0} Complex (NormedField.toNormedDivisionRing.{0} Complex Complex.instNormedFieldComplex))) Complex.UnitDisc.closedBallAction) (SMulZeroClass.toSMul.{0, 0} Complex.UnitDisc Complex.UnitDisc (SemigroupWithZero.toZero.{0} Complex.UnitDisc Complex.UnitDisc.instSemigroupWithZeroUnitDisc) (SMulWithZero.toSMulZeroClass.{0, 0} Complex.UnitDisc Complex.UnitDisc (SemigroupWithZero.toZero.{0} Complex.UnitDisc Complex.UnitDisc.instSemigroupWithZeroUnitDisc) (SemigroupWithZero.toZero.{0} Complex.UnitDisc Complex.UnitDisc.instSemigroupWithZeroUnitDisc) (MulZeroClass.toSMulWithZero.{0} Complex.UnitDisc (SemigroupWithZero.toMulZeroClass.{0} Complex.UnitDisc Complex.UnitDisc.instSemigroupWithZeroUnitDisc))))
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.smul_comm_class_closed_ball Complex.UnitDisc.sMulCommClass_closedBall‚Çì'. -/
instance sMulCommClass_closedBall : SMulCommClass (closedBall (0 : ‚ÑÇ) 1) ùîª ùîª :=
  ‚ü®fun a b c => Subtype.ext <| mul_left_comm _ _ _‚ü©
#align complex.unit_disc.smul_comm_class_closed_ball Complex.UnitDisc.sMulCommClass_closedBall

/- warning: complex.unit_disc.smul_comm_class_closed_ball' -> Complex.UnitDisc.sMulCommClass_closed_ball' is a dubious translation:
lean 3 declaration is
  SMulCommClass.{0, 0, 0} Complex.UnitDisc (coeSort.{1, 2} (Set.{0} Complex) Type (Set.hasCoeToSort.{0} Complex) (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField)))) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) Complex.UnitDisc (Mul.toSMul.{0} Complex.UnitDisc (MulZeroClass.toHasMul.{0} Complex.UnitDisc (SemigroupWithZero.toMulZeroClass.{0} Complex.UnitDisc Complex.UnitDisc.semigroupWithZero))) (MulAction.toHasSmul.{0, 0} (coeSort.{1, 2} (Set.{0} Complex) Type (Set.hasCoeToSort.{0} Complex) (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField)))) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) Complex.UnitDisc (Metric.closedBall.monoid.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField))) Complex.UnitDisc.closedBallAction._proof_1) Complex.UnitDisc.closedBallAction)
but is expected to have type
  SMulCommClass.{0, 0, 0} Complex.UnitDisc (Set.Elem.{0} Complex (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) Complex.UnitDisc (SMulZeroClass.toSMul.{0, 0} Complex.UnitDisc Complex.UnitDisc (SemigroupWithZero.toZero.{0} Complex.UnitDisc Complex.UnitDisc.instSemigroupWithZeroUnitDisc) (SMulWithZero.toSMulZeroClass.{0, 0} Complex.UnitDisc Complex.UnitDisc (SemigroupWithZero.toZero.{0} Complex.UnitDisc Complex.UnitDisc.instSemigroupWithZeroUnitDisc) (SemigroupWithZero.toZero.{0} Complex.UnitDisc Complex.UnitDisc.instSemigroupWithZeroUnitDisc) (MulZeroClass.toSMulWithZero.{0} Complex.UnitDisc (SemigroupWithZero.toMulZeroClass.{0} Complex.UnitDisc Complex.UnitDisc.instSemigroupWithZeroUnitDisc)))) (MulAction.toSMul.{0, 0} (Set.Elem.{0} Complex (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) Complex.UnitDisc (Metric.unitClosedBall.monoid.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex))) (NormedDivisionRing.to_normOneClass.{0} Complex (NormedField.toNormedDivisionRing.{0} Complex Complex.instNormedFieldComplex))) Complex.UnitDisc.closedBallAction)
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.smul_comm_class_closed_ball' Complex.UnitDisc.sMulCommClass_closed_ball'‚Çì'. -/
instance sMulCommClass_closed_ball' : SMulCommClass ùîª (closedBall (0 : ‚ÑÇ) 1) ùîª :=
  SMulCommClass.symm _ _ _
#align complex.unit_disc.smul_comm_class_closed_ball' Complex.UnitDisc.sMulCommClass_closed_ball'

/- warning: complex.unit_disc.smul_comm_class_circle_closed_ball -> Complex.UnitDisc.sMulCommClass_circle_closedBall is a dubious translation:
lean 3 declaration is
  SMulCommClass.{0, 0, 0} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) (coeSort.{1, 2} (Set.{0} Complex) Type (Set.hasCoeToSort.{0} Complex) (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField)))) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) Complex.UnitDisc (MulAction.toHasSmul.{0, 0} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) Complex.UnitDisc (Submonoid.toMonoid.{0} Complex (Ring.toMonoid.{0} Complex Complex.ring) circle) Complex.UnitDisc.circleAction) (MulAction.toHasSmul.{0, 0} (coeSort.{1, 2} (Set.{0} Complex) Type (Set.hasCoeToSort.{0} Complex) (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField)))) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) Complex.UnitDisc (Metric.closedBall.monoid.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField))) Complex.UnitDisc.closedBallAction._proof_1) Complex.UnitDisc.closedBallAction)
but is expected to have type
  SMulCommClass.{0, 0, 0} (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) (Set.Elem.{0} Complex (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) Complex.UnitDisc (MulAction.toSMul.{0, 0} (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) Complex.UnitDisc (Submonoid.toMonoid.{0} Complex (MonoidWithZero.toMonoid.{0} Complex (Semiring.toMonoidWithZero.{0} Complex Complex.instSemiringComplex)) circle) Complex.UnitDisc.circleAction) (MulAction.toSMul.{0, 0} (Set.Elem.{0} Complex (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) Complex.UnitDisc (Metric.unitClosedBall.monoid.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex))) (NormedDivisionRing.to_normOneClass.{0} Complex (NormedField.toNormedDivisionRing.{0} Complex Complex.instNormedFieldComplex))) Complex.UnitDisc.closedBallAction)
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.smul_comm_class_circle_closed_ball Complex.UnitDisc.sMulCommClass_circle_closedBall‚Çì'. -/
instance sMulCommClass_circle_closedBall : SMulCommClass circle (closedBall (0 : ‚ÑÇ) 1) ùîª :=
  sMulCommClass_sphere_closedBall_ball
#align complex.unit_disc.smul_comm_class_circle_closed_ball Complex.UnitDisc.sMulCommClass_circle_closedBall

/- warning: complex.unit_disc.smul_comm_class_closed_ball_circle -> Complex.UnitDisc.sMulCommClass_closedBall_circle is a dubious translation:
lean 3 declaration is
  SMulCommClass.{0, 0, 0} (coeSort.{1, 2} (Set.{0} Complex) Type (Set.hasCoeToSort.{0} Complex) (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField)))) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) Complex.UnitDisc (MulAction.toHasSmul.{0, 0} (coeSort.{1, 2} (Set.{0} Complex) Type (Set.hasCoeToSort.{0} Complex) (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField)))) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) Complex.UnitDisc (Metric.closedBall.monoid.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField))) Complex.UnitDisc.closedBallAction._proof_1) Complex.UnitDisc.closedBallAction) (MulAction.toHasSmul.{0, 0} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) Complex.UnitDisc (Submonoid.toMonoid.{0} Complex (Ring.toMonoid.{0} Complex Complex.ring) circle) Complex.UnitDisc.circleAction)
but is expected to have type
  SMulCommClass.{0, 0, 0} (Set.Elem.{0} Complex (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) Complex.UnitDisc (MulAction.toSMul.{0, 0} (Set.Elem.{0} Complex (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) Complex.UnitDisc (Metric.unitClosedBall.monoid.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex))) (NormedDivisionRing.to_normOneClass.{0} Complex (NormedField.toNormedDivisionRing.{0} Complex Complex.instNormedFieldComplex))) Complex.UnitDisc.closedBallAction) (MulAction.toSMul.{0, 0} (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) Complex.UnitDisc (Submonoid.toMonoid.{0} Complex (MonoidWithZero.toMonoid.{0} Complex (Semiring.toMonoidWithZero.{0} Complex Complex.instSemiringComplex)) circle) Complex.UnitDisc.circleAction)
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.smul_comm_class_closed_ball_circle Complex.UnitDisc.sMulCommClass_closedBall_circle‚Çì'. -/
instance sMulCommClass_closedBall_circle : SMulCommClass (closedBall (0 : ‚ÑÇ) 1) circle ùîª :=
  SMulCommClass.symm _ _ _
#align complex.unit_disc.smul_comm_class_closed_ball_circle Complex.UnitDisc.sMulCommClass_closedBall_circle

/- warning: complex.unit_disc.coe_smul_closed_ball -> Complex.UnitDisc.coe_smul_closedBall is a dubious translation:
lean 3 declaration is
  forall (z : coeSort.{1, 2} (Set.{0} Complex) Type (Set.hasCoeToSort.{0} Complex) (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField)))) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) (w : Complex.UnitDisc), Eq.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Complex.UnitDisc Complex (HasLiftT.mk.{1, 1} Complex.UnitDisc Complex (CoeTC‚Çì.coe.{1, 1} Complex.UnitDisc Complex (coeBase.{1, 1} Complex.UnitDisc Complex Complex.UnitDisc.hasCoe))) (SMul.smul.{0, 0} (coeSort.{1, 2} (Set.{0} Complex) Type (Set.hasCoeToSort.{0} Complex) (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField)))) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) Complex.UnitDisc (MulAction.toHasSmul.{0, 0} (coeSort.{1, 2} (Set.{0} Complex) Type (Set.hasCoeToSort.{0} Complex) (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField)))) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) Complex.UnitDisc (Metric.closedBall.monoid.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField))) Complex.UnitDisc.closedBallAction._proof_1) Complex.UnitDisc.closedBallAction) z w)) (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.hasMul) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Complex) Type (Set.hasCoeToSort.{0} Complex) (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField)))) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) Complex (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Complex) Type (Set.hasCoeToSort.{0} Complex) (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField)))) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) Complex (CoeTC‚Çì.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Complex) Type (Set.hasCoeToSort.{0} Complex) (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField)))) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) Complex (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Complex) Type (Set.hasCoeToSort.{0} Complex) (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField)))) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) Complex (coeSubtype.{1} Complex (fun (x : Complex) => Membership.Mem.{0, 0} Complex (Set.{0} Complex) (Set.hasMem.{0} Complex) x (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSemiNormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.normedField)))) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))))))) z) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Complex.UnitDisc Complex (HasLiftT.mk.{1, 1} Complex.UnitDisc Complex (CoeTC‚Çì.coe.{1, 1} Complex.UnitDisc Complex (coeBase.{1, 1} Complex.UnitDisc Complex Complex.UnitDisc.hasCoe))) w))
but is expected to have type
  forall (z : Set.Elem.{0} Complex (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (w : Complex.UnitDisc), Eq.{1} Complex (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.ball.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (HSMul.hSMul.{0, 0, 0} (Set.Elem.{0} Complex (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) Complex.UnitDisc Complex.UnitDisc (instHSMul.{0, 0} (Set.Elem.{0} Complex (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) Complex.UnitDisc (MulAction.toSMul.{0, 0} (Set.Elem.{0} Complex (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) Complex.UnitDisc (Metric.unitClosedBall.monoid.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex))) (NormedDivisionRing.to_normOneClass.{0} Complex (NormedField.toNormedDivisionRing.{0} Complex Complex.instNormedFieldComplex))) Complex.UnitDisc.closedBallAction)) z w)) (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.instMulComplex) (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.closedBall.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) z) (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.ball.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) w))
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.coe_smul_closed_ball Complex.UnitDisc.coe_smul_closedBall‚Çì'. -/
@[simp, norm_cast]
theorem coe_smul_closedBall (z : closedBall (0 : ‚ÑÇ) 1) (w : ùîª) : ‚Üë(z ‚Ä¢ w) = (z * w : ‚ÑÇ) :=
  rfl
#align complex.unit_disc.coe_smul_closed_ball Complex.UnitDisc.coe_smul_closedBall

#print Complex.UnitDisc.re /-
/-- Real part of a point of the unit disc. -/
def re (z : ùîª) : ‚Ñù :=
  re z
#align complex.unit_disc.re Complex.UnitDisc.re
-/

#print Complex.UnitDisc.im /-
/-- Imaginary part of a point of the unit disc. -/
def im (z : ùîª) : ‚Ñù :=
  im z
#align complex.unit_disc.im Complex.UnitDisc.im
-/

/- warning: complex.unit_disc.re_coe -> Complex.UnitDisc.re_coe is a dubious translation:
lean 3 declaration is
  forall (z : Complex.UnitDisc), Eq.{1} Real (Complex.re ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Complex.UnitDisc Complex (HasLiftT.mk.{1, 1} Complex.UnitDisc Complex (CoeTC‚Çì.coe.{1, 1} Complex.UnitDisc Complex (coeBase.{1, 1} Complex.UnitDisc Complex Complex.UnitDisc.hasCoe))) z)) (Complex.UnitDisc.re z)
but is expected to have type
  forall (z : Complex.UnitDisc), Eq.{1} Real (Complex.re (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.ball.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) z)) (Complex.UnitDisc.re z)
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.re_coe Complex.UnitDisc.re_coe‚Çì'. -/
@[simp, norm_cast]
theorem re_coe (z : ùîª) : (z : ‚ÑÇ).re = z.re :=
  rfl
#align complex.unit_disc.re_coe Complex.UnitDisc.re_coe

/- warning: complex.unit_disc.im_coe -> Complex.UnitDisc.im_coe is a dubious translation:
lean 3 declaration is
  forall (z : Complex.UnitDisc), Eq.{1} Real (Complex.im ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Complex.UnitDisc Complex (HasLiftT.mk.{1, 1} Complex.UnitDisc Complex (CoeTC‚Çì.coe.{1, 1} Complex.UnitDisc Complex (coeBase.{1, 1} Complex.UnitDisc Complex Complex.UnitDisc.hasCoe))) z)) (Complex.UnitDisc.im z)
but is expected to have type
  forall (z : Complex.UnitDisc), Eq.{1} Real (Complex.im (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.ball.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) z)) (Complex.UnitDisc.im z)
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.im_coe Complex.UnitDisc.im_coe‚Çì'. -/
@[simp, norm_cast]
theorem im_coe (z : ùîª) : (z : ‚ÑÇ).im = z.im :=
  rfl
#align complex.unit_disc.im_coe Complex.UnitDisc.im_coe

/- warning: complex.unit_disc.re_neg -> Complex.UnitDisc.re_neg is a dubious translation:
lean 3 declaration is
  forall (z : Complex.UnitDisc), Eq.{1} Real (Complex.UnitDisc.re (Neg.neg.{0} Complex.UnitDisc (NegZeroClass.toHasNeg.{0} Complex.UnitDisc (MulZeroClass.negZeroClass.{0} Complex.UnitDisc (SemigroupWithZero.toMulZeroClass.{0} Complex.UnitDisc Complex.UnitDisc.semigroupWithZero) Complex.UnitDisc.hasDistribNeg)) z)) (Neg.neg.{0} Real Real.hasNeg (Complex.UnitDisc.re z))
but is expected to have type
  forall (z : Complex.UnitDisc), Eq.{1} Real (Complex.UnitDisc.re (Neg.neg.{0} Complex.UnitDisc (NegZeroClass.toNeg.{0} Complex.UnitDisc (MulZeroClass.negZeroClass.{0} Complex.UnitDisc (SemigroupWithZero.toMulZeroClass.{0} Complex.UnitDisc Complex.UnitDisc.instSemigroupWithZeroUnitDisc) Complex.instHasDistribNegUnitDiscToMulToSemigroupInstCommSemigroupUnitDisc)) z)) (Neg.neg.{0} Real Real.instNegReal (Complex.UnitDisc.re z))
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.re_neg Complex.UnitDisc.re_neg‚Çì'. -/
@[simp]
theorem re_neg (z : ùîª) : (-z).re = -z.re :=
  rfl
#align complex.unit_disc.re_neg Complex.UnitDisc.re_neg

/- warning: complex.unit_disc.im_neg -> Complex.UnitDisc.im_neg is a dubious translation:
lean 3 declaration is
  forall (z : Complex.UnitDisc), Eq.{1} Real (Complex.UnitDisc.im (Neg.neg.{0} Complex.UnitDisc (NegZeroClass.toHasNeg.{0} Complex.UnitDisc (MulZeroClass.negZeroClass.{0} Complex.UnitDisc (SemigroupWithZero.toMulZeroClass.{0} Complex.UnitDisc Complex.UnitDisc.semigroupWithZero) Complex.UnitDisc.hasDistribNeg)) z)) (Neg.neg.{0} Real Real.hasNeg (Complex.UnitDisc.im z))
but is expected to have type
  forall (z : Complex.UnitDisc), Eq.{1} Real (Complex.UnitDisc.im (Neg.neg.{0} Complex.UnitDisc (NegZeroClass.toNeg.{0} Complex.UnitDisc (MulZeroClass.negZeroClass.{0} Complex.UnitDisc (SemigroupWithZero.toMulZeroClass.{0} Complex.UnitDisc Complex.UnitDisc.instSemigroupWithZeroUnitDisc) Complex.instHasDistribNegUnitDiscToMulToSemigroupInstCommSemigroupUnitDisc)) z)) (Neg.neg.{0} Real Real.instNegReal (Complex.UnitDisc.im z))
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.im_neg Complex.UnitDisc.im_neg‚Çì'. -/
@[simp]
theorem im_neg (z : ùîª) : (-z).im = -z.im :=
  rfl
#align complex.unit_disc.im_neg Complex.UnitDisc.im_neg

#print Complex.UnitDisc.conj /-
/-- Conjugate point of the unit disc. -/
def conj (z : ùîª) : ùîª :=
  mk (conj' ‚Üëz) <| (abs_conj z).symm ‚ñ∏ z.abs_lt_one
#align complex.unit_disc.conj Complex.UnitDisc.conj
-/

/- warning: complex.unit_disc.coe_conj -> Complex.UnitDisc.coe_conj is a dubious translation:
lean 3 declaration is
  forall (z : Complex.UnitDisc), Eq.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Complex.UnitDisc Complex (HasLiftT.mk.{1, 1} Complex.UnitDisc Complex (CoeTC‚Çì.coe.{1, 1} Complex.UnitDisc Complex (coeBase.{1, 1} Complex.UnitDisc Complex Complex.UnitDisc.hasCoe))) (Complex.UnitDisc.conj z)) (coeFn.{1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (fun (_x : RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) => Complex -> Complex) (RingHom.hasCoeToFun.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (starRingEnd.{0} Complex Complex.commSemiring Complex.starRing) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Complex.UnitDisc Complex (HasLiftT.mk.{1, 1} Complex.UnitDisc Complex (CoeTC‚Çì.coe.{1, 1} Complex.UnitDisc Complex (coeBase.{1, 1} Complex.UnitDisc Complex Complex.UnitDisc.hasCoe))) z))
but is expected to have type
  forall (z : Complex.UnitDisc), Eq.{1} Complex (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.ball.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (Complex.UnitDisc.conj z)) (FunLike.coe.{1, 1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Complex) => Complex) _x) (MulHomClass.toFunLike.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalRingHomClass.toMulHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (RingHomClass.toNonUnitalRingHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (RingHom.instRingHomClassRingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))))) (starRingEnd.{0} Complex Complex.instCommSemiringComplex Complex.instStarRingComplexToNonUnitalSemiringToNonUnitalCommSemiringToNonUnitalCommRingCommRing) (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (Metric.ball.{0} Complex (SeminormedRing.toPseudoMetricSpace.{0} Complex (SeminormedCommRing.toSeminormedRing.{0} Complex (NormedCommRing.toSeminormedCommRing.{0} Complex (NormedField.toNormedCommRing.{0} Complex Complex.instNormedFieldComplex)))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) z))
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.coe_conj Complex.UnitDisc.coe_conj‚Çì'. -/
@[simp, norm_cast]
theorem coe_conj (z : ùîª) : (z.conj : ‚ÑÇ) = conj' ‚Üëz :=
  rfl
#align complex.unit_disc.coe_conj Complex.UnitDisc.coe_conj

/- warning: complex.unit_disc.conj_zero -> Complex.UnitDisc.conj_zero is a dubious translation:
lean 3 declaration is
  Eq.{1} Complex.UnitDisc (Complex.UnitDisc.conj (OfNat.ofNat.{0} Complex.UnitDisc 0 (OfNat.mk.{0} Complex.UnitDisc 0 (Zero.zero.{0} Complex.UnitDisc (MulZeroClass.toHasZero.{0} Complex.UnitDisc (SemigroupWithZero.toMulZeroClass.{0} Complex.UnitDisc Complex.UnitDisc.semigroupWithZero)))))) (OfNat.ofNat.{0} Complex.UnitDisc 0 (OfNat.mk.{0} Complex.UnitDisc 0 (Zero.zero.{0} Complex.UnitDisc (MulZeroClass.toHasZero.{0} Complex.UnitDisc (SemigroupWithZero.toMulZeroClass.{0} Complex.UnitDisc Complex.UnitDisc.semigroupWithZero)))))
but is expected to have type
  Eq.{1} Complex.UnitDisc (Complex.UnitDisc.conj (OfNat.ofNat.{0} Complex.UnitDisc 0 (Zero.toOfNat0.{0} Complex.UnitDisc (SemigroupWithZero.toZero.{0} Complex.UnitDisc Complex.UnitDisc.instSemigroupWithZeroUnitDisc)))) (OfNat.ofNat.{0} Complex.UnitDisc 0 (Zero.toOfNat0.{0} Complex.UnitDisc (SemigroupWithZero.toZero.{0} Complex.UnitDisc Complex.UnitDisc.instSemigroupWithZeroUnitDisc)))
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.conj_zero Complex.UnitDisc.conj_zero‚Çì'. -/
@[simp]
theorem conj_zero : conj 0 = 0 :=
  coe_injective (map_zero conj')
#align complex.unit_disc.conj_zero Complex.UnitDisc.conj_zero

#print Complex.UnitDisc.conj_conj /-
@[simp]
theorem conj_conj (z : ùîª) : conj (conj z) = z :=
  coe_injective <| Complex.conj_conj z
#align complex.unit_disc.conj_conj Complex.UnitDisc.conj_conj
-/

/- warning: complex.unit_disc.conj_neg -> Complex.UnitDisc.conj_neg is a dubious translation:
lean 3 declaration is
  forall (z : Complex.UnitDisc), Eq.{1} Complex.UnitDisc (Complex.UnitDisc.conj (Neg.neg.{0} Complex.UnitDisc (NegZeroClass.toHasNeg.{0} Complex.UnitDisc (MulZeroClass.negZeroClass.{0} Complex.UnitDisc (SemigroupWithZero.toMulZeroClass.{0} Complex.UnitDisc Complex.UnitDisc.semigroupWithZero) Complex.UnitDisc.hasDistribNeg)) z)) (Neg.neg.{0} Complex.UnitDisc (NegZeroClass.toHasNeg.{0} Complex.UnitDisc (MulZeroClass.negZeroClass.{0} Complex.UnitDisc (SemigroupWithZero.toMulZeroClass.{0} Complex.UnitDisc Complex.UnitDisc.semigroupWithZero) Complex.UnitDisc.hasDistribNeg)) (Complex.UnitDisc.conj z))
but is expected to have type
  forall (z : Complex.UnitDisc), Eq.{1} Complex.UnitDisc (Complex.UnitDisc.conj (Neg.neg.{0} Complex.UnitDisc (NegZeroClass.toNeg.{0} Complex.UnitDisc (MulZeroClass.negZeroClass.{0} Complex.UnitDisc (SemigroupWithZero.toMulZeroClass.{0} Complex.UnitDisc Complex.UnitDisc.instSemigroupWithZeroUnitDisc) Complex.instHasDistribNegUnitDiscToMulToSemigroupInstCommSemigroupUnitDisc)) z)) (Neg.neg.{0} Complex.UnitDisc (NegZeroClass.toNeg.{0} Complex.UnitDisc (MulZeroClass.negZeroClass.{0} Complex.UnitDisc (SemigroupWithZero.toMulZeroClass.{0} Complex.UnitDisc Complex.UnitDisc.instSemigroupWithZeroUnitDisc) Complex.instHasDistribNegUnitDiscToMulToSemigroupInstCommSemigroupUnitDisc)) (Complex.UnitDisc.conj z))
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.conj_neg Complex.UnitDisc.conj_neg‚Çì'. -/
@[simp]
theorem conj_neg (z : ùîª) : (-z).conj = -z.conj :=
  rfl
#align complex.unit_disc.conj_neg Complex.UnitDisc.conj_neg

#print Complex.UnitDisc.re_conj /-
@[simp]
theorem re_conj (z : ùîª) : z.conj.re = z.re :=
  rfl
#align complex.unit_disc.re_conj Complex.UnitDisc.re_conj
-/

/- warning: complex.unit_disc.im_conj -> Complex.UnitDisc.im_conj is a dubious translation:
lean 3 declaration is
  forall (z : Complex.UnitDisc), Eq.{1} Real (Complex.UnitDisc.im (Complex.UnitDisc.conj z)) (Neg.neg.{0} Real Real.hasNeg (Complex.UnitDisc.im z))
but is expected to have type
  forall (z : Complex.UnitDisc), Eq.{1} Real (Complex.UnitDisc.im (Complex.UnitDisc.conj z)) (Neg.neg.{0} Real Real.instNegReal (Complex.UnitDisc.im z))
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.im_conj Complex.UnitDisc.im_conj‚Çì'. -/
@[simp]
theorem im_conj (z : ùîª) : z.conj.im = -z.im :=
  rfl
#align complex.unit_disc.im_conj Complex.UnitDisc.im_conj

/- warning: complex.unit_disc.conj_mul -> Complex.UnitDisc.conj_mul is a dubious translation:
lean 3 declaration is
  forall (z : Complex.UnitDisc) (w : Complex.UnitDisc), Eq.{1} Complex.UnitDisc (Complex.UnitDisc.conj (HMul.hMul.{0, 0, 0} Complex.UnitDisc Complex.UnitDisc Complex.UnitDisc (instHMul.{0} Complex.UnitDisc (MulZeroClass.toHasMul.{0} Complex.UnitDisc (SemigroupWithZero.toMulZeroClass.{0} Complex.UnitDisc Complex.UnitDisc.semigroupWithZero))) z w)) (HMul.hMul.{0, 0, 0} Complex.UnitDisc Complex.UnitDisc Complex.UnitDisc (instHMul.{0} Complex.UnitDisc (MulZeroClass.toHasMul.{0} Complex.UnitDisc (SemigroupWithZero.toMulZeroClass.{0} Complex.UnitDisc Complex.UnitDisc.semigroupWithZero))) (Complex.UnitDisc.conj z) (Complex.UnitDisc.conj w))
but is expected to have type
  forall (z : Complex.UnitDisc) (w : Complex.UnitDisc), Eq.{1} Complex.UnitDisc (Complex.UnitDisc.conj (HMul.hMul.{0, 0, 0} Complex.UnitDisc Complex.UnitDisc Complex.UnitDisc (instHMul.{0} Complex.UnitDisc (MulZeroClass.toMul.{0} Complex.UnitDisc (SemigroupWithZero.toMulZeroClass.{0} Complex.UnitDisc Complex.UnitDisc.instSemigroupWithZeroUnitDisc))) z w)) (HMul.hMul.{0, 0, 0} Complex.UnitDisc Complex.UnitDisc Complex.UnitDisc (instHMul.{0} Complex.UnitDisc (MulZeroClass.toMul.{0} Complex.UnitDisc (SemigroupWithZero.toMulZeroClass.{0} Complex.UnitDisc Complex.UnitDisc.instSemigroupWithZeroUnitDisc))) (Complex.UnitDisc.conj z) (Complex.UnitDisc.conj w))
Case conversion may be inaccurate. Consider using '#align complex.unit_disc.conj_mul Complex.UnitDisc.conj_mul‚Çì'. -/
@[simp]
theorem conj_mul (z w : ùîª) : (z * w).conj = z.conj * w.conj :=
  Subtype.ext <| map_mul _ _ _
#align complex.unit_disc.conj_mul Complex.UnitDisc.conj_mul

end UnitDisc

end Complex

