/-
Copyright (c) 2019 Zhouhang Zhou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Zhouhang Zhou, Sébastien Gouëzel, Frédéric Dupuis

! This file was ported from Lean 3 source module analysis.inner_product_space.basic
! leanprover-community/mathlib commit 6d0adfa76594f304b4650d098273d4366edeb61b
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.DirectSum.Module
import Mathbin.Analysis.Complex.Basic
import Mathbin.Analysis.Convex.Uniform
import Mathbin.Analysis.NormedSpace.Completion
import Mathbin.Analysis.NormedSpace.BoundedLinearMaps

/-!
# Inner product space

This file defines inner product spaces and proves the basic properties.  We do not formally
define Hilbert spaces, but they can be obtained using the pair of assumptions
`[inner_product_space 𝕜 E] [complete_space E]`.

An inner product space is a vector space endowed with an inner product. It generalizes the notion of
dot product in `ℝ^n` and provides the means of defining the length of a vector and the angle between
two vectors. In particular vectors `x` and `y` are orthogonal if their inner product equals zero.
We define both the real and complex cases at the same time using the `is_R_or_C` typeclass.

This file proves general results on inner product spaces. For the specific construction of an inner
product structure on `n → 𝕜` for `𝕜 = ℝ` or `ℂ`, see `euclidean_space` in
`analysis.inner_product_space.pi_L2`.

## Main results

- We define the class `inner_product_space 𝕜 E` extending `normed_space 𝕜 E` with a number of basic
  properties, most notably the Cauchy-Schwarz inequality. Here `𝕜` is understood to be either `ℝ`
  or `ℂ`, through the `is_R_or_C` typeclass.
- We show that the inner product is continuous, `continuous_inner`, and bundle it as the
  the continuous sesquilinear map `innerSL` (see also `innerₛₗ` for the non-continuous version).
- We define `orthonormal`, a predicate on a function `v : ι → E`, and prove the existence of a
  maximal orthonormal set, `exists_maximal_orthonormal`.  Bessel's inequality,
  `orthonormal.tsum_inner_products_le`, states that given an orthonormal set `v` and a vector `x`,
  the sum of the norm-squares of the inner products `⟪v i, x⟫` is no more than the norm-square of
  `x`. For the existence of orthonormal bases, Hilbert bases, etc., see the file
  `analysis.inner_product_space.projection`.
- The `orthogonal_complement` of a submodule `K` is defined, and basic API established.  Some of
  the more subtle results about the orthogonal complement are delayed to
  `analysis.inner_product_space.projection`.

## Notation

We globally denote the real and complex inner products by `⟪·, ·⟫_ℝ` and `⟪·, ·⟫_ℂ` respectively.
We also provide two notation namespaces: `real_inner_product_space`, `complex_inner_product_space`,
which respectively introduce the plain notation `⟪·, ·⟫` for the real and complex inner product.

The orthogonal complement of a submodule `K` is denoted by `Kᗮ`.

## Implementation notes

We choose the convention that inner products are conjugate linear in the first argument and linear
in the second.

## Tags

inner product space, Hilbert space, norm

## References
*  [Clément & Martin, *The Lax-Milgram Theorem. A detailed proof to be formalized in Coq*]
*  [Clément & Martin, *A Coq formal proof of the Lax–Milgram theorem*]

The Coq code is available at the following address: <http://www.lri.fr/~sboldo/elfic/index.html>
-/


noncomputable section

open IsROrC Real Filter

open BigOperators TopologicalSpace ComplexConjugate

variable {𝕜 E F : Type _} [IsROrC 𝕜]

/-- Syntactic typeclass for types endowed with an inner product -/
class HasInner (𝕜 E : Type _) where
  inner : E → E → 𝕜
#align has_inner HasInner

export HasInner (inner)

-- mathport name: «expr⟪ , ⟫_ℝ»
notation "⟪" x ", " y "⟫_ℝ" => @inner ℝ _ _ x y

-- mathport name: «expr⟪ , ⟫_ℂ»
notation "⟪" x ", " y "⟫_ℂ" => @inner ℂ _ _ x y

section Notations

-- mathport name: inner.real
scoped[RealInnerProductSpace] notation "⟪" x ", " y "⟫" => @inner ℝ _ _ x y

-- mathport name: inner.complex
scoped[ComplexInnerProductSpace] notation "⟪" x ", " y "⟫" => @inner ℂ _ _ x y

end Notations

/-- An inner product space is a vector space with an additional operation called inner product.
The norm could be derived from the inner product, instead we require the existence of a norm and
the fact that `‖x‖^2 = re ⟪x, x⟫` to be able to put instances on `𝕂` or product
spaces.

To construct a norm from an inner product, see `inner_product_space.of_core`.
-/
class InnerProductSpace (𝕜 : Type _) (E : Type _) [IsROrC 𝕜] extends NormedAddCommGroup E,
  NormedSpace 𝕜 E, HasInner 𝕜 E where
  norm_sq_eq_inner : ∀ x : E, ‖x‖ ^ 2 = re (inner x x)
  conj_sym : ∀ x y, conj (inner y x) = inner x y
  add_left : ∀ x y z, inner (x + y) z = inner x z + inner y z
  smul_left : ∀ x y r, inner (r • x) y = conj r * inner x y
#align inner_product_space InnerProductSpace

attribute [nolint dangerous_instance] InnerProductSpace.toNormedAddCommGroup

/-!
### Constructing a normed space structure from an inner product

In the definition of an inner product space, we require the existence of a norm, which is equal
(but maybe not defeq) to the square root of the scalar product. This makes it possible to put
an inner product space structure on spaces with a preexisting norm (for instance `ℝ`), with good
properties. However, sometimes, one would like to define the norm starting only from a well-behaved
scalar product. This is what we implement in this paragraph, starting from a structure
`inner_product_space.core` stating that we have a nice scalar product.

Our goal here is not to develop a whole theory with all the supporting API, as this will be done
below for `inner_product_space`. Instead, we implement the bare minimum to go as directly as
possible to the construction of the norm and the proof of the triangular inequality.

Warning: Do not use this `core` structure if the space you are interested in already has a norm
instance defined on it, otherwise this will create a second non-defeq norm instance!
-/


-- note [is_R_or_C instance]
/-- A structure requiring that a scalar product is positive definite and symmetric, from which one
can construct an `inner_product_space` instance in `inner_product_space.of_core`. -/
@[nolint has_nonempty_instance]
structure InnerProductSpace.Core (𝕜 : Type _) (F : Type _) [IsROrC 𝕜] [AddCommGroup F]
  [Module 𝕜 F] where
  inner : F → F → 𝕜
  conj_sym : ∀ x y, conj (inner y x) = inner x y
  nonneg_re : ∀ x, 0 ≤ re (inner x x)
  definite : ∀ x, inner x x = 0 → x = 0
  add_left : ∀ x y z, inner (x + y) z = inner x z + inner y z
  smul_left : ∀ x y r, inner (r • x) y = conj r * inner x y
#align inner_product_space.core InnerProductSpace.Core

/- We set `inner_product_space.core` to be a class as we will use it as such in the construction
of the normed space structure that it produces. However, all the instances we will use will be
local to this proof. -/
attribute [class] InnerProductSpace.Core

namespace InnerProductSpace.ofCore

variable [AddCommGroup F] [Module 𝕜 F] [c : InnerProductSpace.Core 𝕜 F]

include c

-- mathport name: «expr⟪ , ⟫»
local notation "⟪" x ", " y "⟫" => @inner 𝕜 F _ x y

-- mathport name: exprnorm_sqK
local notation "norm_sqK" => @IsROrC.normSq 𝕜 _

-- mathport name: exprreK
local notation "reK" => @IsROrC.re 𝕜 _

-- mathport name: exprabsK
local notation "absK" => @IsROrC.abs 𝕜 _

-- mathport name: exprext_iff
local notation "ext_iff" => @IsROrC.ext_iff 𝕜 _

-- mathport name: «expr †»
local postfix:90 "†" => starRingEnd _

/-- Inner product defined by the `inner_product_space.core` structure. -/
def toHasInner : HasInner 𝕜 F where inner := c.inner
#align inner_product_space.of_core.to_has_inner InnerProductSpace.OfCore.toHasInner

attribute [local instance] to_has_inner

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "The norm squared function for `inner_product_space.core` structure. -/")]
      []
      []
      []
      []
      [])
     (Command.def
      "def"
      (Command.declId `normSq [])
      (Command.optDeclSig [(Term.explicitBinder "(" [`x] [":" `F] [] ")")] [])
      (Command.declValSimple
       ":="
       (Term.app
        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.termreK "reK")
        [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          `x
          ", "
          `x
          "⟫")])
       [])
      []
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.termreK "reK")
       [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.598'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.theorem'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- The norm squared function for `inner_product_space.core` structure. -/
  def normSq ( x : F ) := reK ⟪ x , x ⟫
#align inner_product_space.of_core.norm_sq InnerProductSpace.OfCore.normSq

-- mathport name: exprnorm_sqF
local notation "norm_sqF" => @normSq 𝕜 F _ _ _ _

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_conj_sym [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x `y] [":" `F] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term_†»
          (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")
          "†")
         "="
         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          `x
          ", "
          `y
          "⟫"))))
      (Command.declValSimple ":=" (Term.app (Term.proj `c "." `conj_sym) [`x `y]) [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app (Term.proj `c "." `conj_sym) [`x `y])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.proj `c "." `conj_sym)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `c
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term_†»
        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")
        "†")
       "="
       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.598'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem inner_conj_sym ( x y : F ) : ⟪ y , x ⟫ † = ⟪ x , y ⟫ := c . conj_sym x y
#align inner_product_space.of_core.inner_conj_sym InnerProductSpace.OfCore.inner_conj_sym

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_self_nonneg [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x] [":" `F] "}")]
       (Term.typeSpec
        ":"
        («term_≤_»
         (num "0")
         "≤"
         (Term.app
          `re
          [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
            "⟪"
            `x
            ", "
            `x
            "⟫")]))))
      (Command.declValSimple ":=" (Term.app (Term.proj `c "." `nonneg_re) [(Term.hole "_")]) [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app (Term.proj `c "." `nonneg_re) [(Term.hole "_")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.proj `c "." `nonneg_re)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `c
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_≤_»
       (num "0")
       "≤"
       (Term.app
        `re
        [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          `x
          ", "
          `x
          "⟫")]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `re
       [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.598'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem inner_self_nonneg { x : F } : 0 ≤ re ⟪ x , x ⟫ := c . nonneg_re _
#align inner_product_space.of_core.inner_self_nonneg InnerProductSpace.OfCore.inner_self_nonneg

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_self_nonneg_im [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x] [":" `F] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.app
          `im
          [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
            "⟪"
            `x
            ", "
            `x
            "⟫")])
         "="
         (num "0"))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.«tactic_<;>_»
            (Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq
              "["
              [(Tactic.rwRule
                [(patternIgnore (token.«← » "←"))]
                (Term.app (Term.explicit "@" `of_real_inj) [`𝕜]))
               ","
               (Tactic.rwRule [] `im_eq_conj_sub)]
              "]")
             [])
            "<;>"
            (Tactic.simp
             "simp"
             []
             []
             []
             ["[" [(Tactic.simpLemma [] [] `inner_conj_sym)] "]"]
             []))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.«tactic_<;>_»
           (Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule
               [(patternIgnore (token.«← » "←"))]
               (Term.app (Term.explicit "@" `of_real_inj) [`𝕜]))
              ","
              (Tactic.rwRule [] `im_eq_conj_sub)]
             "]")
            [])
           "<;>"
           (Tactic.simp
            "simp"
            []
            []
            []
            ["[" [(Tactic.simpLemma [] [] `inner_conj_sym)] "]"]
            []))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.«tactic_<;>_»
       (Tactic.rwSeq
        "rw"
        []
        (Tactic.rwRuleSeq
         "["
         [(Tactic.rwRule
           [(patternIgnore (token.«← » "←"))]
           (Term.app (Term.explicit "@" `of_real_inj) [`𝕜]))
          ","
          (Tactic.rwRule [] `im_eq_conj_sub)]
         "]")
        [])
       "<;>"
       (Tactic.simp "simp" [] [] [] ["[" [(Tactic.simpLemma [] [] `inner_conj_sym)] "]"] []))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp "simp" [] [] [] ["[" [(Tactic.simpLemma [] [] `inner_conj_sym)] "]"] [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_conj_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 2 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1, tactic))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule
          [(patternIgnore (token.«← » "←"))]
          (Term.app (Term.explicit "@" `of_real_inj) [`𝕜]))
         ","
         (Tactic.rwRule [] `im_eq_conj_sub)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `im_eq_conj_sub
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app (Term.explicit "@" `of_real_inj) [`𝕜])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `𝕜
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.explicit "@" `of_real_inj)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `of_real_inj
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (some 1024,
     term) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Term.app
        `im
        [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          `x
          ", "
          `x
          "⟫")])
       "="
       (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Term.app
       `im
       [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.598'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_self_nonneg_im
  { x : F } : im ⟪ x , x ⟫ = 0
  := by rw [ ← @ of_real_inj 𝕜 , im_eq_conj_sub ] <;> simp [ inner_conj_sym ]
#align
  inner_product_space.of_core.inner_self_nonneg_im InnerProductSpace.OfCore.inner_self_nonneg_im

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_self_im_zero [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x] [":" `F] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.app
          `im
          [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
            "⟪"
            `x
            ", "
            `x
            "⟫")])
         "="
         (num "0"))))
      (Command.declValSimple ":=" `inner_self_nonneg_im [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_self_nonneg_im
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Term.app
        `im
        [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          `x
          ", "
          `x
          "⟫")])
       "="
       (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Term.app
       `im
       [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.598'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem inner_self_im_zero { x : F } : im ⟪ x , x ⟫ = 0 := inner_self_nonneg_im
#align inner_product_space.of_core.inner_self_im_zero InnerProductSpace.OfCore.inner_self_im_zero

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_add_left [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y `z] [":" `F] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          («term_+_» `x "+" `y)
          ", "
          `z
          "⟫")
         "="
         («term_+_»
          (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `z "⟫")
          "+"
          (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           `y
           ", "
           `z
           "⟫")))))
      (Command.declValSimple
       ":="
       (Term.app (Term.proj `c "." `add_left) [(Term.hole "_") (Term.hole "_") (Term.hole "_")])
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app (Term.proj `c "." `add_left) [(Term.hole "_") (Term.hole "_") (Term.hole "_")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.proj `c "." `add_left)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `c
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        («term_+_» `x "+" `y)
        ", "
        `z
        "⟫")
       "="
       («term_+_»
        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `z "⟫")
        "+"
        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `z "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_+_»
       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `z "⟫")
       "+"
       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `z "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `z "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.598'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem inner_add_left { x y z : F } : ⟪ x + y , z ⟫ = ⟪ x , z ⟫ + ⟪ y , z ⟫ := c . add_left _ _ _
#align inner_product_space.of_core.inner_add_left InnerProductSpace.OfCore.inner_add_left

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_add_right [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y `z] [":" `F] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          `x
          ", "
          («term_+_» `y "+" `z)
          "⟫")
         "="
         («term_+_»
          (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
          "+"
          (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           `x
           ", "
           `z
           "⟫")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.«tactic_<;>_»
            (Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq
              "["
              [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
               ","
               (Tactic.rwRule [] `inner_add_left)
               ","
               (Tactic.rwRule [] `RingHom.map_add)]
              "]")
             [])
            "<;>"
            (Tactic.simp
             "simp"
             []
             []
             ["only"]
             ["[" [(Tactic.simpLemma [] [] `inner_conj_sym)] "]"]
             []))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.«tactic_<;>_»
           (Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
              ","
              (Tactic.rwRule [] `inner_add_left)
              ","
              (Tactic.rwRule [] `RingHom.map_add)]
             "]")
            [])
           "<;>"
           (Tactic.simp
            "simp"
            []
            []
            ["only"]
            ["[" [(Tactic.simpLemma [] [] `inner_conj_sym)] "]"]
            []))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.«tactic_<;>_»
       (Tactic.rwSeq
        "rw"
        []
        (Tactic.rwRuleSeq
         "["
         [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
          ","
          (Tactic.rwRule [] `inner_add_left)
          ","
          (Tactic.rwRule [] `RingHom.map_add)]
         "]")
        [])
       "<;>"
       (Tactic.simp "simp" [] [] ["only"] ["[" [(Tactic.simpLemma [] [] `inner_conj_sym)] "]"] []))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp "simp" [] [] ["only"] ["[" [(Tactic.simpLemma [] [] `inner_conj_sym)] "]"] [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_conj_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 2 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1, tactic))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
         ","
         (Tactic.rwRule [] `inner_add_left)
         ","
         (Tactic.rwRule [] `RingHom.map_add)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `RingHom.map_add
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_add_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_conj_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        `x
        ", "
        («term_+_» `y "+" `z)
        "⟫")
       "="
       («term_+_»
        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
        "+"
        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `z "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_+_»
       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
       "+"
       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `z "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `z "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.598'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_add_right
  { x y z : F } : ⟪ x , y + z ⟫ = ⟪ x , y ⟫ + ⟪ x , z ⟫
  := by rw [ ← inner_conj_sym , inner_add_left , RingHom.map_add ] <;> simp only [ inner_conj_sym ]
#align inner_product_space.of_core.inner_add_right InnerProductSpace.OfCore.inner_add_right

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_norm_sq_eq_inner_self [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x] [":" `F] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.typeAscription
          "("
          (Term.app
           (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.termnorm_sqF "norm_sqF")
           [`x])
          ":"
          [`𝕜]
          ")")
         "="
         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          `x
          ", "
          `x
          "⟫"))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule
               []
               (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.termext_iff "ext_iff"))]
             "]")
            [])
           []
           (Tactic.exact
            "exact"
            (Term.anonymousCtor
             "⟨"
             [(Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.«tactic_<;>_»
                   (Tactic.simp
                    "simp"
                    []
                    []
                    ["only"]
                    ["[" [(Tactic.simpLemma [] [] `of_real_re)] "]"]
                    [])
                   "<;>"
                   (Tactic.tacticRfl "rfl"))])))
              ","
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.simp
                   "simp"
                   []
                   []
                   ["only"]
                   ["["
                    [(Tactic.simpLemma [] [] `inner_self_nonneg_im)
                     ","
                     (Tactic.simpLemma [] [] `of_real_im)]
                    "]"]
                   [])])))]
             "⟩"))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule
              []
              (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.termext_iff "ext_iff"))]
            "]")
           [])
          []
          (Tactic.exact
           "exact"
           (Term.anonymousCtor
            "⟨"
            [(Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Tactic.«tactic_<;>_»
                  (Tactic.simp
                   "simp"
                   []
                   []
                   ["only"]
                   ["[" [(Tactic.simpLemma [] [] `of_real_re)] "]"]
                   [])
                  "<;>"
                  (Tactic.tacticRfl "rfl"))])))
             ","
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Tactic.simp
                  "simp"
                  []
                  []
                  ["only"]
                  ["["
                   [(Tactic.simpLemma [] [] `inner_self_nonneg_im)
                    ","
                    (Tactic.simpLemma [] [] `of_real_im)]
                   "]"]
                  [])])))]
            "⟩"))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact
       "exact"
       (Term.anonymousCtor
        "⟨"
        [(Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(Tactic.«tactic_<;>_»
              (Tactic.simp
               "simp"
               []
               []
               ["only"]
               ["[" [(Tactic.simpLemma [] [] `of_real_re)] "]"]
               [])
              "<;>"
              (Tactic.tacticRfl "rfl"))])))
         ","
         (Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(Tactic.simp
              "simp"
              []
              []
              ["only"]
              ["["
               [(Tactic.simpLemma [] [] `inner_self_nonneg_im)
                ","
                (Tactic.simpLemma [] [] `of_real_im)]
               "]"]
              [])])))]
        "⟩"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.anonymousCtor
       "⟨"
       [(Term.byTactic
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(Tactic.«tactic_<;>_»
             (Tactic.simp "simp" [] [] ["only"] ["[" [(Tactic.simpLemma [] [] `of_real_re)] "]"] [])
             "<;>"
             (Tactic.tacticRfl "rfl"))])))
        ","
        (Term.byTactic
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(Tactic.simp
             "simp"
             []
             []
             ["only"]
             ["["
              [(Tactic.simpLemma [] [] `inner_self_nonneg_im)
               ","
               (Tactic.simpLemma [] [] `of_real_im)]
              "]"]
             [])])))]
       "⟩")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["["
            [(Tactic.simpLemma [] [] `inner_self_nonneg_im)
             ","
             (Tactic.simpLemma [] [] `of_real_im)]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] `inner_self_nonneg_im) "," (Tactic.simpLemma [] [] `of_real_im)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `of_real_im
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_self_nonneg_im
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.«tactic_<;>_»
           (Tactic.simp "simp" [] [] ["only"] ["[" [(Tactic.simpLemma [] [] `of_real_re)] "]"] [])
           "<;>"
           (Tactic.tacticRfl "rfl"))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.«tactic_<;>_»
       (Tactic.simp "simp" [] [] ["only"] ["[" [(Tactic.simpLemma [] [] `of_real_re)] "]"] [])
       "<;>"
       (Tactic.tacticRfl "rfl"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.tacticRfl "rfl")
[PrettyPrinter.parenthesize] ...precedences are 2 >? 1024
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1, tactic))
      (Tactic.simp "simp" [] [] ["only"] ["[" [(Tactic.simpLemma [] [] `of_real_re)] "]"] [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `of_real_re
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule
          []
          (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.termext_iff "ext_iff"))]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.termext_iff "ext_iff")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.termext_iff', expected 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.termext_iff._@.Analysis.InnerProductSpace.Basic._hyg.780'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_norm_sq_eq_inner_self
  ( x : F ) : ( norm_sqF x : 𝕜 ) = ⟪ x , x ⟫
  :=
    by
      rw [ ext_iff ]
        exact
          ⟨
            by simp only [ of_real_re ] <;> rfl , by simp only [ inner_self_nonneg_im , of_real_im ]
            ⟩
#align
  inner_product_space.of_core.inner_norm_sq_eq_inner_self InnerProductSpace.OfCore.inner_norm_sq_eq_inner_self

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_re_symm [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `F] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.app
          `re
          [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
            "⟪"
            `x
            ", "
            `y
            "⟫")])
         "="
         (Term.app
          `re
          [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
            "⟪"
            `y
            ", "
            `x
            "⟫")]))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
              ","
              (Tactic.rwRule [] `conj_re)]
             "]")
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
             ","
             (Tactic.rwRule [] `conj_re)]
            "]")
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
         ","
         (Tactic.rwRule [] `conj_re)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `conj_re
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_conj_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Term.app
        `re
        [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          `x
          ", "
          `y
          "⟫")])
       "="
       (Term.app
        `re
        [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          `y
          ", "
          `x
          "⟫")]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `re
       [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.598'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_re_symm
  { x y : F } : re ⟪ x , y ⟫ = re ⟪ y , x ⟫
  := by rw [ ← inner_conj_sym , conj_re ]
#align inner_product_space.of_core.inner_re_symm InnerProductSpace.OfCore.inner_re_symm

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_im_symm [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `F] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.app
          `im
          [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
            "⟪"
            `x
            ", "
            `y
            "⟫")])
         "="
         («term-_»
          "-"
          (Term.app
           `im
           [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             `y
             ", "
             `x
             "⟫")])))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
              ","
              (Tactic.rwRule [] `conj_im)]
             "]")
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
             ","
             (Tactic.rwRule [] `conj_im)]
            "]")
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
         ","
         (Tactic.rwRule [] `conj_im)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `conj_im
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_conj_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Term.app
        `im
        [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          `x
          ", "
          `y
          "⟫")])
       "="
       («term-_»
        "-"
        (Term.app
         `im
         [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           `y
           ", "
           `x
           "⟫")])))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term-_»
       "-"
       (Term.app
        `im
        [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          `y
          ", "
          `x
          "⟫")]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `im
       [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.598'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_im_symm
  { x y : F } : im ⟪ x , y ⟫ = - im ⟪ y , x ⟫
  := by rw [ ← inner_conj_sym , conj_im ]
#align inner_product_space.of_core.inner_im_symm InnerProductSpace.OfCore.inner_im_symm

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_smul_left [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `F] "}") (Term.implicitBinder "{" [`r] [":" `𝕜] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (Algebra.Group.Defs.«term_•_» `r " • " `x)
          ", "
          `y
          "⟫")
         "="
         («term_*_»
          (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term_†» `r "†")
          "*"
          (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           `x
           ", "
           `y
           "⟫")))))
      (Command.declValSimple
       ":="
       (Term.app (Term.proj `c "." `smul_left) [(Term.hole "_") (Term.hole "_") (Term.hole "_")])
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app (Term.proj `c "." `smul_left) [(Term.hole "_") (Term.hole "_") (Term.hole "_")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.proj `c "." `smul_left)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `c
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        (Algebra.Group.Defs.«term_•_» `r " • " `x)
        ", "
        `y
        "⟫")
       "="
       («term_*_»
        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term_†» `r "†")
        "*"
        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term_†» `r "†")
       "*"
       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.598'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_smul_left
  { x y : F } { r : 𝕜 } : ⟪ r • x , y ⟫ = r † * ⟪ x , y ⟫
  := c . smul_left _ _ _
#align inner_product_space.of_core.inner_smul_left InnerProductSpace.OfCore.inner_smul_left

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_smul_right [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `F] "}") (Term.implicitBinder "{" [`r] [":" `𝕜] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          `x
          ", "
          (Algebra.Group.Defs.«term_•_» `r " • " `y)
          "⟫")
         "="
         («term_*_»
          `r
          "*"
          (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           `x
           ", "
           `y
           "⟫")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.«tactic_<;>_»
            (Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq
              "["
              [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
               ","
               (Tactic.rwRule [] `inner_smul_left)]
              "]")
             [])
            "<;>"
            (Tactic.simp
             "simp"
             []
             []
             ["only"]
             ["["
              [(Tactic.simpLemma [] [] `conj_conj)
               ","
               (Tactic.simpLemma [] [] `inner_conj_sym)
               ","
               (Tactic.simpLemma [] [] `RingHom.map_mul)]
              "]"]
             []))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.«tactic_<;>_»
           (Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
              ","
              (Tactic.rwRule [] `inner_smul_left)]
             "]")
            [])
           "<;>"
           (Tactic.simp
            "simp"
            []
            []
            ["only"]
            ["["
             [(Tactic.simpLemma [] [] `conj_conj)
              ","
              (Tactic.simpLemma [] [] `inner_conj_sym)
              ","
              (Tactic.simpLemma [] [] `RingHom.map_mul)]
             "]"]
            []))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.«tactic_<;>_»
       (Tactic.rwSeq
        "rw"
        []
        (Tactic.rwRuleSeq
         "["
         [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
          ","
          (Tactic.rwRule [] `inner_smul_left)]
         "]")
        [])
       "<;>"
       (Tactic.simp
        "simp"
        []
        []
        ["only"]
        ["["
         [(Tactic.simpLemma [] [] `conj_conj)
          ","
          (Tactic.simpLemma [] [] `inner_conj_sym)
          ","
          (Tactic.simpLemma [] [] `RingHom.map_mul)]
         "]"]
        []))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] `conj_conj)
         ","
         (Tactic.simpLemma [] [] `inner_conj_sym)
         ","
         (Tactic.simpLemma [] [] `RingHom.map_mul)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `RingHom.map_mul
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_conj_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `conj_conj
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 2 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1, tactic))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
         ","
         (Tactic.rwRule [] `inner_smul_left)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_smul_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_conj_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        `x
        ", "
        (Algebra.Group.Defs.«term_•_» `r " • " `y)
        "⟫")
       "="
       («term_*_»
        `r
        "*"
        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       `r
       "*"
       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.598'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_smul_right
  { x y : F } { r : 𝕜 } : ⟪ x , r • y ⟫ = r * ⟪ x , y ⟫
  :=
    by
      rw [ ← inner_conj_sym , inner_smul_left ]
        <;>
        simp only [ conj_conj , inner_conj_sym , RingHom.map_mul ]
#align inner_product_space.of_core.inner_smul_right InnerProductSpace.OfCore.inner_smul_right

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_zero_left [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x] [":" `F] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (num "0")
          ", "
          `x
          "⟫")
         "="
         (num "0"))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.«tactic_<;>_»
            (Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq
              "["
              [(Tactic.rwRule
                [(patternIgnore (token.«← » "←"))]
                (Term.app `zero_smul [`𝕜 (Term.typeAscription "(" (num "0") ":" [`F] ")")]))
               ","
               (Tactic.rwRule [] `inner_smul_left)]
              "]")
             [])
            "<;>"
            (Tactic.simp
             "simp"
             []
             []
             ["only"]
             ["["
              [(Tactic.simpLemma [] [] `zero_mul) "," (Tactic.simpLemma [] [] `RingHom.map_zero)]
              "]"]
             []))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.«tactic_<;>_»
           (Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule
               [(patternIgnore (token.«← » "←"))]
               (Term.app `zero_smul [`𝕜 (Term.typeAscription "(" (num "0") ":" [`F] ")")]))
              ","
              (Tactic.rwRule [] `inner_smul_left)]
             "]")
            [])
           "<;>"
           (Tactic.simp
            "simp"
            []
            []
            ["only"]
            ["["
             [(Tactic.simpLemma [] [] `zero_mul) "," (Tactic.simpLemma [] [] `RingHom.map_zero)]
             "]"]
            []))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.«tactic_<;>_»
       (Tactic.rwSeq
        "rw"
        []
        (Tactic.rwRuleSeq
         "["
         [(Tactic.rwRule
           [(patternIgnore (token.«← » "←"))]
           (Term.app `zero_smul [`𝕜 (Term.typeAscription "(" (num "0") ":" [`F] ")")]))
          ","
          (Tactic.rwRule [] `inner_smul_left)]
         "]")
        [])
       "<;>"
       (Tactic.simp
        "simp"
        []
        []
        ["only"]
        ["["
         [(Tactic.simpLemma [] [] `zero_mul) "," (Tactic.simpLemma [] [] `RingHom.map_zero)]
         "]"]
        []))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["[" [(Tactic.simpLemma [] [] `zero_mul) "," (Tactic.simpLemma [] [] `RingHom.map_zero)] "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `RingHom.map_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `zero_mul
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 2 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1, tactic))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule
          [(patternIgnore (token.«← » "←"))]
          (Term.app `zero_smul [`𝕜 (Term.typeAscription "(" (num "0") ":" [`F] ")")]))
         ","
         (Tactic.rwRule [] `inner_smul_left)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_smul_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `zero_smul [`𝕜 (Term.typeAscription "(" (num "0") ":" [`F] ")")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.typeAscription', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.typeAscription', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.typeAscription "(" (num "0") ":" [`F] ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `F
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      `𝕜
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `zero_smul
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        (num "0")
        ", "
        `x
        "⟫")
       "="
       (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
       "⟪"
       (num "0")
       ", "
       `x
       "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.598'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_zero_left
  { x : F } : ⟪ 0 , x ⟫ = 0
  :=
    by
      rw [ ← zero_smul 𝕜 ( 0 : F ) , inner_smul_left ] <;> simp only [ zero_mul , RingHom.map_zero ]
#align inner_product_space.of_core.inner_zero_left InnerProductSpace.OfCore.inner_zero_left

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_zero_right [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x] [":" `F] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          `x
          ", "
          (num "0")
          "⟫")
         "="
         (num "0"))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.«tactic_<;>_»
            (Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq
              "["
              [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
               ","
               (Tactic.rwRule [] `inner_zero_left)]
              "]")
             [])
            "<;>"
            (Tactic.simp
             "simp"
             []
             []
             ["only"]
             ["[" [(Tactic.simpLemma [] [] `RingHom.map_zero)] "]"]
             []))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.«tactic_<;>_»
           (Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
              ","
              (Tactic.rwRule [] `inner_zero_left)]
             "]")
            [])
           "<;>"
           (Tactic.simp
            "simp"
            []
            []
            ["only"]
            ["[" [(Tactic.simpLemma [] [] `RingHom.map_zero)] "]"]
            []))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.«tactic_<;>_»
       (Tactic.rwSeq
        "rw"
        []
        (Tactic.rwRuleSeq
         "["
         [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
          ","
          (Tactic.rwRule [] `inner_zero_left)]
         "]")
        [])
       "<;>"
       (Tactic.simp
        "simp"
        []
        []
        ["only"]
        ["[" [(Tactic.simpLemma [] [] `RingHom.map_zero)] "]"]
        []))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp "simp" [] [] ["only"] ["[" [(Tactic.simpLemma [] [] `RingHom.map_zero)] "]"] [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `RingHom.map_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 2 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1, tactic))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
         ","
         (Tactic.rwRule [] `inner_zero_left)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_zero_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_conj_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        `x
        ", "
        (num "0")
        "⟫")
       "="
       (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
       "⟪"
       `x
       ", "
       (num "0")
       "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.598'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_zero_right
  { x : F } : ⟪ x , 0 ⟫ = 0
  := by rw [ ← inner_conj_sym , inner_zero_left ] <;> simp only [ RingHom.map_zero ]
#align inner_product_space.of_core.inner_zero_right InnerProductSpace.OfCore.inner_zero_right

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_self_eq_zero [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x] [":" `F] "}")]
       (Term.typeSpec
        ":"
        («term_↔_»
         («term_=_»
          (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
          "="
          (num "0"))
         "↔"
         («term_=_» `x "=" (num "0")))))
      (Command.declValSimple
       ":="
       (Term.app
        `Iff.intro
        [(Term.app (Term.proj `c "." `definite) [(Term.hole "_")])
         (Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(Std.Tactic.rintro
              "rintro"
              [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `rfl))]
              [])
             []
             (Tactic.exact "exact" `inner_zero_left)])))])
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `Iff.intro
       [(Term.app (Term.proj `c "." `definite) [(Term.hole "_")])
        (Term.byTactic
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(Std.Tactic.rintro
             "rintro"
             [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `rfl))]
             [])
            []
            (Tactic.exact "exact" `inner_zero_left)])))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.byTactic', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.byTactic', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Std.Tactic.rintro
           "rintro"
           [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `rfl))]
           [])
          []
          (Tactic.exact "exact" `inner_zero_left)])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact "exact" `inner_zero_left)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_zero_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Std.Tactic.rintro
       "rintro"
       [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `rfl))]
       [])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 0,
     tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.byTactic
      "by"
      (Tactic.tacticSeq
       (Tactic.tacticSeq1Indented
        [(Std.Tactic.rintro
          "rintro"
          [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `rfl))]
          [])
         []
         (Tactic.exact "exact" `inner_zero_left)])))
     ")")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.app (Term.proj `c "." `definite) [(Term.hole "_")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.proj `c "." `definite)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `c
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app (Term.proj `c "." `definite) [(Term.hole "_")])
     ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `Iff.intro
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_↔_»
       («term_=_»
        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
        "="
        (num "0"))
       "↔"
       («term_=_» `x "=" (num "0")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_» `x "=" (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none, [anonymous]) <=? (some 50, term)
[PrettyPrinter.parenthesize] ...precedences are 21 >? 50, (some 51, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 20, term))
      («term_=_»
       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
       "="
       (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.598'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_self_eq_zero
  { x : F } : ⟪ x , x ⟫ = 0 ↔ x = 0
  := Iff.intro c . definite _ by rintro rfl exact inner_zero_left
#align inner_product_space.of_core.inner_self_eq_zero InnerProductSpace.OfCore.inner_self_eq_zero

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_self_re_to_K [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x] [":" `F] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.typeAscription
          "("
          (Term.app
           `re
           [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             `x
             ", "
             `x
             "⟫")])
          ":"
          [`𝕜]
          ")")
         "="
         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          `x
          ", "
          `x
          "⟫"))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Mathlib.Tactic.normNum
            "norm_num"
            []
            [(Tactic.simpArgs
              "["
              [(Tactic.simpLemma
                []
                []
                (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.termext_iff "ext_iff"))
               ","
               (Tactic.simpLemma [] [] `inner_self_nonneg_im)]
              "]")]
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Mathlib.Tactic.normNum
           "norm_num"
           []
           [(Tactic.simpArgs
             "["
             [(Tactic.simpLemma
               []
               []
               (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.termext_iff "ext_iff"))
              ","
              (Tactic.simpLemma [] [] `inner_self_nonneg_im)]
             "]")]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.normNum
       "norm_num"
       []
       [(Tactic.simpArgs
         "["
         [(Tactic.simpLemma
           []
           []
           (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.termext_iff "ext_iff"))
          ","
          (Tactic.simpLemma [] [] `inner_self_nonneg_im)]
         "]")]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_self_nonneg_im
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.termext_iff "ext_iff")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.termext_iff', expected 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.termext_iff._@.Analysis.InnerProductSpace.Basic._hyg.780'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_self_re_to_K
  { x : F } : ( re ⟪ x , x ⟫ : 𝕜 ) = ⟪ x , x ⟫
  := by norm_num [ ext_iff , inner_self_nonneg_im ]
#align inner_product_space.of_core.inner_self_re_to_K InnerProductSpace.OfCore.inner_self_re_to_K

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_abs_conj_sym [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `F] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.app
          `abs
          [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
            "⟪"
            `x
            ", "
            `y
            "⟫")])
         "="
         (Term.app
          `abs
          [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
            "⟪"
            `y
            ", "
            `x
            "⟫")]))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
              ","
              (Tactic.rwRule [] `abs_conj)]
             "]")
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
             ","
             (Tactic.rwRule [] `abs_conj)]
            "]")
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
         ","
         (Tactic.rwRule [] `abs_conj)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `abs_conj
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_conj_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Term.app
        `abs
        [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          `x
          ", "
          `y
          "⟫")])
       "="
       (Term.app
        `abs
        [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          `y
          ", "
          `x
          "⟫")]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `abs
       [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.598'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_abs_conj_sym
  { x y : F } : abs ⟪ x , y ⟫ = abs ⟪ y , x ⟫
  := by rw [ ← inner_conj_sym , abs_conj ]
#align inner_product_space.of_core.inner_abs_conj_sym InnerProductSpace.OfCore.inner_abs_conj_sym

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_neg_left [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `F] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          («term-_» "-" `x)
          ", "
          `y
          "⟫")
         "="
         («term-_»
          "-"
          (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           `x
           ", "
           `y
           "⟫")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] (Term.app `neg_one_smul [`𝕜 `x]))
              ","
              (Tactic.rwRule [] `inner_smul_left)]
             "]")
            [])
           []
           (Tactic.simp "simp" [] [] [] [] [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] (Term.app `neg_one_smul [`𝕜 `x]))
             ","
             (Tactic.rwRule [] `inner_smul_left)]
            "]")
           [])
          []
          (Tactic.simp "simp" [] [] [] [] [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp "simp" [] [] [] [] [])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] (Term.app `neg_one_smul [`𝕜 `x]))
         ","
         (Tactic.rwRule [] `inner_smul_left)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_smul_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `neg_one_smul [`𝕜 `x])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `𝕜
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `neg_one_smul
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        («term-_» "-" `x)
        ", "
        `y
        "⟫")
       "="
       («term-_»
        "-"
        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term-_»
       "-"
       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.598'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_neg_left
  { x y : F } : ⟪ - x , y ⟫ = - ⟪ x , y ⟫
  := by rw [ ← neg_one_smul 𝕜 x , inner_smul_left ] simp
#align inner_product_space.of_core.inner_neg_left InnerProductSpace.OfCore.inner_neg_left

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_neg_right [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `F] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          `x
          ", "
          («term-_» "-" `y)
          "⟫")
         "="
         («term-_»
          "-"
          (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           `x
           ", "
           `y
           "⟫")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.«tactic_<;>_»
            (Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq
              "["
              [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
               ","
               (Tactic.rwRule [] `inner_neg_left)]
              "]")
             [])
            "<;>"
            (Tactic.simp
             "simp"
             []
             []
             ["only"]
             ["["
              [(Tactic.simpLemma [] [] `RingHom.map_neg)
               ","
               (Tactic.simpLemma [] [] `inner_conj_sym)]
              "]"]
             []))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.«tactic_<;>_»
           (Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
              ","
              (Tactic.rwRule [] `inner_neg_left)]
             "]")
            [])
           "<;>"
           (Tactic.simp
            "simp"
            []
            []
            ["only"]
            ["["
             [(Tactic.simpLemma [] [] `RingHom.map_neg)
              ","
              (Tactic.simpLemma [] [] `inner_conj_sym)]
             "]"]
            []))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.«tactic_<;>_»
       (Tactic.rwSeq
        "rw"
        []
        (Tactic.rwRuleSeq
         "["
         [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
          ","
          (Tactic.rwRule [] `inner_neg_left)]
         "]")
        [])
       "<;>"
       (Tactic.simp
        "simp"
        []
        []
        ["only"]
        ["["
         [(Tactic.simpLemma [] [] `RingHom.map_neg) "," (Tactic.simpLemma [] [] `inner_conj_sym)]
         "]"]
        []))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] `RingHom.map_neg) "," (Tactic.simpLemma [] [] `inner_conj_sym)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_conj_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `RingHom.map_neg
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 2 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1, tactic))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
         ","
         (Tactic.rwRule [] `inner_neg_left)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_neg_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_conj_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        `x
        ", "
        («term-_» "-" `y)
        "⟫")
       "="
       («term-_»
        "-"
        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term-_»
       "-"
       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.598'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_neg_right
  { x y : F } : ⟪ x , - y ⟫ = - ⟪ x , y ⟫
  := by rw [ ← inner_conj_sym , inner_neg_left ] <;> simp only [ RingHom.map_neg , inner_conj_sym ]
#align inner_product_space.of_core.inner_neg_right InnerProductSpace.OfCore.inner_neg_right

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_sub_left [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y `z] [":" `F] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          («term_-_» `x "-" `y)
          ", "
          `z
          "⟫")
         "="
         («term_-_»
          (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `z "⟫")
          "-"
          (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           `y
           ", "
           `z
           "⟫")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.simp
            "simp"
            []
            []
            []
            ["["
             [(Tactic.simpLemma [] [] `sub_eq_add_neg)
              ","
              (Tactic.simpLemma [] [] `inner_add_left)
              ","
              (Tactic.simpLemma [] [] `inner_neg_left)]
             "]"]
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           []
           ["["
            [(Tactic.simpLemma [] [] `sub_eq_add_neg)
             ","
             (Tactic.simpLemma [] [] `inner_add_left)
             ","
             (Tactic.simpLemma [] [] `inner_neg_left)]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       []
       ["["
        [(Tactic.simpLemma [] [] `sub_eq_add_neg)
         ","
         (Tactic.simpLemma [] [] `inner_add_left)
         ","
         (Tactic.simpLemma [] [] `inner_neg_left)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_neg_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_add_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `sub_eq_add_neg
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        («term_-_» `x "-" `y)
        ", "
        `z
        "⟫")
       "="
       («term_-_»
        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `z "⟫")
        "-"
        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `z "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_-_»
       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `z "⟫")
       "-"
       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `z "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `z "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.598'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_sub_left
  { x y z : F } : ⟪ x - y , z ⟫ = ⟪ x , z ⟫ - ⟪ y , z ⟫
  := by simp [ sub_eq_add_neg , inner_add_left , inner_neg_left ]
#align inner_product_space.of_core.inner_sub_left InnerProductSpace.OfCore.inner_sub_left

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_sub_right [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y `z] [":" `F] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          `x
          ", "
          («term_-_» `y "-" `z)
          "⟫")
         "="
         («term_-_»
          (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
          "-"
          (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           `x
           ", "
           `z
           "⟫")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.simp
            "simp"
            []
            []
            []
            ["["
             [(Tactic.simpLemma [] [] `sub_eq_add_neg)
              ","
              (Tactic.simpLemma [] [] `inner_add_right)
              ","
              (Tactic.simpLemma [] [] `inner_neg_right)]
             "]"]
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           []
           ["["
            [(Tactic.simpLemma [] [] `sub_eq_add_neg)
             ","
             (Tactic.simpLemma [] [] `inner_add_right)
             ","
             (Tactic.simpLemma [] [] `inner_neg_right)]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       []
       ["["
        [(Tactic.simpLemma [] [] `sub_eq_add_neg)
         ","
         (Tactic.simpLemma [] [] `inner_add_right)
         ","
         (Tactic.simpLemma [] [] `inner_neg_right)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_neg_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_add_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `sub_eq_add_neg
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        `x
        ", "
        («term_-_» `y "-" `z)
        "⟫")
       "="
       («term_-_»
        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
        "-"
        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `z "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_-_»
       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
       "-"
       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `z "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `z "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.598'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_sub_right
  { x y z : F } : ⟪ x , y - z ⟫ = ⟪ x , y ⟫ - ⟪ x , z ⟫
  := by simp [ sub_eq_add_neg , inner_add_right , inner_neg_right ]
#align inner_product_space.of_core.inner_sub_right InnerProductSpace.OfCore.inner_sub_right

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_mul_conj_re_abs [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `F] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.app
          `re
          [(«term_*_»
            (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             `x
             ", "
             `y
             "⟫")
            "*"
            (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             `y
             ", "
             `x
             "⟫"))])
         "="
         (Term.app
          `abs
          [(«term_*_»
            (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             `x
             ", "
             `y
             "⟫")
            "*"
            (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             `y
             ", "
             `x
             "⟫"))]))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
              ","
              (Tactic.rwRule [] `mul_comm)]
             "]")
            [])
           []
           (Tactic.exact "exact" (Term.app `re_eq_abs_of_mul_conj [(Term.app `inner [`y `x])]))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
             ","
             (Tactic.rwRule [] `mul_comm)]
            "]")
           [])
          []
          (Tactic.exact "exact" (Term.app `re_eq_abs_of_mul_conj [(Term.app `inner [`y `x])]))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact "exact" (Term.app `re_eq_abs_of_mul_conj [(Term.app `inner [`y `x])]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `re_eq_abs_of_mul_conj [(Term.app `inner [`y `x])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `inner [`y `x])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `y
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `inner
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `inner [`y `x]) ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `re_eq_abs_of_mul_conj
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
         ","
         (Tactic.rwRule [] `mul_comm)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `mul_comm
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_conj_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Term.app
        `re
        [(«term_*_»
          (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
          "*"
          (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           `y
           ", "
           `x
           "⟫"))])
       "="
       (Term.app
        `abs
        [(«term_*_»
          (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
          "*"
          (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           `y
           ", "
           `x
           "⟫"))]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `abs
       [(«term_*_»
         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
         "*"
         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          `y
          ", "
          `x
          "⟫"))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_*_»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_*_»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
       "*"
       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.598'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_mul_conj_re_abs
  { x y : F } : re ⟪ x , y ⟫ * ⟪ y , x ⟫ = abs ⟪ x , y ⟫ * ⟪ y , x ⟫
  := by rw [ ← inner_conj_sym , mul_comm ] exact re_eq_abs_of_mul_conj inner y x
#align
  inner_product_space.of_core.inner_mul_conj_re_abs InnerProductSpace.OfCore.inner_mul_conj_re_abs

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment "/--" "Expand `inner (x + y) (x + y)` -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_add_add_self [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `F] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          («term_+_» `x "+" `y)
          ", "
          («term_+_» `x "+" `y)
          "⟫")
         "="
         («term_+_»
          («term_+_»
           («term_+_»
            (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             `x
             ", "
             `x
             "⟫")
            "+"
            (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             `x
             ", "
             `y
             "⟫"))
           "+"
           (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
            "⟪"
            `y
            ", "
            `x
            "⟫"))
          "+"
          (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           `y
           ", "
           `y
           "⟫")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.«tactic_<;>_»
            (Tactic.simp
             "simp"
             []
             []
             ["only"]
             ["["
              [(Tactic.simpLemma [] [] `inner_add_left)
               ","
               (Tactic.simpLemma [] [] `inner_add_right)]
              "]"]
             [])
            "<;>"
            (Mathlib.Tactic.RingNF.ring "ring"))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.«tactic_<;>_»
           (Tactic.simp
            "simp"
            []
            []
            ["only"]
            ["["
             [(Tactic.simpLemma [] [] `inner_add_left)
              ","
              (Tactic.simpLemma [] [] `inner_add_right)]
             "]"]
            [])
           "<;>"
           (Mathlib.Tactic.RingNF.ring "ring"))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.«tactic_<;>_»
       (Tactic.simp
        "simp"
        []
        []
        ["only"]
        ["["
         [(Tactic.simpLemma [] [] `inner_add_left) "," (Tactic.simpLemma [] [] `inner_add_right)]
         "]"]
        [])
       "<;>"
       (Mathlib.Tactic.RingNF.ring "ring"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.RingNF.ring "ring")
[PrettyPrinter.parenthesize] ...precedences are 2 >? 1024
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1, tactic))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] `inner_add_left) "," (Tactic.simpLemma [] [] `inner_add_right)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_add_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_add_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        («term_+_» `x "+" `y)
        ", "
        («term_+_» `x "+" `y)
        "⟫")
       "="
       («term_+_»
        («term_+_»
         («term_+_»
          (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
          "+"
          (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           `x
           ", "
           `y
           "⟫"))
         "+"
         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))
        "+"
        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_+_»
       («term_+_»
        («term_+_»
         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
         "+"
         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))
        "+"
        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))
       "+"
       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.598'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- Expand `inner (x + y) (x + y)` -/
  theorem
    inner_add_add_self
    { x y : F } : ⟪ x + y , x + y ⟫ = ⟪ x , x ⟫ + ⟪ x , y ⟫ + ⟪ y , x ⟫ + ⟪ y , y ⟫
    := by simp only [ inner_add_left , inner_add_right ] <;> ring
#align inner_product_space.of_core.inner_add_add_self InnerProductSpace.OfCore.inner_add_add_self

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_sub_sub_self [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `F] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          («term_-_» `x "-" `y)
          ", "
          («term_-_» `x "-" `y)
          "⟫")
         "="
         («term_+_»
          («term_-_»
           («term_-_»
            (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             `x
             ", "
             `x
             "⟫")
            "-"
            (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             `x
             ", "
             `y
             "⟫"))
           "-"
           (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
            "⟪"
            `y
            ", "
            `x
            "⟫"))
          "+"
          (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           `y
           ", "
           `y
           "⟫")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.«tactic_<;>_»
            (Tactic.simp
             "simp"
             []
             []
             ["only"]
             ["["
              [(Tactic.simpLemma [] [] `inner_sub_left)
               ","
               (Tactic.simpLemma [] [] `inner_sub_right)]
              "]"]
             [])
            "<;>"
            (Mathlib.Tactic.RingNF.ring "ring"))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.«tactic_<;>_»
           (Tactic.simp
            "simp"
            []
            []
            ["only"]
            ["["
             [(Tactic.simpLemma [] [] `inner_sub_left)
              ","
              (Tactic.simpLemma [] [] `inner_sub_right)]
             "]"]
            [])
           "<;>"
           (Mathlib.Tactic.RingNF.ring "ring"))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.«tactic_<;>_»
       (Tactic.simp
        "simp"
        []
        []
        ["only"]
        ["["
         [(Tactic.simpLemma [] [] `inner_sub_left) "," (Tactic.simpLemma [] [] `inner_sub_right)]
         "]"]
        [])
       "<;>"
       (Mathlib.Tactic.RingNF.ring "ring"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.RingNF.ring "ring")
[PrettyPrinter.parenthesize] ...precedences are 2 >? 1024
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1, tactic))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] `inner_sub_left) "," (Tactic.simpLemma [] [] `inner_sub_right)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_sub_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_sub_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        («term_-_» `x "-" `y)
        ", "
        («term_-_» `x "-" `y)
        "⟫")
       "="
       («term_+_»
        («term_-_»
         («term_-_»
          (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
          "-"
          (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           `x
           ", "
           `y
           "⟫"))
         "-"
         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))
        "+"
        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_+_»
       («term_-_»
        («term_-_»
         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
         "-"
         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))
        "-"
        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))
       "+"
       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.598'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_sub_sub_self
  { x y : F } : ⟪ x - y , x - y ⟫ = ⟪ x , x ⟫ - ⟪ x , y ⟫ - ⟪ y , x ⟫ + ⟪ y , y ⟫
  := by simp only [ inner_sub_left , inner_sub_right ] <;> ring
#align inner_product_space.of_core.inner_sub_sub_self InnerProductSpace.OfCore.inner_sub_sub_self

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "**Cauchy–Schwarz inequality**. This proof follows \"Proof 2\" on Wikipedia.\nWe need this for the `core` structure to prove the triangle inequality below when\nshowing the core is a normed group.\n-/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_mul_inner_self_le [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x `y] [":" `F] [] ")")]
       (Term.typeSpec
        ":"
        («term_≤_»
         («term_*_»
          (Term.app
           `abs
           [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             `x
             ", "
             `y
             "⟫")])
          "*"
          (Term.app
           `abs
           [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             `y
             ", "
             `x
             "⟫")]))
         "≤"
         («term_*_»
          (Term.app
           `re
           [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             `x
             ", "
             `x
             "⟫")])
          "*"
          (Term.app
           `re
           [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             `y
             ", "
             `y
             "⟫")])))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Classical.«tacticBy_cases_:_» "by_cases" [`hy ":"] («term_=_» `y "=" (num "0")))
           []
           (tactic__
            (cdotTk (patternIgnore (token.«· » "·")))
            [(Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `hy)] "]") [])
             []
             (Tactic.simp
              "simp"
              []
              []
              ["only"]
              ["["
               [(Tactic.simpLemma [] [] `IsROrC.abs_zero)
                ","
                (Tactic.simpLemma [] [] `inner_zero_left)
                ","
                (Tactic.simpLemma [] [] `mul_zero)
                ","
                (Tactic.simpLemma [] [] `AddMonoidHom.map_zero)]
               "]"]
              [])])
           []
           (tactic__
            (cdotTk (patternIgnore (token.«· » "·")))
            [(Tactic.change
              "change"
              («term_≠_» `y "≠" (num "0"))
              [(Tactic.location "at" (Tactic.locationHyp [`hy] []))])
             []
             (Tactic.tacticHave_
              "have"
              (Term.haveDecl
               (Term.haveIdDecl
                [`hy' []]
                [(Term.typeSpec
                  ":"
                  («term_≠_»
                   (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                    "⟪"
                    `y
                    ", "
                    `y
                    "⟫")
                   "≠"
                   (num "0")))]
                ":="
                (Term.fun
                 "fun"
                 (Term.basicFun
                  [`h]
                  []
                  "=>"
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(Tactic.«tactic_<;>_»
                       (Tactic.rwSeq
                        "rw"
                        []
                        (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_self_eq_zero)] "]")
                        [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
                       "<;>"
                       (Tactic.exact "exact" (Term.app `hy [`h])))]))))))))
             []
             (Mathlib.Tactic.set
              "set"
              []
              (Mathlib.Tactic.setArgsRest
               `T
               []
               ":="
               («term_/_»
                (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                 "⟪"
                 `y
                 ", "
                 `x
                 "⟫")
                "/"
                (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                 "⟪"
                 `y
                 ", "
                 `y
                 "⟫"))
               ["with" [] `hT]))
             []
             (Tactic.tacticHave_
              "have"
              (Term.haveDecl
               (Term.haveIdDecl
                [`h₁ []]
                [(Term.typeSpec
                  ":"
                  («term_=_»
                   (Term.app
                    `re
                    [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                      "⟪"
                      `y
                      ", "
                      `x
                      "⟫")])
                   "="
                   (Term.app
                    `re
                    [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                      "⟪"
                      `x
                      ", "
                      `y
                      "⟫")])))]
                ":="
                `inner_re_symm)))
             []
             (Tactic.tacticHave_
              "have"
              (Term.haveDecl
               (Term.haveIdDecl
                [`h₂ []]
                [(Term.typeSpec
                  ":"
                  («term_=_»
                   (Term.app
                    `im
                    [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                      "⟪"
                      `y
                      ", "
                      `x
                      "⟫")])
                   "="
                   («term-_»
                    "-"
                    (Term.app
                     `im
                     [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                       "⟪"
                       `x
                       ", "
                       `y
                       "⟫")]))))]
                ":="
                `inner_im_symm)))
             []
             (Tactic.tacticHave_
              "have"
              (Term.haveDecl
               (Term.haveIdDecl
                [`h₃ []]
                [(Term.typeSpec
                  ":"
                  («term_=_»
                   («term_/_»
                    («term_*_»
                     («term_*_»
                      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                       "⟪"
                       `y
                       ", "
                       `x
                       "⟫")
                      "*"
                      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                       "⟪"
                       `x
                       ", "
                       `y
                       "⟫"))
                     "*"
                     (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                      "⟪"
                      `y
                      ", "
                      `y
                      "⟫"))
                    "/"
                    («term_*_»
                     (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                      "⟪"
                      `y
                      ", "
                      `y
                      "⟫")
                     "*"
                     (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                      "⟪"
                      `y
                      ", "
                      `y
                      "⟫")))
                   "="
                   («term_/_»
                    («term_*_»
                     (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                      "⟪"
                      `y
                      ", "
                      `x
                      "⟫")
                     "*"
                     (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                      "⟪"
                      `x
                      ", "
                      `y
                      "⟫"))
                    "/"
                    (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     `y
                     ", "
                     `y
                     "⟫"))))]
                ":="
                (Term.byTactic
                 "by"
                 (Tactic.tacticSeq
                  (Tactic.tacticSeq1Indented
                   [(Tactic.rwSeq
                     "rw"
                     []
                     (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `mul_div_assoc)] "]")
                     [])
                    []
                    (Tactic.tacticHave_
                     "have"
                     (Term.haveDecl
                      (Term.haveIdDecl
                       []
                       [(Term.typeSpec
                         ":"
                         («term_=_»
                          («term_/_»
                           (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                            "⟪"
                            `y
                            ", "
                            `y
                            "⟫")
                           "/"
                           («term_*_»
                            (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                             "⟪"
                             `y
                             ", "
                             `y
                             "⟫")
                            "*"
                            (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                             "⟪"
                             `y
                             ", "
                             `y
                             "⟫")))
                          "="
                          («term_/_»
                           (num "1")
                           "/"
                           (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                            "⟪"
                            `y
                            ", "
                            `y
                            "⟫"))))]
                       ":="
                       (Term.byTactic
                        "by"
                        (Tactic.tacticSeq
                         (Tactic.tacticSeq1Indented
                          [(Tactic.rwSeq
                            "rw"
                            []
                            (Tactic.rwRuleSeq
                             "["
                             [(Tactic.rwRule [] `div_mul_eq_div_mul_one_div)
                              ","
                              (Tactic.rwRule [] (Term.app `div_self [`hy']))
                              ","
                              (Tactic.rwRule [] `one_mul)]
                             "]")
                            [])]))))))
                    []
                    (Tactic.rwSeq
                     "rw"
                     []
                     (Tactic.rwRuleSeq
                      "["
                      [(Tactic.rwRule [] `this)
                       ","
                       (Tactic.rwRule [] `div_eq_mul_inv)
                       ","
                       (Tactic.rwRule [] `one_mul)
                       ","
                       (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `div_eq_mul_inv)]
                      "]")
                     [])]))))))
             []
             (Tactic.tacticHave_
              "have"
              (Term.haveDecl
               (Term.haveIdDecl
                [`h₄ []]
                [(Term.typeSpec
                  ":"
                  («term_=_»
                   (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                    "⟪"
                    `y
                    ", "
                    `y
                    "⟫")
                   "="
                   (Term.app
                    `re
                    [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                      "⟪"
                      `y
                      ", "
                      `y
                      "⟫")])))]
                ":="
                (Term.byTactic
                 "by"
                 (Tactic.tacticSeq
                  (Tactic.tacticSeq1Indented
                   [(Tactic.simp
                     "simp"
                     []
                     []
                     ["only"]
                     ["[" [(Tactic.simpLemma [] [] `inner_self_re_to_K)] "]"]
                     [])]))))))
             []
             (Tactic.tacticHave_
              "have"
              (Term.haveDecl
               (Term.haveIdDecl
                [`h₅ []]
                [(Term.typeSpec
                  ":"
                  («term_>_»
                   (Term.app
                    `re
                    [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                      "⟪"
                      `y
                      ", "
                      `y
                      "⟫")])
                   ">"
                   (num "0")))]
                ":="
                (Term.byTactic
                 "by"
                 (Tactic.tacticSeq
                  (Tactic.tacticSeq1Indented
                   [(Tactic.refine'
                     "refine'"
                     (Term.app `lt_of_le_of_ne [`inner_self_nonneg (Term.hole "_")]))
                    []
                    (Tactic.intro "intro" [`H])
                    []
                    (Tactic.apply "apply" `hy')
                    []
                    (Tactic.rwSeq
                     "rw"
                     []
                     (Tactic.rwRuleSeq
                      "["
                      [(Tactic.rwRule
                        []
                        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.termext_iff
                         "ext_iff"))]
                      "]")
                     [])
                    []
                    (Tactic.exact
                     "exact"
                     (Term.anonymousCtor
                      "⟨"
                      [(Term.byTactic
                        "by"
                        (Tactic.tacticSeq
                         (Tactic.tacticSeq1Indented
                          [(Tactic.simp
                            "simp"
                            []
                            []
                            ["only"]
                            ["["
                             [(Tactic.simpLemma [] [] `H) "," (Tactic.simpLemma [] [] `zero_re')]
                             "]"]
                            [])])))
                       ","
                       (Term.byTactic
                        "by"
                        (Tactic.tacticSeq
                         (Tactic.tacticSeq1Indented
                          [(Tactic.simp
                            "simp"
                            []
                            []
                            ["only"]
                            ["["
                             [(Tactic.simpLemma [] [] `inner_self_nonneg_im)
                              ","
                              (Tactic.simpLemma [] [] `AddMonoidHom.map_zero)]
                             "]"]
                            [])])))]
                      "⟩"))]))))))
             []
             (Tactic.tacticHave_
              "have"
              (Term.haveDecl
               (Term.haveIdDecl
                [`h₆ []]
                [(Term.typeSpec
                  ":"
                  («term_≠_»
                   (Term.app
                    `re
                    [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                      "⟪"
                      `y
                      ", "
                      `y
                      "⟫")])
                   "≠"
                   (num "0")))]
                ":="
                (Term.app `ne_of_gt [`h₅]))))
             []
             (Tactic.tacticHave_
              "have"
              (Term.haveDecl
               (Term.haveIdDecl
                [`hmain []]
                []
                ":="
                (calc
                 "calc"
                 (calcStep
                  («term_≤_»
                   (num "0")
                   "≤"
                   (Term.app
                    `re
                    [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                      "⟪"
                      («term_-_» `x "-" (Algebra.Group.Defs.«term_•_» `T " • " `y))
                      ", "
                      («term_-_» `x "-" (Algebra.Group.Defs.«term_•_» `T " • " `y))
                      "⟫")]))
                  ":="
                  `inner_self_nonneg)
                 [(calcStep
                   («term_=_»
                    (Term.hole "_")
                    "="
                    («term_+_»
                     («term_-_»
                      («term_-_»
                       (Term.app
                        `re
                        [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                          "⟪"
                          `x
                          ", "
                          `x
                          "⟫")])
                       "-"
                       (Term.app
                        `re
                        [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                          "⟪"
                          (Algebra.Group.Defs.«term_•_» `T " • " `y)
                          ", "
                          `x
                          "⟫")]))
                      "-"
                      (Term.app
                       `re
                       [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                         "⟪"
                         `x
                         ", "
                         (Algebra.Group.Defs.«term_•_» `T " • " `y)
                         "⟫")]))
                     "+"
                     (Term.app
                      `re
                      [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                        "⟪"
                        (Algebra.Group.Defs.«term_•_» `T " • " `y)
                        ", "
                        (Algebra.Group.Defs.«term_•_» `T " • " `y)
                        "⟫")])))
                   ":="
                   (Term.byTactic
                    "by"
                    (Tactic.tacticSeq
                     (Tactic.tacticSeq1Indented
                      [(Tactic.simp
                        "simp"
                        []
                        []
                        ["only"]
                        ["["
                         [(Tactic.simpLemma [] [] `inner_sub_sub_self)
                          ","
                          (Tactic.simpLemma [] [] `inner_smul_left)
                          ","
                          (Tactic.simpLemma [] [] `inner_smul_right)
                          ","
                          (Tactic.simpLemma [] [] `h₁)
                          ","
                          (Tactic.simpLemma [] [] `h₂)
                          ","
                          (Tactic.simpLemma [] [] `neg_mul)
                          ","
                          (Tactic.simpLemma [] [] `AddMonoidHom.map_add)
                          ","
                          (Tactic.simpLemma [] [] `mul_re)
                          ","
                          (Tactic.simpLemma [] [] `conj_im)
                          ","
                          (Tactic.simpLemma [] [] `AddMonoidHom.map_sub)
                          ","
                          (Tactic.simpLemma [] [] `mul_neg)
                          ","
                          (Tactic.simpLemma [] [] `conj_re)
                          ","
                          (Tactic.simpLemma [] [] `neg_neg)]
                         "]"]
                        [])]))))
                  (calcStep
                   («term_=_»
                    (Term.hole "_")
                    "="
                    («term_+_»
                     («term_-_»
                      («term_-_»
                       (Term.app
                        `re
                        [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                          "⟪"
                          `x
                          ", "
                          `x
                          "⟫")])
                       "-"
                       (Term.app
                        `re
                        [(«term_*_»
                          (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term_†»
                           `T
                           "†")
                          "*"
                          (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                           "⟪"
                           `y
                           ", "
                           `x
                           "⟫"))]))
                      "-"
                      (Term.app
                       `re
                       [(«term_*_»
                         `T
                         "*"
                         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                          "⟪"
                          `x
                          ", "
                          `y
                          "⟫"))]))
                     "+"
                     (Term.app
                      `re
                      [(«term_*_»
                        («term_*_»
                         `T
                         "*"
                         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term_†»
                          `T
                          "†"))
                        "*"
                        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                         "⟪"
                         `y
                         ", "
                         `y
                         "⟫"))])))
                   ":="
                   (Term.byTactic
                    "by"
                    (Tactic.tacticSeq
                     (Tactic.tacticSeq1Indented
                      [(Tactic.simp
                        "simp"
                        []
                        []
                        ["only"]
                        ["["
                         [(Tactic.simpLemma [] [] `inner_smul_left)
                          ","
                          (Tactic.simpLemma [] [] `inner_smul_right)
                          ","
                          (Tactic.simpLemma [] [] `mul_assoc)]
                         "]"]
                        [])]))))
                  (calcStep
                   («term_=_»
                    (Term.hole "_")
                    "="
                    («term_-_»
                     (Term.app
                      `re
                      [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                        "⟪"
                        `x
                        ", "
                        `x
                        "⟫")])
                     "-"
                     (Term.app
                      `re
                      [(«term_*_»
                        («term_/_»
                         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                          "⟪"
                          `x
                          ", "
                          `y
                          "⟫")
                         "/"
                         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                          "⟪"
                          `y
                          ", "
                          `y
                          "⟫"))
                        "*"
                        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                         "⟪"
                         `y
                         ", "
                         `x
                         "⟫"))])))
                   ":="
                   (Term.byTactic
                    "by"
                    (Tactic.tacticSeq
                     (Tactic.tacticSeq1Indented
                      [(Tactic.fieldSimp
                        "field_simp"
                        []
                        []
                        []
                        [(Tactic.simpArgs
                          "["
                          [(Tactic.simpErase "-" `mul_re)
                           ","
                           (Tactic.simpLemma [] [] `inner_conj_sym)
                           ","
                           (Tactic.simpLemma [] [] `hT)
                           ","
                           (Tactic.simpLemma [] [] `map_div₀)
                           ","
                           (Tactic.simpLemma [] [] `h₁)
                           ","
                           (Tactic.simpLemma [] [] `h₃)]
                          "]")]
                        [])]))))
                  (calcStep
                   («term_=_»
                    (Term.hole "_")
                    "="
                    («term_-_»
                     (Term.app
                      `re
                      [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                        "⟪"
                        `x
                        ", "
                        `x
                        "⟫")])
                     "-"
                     (Term.app
                      `re
                      [(«term_/_»
                        («term_*_»
                         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                          "⟪"
                          `x
                          ", "
                          `y
                          "⟫")
                         "*"
                         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                          "⟪"
                          `y
                          ", "
                          `x
                          "⟫"))
                        "/"
                        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                         "⟪"
                         `y
                         ", "
                         `y
                         "⟫"))])))
                   ":="
                   (Term.byTactic
                    "by"
                    (Tactic.tacticSeq
                     (Tactic.tacticSeq1Indented
                      [(Tactic.rwSeq
                        "rw"
                        []
                        (Tactic.rwRuleSeq
                         "["
                         [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `mul_div_right_comm)]
                         "]")
                        [])]))))
                  (calcStep
                   («term_=_»
                    (Term.hole "_")
                    "="
                    («term_-_»
                     (Term.app
                      `re
                      [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                        "⟪"
                        `x
                        ", "
                        `x
                        "⟫")])
                     "-"
                     (Term.app
                      `re
                      [(«term_/_»
                        («term_*_»
                         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                          "⟪"
                          `x
                          ", "
                          `y
                          "⟫")
                         "*"
                         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                          "⟪"
                          `y
                          ", "
                          `x
                          "⟫"))
                        "/"
                        (Term.app
                         `re
                         [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                           "⟪"
                           `y
                           ", "
                           `y
                           "⟫")]))])))
                   ":="
                   (Term.byTactic
                    "by"
                    (Tactic.tacticSeq
                     (Tactic.tacticSeq1Indented
                      [(Mathlib.Tactic.Conv.convLHS
                        "conv_lhs"
                        []
                        []
                        "=>"
                        (Tactic.Conv.convSeq
                         (Tactic.Conv.convSeq1Indented
                          [(Tactic.Conv.convRw__
                            "rw"
                            []
                            (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `h₄)] "]"))])))]))))
                  (calcStep
                   («term_=_»
                    (Term.hole "_")
                    "="
                    («term_-_»
                     (Term.app
                      `re
                      [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                        "⟪"
                        `x
                        ", "
                        `x
                        "⟫")])
                     "-"
                     («term_/_»
                      (Term.app
                       `re
                       [(«term_*_»
                         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                          "⟪"
                          `x
                          ", "
                          `y
                          "⟫")
                         "*"
                         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                          "⟪"
                          `y
                          ", "
                          `x
                          "⟫"))])
                      "/"
                      (Term.app
                       `re
                       [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                         "⟪"
                         `y
                         ", "
                         `y
                         "⟫")]))))
                   ":="
                   (Term.byTactic
                    "by"
                    (Tactic.tacticSeq
                     (Tactic.tacticSeq1Indented
                      [(Tactic.rwSeq
                        "rw"
                        []
                        (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `div_re_of_real)] "]")
                        [])]))))
                  (calcStep
                   («term_=_»
                    (Term.hole "_")
                    "="
                    («term_-_»
                     (Term.app
                      `re
                      [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                        "⟪"
                        `x
                        ", "
                        `x
                        "⟫")])
                     "-"
                     («term_/_»
                      (Term.app
                       `abs
                       [(«term_*_»
                         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                          "⟪"
                          `x
                          ", "
                          `y
                          "⟫")
                         "*"
                         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                          "⟪"
                          `y
                          ", "
                          `x
                          "⟫"))])
                      "/"
                      (Term.app
                       `re
                       [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                         "⟪"
                         `y
                         ", "
                         `y
                         "⟫")]))))
                   ":="
                   (Term.byTactic
                    "by"
                    (Tactic.tacticSeq
                     (Tactic.tacticSeq1Indented
                      [(Tactic.rwSeq
                        "rw"
                        []
                        (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_mul_conj_re_abs)] "]")
                        [])]))))
                  (calcStep
                   («term_=_»
                    (Term.hole "_")
                    "="
                    («term_-_»
                     (Term.app
                      `re
                      [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                        "⟪"
                        `x
                        ", "
                        `x
                        "⟫")])
                     "-"
                     («term_/_»
                      («term_*_»
                       (Term.app
                        `abs
                        [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                          "⟪"
                          `x
                          ", "
                          `y
                          "⟫")])
                       "*"
                       (Term.app
                        `abs
                        [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                          "⟪"
                          `y
                          ", "
                          `x
                          "⟫")]))
                      "/"
                      (Term.app
                       `re
                       [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                         "⟪"
                         `y
                         ", "
                         `y
                         "⟫")]))))
                   ":="
                   (Term.byTactic
                    "by"
                    (Tactic.tacticSeq
                     (Tactic.tacticSeq1Indented
                      [(Tactic.rwSeq
                        "rw"
                        []
                        (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `IsROrC.abs_mul)] "]")
                        [])]))))]))))
             []
             (Tactic.tacticHave_
              "have"
              (Term.haveDecl
               (Term.haveIdDecl
                [`hmain' []]
                [(Term.typeSpec
                  ":"
                  («term_≤_»
                   («term_/_»
                    («term_*_»
                     (Term.app
                      `abs
                      [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                        "⟪"
                        `x
                        ", "
                        `y
                        "⟫")])
                     "*"
                     (Term.app
                      `abs
                      [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                        "⟪"
                        `y
                        ", "
                        `x
                        "⟫")]))
                    "/"
                    (Term.app
                     `re
                     [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                       "⟪"
                       `y
                       ", "
                       `y
                       "⟫")]))
                   "≤"
                   (Term.app
                    `re
                    [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                      "⟪"
                      `x
                      ", "
                      `x
                      "⟫")])))]
                ":="
                (Term.byTactic
                 "by"
                 (Tactic.tacticSeq
                  (Tactic.tacticSeq1Indented
                   [(linarith "linarith" [] (linarithArgsRest [] [] []))]))))))
             []
             (Tactic.tacticHave_
              "have"
              (Term.haveDecl
               (Term.haveIdDecl
                []
                []
                ":="
                (Term.app (Term.proj (Term.app `mul_le_mul_right [`h₅]) "." `mpr) [`hmain']))))
             []
             (Std.Tactic.tacticRwa__
              "rwa"
              (Tactic.rwRuleSeq
               "["
               [(Tactic.rwRule
                 []
                 (Term.app
                  `div_mul_cancel
                  [(«term_*_»
                    (Term.app
                     `abs
                     [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                       "⟪"
                       `x
                       ", "
                       `y
                       "⟫")])
                    "*"
                    (Term.app
                     `abs
                     [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                       "⟪"
                       `y
                       ", "
                       `x
                       "⟫")]))
                   `h₆]))]
               "]")
              [(Tactic.location "at" (Tactic.locationHyp [`this] []))])])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Classical.«tacticBy_cases_:_» "by_cases" [`hy ":"] («term_=_» `y "=" (num "0")))
          []
          (tactic__
           (cdotTk (patternIgnore (token.«· » "·")))
           [(Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `hy)] "]") [])
            []
            (Tactic.simp
             "simp"
             []
             []
             ["only"]
             ["["
              [(Tactic.simpLemma [] [] `IsROrC.abs_zero)
               ","
               (Tactic.simpLemma [] [] `inner_zero_left)
               ","
               (Tactic.simpLemma [] [] `mul_zero)
               ","
               (Tactic.simpLemma [] [] `AddMonoidHom.map_zero)]
              "]"]
             [])])
          []
          (tactic__
           (cdotTk (patternIgnore (token.«· » "·")))
           [(Tactic.change
             "change"
             («term_≠_» `y "≠" (num "0"))
             [(Tactic.location "at" (Tactic.locationHyp [`hy] []))])
            []
            (Tactic.tacticHave_
             "have"
             (Term.haveDecl
              (Term.haveIdDecl
               [`hy' []]
               [(Term.typeSpec
                 ":"
                 («term_≠_»
                  (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                   "⟪"
                   `y
                   ", "
                   `y
                   "⟫")
                  "≠"
                  (num "0")))]
               ":="
               (Term.fun
                "fun"
                (Term.basicFun
                 [`h]
                 []
                 "=>"
                 (Term.byTactic
                  "by"
                  (Tactic.tacticSeq
                   (Tactic.tacticSeq1Indented
                    [(Tactic.«tactic_<;>_»
                      (Tactic.rwSeq
                       "rw"
                       []
                       (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_self_eq_zero)] "]")
                       [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
                      "<;>"
                      (Tactic.exact "exact" (Term.app `hy [`h])))]))))))))
            []
            (Mathlib.Tactic.set
             "set"
             []
             (Mathlib.Tactic.setArgsRest
              `T
              []
              ":="
              («term_/_»
               (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                "⟪"
                `y
                ", "
                `x
                "⟫")
               "/"
               (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                "⟪"
                `y
                ", "
                `y
                "⟫"))
              ["with" [] `hT]))
            []
            (Tactic.tacticHave_
             "have"
             (Term.haveDecl
              (Term.haveIdDecl
               [`h₁ []]
               [(Term.typeSpec
                 ":"
                 («term_=_»
                  (Term.app
                   `re
                   [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     `y
                     ", "
                     `x
                     "⟫")])
                  "="
                  (Term.app
                   `re
                   [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     `x
                     ", "
                     `y
                     "⟫")])))]
               ":="
               `inner_re_symm)))
            []
            (Tactic.tacticHave_
             "have"
             (Term.haveDecl
              (Term.haveIdDecl
               [`h₂ []]
               [(Term.typeSpec
                 ":"
                 («term_=_»
                  (Term.app
                   `im
                   [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     `y
                     ", "
                     `x
                     "⟫")])
                  "="
                  («term-_»
                   "-"
                   (Term.app
                    `im
                    [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                      "⟪"
                      `x
                      ", "
                      `y
                      "⟫")]))))]
               ":="
               `inner_im_symm)))
            []
            (Tactic.tacticHave_
             "have"
             (Term.haveDecl
              (Term.haveIdDecl
               [`h₃ []]
               [(Term.typeSpec
                 ":"
                 («term_=_»
                  («term_/_»
                   («term_*_»
                    («term_*_»
                     (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                      "⟪"
                      `y
                      ", "
                      `x
                      "⟫")
                     "*"
                     (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                      "⟪"
                      `x
                      ", "
                      `y
                      "⟫"))
                    "*"
                    (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     `y
                     ", "
                     `y
                     "⟫"))
                   "/"
                   («term_*_»
                    (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     `y
                     ", "
                     `y
                     "⟫")
                    "*"
                    (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     `y
                     ", "
                     `y
                     "⟫")))
                  "="
                  («term_/_»
                   («term_*_»
                    (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     `y
                     ", "
                     `x
                     "⟫")
                    "*"
                    (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     `x
                     ", "
                     `y
                     "⟫"))
                   "/"
                   (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                    "⟪"
                    `y
                    ", "
                    `y
                    "⟫"))))]
               ":="
               (Term.byTactic
                "by"
                (Tactic.tacticSeq
                 (Tactic.tacticSeq1Indented
                  [(Tactic.rwSeq
                    "rw"
                    []
                    (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `mul_div_assoc)] "]")
                    [])
                   []
                   (Tactic.tacticHave_
                    "have"
                    (Term.haveDecl
                     (Term.haveIdDecl
                      []
                      [(Term.typeSpec
                        ":"
                        («term_=_»
                         («term_/_»
                          (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                           "⟪"
                           `y
                           ", "
                           `y
                           "⟫")
                          "/"
                          («term_*_»
                           (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                            "⟪"
                            `y
                            ", "
                            `y
                            "⟫")
                           "*"
                           (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                            "⟪"
                            `y
                            ", "
                            `y
                            "⟫")))
                         "="
                         («term_/_»
                          (num "1")
                          "/"
                          (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                           "⟪"
                           `y
                           ", "
                           `y
                           "⟫"))))]
                      ":="
                      (Term.byTactic
                       "by"
                       (Tactic.tacticSeq
                        (Tactic.tacticSeq1Indented
                         [(Tactic.rwSeq
                           "rw"
                           []
                           (Tactic.rwRuleSeq
                            "["
                            [(Tactic.rwRule [] `div_mul_eq_div_mul_one_div)
                             ","
                             (Tactic.rwRule [] (Term.app `div_self [`hy']))
                             ","
                             (Tactic.rwRule [] `one_mul)]
                            "]")
                           [])]))))))
                   []
                   (Tactic.rwSeq
                    "rw"
                    []
                    (Tactic.rwRuleSeq
                     "["
                     [(Tactic.rwRule [] `this)
                      ","
                      (Tactic.rwRule [] `div_eq_mul_inv)
                      ","
                      (Tactic.rwRule [] `one_mul)
                      ","
                      (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `div_eq_mul_inv)]
                     "]")
                    [])]))))))
            []
            (Tactic.tacticHave_
             "have"
             (Term.haveDecl
              (Term.haveIdDecl
               [`h₄ []]
               [(Term.typeSpec
                 ":"
                 («term_=_»
                  (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                   "⟪"
                   `y
                   ", "
                   `y
                   "⟫")
                  "="
                  (Term.app
                   `re
                   [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     `y
                     ", "
                     `y
                     "⟫")])))]
               ":="
               (Term.byTactic
                "by"
                (Tactic.tacticSeq
                 (Tactic.tacticSeq1Indented
                  [(Tactic.simp
                    "simp"
                    []
                    []
                    ["only"]
                    ["[" [(Tactic.simpLemma [] [] `inner_self_re_to_K)] "]"]
                    [])]))))))
            []
            (Tactic.tacticHave_
             "have"
             (Term.haveDecl
              (Term.haveIdDecl
               [`h₅ []]
               [(Term.typeSpec
                 ":"
                 («term_>_»
                  (Term.app
                   `re
                   [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     `y
                     ", "
                     `y
                     "⟫")])
                  ">"
                  (num "0")))]
               ":="
               (Term.byTactic
                "by"
                (Tactic.tacticSeq
                 (Tactic.tacticSeq1Indented
                  [(Tactic.refine'
                    "refine'"
                    (Term.app `lt_of_le_of_ne [`inner_self_nonneg (Term.hole "_")]))
                   []
                   (Tactic.intro "intro" [`H])
                   []
                   (Tactic.apply "apply" `hy')
                   []
                   (Tactic.rwSeq
                    "rw"
                    []
                    (Tactic.rwRuleSeq
                     "["
                     [(Tactic.rwRule
                       []
                       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.termext_iff
                        "ext_iff"))]
                     "]")
                    [])
                   []
                   (Tactic.exact
                    "exact"
                    (Term.anonymousCtor
                     "⟨"
                     [(Term.byTactic
                       "by"
                       (Tactic.tacticSeq
                        (Tactic.tacticSeq1Indented
                         [(Tactic.simp
                           "simp"
                           []
                           []
                           ["only"]
                           ["["
                            [(Tactic.simpLemma [] [] `H) "," (Tactic.simpLemma [] [] `zero_re')]
                            "]"]
                           [])])))
                      ","
                      (Term.byTactic
                       "by"
                       (Tactic.tacticSeq
                        (Tactic.tacticSeq1Indented
                         [(Tactic.simp
                           "simp"
                           []
                           []
                           ["only"]
                           ["["
                            [(Tactic.simpLemma [] [] `inner_self_nonneg_im)
                             ","
                             (Tactic.simpLemma [] [] `AddMonoidHom.map_zero)]
                            "]"]
                           [])])))]
                     "⟩"))]))))))
            []
            (Tactic.tacticHave_
             "have"
             (Term.haveDecl
              (Term.haveIdDecl
               [`h₆ []]
               [(Term.typeSpec
                 ":"
                 («term_≠_»
                  (Term.app
                   `re
                   [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     `y
                     ", "
                     `y
                     "⟫")])
                  "≠"
                  (num "0")))]
               ":="
               (Term.app `ne_of_gt [`h₅]))))
            []
            (Tactic.tacticHave_
             "have"
             (Term.haveDecl
              (Term.haveIdDecl
               [`hmain []]
               []
               ":="
               (calc
                "calc"
                (calcStep
                 («term_≤_»
                  (num "0")
                  "≤"
                  (Term.app
                   `re
                   [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     («term_-_» `x "-" (Algebra.Group.Defs.«term_•_» `T " • " `y))
                     ", "
                     («term_-_» `x "-" (Algebra.Group.Defs.«term_•_» `T " • " `y))
                     "⟫")]))
                 ":="
                 `inner_self_nonneg)
                [(calcStep
                  («term_=_»
                   (Term.hole "_")
                   "="
                   («term_+_»
                    («term_-_»
                     («term_-_»
                      (Term.app
                       `re
                       [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                         "⟪"
                         `x
                         ", "
                         `x
                         "⟫")])
                      "-"
                      (Term.app
                       `re
                       [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                         "⟪"
                         (Algebra.Group.Defs.«term_•_» `T " • " `y)
                         ", "
                         `x
                         "⟫")]))
                     "-"
                     (Term.app
                      `re
                      [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                        "⟪"
                        `x
                        ", "
                        (Algebra.Group.Defs.«term_•_» `T " • " `y)
                        "⟫")]))
                    "+"
                    (Term.app
                     `re
                     [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                       "⟪"
                       (Algebra.Group.Defs.«term_•_» `T " • " `y)
                       ", "
                       (Algebra.Group.Defs.«term_•_» `T " • " `y)
                       "⟫")])))
                  ":="
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(Tactic.simp
                       "simp"
                       []
                       []
                       ["only"]
                       ["["
                        [(Tactic.simpLemma [] [] `inner_sub_sub_self)
                         ","
                         (Tactic.simpLemma [] [] `inner_smul_left)
                         ","
                         (Tactic.simpLemma [] [] `inner_smul_right)
                         ","
                         (Tactic.simpLemma [] [] `h₁)
                         ","
                         (Tactic.simpLemma [] [] `h₂)
                         ","
                         (Tactic.simpLemma [] [] `neg_mul)
                         ","
                         (Tactic.simpLemma [] [] `AddMonoidHom.map_add)
                         ","
                         (Tactic.simpLemma [] [] `mul_re)
                         ","
                         (Tactic.simpLemma [] [] `conj_im)
                         ","
                         (Tactic.simpLemma [] [] `AddMonoidHom.map_sub)
                         ","
                         (Tactic.simpLemma [] [] `mul_neg)
                         ","
                         (Tactic.simpLemma [] [] `conj_re)
                         ","
                         (Tactic.simpLemma [] [] `neg_neg)]
                        "]"]
                       [])]))))
                 (calcStep
                  («term_=_»
                   (Term.hole "_")
                   "="
                   («term_+_»
                    («term_-_»
                     («term_-_»
                      (Term.app
                       `re
                       [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                         "⟪"
                         `x
                         ", "
                         `x
                         "⟫")])
                      "-"
                      (Term.app
                       `re
                       [(«term_*_»
                         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term_†» `T "†")
                         "*"
                         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                          "⟪"
                          `y
                          ", "
                          `x
                          "⟫"))]))
                     "-"
                     (Term.app
                      `re
                      [(«term_*_»
                        `T
                        "*"
                        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                         "⟪"
                         `x
                         ", "
                         `y
                         "⟫"))]))
                    "+"
                    (Term.app
                     `re
                     [(«term_*_»
                       («term_*_»
                        `T
                        "*"
                        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term_†» `T "†"))
                       "*"
                       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                        "⟪"
                        `y
                        ", "
                        `y
                        "⟫"))])))
                  ":="
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(Tactic.simp
                       "simp"
                       []
                       []
                       ["only"]
                       ["["
                        [(Tactic.simpLemma [] [] `inner_smul_left)
                         ","
                         (Tactic.simpLemma [] [] `inner_smul_right)
                         ","
                         (Tactic.simpLemma [] [] `mul_assoc)]
                        "]"]
                       [])]))))
                 (calcStep
                  («term_=_»
                   (Term.hole "_")
                   "="
                   («term_-_»
                    (Term.app
                     `re
                     [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                       "⟪"
                       `x
                       ", "
                       `x
                       "⟫")])
                    "-"
                    (Term.app
                     `re
                     [(«term_*_»
                       («term_/_»
                        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                         "⟪"
                         `x
                         ", "
                         `y
                         "⟫")
                        "/"
                        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                         "⟪"
                         `y
                         ", "
                         `y
                         "⟫"))
                       "*"
                       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                        "⟪"
                        `y
                        ", "
                        `x
                        "⟫"))])))
                  ":="
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(Tactic.fieldSimp
                       "field_simp"
                       []
                       []
                       []
                       [(Tactic.simpArgs
                         "["
                         [(Tactic.simpErase "-" `mul_re)
                          ","
                          (Tactic.simpLemma [] [] `inner_conj_sym)
                          ","
                          (Tactic.simpLemma [] [] `hT)
                          ","
                          (Tactic.simpLemma [] [] `map_div₀)
                          ","
                          (Tactic.simpLemma [] [] `h₁)
                          ","
                          (Tactic.simpLemma [] [] `h₃)]
                         "]")]
                       [])]))))
                 (calcStep
                  («term_=_»
                   (Term.hole "_")
                   "="
                   («term_-_»
                    (Term.app
                     `re
                     [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                       "⟪"
                       `x
                       ", "
                       `x
                       "⟫")])
                    "-"
                    (Term.app
                     `re
                     [(«term_/_»
                       («term_*_»
                        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                         "⟪"
                         `x
                         ", "
                         `y
                         "⟫")
                        "*"
                        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                         "⟪"
                         `y
                         ", "
                         `x
                         "⟫"))
                       "/"
                       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                        "⟪"
                        `y
                        ", "
                        `y
                        "⟫"))])))
                  ":="
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(Tactic.rwSeq
                       "rw"
                       []
                       (Tactic.rwRuleSeq
                        "["
                        [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `mul_div_right_comm)]
                        "]")
                       [])]))))
                 (calcStep
                  («term_=_»
                   (Term.hole "_")
                   "="
                   («term_-_»
                    (Term.app
                     `re
                     [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                       "⟪"
                       `x
                       ", "
                       `x
                       "⟫")])
                    "-"
                    (Term.app
                     `re
                     [(«term_/_»
                       («term_*_»
                        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                         "⟪"
                         `x
                         ", "
                         `y
                         "⟫")
                        "*"
                        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                         "⟪"
                         `y
                         ", "
                         `x
                         "⟫"))
                       "/"
                       (Term.app
                        `re
                        [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                          "⟪"
                          `y
                          ", "
                          `y
                          "⟫")]))])))
                  ":="
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(Mathlib.Tactic.Conv.convLHS
                       "conv_lhs"
                       []
                       []
                       "=>"
                       (Tactic.Conv.convSeq
                        (Tactic.Conv.convSeq1Indented
                         [(Tactic.Conv.convRw__
                           "rw"
                           []
                           (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `h₄)] "]"))])))]))))
                 (calcStep
                  («term_=_»
                   (Term.hole "_")
                   "="
                   («term_-_»
                    (Term.app
                     `re
                     [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                       "⟪"
                       `x
                       ", "
                       `x
                       "⟫")])
                    "-"
                    («term_/_»
                     (Term.app
                      `re
                      [(«term_*_»
                        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                         "⟪"
                         `x
                         ", "
                         `y
                         "⟫")
                        "*"
                        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                         "⟪"
                         `y
                         ", "
                         `x
                         "⟫"))])
                     "/"
                     (Term.app
                      `re
                      [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                        "⟪"
                        `y
                        ", "
                        `y
                        "⟫")]))))
                  ":="
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(Tactic.rwSeq
                       "rw"
                       []
                       (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `div_re_of_real)] "]")
                       [])]))))
                 (calcStep
                  («term_=_»
                   (Term.hole "_")
                   "="
                   («term_-_»
                    (Term.app
                     `re
                     [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                       "⟪"
                       `x
                       ", "
                       `x
                       "⟫")])
                    "-"
                    («term_/_»
                     (Term.app
                      `abs
                      [(«term_*_»
                        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                         "⟪"
                         `x
                         ", "
                         `y
                         "⟫")
                        "*"
                        (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                         "⟪"
                         `y
                         ", "
                         `x
                         "⟫"))])
                     "/"
                     (Term.app
                      `re
                      [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                        "⟪"
                        `y
                        ", "
                        `y
                        "⟫")]))))
                  ":="
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(Tactic.rwSeq
                       "rw"
                       []
                       (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_mul_conj_re_abs)] "]")
                       [])]))))
                 (calcStep
                  («term_=_»
                   (Term.hole "_")
                   "="
                   («term_-_»
                    (Term.app
                     `re
                     [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                       "⟪"
                       `x
                       ", "
                       `x
                       "⟫")])
                    "-"
                    («term_/_»
                     («term_*_»
                      (Term.app
                       `abs
                       [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                         "⟪"
                         `x
                         ", "
                         `y
                         "⟫")])
                      "*"
                      (Term.app
                       `abs
                       [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                         "⟪"
                         `y
                         ", "
                         `x
                         "⟫")]))
                     "/"
                     (Term.app
                      `re
                      [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                        "⟪"
                        `y
                        ", "
                        `y
                        "⟫")]))))
                  ":="
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(Tactic.rwSeq
                       "rw"
                       []
                       (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `IsROrC.abs_mul)] "]")
                       [])]))))]))))
            []
            (Tactic.tacticHave_
             "have"
             (Term.haveDecl
              (Term.haveIdDecl
               [`hmain' []]
               [(Term.typeSpec
                 ":"
                 («term_≤_»
                  («term_/_»
                   («term_*_»
                    (Term.app
                     `abs
                     [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                       "⟪"
                       `x
                       ", "
                       `y
                       "⟫")])
                    "*"
                    (Term.app
                     `abs
                     [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                       "⟪"
                       `y
                       ", "
                       `x
                       "⟫")]))
                   "/"
                   (Term.app
                    `re
                    [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                      "⟪"
                      `y
                      ", "
                      `y
                      "⟫")]))
                  "≤"
                  (Term.app
                   `re
                   [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     `x
                     ", "
                     `x
                     "⟫")])))]
               ":="
               (Term.byTactic
                "by"
                (Tactic.tacticSeq
                 (Tactic.tacticSeq1Indented
                  [(linarith "linarith" [] (linarithArgsRest [] [] []))]))))))
            []
            (Tactic.tacticHave_
             "have"
             (Term.haveDecl
              (Term.haveIdDecl
               []
               []
               ":="
               (Term.app (Term.proj (Term.app `mul_le_mul_right [`h₅]) "." `mpr) [`hmain']))))
            []
            (Std.Tactic.tacticRwa__
             "rwa"
             (Tactic.rwRuleSeq
              "["
              [(Tactic.rwRule
                []
                (Term.app
                 `div_mul_cancel
                 [(«term_*_»
                   (Term.app
                    `abs
                    [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                      "⟪"
                      `x
                      ", "
                      `y
                      "⟫")])
                   "*"
                   (Term.app
                    `abs
                    [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                      "⟪"
                      `y
                      ", "
                      `x
                      "⟫")]))
                  `h₆]))]
              "]")
             [(Tactic.location "at" (Tactic.locationHyp [`this] []))])])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.«· » "·")))
       [(Tactic.change
         "change"
         («term_≠_» `y "≠" (num "0"))
         [(Tactic.location "at" (Tactic.locationHyp [`hy] []))])
        []
        (Tactic.tacticHave_
         "have"
         (Term.haveDecl
          (Term.haveIdDecl
           [`hy' []]
           [(Term.typeSpec
             ":"
             («term_≠_»
              (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
               "⟪"
               `y
               ", "
               `y
               "⟫")
              "≠"
              (num "0")))]
           ":="
           (Term.fun
            "fun"
            (Term.basicFun
             [`h]
             []
             "=>"
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Tactic.«tactic_<;>_»
                  (Tactic.rwSeq
                   "rw"
                   []
                   (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_self_eq_zero)] "]")
                   [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
                  "<;>"
                  (Tactic.exact "exact" (Term.app `hy [`h])))]))))))))
        []
        (Mathlib.Tactic.set
         "set"
         []
         (Mathlib.Tactic.setArgsRest
          `T
          []
          ":="
          («term_/_»
           (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
            "⟪"
            `y
            ", "
            `x
            "⟫")
           "/"
           (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
            "⟪"
            `y
            ", "
            `y
            "⟫"))
          ["with" [] `hT]))
        []
        (Tactic.tacticHave_
         "have"
         (Term.haveDecl
          (Term.haveIdDecl
           [`h₁ []]
           [(Term.typeSpec
             ":"
             («term_=_»
              (Term.app
               `re
               [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                 "⟪"
                 `y
                 ", "
                 `x
                 "⟫")])
              "="
              (Term.app
               `re
               [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                 "⟪"
                 `x
                 ", "
                 `y
                 "⟫")])))]
           ":="
           `inner_re_symm)))
        []
        (Tactic.tacticHave_
         "have"
         (Term.haveDecl
          (Term.haveIdDecl
           [`h₂ []]
           [(Term.typeSpec
             ":"
             («term_=_»
              (Term.app
               `im
               [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                 "⟪"
                 `y
                 ", "
                 `x
                 "⟫")])
              "="
              («term-_»
               "-"
               (Term.app
                `im
                [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                  "⟪"
                  `x
                  ", "
                  `y
                  "⟫")]))))]
           ":="
           `inner_im_symm)))
        []
        (Tactic.tacticHave_
         "have"
         (Term.haveDecl
          (Term.haveIdDecl
           [`h₃ []]
           [(Term.typeSpec
             ":"
             («term_=_»
              («term_/_»
               («term_*_»
                («term_*_»
                 (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                  "⟪"
                  `y
                  ", "
                  `x
                  "⟫")
                 "*"
                 (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                  "⟪"
                  `x
                  ", "
                  `y
                  "⟫"))
                "*"
                (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                 "⟪"
                 `y
                 ", "
                 `y
                 "⟫"))
               "/"
               («term_*_»
                (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                 "⟪"
                 `y
                 ", "
                 `y
                 "⟫")
                "*"
                (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                 "⟪"
                 `y
                 ", "
                 `y
                 "⟫")))
              "="
              («term_/_»
               («term_*_»
                (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                 "⟪"
                 `y
                 ", "
                 `x
                 "⟫")
                "*"
                (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                 "⟪"
                 `x
                 ", "
                 `y
                 "⟫"))
               "/"
               (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                "⟪"
                `y
                ", "
                `y
                "⟫"))))]
           ":="
           (Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.rwSeq
                "rw"
                []
                (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `mul_div_assoc)] "]")
                [])
               []
               (Tactic.tacticHave_
                "have"
                (Term.haveDecl
                 (Term.haveIdDecl
                  []
                  [(Term.typeSpec
                    ":"
                    («term_=_»
                     («term_/_»
                      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                       "⟪"
                       `y
                       ", "
                       `y
                       "⟫")
                      "/"
                      («term_*_»
                       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                        "⟪"
                        `y
                        ", "
                        `y
                        "⟫")
                       "*"
                       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                        "⟪"
                        `y
                        ", "
                        `y
                        "⟫")))
                     "="
                     («term_/_»
                      (num "1")
                      "/"
                      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                       "⟪"
                       `y
                       ", "
                       `y
                       "⟫"))))]
                  ":="
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(Tactic.rwSeq
                       "rw"
                       []
                       (Tactic.rwRuleSeq
                        "["
                        [(Tactic.rwRule [] `div_mul_eq_div_mul_one_div)
                         ","
                         (Tactic.rwRule [] (Term.app `div_self [`hy']))
                         ","
                         (Tactic.rwRule [] `one_mul)]
                        "]")
                       [])]))))))
               []
               (Tactic.rwSeq
                "rw"
                []
                (Tactic.rwRuleSeq
                 "["
                 [(Tactic.rwRule [] `this)
                  ","
                  (Tactic.rwRule [] `div_eq_mul_inv)
                  ","
                  (Tactic.rwRule [] `one_mul)
                  ","
                  (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `div_eq_mul_inv)]
                 "]")
                [])]))))))
        []
        (Tactic.tacticHave_
         "have"
         (Term.haveDecl
          (Term.haveIdDecl
           [`h₄ []]
           [(Term.typeSpec
             ":"
             («term_=_»
              (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
               "⟪"
               `y
               ", "
               `y
               "⟫")
              "="
              (Term.app
               `re
               [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                 "⟪"
                 `y
                 ", "
                 `y
                 "⟫")])))]
           ":="
           (Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.simp
                "simp"
                []
                []
                ["only"]
                ["[" [(Tactic.simpLemma [] [] `inner_self_re_to_K)] "]"]
                [])]))))))
        []
        (Tactic.tacticHave_
         "have"
         (Term.haveDecl
          (Term.haveIdDecl
           [`h₅ []]
           [(Term.typeSpec
             ":"
             («term_>_»
              (Term.app
               `re
               [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                 "⟪"
                 `y
                 ", "
                 `y
                 "⟫")])
              ">"
              (num "0")))]
           ":="
           (Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.refine'
                "refine'"
                (Term.app `lt_of_le_of_ne [`inner_self_nonneg (Term.hole "_")]))
               []
               (Tactic.intro "intro" [`H])
               []
               (Tactic.apply "apply" `hy')
               []
               (Tactic.rwSeq
                "rw"
                []
                (Tactic.rwRuleSeq
                 "["
                 [(Tactic.rwRule
                   []
                   (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.termext_iff
                    "ext_iff"))]
                 "]")
                [])
               []
               (Tactic.exact
                "exact"
                (Term.anonymousCtor
                 "⟨"
                 [(Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(Tactic.simp
                       "simp"
                       []
                       []
                       ["only"]
                       ["["
                        [(Tactic.simpLemma [] [] `H) "," (Tactic.simpLemma [] [] `zero_re')]
                        "]"]
                       [])])))
                  ","
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(Tactic.simp
                       "simp"
                       []
                       []
                       ["only"]
                       ["["
                        [(Tactic.simpLemma [] [] `inner_self_nonneg_im)
                         ","
                         (Tactic.simpLemma [] [] `AddMonoidHom.map_zero)]
                        "]"]
                       [])])))]
                 "⟩"))]))))))
        []
        (Tactic.tacticHave_
         "have"
         (Term.haveDecl
          (Term.haveIdDecl
           [`h₆ []]
           [(Term.typeSpec
             ":"
             («term_≠_»
              (Term.app
               `re
               [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                 "⟪"
                 `y
                 ", "
                 `y
                 "⟫")])
              "≠"
              (num "0")))]
           ":="
           (Term.app `ne_of_gt [`h₅]))))
        []
        (Tactic.tacticHave_
         "have"
         (Term.haveDecl
          (Term.haveIdDecl
           [`hmain []]
           []
           ":="
           (calc
            "calc"
            (calcStep
             («term_≤_»
              (num "0")
              "≤"
              (Term.app
               `re
               [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                 "⟪"
                 («term_-_» `x "-" (Algebra.Group.Defs.«term_•_» `T " • " `y))
                 ", "
                 («term_-_» `x "-" (Algebra.Group.Defs.«term_•_» `T " • " `y))
                 "⟫")]))
             ":="
             `inner_self_nonneg)
            [(calcStep
              («term_=_»
               (Term.hole "_")
               "="
               («term_+_»
                («term_-_»
                 («term_-_»
                  (Term.app
                   `re
                   [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     `x
                     ", "
                     `x
                     "⟫")])
                  "-"
                  (Term.app
                   `re
                   [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     (Algebra.Group.Defs.«term_•_» `T " • " `y)
                     ", "
                     `x
                     "⟫")]))
                 "-"
                 (Term.app
                  `re
                  [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                    "⟪"
                    `x
                    ", "
                    (Algebra.Group.Defs.«term_•_» `T " • " `y)
                    "⟫")]))
                "+"
                (Term.app
                 `re
                 [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                   "⟪"
                   (Algebra.Group.Defs.«term_•_» `T " • " `y)
                   ", "
                   (Algebra.Group.Defs.«term_•_» `T " • " `y)
                   "⟫")])))
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.simp
                   "simp"
                   []
                   []
                   ["only"]
                   ["["
                    [(Tactic.simpLemma [] [] `inner_sub_sub_self)
                     ","
                     (Tactic.simpLemma [] [] `inner_smul_left)
                     ","
                     (Tactic.simpLemma [] [] `inner_smul_right)
                     ","
                     (Tactic.simpLemma [] [] `h₁)
                     ","
                     (Tactic.simpLemma [] [] `h₂)
                     ","
                     (Tactic.simpLemma [] [] `neg_mul)
                     ","
                     (Tactic.simpLemma [] [] `AddMonoidHom.map_add)
                     ","
                     (Tactic.simpLemma [] [] `mul_re)
                     ","
                     (Tactic.simpLemma [] [] `conj_im)
                     ","
                     (Tactic.simpLemma [] [] `AddMonoidHom.map_sub)
                     ","
                     (Tactic.simpLemma [] [] `mul_neg)
                     ","
                     (Tactic.simpLemma [] [] `conj_re)
                     ","
                     (Tactic.simpLemma [] [] `neg_neg)]
                    "]"]
                   [])]))))
             (calcStep
              («term_=_»
               (Term.hole "_")
               "="
               («term_+_»
                («term_-_»
                 («term_-_»
                  (Term.app
                   `re
                   [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     `x
                     ", "
                     `x
                     "⟫")])
                  "-"
                  (Term.app
                   `re
                   [(«term_*_»
                     (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term_†» `T "†")
                     "*"
                     (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                      "⟪"
                      `y
                      ", "
                      `x
                      "⟫"))]))
                 "-"
                 (Term.app
                  `re
                  [(«term_*_»
                    `T
                    "*"
                    (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     `x
                     ", "
                     `y
                     "⟫"))]))
                "+"
                (Term.app
                 `re
                 [(«term_*_»
                   («term_*_»
                    `T
                    "*"
                    (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term_†» `T "†"))
                   "*"
                   (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                    "⟪"
                    `y
                    ", "
                    `y
                    "⟫"))])))
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.simp
                   "simp"
                   []
                   []
                   ["only"]
                   ["["
                    [(Tactic.simpLemma [] [] `inner_smul_left)
                     ","
                     (Tactic.simpLemma [] [] `inner_smul_right)
                     ","
                     (Tactic.simpLemma [] [] `mul_assoc)]
                    "]"]
                   [])]))))
             (calcStep
              («term_=_»
               (Term.hole "_")
               "="
               («term_-_»
                (Term.app
                 `re
                 [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                   "⟪"
                   `x
                   ", "
                   `x
                   "⟫")])
                "-"
                (Term.app
                 `re
                 [(«term_*_»
                   («term_/_»
                    (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     `x
                     ", "
                     `y
                     "⟫")
                    "/"
                    (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     `y
                     ", "
                     `y
                     "⟫"))
                   "*"
                   (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                    "⟪"
                    `y
                    ", "
                    `x
                    "⟫"))])))
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.fieldSimp
                   "field_simp"
                   []
                   []
                   []
                   [(Tactic.simpArgs
                     "["
                     [(Tactic.simpErase "-" `mul_re)
                      ","
                      (Tactic.simpLemma [] [] `inner_conj_sym)
                      ","
                      (Tactic.simpLemma [] [] `hT)
                      ","
                      (Tactic.simpLemma [] [] `map_div₀)
                      ","
                      (Tactic.simpLemma [] [] `h₁)
                      ","
                      (Tactic.simpLemma [] [] `h₃)]
                     "]")]
                   [])]))))
             (calcStep
              («term_=_»
               (Term.hole "_")
               "="
               («term_-_»
                (Term.app
                 `re
                 [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                   "⟪"
                   `x
                   ", "
                   `x
                   "⟫")])
                "-"
                (Term.app
                 `re
                 [(«term_/_»
                   («term_*_»
                    (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     `x
                     ", "
                     `y
                     "⟫")
                    "*"
                    (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     `y
                     ", "
                     `x
                     "⟫"))
                   "/"
                   (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                    "⟪"
                    `y
                    ", "
                    `y
                    "⟫"))])))
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.rwSeq
                   "rw"
                   []
                   (Tactic.rwRuleSeq
                    "["
                    [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `mul_div_right_comm)]
                    "]")
                   [])]))))
             (calcStep
              («term_=_»
               (Term.hole "_")
               "="
               («term_-_»
                (Term.app
                 `re
                 [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                   "⟪"
                   `x
                   ", "
                   `x
                   "⟫")])
                "-"
                (Term.app
                 `re
                 [(«term_/_»
                   («term_*_»
                    (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     `x
                     ", "
                     `y
                     "⟫")
                    "*"
                    (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     `y
                     ", "
                     `x
                     "⟫"))
                   "/"
                   (Term.app
                    `re
                    [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                      "⟪"
                      `y
                      ", "
                      `y
                      "⟫")]))])))
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Mathlib.Tactic.Conv.convLHS
                   "conv_lhs"
                   []
                   []
                   "=>"
                   (Tactic.Conv.convSeq
                    (Tactic.Conv.convSeq1Indented
                     [(Tactic.Conv.convRw__
                       "rw"
                       []
                       (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `h₄)] "]"))])))]))))
             (calcStep
              («term_=_»
               (Term.hole "_")
               "="
               («term_-_»
                (Term.app
                 `re
                 [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                   "⟪"
                   `x
                   ", "
                   `x
                   "⟫")])
                "-"
                («term_/_»
                 (Term.app
                  `re
                  [(«term_*_»
                    (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     `x
                     ", "
                     `y
                     "⟫")
                    "*"
                    (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     `y
                     ", "
                     `x
                     "⟫"))])
                 "/"
                 (Term.app
                  `re
                  [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                    "⟪"
                    `y
                    ", "
                    `y
                    "⟫")]))))
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.rwSeq
                   "rw"
                   []
                   (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `div_re_of_real)] "]")
                   [])]))))
             (calcStep
              («term_=_»
               (Term.hole "_")
               "="
               («term_-_»
                (Term.app
                 `re
                 [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                   "⟪"
                   `x
                   ", "
                   `x
                   "⟫")])
                "-"
                («term_/_»
                 (Term.app
                  `abs
                  [(«term_*_»
                    (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     `x
                     ", "
                     `y
                     "⟫")
                    "*"
                    (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     `y
                     ", "
                     `x
                     "⟫"))])
                 "/"
                 (Term.app
                  `re
                  [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                    "⟪"
                    `y
                    ", "
                    `y
                    "⟫")]))))
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.rwSeq
                   "rw"
                   []
                   (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_mul_conj_re_abs)] "]")
                   [])]))))
             (calcStep
              («term_=_»
               (Term.hole "_")
               "="
               («term_-_»
                (Term.app
                 `re
                 [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                   "⟪"
                   `x
                   ", "
                   `x
                   "⟫")])
                "-"
                («term_/_»
                 («term_*_»
                  (Term.app
                   `abs
                   [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     `x
                     ", "
                     `y
                     "⟫")])
                  "*"
                  (Term.app
                   `abs
                   [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     `y
                     ", "
                     `x
                     "⟫")]))
                 "/"
                 (Term.app
                  `re
                  [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                    "⟪"
                    `y
                    ", "
                    `y
                    "⟫")]))))
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.rwSeq
                   "rw"
                   []
                   (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `IsROrC.abs_mul)] "]")
                   [])]))))]))))
        []
        (Tactic.tacticHave_
         "have"
         (Term.haveDecl
          (Term.haveIdDecl
           [`hmain' []]
           [(Term.typeSpec
             ":"
             («term_≤_»
              («term_/_»
               («term_*_»
                (Term.app
                 `abs
                 [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                   "⟪"
                   `x
                   ", "
                   `y
                   "⟫")])
                "*"
                (Term.app
                 `abs
                 [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                   "⟪"
                   `y
                   ", "
                   `x
                   "⟫")]))
               "/"
               (Term.app
                `re
                [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                  "⟪"
                  `y
                  ", "
                  `y
                  "⟫")]))
              "≤"
              (Term.app
               `re
               [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                 "⟪"
                 `x
                 ", "
                 `x
                 "⟫")])))]
           ":="
           (Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented [(linarith "linarith" [] (linarithArgsRest [] [] []))]))))))
        []
        (Tactic.tacticHave_
         "have"
         (Term.haveDecl
          (Term.haveIdDecl
           []
           []
           ":="
           (Term.app (Term.proj (Term.app `mul_le_mul_right [`h₅]) "." `mpr) [`hmain']))))
        []
        (Std.Tactic.tacticRwa__
         "rwa"
         (Tactic.rwRuleSeq
          "["
          [(Tactic.rwRule
            []
            (Term.app
             `div_mul_cancel
             [(«term_*_»
               (Term.app
                `abs
                [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                  "⟪"
                  `x
                  ", "
                  `y
                  "⟫")])
               "*"
               (Term.app
                `abs
                [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                  "⟪"
                  `y
                  ", "
                  `x
                  "⟫")]))
              `h₆]))]
          "]")
         [(Tactic.location "at" (Tactic.locationHyp [`this] []))])])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Std.Tactic.tacticRwa__
       "rwa"
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule
          []
          (Term.app
           `div_mul_cancel
           [(«term_*_»
             (Term.app
              `abs
              [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                "⟪"
                `x
                ", "
                `y
                "⟫")])
             "*"
             (Term.app
              `abs
              [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                "⟪"
                `y
                ", "
                `x
                "⟫")]))
            `h₆]))]
        "]")
       [(Tactic.location "at" (Tactic.locationHyp [`this] []))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.locationHyp', expected 'Lean.Parser.Tactic.locationWildcard'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `this
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `div_mul_cancel
       [(«term_*_»
         (Term.app
          `abs
          [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
            "⟪"
            `x
            ", "
            `y
            "⟫")])
         "*"
         (Term.app
          `abs
          [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
            "⟪"
            `y
            ", "
            `x
            "⟫")]))
        `h₆])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h₆
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_*_»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_*_»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      («term_*_»
       (Term.app
        `abs
        [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          `x
          ", "
          `y
          "⟫")])
       "*"
       (Term.app
        `abs
        [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          `y
          ", "
          `x
          "⟫")]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `abs
       [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.598'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    **Cauchy–Schwarz inequality**. This proof follows "Proof 2" on Wikipedia.
    We need this for the `core` structure to prove the triangle inequality below when
    showing the core is a normed group.
    -/
  theorem
    inner_mul_inner_self_le
    ( x y : F ) : abs ⟪ x , y ⟫ * abs ⟪ y , x ⟫ ≤ re ⟪ x , x ⟫ * re ⟪ y , y ⟫
    :=
      by
        by_cases hy : y = 0
          ·
            rw [ hy ]
              simp only [ IsROrC.abs_zero , inner_zero_left , mul_zero , AddMonoidHom.map_zero ]
          ·
            change y ≠ 0 at hy
              have hy' : ⟪ y , y ⟫ ≠ 0 := fun h => by rw [ inner_self_eq_zero ] at h <;> exact hy h
              set T := ⟪ y , x ⟫ / ⟪ y , y ⟫ with hT
              have h₁ : re ⟪ y , x ⟫ = re ⟪ x , y ⟫ := inner_re_symm
              have h₂ : im ⟪ y , x ⟫ = - im ⟪ x , y ⟫ := inner_im_symm
              have
                h₃
                  :
                    ⟪ y , x ⟫ * ⟪ x , y ⟫ * ⟪ y , y ⟫ / ⟪ y , y ⟫ * ⟪ y , y ⟫
                      =
                      ⟪ y , x ⟫ * ⟪ x , y ⟫ / ⟪ y , y ⟫
                  :=
                  by
                    rw [ mul_div_assoc ]
                      have
                        : ⟪ y , y ⟫ / ⟪ y , y ⟫ * ⟪ y , y ⟫ = 1 / ⟪ y , y ⟫
                          :=
                          by rw [ div_mul_eq_div_mul_one_div , div_self hy' , one_mul ]
                      rw [ this , div_eq_mul_inv , one_mul , ← div_eq_mul_inv ]
              have h₄ : ⟪ y , y ⟫ = re ⟪ y , y ⟫ := by simp only [ inner_self_re_to_K ]
              have
                h₅
                  : re ⟪ y , y ⟫ > 0
                  :=
                  by
                    refine' lt_of_le_of_ne inner_self_nonneg _
                      intro H
                      apply hy'
                      rw [ ext_iff ]
                      exact
                        ⟨
                          by simp only [ H , zero_re' ]
                            ,
                            by simp only [ inner_self_nonneg_im , AddMonoidHom.map_zero ]
                          ⟩
              have h₆ : re ⟪ y , y ⟫ ≠ 0 := ne_of_gt h₅
              have
                hmain
                  :=
                  calc
                    0 ≤ re ⟪ x - T • y , x - T • y ⟫ := inner_self_nonneg
                    _ = re ⟪ x , x ⟫ - re ⟪ T • y , x ⟫ - re ⟪ x , T • y ⟫ + re ⟪ T • y , T • y ⟫
                        :=
                        by
                          simp
                            only
                            [
                              inner_sub_sub_self
                                ,
                                inner_smul_left
                                ,
                                inner_smul_right
                                ,
                                h₁
                                ,
                                h₂
                                ,
                                neg_mul
                                ,
                                AddMonoidHom.map_add
                                ,
                                mul_re
                                ,
                                conj_im
                                ,
                                AddMonoidHom.map_sub
                                ,
                                mul_neg
                                ,
                                conj_re
                                ,
                                neg_neg
                              ]
                      _
                          =
                          re ⟪ x , x ⟫ - re T † * ⟪ y , x ⟫ - re T * ⟪ x , y ⟫
                            +
                            re T * T † * ⟪ y , y ⟫
                        :=
                        by simp only [ inner_smul_left , inner_smul_right , mul_assoc ]
                      _ = re ⟪ x , x ⟫ - re ⟪ x , y ⟫ / ⟪ y , y ⟫ * ⟪ y , x ⟫
                        :=
                        by field_simp [ - mul_re , inner_conj_sym , hT , map_div₀ , h₁ , h₃ ]
                      _ = re ⟪ x , x ⟫ - re ⟪ x , y ⟫ * ⟪ y , x ⟫ / ⟪ y , y ⟫
                        :=
                        by rw [ ← mul_div_right_comm ]
                      _ = re ⟪ x , x ⟫ - re ⟪ x , y ⟫ * ⟪ y , x ⟫ / re ⟪ y , y ⟫
                        :=
                        by conv_lhs => rw [ h₄ ]
                      _ = re ⟪ x , x ⟫ - re ⟪ x , y ⟫ * ⟪ y , x ⟫ / re ⟪ y , y ⟫
                        :=
                        by rw [ div_re_of_real ]
                      _ = re ⟪ x , x ⟫ - abs ⟪ x , y ⟫ * ⟪ y , x ⟫ / re ⟪ y , y ⟫
                        :=
                        by rw [ inner_mul_conj_re_abs ]
                      _ = re ⟪ x , x ⟫ - abs ⟪ x , y ⟫ * abs ⟪ y , x ⟫ / re ⟪ y , y ⟫
                        :=
                        by rw [ IsROrC.abs_mul ]
              have
                hmain' : abs ⟪ x , y ⟫ * abs ⟪ y , x ⟫ / re ⟪ y , y ⟫ ≤ re ⟪ x , x ⟫ := by linarith
              have := mul_le_mul_right h₅ . mpr hmain'
              rwa [ div_mul_cancel abs ⟪ x , y ⟫ * abs ⟪ y , x ⟫ h₆ ] at this
#align
  inner_product_space.of_core.inner_mul_inner_self_le InnerProductSpace.OfCore.inner_mul_inner_self_le

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "Norm constructed from a `inner_product_space.core` structure, defined to be the square root\nof the scalar product. -/")]
      []
      []
      []
      []
      [])
     (Command.def
      "def"
      (Command.declId `toHasNorm [])
      (Command.optDeclSig [] [(Term.typeSpec ":" (Term.app `HasNorm [`F]))])
      (Command.whereStructInst
       "where"
       [(Command.whereStructField
         (Term.letDecl
          (Term.letIdDecl
           `norm
           [`x]
           []
           ":="
           (Term.app
            `sqrt
            [(Term.app
              `re
              [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                "⟪"
                `x
                ", "
                `x
                "⟫")])]))))]
       [])
      []
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.whereStructInst', expected 'Lean.Parser.Command.declValSimple'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.whereStructInst', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `sqrt
       [(Term.app
         `re
         [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           `x
           ", "
           `x
           "⟫")])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `re
       [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.598'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.letIdDecl', expected 'Lean.Parser.Term.letPatDecl'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.letIdDecl', expected 'Lean.Parser.Term.letEqnsDecl'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.theorem'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    Norm constructed from a `inner_product_space.core` structure, defined to be the square root
    of the scalar product. -/
  def toHasNorm : HasNorm F where norm x := sqrt re ⟪ x , x ⟫
#align inner_product_space.of_core.to_has_norm InnerProductSpace.OfCore.toHasNorm

attribute [local instance] to_has_norm

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `norm_eq_sqrt_inner [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x] [":" `F] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
         "="
         (Term.app
          `sqrt
          [(Term.app
            `re
            [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
              "⟪"
              `x
              ", "
              `x
              "⟫")])]))))
      (Command.declValSimple ":=" `rfl [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `rfl
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
       "="
       (Term.app
        `sqrt
        [(Term.app
          `re
          [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
            "⟪"
            `x
            ", "
            `x
            "⟫")])]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `sqrt
       [(Term.app
         `re
         [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           `x
           ", "
           `x
           "⟫")])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `re
       [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.598'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem norm_eq_sqrt_inner ( x : F ) : ‖ x ‖ = sqrt re ⟪ x , x ⟫ := rfl
#align inner_product_space.of_core.norm_eq_sqrt_inner InnerProductSpace.OfCore.norm_eq_sqrt_inner

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_self_eq_norm_mul_norm [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x] [":" `F] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.app
          `re
          [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
            "⟪"
            `x
            ", "
            `x
            "⟫")])
         "="
         («term_*_»
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
          "*"
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [] `norm_eq_sqrt_inner)
              ","
              (Tactic.rwRule
               [(patternIgnore (token.«← » "←"))]
               (Term.app
                `sqrt_mul
                [`inner_self_nonneg
                 (Term.app
                  `re
                  [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                    "⟪"
                    `x
                    ", "
                    `x
                    "⟫")])]))
              ","
              (Tactic.rwRule [] (Term.app `sqrt_mul_self [`inner_self_nonneg]))]
             "]")
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] `norm_eq_sqrt_inner)
             ","
             (Tactic.rwRule
              [(patternIgnore (token.«← » "←"))]
              (Term.app
               `sqrt_mul
               [`inner_self_nonneg
                (Term.app
                 `re
                 [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                   "⟪"
                   `x
                   ", "
                   `x
                   "⟫")])]))
             ","
             (Tactic.rwRule [] (Term.app `sqrt_mul_self [`inner_self_nonneg]))]
            "]")
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [] `norm_eq_sqrt_inner)
         ","
         (Tactic.rwRule
          [(patternIgnore (token.«← » "←"))]
          (Term.app
           `sqrt_mul
           [`inner_self_nonneg
            (Term.app
             `re
             [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
               "⟪"
               `x
               ", "
               `x
               "⟫")])]))
         ","
         (Tactic.rwRule [] (Term.app `sqrt_mul_self [`inner_self_nonneg]))]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `sqrt_mul_self [`inner_self_nonneg])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_self_nonneg
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `sqrt_mul_self
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `sqrt_mul
       [`inner_self_nonneg
        (Term.app
         `re
         [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           `x
           ", "
           `x
           "⟫")])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `re
       [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.598'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_self_eq_norm_mul_norm
  ( x : F ) : re ⟪ x , x ⟫ = ‖ x ‖ * ‖ x ‖
  :=
    by
      rw
        [
          norm_eq_sqrt_inner
            ,
            ← sqrt_mul inner_self_nonneg re ⟪ x , x ⟫
            ,
            sqrt_mul_self inner_self_nonneg
          ]
#align
  inner_product_space.of_core.inner_self_eq_norm_mul_norm InnerProductSpace.OfCore.inner_self_eq_norm_mul_norm

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `sqrt_norm_sq_eq_norm [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x] [":" `F] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.app
          `sqrt
          [(Term.app
            (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.termnorm_sqF "norm_sqF")
            [`x])])
         "="
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))))
      (Command.declValSimple ":=" `rfl [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `rfl
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Term.app
        `sqrt
        [(Term.app
          (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.termnorm_sqF "norm_sqF")
          [`x])])
       "="
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Term.app
       `sqrt
       [(Term.app
         (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.termnorm_sqF "norm_sqF")
         [`x])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.termnorm_sqF "norm_sqF")
       [`x])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.termnorm_sqF "norm_sqF")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.termnorm_sqF', expected 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.termnorm_sqF._@.Analysis.InnerProductSpace.Basic._hyg.869'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem sqrt_norm_sq_eq_norm { x : F } : sqrt norm_sqF x = ‖ x ‖ := rfl
#align
  inner_product_space.of_core.sqrt_norm_sq_eq_norm InnerProductSpace.OfCore.sqrt_norm_sq_eq_norm

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment "/--" "Cauchy–Schwarz inequality with norm -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `abs_inner_le_norm [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x `y] [":" `F] [] ")")]
       (Term.typeSpec
        ":"
        («term_≤_»
         (Term.app
          `abs
          [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
            "⟪"
            `x
            ", "
            `y
            "⟫")])
         "≤"
         («term_*_»
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
          "*"
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))))
      (Command.declValSimple
       ":="
       (Term.app
        `nonneg_le_nonneg_of_sq_le_sq
        [(Term.app
          `mul_nonneg
          [(Term.app `sqrt_nonneg [(Term.hole "_")]) (Term.app `sqrt_nonneg [(Term.hole "_")])])
         (Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(Tactic.tacticHave_
              "have"
              (Term.haveDecl
               (Term.haveIdDecl
                [`H []]
                [(Term.typeSpec
                  ":"
                  («term_=_»
                   («term_*_»
                    («term_*_»
                     (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                     "*"
                     (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
                    "*"
                    («term_*_»
                     (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                     "*"
                     (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
                   "="
                   («term_*_»
                    (Term.app
                     `re
                     [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                       "⟪"
                       `y
                       ", "
                       `y
                       "⟫")])
                    "*"
                    (Term.app
                     `re
                     [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                       "⟪"
                       `x
                       ", "
                       `x
                       "⟫")]))))]
                ":="
                (Term.byTactic
                 "by"
                 (Tactic.tacticSeq
                  (Tactic.tacticSeq1Indented
                   [(Tactic.simp
                     "simp"
                     []
                     []
                     ["only"]
                     ["[" [(Tactic.simpLemma [] [] `inner_self_eq_norm_mul_norm)] "]"]
                     [])
                    []
                    (Mathlib.Tactic.RingNF.ring "ring")]))))))
             []
             (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `H)] "]") [])
             []
             (Tactic.Conv.conv
              "conv"
              []
              []
              "=>"
              (Tactic.Conv.convSeq
               (Tactic.Conv.convSeq1Indented
                [(Tactic.Conv.lhs "lhs")
                 []
                 (Tactic.Conv.congr "congr")
                 []
                 (Tactic.Conv.convRw__
                  "rw"
                  []
                  (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_abs_conj_sym)] "]"))])))
             []
             (Tactic.exact "exact" (Term.app `inner_mul_inner_self_le [`y `x]))])))])
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `nonneg_le_nonneg_of_sq_le_sq
       [(Term.app
         `mul_nonneg
         [(Term.app `sqrt_nonneg [(Term.hole "_")]) (Term.app `sqrt_nonneg [(Term.hole "_")])])
        (Term.byTactic
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(Tactic.tacticHave_
             "have"
             (Term.haveDecl
              (Term.haveIdDecl
               [`H []]
               [(Term.typeSpec
                 ":"
                 («term_=_»
                  («term_*_»
                   («term_*_»
                    (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                    "*"
                    (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
                   "*"
                   («term_*_»
                    (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                    "*"
                    (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
                  "="
                  («term_*_»
                   (Term.app
                    `re
                    [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                      "⟪"
                      `y
                      ", "
                      `y
                      "⟫")])
                   "*"
                   (Term.app
                    `re
                    [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                      "⟪"
                      `x
                      ", "
                      `x
                      "⟫")]))))]
               ":="
               (Term.byTactic
                "by"
                (Tactic.tacticSeq
                 (Tactic.tacticSeq1Indented
                  [(Tactic.simp
                    "simp"
                    []
                    []
                    ["only"]
                    ["[" [(Tactic.simpLemma [] [] `inner_self_eq_norm_mul_norm)] "]"]
                    [])
                   []
                   (Mathlib.Tactic.RingNF.ring "ring")]))))))
            []
            (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `H)] "]") [])
            []
            (Tactic.Conv.conv
             "conv"
             []
             []
             "=>"
             (Tactic.Conv.convSeq
              (Tactic.Conv.convSeq1Indented
               [(Tactic.Conv.lhs "lhs")
                []
                (Tactic.Conv.congr "congr")
                []
                (Tactic.Conv.convRw__
                 "rw"
                 []
                 (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_abs_conj_sym)] "]"))])))
            []
            (Tactic.exact "exact" (Term.app `inner_mul_inner_self_le [`y `x]))])))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.byTactic', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.byTactic', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.tacticHave_
           "have"
           (Term.haveDecl
            (Term.haveIdDecl
             [`H []]
             [(Term.typeSpec
               ":"
               («term_=_»
                («term_*_»
                 («term_*_»
                  (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                  "*"
                  (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
                 "*"
                 («term_*_»
                  (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                  "*"
                  (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
                "="
                («term_*_»
                 (Term.app
                  `re
                  [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                    "⟪"
                    `y
                    ", "
                    `y
                    "⟫")])
                 "*"
                 (Term.app
                  `re
                  [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                    "⟪"
                    `x
                    ", "
                    `x
                    "⟫")]))))]
             ":="
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Tactic.simp
                  "simp"
                  []
                  []
                  ["only"]
                  ["[" [(Tactic.simpLemma [] [] `inner_self_eq_norm_mul_norm)] "]"]
                  [])
                 []
                 (Mathlib.Tactic.RingNF.ring "ring")]))))))
          []
          (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `H)] "]") [])
          []
          (Tactic.Conv.conv
           "conv"
           []
           []
           "=>"
           (Tactic.Conv.convSeq
            (Tactic.Conv.convSeq1Indented
             [(Tactic.Conv.lhs "lhs")
              []
              (Tactic.Conv.congr "congr")
              []
              (Tactic.Conv.convRw__
               "rw"
               []
               (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_abs_conj_sym)] "]"))])))
          []
          (Tactic.exact "exact" (Term.app `inner_mul_inner_self_le [`y `x]))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact "exact" (Term.app `inner_mul_inner_self_le [`y `x]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `inner_mul_inner_self_le [`y `x])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `y
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `inner_mul_inner_self_le
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.Conv.conv
       "conv"
       []
       []
       "=>"
       (Tactic.Conv.convSeq
        (Tactic.Conv.convSeq1Indented
         [(Tactic.Conv.lhs "lhs")
          []
          (Tactic.Conv.congr "congr")
          []
          (Tactic.Conv.convRw__
           "rw"
           []
           (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_abs_conj_sym)] "]"))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.Conv.convSeq1Indented', expected 'Lean.Parser.Tactic.Conv.convSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_abs_conj_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `H)] "]") [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `H
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.tacticHave_
       "have"
       (Term.haveDecl
        (Term.haveIdDecl
         [`H []]
         [(Term.typeSpec
           ":"
           («term_=_»
            («term_*_»
             («term_*_»
              (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
              "*"
              (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
             "*"
             («term_*_»
              (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
              "*"
              (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
            "="
            («term_*_»
             (Term.app
              `re
              [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                "⟪"
                `y
                ", "
                `y
                "⟫")])
             "*"
             (Term.app
              `re
              [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                "⟪"
                `x
                ", "
                `x
                "⟫")]))))]
         ":="
         (Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(Tactic.simp
              "simp"
              []
              []
              ["only"]
              ["[" [(Tactic.simpLemma [] [] `inner_self_eq_norm_mul_norm)] "]"]
              [])
             []
             (Mathlib.Tactic.RingNF.ring "ring")]))))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["[" [(Tactic.simpLemma [] [] `inner_self_eq_norm_mul_norm)] "]"]
           [])
          []
          (Mathlib.Tactic.RingNF.ring "ring")])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.RingNF.ring "ring")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["[" [(Tactic.simpLemma [] [] `inner_self_eq_norm_mul_norm)] "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_self_eq_norm_mul_norm
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_»
       («term_*_»
        («term_*_»
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
         "*"
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
        "*"
        («term_*_»
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
         "*"
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
       "="
       («term_*_»
        (Term.app
         `re
         [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           `y
           ", "
           `y
           "⟫")])
        "*"
        (Term.app
         `re
         [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           `x
           ", "
           `x
           "⟫")])))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (Term.app
        `re
        [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          `y
          ", "
          `y
          "⟫")])
       "*"
       (Term.app
        `re
        [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          `x
          ", "
          `x
          "⟫")]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `re
       [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.598'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.haveIdDecl', expected 'Lean.Parser.Term.letPatDecl'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.haveIdDecl', expected 'Lean.Parser.Term.haveEqnsDecl'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- Cauchy–Schwarz inequality with norm -/
  theorem
    abs_inner_le_norm
    ( x y : F ) : abs ⟪ x , y ⟫ ≤ ‖ x ‖ * ‖ y ‖
    :=
      nonneg_le_nonneg_of_sq_le_sq
        mul_nonneg sqrt_nonneg _ sqrt_nonneg _
          by
            have
                H
                  : ‖ x ‖ * ‖ y ‖ * ‖ x ‖ * ‖ y ‖ = re ⟪ y , y ⟫ * re ⟪ x , x ⟫
                  :=
                  by simp only [ inner_self_eq_norm_mul_norm ] ring
              rw [ H ]
              conv => lhs congr rw [ inner_abs_conj_sym ]
              exact inner_mul_inner_self_le y x
#align inner_product_space.of_core.abs_inner_le_norm InnerProductSpace.OfCore.abs_inner_le_norm

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "Normed group structure constructed from an `inner_product_space.core` structure -/")]
      []
      []
      []
      []
      [])
     (Command.def
      "def"
      (Command.declId `toNormedAddCommGroup [])
      (Command.optDeclSig [] [(Term.typeSpec ":" (Term.app `NormedAddCommGroup [`F]))])
      (Command.declValSimple
       ":="
       (Term.app
        `AddGroupNorm.toNormedAddCommGroup
        [(Term.structInst
          "{"
          []
          [(Term.structInstField
            (Term.structInstLVal `toFun [])
            ":="
            (Term.fun
             "fun"
             (Term.basicFun
              [`x]
              []
              "=>"
              (Term.app
               `sqrt
               [(Term.app
                 `re
                 [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                   "⟪"
                   `x
                   ", "
                   `x
                   "⟫")])]))))
           []
           (Term.structInstField
            (Term.structInstLVal `map_zero' [])
            ":="
            (Term.byTactic
             "by"
             (Tactic.tacticSeq
              (Tactic.tacticSeq1Indented
               [(Tactic.simp
                 "simp"
                 []
                 []
                 ["only"]
                 ["["
                  [(Tactic.simpLemma [] [] `sqrt_zero)
                   ","
                   (Tactic.simpLemma [] [] `inner_zero_right)
                   ","
                   (Tactic.simpLemma [] [] `map_zero)]
                  "]"]
                 [])]))))
           []
           (Term.structInstField
            (Term.structInstLVal `neg' [])
            ":="
            (Term.fun
             "fun"
             (Term.basicFun
              [`x]
              []
              "=>"
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.simp
                   "simp"
                   []
                   []
                   ["only"]
                   ["["
                    [(Tactic.simpLemma [] [] `inner_neg_left)
                     ","
                     (Tactic.simpLemma [] [] `neg_neg)
                     ","
                     (Tactic.simpLemma [] [] `inner_neg_right)]
                    "]"]
                   [])]))))))
           []
           (Term.structInstField
            (Term.structInstLVal `add_le' [])
            ":="
            (Term.fun
             "fun"
             (Term.basicFun
              [`x `y]
              []
              "=>"
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.tacticHave_
                   "have"
                   (Term.haveDecl
                    (Term.haveIdDecl
                     [`h₁ []]
                     [(Term.typeSpec
                       ":"
                       («term_≤_»
                        (Term.app
                         `abs
                         [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                           "⟪"
                           `x
                           ", "
                           `y
                           "⟫")])
                        "≤"
                        («term_*_»
                         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                         "*"
                         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))))]
                     ":="
                     (Term.app `abs_inner_le_norm [(Term.hole "_") (Term.hole "_")]))))
                  []
                  (Tactic.tacticHave_
                   "have"
                   (Term.haveDecl
                    (Term.haveIdDecl
                     [`h₂ []]
                     [(Term.typeSpec
                       ":"
                       («term_≤_»
                        (Term.app
                         `re
                         [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                           "⟪"
                           `x
                           ", "
                           `y
                           "⟫")])
                        "≤"
                        (Term.app
                         `abs
                         [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                           "⟪"
                           `x
                           ", "
                           `y
                           "⟫")])))]
                     ":="
                     (Term.app `re_le_abs [(Term.hole "_")]))))
                  []
                  (Tactic.tacticHave_
                   "have"
                   (Term.haveDecl
                    (Term.haveIdDecl
                     [`h₃ []]
                     [(Term.typeSpec
                       ":"
                       («term_≤_»
                        (Term.app
                         `re
                         [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                           "⟪"
                           `x
                           ", "
                           `y
                           "⟫")])
                        "≤"
                        («term_*_»
                         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                         "*"
                         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))))]
                     ":="
                     (Term.byTactic
                      "by"
                      (Tactic.tacticSeq
                       (Tactic.tacticSeq1Indented
                        [(linarith "linarith" [] (linarithArgsRest [] [] []))]))))))
                  []
                  (Tactic.tacticHave_
                   "have"
                   (Term.haveDecl
                    (Term.haveIdDecl
                     [`h₄ []]
                     [(Term.typeSpec
                       ":"
                       («term_≤_»
                        (Term.app
                         `re
                         [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                           "⟪"
                           `y
                           ", "
                           `x
                           "⟫")])
                        "≤"
                        («term_*_»
                         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                         "*"
                         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))))]
                     ":="
                     (Term.byTactic
                      "by"
                      (Tactic.tacticSeq
                       (Tactic.tacticSeq1Indented
                        [(Std.Tactic.tacticRwa__
                          "rwa"
                          (Tactic.rwRuleSeq
                           "["
                           [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
                            ","
                            (Tactic.rwRule [] `conj_re)]
                           "]")
                          [])]))))))
                  []
                  (Tactic.tacticHave_
                   "have"
                   (Term.haveDecl
                    (Term.haveIdDecl
                     []
                     [(Term.typeSpec
                       ":"
                       («term_≤_»
                        («term_*_»
                         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖")
                         "*"
                         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖"))
                        "≤"
                        («term_*_»
                         («term_+_»
                          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                          "+"
                          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
                         "*"
                         («term_+_»
                          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                          "+"
                          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))))]
                     ":="
                     (Term.byTactic
                      "by"
                      (Tactic.tacticSeq
                       (Tactic.tacticSeq1Indented
                        [(Tactic.simp
                          "simp"
                          []
                          []
                          ["only"]
                          ["["
                           [(Tactic.simpLemma
                             []
                             [(patternIgnore (token.«← » "←"))]
                             `inner_self_eq_norm_mul_norm)
                            ","
                            (Tactic.simpLemma [] [] `inner_add_add_self)
                            ","
                            (Tactic.simpLemma [] [] `mul_add)
                            ","
                            (Tactic.simpLemma [] [] `mul_comm)
                            ","
                            (Tactic.simpLemma [] [] `map_add)]
                           "]"]
                          [])
                         []
                         (linarith "linarith" [] (linarithArgsRest [] [] []))]))))))
                  []
                  (Tactic.exact
                   "exact"
                   (Term.app
                    `nonneg_le_nonneg_of_sq_le_sq
                    [(Term.app
                      `add_nonneg
                      [(Term.app `sqrt_nonneg [(Term.hole "_")])
                       (Term.app `sqrt_nonneg [(Term.hole "_")])])
                     `this]))]))))))
           []
           (Term.structInstField
            (Term.structInstLVal `eq_zero_of_map_eq_zero' [])
            ":="
            (Term.fun
             "fun"
             (Term.basicFun
              [`x `hx]
              []
              "=>"
              («term_<|_»
               (Term.proj
                (Term.typeAscription
                 "("
                 `inner_self_eq_zero
                 ":"
                 [(«term_↔_»
                   («term_=_»
                    (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     `x
                     ", "
                     `x
                     "⟫")
                    "="
                    (num "0"))
                   "↔"
                   («term_=_» `x "=" (num "0")))]
                 ")")
                "."
                (fieldIdx "1"))
               "<|"
               (Term.byTactic
                "by"
                (Tactic.tacticSeq
                 (Tactic.tacticSeq1Indented
                  [(Tactic.change
                    "change"
                    («term_=_»
                     (Term.app
                      `sqrt
                      [(Term.app
                        `re
                        [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                          "⟪"
                          `x
                          ", "
                          `x
                          "⟫")])])
                     "="
                     (num "0"))
                    [(Tactic.location "at" (Tactic.locationHyp [`hx] []))])
                   []
                   (Tactic.rwSeq
                    "rw"
                    []
                    (Tactic.rwRuleSeq
                     "["
                     [(Tactic.rwRule [] (Term.app `sqrt_eq_zero [`inner_self_nonneg]))]
                     "]")
                    [(Tactic.location "at" (Tactic.locationHyp [`hx] []))])
                   []
                   (Tactic.exact
                    "exact"
                    (Term.app
                     `ext
                     [(Term.byTactic
                       "by"
                       (Tactic.tacticSeq
                        (Tactic.tacticSeq1Indented
                         [(Tactic.simp
                           "simp"
                           []
                           []
                           []
                           ["[" [(Tactic.simpLemma [] [] `hx)] "]"]
                           [])])))
                      (Term.byTactic
                       "by"
                       (Tactic.tacticSeq
                        (Tactic.tacticSeq1Indented
                         [(Tactic.simp
                           "simp"
                           []
                           []
                           []
                           ["[" [(Tactic.simpLemma [] [] `inner_self_im_zero)] "]"]
                           [])])))]))])))))))]
          (Term.optEllipsis [])
          []
          "}")])
       [])
      []
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `AddGroupNorm.toNormedAddCommGroup
       [(Term.structInst
         "{"
         []
         [(Term.structInstField
           (Term.structInstLVal `toFun [])
           ":="
           (Term.fun
            "fun"
            (Term.basicFun
             [`x]
             []
             "=>"
             (Term.app
              `sqrt
              [(Term.app
                `re
                [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                  "⟪"
                  `x
                  ", "
                  `x
                  "⟫")])]))))
          []
          (Term.structInstField
           (Term.structInstLVal `map_zero' [])
           ":="
           (Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.simp
                "simp"
                []
                []
                ["only"]
                ["["
                 [(Tactic.simpLemma [] [] `sqrt_zero)
                  ","
                  (Tactic.simpLemma [] [] `inner_zero_right)
                  ","
                  (Tactic.simpLemma [] [] `map_zero)]
                 "]"]
                [])]))))
          []
          (Term.structInstField
           (Term.structInstLVal `neg' [])
           ":="
           (Term.fun
            "fun"
            (Term.basicFun
             [`x]
             []
             "=>"
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Tactic.simp
                  "simp"
                  []
                  []
                  ["only"]
                  ["["
                   [(Tactic.simpLemma [] [] `inner_neg_left)
                    ","
                    (Tactic.simpLemma [] [] `neg_neg)
                    ","
                    (Tactic.simpLemma [] [] `inner_neg_right)]
                   "]"]
                  [])]))))))
          []
          (Term.structInstField
           (Term.structInstLVal `add_le' [])
           ":="
           (Term.fun
            "fun"
            (Term.basicFun
             [`x `y]
             []
             "=>"
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Tactic.tacticHave_
                  "have"
                  (Term.haveDecl
                   (Term.haveIdDecl
                    [`h₁ []]
                    [(Term.typeSpec
                      ":"
                      («term_≤_»
                       (Term.app
                        `abs
                        [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                          "⟪"
                          `x
                          ", "
                          `y
                          "⟫")])
                       "≤"
                       («term_*_»
                        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                        "*"
                        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))))]
                    ":="
                    (Term.app `abs_inner_le_norm [(Term.hole "_") (Term.hole "_")]))))
                 []
                 (Tactic.tacticHave_
                  "have"
                  (Term.haveDecl
                   (Term.haveIdDecl
                    [`h₂ []]
                    [(Term.typeSpec
                      ":"
                      («term_≤_»
                       (Term.app
                        `re
                        [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                          "⟪"
                          `x
                          ", "
                          `y
                          "⟫")])
                       "≤"
                       (Term.app
                        `abs
                        [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                          "⟪"
                          `x
                          ", "
                          `y
                          "⟫")])))]
                    ":="
                    (Term.app `re_le_abs [(Term.hole "_")]))))
                 []
                 (Tactic.tacticHave_
                  "have"
                  (Term.haveDecl
                   (Term.haveIdDecl
                    [`h₃ []]
                    [(Term.typeSpec
                      ":"
                      («term_≤_»
                       (Term.app
                        `re
                        [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                          "⟪"
                          `x
                          ", "
                          `y
                          "⟫")])
                       "≤"
                       («term_*_»
                        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                        "*"
                        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))))]
                    ":="
                    (Term.byTactic
                     "by"
                     (Tactic.tacticSeq
                      (Tactic.tacticSeq1Indented
                       [(linarith "linarith" [] (linarithArgsRest [] [] []))]))))))
                 []
                 (Tactic.tacticHave_
                  "have"
                  (Term.haveDecl
                   (Term.haveIdDecl
                    [`h₄ []]
                    [(Term.typeSpec
                      ":"
                      («term_≤_»
                       (Term.app
                        `re
                        [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                          "⟪"
                          `y
                          ", "
                          `x
                          "⟫")])
                       "≤"
                       («term_*_»
                        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                        "*"
                        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))))]
                    ":="
                    (Term.byTactic
                     "by"
                     (Tactic.tacticSeq
                      (Tactic.tacticSeq1Indented
                       [(Std.Tactic.tacticRwa__
                         "rwa"
                         (Tactic.rwRuleSeq
                          "["
                          [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
                           ","
                           (Tactic.rwRule [] `conj_re)]
                          "]")
                         [])]))))))
                 []
                 (Tactic.tacticHave_
                  "have"
                  (Term.haveDecl
                   (Term.haveIdDecl
                    []
                    [(Term.typeSpec
                      ":"
                      («term_≤_»
                       («term_*_»
                        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖")
                        "*"
                        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖"))
                       "≤"
                       («term_*_»
                        («term_+_»
                         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                         "+"
                         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
                        "*"
                        («term_+_»
                         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                         "+"
                         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))))]
                    ":="
                    (Term.byTactic
                     "by"
                     (Tactic.tacticSeq
                      (Tactic.tacticSeq1Indented
                       [(Tactic.simp
                         "simp"
                         []
                         []
                         ["only"]
                         ["["
                          [(Tactic.simpLemma
                            []
                            [(patternIgnore (token.«← » "←"))]
                            `inner_self_eq_norm_mul_norm)
                           ","
                           (Tactic.simpLemma [] [] `inner_add_add_self)
                           ","
                           (Tactic.simpLemma [] [] `mul_add)
                           ","
                           (Tactic.simpLemma [] [] `mul_comm)
                           ","
                           (Tactic.simpLemma [] [] `map_add)]
                          "]"]
                         [])
                        []
                        (linarith "linarith" [] (linarithArgsRest [] [] []))]))))))
                 []
                 (Tactic.exact
                  "exact"
                  (Term.app
                   `nonneg_le_nonneg_of_sq_le_sq
                   [(Term.app
                     `add_nonneg
                     [(Term.app `sqrt_nonneg [(Term.hole "_")])
                      (Term.app `sqrt_nonneg [(Term.hole "_")])])
                    `this]))]))))))
          []
          (Term.structInstField
           (Term.structInstLVal `eq_zero_of_map_eq_zero' [])
           ":="
           (Term.fun
            "fun"
            (Term.basicFun
             [`x `hx]
             []
             "=>"
             («term_<|_»
              (Term.proj
               (Term.typeAscription
                "("
                `inner_self_eq_zero
                ":"
                [(«term_↔_»
                  («term_=_»
                   (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                    "⟪"
                    `x
                    ", "
                    `x
                    "⟫")
                   "="
                   (num "0"))
                  "↔"
                  («term_=_» `x "=" (num "0")))]
                ")")
               "."
               (fieldIdx "1"))
              "<|"
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.change
                   "change"
                   («term_=_»
                    (Term.app
                     `sqrt
                     [(Term.app
                       `re
                       [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                         "⟪"
                         `x
                         ", "
                         `x
                         "⟫")])])
                    "="
                    (num "0"))
                   [(Tactic.location "at" (Tactic.locationHyp [`hx] []))])
                  []
                  (Tactic.rwSeq
                   "rw"
                   []
                   (Tactic.rwRuleSeq
                    "["
                    [(Tactic.rwRule [] (Term.app `sqrt_eq_zero [`inner_self_nonneg]))]
                    "]")
                   [(Tactic.location "at" (Tactic.locationHyp [`hx] []))])
                  []
                  (Tactic.exact
                   "exact"
                   (Term.app
                    `ext
                    [(Term.byTactic
                      "by"
                      (Tactic.tacticSeq
                       (Tactic.tacticSeq1Indented
                        [(Tactic.simp
                          "simp"
                          []
                          []
                          []
                          ["[" [(Tactic.simpLemma [] [] `hx)] "]"]
                          [])])))
                     (Term.byTactic
                      "by"
                      (Tactic.tacticSeq
                       (Tactic.tacticSeq1Indented
                        [(Tactic.simp
                          "simp"
                          []
                          []
                          []
                          ["[" [(Tactic.simpLemma [] [] `inner_self_im_zero)] "]"]
                          [])])))]))])))))))]
         (Term.optEllipsis [])
         []
         "}")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInst', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInst', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.structInst
       "{"
       []
       [(Term.structInstField
         (Term.structInstLVal `toFun [])
         ":="
         (Term.fun
          "fun"
          (Term.basicFun
           [`x]
           []
           "=>"
           (Term.app
            `sqrt
            [(Term.app
              `re
              [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                "⟪"
                `x
                ", "
                `x
                "⟫")])]))))
        []
        (Term.structInstField
         (Term.structInstLVal `map_zero' [])
         ":="
         (Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(Tactic.simp
              "simp"
              []
              []
              ["only"]
              ["["
               [(Tactic.simpLemma [] [] `sqrt_zero)
                ","
                (Tactic.simpLemma [] [] `inner_zero_right)
                ","
                (Tactic.simpLemma [] [] `map_zero)]
               "]"]
              [])]))))
        []
        (Term.structInstField
         (Term.structInstLVal `neg' [])
         ":="
         (Term.fun
          "fun"
          (Term.basicFun
           [`x]
           []
           "=>"
           (Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.simp
                "simp"
                []
                []
                ["only"]
                ["["
                 [(Tactic.simpLemma [] [] `inner_neg_left)
                  ","
                  (Tactic.simpLemma [] [] `neg_neg)
                  ","
                  (Tactic.simpLemma [] [] `inner_neg_right)]
                 "]"]
                [])]))))))
        []
        (Term.structInstField
         (Term.structInstLVal `add_le' [])
         ":="
         (Term.fun
          "fun"
          (Term.basicFun
           [`x `y]
           []
           "=>"
           (Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.tacticHave_
                "have"
                (Term.haveDecl
                 (Term.haveIdDecl
                  [`h₁ []]
                  [(Term.typeSpec
                    ":"
                    («term_≤_»
                     (Term.app
                      `abs
                      [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                        "⟪"
                        `x
                        ", "
                        `y
                        "⟫")])
                     "≤"
                     («term_*_»
                      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                      "*"
                      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))))]
                  ":="
                  (Term.app `abs_inner_le_norm [(Term.hole "_") (Term.hole "_")]))))
               []
               (Tactic.tacticHave_
                "have"
                (Term.haveDecl
                 (Term.haveIdDecl
                  [`h₂ []]
                  [(Term.typeSpec
                    ":"
                    («term_≤_»
                     (Term.app
                      `re
                      [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                        "⟪"
                        `x
                        ", "
                        `y
                        "⟫")])
                     "≤"
                     (Term.app
                      `abs
                      [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                        "⟪"
                        `x
                        ", "
                        `y
                        "⟫")])))]
                  ":="
                  (Term.app `re_le_abs [(Term.hole "_")]))))
               []
               (Tactic.tacticHave_
                "have"
                (Term.haveDecl
                 (Term.haveIdDecl
                  [`h₃ []]
                  [(Term.typeSpec
                    ":"
                    («term_≤_»
                     (Term.app
                      `re
                      [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                        "⟪"
                        `x
                        ", "
                        `y
                        "⟫")])
                     "≤"
                     («term_*_»
                      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                      "*"
                      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))))]
                  ":="
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(linarith "linarith" [] (linarithArgsRest [] [] []))]))))))
               []
               (Tactic.tacticHave_
                "have"
                (Term.haveDecl
                 (Term.haveIdDecl
                  [`h₄ []]
                  [(Term.typeSpec
                    ":"
                    («term_≤_»
                     (Term.app
                      `re
                      [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                        "⟪"
                        `y
                        ", "
                        `x
                        "⟫")])
                     "≤"
                     («term_*_»
                      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                      "*"
                      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))))]
                  ":="
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(Std.Tactic.tacticRwa__
                       "rwa"
                       (Tactic.rwRuleSeq
                        "["
                        [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
                         ","
                         (Tactic.rwRule [] `conj_re)]
                        "]")
                       [])]))))))
               []
               (Tactic.tacticHave_
                "have"
                (Term.haveDecl
                 (Term.haveIdDecl
                  []
                  [(Term.typeSpec
                    ":"
                    («term_≤_»
                     («term_*_»
                      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖")
                      "*"
                      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖"))
                     "≤"
                     («term_*_»
                      («term_+_»
                       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                       "+"
                       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
                      "*"
                      («term_+_»
                       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                       "+"
                       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))))]
                  ":="
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(Tactic.simp
                       "simp"
                       []
                       []
                       ["only"]
                       ["["
                        [(Tactic.simpLemma
                          []
                          [(patternIgnore (token.«← » "←"))]
                          `inner_self_eq_norm_mul_norm)
                         ","
                         (Tactic.simpLemma [] [] `inner_add_add_self)
                         ","
                         (Tactic.simpLemma [] [] `mul_add)
                         ","
                         (Tactic.simpLemma [] [] `mul_comm)
                         ","
                         (Tactic.simpLemma [] [] `map_add)]
                        "]"]
                       [])
                      []
                      (linarith "linarith" [] (linarithArgsRest [] [] []))]))))))
               []
               (Tactic.exact
                "exact"
                (Term.app
                 `nonneg_le_nonneg_of_sq_le_sq
                 [(Term.app
                   `add_nonneg
                   [(Term.app `sqrt_nonneg [(Term.hole "_")])
                    (Term.app `sqrt_nonneg [(Term.hole "_")])])
                  `this]))]))))))
        []
        (Term.structInstField
         (Term.structInstLVal `eq_zero_of_map_eq_zero' [])
         ":="
         (Term.fun
          "fun"
          (Term.basicFun
           [`x `hx]
           []
           "=>"
           («term_<|_»
            (Term.proj
             (Term.typeAscription
              "("
              `inner_self_eq_zero
              ":"
              [(«term_↔_»
                («term_=_»
                 (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                  "⟪"
                  `x
                  ", "
                  `x
                  "⟫")
                 "="
                 (num "0"))
                "↔"
                («term_=_» `x "=" (num "0")))]
              ")")
             "."
             (fieldIdx "1"))
            "<|"
            (Term.byTactic
             "by"
             (Tactic.tacticSeq
              (Tactic.tacticSeq1Indented
               [(Tactic.change
                 "change"
                 («term_=_»
                  (Term.app
                   `sqrt
                   [(Term.app
                     `re
                     [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                       "⟪"
                       `x
                       ", "
                       `x
                       "⟫")])])
                  "="
                  (num "0"))
                 [(Tactic.location "at" (Tactic.locationHyp [`hx] []))])
                []
                (Tactic.rwSeq
                 "rw"
                 []
                 (Tactic.rwRuleSeq
                  "["
                  [(Tactic.rwRule [] (Term.app `sqrt_eq_zero [`inner_self_nonneg]))]
                  "]")
                 [(Tactic.location "at" (Tactic.locationHyp [`hx] []))])
                []
                (Tactic.exact
                 "exact"
                 (Term.app
                  `ext
                  [(Term.byTactic
                    "by"
                    (Tactic.tacticSeq
                     (Tactic.tacticSeq1Indented
                      [(Tactic.simp "simp" [] [] [] ["[" [(Tactic.simpLemma [] [] `hx)] "]"] [])])))
                   (Term.byTactic
                    "by"
                    (Tactic.tacticSeq
                     (Tactic.tacticSeq1Indented
                      [(Tactic.simp
                        "simp"
                        []
                        []
                        []
                        ["[" [(Tactic.simpLemma [] [] `inner_self_im_zero)] "]"]
                        [])])))]))])))))))]
       (Term.optEllipsis [])
       []
       "}")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstField', expected 'Lean.Parser.Term.structInstFieldAbbrev'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun
       "fun"
       (Term.basicFun
        [`x `hx]
        []
        "=>"
        («term_<|_»
         (Term.proj
          (Term.typeAscription
           "("
           `inner_self_eq_zero
           ":"
           [(«term_↔_»
             («term_=_»
              (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
               "⟪"
               `x
               ", "
               `x
               "⟫")
              "="
              (num "0"))
             "↔"
             («term_=_» `x "=" (num "0")))]
           ")")
          "."
          (fieldIdx "1"))
         "<|"
         (Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(Tactic.change
              "change"
              («term_=_»
               (Term.app
                `sqrt
                [(Term.app
                  `re
                  [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                    "⟪"
                    `x
                    ", "
                    `x
                    "⟫")])])
               "="
               (num "0"))
              [(Tactic.location "at" (Tactic.locationHyp [`hx] []))])
             []
             (Tactic.rwSeq
              "rw"
              []
              (Tactic.rwRuleSeq
               "["
               [(Tactic.rwRule [] (Term.app `sqrt_eq_zero [`inner_self_nonneg]))]
               "]")
              [(Tactic.location "at" (Tactic.locationHyp [`hx] []))])
             []
             (Tactic.exact
              "exact"
              (Term.app
               `ext
               [(Term.byTactic
                 "by"
                 (Tactic.tacticSeq
                  (Tactic.tacticSeq1Indented
                   [(Tactic.simp "simp" [] [] [] ["[" [(Tactic.simpLemma [] [] `hx)] "]"] [])])))
                (Term.byTactic
                 "by"
                 (Tactic.tacticSeq
                  (Tactic.tacticSeq1Indented
                   [(Tactic.simp
                     "simp"
                     []
                     []
                     []
                     ["[" [(Tactic.simpLemma [] [] `inner_self_im_zero)] "]"]
                     [])])))]))]))))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_<|_»
       (Term.proj
        (Term.typeAscription
         "("
         `inner_self_eq_zero
         ":"
         [(«term_↔_»
           («term_=_»
            (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             `x
             ", "
             `x
             "⟫")
            "="
            (num "0"))
           "↔"
           («term_=_» `x "=" (num "0")))]
         ")")
        "."
        (fieldIdx "1"))
       "<|"
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.change
            "change"
            («term_=_»
             (Term.app
              `sqrt
              [(Term.app
                `re
                [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                  "⟪"
                  `x
                  ", "
                  `x
                  "⟫")])])
             "="
             (num "0"))
            [(Tactic.location "at" (Tactic.locationHyp [`hx] []))])
           []
           (Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [] (Term.app `sqrt_eq_zero [`inner_self_nonneg]))]
             "]")
            [(Tactic.location "at" (Tactic.locationHyp [`hx] []))])
           []
           (Tactic.exact
            "exact"
            (Term.app
             `ext
             [(Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.simp "simp" [] [] [] ["[" [(Tactic.simpLemma [] [] `hx)] "]"] [])])))
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.simp
                   "simp"
                   []
                   []
                   []
                   ["[" [(Tactic.simpLemma [] [] `inner_self_im_zero)] "]"]
                   [])])))]))]))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.change
           "change"
           («term_=_»
            (Term.app
             `sqrt
             [(Term.app
               `re
               [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                 "⟪"
                 `x
                 ", "
                 `x
                 "⟫")])])
            "="
            (num "0"))
           [(Tactic.location "at" (Tactic.locationHyp [`hx] []))])
          []
          (Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] (Term.app `sqrt_eq_zero [`inner_self_nonneg]))]
            "]")
           [(Tactic.location "at" (Tactic.locationHyp [`hx] []))])
          []
          (Tactic.exact
           "exact"
           (Term.app
            `ext
            [(Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Tactic.simp "simp" [] [] [] ["[" [(Tactic.simpLemma [] [] `hx)] "]"] [])])))
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Tactic.simp
                  "simp"
                  []
                  []
                  []
                  ["[" [(Tactic.simpLemma [] [] `inner_self_im_zero)] "]"]
                  [])])))]))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact
       "exact"
       (Term.app
        `ext
        [(Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(Tactic.simp "simp" [] [] [] ["[" [(Tactic.simpLemma [] [] `hx)] "]"] [])])))
         (Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(Tactic.simp
              "simp"
              []
              []
              []
              ["[" [(Tactic.simpLemma [] [] `inner_self_im_zero)] "]"]
              [])])))]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `ext
       [(Term.byTactic
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(Tactic.simp "simp" [] [] [] ["[" [(Tactic.simpLemma [] [] `hx)] "]"] [])])))
        (Term.byTactic
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(Tactic.simp
             "simp"
             []
             []
             []
             ["[" [(Tactic.simpLemma [] [] `inner_self_im_zero)] "]"]
             [])])))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.byTactic', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.byTactic', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           []
           ["[" [(Tactic.simpLemma [] [] `inner_self_im_zero)] "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp "simp" [] [] [] ["[" [(Tactic.simpLemma [] [] `inner_self_im_zero)] "]"] [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_self_im_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 0,
     tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.byTactic
      "by"
      (Tactic.tacticSeq
       (Tactic.tacticSeq1Indented
        [(Tactic.simp
          "simp"
          []
          []
          []
          ["[" [(Tactic.simpLemma [] [] `inner_self_im_zero)] "]"]
          [])])))
     ")")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.byTactic', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.byTactic', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp "simp" [] [] [] ["[" [(Tactic.simpLemma [] [] `hx)] "]"] [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp "simp" [] [] [] ["[" [(Tactic.simpLemma [] [] `hx)] "]"] [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hx
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 0, tactic) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.byTactic
      "by"
      (Tactic.tacticSeq
       (Tactic.tacticSeq1Indented
        [(Tactic.simp "simp" [] [] [] ["[" [(Tactic.simpLemma [] [] `hx)] "]"] [])])))
     ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `ext
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] (Term.app `sqrt_eq_zero [`inner_self_nonneg]))] "]")
       [(Tactic.location "at" (Tactic.locationHyp [`hx] []))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.locationHyp', expected 'Lean.Parser.Tactic.locationWildcard'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hx
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `sqrt_eq_zero [`inner_self_nonneg])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_self_nonneg
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `sqrt_eq_zero
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.change
       "change"
       («term_=_»
        (Term.app
         `sqrt
         [(Term.app
           `re
           [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             `x
             ", "
             `x
             "⟫")])])
        "="
        (num "0"))
       [(Tactic.location "at" (Tactic.locationHyp [`hx] []))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.locationHyp', expected 'Lean.Parser.Tactic.locationWildcard'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hx
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_»
       (Term.app
        `sqrt
        [(Term.app
          `re
          [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
            "⟪"
            `x
            ", "
            `x
            "⟫")])])
       "="
       (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Term.app
       `sqrt
       [(Term.app
         `re
         [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           `x
           ", "
           `x
           "⟫")])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `re
       [(InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'InnerProductSpace.ofCore.Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.598'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.matchAlts'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.theorem'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- Normed group structure constructed from an `inner_product_space.core` structure -/
  def
    toNormedAddCommGroup
    : NormedAddCommGroup F
    :=
      AddGroupNorm.toNormedAddCommGroup
        {
          toFun := fun x => sqrt re ⟪ x , x ⟫
            map_zero' := by simp only [ sqrt_zero , inner_zero_right , map_zero ]
            neg' := fun x => by simp only [ inner_neg_left , neg_neg , inner_neg_right ]
            add_le'
              :=
              fun
                x y
                  =>
                  by
                    have h₁ : abs ⟪ x , y ⟫ ≤ ‖ x ‖ * ‖ y ‖ := abs_inner_le_norm _ _
                      have h₂ : re ⟪ x , y ⟫ ≤ abs ⟪ x , y ⟫ := re_le_abs _
                      have h₃ : re ⟪ x , y ⟫ ≤ ‖ x ‖ * ‖ y ‖ := by linarith
                      have
                        h₄ : re ⟪ y , x ⟫ ≤ ‖ x ‖ * ‖ y ‖ := by rwa [ ← inner_conj_sym , conj_re ]
                      have
                        : ‖ x + y ‖ * ‖ x + y ‖ ≤ ‖ x ‖ + ‖ y ‖ * ‖ x ‖ + ‖ y ‖
                          :=
                          by
                            simp
                                only
                                [
                                  ← inner_self_eq_norm_mul_norm
                                    ,
                                    inner_add_add_self
                                    ,
                                    mul_add
                                    ,
                                    mul_comm
                                    ,
                                    map_add
                                  ]
                              linarith
                      exact nonneg_le_nonneg_of_sq_le_sq add_nonneg sqrt_nonneg _ sqrt_nonneg _ this
            eq_zero_of_map_eq_zero'
              :=
              fun
                x hx
                  =>
                  ( inner_self_eq_zero : ⟪ x , x ⟫ = 0 ↔ x = 0 ) . 1
                    <|
                    by
                      change sqrt re ⟪ x , x ⟫ = 0 at hx
                        rw [ sqrt_eq_zero inner_self_nonneg ] at hx
                        exact ext by simp [ hx ] by simp [ inner_self_im_zero ]
          }
#align
  inner_product_space.of_core.to_normed_add_comm_group InnerProductSpace.OfCore.toNormedAddCommGroup

attribute [local instance] to_normed_add_comm_group

/-- Normed space structure constructed from a `inner_product_space.core` structure -/
def toNormedSpace : NormedSpace 𝕜 F
    where norm_smul_le r x :=
    by
    rw [norm_eq_sqrt_inner, inner_smul_left, inner_smul_right, ← mul_assoc]
    rw [conj_mul_eq_norm_sq_left, of_real_mul_re, sqrt_mul, ← inner_norm_sq_eq_inner_self,
      of_real_re]
    · simp [sqrt_norm_sq_eq_norm, IsROrC.sqrt_norm_sq_eq_norm]
    · exact norm_sq_nonneg r
#align inner_product_space.of_core.to_normed_space InnerProductSpace.OfCore.toNormedSpace

end InnerProductSpace.ofCore

/-- Given a `inner_product_space.core` structure on a space, one can use it to turn
the space into an inner product space, constructing the norm out of the inner product -/
def InnerProductSpace.ofCore [AddCommGroup F] [Module 𝕜 F] (c : InnerProductSpace.Core 𝕜 F) :
    InnerProductSpace 𝕜 F :=
  by
  letI : NormedAddCommGroup F := @InnerProductSpace.OfCore.toNormedAddCommGroup 𝕜 F _ _ _ c
  letI : NormedSpace 𝕜 F := @InnerProductSpace.OfCore.toNormedSpace 𝕜 F _ _ _ c
  exact
    { c with
      norm_sq_eq_inner := fun x =>
        by
        have h₁ : ‖x‖ ^ 2 = sqrt (re (c.inner x x)) ^ 2 := rfl
        have h₂ : 0 ≤ re (c.inner x x) := InnerProductSpace.OfCore.inner_self_nonneg
        simp [h₁, sq_sqrt, h₂] }
#align inner_product_space.of_core InnerProductSpace.ofCore

/-! ### Properties of inner product spaces -/


variable [InnerProductSpace 𝕜 E] [InnerProductSpace ℝ F]

variable [dec_E : DecidableEq E]

-- mathport name: «expr⟪ , ⟫»
local notation "⟪" x ", " y "⟫" => @inner 𝕜 _ _ x y

-- mathport name: exprIK
local notation "IK" => @IsROrC.i 𝕜 _

-- mathport name: exprabsR
local notation "absR" => Abs.abs

-- mathport name: exprabsK
local notation "absK" => @IsROrC.abs 𝕜 _

-- mathport name: «expr †»
local postfix:90 "†" => starRingEnd _

export InnerProductSpace (norm_sq_eq_inner)

section BasicProperties

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      []
      [(Term.attributes "@[" [(Term.attrInstance (Term.attrKind []) (Attr.simp "simp" [] []))] "]")]
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_conj_sym [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x `y] [":" `E] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term_†»
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")
          "†")
         "="
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))))
      (Command.declValSimple
       ":="
       (Term.app `InnerProductSpace.conj_sym [(Term.hole "_") (Term.hole "_")])
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `InnerProductSpace.conj_sym [(Term.hole "_") (Term.hole "_")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `InnerProductSpace.conj_sym
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term_†»
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")
        "†")
       "="
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
@[ simp ]
  theorem inner_conj_sym ( x y : E ) : ⟪ y , x ⟫ † = ⟪ x , y ⟫ := InnerProductSpace.conj_sym _ _
#align inner_conj_sym inner_conj_sym

theorem real_inner_comm (x y : F) : ⟪y, x⟫_ℝ = ⟪x, y⟫_ℝ :=
  @inner_conj_sym ℝ _ _ _ x y
#align real_inner_comm real_inner_comm

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_eq_zero_sym [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_↔_»
         («term_=_» (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫") "=" (num "0"))
         "↔"
         («term_=_»
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")
          "="
          (num "0")))))
      (Command.declValSimple
       ":="
       (Term.anonymousCtor
        "⟨"
        [(Term.fun
          "fun"
          (Term.basicFun
           [`h]
           []
           "=>"
           (Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.simp
                "simp"
                []
                []
                []
                ["["
                 [(Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
                  ","
                  (Tactic.simpLemma [] [] `h)]
                 "]"]
                [])])))))
         ","
         (Term.fun
          "fun"
          (Term.basicFun
           [`h]
           []
           "=>"
           (Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.simp
                "simp"
                []
                []
                []
                ["["
                 [(Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
                  ","
                  (Tactic.simpLemma [] [] `h)]
                 "]"]
                [])])))))]
        "⟩")
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.anonymousCtor
       "⟨"
       [(Term.fun
         "fun"
         (Term.basicFun
          [`h]
          []
          "=>"
          (Term.byTactic
           "by"
           (Tactic.tacticSeq
            (Tactic.tacticSeq1Indented
             [(Tactic.simp
               "simp"
               []
               []
               []
               ["["
                [(Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
                 ","
                 (Tactic.simpLemma [] [] `h)]
                "]"]
               [])])))))
        ","
        (Term.fun
         "fun"
         (Term.basicFun
          [`h]
          []
          "=>"
          (Term.byTactic
           "by"
           (Tactic.tacticSeq
            (Tactic.tacticSeq1Indented
             [(Tactic.simp
               "simp"
               []
               []
               []
               ["["
                [(Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
                 ","
                 (Tactic.simpLemma [] [] `h)]
                "]"]
               [])])))))]
       "⟩")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun
       "fun"
       (Term.basicFun
        [`h]
        []
        "=>"
        (Term.byTactic
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(Tactic.simp
             "simp"
             []
             []
             []
             ["["
              [(Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
               ","
               (Tactic.simpLemma [] [] `h)]
              "]"]
             [])])))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           []
           ["["
            [(Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
             ","
             (Tactic.simpLemma [] [] `h)]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       []
       ["["
        [(Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
         ","
         (Tactic.simpLemma [] [] `h)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_conj_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun
       "fun"
       (Term.basicFun
        [`h]
        []
        "=>"
        (Term.byTactic
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(Tactic.simp
             "simp"
             []
             []
             []
             ["["
              [(Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
               ","
               (Tactic.simpLemma [] [] `h)]
              "]"]
             [])])))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           []
           ["["
            [(Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
             ","
             (Tactic.simpLemma [] [] `h)]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       []
       ["["
        [(Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
         ","
         (Tactic.simpLemma [] [] `h)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_conj_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_↔_»
       («term_=_» (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫") "=" (num "0"))
       "↔"
       («term_=_» (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫") "=" (num "0")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_» (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫") "=" (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_eq_zero_sym
  { x y : E } : ⟪ x , y ⟫ = 0 ↔ ⟪ y , x ⟫ = 0
  := ⟨ fun h => by simp [ ← inner_conj_sym , h ] , fun h => by simp [ ← inner_conj_sym , h ] ⟩
#align inner_eq_zero_sym inner_eq_zero_sym

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      []
      [(Term.attributes "@[" [(Term.attrInstance (Term.attrKind []) (Attr.simp "simp" [] []))] "]")]
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_self_nonneg_im [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.app `im [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
         "="
         (num "0"))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.«tactic_<;>_»
            (Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq
              "["
              [(Tactic.rwRule
                [(patternIgnore (token.«← » "←"))]
                (Term.app (Term.explicit "@" `of_real_inj) [`𝕜]))
               ","
               (Tactic.rwRule [] `im_eq_conj_sub)]
              "]")
             [])
            "<;>"
            (Tactic.simp "simp" [] [] [] [] []))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.«tactic_<;>_»
           (Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule
               [(patternIgnore (token.«← » "←"))]
               (Term.app (Term.explicit "@" `of_real_inj) [`𝕜]))
              ","
              (Tactic.rwRule [] `im_eq_conj_sub)]
             "]")
            [])
           "<;>"
           (Tactic.simp "simp" [] [] [] [] []))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.«tactic_<;>_»
       (Tactic.rwSeq
        "rw"
        []
        (Tactic.rwRuleSeq
         "["
         [(Tactic.rwRule
           [(patternIgnore (token.«← » "←"))]
           (Term.app (Term.explicit "@" `of_real_inj) [`𝕜]))
          ","
          (Tactic.rwRule [] `im_eq_conj_sub)]
         "]")
        [])
       "<;>"
       (Tactic.simp "simp" [] [] [] [] []))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp "simp" [] [] [] [] [])
[PrettyPrinter.parenthesize] ...precedences are 2 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1, tactic))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule
          [(patternIgnore (token.«← » "←"))]
          (Term.app (Term.explicit "@" `of_real_inj) [`𝕜]))
         ","
         (Tactic.rwRule [] `im_eq_conj_sub)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `im_eq_conj_sub
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app (Term.explicit "@" `of_real_inj) [`𝕜])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `𝕜
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.explicit "@" `of_real_inj)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `of_real_inj
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (some 1024,
     term) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Term.app `im [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
       "="
       (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Term.app `im [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
@[ simp ]
  theorem
    inner_self_nonneg_im
    { x : E } : im ⟪ x , x ⟫ = 0
    := by rw [ ← @ of_real_inj 𝕜 , im_eq_conj_sub ] <;> simp
#align inner_self_nonneg_im inner_self_nonneg_im

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_self_im_zero [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.app `im [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
         "="
         (num "0"))))
      (Command.declValSimple ":=" `inner_self_nonneg_im [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_self_nonneg_im
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Term.app `im [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
       "="
       (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Term.app `im [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem inner_self_im_zero { x : E } : im ⟪ x , x ⟫ = 0 := inner_self_nonneg_im
#align inner_self_im_zero inner_self_im_zero

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_add_left [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y `z] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" («term_+_» `x "+" `y) ", " `z "⟫")
         "="
         («term_+_»
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `z "⟫")
          "+"
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `z "⟫")))))
      (Command.declValSimple
       ":="
       (Term.app `InnerProductSpace.add_left [(Term.hole "_") (Term.hole "_") (Term.hole "_")])
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `InnerProductSpace.add_left [(Term.hole "_") (Term.hole "_") (Term.hole "_")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `InnerProductSpace.add_left
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" («term_+_» `x "+" `y) ", " `z "⟫")
       "="
       («term_+_»
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `z "⟫")
        "+"
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `z "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_+_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `z "⟫")
       "+"
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `z "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `z "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_add_left
  { x y z : E } : ⟪ x + y , z ⟫ = ⟪ x , z ⟫ + ⟪ y , z ⟫
  := InnerProductSpace.add_left _ _ _
#align inner_add_left inner_add_left

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_add_right [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y `z] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " («term_+_» `y "+" `z) "⟫")
         "="
         («term_+_»
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
          "+"
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `z "⟫")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
              ","
              (Tactic.rwRule [] `inner_add_left)
              ","
              (Tactic.rwRule [] `RingHom.map_add)]
             "]")
            [])
           []
           (Tactic.simp
            "simp"
            []
            []
            ["only"]
            ["[" [(Tactic.simpLemma [] [] `inner_conj_sym)] "]"]
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
             ","
             (Tactic.rwRule [] `inner_add_left)
             ","
             (Tactic.rwRule [] `RingHom.map_add)]
            "]")
           [])
          []
          (Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["[" [(Tactic.simpLemma [] [] `inner_conj_sym)] "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp "simp" [] [] ["only"] ["[" [(Tactic.simpLemma [] [] `inner_conj_sym)] "]"] [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_conj_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
         ","
         (Tactic.rwRule [] `inner_add_left)
         ","
         (Tactic.rwRule [] `RingHom.map_add)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `RingHom.map_add
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_add_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_conj_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " («term_+_» `y "+" `z) "⟫")
       "="
       («term_+_»
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
        "+"
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `z "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_+_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
       "+"
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `z "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `z "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_add_right
  { x y z : E } : ⟪ x , y + z ⟫ = ⟪ x , y ⟫ + ⟪ x , z ⟫
  := by rw [ ← inner_conj_sym , inner_add_left , RingHom.map_add ] simp only [ inner_conj_sym ]
#align inner_add_right inner_add_right

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_re_symm [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
         "="
         (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")]))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
              ","
              (Tactic.rwRule [] `conj_re)]
             "]")
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
             ","
             (Tactic.rwRule [] `conj_re)]
            "]")
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
         ","
         (Tactic.rwRule [] `conj_re)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `conj_re
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_conj_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
       "="
       (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_re_symm
  { x y : E } : re ⟪ x , y ⟫ = re ⟪ y , x ⟫
  := by rw [ ← inner_conj_sym , conj_re ]
#align inner_re_symm inner_re_symm

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_im_symm [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.app `im [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
         "="
         («term-_»
          "-"
          (Term.app `im [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")])))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
              ","
              (Tactic.rwRule [] `conj_im)]
             "]")
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
             ","
             (Tactic.rwRule [] `conj_im)]
            "]")
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
         ","
         (Tactic.rwRule [] `conj_im)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `conj_im
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_conj_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Term.app `im [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
       "="
       («term-_»
        "-"
        (Term.app `im [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")])))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term-_»
       "-"
       (Term.app `im [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `im [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_im_symm
  { x y : E } : im ⟪ x , y ⟫ = - im ⟪ y , x ⟫
  := by rw [ ← inner_conj_sym , conj_im ]
#align inner_im_symm inner_im_symm

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_smul_left [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `E] "}") (Term.implicitBinder "{" [`r] [":" `𝕜] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (Algebra.Group.Defs.«term_•_» `r " • " `x)
          ", "
          `y
          "⟫")
         "="
         («term_*_»
          (Analysis.InnerProductSpace.Basic.«term_†» `r "†")
          "*"
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")))))
      (Command.declValSimple
       ":="
       (Term.app `InnerProductSpace.smul_left [(Term.hole "_") (Term.hole "_") (Term.hole "_")])
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `InnerProductSpace.smul_left [(Term.hole "_") (Term.hole "_") (Term.hole "_")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `InnerProductSpace.smul_left
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        (Algebra.Group.Defs.«term_•_» `r " • " `x)
        ", "
        `y
        "⟫")
       "="
       («term_*_»
        (Analysis.InnerProductSpace.Basic.«term_†» `r "†")
        "*"
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (Analysis.InnerProductSpace.Basic.«term_†» `r "†")
       "*"
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_smul_left
  { x y : E } { r : 𝕜 } : ⟪ r • x , y ⟫ = r † * ⟪ x , y ⟫
  := InnerProductSpace.smul_left _ _ _
#align inner_smul_left inner_smul_left

theorem real_inner_smul_left {x y : F} {r : ℝ} : ⟪r • x, y⟫_ℝ = r * ⟪x, y⟫_ℝ :=
  inner_smul_left
#align real_inner_smul_left real_inner_smul_left

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_smul_real_left [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `E] "}")
        (Term.implicitBinder "{" [`r] [":" (Data.Real.Basic.termℝ "ℝ")] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (Algebra.Group.Defs.«term_•_» (Term.typeAscription "(" `r ":" [`𝕜] ")") " • " `x)
          ", "
          `y
          "⟫")
         "="
         (Algebra.Group.Defs.«term_•_»
          `r
          " • "
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [] `inner_smul_left)
              ","
              (Tactic.rwRule [] `conj_of_real)
              ","
              (Tactic.rwRule [] `Algebra.smul_def)]
             "]")
            [])
           []
           (Tactic.tacticRfl "rfl")])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] `inner_smul_left)
             ","
             (Tactic.rwRule [] `conj_of_real)
             ","
             (Tactic.rwRule [] `Algebra.smul_def)]
            "]")
           [])
          []
          (Tactic.tacticRfl "rfl")])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.tacticRfl "rfl")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [] `inner_smul_left)
         ","
         (Tactic.rwRule [] `conj_of_real)
         ","
         (Tactic.rwRule [] `Algebra.smul_def)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Algebra.smul_def
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `conj_of_real
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_smul_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        (Algebra.Group.Defs.«term_•_» (Term.typeAscription "(" `r ":" [`𝕜] ")") " • " `x)
        ", "
        `y
        "⟫")
       "="
       (Algebra.Group.Defs.«term_•_»
        `r
        " • "
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Algebra.Group.Defs.«term_•_»
       `r
       " • "
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_smul_real_left
  { x y : E } { r : ℝ } : ⟪ ( r : 𝕜 ) • x , y ⟫ = r • ⟪ x , y ⟫
  := by rw [ inner_smul_left , conj_of_real , Algebra.smul_def ] rfl
#align inner_smul_real_left inner_smul_real_left

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_smul_right [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `E] "}") (Term.implicitBinder "{" [`r] [":" `𝕜] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          `x
          ", "
          (Algebra.Group.Defs.«term_•_» `r " • " `y)
          "⟫")
         "="
         («term_*_» `r "*" (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
              ","
              (Tactic.rwRule [] `inner_smul_left)
              ","
              (Tactic.rwRule [] `RingHom.map_mul)
              ","
              (Tactic.rwRule [] `conj_conj)
              ","
              (Tactic.rwRule [] `inner_conj_sym)]
             "]")
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
             ","
             (Tactic.rwRule [] `inner_smul_left)
             ","
             (Tactic.rwRule [] `RingHom.map_mul)
             ","
             (Tactic.rwRule [] `conj_conj)
             ","
             (Tactic.rwRule [] `inner_conj_sym)]
            "]")
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
         ","
         (Tactic.rwRule [] `inner_smul_left)
         ","
         (Tactic.rwRule [] `RingHom.map_mul)
         ","
         (Tactic.rwRule [] `conj_conj)
         ","
         (Tactic.rwRule [] `inner_conj_sym)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_conj_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `conj_conj
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `RingHom.map_mul
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_smul_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_conj_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        `x
        ", "
        (Algebra.Group.Defs.«term_•_» `r " • " `y)
        "⟫")
       "="
       («term_*_» `r "*" (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_» `r "*" (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_smul_right
  { x y : E } { r : 𝕜 } : ⟪ x , r • y ⟫ = r * ⟪ x , y ⟫
  := by rw [ ← inner_conj_sym , inner_smul_left , RingHom.map_mul , conj_conj , inner_conj_sym ]
#align inner_smul_right inner_smul_right

theorem real_inner_smul_right {x y : F} {r : ℝ} : ⟪x, r • y⟫_ℝ = r * ⟪x, y⟫_ℝ :=
  inner_smul_right
#align real_inner_smul_right real_inner_smul_right

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_smul_real_right [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `E] "}")
        (Term.implicitBinder "{" [`r] [":" (Data.Real.Basic.termℝ "ℝ")] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          `x
          ", "
          (Algebra.Group.Defs.«term_•_» (Term.typeAscription "(" `r ":" [`𝕜] ")") " • " `y)
          "⟫")
         "="
         (Algebra.Group.Defs.«term_•_»
          `r
          " • "
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [] `inner_smul_right) "," (Tactic.rwRule [] `Algebra.smul_def)]
             "]")
            [])
           []
           (Tactic.tacticRfl "rfl")])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] `inner_smul_right) "," (Tactic.rwRule [] `Algebra.smul_def)]
            "]")
           [])
          []
          (Tactic.tacticRfl "rfl")])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.tacticRfl "rfl")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [] `inner_smul_right) "," (Tactic.rwRule [] `Algebra.smul_def)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Algebra.smul_def
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_smul_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        `x
        ", "
        (Algebra.Group.Defs.«term_•_» (Term.typeAscription "(" `r ":" [`𝕜] ")") " • " `y)
        "⟫")
       "="
       (Algebra.Group.Defs.«term_•_»
        `r
        " • "
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Algebra.Group.Defs.«term_•_»
       `r
       " • "
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_smul_real_right
  { x y : E } { r : ℝ } : ⟪ x , ( r : 𝕜 ) • y ⟫ = r • ⟪ x , y ⟫
  := by rw [ inner_smul_right , Algebra.smul_def ] rfl
#align inner_smul_real_right inner_smul_real_right

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "The inner product as a sesquilinear form.\n\nNote that in the case `𝕜 = ℝ` this is a bilinear form. -/")]
      [(Term.attributes
        "@["
        [(Term.attrInstance (Term.attrKind []) (Attr.simps "simps" [] (Attr.simpsArgsRest [] [])))]
        "]")]
      []
      []
      []
      [])
     (Command.def
      "def"
      (Command.declId `sesqFormOfInner [])
      (Command.optDeclSig
       []
       [(Term.typeSpec
         ":"
         (Algebra.Module.LinearMap.«term_→ₗ[_]_»
          `E
          " →ₗ["
          `𝕜
          "] "
          (Algebra.Module.LinearMap.«term_→ₗ⋆[_]_» `E " →ₗ⋆[" `𝕜 "] " `𝕜)))])
      (Command.declValSimple
       ":="
       (Term.app
        `LinearMap.mk₂'ₛₗ
        [(Term.app `RingHom.id [`𝕜])
         (Term.app `starRingEnd [(Term.hole "_")])
         (Term.fun
          "fun"
          (Term.basicFun
           [`x `y]
           []
           "=>"
           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")))
         (Term.fun "fun" (Term.basicFun [`x `y `z] [] "=>" `inner_add_right))
         (Term.fun "fun" (Term.basicFun [`r `x `y] [] "=>" `inner_smul_right))
         (Term.fun "fun" (Term.basicFun [`x `y `z] [] "=>" `inner_add_left))
         (Term.fun "fun" (Term.basicFun [`r `x `y] [] "=>" `inner_smul_left))])
       [])
      []
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `LinearMap.mk₂'ₛₗ
       [(Term.app `RingHom.id [`𝕜])
        (Term.app `starRingEnd [(Term.hole "_")])
        (Term.fun
         "fun"
         (Term.basicFun
          [`x `y]
          []
          "=>"
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")))
        (Term.fun "fun" (Term.basicFun [`x `y `z] [] "=>" `inner_add_right))
        (Term.fun "fun" (Term.basicFun [`r `x `y] [] "=>" `inner_smul_right))
        (Term.fun "fun" (Term.basicFun [`x `y `z] [] "=>" `inner_add_left))
        (Term.fun "fun" (Term.basicFun [`r `x `y] [] "=>" `inner_smul_left))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun "fun" (Term.basicFun [`r `x `y] [] "=>" `inner_smul_left))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_smul_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `r
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.fun "fun" (Term.basicFun [`x `y `z] [] "=>" `inner_add_left))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_add_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `z
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `y
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (some 0, term) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.fun "fun" (Term.basicFun [`x `y `z] [] "=>" `inner_add_left))
     ")")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.fun "fun" (Term.basicFun [`r `x `y] [] "=>" `inner_smul_right))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_smul_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `r
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (some 0, term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.fun "fun" (Term.basicFun [`r `x `y] [] "=>" `inner_smul_right))
     ")")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.fun "fun" (Term.basicFun [`x `y `z] [] "=>" `inner_add_right))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_add_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `z
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `y
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (some 0, term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.fun "fun" (Term.basicFun [`x `y `z] [] "=>" `inner_add_right))
     ")")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.fun
       "fun"
       (Term.basicFun
        [`x `y]
        []
        "=>"
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.matchAlts'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.theorem'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
      The inner product as a sesquilinear form.
      
      Note that in the case `𝕜 = ℝ` this is a bilinear form. -/
    @[ simps ]
  def
    sesqFormOfInner
    : E →ₗ[ 𝕜 ] E →ₗ⋆[ 𝕜 ] 𝕜
    :=
      LinearMap.mk₂'ₛₗ
        RingHom.id 𝕜
          starRingEnd _
          fun x y => ⟪ y , x ⟫
          fun x y z => inner_add_right
          fun r x y => inner_smul_right
          fun x y z => inner_add_left
          fun r x y => inner_smul_left
#align sesq_form_of_inner sesqFormOfInner

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment "/--" "An inner product with a sum on the left. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `sum_inner [])
      (Command.declSig
       [(Term.implicitBinder "{" [`ι] [":" (Term.type "Type" [(Level.hole "_")])] "}")
        (Term.explicitBinder "(" [`s] [":" (Term.app `Finset [`ι])] [] ")")
        (Term.explicitBinder "(" [`f] [":" (Term.arrow `ι "→" `E)] [] ")")
        (Term.explicitBinder "(" [`x] [":" `E] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (BigOperators.Algebra.BigOperators.Basic.finset.sum
           "∑"
           (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
           " in "
           `s
           ", "
           (Term.app `f [`i]))
          ", "
          `x
          "⟫")
         "="
         (BigOperators.Algebra.BigOperators.Basic.finset.sum
          "∑"
          (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
          " in "
          `s
          ", "
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `f [`i]) ", " `x "⟫")))))
      (Command.declValSimple ":=" (Term.proj (Term.app `sesqFormOfInner [`x]) "." `map_sum) [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.proj (Term.app `sesqFormOfInner [`x]) "." `map_sum)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.app `sesqFormOfInner [`x])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `sesqFormOfInner
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `sesqFormOfInner [`x]) ")")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        (BigOperators.Algebra.BigOperators.Basic.finset.sum
         "∑"
         (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
         " in "
         `s
         ", "
         (Term.app `f [`i]))
        ", "
        `x
        "⟫")
       "="
       (BigOperators.Algebra.BigOperators.Basic.finset.sum
        "∑"
        (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
        " in "
        `s
        ", "
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `f [`i]) ", " `x "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (BigOperators.Algebra.BigOperators.Basic.finset.sum
       "∑"
       (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
       " in "
       `s
       ", "
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `f [`i]) ", " `x "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `f [`i]) ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- An inner product with a sum on the left. -/
  theorem
    sum_inner
    { ι : Type _ } ( s : Finset ι ) ( f : ι → E ) ( x : E )
      : ⟪ ∑ i in s , f i , x ⟫ = ∑ i in s , ⟪ f i , x ⟫
    := sesqFormOfInner x . map_sum
#align sum_inner sum_inner

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment "/--" "An inner product with a sum on the right. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_sum [])
      (Command.declSig
       [(Term.implicitBinder "{" [`ι] [":" (Term.type "Type" [(Level.hole "_")])] "}")
        (Term.explicitBinder "(" [`s] [":" (Term.app `Finset [`ι])] [] ")")
        (Term.explicitBinder "(" [`f] [":" (Term.arrow `ι "→" `E)] [] ")")
        (Term.explicitBinder "(" [`x] [":" `E] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          `x
          ", "
          (BigOperators.Algebra.BigOperators.Basic.finset.sum
           "∑"
           (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
           " in "
           `s
           ", "
           (Term.app `f [`i]))
          "⟫")
         "="
         (BigOperators.Algebra.BigOperators.Basic.finset.sum
          "∑"
          (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
          " in "
          `s
          ", "
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " (Term.app `f [`i]) "⟫")))))
      (Command.declValSimple
       ":="
       (Term.proj (Term.app `LinearMap.flip [`sesqFormOfInner `x]) "." `map_sum)
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.proj (Term.app `LinearMap.flip [`sesqFormOfInner `x]) "." `map_sum)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.app `LinearMap.flip [`sesqFormOfInner `x])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `sesqFormOfInner
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `LinearMap.flip
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app `LinearMap.flip [`sesqFormOfInner `x])
     ")")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        `x
        ", "
        (BigOperators.Algebra.BigOperators.Basic.finset.sum
         "∑"
         (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
         " in "
         `s
         ", "
         (Term.app `f [`i]))
        "⟫")
       "="
       (BigOperators.Algebra.BigOperators.Basic.finset.sum
        "∑"
        (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
        " in "
        `s
        ", "
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " (Term.app `f [`i]) "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (BigOperators.Algebra.BigOperators.Basic.finset.sum
       "∑"
       (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
       " in "
       `s
       ", "
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " (Term.app `f [`i]) "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " (Term.app `f [`i]) "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- An inner product with a sum on the right. -/
  theorem
    inner_sum
    { ι : Type _ } ( s : Finset ι ) ( f : ι → E ) ( x : E )
      : ⟪ x , ∑ i in s , f i ⟫ = ∑ i in s , ⟪ x , f i ⟫
    := LinearMap.flip sesqFormOfInner x . map_sum
#align inner_sum inner_sum

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment "/--" "An inner product with a sum on the left, `finsupp` version. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `Finsupp.sum_inner [])
      (Command.declSig
       [(Term.implicitBinder "{" [`ι] [":" (Term.type "Type" [(Level.hole "_")])] "}")
        (Term.explicitBinder "(" [`l] [":" (Data.Finsupp.Defs.«term_→₀_» `ι " →₀ " `𝕜)] [] ")")
        (Term.explicitBinder "(" [`v] [":" (Term.arrow `ι "→" `E)] [] ")")
        (Term.explicitBinder "(" [`x] [":" `E] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (Term.app
           (Term.proj `l "." `Sum)
           [(Term.fun
             "fun"
             (Term.basicFun
              [(Term.typeAscription "(" (Term.app `i []) ":" [`ι] ")")
               (Term.typeAscription "(" (Term.app `a []) ":" [`𝕜] ")")]
              []
              "=>"
              (Algebra.Group.Defs.«term_•_» `a " • " (Term.app `v [`i]))))])
          ", "
          `x
          "⟫")
         "="
         (Term.app
          (Term.proj `l "." `Sum)
          [(Term.fun
            "fun"
            (Term.basicFun
             [(Term.typeAscription "(" (Term.app `i []) ":" [`ι] ")")
              (Term.typeAscription "(" (Term.app `a []) ":" [`𝕜] ")")]
             []
             "=>"
             (Algebra.Group.Defs.«term_•_»
              (Term.app (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj") [`a])
              " • "
              (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
               "⟪"
               (Term.app `v [`i])
               ", "
               `x
               "⟫"))))]))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(convert
            "convert"
            []
            (Term.app
             `sum_inner
             [`l.support
              (Term.fun
               "fun"
               (Term.basicFun
                [`a]
                []
                "=>"
                (Algebra.Group.Defs.«term_•_» (Term.app `l [`a]) " • " (Term.app `v [`a]))))
              `x])
            [])
           []
           (Tactic.simp
            "simp"
            []
            []
            ["only"]
            ["["
             [(Tactic.simpLemma [] [] `inner_smul_left)
              ","
              (Tactic.simpLemma [] [] `Finsupp.sum)
              ","
              (Tactic.simpLemma [] [] `smul_eq_mul)]
             "]"]
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(convert
           "convert"
           []
           (Term.app
            `sum_inner
            [`l.support
             (Term.fun
              "fun"
              (Term.basicFun
               [`a]
               []
               "=>"
               (Algebra.Group.Defs.«term_•_» (Term.app `l [`a]) " • " (Term.app `v [`a]))))
             `x])
           [])
          []
          (Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["["
            [(Tactic.simpLemma [] [] `inner_smul_left)
             ","
             (Tactic.simpLemma [] [] `Finsupp.sum)
             ","
             (Tactic.simpLemma [] [] `smul_eq_mul)]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] `inner_smul_left)
         ","
         (Tactic.simpLemma [] [] `Finsupp.sum)
         ","
         (Tactic.simpLemma [] [] `smul_eq_mul)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `smul_eq_mul
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Finsupp.sum
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_smul_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (convert
       "convert"
       []
       (Term.app
        `sum_inner
        [`l.support
         (Term.fun
          "fun"
          (Term.basicFun
           [`a]
           []
           "=>"
           (Algebra.Group.Defs.«term_•_» (Term.app `l [`a]) " • " (Term.app `v [`a]))))
         `x])
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `sum_inner
       [`l.support
        (Term.fun
         "fun"
         (Term.basicFun
          [`a]
          []
          "=>"
          (Algebra.Group.Defs.«term_•_» (Term.app `l [`a]) " • " (Term.app `v [`a]))))
        `x])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.fun
       "fun"
       (Term.basicFun
        [`a]
        []
        "=>"
        (Algebra.Group.Defs.«term_•_» (Term.app `l [`a]) " • " (Term.app `v [`a]))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Algebra.Group.Defs.«term_•_» (Term.app `l [`a]) " • " (Term.app `v [`a]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `v [`a])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `a
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `v
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 73 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 73, term))
      (Term.app `l [`a])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `a
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `l
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 74 >? 1022, (some 1023, term) <=? (some 73, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 73, (some 73, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `a
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (some 0, term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.fun
      "fun"
      (Term.basicFun
       [`a]
       []
       "=>"
       (Algebra.Group.Defs.«term_•_» (Term.app `l [`a]) " • " (Term.app `v [`a]))))
     ")")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `l.support
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `sum_inner
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        (Term.app
         (Term.proj `l "." `Sum)
         [(Term.fun
           "fun"
           (Term.basicFun
            [(Term.typeAscription "(" (Term.app `i []) ":" [`ι] ")")
             (Term.typeAscription "(" (Term.app `a []) ":" [`𝕜] ")")]
            []
            "=>"
            (Algebra.Group.Defs.«term_•_» `a " • " (Term.app `v [`i]))))])
        ", "
        `x
        "⟫")
       "="
       (Term.app
        (Term.proj `l "." `Sum)
        [(Term.fun
          "fun"
          (Term.basicFun
           [(Term.typeAscription "(" (Term.app `i []) ":" [`ι] ")")
            (Term.typeAscription "(" (Term.app `a []) ":" [`𝕜] ")")]
           []
           "=>"
           (Algebra.Group.Defs.«term_•_»
            (Term.app (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj") [`a])
            " • "
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " `x "⟫"))))]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       (Term.proj `l "." `Sum)
       [(Term.fun
         "fun"
         (Term.basicFun
          [(Term.typeAscription "(" (Term.app `i []) ":" [`ι] ")")
           (Term.typeAscription "(" (Term.app `a []) ":" [`𝕜] ")")]
          []
          "=>"
          (Algebra.Group.Defs.«term_•_»
           (Term.app (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj") [`a])
           " • "
           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " `x "⟫"))))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun
       "fun"
       (Term.basicFun
        [(Term.typeAscription "(" (Term.app `i []) ":" [`ι] ")")
         (Term.typeAscription "(" (Term.app `a []) ":" [`𝕜] ")")]
        []
        "=>"
        (Algebra.Group.Defs.«term_•_»
         (Term.app (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj") [`a])
         " • "
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " `x "⟫"))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Algebra.Group.Defs.«term_•_»
       (Term.app (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj") [`a])
       " • "
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " `x "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.matchAlts'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- An inner product with a sum on the left, `finsupp` version. -/
  theorem
    Finsupp.sum_inner
    { ι : Type _ } ( l : ι →₀ 𝕜 ) ( v : ι → E ) ( x : E )
      :
        ⟪ l . Sum fun ( i : ι ) ( a : 𝕜 ) => a • v i , x ⟫
          =
          l . Sum fun ( i : ι ) ( a : 𝕜 ) => conj a • ⟪ v i , x ⟫
    :=
      by
        convert sum_inner l.support fun a => l a • v a x
          simp only [ inner_smul_left , Finsupp.sum , smul_eq_mul ]
#align finsupp.sum_inner Finsupp.sum_inner

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment "/--" "An inner product with a sum on the right, `finsupp` version. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `Finsupp.inner_sum [])
      (Command.declSig
       [(Term.implicitBinder "{" [`ι] [":" (Term.type "Type" [(Level.hole "_")])] "}")
        (Term.explicitBinder "(" [`l] [":" (Data.Finsupp.Defs.«term_→₀_» `ι " →₀ " `𝕜)] [] ")")
        (Term.explicitBinder "(" [`v] [":" (Term.arrow `ι "→" `E)] [] ")")
        (Term.explicitBinder "(" [`x] [":" `E] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          `x
          ", "
          (Term.app
           (Term.proj `l "." `Sum)
           [(Term.fun
             "fun"
             (Term.basicFun
              [(Term.typeAscription "(" (Term.app `i []) ":" [`ι] ")")
               (Term.typeAscription "(" (Term.app `a []) ":" [`𝕜] ")")]
              []
              "=>"
              (Algebra.Group.Defs.«term_•_» `a " • " (Term.app `v [`i]))))])
          "⟫")
         "="
         (Term.app
          (Term.proj `l "." `Sum)
          [(Term.fun
            "fun"
            (Term.basicFun
             [(Term.typeAscription "(" (Term.app `i []) ":" [`ι] ")")
              (Term.typeAscription "(" (Term.app `a []) ":" [`𝕜] ")")]
             []
             "=>"
             (Algebra.Group.Defs.«term_•_»
              `a
              " • "
              (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
               "⟪"
               `x
               ", "
               (Term.app `v [`i])
               "⟫"))))]))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(convert
            "convert"
            []
            (Term.app
             `inner_sum
             [`l.support
              (Term.fun
               "fun"
               (Term.basicFun
                [`a]
                []
                "=>"
                (Algebra.Group.Defs.«term_•_» (Term.app `l [`a]) " • " (Term.app `v [`a]))))
              `x])
            [])
           []
           (Tactic.simp
            "simp"
            []
            []
            ["only"]
            ["["
             [(Tactic.simpLemma [] [] `inner_smul_right)
              ","
              (Tactic.simpLemma [] [] `Finsupp.sum)
              ","
              (Tactic.simpLemma [] [] `smul_eq_mul)]
             "]"]
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(convert
           "convert"
           []
           (Term.app
            `inner_sum
            [`l.support
             (Term.fun
              "fun"
              (Term.basicFun
               [`a]
               []
               "=>"
               (Algebra.Group.Defs.«term_•_» (Term.app `l [`a]) " • " (Term.app `v [`a]))))
             `x])
           [])
          []
          (Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["["
            [(Tactic.simpLemma [] [] `inner_smul_right)
             ","
             (Tactic.simpLemma [] [] `Finsupp.sum)
             ","
             (Tactic.simpLemma [] [] `smul_eq_mul)]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] `inner_smul_right)
         ","
         (Tactic.simpLemma [] [] `Finsupp.sum)
         ","
         (Tactic.simpLemma [] [] `smul_eq_mul)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `smul_eq_mul
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Finsupp.sum
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_smul_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (convert
       "convert"
       []
       (Term.app
        `inner_sum
        [`l.support
         (Term.fun
          "fun"
          (Term.basicFun
           [`a]
           []
           "=>"
           (Algebra.Group.Defs.«term_•_» (Term.app `l [`a]) " • " (Term.app `v [`a]))))
         `x])
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `inner_sum
       [`l.support
        (Term.fun
         "fun"
         (Term.basicFun
          [`a]
          []
          "=>"
          (Algebra.Group.Defs.«term_•_» (Term.app `l [`a]) " • " (Term.app `v [`a]))))
        `x])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.fun
       "fun"
       (Term.basicFun
        [`a]
        []
        "=>"
        (Algebra.Group.Defs.«term_•_» (Term.app `l [`a]) " • " (Term.app `v [`a]))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Algebra.Group.Defs.«term_•_» (Term.app `l [`a]) " • " (Term.app `v [`a]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `v [`a])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `a
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `v
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 73 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 73, term))
      (Term.app `l [`a])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `a
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `l
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 74 >? 1022, (some 1023, term) <=? (some 73, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 73, (some 73, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `a
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (some 0, term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.fun
      "fun"
      (Term.basicFun
       [`a]
       []
       "=>"
       (Algebra.Group.Defs.«term_•_» (Term.app `l [`a]) " • " (Term.app `v [`a]))))
     ")")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `l.support
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `inner_sum
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        `x
        ", "
        (Term.app
         (Term.proj `l "." `Sum)
         [(Term.fun
           "fun"
           (Term.basicFun
            [(Term.typeAscription "(" (Term.app `i []) ":" [`ι] ")")
             (Term.typeAscription "(" (Term.app `a []) ":" [`𝕜] ")")]
            []
            "=>"
            (Algebra.Group.Defs.«term_•_» `a " • " (Term.app `v [`i]))))])
        "⟫")
       "="
       (Term.app
        (Term.proj `l "." `Sum)
        [(Term.fun
          "fun"
          (Term.basicFun
           [(Term.typeAscription "(" (Term.app `i []) ":" [`ι] ")")
            (Term.typeAscription "(" (Term.app `a []) ":" [`𝕜] ")")]
           []
           "=>"
           (Algebra.Group.Defs.«term_•_»
            `a
            " • "
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " (Term.app `v [`i]) "⟫"))))]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       (Term.proj `l "." `Sum)
       [(Term.fun
         "fun"
         (Term.basicFun
          [(Term.typeAscription "(" (Term.app `i []) ":" [`ι] ")")
           (Term.typeAscription "(" (Term.app `a []) ":" [`𝕜] ")")]
          []
          "=>"
          (Algebra.Group.Defs.«term_•_»
           `a
           " • "
           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " (Term.app `v [`i]) "⟫"))))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun
       "fun"
       (Term.basicFun
        [(Term.typeAscription "(" (Term.app `i []) ":" [`ι] ")")
         (Term.typeAscription "(" (Term.app `a []) ":" [`𝕜] ")")]
        []
        "=>"
        (Algebra.Group.Defs.«term_•_»
         `a
         " • "
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " (Term.app `v [`i]) "⟫"))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Algebra.Group.Defs.«term_•_»
       `a
       " • "
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " (Term.app `v [`i]) "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " (Term.app `v [`i]) "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.matchAlts'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- An inner product with a sum on the right, `finsupp` version. -/
  theorem
    Finsupp.inner_sum
    { ι : Type _ } ( l : ι →₀ 𝕜 ) ( v : ι → E ) ( x : E )
      :
        ⟪ x , l . Sum fun ( i : ι ) ( a : 𝕜 ) => a • v i ⟫
          =
          l . Sum fun ( i : ι ) ( a : 𝕜 ) => a • ⟪ x , v i ⟫
    :=
      by
        convert inner_sum l.support fun a => l a • v a x
          simp only [ inner_smul_right , Finsupp.sum , smul_eq_mul ]
#align finsupp.inner_sum Finsupp.inner_sum

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `Dfinsupp.sum_inner [])
      (Command.declSig
       [(Term.implicitBinder "{" [`ι] [":" (Term.type "Type" [(Level.hole "_")])] "}")
        (Term.instBinder "[" [`dec ":"] (Term.app `DecidableEq [`ι]) "]")
        (Term.implicitBinder
         "{"
         [`α]
         [":" (Term.arrow `ι "→" (Term.type "Type" [(Level.hole "_")]))]
         "}")
        (Term.instBinder
         "["
         []
         (Term.forall "∀" [`i] [] "," (Term.app `AddZeroClass [(Term.app `α [`i])]))
         "]")
        (Term.instBinder
         "["
         []
         (Term.forall
          "∀"
          [(Term.explicitBinder "(" [`i] [] [] ")")
           (Term.explicitBinder "(" [`x] [":" (Term.app `α [`i])] [] ")")]
          []
          ","
          (Term.app `Decidable [(«term_≠_» `x "≠" (num "0"))]))
         "]")
        (Term.explicitBinder
         "("
         [`f]
         [":" (Term.forall "∀" [`i] [] "," (Term.arrow (Term.app `α [`i]) "→" `E))]
         []
         ")")
        (Term.explicitBinder
         "("
         [`l]
         [":"
          (Data.Dfinsupp.Basic.«termΠ₀_,_»
           "Π₀"
           (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
           ", "
           (Term.app `α [`i]))]
         []
         ")")
        (Term.explicitBinder "(" [`x] [":" `E] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (Term.app (Term.proj `l "." `Sum) [`f])
          ", "
          `x
          "⟫")
         "="
         (Term.app
          (Term.proj `l "." `Sum)
          [(Term.fun
            "fun"
            (Term.basicFun
             [`i `a]
             []
             "=>"
             (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
              "⟪"
              (Term.app `f [`i `a])
              ", "
              `x
              "⟫")))]))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.simp
            "simp"
            [(Tactic.config
              "("
              "config"
              ":="
              (Term.structInst
               "{"
               []
               [(Term.structInstField (Term.structInstLVal `contextual []) ":=" `true)]
               (Term.optEllipsis [])
               []
               "}")
              ")")]
            []
            ["only"]
            ["["
             [(Tactic.simpLemma [] [] `Dfinsupp.sum)
              ","
              (Tactic.simpLemma [] [] `sum_inner)
              ","
              (Tactic.simpLemma [] [] `smul_eq_mul)]
             "]"]
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           [(Tactic.config
             "("
             "config"
             ":="
             (Term.structInst
              "{"
              []
              [(Term.structInstField (Term.structInstLVal `contextual []) ":=" `true)]
              (Term.optEllipsis [])
              []
              "}")
             ")")]
           []
           ["only"]
           ["["
            [(Tactic.simpLemma [] [] `Dfinsupp.sum)
             ","
             (Tactic.simpLemma [] [] `sum_inner)
             ","
             (Tactic.simpLemma [] [] `smul_eq_mul)]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       [(Tactic.config
         "("
         "config"
         ":="
         (Term.structInst
          "{"
          []
          [(Term.structInstField (Term.structInstLVal `contextual []) ":=" `true)]
          (Term.optEllipsis [])
          []
          "}")
         ")")]
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] `Dfinsupp.sum)
         ","
         (Tactic.simpLemma [] [] `sum_inner)
         ","
         (Tactic.simpLemma [] [] `smul_eq_mul)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `smul_eq_mul
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `sum_inner
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Dfinsupp.sum
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.structInst
       "{"
       []
       [(Term.structInstField (Term.structInstLVal `contextual []) ":=" `true)]
       (Term.optEllipsis [])
       []
       "}")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstField', expected 'Lean.Parser.Term.structInstFieldAbbrev'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `true
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        (Term.app (Term.proj `l "." `Sum) [`f])
        ", "
        `x
        "⟫")
       "="
       (Term.app
        (Term.proj `l "." `Sum)
        [(Term.fun
          "fun"
          (Term.basicFun
           [`i `a]
           []
           "=>"
           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `f [`i `a]) ", " `x "⟫")))]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       (Term.proj `l "." `Sum)
       [(Term.fun
         "fun"
         (Term.basicFun
          [`i `a]
          []
          "=>"
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `f [`i `a]) ", " `x "⟫")))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun
       "fun"
       (Term.basicFun
        [`i `a]
        []
        "=>"
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `f [`i `a]) ", " `x "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `f [`i `a]) ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.matchAlts'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  Dfinsupp.sum_inner
  { ι : Type _ }
      [ dec : DecidableEq ι ]
      { α : ι → Type _ }
      [ ∀ i , AddZeroClass α i ]
      [ ∀ ( i ) ( x : α i ) , Decidable x ≠ 0 ]
      ( f : ∀ i , α i → E )
      ( l : Π₀ i , α i )
      ( x : E )
    : ⟪ l . Sum f , x ⟫ = l . Sum fun i a => ⟪ f i a , x ⟫
  := by simp ( config := { contextual := true } ) only [ Dfinsupp.sum , sum_inner , smul_eq_mul ]
#align dfinsupp.sum_inner Dfinsupp.sum_inner

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `Dfinsupp.inner_sum [])
      (Command.declSig
       [(Term.implicitBinder "{" [`ι] [":" (Term.type "Type" [(Level.hole "_")])] "}")
        (Term.instBinder "[" [`dec ":"] (Term.app `DecidableEq [`ι]) "]")
        (Term.implicitBinder
         "{"
         [`α]
         [":" (Term.arrow `ι "→" (Term.type "Type" [(Level.hole "_")]))]
         "}")
        (Term.instBinder
         "["
         []
         (Term.forall "∀" [`i] [] "," (Term.app `AddZeroClass [(Term.app `α [`i])]))
         "]")
        (Term.instBinder
         "["
         []
         (Term.forall
          "∀"
          [(Term.explicitBinder "(" [`i] [] [] ")")
           (Term.explicitBinder "(" [`x] [":" (Term.app `α [`i])] [] ")")]
          []
          ","
          (Term.app `Decidable [(«term_≠_» `x "≠" (num "0"))]))
         "]")
        (Term.explicitBinder
         "("
         [`f]
         [":" (Term.forall "∀" [`i] [] "," (Term.arrow (Term.app `α [`i]) "→" `E))]
         []
         ")")
        (Term.explicitBinder
         "("
         [`l]
         [":"
          (Data.Dfinsupp.Basic.«termΠ₀_,_»
           "Π₀"
           (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
           ", "
           (Term.app `α [`i]))]
         []
         ")")
        (Term.explicitBinder "(" [`x] [":" `E] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          `x
          ", "
          (Term.app (Term.proj `l "." `Sum) [`f])
          "⟫")
         "="
         (Term.app
          (Term.proj `l "." `Sum)
          [(Term.fun
            "fun"
            (Term.basicFun
             [`i `a]
             []
             "=>"
             (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
              "⟪"
              `x
              ", "
              (Term.app `f [`i `a])
              "⟫")))]))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.simp
            "simp"
            [(Tactic.config
              "("
              "config"
              ":="
              (Term.structInst
               "{"
               []
               [(Term.structInstField (Term.structInstLVal `contextual []) ":=" `true)]
               (Term.optEllipsis [])
               []
               "}")
              ")")]
            []
            ["only"]
            ["["
             [(Tactic.simpLemma [] [] `Dfinsupp.sum)
              ","
              (Tactic.simpLemma [] [] `inner_sum)
              ","
              (Tactic.simpLemma [] [] `smul_eq_mul)]
             "]"]
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           [(Tactic.config
             "("
             "config"
             ":="
             (Term.structInst
              "{"
              []
              [(Term.structInstField (Term.structInstLVal `contextual []) ":=" `true)]
              (Term.optEllipsis [])
              []
              "}")
             ")")]
           []
           ["only"]
           ["["
            [(Tactic.simpLemma [] [] `Dfinsupp.sum)
             ","
             (Tactic.simpLemma [] [] `inner_sum)
             ","
             (Tactic.simpLemma [] [] `smul_eq_mul)]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       [(Tactic.config
         "("
         "config"
         ":="
         (Term.structInst
          "{"
          []
          [(Term.structInstField (Term.structInstLVal `contextual []) ":=" `true)]
          (Term.optEllipsis [])
          []
          "}")
         ")")]
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] `Dfinsupp.sum)
         ","
         (Tactic.simpLemma [] [] `inner_sum)
         ","
         (Tactic.simpLemma [] [] `smul_eq_mul)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `smul_eq_mul
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_sum
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Dfinsupp.sum
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.structInst
       "{"
       []
       [(Term.structInstField (Term.structInstLVal `contextual []) ":=" `true)]
       (Term.optEllipsis [])
       []
       "}")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstField', expected 'Lean.Parser.Term.structInstFieldAbbrev'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `true
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        `x
        ", "
        (Term.app (Term.proj `l "." `Sum) [`f])
        "⟫")
       "="
       (Term.app
        (Term.proj `l "." `Sum)
        [(Term.fun
          "fun"
          (Term.basicFun
           [`i `a]
           []
           "=>"
           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " (Term.app `f [`i `a]) "⟫")))]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       (Term.proj `l "." `Sum)
       [(Term.fun
         "fun"
         (Term.basicFun
          [`i `a]
          []
          "=>"
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " (Term.app `f [`i `a]) "⟫")))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun
       "fun"
       (Term.basicFun
        [`i `a]
        []
        "=>"
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " (Term.app `f [`i `a]) "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " (Term.app `f [`i `a]) "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.matchAlts'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  Dfinsupp.inner_sum
  { ι : Type _ }
      [ dec : DecidableEq ι ]
      { α : ι → Type _ }
      [ ∀ i , AddZeroClass α i ]
      [ ∀ ( i ) ( x : α i ) , Decidable x ≠ 0 ]
      ( f : ∀ i , α i → E )
      ( l : Π₀ i , α i )
      ( x : E )
    : ⟪ x , l . Sum f ⟫ = l . Sum fun i a => ⟪ x , f i a ⟫
  := by simp ( config := { contextual := true } ) only [ Dfinsupp.sum , inner_sum , smul_eq_mul ]
#align dfinsupp.inner_sum Dfinsupp.inner_sum

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      []
      [(Term.attributes "@[" [(Term.attrInstance (Term.attrKind []) (Attr.simp "simp" [] []))] "]")]
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_zero_left [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (num "0") ", " `x "⟫")
         "="
         (num "0"))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule
               [(patternIgnore (token.«← » "←"))]
               (Term.app `zero_smul [`𝕜 (Term.typeAscription "(" (num "0") ":" [`E] ")")]))
              ","
              (Tactic.rwRule [] `inner_smul_left)
              ","
              (Tactic.rwRule [] `RingHom.map_zero)
              ","
              (Tactic.rwRule [] `zero_mul)]
             "]")
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule
              [(patternIgnore (token.«← » "←"))]
              (Term.app `zero_smul [`𝕜 (Term.typeAscription "(" (num "0") ":" [`E] ")")]))
             ","
             (Tactic.rwRule [] `inner_smul_left)
             ","
             (Tactic.rwRule [] `RingHom.map_zero)
             ","
             (Tactic.rwRule [] `zero_mul)]
            "]")
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule
          [(patternIgnore (token.«← » "←"))]
          (Term.app `zero_smul [`𝕜 (Term.typeAscription "(" (num "0") ":" [`E] ")")]))
         ","
         (Tactic.rwRule [] `inner_smul_left)
         ","
         (Tactic.rwRule [] `RingHom.map_zero)
         ","
         (Tactic.rwRule [] `zero_mul)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `zero_mul
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `RingHom.map_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_smul_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `zero_smul [`𝕜 (Term.typeAscription "(" (num "0") ":" [`E] ")")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.typeAscription', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.typeAscription', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.typeAscription "(" (num "0") ":" [`E] ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `E
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      `𝕜
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `zero_smul
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (num "0") ", " `x "⟫")
       "="
       (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (num "0") ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
@[ simp ]
  theorem
    inner_zero_left
    { x : E } : ⟪ 0 , x ⟫ = 0
    := by rw [ ← zero_smul 𝕜 ( 0 : E ) , inner_smul_left , RingHom.map_zero , zero_mul ]
#align inner_zero_left inner_zero_left

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_re_zero_left [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (num "0") ", " `x "⟫")])
         "="
         (num "0"))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.simp
            "simp"
            []
            []
            ["only"]
            ["["
             [(Tactic.simpLemma [] [] `inner_zero_left)
              ","
              (Tactic.simpLemma [] [] `AddMonoidHom.map_zero)]
             "]"]
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["["
            [(Tactic.simpLemma [] [] `inner_zero_left)
             ","
             (Tactic.simpLemma [] [] `AddMonoidHom.map_zero)]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] `inner_zero_left)
         ","
         (Tactic.simpLemma [] [] `AddMonoidHom.map_zero)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `AddMonoidHom.map_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_zero_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (num "0") ", " `x "⟫")])
       "="
       (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (num "0") ", " `x "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (num "0") ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_re_zero_left
  { x : E } : re ⟪ 0 , x ⟫ = 0
  := by simp only [ inner_zero_left , AddMonoidHom.map_zero ]
#align inner_re_zero_left inner_re_zero_left

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      []
      [(Term.attributes "@[" [(Term.attrInstance (Term.attrKind []) (Attr.simp "simp" [] []))] "]")]
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_zero_right [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " (num "0") "⟫")
         "="
         (num "0"))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
              ","
              (Tactic.rwRule [] `inner_zero_left)
              ","
              (Tactic.rwRule [] `RingHom.map_zero)]
             "]")
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
             ","
             (Tactic.rwRule [] `inner_zero_left)
             ","
             (Tactic.rwRule [] `RingHom.map_zero)]
            "]")
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
         ","
         (Tactic.rwRule [] `inner_zero_left)
         ","
         (Tactic.rwRule [] `RingHom.map_zero)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `RingHom.map_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_zero_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_conj_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " (num "0") "⟫")
       "="
       (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " (num "0") "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
@[ simp ]
  theorem
    inner_zero_right
    { x : E } : ⟪ x , 0 ⟫ = 0
    := by rw [ ← inner_conj_sym , inner_zero_left , RingHom.map_zero ]
#align inner_zero_right inner_zero_right

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_re_zero_right [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " (num "0") "⟫")])
         "="
         (num "0"))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.simp
            "simp"
            []
            []
            ["only"]
            ["["
             [(Tactic.simpLemma [] [] `inner_zero_right)
              ","
              (Tactic.simpLemma [] [] `AddMonoidHom.map_zero)]
             "]"]
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["["
            [(Tactic.simpLemma [] [] `inner_zero_right)
             ","
             (Tactic.simpLemma [] [] `AddMonoidHom.map_zero)]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] `inner_zero_right)
         ","
         (Tactic.simpLemma [] [] `AddMonoidHom.map_zero)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `AddMonoidHom.map_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_zero_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " (num "0") "⟫")])
       "="
       (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " (num "0") "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " (num "0") "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_re_zero_right
  { x : E } : re ⟪ x , 0 ⟫ = 0
  := by simp only [ inner_zero_right , AddMonoidHom.map_zero ]
#align inner_re_zero_right inner_re_zero_right

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_self_nonneg [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_≤_»
         (num "0")
         "≤"
         (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")]))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.«tactic_<;>_»
            (Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq
              "["
              [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `norm_sq_eq_inner)]
              "]")
             [])
            "<;>"
            (Tactic.exact
             "exact"
             (Term.app `pow_nonneg [(Term.app `norm_nonneg [`x]) (num "2")])))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.«tactic_<;>_»
           (Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `norm_sq_eq_inner)]
             "]")
            [])
           "<;>"
           (Tactic.exact
            "exact"
            (Term.app `pow_nonneg [(Term.app `norm_nonneg [`x]) (num "2")])))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.«tactic_<;>_»
       (Tactic.rwSeq
        "rw"
        []
        (Tactic.rwRuleSeq
         "["
         [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `norm_sq_eq_inner)]
         "]")
        [])
       "<;>"
       (Tactic.exact "exact" (Term.app `pow_nonneg [(Term.app `norm_nonneg [`x]) (num "2")])))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact "exact" (Term.app `pow_nonneg [(Term.app `norm_nonneg [`x]) (num "2")]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `pow_nonneg [(Term.app `norm_nonneg [`x]) (num "2")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'num', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'num', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "2")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.app `norm_nonneg [`x])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `norm_nonneg
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `norm_nonneg [`x]) ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `pow_nonneg
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 2 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1, tactic))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `norm_sq_eq_inner)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `norm_sq_eq_inner
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_≤_»
       (num "0")
       "≤"
       (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_self_nonneg
  { x : E } : 0 ≤ re ⟪ x , x ⟫
  := by rw [ ← norm_sq_eq_inner ] <;> exact pow_nonneg norm_nonneg x 2
#align inner_self_nonneg inner_self_nonneg

theorem real_inner_self_nonneg {x : F} : 0 ≤ ⟪x, x⟫_ℝ :=
  @inner_self_nonneg ℝ F _ _ x
#align real_inner_self_nonneg real_inner_self_nonneg

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      []
      [(Term.attributes "@[" [(Term.attrInstance (Term.attrKind []) (Attr.simp "simp" [] []))] "]")]
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_self_eq_zero [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_↔_»
         («term_=_» (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫") "=" (num "0"))
         "↔"
         («term_=_» `x "=" (num "0")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.constructor "constructor")
           []
           (tactic__
            (cdotTk (patternIgnore (token.«· » "·")))
            [(Tactic.intro "intro" [`h])
             []
             (Tactic.tacticHave_
              "have"
              (Term.haveDecl
               (Term.haveIdDecl
                [`h₁ []]
                [(Term.typeSpec
                  ":"
                  («term_=_»
                   (Term.app
                    `re
                    [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                   "="
                   (num "0")))]
                ":="
                (Term.byTactic
                 "by"
                 (Tactic.tacticSeq
                  (Tactic.tacticSeq1Indented
                   [(Tactic.«tactic_<;>_»
                     (Tactic.rwSeq
                      "rw"
                      []
                      (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `IsROrC.ext_iff)] "]")
                      [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
                     "<;>"
                     (Tactic.simp
                      "simp"
                      []
                      []
                      ["only"]
                      ["["
                       [(Tactic.simpLemma [] [] (Term.proj `h "." (fieldIdx "1")))
                        ","
                        (Tactic.simpLemma [] [] `zero_re')]
                       "]"]
                      []))]))))))
             []
             (Tactic.rwSeq
              "rw"
              []
              (Tactic.rwRuleSeq
               "["
               [(Tactic.rwRule
                 [(patternIgnore (token.«← » "←"))]
                 (Term.app `norm_sq_eq_inner [`x]))]
               "]")
              [(Tactic.location "at" (Tactic.locationHyp [`h₁] []))])
             []
             (Tactic.rwSeq
              "rw"
              []
              (Tactic.rwRuleSeq
               "["
               [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `norm_eq_zero)]
               "]")
              [])
             []
             (Tactic.exact "exact" (Term.app `pow_eq_zero [`h₁]))])
           []
           (tactic__
            (cdotTk (patternIgnore (token.«· » "·")))
            [(Std.Tactic.rintro
              "rintro"
              [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `rfl))]
              [])
             []
             (Tactic.exact "exact" `inner_zero_left)])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.constructor "constructor")
          []
          (tactic__
           (cdotTk (patternIgnore (token.«· » "·")))
           [(Tactic.intro "intro" [`h])
            []
            (Tactic.tacticHave_
             "have"
             (Term.haveDecl
              (Term.haveIdDecl
               [`h₁ []]
               [(Term.typeSpec
                 ":"
                 («term_=_»
                  (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                  "="
                  (num "0")))]
               ":="
               (Term.byTactic
                "by"
                (Tactic.tacticSeq
                 (Tactic.tacticSeq1Indented
                  [(Tactic.«tactic_<;>_»
                    (Tactic.rwSeq
                     "rw"
                     []
                     (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `IsROrC.ext_iff)] "]")
                     [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
                    "<;>"
                    (Tactic.simp
                     "simp"
                     []
                     []
                     ["only"]
                     ["["
                      [(Tactic.simpLemma [] [] (Term.proj `h "." (fieldIdx "1")))
                       ","
                       (Tactic.simpLemma [] [] `zero_re')]
                      "]"]
                     []))]))))))
            []
            (Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq
              "["
              [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] (Term.app `norm_sq_eq_inner [`x]))]
              "]")
             [(Tactic.location "at" (Tactic.locationHyp [`h₁] []))])
            []
            (Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq
              "["
              [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `norm_eq_zero)]
              "]")
             [])
            []
            (Tactic.exact "exact" (Term.app `pow_eq_zero [`h₁]))])
          []
          (tactic__
           (cdotTk (patternIgnore (token.«· » "·")))
           [(Std.Tactic.rintro
             "rintro"
             [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `rfl))]
             [])
            []
            (Tactic.exact "exact" `inner_zero_left)])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.«· » "·")))
       [(Std.Tactic.rintro
         "rintro"
         [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `rfl))]
         [])
        []
        (Tactic.exact "exact" `inner_zero_left)])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact "exact" `inner_zero_left)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_zero_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Std.Tactic.rintro
       "rintro"
       [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `rfl))]
       [])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.«· » "·")))
       [(Tactic.intro "intro" [`h])
        []
        (Tactic.tacticHave_
         "have"
         (Term.haveDecl
          (Term.haveIdDecl
           [`h₁ []]
           [(Term.typeSpec
             ":"
             («term_=_»
              (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
              "="
              (num "0")))]
           ":="
           (Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.«tactic_<;>_»
                (Tactic.rwSeq
                 "rw"
                 []
                 (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `IsROrC.ext_iff)] "]")
                 [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
                "<;>"
                (Tactic.simp
                 "simp"
                 []
                 []
                 ["only"]
                 ["["
                  [(Tactic.simpLemma [] [] (Term.proj `h "." (fieldIdx "1")))
                   ","
                   (Tactic.simpLemma [] [] `zero_re')]
                  "]"]
                 []))]))))))
        []
        (Tactic.rwSeq
         "rw"
         []
         (Tactic.rwRuleSeq
          "["
          [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] (Term.app `norm_sq_eq_inner [`x]))]
          "]")
         [(Tactic.location "at" (Tactic.locationHyp [`h₁] []))])
        []
        (Tactic.rwSeq
         "rw"
         []
         (Tactic.rwRuleSeq
          "["
          [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `norm_eq_zero)]
          "]")
         [])
        []
        (Tactic.exact "exact" (Term.app `pow_eq_zero [`h₁]))])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact "exact" (Term.app `pow_eq_zero [`h₁]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `pow_eq_zero [`h₁])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h₁
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `pow_eq_zero
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq "[" [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `norm_eq_zero)] "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `norm_eq_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] (Term.app `norm_sq_eq_inner [`x]))]
        "]")
       [(Tactic.location "at" (Tactic.locationHyp [`h₁] []))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.locationHyp', expected 'Lean.Parser.Tactic.locationWildcard'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h₁
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `norm_sq_eq_inner [`x])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `norm_sq_eq_inner
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.tacticHave_
       "have"
       (Term.haveDecl
        (Term.haveIdDecl
         [`h₁ []]
         [(Term.typeSpec
           ":"
           («term_=_»
            (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
            "="
            (num "0")))]
         ":="
         (Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(Tactic.«tactic_<;>_»
              (Tactic.rwSeq
               "rw"
               []
               (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `IsROrC.ext_iff)] "]")
               [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
              "<;>"
              (Tactic.simp
               "simp"
               []
               []
               ["only"]
               ["["
                [(Tactic.simpLemma [] [] (Term.proj `h "." (fieldIdx "1")))
                 ","
                 (Tactic.simpLemma [] [] `zero_re')]
                "]"]
               []))]))))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.«tactic_<;>_»
           (Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `IsROrC.ext_iff)] "]")
            [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
           "<;>"
           (Tactic.simp
            "simp"
            []
            []
            ["only"]
            ["["
             [(Tactic.simpLemma [] [] (Term.proj `h "." (fieldIdx "1")))
              ","
              (Tactic.simpLemma [] [] `zero_re')]
             "]"]
            []))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.«tactic_<;>_»
       (Tactic.rwSeq
        "rw"
        []
        (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `IsROrC.ext_iff)] "]")
        [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
       "<;>"
       (Tactic.simp
        "simp"
        []
        []
        ["only"]
        ["["
         [(Tactic.simpLemma [] [] (Term.proj `h "." (fieldIdx "1")))
          ","
          (Tactic.simpLemma [] [] `zero_re')]
         "]"]
        []))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] (Term.proj `h "." (fieldIdx "1")))
         ","
         (Tactic.simpLemma [] [] `zero_re')]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `zero_re'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.proj `h "." (fieldIdx "1"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `h
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 2 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1, tactic))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `IsROrC.ext_iff)] "]")
       [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.locationHyp', expected 'Lean.Parser.Tactic.locationWildcard'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `IsROrC.ext_iff
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_»
       (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
       "="
       (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.haveIdDecl', expected 'Lean.Parser.Term.letPatDecl'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.haveIdDecl', expected 'Lean.Parser.Term.haveEqnsDecl'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
@[ simp ]
  theorem
    inner_self_eq_zero
    { x : E } : ⟪ x , x ⟫ = 0 ↔ x = 0
    :=
      by
        constructor
          ·
            intro h
              have
                h₁
                  : re ⟪ x , x ⟫ = 0
                  :=
                  by rw [ IsROrC.ext_iff ] at h <;> simp only [ h . 1 , zero_re' ]
              rw [ ← norm_sq_eq_inner x ] at h₁
              rw [ ← norm_eq_zero ]
              exact pow_eq_zero h₁
          · rintro rfl exact inner_zero_left
#align inner_self_eq_zero inner_self_eq_zero

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      []
      [(Term.attributes "@[" [(Term.attrInstance (Term.attrKind []) (Attr.simp "simp" [] []))] "]")]
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_self_nonpos [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_↔_»
         («term_≤_»
          (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
          "≤"
          (num "0"))
         "↔"
         («term_=_» `x "=" (num "0")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.constructor "constructor")
           []
           (tactic__
            (cdotTk (patternIgnore (token.«· » "·")))
            [(Tactic.intro "intro" [`h])
             []
             (Tactic.rwSeq
              "rw"
              []
              (Tactic.rwRuleSeq
               "["
               [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_self_eq_zero)]
               "]")
              [])
             []
             (Tactic.tacticHave_
              "have"
              (Term.haveDecl
               (Term.haveIdDecl
                [`H₁ []]
                [(Term.typeSpec
                  ":"
                  («term_≥_»
                   (Term.app
                    `re
                    [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                   "≥"
                   (num "0")))]
                ":="
                `inner_self_nonneg)))
             []
             (Tactic.tacticHave_
              "have"
              (Term.haveDecl
               (Term.haveIdDecl
                [`H₂ []]
                [(Term.typeSpec
                  ":"
                  («term_=_»
                   (Term.app
                    `re
                    [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                   "="
                   (num "0")))]
                ":="
                (Term.app `le_antisymm [`h `H₁]))))
             []
             (Tactic.rwSeq
              "rw"
              []
              (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `IsROrC.ext_iff)] "]")
              [])
             []
             (Tactic.exact
              "exact"
              (Term.anonymousCtor
               "⟨"
               [(Term.byTactic
                 "by"
                 (Tactic.tacticSeq
                  (Tactic.tacticSeq1Indented
                   [(Tactic.simp "simp" [] [] [] ["[" [(Tactic.simpLemma [] [] `H₂)] "]"] [])])))
                ","
                (Term.byTactic
                 "by"
                 (Tactic.tacticSeq
                  (Tactic.tacticSeq1Indented
                   [(Tactic.simp
                     "simp"
                     []
                     []
                     []
                     ["[" [(Tactic.simpLemma [] [] `inner_self_nonneg_im)] "]"]
                     [])])))]
               "⟩"))])
           []
           (tactic__
            (cdotTk (patternIgnore (token.«· » "·")))
            [(Std.Tactic.rintro
              "rintro"
              [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `rfl))]
              [])
             []
             (Tactic.simp
              "simp"
              []
              []
              ["only"]
              ["["
               [(Tactic.simpLemma [] [] `inner_zero_left)
                ","
                (Tactic.simpLemma [] [] `AddMonoidHom.map_zero)]
               "]"]
              [])])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.constructor "constructor")
          []
          (tactic__
           (cdotTk (patternIgnore (token.«· » "·")))
           [(Tactic.intro "intro" [`h])
            []
            (Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq
              "["
              [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_self_eq_zero)]
              "]")
             [])
            []
            (Tactic.tacticHave_
             "have"
             (Term.haveDecl
              (Term.haveIdDecl
               [`H₁ []]
               [(Term.typeSpec
                 ":"
                 («term_≥_»
                  (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                  "≥"
                  (num "0")))]
               ":="
               `inner_self_nonneg)))
            []
            (Tactic.tacticHave_
             "have"
             (Term.haveDecl
              (Term.haveIdDecl
               [`H₂ []]
               [(Term.typeSpec
                 ":"
                 («term_=_»
                  (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                  "="
                  (num "0")))]
               ":="
               (Term.app `le_antisymm [`h `H₁]))))
            []
            (Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `IsROrC.ext_iff)] "]")
             [])
            []
            (Tactic.exact
             "exact"
             (Term.anonymousCtor
              "⟨"
              [(Term.byTactic
                "by"
                (Tactic.tacticSeq
                 (Tactic.tacticSeq1Indented
                  [(Tactic.simp "simp" [] [] [] ["[" [(Tactic.simpLemma [] [] `H₂)] "]"] [])])))
               ","
               (Term.byTactic
                "by"
                (Tactic.tacticSeq
                 (Tactic.tacticSeq1Indented
                  [(Tactic.simp
                    "simp"
                    []
                    []
                    []
                    ["[" [(Tactic.simpLemma [] [] `inner_self_nonneg_im)] "]"]
                    [])])))]
              "⟩"))])
          []
          (tactic__
           (cdotTk (patternIgnore (token.«· » "·")))
           [(Std.Tactic.rintro
             "rintro"
             [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `rfl))]
             [])
            []
            (Tactic.simp
             "simp"
             []
             []
             ["only"]
             ["["
              [(Tactic.simpLemma [] [] `inner_zero_left)
               ","
               (Tactic.simpLemma [] [] `AddMonoidHom.map_zero)]
              "]"]
             [])])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.«· » "·")))
       [(Std.Tactic.rintro
         "rintro"
         [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `rfl))]
         [])
        []
        (Tactic.simp
         "simp"
         []
         []
         ["only"]
         ["["
          [(Tactic.simpLemma [] [] `inner_zero_left)
           ","
           (Tactic.simpLemma [] [] `AddMonoidHom.map_zero)]
          "]"]
         [])])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] `inner_zero_left)
         ","
         (Tactic.simpLemma [] [] `AddMonoidHom.map_zero)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `AddMonoidHom.map_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_zero_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Std.Tactic.rintro
       "rintro"
       [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `rfl))]
       [])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.«· » "·")))
       [(Tactic.intro "intro" [`h])
        []
        (Tactic.rwSeq
         "rw"
         []
         (Tactic.rwRuleSeq
          "["
          [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_self_eq_zero)]
          "]")
         [])
        []
        (Tactic.tacticHave_
         "have"
         (Term.haveDecl
          (Term.haveIdDecl
           [`H₁ []]
           [(Term.typeSpec
             ":"
             («term_≥_»
              (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
              "≥"
              (num "0")))]
           ":="
           `inner_self_nonneg)))
        []
        (Tactic.tacticHave_
         "have"
         (Term.haveDecl
          (Term.haveIdDecl
           [`H₂ []]
           [(Term.typeSpec
             ":"
             («term_=_»
              (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
              "="
              (num "0")))]
           ":="
           (Term.app `le_antisymm [`h `H₁]))))
        []
        (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `IsROrC.ext_iff)] "]") [])
        []
        (Tactic.exact
         "exact"
         (Term.anonymousCtor
          "⟨"
          [(Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.simp "simp" [] [] [] ["[" [(Tactic.simpLemma [] [] `H₂)] "]"] [])])))
           ","
           (Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.simp
                "simp"
                []
                []
                []
                ["[" [(Tactic.simpLemma [] [] `inner_self_nonneg_im)] "]"]
                [])])))]
          "⟩"))])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact
       "exact"
       (Term.anonymousCtor
        "⟨"
        [(Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(Tactic.simp "simp" [] [] [] ["[" [(Tactic.simpLemma [] [] `H₂)] "]"] [])])))
         ","
         (Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(Tactic.simp
              "simp"
              []
              []
              []
              ["[" [(Tactic.simpLemma [] [] `inner_self_nonneg_im)] "]"]
              [])])))]
        "⟩"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.anonymousCtor
       "⟨"
       [(Term.byTactic
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(Tactic.simp "simp" [] [] [] ["[" [(Tactic.simpLemma [] [] `H₂)] "]"] [])])))
        ","
        (Term.byTactic
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(Tactic.simp
             "simp"
             []
             []
             []
             ["[" [(Tactic.simpLemma [] [] `inner_self_nonneg_im)] "]"]
             [])])))]
       "⟩")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           []
           ["[" [(Tactic.simpLemma [] [] `inner_self_nonneg_im)] "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp "simp" [] [] [] ["[" [(Tactic.simpLemma [] [] `inner_self_nonneg_im)] "]"] [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_self_nonneg_im
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp "simp" [] [] [] ["[" [(Tactic.simpLemma [] [] `H₂)] "]"] [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp "simp" [] [] [] ["[" [(Tactic.simpLemma [] [] `H₂)] "]"] [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `H₂
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `IsROrC.ext_iff)] "]") [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `IsROrC.ext_iff
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.tacticHave_
       "have"
       (Term.haveDecl
        (Term.haveIdDecl
         [`H₂ []]
         [(Term.typeSpec
           ":"
           («term_=_»
            (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
            "="
            (num "0")))]
         ":="
         (Term.app `le_antisymm [`h `H₁]))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `le_antisymm [`h `H₁])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `H₁
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `le_antisymm
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_»
       (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
       "="
       (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.haveIdDecl', expected 'Lean.Parser.Term.letPatDecl'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.haveIdDecl', expected 'Lean.Parser.Term.haveEqnsDecl'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
@[ simp ]
  theorem
    inner_self_nonpos
    { x : E } : re ⟪ x , x ⟫ ≤ 0 ↔ x = 0
    :=
      by
        constructor
          ·
            intro h
              rw [ ← inner_self_eq_zero ]
              have H₁ : re ⟪ x , x ⟫ ≥ 0 := inner_self_nonneg
              have H₂ : re ⟪ x , x ⟫ = 0 := le_antisymm h H₁
              rw [ IsROrC.ext_iff ]
              exact ⟨ by simp [ H₂ ] , by simp [ inner_self_nonneg_im ] ⟩
          · rintro rfl simp only [ inner_zero_left , AddMonoidHom.map_zero ]
#align inner_self_nonpos inner_self_nonpos

theorem real_inner_self_nonpos {x : F} : ⟪x, x⟫_ℝ ≤ 0 ↔ x = 0 :=
  by
  have h := @inner_self_nonpos ℝ F _ _ x
  simpa using h
#align real_inner_self_nonpos real_inner_self_nonpos

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      []
      [(Term.attributes "@[" [(Term.attrInstance (Term.attrKind []) (Attr.simp "simp" [] []))] "]")]
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_self_re_to_K [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.typeAscription
          "("
          (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
          ":"
          [`𝕜]
          ")")
         "="
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫"))))
      (Command.declValSimple
       ":="
       (Term.app
        (Term.proj `IsROrC.ext_iff "." (fieldIdx "2"))
        [(Term.anonymousCtor
          "⟨"
          [(Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.simp
                "simp"
                []
                []
                ["only"]
                ["[" [(Tactic.simpLemma [] [] `of_real_re)] "]"]
                [])])))
           ","
           (Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.simp
                "simp"
                []
                []
                ["only"]
                ["["
                 [(Tactic.simpLemma [] [] `inner_self_nonneg_im)
                  ","
                  (Tactic.simpLemma [] [] `of_real_im)]
                 "]"]
                [])])))]
          "⟩")])
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       (Term.proj `IsROrC.ext_iff "." (fieldIdx "2"))
       [(Term.anonymousCtor
         "⟨"
         [(Term.byTactic
           "by"
           (Tactic.tacticSeq
            (Tactic.tacticSeq1Indented
             [(Tactic.simp
               "simp"
               []
               []
               ["only"]
               ["[" [(Tactic.simpLemma [] [] `of_real_re)] "]"]
               [])])))
          ","
          (Term.byTactic
           "by"
           (Tactic.tacticSeq
            (Tactic.tacticSeq1Indented
             [(Tactic.simp
               "simp"
               []
               []
               ["only"]
               ["["
                [(Tactic.simpLemma [] [] `inner_self_nonneg_im)
                 ","
                 (Tactic.simpLemma [] [] `of_real_im)]
                "]"]
               [])])))]
         "⟩")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.anonymousCtor
       "⟨"
       [(Term.byTactic
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(Tactic.simp
             "simp"
             []
             []
             ["only"]
             ["[" [(Tactic.simpLemma [] [] `of_real_re)] "]"]
             [])])))
        ","
        (Term.byTactic
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(Tactic.simp
             "simp"
             []
             []
             ["only"]
             ["["
              [(Tactic.simpLemma [] [] `inner_self_nonneg_im)
               ","
               (Tactic.simpLemma [] [] `of_real_im)]
              "]"]
             [])])))]
       "⟩")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["["
            [(Tactic.simpLemma [] [] `inner_self_nonneg_im)
             ","
             (Tactic.simpLemma [] [] `of_real_im)]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] `inner_self_nonneg_im) "," (Tactic.simpLemma [] [] `of_real_im)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `of_real_im
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_self_nonneg_im
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["[" [(Tactic.simpLemma [] [] `of_real_re)] "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp "simp" [] [] ["only"] ["[" [(Tactic.simpLemma [] [] `of_real_re)] "]"] [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `of_real_re
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.proj `IsROrC.ext_iff "." (fieldIdx "2"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `IsROrC.ext_iff
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Term.typeAscription
        "("
        (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
        ":"
        [`𝕜]
        ")")
       "="
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
@[ simp ]
  theorem
    inner_self_re_to_K
    { x : E } : ( re ⟪ x , x ⟫ : 𝕜 ) = ⟪ x , x ⟫
    :=
      IsROrC.ext_iff . 2
        ⟨ by simp only [ of_real_re ] , by simp only [ inner_self_nonneg_im , of_real_im ] ⟩
#align inner_self_re_to_K inner_self_re_to_K

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_self_eq_norm_sq_to_K [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x] [":" `E] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
         "="
         (Term.typeAscription
          "("
          («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "^" (num "2"))
          ":"
          [`𝕜]
          ")"))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.tacticSuffices_
            "suffices"
            (Term.sufficesDecl
             []
             («term_=_»
              (Term.typeAscription
               "("
               (Term.app
                `IsROrC.re
                [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
               ":"
               [`𝕜]
               ")")
              "="
              («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "^" (num "2")))
             (Term.byTactic'
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Std.Tactic.Simpa.simpa
                  "simpa"
                  []
                  []
                  (Std.Tactic.Simpa.simpaArgsRest
                   []
                   []
                   ["only"]
                   [(Tactic.simpArgs "[" [(Tactic.simpLemma [] [] `inner_self_re_to_K)] "]")]
                   ["using" `this]))])))))
           []
           (Tactic.NormCast.tacticExact_mod_cast_
            "exact_mod_cast"
            (Term.proj (Term.app `norm_sq_eq_inner [`x]) "." `symm))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.tacticSuffices_
           "suffices"
           (Term.sufficesDecl
            []
            («term_=_»
             (Term.typeAscription
              "("
              (Term.app
               `IsROrC.re
               [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
              ":"
              [`𝕜]
              ")")
             "="
             («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "^" (num "2")))
            (Term.byTactic'
             "by"
             (Tactic.tacticSeq
              (Tactic.tacticSeq1Indented
               [(Std.Tactic.Simpa.simpa
                 "simpa"
                 []
                 []
                 (Std.Tactic.Simpa.simpaArgsRest
                  []
                  []
                  ["only"]
                  [(Tactic.simpArgs "[" [(Tactic.simpLemma [] [] `inner_self_re_to_K)] "]")]
                  ["using" `this]))])))))
          []
          (Tactic.NormCast.tacticExact_mod_cast_
           "exact_mod_cast"
           (Term.proj (Term.app `norm_sq_eq_inner [`x]) "." `symm))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.NormCast.tacticExact_mod_cast_
       "exact_mod_cast"
       (Term.proj (Term.app `norm_sq_eq_inner [`x]) "." `symm))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.proj (Term.app `norm_sq_eq_inner [`x]) "." `symm)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.app `norm_sq_eq_inner [`x])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `norm_sq_eq_inner
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `norm_sq_eq_inner [`x]) ")")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.tacticSuffices_
       "suffices"
       (Term.sufficesDecl
        []
        («term_=_»
         (Term.typeAscription
          "("
          (Term.app `IsROrC.re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
          ":"
          [`𝕜]
          ")")
         "="
         («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "^" (num "2")))
        (Term.byTactic'
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(Std.Tactic.Simpa.simpa
             "simpa"
             []
             []
             (Std.Tactic.Simpa.simpaArgsRest
              []
              []
              ["only"]
              [(Tactic.simpArgs "[" [(Tactic.simpLemma [] [] `inner_self_re_to_K)] "]")]
              ["using" `this]))])))))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.byTactic'', expected 'Lean.Parser.Term.fromTerm'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Std.Tactic.Simpa.simpa
       "simpa"
       []
       []
       (Std.Tactic.Simpa.simpaArgsRest
        []
        []
        ["only"]
        [(Tactic.simpArgs "[" [(Tactic.simpLemma [] [] `inner_self_re_to_K)] "]")]
        ["using" `this]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `this
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_self_re_to_K
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Term.typeAscription
        "("
        (Term.app `IsROrC.re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
        ":"
        [`𝕜]
        ")")
       "="
       («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "^" (num "2")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "^" (num "2"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "2")
[PrettyPrinter.parenthesize] ...precedences are 80 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 80, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 81 >? 1024, (none, [anonymous]) <=? (some 80, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 80, (some 80, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Term.typeAscription
       "("
       (Term.app `IsROrC.re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
       ":"
       [`𝕜]
       ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `𝕜
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `IsROrC.re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_self_eq_norm_sq_to_K
  ( x : E ) : ⟪ x , x ⟫ = ( ‖ x ‖ ^ 2 : 𝕜 )
  :=
    by
      suffices
          ( IsROrC.re ⟪ x , x ⟫ : 𝕜 ) = ‖ x ‖ ^ 2 by simpa only [ inner_self_re_to_K ] using this
        exact_mod_cast norm_sq_eq_inner x . symm
#align inner_self_eq_norm_sq_to_K inner_self_eq_norm_sq_to_K

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_self_re_abs [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
         "="
         (Term.app `abs [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")]))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Mathlib.Tactic.Conv.convRHS
            "conv_rhs"
            []
            []
            "=>"
            (Tactic.Conv.convSeq
             (Tactic.Conv.convSeq1Indented
              [(Tactic.Conv.convRw__
                "rw"
                []
                (Tactic.rwRuleSeq
                 "["
                 [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_self_re_to_K)]
                 "]"))])))
           []
           (Mathlib.Tactic.tacticSymm_ "symm" [])
           []
           (Tactic.exact "exact" (Term.app `IsROrC.abs_of_nonneg [`inner_self_nonneg]))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Mathlib.Tactic.Conv.convRHS
           "conv_rhs"
           []
           []
           "=>"
           (Tactic.Conv.convSeq
            (Tactic.Conv.convSeq1Indented
             [(Tactic.Conv.convRw__
               "rw"
               []
               (Tactic.rwRuleSeq
                "["
                [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_self_re_to_K)]
                "]"))])))
          []
          (Mathlib.Tactic.tacticSymm_ "symm" [])
          []
          (Tactic.exact "exact" (Term.app `IsROrC.abs_of_nonneg [`inner_self_nonneg]))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact "exact" (Term.app `IsROrC.abs_of_nonneg [`inner_self_nonneg]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `IsROrC.abs_of_nonneg [`inner_self_nonneg])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_self_nonneg
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `IsROrC.abs_of_nonneg
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.tacticSymm_ "symm" [])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.Conv.convRHS
       "conv_rhs"
       []
       []
       "=>"
       (Tactic.Conv.convSeq
        (Tactic.Conv.convSeq1Indented
         [(Tactic.Conv.convRw__
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_self_re_to_K)]
            "]"))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.Conv.convSeq1Indented', expected 'Lean.Parser.Tactic.Conv.convSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_self_re_to_K
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
       "="
       (Term.app `abs [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `abs [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_self_re_abs
  { x : E } : re ⟪ x , x ⟫ = abs ⟪ x , x ⟫
  := by conv_rhs => rw [ ← inner_self_re_to_K ] symm exact IsROrC.abs_of_nonneg inner_self_nonneg
#align inner_self_re_abs inner_self_re_abs

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_self_abs_to_K [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.typeAscription
          "("
          (Term.app
           (Analysis.InnerProductSpace.Basic.termabsK "absK")
           [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
          ":"
          [`𝕜]
          ")")
         "="
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫"))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_self_re_abs)]
             "]")
            [])
           []
           (Tactic.exact "exact" `inner_self_re_to_K)])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_self_re_abs)]
            "]")
           [])
          []
          (Tactic.exact "exact" `inner_self_re_to_K)])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact "exact" `inner_self_re_to_K)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_self_re_to_K
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_self_re_abs)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_self_re_abs
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Term.typeAscription
        "("
        (Term.app
         (Analysis.InnerProductSpace.Basic.termabsK "absK")
         [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
        ":"
        [`𝕜]
        ")")
       "="
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_self_abs_to_K
  { x : E } : ( absK ⟪ x , x ⟫ : 𝕜 ) = ⟪ x , x ⟫
  := by rw [ ← inner_self_re_abs ] exact inner_self_re_to_K
#align inner_self_abs_to_K inner_self_abs_to_K

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `real_inner_self_abs [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x] [":" `F] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.app
          (Analysis.InnerProductSpace.Basic.termabsR "absR")
          [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫_ℝ» "⟪" `x ", " `x "⟫_ℝ")])
         "="
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫_ℝ» "⟪" `x ", " `x "⟫_ℝ"))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.tacticHave_
            "have"
            (Term.haveDecl
             (Term.haveIdDecl
              [`h []]
              []
              ":="
              (Term.app
               (Term.explicit "@" `inner_self_abs_to_K)
               [(Data.Real.Basic.termℝ "ℝ") `F (Term.hole "_") (Term.hole "_") `x]))))
           []
           (Std.Tactic.Simpa.simpa
            "simpa"
            []
            []
            (Std.Tactic.Simpa.simpaArgsRest [] [] [] [] ["using" `h]))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.tacticHave_
           "have"
           (Term.haveDecl
            (Term.haveIdDecl
             [`h []]
             []
             ":="
             (Term.app
              (Term.explicit "@" `inner_self_abs_to_K)
              [(Data.Real.Basic.termℝ "ℝ") `F (Term.hole "_") (Term.hole "_") `x]))))
          []
          (Std.Tactic.Simpa.simpa
           "simpa"
           []
           []
           (Std.Tactic.Simpa.simpaArgsRest [] [] [] [] ["using" `h]))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Std.Tactic.Simpa.simpa
       "simpa"
       []
       []
       (Std.Tactic.Simpa.simpaArgsRest [] [] [] [] ["using" `h]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.tacticHave_
       "have"
       (Term.haveDecl
        (Term.haveIdDecl
         [`h []]
         []
         ":="
         (Term.app
          (Term.explicit "@" `inner_self_abs_to_K)
          [(Data.Real.Basic.termℝ "ℝ") `F (Term.hole "_") (Term.hole "_") `x]))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       (Term.explicit "@" `inner_self_abs_to_K)
       [(Data.Real.Basic.termℝ "ℝ") `F (Term.hole "_") (Term.hole "_") `x])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      `F
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Data.Real.Basic.termℝ', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Data.Real.Basic.termℝ', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Data.Real.Basic.termℝ "ℝ")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.explicit "@" `inner_self_abs_to_K)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_self_abs_to_K
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (some 1024,
     term) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Term.app
        (Analysis.InnerProductSpace.Basic.termabsR "absR")
        [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫_ℝ» "⟪" `x ", " `x "⟫_ℝ")])
       "="
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫_ℝ» "⟪" `x ", " `x "⟫_ℝ"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫_ℝ» "⟪" `x ", " `x "⟫_ℝ")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Term.app
       (Analysis.InnerProductSpace.Basic.termabsR "absR")
       [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫_ℝ» "⟪" `x ", " `x "⟫_ℝ")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫_ℝ»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫_ℝ»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫_ℝ» "⟪" `x ", " `x "⟫_ℝ")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Analysis.InnerProductSpace.Basic.termabsR "absR")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.termabsR', expected 'Analysis.InnerProductSpace.Basic.termabsR._@.Analysis.InnerProductSpace.Basic._hyg.1003'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  real_inner_self_abs
  { x : F } : absR ⟪ x , x ⟫_ℝ = ⟪ x , x ⟫_ℝ
  := by have h := @ inner_self_abs_to_K ℝ F _ _ x simpa using h
#align real_inner_self_abs real_inner_self_abs

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_abs_conj_sym [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.app `abs [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
         "="
         (Term.app `abs [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")]))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
              ","
              (Tactic.rwRule [] `abs_conj)]
             "]")
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
             ","
             (Tactic.rwRule [] `abs_conj)]
            "]")
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
         ","
         (Tactic.rwRule [] `abs_conj)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `abs_conj
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_conj_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Term.app `abs [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
       "="
       (Term.app `abs [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `abs [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_abs_conj_sym
  { x y : E } : abs ⟪ x , y ⟫ = abs ⟪ y , x ⟫
  := by rw [ ← inner_conj_sym , abs_conj ]
#align inner_abs_conj_sym inner_abs_conj_sym

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      []
      [(Term.attributes "@[" [(Term.attrInstance (Term.attrKind []) (Attr.simp "simp" [] []))] "]")]
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_neg_left [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" («term-_» "-" `x) ", " `y "⟫")
         "="
         («term-_» "-" (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] (Term.app `neg_one_smul [`𝕜 `x]))
              ","
              (Tactic.rwRule [] `inner_smul_left)]
             "]")
            [])
           []
           (Tactic.simp "simp" [] [] [] [] [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] (Term.app `neg_one_smul [`𝕜 `x]))
             ","
             (Tactic.rwRule [] `inner_smul_left)]
            "]")
           [])
          []
          (Tactic.simp "simp" [] [] [] [] [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp "simp" [] [] [] [] [])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] (Term.app `neg_one_smul [`𝕜 `x]))
         ","
         (Tactic.rwRule [] `inner_smul_left)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_smul_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `neg_one_smul [`𝕜 `x])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `𝕜
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `neg_one_smul
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" («term-_» "-" `x) ", " `y "⟫")
       "="
       («term-_» "-" (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term-_» "-" (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
@[ simp ]
  theorem
    inner_neg_left
    { x y : E } : ⟪ - x , y ⟫ = - ⟪ x , y ⟫
    := by rw [ ← neg_one_smul 𝕜 x , inner_smul_left ] simp
#align inner_neg_left inner_neg_left

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      []
      [(Term.attributes "@[" [(Term.attrInstance (Term.attrKind []) (Attr.simp "simp" [] []))] "]")]
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_neg_right [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " («term-_» "-" `y) "⟫")
         "="
         («term-_» "-" (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.«tactic_<;>_»
            (Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq
              "["
              [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
               ","
               (Tactic.rwRule [] `inner_neg_left)]
              "]")
             [])
            "<;>"
            (Tactic.simp
             "simp"
             []
             []
             ["only"]
             ["["
              [(Tactic.simpLemma [] [] `RingHom.map_neg)
               ","
               (Tactic.simpLemma [] [] `inner_conj_sym)]
              "]"]
             []))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.«tactic_<;>_»
           (Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
              ","
              (Tactic.rwRule [] `inner_neg_left)]
             "]")
            [])
           "<;>"
           (Tactic.simp
            "simp"
            []
            []
            ["only"]
            ["["
             [(Tactic.simpLemma [] [] `RingHom.map_neg)
              ","
              (Tactic.simpLemma [] [] `inner_conj_sym)]
             "]"]
            []))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.«tactic_<;>_»
       (Tactic.rwSeq
        "rw"
        []
        (Tactic.rwRuleSeq
         "["
         [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
          ","
          (Tactic.rwRule [] `inner_neg_left)]
         "]")
        [])
       "<;>"
       (Tactic.simp
        "simp"
        []
        []
        ["only"]
        ["["
         [(Tactic.simpLemma [] [] `RingHom.map_neg) "," (Tactic.simpLemma [] [] `inner_conj_sym)]
         "]"]
        []))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] `RingHom.map_neg) "," (Tactic.simpLemma [] [] `inner_conj_sym)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_conj_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `RingHom.map_neg
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 2 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1, tactic))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
         ","
         (Tactic.rwRule [] `inner_neg_left)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_neg_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_conj_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " («term-_» "-" `y) "⟫")
       "="
       («term-_» "-" (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term-_» "-" (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
@[ simp ]
  theorem
    inner_neg_right
    { x y : E } : ⟪ x , - y ⟫ = - ⟪ x , y ⟫
    :=
      by rw [ ← inner_conj_sym , inner_neg_left ] <;> simp only [ RingHom.map_neg , inner_conj_sym ]
#align inner_neg_right inner_neg_right

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_neg_neg [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          («term-_» "-" `x)
          ", "
          («term-_» "-" `y)
          "⟫")
         "="
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(Tactic.simp "simp" [] [] [] [] [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(Tactic.simp "simp" [] [] [] [] [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp "simp" [] [] [] [] [])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        («term-_» "-" `x)
        ", "
        («term-_» "-" `y)
        "⟫")
       "="
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem inner_neg_neg { x y : E } : ⟪ - x , - y ⟫ = ⟪ x , y ⟫ := by simp
#align inner_neg_neg inner_neg_neg

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      []
      [(Term.attributes "@[" [(Term.attrInstance (Term.attrKind []) (Attr.simp "simp" [] []))] "]")]
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_self_conj [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term_†»
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
          "†")
         "="
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫"))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.«tactic_<;>_»
            (Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `IsROrC.ext_iff)] "]")
             [])
            "<;>"
            (Tactic.exact
             "exact"
             (Term.anonymousCtor
              "⟨"
              [(Term.byTactic
                "by"
                (Tactic.tacticSeq
                 (Tactic.tacticSeq1Indented
                  [(Tactic.rwSeq
                    "rw"
                    []
                    (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `conj_re)] "]")
                    [])])))
               ","
               (Term.byTactic
                "by"
                (Tactic.tacticSeq
                 (Tactic.tacticSeq1Indented
                  [(Tactic.rwSeq
                    "rw"
                    []
                    (Tactic.rwRuleSeq
                     "["
                     [(Tactic.rwRule [] `conj_im)
                      ","
                      (Tactic.rwRule [] `inner_self_im_zero)
                      ","
                      (Tactic.rwRule [] `neg_zero)]
                     "]")
                    [])])))]
              "⟩")))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.«tactic_<;>_»
           (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `IsROrC.ext_iff)] "]") [])
           "<;>"
           (Tactic.exact
            "exact"
            (Term.anonymousCtor
             "⟨"
             [(Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.rwSeq
                   "rw"
                   []
                   (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `conj_re)] "]")
                   [])])))
              ","
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.rwSeq
                   "rw"
                   []
                   (Tactic.rwRuleSeq
                    "["
                    [(Tactic.rwRule [] `conj_im)
                     ","
                     (Tactic.rwRule [] `inner_self_im_zero)
                     ","
                     (Tactic.rwRule [] `neg_zero)]
                    "]")
                   [])])))]
             "⟩")))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.«tactic_<;>_»
       (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `IsROrC.ext_iff)] "]") [])
       "<;>"
       (Tactic.exact
        "exact"
        (Term.anonymousCtor
         "⟨"
         [(Term.byTactic
           "by"
           (Tactic.tacticSeq
            (Tactic.tacticSeq1Indented
             [(Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `conj_re)] "]") [])])))
          ","
          (Term.byTactic
           "by"
           (Tactic.tacticSeq
            (Tactic.tacticSeq1Indented
             [(Tactic.rwSeq
               "rw"
               []
               (Tactic.rwRuleSeq
                "["
                [(Tactic.rwRule [] `conj_im)
                 ","
                 (Tactic.rwRule [] `inner_self_im_zero)
                 ","
                 (Tactic.rwRule [] `neg_zero)]
                "]")
               [])])))]
         "⟩")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact
       "exact"
       (Term.anonymousCtor
        "⟨"
        [(Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `conj_re)] "]") [])])))
         ","
         (Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(Tactic.rwSeq
              "rw"
              []
              (Tactic.rwRuleSeq
               "["
               [(Tactic.rwRule [] `conj_im)
                ","
                (Tactic.rwRule [] `inner_self_im_zero)
                ","
                (Tactic.rwRule [] `neg_zero)]
               "]")
              [])])))]
        "⟩"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.anonymousCtor
       "⟨"
       [(Term.byTactic
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `conj_re)] "]") [])])))
        ","
        (Term.byTactic
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq
              "["
              [(Tactic.rwRule [] `conj_im)
               ","
               (Tactic.rwRule [] `inner_self_im_zero)
               ","
               (Tactic.rwRule [] `neg_zero)]
              "]")
             [])])))]
       "⟩")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] `conj_im)
             ","
             (Tactic.rwRule [] `inner_self_im_zero)
             ","
             (Tactic.rwRule [] `neg_zero)]
            "]")
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [] `conj_im)
         ","
         (Tactic.rwRule [] `inner_self_im_zero)
         ","
         (Tactic.rwRule [] `neg_zero)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `neg_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_self_im_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `conj_im
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `conj_re)] "]") [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `conj_re)] "]") [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `conj_re
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 2 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1, tactic))
      (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `IsROrC.ext_iff)] "]") [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `IsROrC.ext_iff
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term_†»
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
        "†")
       "="
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
@[ simp ]
  theorem
    inner_self_conj
    { x : E } : ⟪ x , x ⟫ † = ⟪ x , x ⟫
    :=
      by
        rw [ IsROrC.ext_iff ]
          <;>
          exact ⟨ by rw [ conj_re ] , by rw [ conj_im , inner_self_im_zero , neg_zero ] ⟩
#align inner_self_conj inner_self_conj

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_sub_left [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y `z] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" («term_-_» `x "-" `y) ", " `z "⟫")
         "="
         («term_-_»
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `z "⟫")
          "-"
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `z "⟫")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.simp
            "simp"
            []
            []
            []
            ["["
             [(Tactic.simpLemma [] [] `sub_eq_add_neg) "," (Tactic.simpLemma [] [] `inner_add_left)]
             "]"]
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           []
           ["["
            [(Tactic.simpLemma [] [] `sub_eq_add_neg) "," (Tactic.simpLemma [] [] `inner_add_left)]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       []
       ["["
        [(Tactic.simpLemma [] [] `sub_eq_add_neg) "," (Tactic.simpLemma [] [] `inner_add_left)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_add_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `sub_eq_add_neg
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" («term_-_» `x "-" `y) ", " `z "⟫")
       "="
       («term_-_»
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `z "⟫")
        "-"
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `z "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_-_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `z "⟫")
       "-"
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `z "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `z "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_sub_left
  { x y z : E } : ⟪ x - y , z ⟫ = ⟪ x , z ⟫ - ⟪ y , z ⟫
  := by simp [ sub_eq_add_neg , inner_add_left ]
#align inner_sub_left inner_sub_left

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_sub_right [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y `z] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " («term_-_» `y "-" `z) "⟫")
         "="
         («term_-_»
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
          "-"
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `z "⟫")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.simp
            "simp"
            []
            []
            []
            ["["
             [(Tactic.simpLemma [] [] `sub_eq_add_neg)
              ","
              (Tactic.simpLemma [] [] `inner_add_right)]
             "]"]
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           []
           ["["
            [(Tactic.simpLemma [] [] `sub_eq_add_neg) "," (Tactic.simpLemma [] [] `inner_add_right)]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       []
       ["["
        [(Tactic.simpLemma [] [] `sub_eq_add_neg) "," (Tactic.simpLemma [] [] `inner_add_right)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_add_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `sub_eq_add_neg
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " («term_-_» `y "-" `z) "⟫")
       "="
       («term_-_»
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
        "-"
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `z "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_-_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
       "-"
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `z "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `z "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_sub_right
  { x y z : E } : ⟪ x , y - z ⟫ = ⟪ x , y ⟫ - ⟪ x , z ⟫
  := by simp [ sub_eq_add_neg , inner_add_right ]
#align inner_sub_right inner_sub_right

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_mul_conj_re_abs [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.app
          `re
          [(«term_*_»
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
            "*"
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))])
         "="
         (Term.app
          `abs
          [(«term_*_»
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
            "*"
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))]))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
              ","
              (Tactic.rwRule [] `mul_comm)]
             "]")
            [])
           []
           (Tactic.exact "exact" (Term.app `re_eq_abs_of_mul_conj [(Term.app `inner [`y `x])]))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
             ","
             (Tactic.rwRule [] `mul_comm)]
            "]")
           [])
          []
          (Tactic.exact "exact" (Term.app `re_eq_abs_of_mul_conj [(Term.app `inner [`y `x])]))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact "exact" (Term.app `re_eq_abs_of_mul_conj [(Term.app `inner [`y `x])]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `re_eq_abs_of_mul_conj [(Term.app `inner [`y `x])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `inner [`y `x])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `y
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `inner
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `inner [`y `x]) ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `re_eq_abs_of_mul_conj
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
         ","
         (Tactic.rwRule [] `mul_comm)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `mul_comm
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_conj_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Term.app
        `re
        [(«term_*_»
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
          "*"
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))])
       "="
       (Term.app
        `abs
        [(«term_*_»
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
          "*"
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `abs
       [(«term_*_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
         "*"
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_*_»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_*_»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
       "*"
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_mul_conj_re_abs
  { x y : E } : re ⟪ x , y ⟫ * ⟪ y , x ⟫ = abs ⟪ x , y ⟫ * ⟪ y , x ⟫
  := by rw [ ← inner_conj_sym , mul_comm ] exact re_eq_abs_of_mul_conj inner y x
#align inner_mul_conj_re_abs inner_mul_conj_re_abs

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment "/--" "Expand `⟪x + y, x + y⟫` -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_add_add_self [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          («term_+_» `x "+" `y)
          ", "
          («term_+_» `x "+" `y)
          "⟫")
         "="
         («term_+_»
          («term_+_»
           («term_+_»
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
            "+"
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))
           "+"
           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))
          "+"
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.«tactic_<;>_»
            (Tactic.simp
             "simp"
             []
             []
             ["only"]
             ["["
              [(Tactic.simpLemma [] [] `inner_add_left)
               ","
               (Tactic.simpLemma [] [] `inner_add_right)]
              "]"]
             [])
            "<;>"
            (Mathlib.Tactic.RingNF.ring "ring"))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.«tactic_<;>_»
           (Tactic.simp
            "simp"
            []
            []
            ["only"]
            ["["
             [(Tactic.simpLemma [] [] `inner_add_left)
              ","
              (Tactic.simpLemma [] [] `inner_add_right)]
             "]"]
            [])
           "<;>"
           (Mathlib.Tactic.RingNF.ring "ring"))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.«tactic_<;>_»
       (Tactic.simp
        "simp"
        []
        []
        ["only"]
        ["["
         [(Tactic.simpLemma [] [] `inner_add_left) "," (Tactic.simpLemma [] [] `inner_add_right)]
         "]"]
        [])
       "<;>"
       (Mathlib.Tactic.RingNF.ring "ring"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.RingNF.ring "ring")
[PrettyPrinter.parenthesize] ...precedences are 2 >? 1024
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1, tactic))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] `inner_add_left) "," (Tactic.simpLemma [] [] `inner_add_right)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_add_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_add_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        («term_+_» `x "+" `y)
        ", "
        («term_+_» `x "+" `y)
        "⟫")
       "="
       («term_+_»
        («term_+_»
         («term_+_»
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
          "+"
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))
         "+"
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))
        "+"
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_+_»
       («term_+_»
        («term_+_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
         "+"
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))
        "+"
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))
       "+"
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- Expand `⟪x + y, x + y⟫` -/
  theorem
    inner_add_add_self
    { x y : E } : ⟪ x + y , x + y ⟫ = ⟪ x , x ⟫ + ⟪ x , y ⟫ + ⟪ y , x ⟫ + ⟪ y , y ⟫
    := by simp only [ inner_add_left , inner_add_right ] <;> ring
#align inner_add_add_self inner_add_add_self

/-- Expand `⟪x + y, x + y⟫_ℝ` -/
theorem real_inner_add_add_self {x y : F} : ⟪x + y, x + y⟫_ℝ = ⟪x, x⟫_ℝ + 2 * ⟪x, y⟫_ℝ + ⟪y, y⟫_ℝ :=
  by
  have : ⟪y, x⟫_ℝ = ⟪x, y⟫_ℝ := by rw [← inner_conj_sym] <;> rfl
  simp only [inner_add_add_self, this, add_left_inj]
  ring
#align real_inner_add_add_self real_inner_add_add_self

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_sub_sub_self [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          («term_-_» `x "-" `y)
          ", "
          («term_-_» `x "-" `y)
          "⟫")
         "="
         («term_+_»
          («term_-_»
           («term_-_»
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
            "-"
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))
           "-"
           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))
          "+"
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.«tactic_<;>_»
            (Tactic.simp
             "simp"
             []
             []
             ["only"]
             ["["
              [(Tactic.simpLemma [] [] `inner_sub_left)
               ","
               (Tactic.simpLemma [] [] `inner_sub_right)]
              "]"]
             [])
            "<;>"
            (Mathlib.Tactic.RingNF.ring "ring"))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.«tactic_<;>_»
           (Tactic.simp
            "simp"
            []
            []
            ["only"]
            ["["
             [(Tactic.simpLemma [] [] `inner_sub_left)
              ","
              (Tactic.simpLemma [] [] `inner_sub_right)]
             "]"]
            [])
           "<;>"
           (Mathlib.Tactic.RingNF.ring "ring"))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.«tactic_<;>_»
       (Tactic.simp
        "simp"
        []
        []
        ["only"]
        ["["
         [(Tactic.simpLemma [] [] `inner_sub_left) "," (Tactic.simpLemma [] [] `inner_sub_right)]
         "]"]
        [])
       "<;>"
       (Mathlib.Tactic.RingNF.ring "ring"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.RingNF.ring "ring")
[PrettyPrinter.parenthesize] ...precedences are 2 >? 1024
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1, tactic))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] `inner_sub_left) "," (Tactic.simpLemma [] [] `inner_sub_right)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_sub_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_sub_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        («term_-_» `x "-" `y)
        ", "
        («term_-_» `x "-" `y)
        "⟫")
       "="
       («term_+_»
        («term_-_»
         («term_-_»
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
          "-"
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))
         "-"
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))
        "+"
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_+_»
       («term_-_»
        («term_-_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
         "-"
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))
        "-"
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))
       "+"
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_sub_sub_self
  { x y : E } : ⟪ x - y , x - y ⟫ = ⟪ x , x ⟫ - ⟪ x , y ⟫ - ⟪ y , x ⟫ + ⟪ y , y ⟫
  := by simp only [ inner_sub_left , inner_sub_right ] <;> ring
#align inner_sub_sub_self inner_sub_sub_self

/-- Expand `⟪x - y, x - y⟫_ℝ` -/
theorem real_inner_sub_sub_self {x y : F} : ⟪x - y, x - y⟫_ℝ = ⟪x, x⟫_ℝ - 2 * ⟪x, y⟫_ℝ + ⟪y, y⟫_ℝ :=
  by
  have : ⟪y, x⟫_ℝ = ⟪x, y⟫_ℝ := by rw [← inner_conj_sym] <;> rfl
  simp only [inner_sub_sub_self, this, add_left_inj]
  ring
#align real_inner_sub_sub_self real_inner_sub_sub_self

variable (𝕜)

include 𝕜

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `ext_inner_left [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `E] "}")
        (Term.explicitBinder
         "("
         [`h]
         [":"
          (Term.forall
           "∀"
           [`v]
           []
           ","
           («term_=_»
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `x "⟫")
            "="
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `y "⟫")))]
         []
         ")")]
       (Term.typeSpec ":" («term_=_» `x "=" `y)))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `sub_eq_zero)
              ","
              (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_self_eq_zero)
              ","
              (Tactic.rwRule [] `inner_sub_right)
              ","
              (Tactic.rwRule [] `sub_eq_zero)
              ","
              (Tactic.rwRule [] (Term.app `h [(«term_-_» `x "-" `y)]))]
             "]")
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `sub_eq_zero)
             ","
             (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_self_eq_zero)
             ","
             (Tactic.rwRule [] `inner_sub_right)
             ","
             (Tactic.rwRule [] `sub_eq_zero)
             ","
             (Tactic.rwRule [] (Term.app `h [(«term_-_» `x "-" `y)]))]
            "]")
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `sub_eq_zero)
         ","
         (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_self_eq_zero)
         ","
         (Tactic.rwRule [] `inner_sub_right)
         ","
         (Tactic.rwRule [] `sub_eq_zero)
         ","
         (Tactic.rwRule [] (Term.app `h [(«term_-_» `x "-" `y)]))]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `h [(«term_-_» `x "-" `y)])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_-_»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_-_»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_-_» `x "-" `y)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 66 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 65, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 65 >? 1024, (none, [anonymous]) <=? (some 65, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 65, (some 66, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" («term_-_» `x "-" `y) ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `sub_eq_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_sub_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_self_eq_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `sub_eq_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_» `x "=" `y)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none, [anonymous]) <=? (some 50, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 50, (some 51,
     term) <=? (some 1023, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'ident'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.hole'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.forall
       "∀"
       [`v]
       []
       ","
       («term_=_»
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `x "⟫")
        "="
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `y "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `x "⟫")
       "="
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `y "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  ext_inner_left
  { x y : E } ( h : ∀ v , ⟪ v , x ⟫ = ⟪ v , y ⟫ ) : x = y
  := by rw [ ← sub_eq_zero , ← inner_self_eq_zero , inner_sub_right , sub_eq_zero , h x - y ]
#align ext_inner_left ext_inner_left

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `ext_inner_right [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `E] "}")
        (Term.explicitBinder
         "("
         [`h]
         [":"
          (Term.forall
           "∀"
           [`v]
           []
           ","
           («term_=_»
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `v "⟫")
            "="
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `v "⟫")))]
         []
         ")")]
       (Term.typeSpec ":" («term_=_» `x "=" `y)))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `sub_eq_zero)
              ","
              (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_self_eq_zero)
              ","
              (Tactic.rwRule [] `inner_sub_left)
              ","
              (Tactic.rwRule [] `sub_eq_zero)
              ","
              (Tactic.rwRule [] (Term.app `h [(«term_-_» `x "-" `y)]))]
             "]")
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `sub_eq_zero)
             ","
             (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_self_eq_zero)
             ","
             (Tactic.rwRule [] `inner_sub_left)
             ","
             (Tactic.rwRule [] `sub_eq_zero)
             ","
             (Tactic.rwRule [] (Term.app `h [(«term_-_» `x "-" `y)]))]
            "]")
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `sub_eq_zero)
         ","
         (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_self_eq_zero)
         ","
         (Tactic.rwRule [] `inner_sub_left)
         ","
         (Tactic.rwRule [] `sub_eq_zero)
         ","
         (Tactic.rwRule [] (Term.app `h [(«term_-_» `x "-" `y)]))]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `h [(«term_-_» `x "-" `y)])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_-_»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_-_»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_-_» `x "-" `y)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 66 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 65, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 65 >? 1024, (none, [anonymous]) <=? (some 65, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 65, (some 66, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" («term_-_» `x "-" `y) ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `sub_eq_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_sub_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_self_eq_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `sub_eq_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_» `x "=" `y)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none, [anonymous]) <=? (some 50, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 50, (some 51,
     term) <=? (some 1023, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'ident'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.hole'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.forall
       "∀"
       [`v]
       []
       ","
       («term_=_»
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `v "⟫")
        "="
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `v "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `v "⟫")
       "="
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `v "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `v "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  ext_inner_right
  { x y : E } ( h : ∀ v , ⟪ x , v ⟫ = ⟪ y , v ⟫ ) : x = y
  := by rw [ ← sub_eq_zero , ← inner_self_eq_zero , inner_sub_left , sub_eq_zero , h x - y ]
#align ext_inner_right ext_inner_right

omit 𝕜

variable {𝕜}

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [(Command.docComment "/--" "Parallelogram law -/")] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `parallelogram_law [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         («term_+_»
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           («term_+_» `x "+" `y)
           ", "
           («term_+_» `x "+" `y)
           "⟫")
          "+"
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           («term_-_» `x "-" `y)
           ", "
           («term_-_» `x "-" `y)
           "⟫"))
         "="
         («term_*_»
          (num "2")
          "*"
          («term_+_»
           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
           "+"
           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫"))))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.simp
            "simp"
            []
            []
            []
            ["["
             [(Tactic.simpLemma [] [] `inner_add_add_self)
              ","
              (Tactic.simpLemma [] [] `inner_sub_sub_self)
              ","
              (Tactic.simpLemma [] [] `two_mul)
              ","
              (Tactic.simpLemma [] [] `sub_eq_add_neg)
              ","
              (Tactic.simpLemma [] [] `add_comm)
              ","
              (Tactic.simpLemma [] [] `add_left_comm)]
             "]"]
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           []
           ["["
            [(Tactic.simpLemma [] [] `inner_add_add_self)
             ","
             (Tactic.simpLemma [] [] `inner_sub_sub_self)
             ","
             (Tactic.simpLemma [] [] `two_mul)
             ","
             (Tactic.simpLemma [] [] `sub_eq_add_neg)
             ","
             (Tactic.simpLemma [] [] `add_comm)
             ","
             (Tactic.simpLemma [] [] `add_left_comm)]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       []
       ["["
        [(Tactic.simpLemma [] [] `inner_add_add_self)
         ","
         (Tactic.simpLemma [] [] `inner_sub_sub_self)
         ","
         (Tactic.simpLemma [] [] `two_mul)
         ","
         (Tactic.simpLemma [] [] `sub_eq_add_neg)
         ","
         (Tactic.simpLemma [] [] `add_comm)
         ","
         (Tactic.simpLemma [] [] `add_left_comm)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `add_left_comm
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `add_comm
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `sub_eq_add_neg
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `two_mul
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_sub_sub_self
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_add_add_self
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       («term_+_»
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
         "⟪"
         («term_+_» `x "+" `y)
         ", "
         («term_+_» `x "+" `y)
         "⟫")
        "+"
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
         "⟪"
         («term_-_» `x "-" `y)
         ", "
         («term_-_» `x "-" `y)
         "⟫"))
       "="
       («term_*_»
        (num "2")
        "*"
        («term_+_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
         "+"
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫"))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (num "2")
       "*"
       («term_+_»
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
        "+"
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_+_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
       "+"
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- Parallelogram law -/
  theorem
    parallelogram_law
    { x y : E } : ⟪ x + y , x + y ⟫ + ⟪ x - y , x - y ⟫ = 2 * ⟪ x , x ⟫ + ⟪ y , y ⟫
    :=
      by
        simp
          [
            inner_add_add_self
              ,
              inner_sub_sub_self
              ,
              two_mul
              ,
              sub_eq_add_neg
              ,
              add_comm
              ,
              add_left_comm
            ]
#align parallelogram_law parallelogram_law

/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic tactic.field_simp.ne_zero -/
/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "Cauchy–Schwarz inequality. This proof follows \"Proof 2\" on Wikipedia. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_mul_inner_self_le [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x `y] [":" `E] [] ")")]
       (Term.typeSpec
        ":"
        («term_≤_»
         («term_*_»
          (Term.app `abs [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
          "*"
          (Term.app `abs [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")]))
         "≤"
         («term_*_»
          (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
          "*"
          (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")])))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Classical.«tacticBy_cases_:_» "by_cases" [`hy ":"] («term_=_» `y "=" (num "0")))
           []
           (tactic__
            (cdotTk (patternIgnore (token.«· » "·")))
            [(Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `hy)] "]") [])
             []
             (Tactic.simp
              "simp"
              []
              []
              ["only"]
              ["["
               [(Tactic.simpLemma [] [] `IsROrC.abs_zero)
                ","
                (Tactic.simpLemma [] [] `inner_zero_left)
                ","
                (Tactic.simpLemma [] [] `mul_zero)
                ","
                (Tactic.simpLemma [] [] `AddMonoidHom.map_zero)]
               "]"]
              [])])
           []
           (tactic__
            (cdotTk (patternIgnore (token.«· » "·")))
            [(Tactic.tacticHave_
              "have"
              (Term.haveDecl
               (Term.haveIdDecl
                [`hy' []]
                [(Term.typeSpec
                  ":"
                  («term_≠_»
                   (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")
                   "≠"
                   (num "0")))]
                ":="
                (Term.app (Term.proj `inner_self_eq_zero.not "." (fieldIdx "2")) [`hy]))))
             []
             (Mathlib.Tactic.set
              "set"
              []
              (Mathlib.Tactic.setArgsRest
               `T
               []
               ":="
               («term_/_»
                (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")
                "/"
                (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫"))
               ["with" [] `hT]))
             []
             (Tactic.tacticHave_
              "have"
              (Term.haveDecl
               (Term.haveIdDecl
                [`h₁ []]
                [(Term.typeSpec
                  ":"
                  («term_=_»
                   (Term.app
                    `re
                    [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")])
                   "="
                   (Term.app
                    `re
                    [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))]
                ":="
                `inner_re_symm)))
             []
             (Tactic.tacticHave_
              "have"
              (Term.haveDecl
               (Term.haveIdDecl
                [`h₂ []]
                [(Term.typeSpec
                  ":"
                  («term_=_»
                   (Term.app
                    `im
                    [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")])
                   "="
                   («term-_»
                    "-"
                    (Term.app
                     `im
                     [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")]))))]
                ":="
                `inner_im_symm)))
             []
             (Tactic.tacticHave_
              "have"
              (Term.haveDecl
               (Term.haveIdDecl
                [`h₃ []]
                [(Term.typeSpec
                  ":"
                  («term_=_»
                   («term_/_»
                    («term_*_»
                     («term_*_»
                      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")
                      "*"
                      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))
                     "*"
                     (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫"))
                    "/"
                    («term_*_»
                     (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")
                     "*"
                     (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")))
                   "="
                   («term_/_»
                    («term_*_»
                     (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")
                     "*"
                     (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))
                    "/"
                    (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫"))))]
                ":="
                (Term.byTactic
                 "by"
                 (Tactic.tacticSeq
                  (Tactic.tacticSeq1Indented
                   [(Tactic.rwSeq
                     "rw"
                     []
                     (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `mul_div_assoc)] "]")
                     [])
                    []
                    (Tactic.tacticHave_
                     "have"
                     (Term.haveDecl
                      (Term.haveIdDecl
                       []
                       [(Term.typeSpec
                         ":"
                         («term_=_»
                          («term_/_»
                           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")
                           "/"
                           («term_*_»
                            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")
                            "*"
                            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")))
                          "="
                          («term_/_»
                           (num "1")
                           "/"
                           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫"))))]
                       ":="
                       (Term.byTactic
                        "by"
                        (Tactic.tacticSeq
                         (Tactic.tacticSeq1Indented
                          [(Tactic.rwSeq
                            "rw"
                            []
                            (Tactic.rwRuleSeq
                             "["
                             [(Tactic.rwRule [] `div_mul_eq_div_mul_one_div)
                              ","
                              (Tactic.rwRule [] (Term.app `div_self [`hy']))
                              ","
                              (Tactic.rwRule [] `one_mul)]
                             "]")
                            [])]))))))
                    []
                    (Tactic.rwSeq
                     "rw"
                     []
                     (Tactic.rwRuleSeq
                      "["
                      [(Tactic.rwRule [] `this)
                       ","
                       (Tactic.rwRule [] `div_eq_mul_inv)
                       ","
                       (Tactic.rwRule [] `one_mul)
                       ","
                       (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `div_eq_mul_inv)]
                      "]")
                     [])]))))))
             []
             (Tactic.tacticHave_
              "have"
              (Term.haveDecl
               (Term.haveIdDecl
                [`h₄ []]
                [(Term.typeSpec
                  ":"
                  («term_=_»
                   (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")
                   "="
                   (Term.app
                    `re
                    [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")])))]
                ":="
                `inner_self_re_to_K.symm)))
             []
             (Tactic.tacticHave_
              "have"
              (Term.haveDecl
               (Term.haveIdDecl
                [`h₅ []]
                [(Term.typeSpec
                  ":"
                  («term_>_»
                   (Term.app
                    `re
                    [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")])
                   ">"
                   (num "0")))]
                ":="
                (Term.byTactic
                 "by"
                 (Tactic.tacticSeq
                  (Tactic.tacticSeq1Indented
                   [(Tactic.refine'
                     "refine'"
                     (Term.app `lt_of_le_of_ne [`inner_self_nonneg (Term.hole "_")]))
                    []
                    (Tactic.intro "intro" [`H])
                    []
                    (Tactic.apply "apply" `hy')
                    []
                    (Tactic.rwSeq
                     "rw"
                     []
                     (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `IsROrC.ext_iff)] "]")
                     [])
                    []
                    (Tactic.exact
                     "exact"
                     (Term.anonymousCtor
                      "⟨"
                      [(Term.byTactic
                        "by"
                        (Tactic.tacticSeq
                         (Tactic.tacticSeq1Indented
                          [(Tactic.simp
                            "simp"
                            []
                            []
                            ["only"]
                            ["["
                             [(Tactic.simpLemma [] [] `H) "," (Tactic.simpLemma [] [] `zero_re')]
                             "]"]
                            [])])))
                       ","
                       (Term.byTactic
                        "by"
                        (Tactic.tacticSeq
                         (Tactic.tacticSeq1Indented
                          [(Tactic.simp
                            "simp"
                            []
                            []
                            ["only"]
                            ["["
                             [(Tactic.simpLemma [] [] `inner_self_nonneg_im)
                              ","
                              (Tactic.simpLemma [] [] `AddMonoidHom.map_zero)]
                             "]"]
                            [])])))]
                      "⟩"))]))))))
             []
             (Tactic.tacticHave_
              "have"
              (Term.haveDecl
               (Term.haveIdDecl
                [`h₆ []]
                [(Term.typeSpec
                  ":"
                  («term_≠_»
                   (Term.app
                    `re
                    [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")])
                   "≠"
                   (num "0")))]
                ":="
                (Term.app `ne_of_gt [`h₅]))))
             []
             (Tactic.tacticHave_
              "have"
              (Term.haveDecl
               (Term.haveIdDecl
                [`hmain []]
                []
                ":="
                (calc
                 "calc"
                 (calcStep
                  («term_≤_»
                   (num "0")
                   "≤"
                   (Term.app
                    `re
                    [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                      "⟪"
                      («term_-_» `x "-" (Algebra.Group.Defs.«term_•_» `T " • " `y))
                      ", "
                      («term_-_» `x "-" (Algebra.Group.Defs.«term_•_» `T " • " `y))
                      "⟫")]))
                  ":="
                  `inner_self_nonneg)
                 [(calcStep
                   («term_=_»
                    (Term.hole "_")
                    "="
                    («term_+_»
                     («term_-_»
                      («term_-_»
                       (Term.app
                        `re
                        [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                       "-"
                       (Term.app
                        `re
                        [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                          "⟪"
                          (Algebra.Group.Defs.«term_•_» `T " • " `y)
                          ", "
                          `x
                          "⟫")]))
                      "-"
                      (Term.app
                       `re
                       [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                         "⟪"
                         `x
                         ", "
                         (Algebra.Group.Defs.«term_•_» `T " • " `y)
                         "⟫")]))
                     "+"
                     (Term.app
                      `re
                      [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                        "⟪"
                        (Algebra.Group.Defs.«term_•_» `T " • " `y)
                        ", "
                        (Algebra.Group.Defs.«term_•_» `T " • " `y)
                        "⟫")])))
                   ":="
                   (Term.byTactic
                    "by"
                    (Tactic.tacticSeq
                     (Tactic.tacticSeq1Indented
                      [(Tactic.simp
                        "simp"
                        []
                        []
                        ["only"]
                        ["["
                         [(Tactic.simpLemma [] [] `inner_sub_sub_self)
                          ","
                          (Tactic.simpLemma [] [] `inner_smul_left)
                          ","
                          (Tactic.simpLemma [] [] `inner_smul_right)
                          ","
                          (Tactic.simpLemma [] [] `h₁)
                          ","
                          (Tactic.simpLemma [] [] `h₂)
                          ","
                          (Tactic.simpLemma [] [] `neg_mul)
                          ","
                          (Tactic.simpLemma [] [] `AddMonoidHom.map_add)
                          ","
                          (Tactic.simpLemma [] [] `conj_im)
                          ","
                          (Tactic.simpLemma [] [] `AddMonoidHom.map_sub)
                          ","
                          (Tactic.simpLemma [] [] `mul_neg)
                          ","
                          (Tactic.simpLemma [] [] `conj_re)
                          ","
                          (Tactic.simpLemma [] [] `neg_neg)
                          ","
                          (Tactic.simpLemma [] [] `mul_re)]
                         "]"]
                        [])]))))
                  (calcStep
                   («term_=_»
                    (Term.hole "_")
                    "="
                    («term_+_»
                     («term_-_»
                      («term_-_»
                       (Term.app
                        `re
                        [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                       "-"
                       (Term.app
                        `re
                        [(«term_*_»
                          (Analysis.InnerProductSpace.Basic.«term_†» `T "†")
                          "*"
                          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))]))
                      "-"
                      (Term.app
                       `re
                       [(«term_*_»
                         `T
                         "*"
                         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))]))
                     "+"
                     (Term.app
                      `re
                      [(«term_*_»
                        («term_*_» `T "*" (Analysis.InnerProductSpace.Basic.«term_†» `T "†"))
                        "*"
                        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫"))])))
                   ":="
                   (Term.byTactic
                    "by"
                    (Tactic.tacticSeq
                     (Tactic.tacticSeq1Indented
                      [(Tactic.simp
                        "simp"
                        []
                        []
                        ["only"]
                        ["["
                         [(Tactic.simpLemma [] [] `inner_smul_left)
                          ","
                          (Tactic.simpLemma [] [] `inner_smul_right)
                          ","
                          (Tactic.simpLemma [] [] `mul_assoc)]
                         "]"]
                        [])]))))
                  (calcStep
                   («term_=_»
                    (Term.hole "_")
                    "="
                    («term_-_»
                     (Term.app
                      `re
                      [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                     "-"
                     (Term.app
                      `re
                      [(«term_*_»
                        («term_/_»
                         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
                         "/"
                         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫"))
                        "*"
                        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))])))
                   ":="
                   (Term.byTactic
                    "by"
                    (Tactic.tacticSeq
                     (Tactic.tacticSeq1Indented
                      [(Tactic.simp
                        "simp"
                        []
                        [(Tactic.discharger
                          "("
                          (patternIgnore (token.disch "disch"))
                          ":="
                          (Tactic.tacticSeq
                           (Tactic.tacticSeq1Indented
                            [(Mathlib.RunCmd.runTac
                              "run_tac"
                              (Term.doSeqIndent
                               [(Term.doSeqItem (Term.doExpr `tactic.field_simp.ne_zero) [])]))]))
                          ")")]
                        ["only"]
                        ["["
                         [(Tactic.simpLemma [] [] `map_div₀)
                          ","
                          (Tactic.simpLemma [] [] `h₃)
                          ","
                          (Tactic.simpLemma [] [] `inner_conj_sym)
                          ","
                          (Tactic.simpLemma [] [] `sub_add_cancel)
                          ","
                          (Tactic.simpLemma [] [] `field_simps)]
                         "]"]
                        [])]))))
                  (calcStep
                   («term_=_»
                    (Term.hole "_")
                    "="
                    («term_-_»
                     (Term.app
                      `re
                      [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                     "-"
                     (Term.app
                      `re
                      [(«term_/_»
                        («term_*_»
                         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
                         "*"
                         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))
                        "/"
                        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫"))])))
                   ":="
                   (Term.byTactic
                    "by"
                    (Tactic.tacticSeq
                     (Tactic.tacticSeq1Indented
                      [(Tactic.rwSeq
                        "rw"
                        []
                        (Tactic.rwRuleSeq
                         "["
                         [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `mul_div_right_comm)]
                         "]")
                        [])]))))
                  (calcStep
                   («term_=_»
                    (Term.hole "_")
                    "="
                    («term_-_»
                     (Term.app
                      `re
                      [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                     "-"
                     (Term.app
                      `re
                      [(«term_/_»
                        («term_*_»
                         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
                         "*"
                         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))
                        "/"
                        (Term.app
                         `re
                         [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")]))])))
                   ":="
                   (Term.byTactic
                    "by"
                    (Tactic.tacticSeq
                     (Tactic.tacticSeq1Indented
                      [(Mathlib.Tactic.Conv.convLHS
                        "conv_lhs"
                        []
                        []
                        "=>"
                        (Tactic.Conv.convSeq
                         (Tactic.Conv.convSeq1Indented
                          [(Tactic.Conv.convRw__
                            "rw"
                            []
                            (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `h₄)] "]"))])))]))))
                  (calcStep
                   («term_=_»
                    (Term.hole "_")
                    "="
                    («term_-_»
                     (Term.app
                      `re
                      [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                     "-"
                     («term_/_»
                      (Term.app
                       `re
                       [(«term_*_»
                         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
                         "*"
                         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))])
                      "/"
                      (Term.app
                       `re
                       [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")]))))
                   ":="
                   (Term.byTactic
                    "by"
                    (Tactic.tacticSeq
                     (Tactic.tacticSeq1Indented
                      [(Tactic.rwSeq
                        "rw"
                        []
                        (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `div_re_of_real)] "]")
                        [])]))))
                  (calcStep
                   («term_=_»
                    (Term.hole "_")
                    "="
                    («term_-_»
                     (Term.app
                      `re
                      [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                     "-"
                     («term_/_»
                      (Term.app
                       `abs
                       [(«term_*_»
                         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
                         "*"
                         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))])
                      "/"
                      (Term.app
                       `re
                       [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")]))))
                   ":="
                   (Term.byTactic
                    "by"
                    (Tactic.tacticSeq
                     (Tactic.tacticSeq1Indented
                      [(Tactic.rwSeq
                        "rw"
                        []
                        (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_mul_conj_re_abs)] "]")
                        [])]))))
                  (calcStep
                   («term_=_»
                    (Term.hole "_")
                    "="
                    («term_-_»
                     (Term.app
                      `re
                      [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                     "-"
                     («term_/_»
                      («term_*_»
                       (Term.app
                        `abs
                        [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
                       "*"
                       (Term.app
                        `abs
                        [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")]))
                      "/"
                      (Term.app
                       `re
                       [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")]))))
                   ":="
                   (Term.byTactic
                    "by"
                    (Tactic.tacticSeq
                     (Tactic.tacticSeq1Indented
                      [(Tactic.rwSeq
                        "rw"
                        []
                        (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `IsROrC.abs_mul)] "]")
                        [])]))))]))))
             []
             (Tactic.tacticHave_
              "have"
              (Term.haveDecl
               (Term.haveIdDecl
                [`hmain' []]
                [(Term.typeSpec
                  ":"
                  («term_≤_»
                   («term_/_»
                    («term_*_»
                     (Term.app
                      `abs
                      [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
                     "*"
                     (Term.app
                      `abs
                      [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")]))
                    "/"
                    (Term.app
                     `re
                     [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")]))
                   "≤"
                   (Term.app
                    `re
                    [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])))]
                ":="
                (Term.byTactic
                 "by"
                 (Tactic.tacticSeq
                  (Tactic.tacticSeq1Indented
                   [(linarith "linarith" [] (linarithArgsRest [] [] []))]))))))
             []
             (Tactic.tacticHave_
              "have"
              (Term.haveDecl
               (Term.haveIdDecl
                []
                []
                ":="
                (Term.app (Term.proj (Term.app `mul_le_mul_right [`h₅]) "." `mpr) [`hmain']))))
             []
             (Std.Tactic.tacticRwa__
              "rwa"
              (Tactic.rwRuleSeq
               "["
               [(Tactic.rwRule
                 []
                 (Term.app
                  `div_mul_cancel
                  [(«term_*_»
                    (Term.app
                     `abs
                     [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
                    "*"
                    (Term.app
                     `abs
                     [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")]))
                   `h₆]))]
               "]")
              [(Tactic.location "at" (Tactic.locationHyp [`this] []))])])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Classical.«tacticBy_cases_:_» "by_cases" [`hy ":"] («term_=_» `y "=" (num "0")))
          []
          (tactic__
           (cdotTk (patternIgnore (token.«· » "·")))
           [(Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `hy)] "]") [])
            []
            (Tactic.simp
             "simp"
             []
             []
             ["only"]
             ["["
              [(Tactic.simpLemma [] [] `IsROrC.abs_zero)
               ","
               (Tactic.simpLemma [] [] `inner_zero_left)
               ","
               (Tactic.simpLemma [] [] `mul_zero)
               ","
               (Tactic.simpLemma [] [] `AddMonoidHom.map_zero)]
              "]"]
             [])])
          []
          (tactic__
           (cdotTk (patternIgnore (token.«· » "·")))
           [(Tactic.tacticHave_
             "have"
             (Term.haveDecl
              (Term.haveIdDecl
               [`hy' []]
               [(Term.typeSpec
                 ":"
                 («term_≠_»
                  (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")
                  "≠"
                  (num "0")))]
               ":="
               (Term.app (Term.proj `inner_self_eq_zero.not "." (fieldIdx "2")) [`hy]))))
            []
            (Mathlib.Tactic.set
             "set"
             []
             (Mathlib.Tactic.setArgsRest
              `T
              []
              ":="
              («term_/_»
               (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")
               "/"
               (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫"))
              ["with" [] `hT]))
            []
            (Tactic.tacticHave_
             "have"
             (Term.haveDecl
              (Term.haveIdDecl
               [`h₁ []]
               [(Term.typeSpec
                 ":"
                 («term_=_»
                  (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")])
                  "="
                  (Term.app
                   `re
                   [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))]
               ":="
               `inner_re_symm)))
            []
            (Tactic.tacticHave_
             "have"
             (Term.haveDecl
              (Term.haveIdDecl
               [`h₂ []]
               [(Term.typeSpec
                 ":"
                 («term_=_»
                  (Term.app `im [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")])
                  "="
                  («term-_»
                   "-"
                   (Term.app
                    `im
                    [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")]))))]
               ":="
               `inner_im_symm)))
            []
            (Tactic.tacticHave_
             "have"
             (Term.haveDecl
              (Term.haveIdDecl
               [`h₃ []]
               [(Term.typeSpec
                 ":"
                 («term_=_»
                  («term_/_»
                   («term_*_»
                    («term_*_»
                     (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")
                     "*"
                     (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))
                    "*"
                    (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫"))
                   "/"
                   («term_*_»
                    (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")
                    "*"
                    (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")))
                  "="
                  («term_/_»
                   («term_*_»
                    (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")
                    "*"
                    (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))
                   "/"
                   (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫"))))]
               ":="
               (Term.byTactic
                "by"
                (Tactic.tacticSeq
                 (Tactic.tacticSeq1Indented
                  [(Tactic.rwSeq
                    "rw"
                    []
                    (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `mul_div_assoc)] "]")
                    [])
                   []
                   (Tactic.tacticHave_
                    "have"
                    (Term.haveDecl
                     (Term.haveIdDecl
                      []
                      [(Term.typeSpec
                        ":"
                        («term_=_»
                         («term_/_»
                          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")
                          "/"
                          («term_*_»
                           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")
                           "*"
                           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")))
                         "="
                         («term_/_»
                          (num "1")
                          "/"
                          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫"))))]
                      ":="
                      (Term.byTactic
                       "by"
                       (Tactic.tacticSeq
                        (Tactic.tacticSeq1Indented
                         [(Tactic.rwSeq
                           "rw"
                           []
                           (Tactic.rwRuleSeq
                            "["
                            [(Tactic.rwRule [] `div_mul_eq_div_mul_one_div)
                             ","
                             (Tactic.rwRule [] (Term.app `div_self [`hy']))
                             ","
                             (Tactic.rwRule [] `one_mul)]
                            "]")
                           [])]))))))
                   []
                   (Tactic.rwSeq
                    "rw"
                    []
                    (Tactic.rwRuleSeq
                     "["
                     [(Tactic.rwRule [] `this)
                      ","
                      (Tactic.rwRule [] `div_eq_mul_inv)
                      ","
                      (Tactic.rwRule [] `one_mul)
                      ","
                      (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `div_eq_mul_inv)]
                     "]")
                    [])]))))))
            []
            (Tactic.tacticHave_
             "have"
             (Term.haveDecl
              (Term.haveIdDecl
               [`h₄ []]
               [(Term.typeSpec
                 ":"
                 («term_=_»
                  (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")
                  "="
                  (Term.app
                   `re
                   [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")])))]
               ":="
               `inner_self_re_to_K.symm)))
            []
            (Tactic.tacticHave_
             "have"
             (Term.haveDecl
              (Term.haveIdDecl
               [`h₅ []]
               [(Term.typeSpec
                 ":"
                 («term_>_»
                  (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")])
                  ">"
                  (num "0")))]
               ":="
               (Term.byTactic
                "by"
                (Tactic.tacticSeq
                 (Tactic.tacticSeq1Indented
                  [(Tactic.refine'
                    "refine'"
                    (Term.app `lt_of_le_of_ne [`inner_self_nonneg (Term.hole "_")]))
                   []
                   (Tactic.intro "intro" [`H])
                   []
                   (Tactic.apply "apply" `hy')
                   []
                   (Tactic.rwSeq
                    "rw"
                    []
                    (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `IsROrC.ext_iff)] "]")
                    [])
                   []
                   (Tactic.exact
                    "exact"
                    (Term.anonymousCtor
                     "⟨"
                     [(Term.byTactic
                       "by"
                       (Tactic.tacticSeq
                        (Tactic.tacticSeq1Indented
                         [(Tactic.simp
                           "simp"
                           []
                           []
                           ["only"]
                           ["["
                            [(Tactic.simpLemma [] [] `H) "," (Tactic.simpLemma [] [] `zero_re')]
                            "]"]
                           [])])))
                      ","
                      (Term.byTactic
                       "by"
                       (Tactic.tacticSeq
                        (Tactic.tacticSeq1Indented
                         [(Tactic.simp
                           "simp"
                           []
                           []
                           ["only"]
                           ["["
                            [(Tactic.simpLemma [] [] `inner_self_nonneg_im)
                             ","
                             (Tactic.simpLemma [] [] `AddMonoidHom.map_zero)]
                            "]"]
                           [])])))]
                     "⟩"))]))))))
            []
            (Tactic.tacticHave_
             "have"
             (Term.haveDecl
              (Term.haveIdDecl
               [`h₆ []]
               [(Term.typeSpec
                 ":"
                 («term_≠_»
                  (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")])
                  "≠"
                  (num "0")))]
               ":="
               (Term.app `ne_of_gt [`h₅]))))
            []
            (Tactic.tacticHave_
             "have"
             (Term.haveDecl
              (Term.haveIdDecl
               [`hmain []]
               []
               ":="
               (calc
                "calc"
                (calcStep
                 («term_≤_»
                  (num "0")
                  "≤"
                  (Term.app
                   `re
                   [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     («term_-_» `x "-" (Algebra.Group.Defs.«term_•_» `T " • " `y))
                     ", "
                     («term_-_» `x "-" (Algebra.Group.Defs.«term_•_» `T " • " `y))
                     "⟫")]))
                 ":="
                 `inner_self_nonneg)
                [(calcStep
                  («term_=_»
                   (Term.hole "_")
                   "="
                   («term_+_»
                    («term_-_»
                     («term_-_»
                      (Term.app
                       `re
                       [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                      "-"
                      (Term.app
                       `re
                       [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                         "⟪"
                         (Algebra.Group.Defs.«term_•_» `T " • " `y)
                         ", "
                         `x
                         "⟫")]))
                     "-"
                     (Term.app
                      `re
                      [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                        "⟪"
                        `x
                        ", "
                        (Algebra.Group.Defs.«term_•_» `T " • " `y)
                        "⟫")]))
                    "+"
                    (Term.app
                     `re
                     [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                       "⟪"
                       (Algebra.Group.Defs.«term_•_» `T " • " `y)
                       ", "
                       (Algebra.Group.Defs.«term_•_» `T " • " `y)
                       "⟫")])))
                  ":="
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(Tactic.simp
                       "simp"
                       []
                       []
                       ["only"]
                       ["["
                        [(Tactic.simpLemma [] [] `inner_sub_sub_self)
                         ","
                         (Tactic.simpLemma [] [] `inner_smul_left)
                         ","
                         (Tactic.simpLemma [] [] `inner_smul_right)
                         ","
                         (Tactic.simpLemma [] [] `h₁)
                         ","
                         (Tactic.simpLemma [] [] `h₂)
                         ","
                         (Tactic.simpLemma [] [] `neg_mul)
                         ","
                         (Tactic.simpLemma [] [] `AddMonoidHom.map_add)
                         ","
                         (Tactic.simpLemma [] [] `conj_im)
                         ","
                         (Tactic.simpLemma [] [] `AddMonoidHom.map_sub)
                         ","
                         (Tactic.simpLemma [] [] `mul_neg)
                         ","
                         (Tactic.simpLemma [] [] `conj_re)
                         ","
                         (Tactic.simpLemma [] [] `neg_neg)
                         ","
                         (Tactic.simpLemma [] [] `mul_re)]
                        "]"]
                       [])]))))
                 (calcStep
                  («term_=_»
                   (Term.hole "_")
                   "="
                   («term_+_»
                    («term_-_»
                     («term_-_»
                      (Term.app
                       `re
                       [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                      "-"
                      (Term.app
                       `re
                       [(«term_*_»
                         (Analysis.InnerProductSpace.Basic.«term_†» `T "†")
                         "*"
                         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))]))
                     "-"
                     (Term.app
                      `re
                      [(«term_*_»
                        `T
                        "*"
                        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))]))
                    "+"
                    (Term.app
                     `re
                     [(«term_*_»
                       («term_*_» `T "*" (Analysis.InnerProductSpace.Basic.«term_†» `T "†"))
                       "*"
                       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫"))])))
                  ":="
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(Tactic.simp
                       "simp"
                       []
                       []
                       ["only"]
                       ["["
                        [(Tactic.simpLemma [] [] `inner_smul_left)
                         ","
                         (Tactic.simpLemma [] [] `inner_smul_right)
                         ","
                         (Tactic.simpLemma [] [] `mul_assoc)]
                        "]"]
                       [])]))))
                 (calcStep
                  («term_=_»
                   (Term.hole "_")
                   "="
                   («term_-_»
                    (Term.app
                     `re
                     [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                    "-"
                    (Term.app
                     `re
                     [(«term_*_»
                       («term_/_»
                        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
                        "/"
                        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫"))
                       "*"
                       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))])))
                  ":="
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(Tactic.simp
                       "simp"
                       []
                       [(Tactic.discharger
                         "("
                         (patternIgnore (token.disch "disch"))
                         ":="
                         (Tactic.tacticSeq
                          (Tactic.tacticSeq1Indented
                           [(Mathlib.RunCmd.runTac
                             "run_tac"
                             (Term.doSeqIndent
                              [(Term.doSeqItem (Term.doExpr `tactic.field_simp.ne_zero) [])]))]))
                         ")")]
                       ["only"]
                       ["["
                        [(Tactic.simpLemma [] [] `map_div₀)
                         ","
                         (Tactic.simpLemma [] [] `h₃)
                         ","
                         (Tactic.simpLemma [] [] `inner_conj_sym)
                         ","
                         (Tactic.simpLemma [] [] `sub_add_cancel)
                         ","
                         (Tactic.simpLemma [] [] `field_simps)]
                        "]"]
                       [])]))))
                 (calcStep
                  («term_=_»
                   (Term.hole "_")
                   "="
                   («term_-_»
                    (Term.app
                     `re
                     [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                    "-"
                    (Term.app
                     `re
                     [(«term_/_»
                       («term_*_»
                        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
                        "*"
                        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))
                       "/"
                       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫"))])))
                  ":="
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(Tactic.rwSeq
                       "rw"
                       []
                       (Tactic.rwRuleSeq
                        "["
                        [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `mul_div_right_comm)]
                        "]")
                       [])]))))
                 (calcStep
                  («term_=_»
                   (Term.hole "_")
                   "="
                   («term_-_»
                    (Term.app
                     `re
                     [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                    "-"
                    (Term.app
                     `re
                     [(«term_/_»
                       («term_*_»
                        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
                        "*"
                        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))
                       "/"
                       (Term.app
                        `re
                        [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")]))])))
                  ":="
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(Mathlib.Tactic.Conv.convLHS
                       "conv_lhs"
                       []
                       []
                       "=>"
                       (Tactic.Conv.convSeq
                        (Tactic.Conv.convSeq1Indented
                         [(Tactic.Conv.convRw__
                           "rw"
                           []
                           (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `h₄)] "]"))])))]))))
                 (calcStep
                  («term_=_»
                   (Term.hole "_")
                   "="
                   («term_-_»
                    (Term.app
                     `re
                     [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                    "-"
                    («term_/_»
                     (Term.app
                      `re
                      [(«term_*_»
                        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
                        "*"
                        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))])
                     "/"
                     (Term.app
                      `re
                      [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")]))))
                  ":="
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(Tactic.rwSeq
                       "rw"
                       []
                       (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `div_re_of_real)] "]")
                       [])]))))
                 (calcStep
                  («term_=_»
                   (Term.hole "_")
                   "="
                   («term_-_»
                    (Term.app
                     `re
                     [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                    "-"
                    («term_/_»
                     (Term.app
                      `abs
                      [(«term_*_»
                        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
                        "*"
                        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))])
                     "/"
                     (Term.app
                      `re
                      [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")]))))
                  ":="
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(Tactic.rwSeq
                       "rw"
                       []
                       (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_mul_conj_re_abs)] "]")
                       [])]))))
                 (calcStep
                  («term_=_»
                   (Term.hole "_")
                   "="
                   («term_-_»
                    (Term.app
                     `re
                     [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                    "-"
                    («term_/_»
                     («term_*_»
                      (Term.app
                       `abs
                       [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
                      "*"
                      (Term.app
                       `abs
                       [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")]))
                     "/"
                     (Term.app
                      `re
                      [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")]))))
                  ":="
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(Tactic.rwSeq
                       "rw"
                       []
                       (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `IsROrC.abs_mul)] "]")
                       [])]))))]))))
            []
            (Tactic.tacticHave_
             "have"
             (Term.haveDecl
              (Term.haveIdDecl
               [`hmain' []]
               [(Term.typeSpec
                 ":"
                 («term_≤_»
                  («term_/_»
                   («term_*_»
                    (Term.app
                     `abs
                     [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
                    "*"
                    (Term.app
                     `abs
                     [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")]))
                   "/"
                   (Term.app
                    `re
                    [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")]))
                  "≤"
                  (Term.app
                   `re
                   [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])))]
               ":="
               (Term.byTactic
                "by"
                (Tactic.tacticSeq
                 (Tactic.tacticSeq1Indented
                  [(linarith "linarith" [] (linarithArgsRest [] [] []))]))))))
            []
            (Tactic.tacticHave_
             "have"
             (Term.haveDecl
              (Term.haveIdDecl
               []
               []
               ":="
               (Term.app (Term.proj (Term.app `mul_le_mul_right [`h₅]) "." `mpr) [`hmain']))))
            []
            (Std.Tactic.tacticRwa__
             "rwa"
             (Tactic.rwRuleSeq
              "["
              [(Tactic.rwRule
                []
                (Term.app
                 `div_mul_cancel
                 [(«term_*_»
                   (Term.app
                    `abs
                    [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
                   "*"
                   (Term.app
                    `abs
                    [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")]))
                  `h₆]))]
              "]")
             [(Tactic.location "at" (Tactic.locationHyp [`this] []))])])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.«· » "·")))
       [(Tactic.tacticHave_
         "have"
         (Term.haveDecl
          (Term.haveIdDecl
           [`hy' []]
           [(Term.typeSpec
             ":"
             («term_≠_»
              (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")
              "≠"
              (num "0")))]
           ":="
           (Term.app (Term.proj `inner_self_eq_zero.not "." (fieldIdx "2")) [`hy]))))
        []
        (Mathlib.Tactic.set
         "set"
         []
         (Mathlib.Tactic.setArgsRest
          `T
          []
          ":="
          («term_/_»
           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")
           "/"
           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫"))
          ["with" [] `hT]))
        []
        (Tactic.tacticHave_
         "have"
         (Term.haveDecl
          (Term.haveIdDecl
           [`h₁ []]
           [(Term.typeSpec
             ":"
             («term_=_»
              (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")])
              "="
              (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))]
           ":="
           `inner_re_symm)))
        []
        (Tactic.tacticHave_
         "have"
         (Term.haveDecl
          (Term.haveIdDecl
           [`h₂ []]
           [(Term.typeSpec
             ":"
             («term_=_»
              (Term.app `im [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")])
              "="
              («term-_»
               "-"
               (Term.app
                `im
                [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")]))))]
           ":="
           `inner_im_symm)))
        []
        (Tactic.tacticHave_
         "have"
         (Term.haveDecl
          (Term.haveIdDecl
           [`h₃ []]
           [(Term.typeSpec
             ":"
             («term_=_»
              («term_/_»
               («term_*_»
                («term_*_»
                 (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")
                 "*"
                 (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))
                "*"
                (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫"))
               "/"
               («term_*_»
                (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")
                "*"
                (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")))
              "="
              («term_/_»
               («term_*_»
                (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")
                "*"
                (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))
               "/"
               (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫"))))]
           ":="
           (Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.rwSeq
                "rw"
                []
                (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `mul_div_assoc)] "]")
                [])
               []
               (Tactic.tacticHave_
                "have"
                (Term.haveDecl
                 (Term.haveIdDecl
                  []
                  [(Term.typeSpec
                    ":"
                    («term_=_»
                     («term_/_»
                      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")
                      "/"
                      («term_*_»
                       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")
                       "*"
                       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")))
                     "="
                     («term_/_»
                      (num "1")
                      "/"
                      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫"))))]
                  ":="
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(Tactic.rwSeq
                       "rw"
                       []
                       (Tactic.rwRuleSeq
                        "["
                        [(Tactic.rwRule [] `div_mul_eq_div_mul_one_div)
                         ","
                         (Tactic.rwRule [] (Term.app `div_self [`hy']))
                         ","
                         (Tactic.rwRule [] `one_mul)]
                        "]")
                       [])]))))))
               []
               (Tactic.rwSeq
                "rw"
                []
                (Tactic.rwRuleSeq
                 "["
                 [(Tactic.rwRule [] `this)
                  ","
                  (Tactic.rwRule [] `div_eq_mul_inv)
                  ","
                  (Tactic.rwRule [] `one_mul)
                  ","
                  (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `div_eq_mul_inv)]
                 "]")
                [])]))))))
        []
        (Tactic.tacticHave_
         "have"
         (Term.haveDecl
          (Term.haveIdDecl
           [`h₄ []]
           [(Term.typeSpec
             ":"
             («term_=_»
              (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")
              "="
              (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")])))]
           ":="
           `inner_self_re_to_K.symm)))
        []
        (Tactic.tacticHave_
         "have"
         (Term.haveDecl
          (Term.haveIdDecl
           [`h₅ []]
           [(Term.typeSpec
             ":"
             («term_>_»
              (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")])
              ">"
              (num "0")))]
           ":="
           (Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.refine'
                "refine'"
                (Term.app `lt_of_le_of_ne [`inner_self_nonneg (Term.hole "_")]))
               []
               (Tactic.intro "intro" [`H])
               []
               (Tactic.apply "apply" `hy')
               []
               (Tactic.rwSeq
                "rw"
                []
                (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `IsROrC.ext_iff)] "]")
                [])
               []
               (Tactic.exact
                "exact"
                (Term.anonymousCtor
                 "⟨"
                 [(Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(Tactic.simp
                       "simp"
                       []
                       []
                       ["only"]
                       ["["
                        [(Tactic.simpLemma [] [] `H) "," (Tactic.simpLemma [] [] `zero_re')]
                        "]"]
                       [])])))
                  ","
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(Tactic.simp
                       "simp"
                       []
                       []
                       ["only"]
                       ["["
                        [(Tactic.simpLemma [] [] `inner_self_nonneg_im)
                         ","
                         (Tactic.simpLemma [] [] `AddMonoidHom.map_zero)]
                        "]"]
                       [])])))]
                 "⟩"))]))))))
        []
        (Tactic.tacticHave_
         "have"
         (Term.haveDecl
          (Term.haveIdDecl
           [`h₆ []]
           [(Term.typeSpec
             ":"
             («term_≠_»
              (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")])
              "≠"
              (num "0")))]
           ":="
           (Term.app `ne_of_gt [`h₅]))))
        []
        (Tactic.tacticHave_
         "have"
         (Term.haveDecl
          (Term.haveIdDecl
           [`hmain []]
           []
           ":="
           (calc
            "calc"
            (calcStep
             («term_≤_»
              (num "0")
              "≤"
              (Term.app
               `re
               [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                 "⟪"
                 («term_-_» `x "-" (Algebra.Group.Defs.«term_•_» `T " • " `y))
                 ", "
                 («term_-_» `x "-" (Algebra.Group.Defs.«term_•_» `T " • " `y))
                 "⟫")]))
             ":="
             `inner_self_nonneg)
            [(calcStep
              («term_=_»
               (Term.hole "_")
               "="
               («term_+_»
                («term_-_»
                 («term_-_»
                  (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                  "-"
                  (Term.app
                   `re
                   [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     (Algebra.Group.Defs.«term_•_» `T " • " `y)
                     ", "
                     `x
                     "⟫")]))
                 "-"
                 (Term.app
                  `re
                  [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                    "⟪"
                    `x
                    ", "
                    (Algebra.Group.Defs.«term_•_» `T " • " `y)
                    "⟫")]))
                "+"
                (Term.app
                 `re
                 [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                   "⟪"
                   (Algebra.Group.Defs.«term_•_» `T " • " `y)
                   ", "
                   (Algebra.Group.Defs.«term_•_» `T " • " `y)
                   "⟫")])))
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.simp
                   "simp"
                   []
                   []
                   ["only"]
                   ["["
                    [(Tactic.simpLemma [] [] `inner_sub_sub_self)
                     ","
                     (Tactic.simpLemma [] [] `inner_smul_left)
                     ","
                     (Tactic.simpLemma [] [] `inner_smul_right)
                     ","
                     (Tactic.simpLemma [] [] `h₁)
                     ","
                     (Tactic.simpLemma [] [] `h₂)
                     ","
                     (Tactic.simpLemma [] [] `neg_mul)
                     ","
                     (Tactic.simpLemma [] [] `AddMonoidHom.map_add)
                     ","
                     (Tactic.simpLemma [] [] `conj_im)
                     ","
                     (Tactic.simpLemma [] [] `AddMonoidHom.map_sub)
                     ","
                     (Tactic.simpLemma [] [] `mul_neg)
                     ","
                     (Tactic.simpLemma [] [] `conj_re)
                     ","
                     (Tactic.simpLemma [] [] `neg_neg)
                     ","
                     (Tactic.simpLemma [] [] `mul_re)]
                    "]"]
                   [])]))))
             (calcStep
              («term_=_»
               (Term.hole "_")
               "="
               («term_+_»
                («term_-_»
                 («term_-_»
                  (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                  "-"
                  (Term.app
                   `re
                   [(«term_*_»
                     (Analysis.InnerProductSpace.Basic.«term_†» `T "†")
                     "*"
                     (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))]))
                 "-"
                 (Term.app
                  `re
                  [(«term_*_»
                    `T
                    "*"
                    (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))]))
                "+"
                (Term.app
                 `re
                 [(«term_*_»
                   («term_*_» `T "*" (Analysis.InnerProductSpace.Basic.«term_†» `T "†"))
                   "*"
                   (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫"))])))
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.simp
                   "simp"
                   []
                   []
                   ["only"]
                   ["["
                    [(Tactic.simpLemma [] [] `inner_smul_left)
                     ","
                     (Tactic.simpLemma [] [] `inner_smul_right)
                     ","
                     (Tactic.simpLemma [] [] `mul_assoc)]
                    "]"]
                   [])]))))
             (calcStep
              («term_=_»
               (Term.hole "_")
               "="
               («term_-_»
                (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                "-"
                (Term.app
                 `re
                 [(«term_*_»
                   («term_/_»
                    (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
                    "/"
                    (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫"))
                   "*"
                   (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))])))
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.simp
                   "simp"
                   []
                   [(Tactic.discharger
                     "("
                     (patternIgnore (token.disch "disch"))
                     ":="
                     (Tactic.tacticSeq
                      (Tactic.tacticSeq1Indented
                       [(Mathlib.RunCmd.runTac
                         "run_tac"
                         (Term.doSeqIndent
                          [(Term.doSeqItem (Term.doExpr `tactic.field_simp.ne_zero) [])]))]))
                     ")")]
                   ["only"]
                   ["["
                    [(Tactic.simpLemma [] [] `map_div₀)
                     ","
                     (Tactic.simpLemma [] [] `h₃)
                     ","
                     (Tactic.simpLemma [] [] `inner_conj_sym)
                     ","
                     (Tactic.simpLemma [] [] `sub_add_cancel)
                     ","
                     (Tactic.simpLemma [] [] `field_simps)]
                    "]"]
                   [])]))))
             (calcStep
              («term_=_»
               (Term.hole "_")
               "="
               («term_-_»
                (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                "-"
                (Term.app
                 `re
                 [(«term_/_»
                   («term_*_»
                    (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
                    "*"
                    (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))
                   "/"
                   (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫"))])))
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.rwSeq
                   "rw"
                   []
                   (Tactic.rwRuleSeq
                    "["
                    [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `mul_div_right_comm)]
                    "]")
                   [])]))))
             (calcStep
              («term_=_»
               (Term.hole "_")
               "="
               («term_-_»
                (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                "-"
                (Term.app
                 `re
                 [(«term_/_»
                   («term_*_»
                    (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
                    "*"
                    (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))
                   "/"
                   (Term.app
                    `re
                    [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")]))])))
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Mathlib.Tactic.Conv.convLHS
                   "conv_lhs"
                   []
                   []
                   "=>"
                   (Tactic.Conv.convSeq
                    (Tactic.Conv.convSeq1Indented
                     [(Tactic.Conv.convRw__
                       "rw"
                       []
                       (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `h₄)] "]"))])))]))))
             (calcStep
              («term_=_»
               (Term.hole "_")
               "="
               («term_-_»
                (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                "-"
                («term_/_»
                 (Term.app
                  `re
                  [(«term_*_»
                    (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
                    "*"
                    (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))])
                 "/"
                 (Term.app
                  `re
                  [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")]))))
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.rwSeq
                   "rw"
                   []
                   (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `div_re_of_real)] "]")
                   [])]))))
             (calcStep
              («term_=_»
               (Term.hole "_")
               "="
               («term_-_»
                (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                "-"
                («term_/_»
                 (Term.app
                  `abs
                  [(«term_*_»
                    (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
                    "*"
                    (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))])
                 "/"
                 (Term.app
                  `re
                  [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")]))))
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.rwSeq
                   "rw"
                   []
                   (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_mul_conj_re_abs)] "]")
                   [])]))))
             (calcStep
              («term_=_»
               (Term.hole "_")
               "="
               («term_-_»
                (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                "-"
                («term_/_»
                 («term_*_»
                  (Term.app
                   `abs
                   [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
                  "*"
                  (Term.app
                   `abs
                   [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")]))
                 "/"
                 (Term.app
                  `re
                  [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")]))))
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.rwSeq
                   "rw"
                   []
                   (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `IsROrC.abs_mul)] "]")
                   [])]))))]))))
        []
        (Tactic.tacticHave_
         "have"
         (Term.haveDecl
          (Term.haveIdDecl
           [`hmain' []]
           [(Term.typeSpec
             ":"
             («term_≤_»
              («term_/_»
               («term_*_»
                (Term.app `abs [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
                "*"
                (Term.app `abs [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")]))
               "/"
               (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")]))
              "≤"
              (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])))]
           ":="
           (Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented [(linarith "linarith" [] (linarithArgsRest [] [] []))]))))))
        []
        (Tactic.tacticHave_
         "have"
         (Term.haveDecl
          (Term.haveIdDecl
           []
           []
           ":="
           (Term.app (Term.proj (Term.app `mul_le_mul_right [`h₅]) "." `mpr) [`hmain']))))
        []
        (Std.Tactic.tacticRwa__
         "rwa"
         (Tactic.rwRuleSeq
          "["
          [(Tactic.rwRule
            []
            (Term.app
             `div_mul_cancel
             [(«term_*_»
               (Term.app `abs [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
               "*"
               (Term.app `abs [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")]))
              `h₆]))]
          "]")
         [(Tactic.location "at" (Tactic.locationHyp [`this] []))])])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Std.Tactic.tacticRwa__
       "rwa"
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule
          []
          (Term.app
           `div_mul_cancel
           [(«term_*_»
             (Term.app `abs [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
             "*"
             (Term.app `abs [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")]))
            `h₆]))]
        "]")
       [(Tactic.location "at" (Tactic.locationHyp [`this] []))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.locationHyp', expected 'Lean.Parser.Tactic.locationWildcard'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `this
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `div_mul_cancel
       [(«term_*_»
         (Term.app `abs [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
         "*"
         (Term.app `abs [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")]))
        `h₆])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h₆
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_*_»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_*_»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      («term_*_»
       (Term.app `abs [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
       "*"
       (Term.app `abs [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `abs [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- Cauchy–Schwarz inequality. This proof follows "Proof 2" on Wikipedia. -/
  theorem
    inner_mul_inner_self_le
    ( x y : E ) : abs ⟪ x , y ⟫ * abs ⟪ y , x ⟫ ≤ re ⟪ x , x ⟫ * re ⟪ y , y ⟫
    :=
      by
        by_cases hy : y = 0
          ·
            rw [ hy ]
              simp only [ IsROrC.abs_zero , inner_zero_left , mul_zero , AddMonoidHom.map_zero ]
          ·
            have hy' : ⟪ y , y ⟫ ≠ 0 := inner_self_eq_zero.not . 2 hy
              set T := ⟪ y , x ⟫ / ⟪ y , y ⟫ with hT
              have h₁ : re ⟪ y , x ⟫ = re ⟪ x , y ⟫ := inner_re_symm
              have h₂ : im ⟪ y , x ⟫ = - im ⟪ x , y ⟫ := inner_im_symm
              have
                h₃
                  :
                    ⟪ y , x ⟫ * ⟪ x , y ⟫ * ⟪ y , y ⟫ / ⟪ y , y ⟫ * ⟪ y , y ⟫
                      =
                      ⟪ y , x ⟫ * ⟪ x , y ⟫ / ⟪ y , y ⟫
                  :=
                  by
                    rw [ mul_div_assoc ]
                      have
                        : ⟪ y , y ⟫ / ⟪ y , y ⟫ * ⟪ y , y ⟫ = 1 / ⟪ y , y ⟫
                          :=
                          by rw [ div_mul_eq_div_mul_one_div , div_self hy' , one_mul ]
                      rw [ this , div_eq_mul_inv , one_mul , ← div_eq_mul_inv ]
              have h₄ : ⟪ y , y ⟫ = re ⟪ y , y ⟫ := inner_self_re_to_K.symm
              have
                h₅
                  : re ⟪ y , y ⟫ > 0
                  :=
                  by
                    refine' lt_of_le_of_ne inner_self_nonneg _
                      intro H
                      apply hy'
                      rw [ IsROrC.ext_iff ]
                      exact
                        ⟨
                          by simp only [ H , zero_re' ]
                            ,
                            by simp only [ inner_self_nonneg_im , AddMonoidHom.map_zero ]
                          ⟩
              have h₆ : re ⟪ y , y ⟫ ≠ 0 := ne_of_gt h₅
              have
                hmain
                  :=
                  calc
                    0 ≤ re ⟪ x - T • y , x - T • y ⟫ := inner_self_nonneg
                    _ = re ⟪ x , x ⟫ - re ⟪ T • y , x ⟫ - re ⟪ x , T • y ⟫ + re ⟪ T • y , T • y ⟫
                        :=
                        by
                          simp
                            only
                            [
                              inner_sub_sub_self
                                ,
                                inner_smul_left
                                ,
                                inner_smul_right
                                ,
                                h₁
                                ,
                                h₂
                                ,
                                neg_mul
                                ,
                                AddMonoidHom.map_add
                                ,
                                conj_im
                                ,
                                AddMonoidHom.map_sub
                                ,
                                mul_neg
                                ,
                                conj_re
                                ,
                                neg_neg
                                ,
                                mul_re
                              ]
                      _
                          =
                          re ⟪ x , x ⟫ - re T † * ⟪ y , x ⟫ - re T * ⟪ x , y ⟫
                            +
                            re T * T † * ⟪ y , y ⟫
                        :=
                        by simp only [ inner_smul_left , inner_smul_right , mul_assoc ]
                      _ = re ⟪ x , x ⟫ - re ⟪ x , y ⟫ / ⟪ y , y ⟫ * ⟪ y , x ⟫
                        :=
                        by
                          simp
                            ( disch := run_tac tactic.field_simp.ne_zero )
                            only
                            [ map_div₀ , h₃ , inner_conj_sym , sub_add_cancel , field_simps ]
                      _ = re ⟪ x , x ⟫ - re ⟪ x , y ⟫ * ⟪ y , x ⟫ / ⟪ y , y ⟫
                        :=
                        by rw [ ← mul_div_right_comm ]
                      _ = re ⟪ x , x ⟫ - re ⟪ x , y ⟫ * ⟪ y , x ⟫ / re ⟪ y , y ⟫
                        :=
                        by conv_lhs => rw [ h₄ ]
                      _ = re ⟪ x , x ⟫ - re ⟪ x , y ⟫ * ⟪ y , x ⟫ / re ⟪ y , y ⟫
                        :=
                        by rw [ div_re_of_real ]
                      _ = re ⟪ x , x ⟫ - abs ⟪ x , y ⟫ * ⟪ y , x ⟫ / re ⟪ y , y ⟫
                        :=
                        by rw [ inner_mul_conj_re_abs ]
                      _ = re ⟪ x , x ⟫ - abs ⟪ x , y ⟫ * abs ⟪ y , x ⟫ / re ⟪ y , y ⟫
                        :=
                        by rw [ IsROrC.abs_mul ]
              have
                hmain' : abs ⟪ x , y ⟫ * abs ⟪ y , x ⟫ / re ⟪ y , y ⟫ ≤ re ⟪ x , x ⟫ := by linarith
              have := mul_le_mul_right h₅ . mpr hmain'
              rwa [ div_mul_cancel abs ⟪ x , y ⟫ * abs ⟪ y , x ⟫ h₆ ] at this
#align inner_mul_inner_self_le inner_mul_inner_self_le

/-- Cauchy–Schwarz inequality for real inner products. -/
theorem real_inner_mul_inner_self_le (x y : F) : ⟪x, y⟫_ℝ * ⟪x, y⟫_ℝ ≤ ⟪x, x⟫_ℝ * ⟪y, y⟫_ℝ :=
  by
  have h₁ : ⟪y, x⟫_ℝ = ⟪x, y⟫_ℝ := by rw [← inner_conj_sym] <;> rfl
  have h₂ := @inner_mul_inner_self_le ℝ F _ _ x y
  dsimp at h₂
  have h₃ := abs_mul_abs_self ⟪x, y⟫_ℝ
  rw [h₁] at h₂
  simpa [h₃] using h₂
#align real_inner_mul_inner_self_le real_inner_mul_inner_self_le

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "A family of vectors is linearly independent if they are nonzero\nand orthogonal. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `linear_independent_of_ne_zero_of_inner_eq_zero [])
      (Command.declSig
       [(Term.implicitBinder "{" [`ι] [":" (Term.type "Type" [(Level.hole "_")])] "}")
        (Term.implicitBinder "{" [`v] [":" (Term.arrow `ι "→" `E)] "}")
        (Term.explicitBinder
         "("
         [`hz]
         [":" (Term.forall "∀" [`i] [] "," («term_≠_» (Term.app `v [`i]) "≠" (num "0")))]
         []
         ")")
        (Term.explicitBinder
         "("
         [`ho]
         [":"
          (Term.forall
           "∀"
           [`i `j]
           []
           ","
           (Term.arrow
            («term_≠_» `i "≠" `j)
            "→"
            («term_=_»
             (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
              "⟪"
              (Term.app `v [`i])
              ", "
              (Term.app `v [`j])
              "⟫")
             "="
             (num "0"))))]
         []
         ")")]
       (Term.typeSpec ":" (Term.app `LinearIndependent [`𝕜 `v])))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `linear_independent_iff')] "]")
            [])
           []
           (Tactic.intro "intro" [`s `g `hg `i `hi])
           []
           (Tactic.tacticHave_
            "have"
            (Term.haveDecl
             (Term.haveIdDecl
              [`h' []]
              [(Term.typeSpec
                ":"
                («term_=_»
                 («term_*_»
                  (Term.app `g [`i])
                  "*"
                  (Term.app `inner [(Term.app `v [`i]) (Term.app `v [`i])]))
                 "="
                 (Term.app
                  `inner
                  [(Term.app `v [`i])
                   (BigOperators.Algebra.BigOperators.Basic.finset.sum
                    "∑"
                    (Std.ExtendedBinder.extBinders
                     (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) []))
                    " in "
                    `s
                    ", "
                    (Algebra.Group.Defs.«term_•_» (Term.app `g [`j]) " • " (Term.app `v [`j])))])))]
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.rwSeq
                   "rw"
                   []
                   (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_sum)] "]")
                   [])
                  []
                  (Mathlib.Tactic.tacticSymm_ "symm" [])
                  []
                  (convert
                   "convert"
                   []
                   (Term.app `Finset.sum_eq_single [`i (Term.hole "_") (Term.hole "_")])
                   [])
                  []
                  (tactic__
                   (cdotTk (patternIgnore (token.«· » "·")))
                   [(Tactic.rwSeq
                     "rw"
                     []
                     (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_smul_right)] "]")
                     [])])
                  []
                  (tactic__
                   (cdotTk (patternIgnore (token.«· » "·")))
                   [(Tactic.intro "intro" [`j `hj `hji])
                    []
                    (Tactic.rwSeq
                     "rw"
                     []
                     (Tactic.rwRuleSeq
                      "["
                      [(Tactic.rwRule [] `inner_smul_right)
                       ","
                       (Tactic.rwRule [] (Term.app `ho [`i `j `hji.symm]))
                       ","
                       (Tactic.rwRule [] `mul_zero)]
                      "]")
                     [])])
                  []
                  (tactic__
                   (cdotTk (patternIgnore (token.«· » "·")))
                   [(Tactic.exact
                     "exact"
                     (Term.fun
                      "fun"
                      (Term.basicFun
                       [`h]
                       []
                       "=>"
                       (Term.app `False.elim [(Term.app `h [`hi])]))))])]))))))
           []
           (Std.Tactic.Simpa.simpa
            "simpa"
            []
            []
            (Std.Tactic.Simpa.simpaArgsRest
             []
             []
             []
             [(Tactic.simpArgs
               "["
               [(Tactic.simpLemma [] [] `hg) "," (Tactic.simpLemma [] [] `hz)]
               "]")]
             ["using" `h']))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `linear_independent_iff')] "]")
           [])
          []
          (Tactic.intro "intro" [`s `g `hg `i `hi])
          []
          (Tactic.tacticHave_
           "have"
           (Term.haveDecl
            (Term.haveIdDecl
             [`h' []]
             [(Term.typeSpec
               ":"
               («term_=_»
                («term_*_»
                 (Term.app `g [`i])
                 "*"
                 (Term.app `inner [(Term.app `v [`i]) (Term.app `v [`i])]))
                "="
                (Term.app
                 `inner
                 [(Term.app `v [`i])
                  (BigOperators.Algebra.BigOperators.Basic.finset.sum
                   "∑"
                   (Std.ExtendedBinder.extBinders
                    (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) []))
                   " in "
                   `s
                   ", "
                   (Algebra.Group.Defs.«term_•_» (Term.app `g [`j]) " • " (Term.app `v [`j])))])))]
             ":="
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Tactic.rwSeq
                  "rw"
                  []
                  (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_sum)] "]")
                  [])
                 []
                 (Mathlib.Tactic.tacticSymm_ "symm" [])
                 []
                 (convert
                  "convert"
                  []
                  (Term.app `Finset.sum_eq_single [`i (Term.hole "_") (Term.hole "_")])
                  [])
                 []
                 (tactic__
                  (cdotTk (patternIgnore (token.«· » "·")))
                  [(Tactic.rwSeq
                    "rw"
                    []
                    (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_smul_right)] "]")
                    [])])
                 []
                 (tactic__
                  (cdotTk (patternIgnore (token.«· » "·")))
                  [(Tactic.intro "intro" [`j `hj `hji])
                   []
                   (Tactic.rwSeq
                    "rw"
                    []
                    (Tactic.rwRuleSeq
                     "["
                     [(Tactic.rwRule [] `inner_smul_right)
                      ","
                      (Tactic.rwRule [] (Term.app `ho [`i `j `hji.symm]))
                      ","
                      (Tactic.rwRule [] `mul_zero)]
                     "]")
                    [])])
                 []
                 (tactic__
                  (cdotTk (patternIgnore (token.«· » "·")))
                  [(Tactic.exact
                    "exact"
                    (Term.fun
                     "fun"
                     (Term.basicFun
                      [`h]
                      []
                      "=>"
                      (Term.app `False.elim [(Term.app `h [`hi])]))))])]))))))
          []
          (Std.Tactic.Simpa.simpa
           "simpa"
           []
           []
           (Std.Tactic.Simpa.simpaArgsRest
            []
            []
            []
            [(Tactic.simpArgs
              "["
              [(Tactic.simpLemma [] [] `hg) "," (Tactic.simpLemma [] [] `hz)]
              "]")]
            ["using" `h']))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Std.Tactic.Simpa.simpa
       "simpa"
       []
       []
       (Std.Tactic.Simpa.simpaArgsRest
        []
        []
        []
        [(Tactic.simpArgs "[" [(Tactic.simpLemma [] [] `hg) "," (Tactic.simpLemma [] [] `hz)] "]")]
        ["using" `h']))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hz
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hg
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.tacticHave_
       "have"
       (Term.haveDecl
        (Term.haveIdDecl
         [`h' []]
         [(Term.typeSpec
           ":"
           («term_=_»
            («term_*_»
             (Term.app `g [`i])
             "*"
             (Term.app `inner [(Term.app `v [`i]) (Term.app `v [`i])]))
            "="
            (Term.app
             `inner
             [(Term.app `v [`i])
              (BigOperators.Algebra.BigOperators.Basic.finset.sum
               "∑"
               (Std.ExtendedBinder.extBinders
                (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) []))
               " in "
               `s
               ", "
               (Algebra.Group.Defs.«term_•_» (Term.app `g [`j]) " • " (Term.app `v [`j])))])))]
         ":="
         (Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_sum)] "]") [])
             []
             (Mathlib.Tactic.tacticSymm_ "symm" [])
             []
             (convert
              "convert"
              []
              (Term.app `Finset.sum_eq_single [`i (Term.hole "_") (Term.hole "_")])
              [])
             []
             (tactic__
              (cdotTk (patternIgnore (token.«· » "·")))
              [(Tactic.rwSeq
                "rw"
                []
                (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_smul_right)] "]")
                [])])
             []
             (tactic__
              (cdotTk (patternIgnore (token.«· » "·")))
              [(Tactic.intro "intro" [`j `hj `hji])
               []
               (Tactic.rwSeq
                "rw"
                []
                (Tactic.rwRuleSeq
                 "["
                 [(Tactic.rwRule [] `inner_smul_right)
                  ","
                  (Tactic.rwRule [] (Term.app `ho [`i `j `hji.symm]))
                  ","
                  (Tactic.rwRule [] `mul_zero)]
                 "]")
                [])])
             []
             (tactic__
              (cdotTk (patternIgnore (token.«· » "·")))
              [(Tactic.exact
                "exact"
                (Term.fun
                 "fun"
                 (Term.basicFun
                  [`h]
                  []
                  "=>"
                  (Term.app `False.elim [(Term.app `h [`hi])]))))])]))))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_sum)] "]") [])
          []
          (Mathlib.Tactic.tacticSymm_ "symm" [])
          []
          (convert
           "convert"
           []
           (Term.app `Finset.sum_eq_single [`i (Term.hole "_") (Term.hole "_")])
           [])
          []
          (tactic__
           (cdotTk (patternIgnore (token.«· » "·")))
           [(Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_smul_right)] "]")
             [])])
          []
          (tactic__
           (cdotTk (patternIgnore (token.«· » "·")))
           [(Tactic.intro "intro" [`j `hj `hji])
            []
            (Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq
              "["
              [(Tactic.rwRule [] `inner_smul_right)
               ","
               (Tactic.rwRule [] (Term.app `ho [`i `j `hji.symm]))
               ","
               (Tactic.rwRule [] `mul_zero)]
              "]")
             [])])
          []
          (tactic__
           (cdotTk (patternIgnore (token.«· » "·")))
           [(Tactic.exact
             "exact"
             (Term.fun
              "fun"
              (Term.basicFun [`h] [] "=>" (Term.app `False.elim [(Term.app `h [`hi])]))))])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.«· » "·")))
       [(Tactic.exact
         "exact"
         (Term.fun
          "fun"
          (Term.basicFun [`h] [] "=>" (Term.app `False.elim [(Term.app `h [`hi])]))))])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact
       "exact"
       (Term.fun "fun" (Term.basicFun [`h] [] "=>" (Term.app `False.elim [(Term.app `h [`hi])]))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun "fun" (Term.basicFun [`h] [] "=>" (Term.app `False.elim [(Term.app `h [`hi])])))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `False.elim [(Term.app `h [`hi])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `h [`hi])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hi
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `h [`hi]) ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `False.elim
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.«· » "·")))
       [(Tactic.intro "intro" [`j `hj `hji])
        []
        (Tactic.rwSeq
         "rw"
         []
         (Tactic.rwRuleSeq
          "["
          [(Tactic.rwRule [] `inner_smul_right)
           ","
           (Tactic.rwRule [] (Term.app `ho [`i `j `hji.symm]))
           ","
           (Tactic.rwRule [] `mul_zero)]
          "]")
         [])])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [] `inner_smul_right)
         ","
         (Tactic.rwRule [] (Term.app `ho [`i `j `hji.symm]))
         ","
         (Tactic.rwRule [] `mul_zero)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `mul_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `ho [`i `j `hji.symm])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hji.symm
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `j
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `i
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `ho
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_smul_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.intro "intro" [`j `hj `hji])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hji
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `hj
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `j
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.«· » "·")))
       [(Tactic.rwSeq
         "rw"
         []
         (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_smul_right)] "]")
         [])])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_smul_right)] "]") [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_smul_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (convert
       "convert"
       []
       (Term.app `Finset.sum_eq_single [`i (Term.hole "_") (Term.hole "_")])
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `Finset.sum_eq_single [`i (Term.hole "_") (Term.hole "_")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      `i
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `Finset.sum_eq_single
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.tacticSymm_ "symm" [])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_sum)] "]") [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_sum
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_»
       («term_*_» (Term.app `g [`i]) "*" (Term.app `inner [(Term.app `v [`i]) (Term.app `v [`i])]))
       "="
       (Term.app
        `inner
        [(Term.app `v [`i])
         (BigOperators.Algebra.BigOperators.Basic.finset.sum
          "∑"
          (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) []))
          " in "
          `s
          ", "
          (Algebra.Group.Defs.«term_•_» (Term.app `g [`j]) " • " (Term.app `v [`j])))]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `inner
       [(Term.app `v [`i])
        (BigOperators.Algebra.BigOperators.Basic.finset.sum
         "∑"
         (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) []))
         " in "
         `s
         ", "
         (Algebra.Group.Defs.«term_•_» (Term.app `g [`j]) " • " (Term.app `v [`j])))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'BigOperators.Algebra.BigOperators.Basic.finset.sum', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'BigOperators.Algebra.BigOperators.Basic.finset.sum', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (BigOperators.Algebra.BigOperators.Basic.finset.sum
       "∑"
       (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) []))
       " in "
       `s
       ", "
       (Algebra.Group.Defs.«term_•_» (Term.app `g [`j]) " • " (Term.app `v [`j])))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Algebra.Group.Defs.«term_•_» (Term.app `g [`j]) " • " (Term.app `v [`j]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `v [`j])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `j
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `v
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 73 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 73, term))
      (Term.app `g [`j])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `j
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `g
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 74 >? 1022, (some 1023, term) <=? (some 73, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 73, (some 73, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `s
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (BigOperators.Algebra.BigOperators.Basic.finset.sum
      "∑"
      (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) []))
      " in "
      `s
      ", "
      (Algebra.Group.Defs.«term_•_» (Term.app `g [`j]) " • " (Term.app `v [`j])))
     ")")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.app `v [`i])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `i
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `v
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `v [`i]) ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `inner
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      («term_*_» (Term.app `g [`i]) "*" (Term.app `inner [(Term.app `v [`i]) (Term.app `v [`i])]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `inner [(Term.app `v [`i]) (Term.app `v [`i])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `v [`i])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `i
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `v
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `v [`i]) ")")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.app `v [`i])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `i
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `v
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `v [`i]) ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `inner
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Term.app `g [`i])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `i
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `g
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1022, (some 1023, term) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 70, (some 71, term) <=? (some 50, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 50, (some 51, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.intro "intro" [`s `g `hg `i `hi])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hi
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `i
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `hg
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `g
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `s
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `linear_independent_iff')] "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `linear_independent_iff'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      (Term.app `LinearIndependent [`𝕜 `v])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `v
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `𝕜
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `LinearIndependent
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023,
     term) <=? (some 1023, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'ident'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.hole'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.forall
       "∀"
       [`i `j]
       []
       ","
       (Term.arrow
        («term_≠_» `i "≠" `j)
        "→"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (Term.app `v [`i])
          ", "
          (Term.app `v [`j])
          "⟫")
         "="
         (num "0"))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.arrow
       («term_≠_» `i "≠" `j)
       "→"
       («term_=_»
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
         "⟪"
         (Term.app `v [`i])
         ", "
         (Term.app `v [`j])
         "⟫")
        "="
        (num "0")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        (Term.app `v [`i])
        ", "
        (Term.app `v [`j])
        "⟫")
       "="
       (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
       "⟪"
       (Term.app `v [`i])
       ", "
       (Term.app `v [`j])
       "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    A family of vectors is linearly independent if they are nonzero
    and orthogonal. -/
  theorem
    linear_independent_of_ne_zero_of_inner_eq_zero
    { ι : Type _ } { v : ι → E } ( hz : ∀ i , v i ≠ 0 ) ( ho : ∀ i j , i ≠ j → ⟪ v i , v j ⟫ = 0 )
      : LinearIndependent 𝕜 v
    :=
      by
        rw [ linear_independent_iff' ]
          intro s g hg i hi
          have
            h'
              : g i * inner v i v i = inner v i ∑ j in s , g j • v j
              :=
              by
                rw [ inner_sum ]
                  symm
                  convert Finset.sum_eq_single i _ _
                  · rw [ inner_smul_right ]
                  · intro j hj hji rw [ inner_smul_right , ho i j hji.symm , mul_zero ]
                  · exact fun h => False.elim h hi
          simpa [ hg , hz ] using h'
#align linear_independent_of_ne_zero_of_inner_eq_zero linear_independent_of_ne_zero_of_inner_eq_zero

end BasicProperties

section OrthonormalSets

variable {ι : Type _} [dec_ι : DecidableEq ι] (𝕜)

include 𝕜

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment "/--" "An orthonormal set of vectors in an `inner_product_space` -/")]
      []
      []
      []
      []
      [])
     (Command.def
      "def"
      (Command.declId `Orthonormal [])
      (Command.optDeclSig
       [(Term.explicitBinder "(" [`v] [":" (Term.arrow `ι "→" `E)] [] ")")]
       [(Term.typeSpec ":" (Term.prop "Prop"))])
      (Command.declValSimple
       ":="
       («term_∧_»
        (Term.forall
         "∀"
         [`i]
         []
         ","
         («term_=_»
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `v [`i]) "‖")
          "="
          (num "1")))
        "∧"
        (Term.forall
         "∀"
         [(Term.implicitBinder "{" [`i `j] [] "}")]
         []
         ","
         (Term.arrow
          («term_≠_» `i "≠" `j)
          "→"
          («term_=_»
           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
            "⟪"
            (Term.app `v [`i])
            ", "
            (Term.app `v [`j])
            "⟫")
           "="
           (num "0")))))
       [])
      []
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_∧_»
       (Term.forall
        "∀"
        [`i]
        []
        ","
        («term_=_»
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `v [`i]) "‖")
         "="
         (num "1")))
       "∧"
       (Term.forall
        "∀"
        [(Term.implicitBinder "{" [`i `j] [] "}")]
        []
        ","
        (Term.arrow
         («term_≠_» `i "≠" `j)
         "→"
         («term_=_»
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           (Term.app `v [`i])
           ", "
           (Term.app `v [`j])
           "⟫")
          "="
          (num "0")))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.forall
       "∀"
       [(Term.implicitBinder "{" [`i `j] [] "}")]
       []
       ","
       (Term.arrow
        («term_≠_» `i "≠" `j)
        "→"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (Term.app `v [`i])
          ", "
          (Term.app `v [`j])
          "⟫")
         "="
         (num "0"))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.arrow
       («term_≠_» `i "≠" `j)
       "→"
       («term_=_»
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
         "⟪"
         (Term.app `v [`i])
         ", "
         (Term.app `v [`j])
         "⟫")
        "="
        (num "0")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        (Term.app `v [`i])
        ", "
        (Term.app `v [`j])
        "⟫")
       "="
       (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
       "⟪"
       (Term.app `v [`i])
       ", "
       (Term.app `v [`j])
       "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.theorem'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- An orthonormal set of vectors in an `inner_product_space` -/
  def Orthonormal ( v : ι → E ) : Prop := ∀ i , ‖ v i ‖ = 1 ∧ ∀ { i j } , i ≠ j → ⟪ v i , v j ⟫ = 0
#align orthonormal Orthonormal

omit 𝕜

variable {𝕜}

include dec_ι

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "`if ... then ... else` characterization of an indexed set of vectors being orthonormal.  (Inner\nproduct equals Kronecker delta.) -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `orthonormal_iff_ite [])
      (Command.declSig
       [(Term.implicitBinder "{" [`v] [":" (Term.arrow `ι "→" `E)] "}")]
       (Term.typeSpec
        ":"
        («term_↔_»
         (Term.app `Orthonormal [`𝕜 `v])
         "↔"
         (Term.forall
          "∀"
          [`i `j]
          []
          ","
          («term_=_»
           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
            "⟪"
            (Term.app `v [`i])
            ", "
            (Term.app `v [`j])
            "⟫")
           "="
           (termIfThenElse
            "if"
            («term_=_» `i "=" `j)
            "then"
            (Term.typeAscription "(" (num "1") ":" [`𝕜] ")")
            "else"
            (Term.typeAscription "(" (num "0") ":" [`𝕜] ")")))))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.constructor "constructor")
           []
           (tactic__
            (cdotTk (patternIgnore (token.«· » "·")))
            [(Tactic.intro "intro" [`hv `i `j])
             []
             (Mathlib.Tactic.splitIfs "split_ifs" [] [])
             []
             (tactic__
              (cdotTk (patternIgnore (token.«· » "·")))
              [(Tactic.simp
                "simp"
                []
                []
                []
                ["["
                 [(Tactic.simpLemma [] [] `h)
                  ","
                  (Tactic.simpLemma [] [] `inner_self_eq_norm_sq_to_K)
                  ","
                  (Tactic.simpLemma [] [] (Term.proj `hv "." (fieldIdx "1")))]
                 "]"]
                [])])
             []
             (tactic__
              (cdotTk (patternIgnore (token.«· » "·")))
              [(Tactic.exact "exact" (Term.app (Term.proj `hv "." (fieldIdx "2")) [`h]))])])
           []
           (tactic__
            (cdotTk (patternIgnore (token.«· » "·")))
            [(Tactic.intro "intro" [`h])
             []
             (Tactic.constructor "constructor")
             []
             (tactic__
              (cdotTk (patternIgnore (token.«· » "·")))
              [(Tactic.intro "intro" [`i])
               []
               (Tactic.tacticHave_
                "have"
                (Term.haveDecl
                 (Term.haveIdDecl
                  [`h' []]
                  [(Term.typeSpec
                    ":"
                    («term_=_»
                     («term_^_»
                      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `v [`i]) "‖")
                      "^"
                      (num "2"))
                     "="
                     («term_^_» (num "1") "^" (num "2"))))]
                  ":="
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(Tactic.simp
                       "simp"
                       []
                       []
                       []
                       ["["
                        [(Tactic.simpLemma [] [] `norm_sq_eq_inner)
                         ","
                         (Tactic.simpLemma [] [] (Term.app `h [`i `i]))]
                        "]"]
                       [])]))))))
               []
               (Tactic.tacticHave_
                "have"
                (Term.haveDecl
                 (Term.haveIdDecl
                  [`h₁ []]
                  [(Term.typeSpec
                    ":"
                    («term_≤_»
                     (num "0")
                     "≤"
                     (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `v [`i]) "‖")))]
                  ":="
                  (Term.app `norm_nonneg [(Term.hole "_")]))))
               []
               (Tactic.tacticHave_
                "have"
                (Term.haveDecl
                 (Term.haveIdDecl
                  [`h₂ []]
                  [(Term.typeSpec
                    ":"
                    («term_≤_»
                     (Term.typeAscription "(" (num "0") ":" [(Data.Real.Basic.termℝ "ℝ")] ")")
                     "≤"
                     (num "1")))]
                  ":="
                  `zero_le_one)))
               []
               (Std.Tactic.tacticRwa__
                "rwa"
                (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] (Term.app `sq_eq_sq [`h₁ `h₂]))] "]")
                [(Tactic.location "at" (Tactic.locationHyp [`h'] []))])])
             []
             (tactic__
              (cdotTk (patternIgnore (token.«· » "·")))
              [(Tactic.intro "intro" [`i `j `hij])
               []
               (Std.Tactic.Simpa.simpa
                "simpa"
                []
                []
                (Std.Tactic.Simpa.simpaArgsRest
                 []
                 []
                 []
                 [(Tactic.simpArgs "[" [(Tactic.simpLemma [] [] `hij)] "]")]
                 ["using" (Term.app `h [`i `j])]))])])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.constructor "constructor")
          []
          (tactic__
           (cdotTk (patternIgnore (token.«· » "·")))
           [(Tactic.intro "intro" [`hv `i `j])
            []
            (Mathlib.Tactic.splitIfs "split_ifs" [] [])
            []
            (tactic__
             (cdotTk (patternIgnore (token.«· » "·")))
             [(Tactic.simp
               "simp"
               []
               []
               []
               ["["
                [(Tactic.simpLemma [] [] `h)
                 ","
                 (Tactic.simpLemma [] [] `inner_self_eq_norm_sq_to_K)
                 ","
                 (Tactic.simpLemma [] [] (Term.proj `hv "." (fieldIdx "1")))]
                "]"]
               [])])
            []
            (tactic__
             (cdotTk (patternIgnore (token.«· » "·")))
             [(Tactic.exact "exact" (Term.app (Term.proj `hv "." (fieldIdx "2")) [`h]))])])
          []
          (tactic__
           (cdotTk (patternIgnore (token.«· » "·")))
           [(Tactic.intro "intro" [`h])
            []
            (Tactic.constructor "constructor")
            []
            (tactic__
             (cdotTk (patternIgnore (token.«· » "·")))
             [(Tactic.intro "intro" [`i])
              []
              (Tactic.tacticHave_
               "have"
               (Term.haveDecl
                (Term.haveIdDecl
                 [`h' []]
                 [(Term.typeSpec
                   ":"
                   («term_=_»
                    («term_^_»
                     (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `v [`i]) "‖")
                     "^"
                     (num "2"))
                    "="
                    («term_^_» (num "1") "^" (num "2"))))]
                 ":="
                 (Term.byTactic
                  "by"
                  (Tactic.tacticSeq
                   (Tactic.tacticSeq1Indented
                    [(Tactic.simp
                      "simp"
                      []
                      []
                      []
                      ["["
                       [(Tactic.simpLemma [] [] `norm_sq_eq_inner)
                        ","
                        (Tactic.simpLemma [] [] (Term.app `h [`i `i]))]
                       "]"]
                      [])]))))))
              []
              (Tactic.tacticHave_
               "have"
               (Term.haveDecl
                (Term.haveIdDecl
                 [`h₁ []]
                 [(Term.typeSpec
                   ":"
                   («term_≤_»
                    (num "0")
                    "≤"
                    (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `v [`i]) "‖")))]
                 ":="
                 (Term.app `norm_nonneg [(Term.hole "_")]))))
              []
              (Tactic.tacticHave_
               "have"
               (Term.haveDecl
                (Term.haveIdDecl
                 [`h₂ []]
                 [(Term.typeSpec
                   ":"
                   («term_≤_»
                    (Term.typeAscription "(" (num "0") ":" [(Data.Real.Basic.termℝ "ℝ")] ")")
                    "≤"
                    (num "1")))]
                 ":="
                 `zero_le_one)))
              []
              (Std.Tactic.tacticRwa__
               "rwa"
               (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] (Term.app `sq_eq_sq [`h₁ `h₂]))] "]")
               [(Tactic.location "at" (Tactic.locationHyp [`h'] []))])])
            []
            (tactic__
             (cdotTk (patternIgnore (token.«· » "·")))
             [(Tactic.intro "intro" [`i `j `hij])
              []
              (Std.Tactic.Simpa.simpa
               "simpa"
               []
               []
               (Std.Tactic.Simpa.simpaArgsRest
                []
                []
                []
                [(Tactic.simpArgs "[" [(Tactic.simpLemma [] [] `hij)] "]")]
                ["using" (Term.app `h [`i `j])]))])])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.«· » "·")))
       [(Tactic.intro "intro" [`h])
        []
        (Tactic.constructor "constructor")
        []
        (tactic__
         (cdotTk (patternIgnore (token.«· » "·")))
         [(Tactic.intro "intro" [`i])
          []
          (Tactic.tacticHave_
           "have"
           (Term.haveDecl
            (Term.haveIdDecl
             [`h' []]
             [(Term.typeSpec
               ":"
               («term_=_»
                («term_^_»
                 (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `v [`i]) "‖")
                 "^"
                 (num "2"))
                "="
                («term_^_» (num "1") "^" (num "2"))))]
             ":="
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Tactic.simp
                  "simp"
                  []
                  []
                  []
                  ["["
                   [(Tactic.simpLemma [] [] `norm_sq_eq_inner)
                    ","
                    (Tactic.simpLemma [] [] (Term.app `h [`i `i]))]
                   "]"]
                  [])]))))))
          []
          (Tactic.tacticHave_
           "have"
           (Term.haveDecl
            (Term.haveIdDecl
             [`h₁ []]
             [(Term.typeSpec
               ":"
               («term_≤_»
                (num "0")
                "≤"
                (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `v [`i]) "‖")))]
             ":="
             (Term.app `norm_nonneg [(Term.hole "_")]))))
          []
          (Tactic.tacticHave_
           "have"
           (Term.haveDecl
            (Term.haveIdDecl
             [`h₂ []]
             [(Term.typeSpec
               ":"
               («term_≤_»
                (Term.typeAscription "(" (num "0") ":" [(Data.Real.Basic.termℝ "ℝ")] ")")
                "≤"
                (num "1")))]
             ":="
             `zero_le_one)))
          []
          (Std.Tactic.tacticRwa__
           "rwa"
           (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] (Term.app `sq_eq_sq [`h₁ `h₂]))] "]")
           [(Tactic.location "at" (Tactic.locationHyp [`h'] []))])])
        []
        (tactic__
         (cdotTk (patternIgnore (token.«· » "·")))
         [(Tactic.intro "intro" [`i `j `hij])
          []
          (Std.Tactic.Simpa.simpa
           "simpa"
           []
           []
           (Std.Tactic.Simpa.simpaArgsRest
            []
            []
            []
            [(Tactic.simpArgs "[" [(Tactic.simpLemma [] [] `hij)] "]")]
            ["using" (Term.app `h [`i `j])]))])])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.«· » "·")))
       [(Tactic.intro "intro" [`i `j `hij])
        []
        (Std.Tactic.Simpa.simpa
         "simpa"
         []
         []
         (Std.Tactic.Simpa.simpaArgsRest
          []
          []
          []
          [(Tactic.simpArgs "[" [(Tactic.simpLemma [] [] `hij)] "]")]
          ["using" (Term.app `h [`i `j])]))])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Std.Tactic.Simpa.simpa
       "simpa"
       []
       []
       (Std.Tactic.Simpa.simpaArgsRest
        []
        []
        []
        [(Tactic.simpArgs "[" [(Tactic.simpLemma [] [] `hij)] "]")]
        ["using" (Term.app `h [`i `j])]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `h [`i `j])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `j
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `i
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hij
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.intro "intro" [`i `j `hij])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hij
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `j
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `i
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.«· » "·")))
       [(Tactic.intro "intro" [`i])
        []
        (Tactic.tacticHave_
         "have"
         (Term.haveDecl
          (Term.haveIdDecl
           [`h' []]
           [(Term.typeSpec
             ":"
             («term_=_»
              («term_^_»
               (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `v [`i]) "‖")
               "^"
               (num "2"))
              "="
              («term_^_» (num "1") "^" (num "2"))))]
           ":="
           (Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.simp
                "simp"
                []
                []
                []
                ["["
                 [(Tactic.simpLemma [] [] `norm_sq_eq_inner)
                  ","
                  (Tactic.simpLemma [] [] (Term.app `h [`i `i]))]
                 "]"]
                [])]))))))
        []
        (Tactic.tacticHave_
         "have"
         (Term.haveDecl
          (Term.haveIdDecl
           [`h₁ []]
           [(Term.typeSpec
             ":"
             («term_≤_»
              (num "0")
              "≤"
              (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `v [`i]) "‖")))]
           ":="
           (Term.app `norm_nonneg [(Term.hole "_")]))))
        []
        (Tactic.tacticHave_
         "have"
         (Term.haveDecl
          (Term.haveIdDecl
           [`h₂ []]
           [(Term.typeSpec
             ":"
             («term_≤_»
              (Term.typeAscription "(" (num "0") ":" [(Data.Real.Basic.termℝ "ℝ")] ")")
              "≤"
              (num "1")))]
           ":="
           `zero_le_one)))
        []
        (Std.Tactic.tacticRwa__
         "rwa"
         (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] (Term.app `sq_eq_sq [`h₁ `h₂]))] "]")
         [(Tactic.location "at" (Tactic.locationHyp [`h'] []))])])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Std.Tactic.tacticRwa__
       "rwa"
       (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] (Term.app `sq_eq_sq [`h₁ `h₂]))] "]")
       [(Tactic.location "at" (Tactic.locationHyp [`h'] []))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.locationHyp', expected 'Lean.Parser.Tactic.locationWildcard'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `sq_eq_sq [`h₁ `h₂])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h₂
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `h₁
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `sq_eq_sq
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.tacticHave_
       "have"
       (Term.haveDecl
        (Term.haveIdDecl
         [`h₂ []]
         [(Term.typeSpec
           ":"
           («term_≤_»
            (Term.typeAscription "(" (num "0") ":" [(Data.Real.Basic.termℝ "ℝ")] ")")
            "≤"
            (num "1")))]
         ":="
         `zero_le_one)))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `zero_le_one
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_≤_»
       (Term.typeAscription "(" (num "0") ":" [(Data.Real.Basic.termℝ "ℝ")] ")")
       "≤"
       (num "1"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "1")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Term.typeAscription "(" (num "0") ":" [(Data.Real.Basic.termℝ "ℝ")] ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Data.Real.Basic.termℝ "ℝ")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none, [anonymous]) <=? (some 50, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 50, (some 51, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.tacticHave_
       "have"
       (Term.haveDecl
        (Term.haveIdDecl
         [`h₁ []]
         [(Term.typeSpec
           ":"
           («term_≤_»
            (num "0")
            "≤"
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `v [`i]) "‖")))]
         ":="
         (Term.app `norm_nonneg [(Term.hole "_")]))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `norm_nonneg [(Term.hole "_")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `norm_nonneg
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_≤_» (num "0") "≤" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `v [`i]) "‖"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `v [`i]) "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `v [`i])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `i
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `v
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none, [anonymous]) <=? (some 50, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 50, (some 51, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.tacticHave_
       "have"
       (Term.haveDecl
        (Term.haveIdDecl
         [`h' []]
         [(Term.typeSpec
           ":"
           («term_=_»
            («term_^_»
             (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `v [`i]) "‖")
             "^"
             (num "2"))
            "="
            («term_^_» (num "1") "^" (num "2"))))]
         ":="
         (Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(Tactic.simp
              "simp"
              []
              []
              []
              ["["
               [(Tactic.simpLemma [] [] `norm_sq_eq_inner)
                ","
                (Tactic.simpLemma [] [] (Term.app `h [`i `i]))]
               "]"]
              [])]))))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           []
           ["["
            [(Tactic.simpLemma [] [] `norm_sq_eq_inner)
             ","
             (Tactic.simpLemma [] [] (Term.app `h [`i `i]))]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       []
       ["["
        [(Tactic.simpLemma [] [] `norm_sq_eq_inner)
         ","
         (Tactic.simpLemma [] [] (Term.app `h [`i `i]))]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `h [`i `i])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `i
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `i
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `norm_sq_eq_inner
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_»
       («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `v [`i]) "‖") "^" (num "2"))
       "="
       («term_^_» (num "1") "^" (num "2")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_^_» (num "1") "^" (num "2"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "2")
[PrettyPrinter.parenthesize] ...precedences are 80 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 80, term))
      (num "1")
[PrettyPrinter.parenthesize] ...precedences are 81 >? 1024, (none, [anonymous]) <=? (some 80, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 80, (some 80, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `v [`i]) "‖") "^" (num "2"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "2")
[PrettyPrinter.parenthesize] ...precedences are 80 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 80, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `v [`i]) "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `v [`i])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `i
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `v
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 81 >? 1024, (none, [anonymous]) <=? (some 80, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 80, (some 80, term) <=? (some 50, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 50, (some 51, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.intro "intro" [`i])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `i
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.constructor "constructor")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.intro "intro" [`h])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.«· » "·")))
       [(Tactic.intro "intro" [`hv `i `j])
        []
        (Mathlib.Tactic.splitIfs "split_ifs" [] [])
        []
        (tactic__
         (cdotTk (patternIgnore (token.«· » "·")))
         [(Tactic.simp
           "simp"
           []
           []
           []
           ["["
            [(Tactic.simpLemma [] [] `h)
             ","
             (Tactic.simpLemma [] [] `inner_self_eq_norm_sq_to_K)
             ","
             (Tactic.simpLemma [] [] (Term.proj `hv "." (fieldIdx "1")))]
            "]"]
           [])])
        []
        (tactic__
         (cdotTk (patternIgnore (token.«· » "·")))
         [(Tactic.exact "exact" (Term.app (Term.proj `hv "." (fieldIdx "2")) [`h]))])])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.«· » "·")))
       [(Tactic.exact "exact" (Term.app (Term.proj `hv "." (fieldIdx "2")) [`h]))])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact "exact" (Term.app (Term.proj `hv "." (fieldIdx "2")) [`h]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app (Term.proj `hv "." (fieldIdx "2")) [`h])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.proj `hv "." (fieldIdx "2"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `hv
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.«· » "·")))
       [(Tactic.simp
         "simp"
         []
         []
         []
         ["["
          [(Tactic.simpLemma [] [] `h)
           ","
           (Tactic.simpLemma [] [] `inner_self_eq_norm_sq_to_K)
           ","
           (Tactic.simpLemma [] [] (Term.proj `hv "." (fieldIdx "1")))]
          "]"]
         [])])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       []
       ["["
        [(Tactic.simpLemma [] [] `h)
         ","
         (Tactic.simpLemma [] [] `inner_self_eq_norm_sq_to_K)
         ","
         (Tactic.simpLemma [] [] (Term.proj `hv "." (fieldIdx "1")))]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.proj `hv "." (fieldIdx "1"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `hv
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_self_eq_norm_sq_to_K
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.splitIfs "split_ifs" [] [])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.intro "intro" [`hv `i `j])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `j
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `i
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `hv
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.constructor "constructor")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_↔_»
       (Term.app `Orthonormal [`𝕜 `v])
       "↔"
       (Term.forall
        "∀"
        [`i `j]
        []
        ","
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (Term.app `v [`i])
          ", "
          (Term.app `v [`j])
          "⟫")
         "="
         (termIfThenElse
          "if"
          («term_=_» `i "=" `j)
          "then"
          (Term.typeAscription "(" (num "1") ":" [`𝕜] ")")
          "else"
          (Term.typeAscription "(" (num "0") ":" [`𝕜] ")")))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.forall
       "∀"
       [`i `j]
       []
       ","
       («term_=_»
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
         "⟪"
         (Term.app `v [`i])
         ", "
         (Term.app `v [`j])
         "⟫")
        "="
        (termIfThenElse
         "if"
         («term_=_» `i "=" `j)
         "then"
         (Term.typeAscription "(" (num "1") ":" [`𝕜] ")")
         "else"
         (Term.typeAscription "(" (num "0") ":" [`𝕜] ")"))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        (Term.app `v [`i])
        ", "
        (Term.app `v [`j])
        "⟫")
       "="
       (termIfThenElse
        "if"
        («term_=_» `i "=" `j)
        "then"
        (Term.typeAscription "(" (num "1") ":" [`𝕜] ")")
        "else"
        (Term.typeAscription "(" (num "0") ":" [`𝕜] ")")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (termIfThenElse
       "if"
       («term_=_» `i "=" `j)
       "then"
       (Term.typeAscription "(" (num "1") ":" [`𝕜] ")")
       "else"
       (Term.typeAscription "(" (num "0") ":" [`𝕜] ")"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.typeAscription "(" (num "0") ":" [`𝕜] ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `𝕜
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.typeAscription "(" (num "1") ":" [`𝕜] ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `𝕜
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "1")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_» `i "=" `j)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `j
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      `i
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none, [anonymous]) <=? (some 50, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 50, (some 51, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1022, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
       "⟪"
       (Term.app `v [`i])
       ", "
       (Term.app `v [`j])
       "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    `if ... then ... else` characterization of an indexed set of vectors being orthonormal.  (Inner
    product equals Kronecker delta.) -/
  theorem
    orthonormal_iff_ite
    { v : ι → E } : Orthonormal 𝕜 v ↔ ∀ i j , ⟪ v i , v j ⟫ = if i = j then ( 1 : 𝕜 ) else ( 0 : 𝕜 )
    :=
      by
        constructor
          ·
            intro hv i j
              split_ifs
              · simp [ h , inner_self_eq_norm_sq_to_K , hv . 1 ]
              · exact hv . 2 h
          ·
            intro h
              constructor
              ·
                intro i
                  have h' : ‖ v i ‖ ^ 2 = 1 ^ 2 := by simp [ norm_sq_eq_inner , h i i ]
                  have h₁ : 0 ≤ ‖ v i ‖ := norm_nonneg _
                  have h₂ : ( 0 : ℝ ) ≤ 1 := zero_le_one
                  rwa [ sq_eq_sq h₁ h₂ ] at h'
              · intro i j hij simpa [ hij ] using h i j
#align orthonormal_iff_ite orthonormal_iff_ite

omit dec_ι

include dec_E

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "`if ... then ... else` characterization of a set of vectors being orthonormal.  (Inner product\nequals Kronecker delta.) -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `orthonormal_subtype_iff_ite [])
      (Command.declSig
       [(Term.implicitBinder "{" [`s] [":" (Term.app `Set [`E])] "}")]
       (Term.typeSpec
        ":"
        («term_↔_»
         (Term.app
          `Orthonormal
          [`𝕜 (Term.typeAscription "(" `coe ":" [(Term.arrow `s "→" `E)] ")")])
         "↔"
         (Std.ExtendedBinder.«term∀__,_»
          "∀"
          (Lean.binderIdent `v)
          («binderTerm∈_» "∈" `s)
          ","
          (Std.ExtendedBinder.«term∀__,_»
           "∀"
           (Lean.binderIdent `w)
           («binderTerm∈_» "∈" `s)
           ","
           («term_=_»
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `w "⟫")
            "="
            (termIfThenElse "if" («term_=_» `v "=" `w) "then" (num "1") "else" (num "0"))))))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `orthonormal_iff_ite)] "]")
            [])
           []
           (Tactic.constructor "constructor")
           []
           (tactic__
            (cdotTk (patternIgnore (token.«· » "·")))
            [(Tactic.intro "intro" [`h `v `hv `w `hw])
             []
             (convert
              "convert"
              []
              (Term.app
               `h
               [(Term.anonymousCtor "⟨" [`v "," `hv] "⟩")
                (Term.anonymousCtor "⟨" [`w "," `hw] "⟩")])
              ["using" (num "1")])
             []
             (Tactic.simp "simp" [] [] [] [] [])])
           []
           (tactic__
            (cdotTk (patternIgnore (token.«· » "·")))
            [(Std.Tactic.rintro
              "rintro"
              [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `h))
               (Std.Tactic.RCases.rintroPat.one
                (Std.Tactic.RCases.rcasesPat.tuple
                 "⟨"
                 [(Std.Tactic.RCases.rcasesPatLo
                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `v)])
                   [])
                  ","
                  (Std.Tactic.RCases.rcasesPatLo
                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hv)])
                   [])]
                 "⟩"))
               (Std.Tactic.RCases.rintroPat.one
                (Std.Tactic.RCases.rcasesPat.tuple
                 "⟨"
                 [(Std.Tactic.RCases.rcasesPatLo
                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `w)])
                   [])
                  ","
                  (Std.Tactic.RCases.rcasesPatLo
                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hw)])
                   [])]
                 "⟩"))]
              [])
             []
             (convert "convert" [] (Term.app `h [`v `hv `w `hw]) ["using" (num "1")])
             []
             (Tactic.simp "simp" [] [] [] [] [])])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `orthonormal_iff_ite)] "]")
           [])
          []
          (Tactic.constructor "constructor")
          []
          (tactic__
           (cdotTk (patternIgnore (token.«· » "·")))
           [(Tactic.intro "intro" [`h `v `hv `w `hw])
            []
            (convert
             "convert"
             []
             (Term.app
              `h
              [(Term.anonymousCtor "⟨" [`v "," `hv] "⟩") (Term.anonymousCtor "⟨" [`w "," `hw] "⟩")])
             ["using" (num "1")])
            []
            (Tactic.simp "simp" [] [] [] [] [])])
          []
          (tactic__
           (cdotTk (patternIgnore (token.«· » "·")))
           [(Std.Tactic.rintro
             "rintro"
             [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `h))
              (Std.Tactic.RCases.rintroPat.one
               (Std.Tactic.RCases.rcasesPat.tuple
                "⟨"
                [(Std.Tactic.RCases.rcasesPatLo
                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `v)])
                  [])
                 ","
                 (Std.Tactic.RCases.rcasesPatLo
                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hv)])
                  [])]
                "⟩"))
              (Std.Tactic.RCases.rintroPat.one
               (Std.Tactic.RCases.rcasesPat.tuple
                "⟨"
                [(Std.Tactic.RCases.rcasesPatLo
                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `w)])
                  [])
                 ","
                 (Std.Tactic.RCases.rcasesPatLo
                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hw)])
                  [])]
                "⟩"))]
             [])
            []
            (convert "convert" [] (Term.app `h [`v `hv `w `hw]) ["using" (num "1")])
            []
            (Tactic.simp "simp" [] [] [] [] [])])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.«· » "·")))
       [(Std.Tactic.rintro
         "rintro"
         [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `h))
          (Std.Tactic.RCases.rintroPat.one
           (Std.Tactic.RCases.rcasesPat.tuple
            "⟨"
            [(Std.Tactic.RCases.rcasesPatLo
              (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `v)])
              [])
             ","
             (Std.Tactic.RCases.rcasesPatLo
              (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hv)])
              [])]
            "⟩"))
          (Std.Tactic.RCases.rintroPat.one
           (Std.Tactic.RCases.rcasesPat.tuple
            "⟨"
            [(Std.Tactic.RCases.rcasesPatLo
              (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `w)])
              [])
             ","
             (Std.Tactic.RCases.rcasesPatLo
              (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hw)])
              [])]
            "⟩"))]
         [])
        []
        (convert "convert" [] (Term.app `h [`v `hv `w `hw]) ["using" (num "1")])
        []
        (Tactic.simp "simp" [] [] [] [] [])])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp "simp" [] [] [] [] [])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (convert "convert" [] (Term.app `h [`v `hv `w `hw]) ["using" (num "1")])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `h [`v `hv `w `hw])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hw
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `w
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `hv
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `v
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Std.Tactic.rintro
       "rintro"
       [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `h))
        (Std.Tactic.RCases.rintroPat.one
         (Std.Tactic.RCases.rcasesPat.tuple
          "⟨"
          [(Std.Tactic.RCases.rcasesPatLo
            (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `v)])
            [])
           ","
           (Std.Tactic.RCases.rcasesPatLo
            (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hv)])
            [])]
          "⟩"))
        (Std.Tactic.RCases.rintroPat.one
         (Std.Tactic.RCases.rcasesPat.tuple
          "⟨"
          [(Std.Tactic.RCases.rcasesPatLo
            (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `w)])
            [])
           ","
           (Std.Tactic.RCases.rcasesPatLo
            (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hw)])
            [])]
          "⟩"))]
       [])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.«· » "·")))
       [(Tactic.intro "intro" [`h `v `hv `w `hw])
        []
        (convert
         "convert"
         []
         (Term.app
          `h
          [(Term.anonymousCtor "⟨" [`v "," `hv] "⟩") (Term.anonymousCtor "⟨" [`w "," `hw] "⟩")])
         ["using" (num "1")])
        []
        (Tactic.simp "simp" [] [] [] [] [])])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp "simp" [] [] [] [] [])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (convert
       "convert"
       []
       (Term.app
        `h
        [(Term.anonymousCtor "⟨" [`v "," `hv] "⟩") (Term.anonymousCtor "⟨" [`w "," `hw] "⟩")])
       ["using" (num "1")])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `h
       [(Term.anonymousCtor "⟨" [`v "," `hv] "⟩") (Term.anonymousCtor "⟨" [`w "," `hw] "⟩")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.anonymousCtor "⟨" [`w "," `hw] "⟩")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hw
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `w
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.anonymousCtor "⟨" [`v "," `hv] "⟩")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hv
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `v
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.intro "intro" [`h `v `hv `w `hw])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hw
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `w
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `hv
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `v
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.constructor "constructor")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `orthonormal_iff_ite)] "]") [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `orthonormal_iff_ite
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_↔_»
       (Term.app `Orthonormal [`𝕜 (Term.typeAscription "(" `coe ":" [(Term.arrow `s "→" `E)] ")")])
       "↔"
       (Std.ExtendedBinder.«term∀__,_»
        "∀"
        (Lean.binderIdent `v)
        («binderTerm∈_» "∈" `s)
        ","
        (Std.ExtendedBinder.«term∀__,_»
         "∀"
         (Lean.binderIdent `w)
         («binderTerm∈_» "∈" `s)
         ","
         («term_=_»
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `w "⟫")
          "="
          (termIfThenElse "if" («term_=_» `v "=" `w) "then" (num "1") "else" (num "0"))))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Std.ExtendedBinder.«term∀__,_»
       "∀"
       (Lean.binderIdent `v)
       («binderTerm∈_» "∈" `s)
       ","
       (Std.ExtendedBinder.«term∀__,_»
        "∀"
        (Lean.binderIdent `w)
        («binderTerm∈_» "∈" `s)
        ","
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `w "⟫")
         "="
         (termIfThenElse "if" («term_=_» `v "=" `w) "then" (num "1") "else" (num "0")))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Std.ExtendedBinder.«term∀__,_»
       "∀"
       (Lean.binderIdent `w)
       («binderTerm∈_» "∈" `s)
       ","
       («term_=_»
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `w "⟫")
        "="
        (termIfThenElse "if" («term_=_» `v "=" `w) "then" (num "1") "else" (num "0"))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `w "⟫")
       "="
       (termIfThenElse "if" («term_=_» `v "=" `w) "then" (num "1") "else" (num "0")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (termIfThenElse "if" («term_=_» `v "=" `w) "then" (num "1") "else" (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "1")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_» `v "=" `w)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `w
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      `v
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none, [anonymous]) <=? (some 50, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 50, (some 51, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1022, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `w "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    `if ... then ... else` characterization of a set of vectors being orthonormal.  (Inner product
    equals Kronecker delta.) -/
  theorem
    orthonormal_subtype_iff_ite
    { s : Set E }
      : Orthonormal 𝕜 ( coe : s → E ) ↔ ∀ v ∈ s , ∀ w ∈ s , ⟪ v , w ⟫ = if v = w then 1 else 0
    :=
      by
        rw [ orthonormal_iff_ite ]
          constructor
          · intro h v hv w hw convert h ⟨ v , hv ⟩ ⟨ w , hw ⟩ using 1 simp
          · rintro h ⟨ v , hv ⟩ ⟨ w , hw ⟩ convert h v hv w hw using 1 simp
#align orthonormal_subtype_iff_ite orthonormal_subtype_iff_ite

omit dec_E

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "The inner product of a linear combination of a set of orthonormal vectors with one of those\nvectors picks out the coefficient of that vector. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `Orthonormal.inner_right_finsupp [])
      (Command.declSig
       [(Term.implicitBinder "{" [`v] [":" (Term.arrow `ι "→" `E)] "}")
        (Term.explicitBinder "(" [`hv] [":" (Term.app `Orthonormal [`𝕜 `v])] [] ")")
        (Term.explicitBinder "(" [`l] [":" (Data.Finsupp.Defs.«term_→₀_» `ι " →₀ " `𝕜)] [] ")")
        (Term.explicitBinder "(" [`i] [":" `ι] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (Term.app `v [`i])
          ", "
          (Term.app `Finsupp.total [`ι `E `𝕜 `v `l])
          "⟫")
         "="
         (Term.app `l [`i]))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Mathlib.Tactic.tacticClassical_
            "classical"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.simp
                "simp"
                []
                []
                []
                ["["
                 [(Tactic.simpLemma [] [] `Finsupp.total_apply)
                  ","
                  (Tactic.simpLemma [] [] `Finsupp.inner_sum)
                  ","
                  (Tactic.simpLemma [] [] (Term.app `orthonormal_iff_ite.mp [`hv]))]
                 "]"]
                [])])))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Mathlib.Tactic.tacticClassical_
           "classical"
           (Tactic.tacticSeq
            (Tactic.tacticSeq1Indented
             [(Tactic.simp
               "simp"
               []
               []
               []
               ["["
                [(Tactic.simpLemma [] [] `Finsupp.total_apply)
                 ","
                 (Tactic.simpLemma [] [] `Finsupp.inner_sum)
                 ","
                 (Tactic.simpLemma [] [] (Term.app `orthonormal_iff_ite.mp [`hv]))]
                "]"]
               [])])))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.tacticClassical_
       "classical"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           []
           ["["
            [(Tactic.simpLemma [] [] `Finsupp.total_apply)
             ","
             (Tactic.simpLemma [] [] `Finsupp.inner_sum)
             ","
             (Tactic.simpLemma [] [] (Term.app `orthonormal_iff_ite.mp [`hv]))]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       []
       ["["
        [(Tactic.simpLemma [] [] `Finsupp.total_apply)
         ","
         (Tactic.simpLemma [] [] `Finsupp.inner_sum)
         ","
         (Tactic.simpLemma [] [] (Term.app `orthonormal_iff_ite.mp [`hv]))]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `orthonormal_iff_ite.mp [`hv])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hv
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `orthonormal_iff_ite.mp
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Finsupp.inner_sum
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Finsupp.total_apply
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        (Term.app `v [`i])
        ", "
        (Term.app `Finsupp.total [`ι `E `𝕜 `v `l])
        "⟫")
       "="
       (Term.app `l [`i]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `l [`i])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `i
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `l
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
       "⟪"
       (Term.app `v [`i])
       ", "
       (Term.app `Finsupp.total [`ι `E `𝕜 `v `l])
       "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    The inner product of a linear combination of a set of orthonormal vectors with one of those
    vectors picks out the coefficient of that vector. -/
  theorem
    Orthonormal.inner_right_finsupp
    { v : ι → E } ( hv : Orthonormal 𝕜 v ) ( l : ι →₀ 𝕜 ) ( i : ι )
      : ⟪ v i , Finsupp.total ι E 𝕜 v l ⟫ = l i
    := by classical simp [ Finsupp.total_apply , Finsupp.inner_sum , orthonormal_iff_ite.mp hv ]
#align orthonormal.inner_right_finsupp Orthonormal.inner_right_finsupp

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "The inner product of a linear combination of a set of orthonormal vectors with one of those\nvectors picks out the coefficient of that vector. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `Orthonormal.inner_right_sum [])
      (Command.declSig
       [(Term.implicitBinder "{" [`v] [":" (Term.arrow `ι "→" `E)] "}")
        (Term.explicitBinder "(" [`hv] [":" (Term.app `Orthonormal [`𝕜 `v])] [] ")")
        (Term.explicitBinder "(" [`l] [":" (Term.arrow `ι "→" `𝕜)] [] ")")
        (Term.implicitBinder "{" [`s] [":" (Term.app `Finset [`ι])] "}")
        (Term.implicitBinder "{" [`i] [":" `ι] "}")
        (Term.explicitBinder "(" [`hi] [":" («term_∈_» `i "∈" `s)] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (Term.app `v [`i])
          ", "
          (BigOperators.Algebra.BigOperators.Basic.finset.sum
           "∑"
           (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
           " in "
           `s
           ", "
           (Algebra.Group.Defs.«term_•_» (Term.app `l [`i]) " • " (Term.app `v [`i])))
          "⟫")
         "="
         (Term.app `l [`i]))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Mathlib.Tactic.tacticClassical_
            "classical"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.simp
                "simp"
                []
                []
                []
                ["["
                 [(Tactic.simpLemma [] [] `inner_sum)
                  ","
                  (Tactic.simpLemma [] [] `inner_smul_right)
                  ","
                  (Tactic.simpLemma [] [] (Term.app `orthonormal_iff_ite.mp [`hv]))
                  ","
                  (Tactic.simpLemma [] [] `hi)]
                 "]"]
                [])])))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Mathlib.Tactic.tacticClassical_
           "classical"
           (Tactic.tacticSeq
            (Tactic.tacticSeq1Indented
             [(Tactic.simp
               "simp"
               []
               []
               []
               ["["
                [(Tactic.simpLemma [] [] `inner_sum)
                 ","
                 (Tactic.simpLemma [] [] `inner_smul_right)
                 ","
                 (Tactic.simpLemma [] [] (Term.app `orthonormal_iff_ite.mp [`hv]))
                 ","
                 (Tactic.simpLemma [] [] `hi)]
                "]"]
               [])])))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.tacticClassical_
       "classical"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           []
           ["["
            [(Tactic.simpLemma [] [] `inner_sum)
             ","
             (Tactic.simpLemma [] [] `inner_smul_right)
             ","
             (Tactic.simpLemma [] [] (Term.app `orthonormal_iff_ite.mp [`hv]))
             ","
             (Tactic.simpLemma [] [] `hi)]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       []
       ["["
        [(Tactic.simpLemma [] [] `inner_sum)
         ","
         (Tactic.simpLemma [] [] `inner_smul_right)
         ","
         (Tactic.simpLemma [] [] (Term.app `orthonormal_iff_ite.mp [`hv]))
         ","
         (Tactic.simpLemma [] [] `hi)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hi
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `orthonormal_iff_ite.mp [`hv])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hv
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `orthonormal_iff_ite.mp
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_smul_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_sum
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        (Term.app `v [`i])
        ", "
        (BigOperators.Algebra.BigOperators.Basic.finset.sum
         "∑"
         (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
         " in "
         `s
         ", "
         (Algebra.Group.Defs.«term_•_» (Term.app `l [`i]) " • " (Term.app `v [`i])))
        "⟫")
       "="
       (Term.app `l [`i]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `l [`i])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `i
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `l
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
       "⟪"
       (Term.app `v [`i])
       ", "
       (BigOperators.Algebra.BigOperators.Basic.finset.sum
        "∑"
        (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
        " in "
        `s
        ", "
        (Algebra.Group.Defs.«term_•_» (Term.app `l [`i]) " • " (Term.app `v [`i])))
       "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    The inner product of a linear combination of a set of orthonormal vectors with one of those
    vectors picks out the coefficient of that vector. -/
  theorem
    Orthonormal.inner_right_sum
    { v : ι → E } ( hv : Orthonormal 𝕜 v ) ( l : ι → 𝕜 ) { s : Finset ι } { i : ι } ( hi : i ∈ s )
      : ⟪ v i , ∑ i in s , l i • v i ⟫ = l i
    := by classical simp [ inner_sum , inner_smul_right , orthonormal_iff_ite.mp hv , hi ]
#align orthonormal.inner_right_sum Orthonormal.inner_right_sum

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "The inner product of a linear combination of a set of orthonormal vectors with one of those\nvectors picks out the coefficient of that vector. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `Orthonormal.inner_right_fintype [])
      (Command.declSig
       [(Term.instBinder "[" [] (Term.app `Fintype [`ι]) "]")
        (Term.implicitBinder "{" [`v] [":" (Term.arrow `ι "→" `E)] "}")
        (Term.explicitBinder "(" [`hv] [":" (Term.app `Orthonormal [`𝕜 `v])] [] ")")
        (Term.explicitBinder "(" [`l] [":" (Term.arrow `ι "→" `𝕜)] [] ")")
        (Term.explicitBinder "(" [`i] [":" `ι] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (Term.app `v [`i])
          ", "
          (BigOperators.Algebra.BigOperators.Basic.finset.sum_univ
           "∑"
           (Std.ExtendedBinder.extBinders
            (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) [(group ":" `ι)]))
           ", "
           (Algebra.Group.Defs.«term_•_» (Term.app `l [`i]) " • " (Term.app `v [`i])))
          "⟫")
         "="
         (Term.app `l [`i]))))
      (Command.declValSimple
       ":="
       (Term.app
        (Term.proj `hv "." `inner_right_sum)
        [`l (Term.app `Finset.mem_univ [(Term.hole "_")])])
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       (Term.proj `hv "." `inner_right_sum)
       [`l (Term.app `Finset.mem_univ [(Term.hole "_")])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `Finset.mem_univ [(Term.hole "_")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `Finset.mem_univ
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app `Finset.mem_univ [(Term.hole "_")])
     ")")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `l
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.proj `hv "." `inner_right_sum)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `hv
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        (Term.app `v [`i])
        ", "
        (BigOperators.Algebra.BigOperators.Basic.finset.sum_univ
         "∑"
         (Std.ExtendedBinder.extBinders
          (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) [(group ":" `ι)]))
         ", "
         (Algebra.Group.Defs.«term_•_» (Term.app `l [`i]) " • " (Term.app `v [`i])))
        "⟫")
       "="
       (Term.app `l [`i]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `l [`i])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `i
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `l
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
       "⟪"
       (Term.app `v [`i])
       ", "
       (BigOperators.Algebra.BigOperators.Basic.finset.sum_univ
        "∑"
        (Std.ExtendedBinder.extBinders
         (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) [(group ":" `ι)]))
        ", "
        (Algebra.Group.Defs.«term_•_» (Term.app `l [`i]) " • " (Term.app `v [`i])))
       "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    The inner product of a linear combination of a set of orthonormal vectors with one of those
    vectors picks out the coefficient of that vector. -/
  theorem
    Orthonormal.inner_right_fintype
    [ Fintype ι ] { v : ι → E } ( hv : Orthonormal 𝕜 v ) ( l : ι → 𝕜 ) ( i : ι )
      : ⟪ v i , ∑ i : ι , l i • v i ⟫ = l i
    := hv . inner_right_sum l Finset.mem_univ _
#align orthonormal.inner_right_fintype Orthonormal.inner_right_fintype

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "The inner product of a linear combination of a set of orthonormal vectors with one of those\nvectors picks out the coefficient of that vector. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `Orthonormal.inner_left_finsupp [])
      (Command.declSig
       [(Term.implicitBinder "{" [`v] [":" (Term.arrow `ι "→" `E)] "}")
        (Term.explicitBinder "(" [`hv] [":" (Term.app `Orthonormal [`𝕜 `v])] [] ")")
        (Term.explicitBinder "(" [`l] [":" (Data.Finsupp.Defs.«term_→₀_» `ι " →₀ " `𝕜)] [] ")")
        (Term.explicitBinder "(" [`i] [":" `ι] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (Term.app `Finsupp.total [`ι `E `𝕜 `v `l])
          ", "
          (Term.app `v [`i])
          "⟫")
         "="
         (Term.app
          (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj")
          [(Term.app `l [`i])]))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
              ","
              (Tactic.rwRule [] `hv.inner_right_finsupp)]
             "]")
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
             ","
             (Tactic.rwRule [] `hv.inner_right_finsupp)]
            "]")
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
         ","
         (Tactic.rwRule [] `hv.inner_right_finsupp)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hv.inner_right_finsupp
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_conj_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        (Term.app `Finsupp.total [`ι `E `𝕜 `v `l])
        ", "
        (Term.app `v [`i])
        "⟫")
       "="
       (Term.app (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj") [(Term.app `l [`i])]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj") [(Term.app `l [`i])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `l [`i])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `i
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `l
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `l [`i]) ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
       "⟪"
       (Term.app `Finsupp.total [`ι `E `𝕜 `v `l])
       ", "
       (Term.app `v [`i])
       "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    The inner product of a linear combination of a set of orthonormal vectors with one of those
    vectors picks out the coefficient of that vector. -/
  theorem
    Orthonormal.inner_left_finsupp
    { v : ι → E } ( hv : Orthonormal 𝕜 v ) ( l : ι →₀ 𝕜 ) ( i : ι )
      : ⟪ Finsupp.total ι E 𝕜 v l , v i ⟫ = conj l i
    := by rw [ ← inner_conj_sym , hv.inner_right_finsupp ]
#align orthonormal.inner_left_finsupp Orthonormal.inner_left_finsupp

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "The inner product of a linear combination of a set of orthonormal vectors with one of those\nvectors picks out the coefficient of that vector. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `Orthonormal.inner_left_sum [])
      (Command.declSig
       [(Term.implicitBinder "{" [`v] [":" (Term.arrow `ι "→" `E)] "}")
        (Term.explicitBinder "(" [`hv] [":" (Term.app `Orthonormal [`𝕜 `v])] [] ")")
        (Term.explicitBinder "(" [`l] [":" (Term.arrow `ι "→" `𝕜)] [] ")")
        (Term.implicitBinder "{" [`s] [":" (Term.app `Finset [`ι])] "}")
        (Term.implicitBinder "{" [`i] [":" `ι] "}")
        (Term.explicitBinder "(" [`hi] [":" («term_∈_» `i "∈" `s)] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (BigOperators.Algebra.BigOperators.Basic.finset.sum
           "∑"
           (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
           " in "
           `s
           ", "
           (Algebra.Group.Defs.«term_•_» (Term.app `l [`i]) " • " (Term.app `v [`i])))
          ", "
          (Term.app `v [`i])
          "⟫")
         "="
         (Term.app
          (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj")
          [(Term.app `l [`i])]))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Mathlib.Tactic.tacticClassical_
            "classical"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.simp
                "simp"
                []
                []
                ["only"]
                ["["
                 [(Tactic.simpLemma [] [] `sum_inner)
                  ","
                  (Tactic.simpLemma [] [] `inner_smul_left)
                  ","
                  (Tactic.simpLemma [] [] (Term.app `orthonormal_iff_ite.mp [`hv]))
                  ","
                  (Tactic.simpLemma [] [] `hi)
                  ","
                  (Tactic.simpLemma [] [] `mul_boole)
                  ","
                  (Tactic.simpLemma [] [] `Finset.sum_ite_eq')
                  ","
                  (Tactic.simpLemma [] [] `if_true)]
                 "]"]
                [])])))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Mathlib.Tactic.tacticClassical_
           "classical"
           (Tactic.tacticSeq
            (Tactic.tacticSeq1Indented
             [(Tactic.simp
               "simp"
               []
               []
               ["only"]
               ["["
                [(Tactic.simpLemma [] [] `sum_inner)
                 ","
                 (Tactic.simpLemma [] [] `inner_smul_left)
                 ","
                 (Tactic.simpLemma [] [] (Term.app `orthonormal_iff_ite.mp [`hv]))
                 ","
                 (Tactic.simpLemma [] [] `hi)
                 ","
                 (Tactic.simpLemma [] [] `mul_boole)
                 ","
                 (Tactic.simpLemma [] [] `Finset.sum_ite_eq')
                 ","
                 (Tactic.simpLemma [] [] `if_true)]
                "]"]
               [])])))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.tacticClassical_
       "classical"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["["
            [(Tactic.simpLemma [] [] `sum_inner)
             ","
             (Tactic.simpLemma [] [] `inner_smul_left)
             ","
             (Tactic.simpLemma [] [] (Term.app `orthonormal_iff_ite.mp [`hv]))
             ","
             (Tactic.simpLemma [] [] `hi)
             ","
             (Tactic.simpLemma [] [] `mul_boole)
             ","
             (Tactic.simpLemma [] [] `Finset.sum_ite_eq')
             ","
             (Tactic.simpLemma [] [] `if_true)]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] `sum_inner)
         ","
         (Tactic.simpLemma [] [] `inner_smul_left)
         ","
         (Tactic.simpLemma [] [] (Term.app `orthonormal_iff_ite.mp [`hv]))
         ","
         (Tactic.simpLemma [] [] `hi)
         ","
         (Tactic.simpLemma [] [] `mul_boole)
         ","
         (Tactic.simpLemma [] [] `Finset.sum_ite_eq')
         ","
         (Tactic.simpLemma [] [] `if_true)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `if_true
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Finset.sum_ite_eq'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `mul_boole
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hi
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `orthonormal_iff_ite.mp [`hv])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hv
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `orthonormal_iff_ite.mp
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_smul_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `sum_inner
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        (BigOperators.Algebra.BigOperators.Basic.finset.sum
         "∑"
         (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
         " in "
         `s
         ", "
         (Algebra.Group.Defs.«term_•_» (Term.app `l [`i]) " • " (Term.app `v [`i])))
        ", "
        (Term.app `v [`i])
        "⟫")
       "="
       (Term.app (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj") [(Term.app `l [`i])]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj") [(Term.app `l [`i])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `l [`i])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `i
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `l
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `l [`i]) ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
       "⟪"
       (BigOperators.Algebra.BigOperators.Basic.finset.sum
        "∑"
        (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
        " in "
        `s
        ", "
        (Algebra.Group.Defs.«term_•_» (Term.app `l [`i]) " • " (Term.app `v [`i])))
       ", "
       (Term.app `v [`i])
       "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    The inner product of a linear combination of a set of orthonormal vectors with one of those
    vectors picks out the coefficient of that vector. -/
  theorem
    Orthonormal.inner_left_sum
    { v : ι → E } ( hv : Orthonormal 𝕜 v ) ( l : ι → 𝕜 ) { s : Finset ι } { i : ι } ( hi : i ∈ s )
      : ⟪ ∑ i in s , l i • v i , v i ⟫ = conj l i
    :=
      by
        classical
          simp
            only
            [
              sum_inner
                ,
                inner_smul_left
                ,
                orthonormal_iff_ite.mp hv
                ,
                hi
                ,
                mul_boole
                ,
                Finset.sum_ite_eq'
                ,
                if_true
              ]
#align orthonormal.inner_left_sum Orthonormal.inner_left_sum

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "The inner product of a linear combination of a set of orthonormal vectors with one of those\nvectors picks out the coefficient of that vector. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `Orthonormal.inner_left_fintype [])
      (Command.declSig
       [(Term.instBinder "[" [] (Term.app `Fintype [`ι]) "]")
        (Term.implicitBinder "{" [`v] [":" (Term.arrow `ι "→" `E)] "}")
        (Term.explicitBinder "(" [`hv] [":" (Term.app `Orthonormal [`𝕜 `v])] [] ")")
        (Term.explicitBinder "(" [`l] [":" (Term.arrow `ι "→" `𝕜)] [] ")")
        (Term.explicitBinder "(" [`i] [":" `ι] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (BigOperators.Algebra.BigOperators.Basic.finset.sum_univ
           "∑"
           (Std.ExtendedBinder.extBinders
            (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) [(group ":" `ι)]))
           ", "
           (Algebra.Group.Defs.«term_•_» (Term.app `l [`i]) " • " (Term.app `v [`i])))
          ", "
          (Term.app `v [`i])
          "⟫")
         "="
         (Term.app
          (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj")
          [(Term.app `l [`i])]))))
      (Command.declValSimple
       ":="
       (Term.app
        (Term.proj `hv "." `inner_left_sum)
        [`l (Term.app `Finset.mem_univ [(Term.hole "_")])])
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       (Term.proj `hv "." `inner_left_sum)
       [`l (Term.app `Finset.mem_univ [(Term.hole "_")])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `Finset.mem_univ [(Term.hole "_")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `Finset.mem_univ
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app `Finset.mem_univ [(Term.hole "_")])
     ")")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `l
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.proj `hv "." `inner_left_sum)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `hv
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        (BigOperators.Algebra.BigOperators.Basic.finset.sum_univ
         "∑"
         (Std.ExtendedBinder.extBinders
          (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) [(group ":" `ι)]))
         ", "
         (Algebra.Group.Defs.«term_•_» (Term.app `l [`i]) " • " (Term.app `v [`i])))
        ", "
        (Term.app `v [`i])
        "⟫")
       "="
       (Term.app (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj") [(Term.app `l [`i])]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj") [(Term.app `l [`i])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `l [`i])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `i
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `l
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `l [`i]) ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
       "⟪"
       (BigOperators.Algebra.BigOperators.Basic.finset.sum_univ
        "∑"
        (Std.ExtendedBinder.extBinders
         (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) [(group ":" `ι)]))
        ", "
        (Algebra.Group.Defs.«term_•_» (Term.app `l [`i]) " • " (Term.app `v [`i])))
       ", "
       (Term.app `v [`i])
       "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    The inner product of a linear combination of a set of orthonormal vectors with one of those
    vectors picks out the coefficient of that vector. -/
  theorem
    Orthonormal.inner_left_fintype
    [ Fintype ι ] { v : ι → E } ( hv : Orthonormal 𝕜 v ) ( l : ι → 𝕜 ) ( i : ι )
      : ⟪ ∑ i : ι , l i • v i , v i ⟫ = conj l i
    := hv . inner_left_sum l Finset.mem_univ _
#align orthonormal.inner_left_fintype Orthonormal.inner_left_fintype

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "The inner product of two linear combinations of a set of orthonormal vectors, expressed as\na sum over the first `finsupp`. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `Orthonormal.inner_finsupp_eq_sum_left [])
      (Command.declSig
       [(Term.implicitBinder "{" [`v] [":" (Term.arrow `ι "→" `E)] "}")
        (Term.explicitBinder "(" [`hv] [":" (Term.app `Orthonormal [`𝕜 `v])] [] ")")
        (Term.explicitBinder
         "("
         [`l₁ `l₂]
         [":" (Data.Finsupp.Defs.«term_→₀_» `ι " →₀ " `𝕜)]
         []
         ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (Term.app `Finsupp.total [`ι `E `𝕜 `v `l₁])
          ", "
          (Term.app `Finsupp.total [`ι `E `𝕜 `v `l₂])
          "⟫")
         "="
         (Term.app
          (Term.proj `l₁ "." `Sum)
          [(Term.fun
            "fun"
            (Term.basicFun
             [`i `y]
             []
             "=>"
             («term_*_»
              (Term.app (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj") [`y])
              "*"
              (Term.app `l₂ [`i]))))]))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.simp
            "simp"
            []
            []
            ["only"]
            ["["
             [(Tactic.simpLemma [] [] (Term.app `l₁.total_apply [(Term.hole "_")]))
              ","
              (Tactic.simpLemma [] [] `Finsupp.sum_inner)
              ","
              (Tactic.simpLemma [] [] `hv.inner_right_finsupp)
              ","
              (Tactic.simpLemma [] [] `smul_eq_mul)]
             "]"]
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["["
            [(Tactic.simpLemma [] [] (Term.app `l₁.total_apply [(Term.hole "_")]))
             ","
             (Tactic.simpLemma [] [] `Finsupp.sum_inner)
             ","
             (Tactic.simpLemma [] [] `hv.inner_right_finsupp)
             ","
             (Tactic.simpLemma [] [] `smul_eq_mul)]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] (Term.app `l₁.total_apply [(Term.hole "_")]))
         ","
         (Tactic.simpLemma [] [] `Finsupp.sum_inner)
         ","
         (Tactic.simpLemma [] [] `hv.inner_right_finsupp)
         ","
         (Tactic.simpLemma [] [] `smul_eq_mul)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `smul_eq_mul
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hv.inner_right_finsupp
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Finsupp.sum_inner
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `l₁.total_apply [(Term.hole "_")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `l₁.total_apply
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        (Term.app `Finsupp.total [`ι `E `𝕜 `v `l₁])
        ", "
        (Term.app `Finsupp.total [`ι `E `𝕜 `v `l₂])
        "⟫")
       "="
       (Term.app
        (Term.proj `l₁ "." `Sum)
        [(Term.fun
          "fun"
          (Term.basicFun
           [`i `y]
           []
           "=>"
           («term_*_»
            (Term.app (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj") [`y])
            "*"
            (Term.app `l₂ [`i]))))]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       (Term.proj `l₁ "." `Sum)
       [(Term.fun
         "fun"
         (Term.basicFun
          [`i `y]
          []
          "=>"
          («term_*_»
           (Term.app (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj") [`y])
           "*"
           (Term.app `l₂ [`i]))))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun
       "fun"
       (Term.basicFun
        [`i `y]
        []
        "=>"
        («term_*_»
         (Term.app (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj") [`y])
         "*"
         (Term.app `l₂ [`i]))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (Term.app (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj") [`y])
       "*"
       (Term.app `l₂ [`i]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `l₂ [`i])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `i
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `l₂
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Term.app (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj") [`y])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1022, (some 1023, term) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 70, (some 71, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `i
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.proj `l₁ "." `Sum)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `l₁
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1022, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
       "⟪"
       (Term.app `Finsupp.total [`ι `E `𝕜 `v `l₁])
       ", "
       (Term.app `Finsupp.total [`ι `E `𝕜 `v `l₂])
       "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    The inner product of two linear combinations of a set of orthonormal vectors, expressed as
    a sum over the first `finsupp`. -/
  theorem
    Orthonormal.inner_finsupp_eq_sum_left
    { v : ι → E } ( hv : Orthonormal 𝕜 v ) ( l₁ l₂ : ι →₀ 𝕜 )
      : ⟪ Finsupp.total ι E 𝕜 v l₁ , Finsupp.total ι E 𝕜 v l₂ ⟫ = l₁ . Sum fun i y => conj y * l₂ i
    := by simp only [ l₁.total_apply _ , Finsupp.sum_inner , hv.inner_right_finsupp , smul_eq_mul ]
#align orthonormal.inner_finsupp_eq_sum_left Orthonormal.inner_finsupp_eq_sum_left

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "The inner product of two linear combinations of a set of orthonormal vectors, expressed as\na sum over the second `finsupp`. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `Orthonormal.inner_finsupp_eq_sum_right [])
      (Command.declSig
       [(Term.implicitBinder "{" [`v] [":" (Term.arrow `ι "→" `E)] "}")
        (Term.explicitBinder "(" [`hv] [":" (Term.app `Orthonormal [`𝕜 `v])] [] ")")
        (Term.explicitBinder
         "("
         [`l₁ `l₂]
         [":" (Data.Finsupp.Defs.«term_→₀_» `ι " →₀ " `𝕜)]
         []
         ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (Term.app `Finsupp.total [`ι `E `𝕜 `v `l₁])
          ", "
          (Term.app `Finsupp.total [`ι `E `𝕜 `v `l₂])
          "⟫")
         "="
         (Term.app
          (Term.proj `l₂ "." `Sum)
          [(Term.fun
            "fun"
            (Term.basicFun
             [`i `y]
             []
             "=>"
             («term_*_»
              (Term.app
               (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj")
               [(Term.app `l₁ [`i])])
              "*"
              `y)))]))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.simp
            "simp"
            []
            []
            ["only"]
            ["["
             [(Tactic.simpLemma [] [] (Term.app `l₂.total_apply [(Term.hole "_")]))
              ","
              (Tactic.simpLemma [] [] `Finsupp.inner_sum)
              ","
              (Tactic.simpLemma [] [] `hv.inner_left_finsupp)
              ","
              (Tactic.simpLemma [] [] `mul_comm)
              ","
              (Tactic.simpLemma [] [] `smul_eq_mul)]
             "]"]
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["["
            [(Tactic.simpLemma [] [] (Term.app `l₂.total_apply [(Term.hole "_")]))
             ","
             (Tactic.simpLemma [] [] `Finsupp.inner_sum)
             ","
             (Tactic.simpLemma [] [] `hv.inner_left_finsupp)
             ","
             (Tactic.simpLemma [] [] `mul_comm)
             ","
             (Tactic.simpLemma [] [] `smul_eq_mul)]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] (Term.app `l₂.total_apply [(Term.hole "_")]))
         ","
         (Tactic.simpLemma [] [] `Finsupp.inner_sum)
         ","
         (Tactic.simpLemma [] [] `hv.inner_left_finsupp)
         ","
         (Tactic.simpLemma [] [] `mul_comm)
         ","
         (Tactic.simpLemma [] [] `smul_eq_mul)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `smul_eq_mul
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `mul_comm
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hv.inner_left_finsupp
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Finsupp.inner_sum
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `l₂.total_apply [(Term.hole "_")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `l₂.total_apply
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        (Term.app `Finsupp.total [`ι `E `𝕜 `v `l₁])
        ", "
        (Term.app `Finsupp.total [`ι `E `𝕜 `v `l₂])
        "⟫")
       "="
       (Term.app
        (Term.proj `l₂ "." `Sum)
        [(Term.fun
          "fun"
          (Term.basicFun
           [`i `y]
           []
           "=>"
           («term_*_»
            (Term.app
             (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj")
             [(Term.app `l₁ [`i])])
            "*"
            `y)))]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       (Term.proj `l₂ "." `Sum)
       [(Term.fun
         "fun"
         (Term.basicFun
          [`i `y]
          []
          "=>"
          («term_*_»
           (Term.app
            (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj")
            [(Term.app `l₁ [`i])])
           "*"
           `y)))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun
       "fun"
       (Term.basicFun
        [`i `y]
        []
        "=>"
        («term_*_»
         (Term.app (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj") [(Term.app `l₁ [`i])])
         "*"
         `y)))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (Term.app (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj") [(Term.app `l₁ [`i])])
       "*"
       `y)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Term.app (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj") [(Term.app `l₁ [`i])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `l₁ [`i])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `i
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `l₁
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `l₁ [`i]) ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1022, (some 1023, term) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 70, (some 71, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `i
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.proj `l₂ "." `Sum)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `l₂
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1022, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
       "⟪"
       (Term.app `Finsupp.total [`ι `E `𝕜 `v `l₁])
       ", "
       (Term.app `Finsupp.total [`ι `E `𝕜 `v `l₂])
       "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    The inner product of two linear combinations of a set of orthonormal vectors, expressed as
    a sum over the second `finsupp`. -/
  theorem
    Orthonormal.inner_finsupp_eq_sum_right
    { v : ι → E } ( hv : Orthonormal 𝕜 v ) ( l₁ l₂ : ι →₀ 𝕜 )
      : ⟪ Finsupp.total ι E 𝕜 v l₁ , Finsupp.total ι E 𝕜 v l₂ ⟫ = l₂ . Sum fun i y => conj l₁ i * y
    :=
      by
        simp
          only
          [ l₂.total_apply _ , Finsupp.inner_sum , hv.inner_left_finsupp , mul_comm , smul_eq_mul ]
#align orthonormal.inner_finsupp_eq_sum_right Orthonormal.inner_finsupp_eq_sum_right

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "The inner product of two linear combinations of a set of orthonormal vectors, expressed as\na sum. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `Orthonormal.inner_sum [])
      (Command.declSig
       [(Term.implicitBinder "{" [`v] [":" (Term.arrow `ι "→" `E)] "}")
        (Term.explicitBinder "(" [`hv] [":" (Term.app `Orthonormal [`𝕜 `v])] [] ")")
        (Term.explicitBinder "(" [`l₁ `l₂] [":" (Term.arrow `ι "→" `𝕜)] [] ")")
        (Term.explicitBinder "(" [`s] [":" (Term.app `Finset [`ι])] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (BigOperators.Algebra.BigOperators.Basic.finset.sum
           "∑"
           (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
           " in "
           `s
           ", "
           (Algebra.Group.Defs.«term_•_» (Term.app `l₁ [`i]) " • " (Term.app `v [`i])))
          ", "
          (BigOperators.Algebra.BigOperators.Basic.finset.sum
           "∑"
           (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
           " in "
           `s
           ", "
           (Algebra.Group.Defs.«term_•_» (Term.app `l₂ [`i]) " • " (Term.app `v [`i])))
          "⟫")
         "="
         (BigOperators.Algebra.BigOperators.Basic.finset.sum
          "∑"
          (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
          " in "
          `s
          ", "
          («term_*_»
           (Term.app
            (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj")
            [(Term.app `l₁ [`i])])
           "*"
           (Term.app `l₂ [`i]))))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Mathlib.Tactic.tacticSimp_rw__
            "simp_rw"
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [] `sum_inner) "," (Tactic.rwRule [] `inner_smul_left)]
             "]")
            [])
           []
           (Tactic.refine'
            "refine'"
            (Term.app
             `Finset.sum_congr
             [`rfl (Term.fun "fun" (Term.basicFun [`i `hi] [] "=>" (Term.hole "_")))]))
           []
           (Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] (Term.app `hv.inner_right_sum [`l₂ `hi]))] "]")
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Mathlib.Tactic.tacticSimp_rw__
           "simp_rw"
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] `sum_inner) "," (Tactic.rwRule [] `inner_smul_left)]
            "]")
           [])
          []
          (Tactic.refine'
           "refine'"
           (Term.app
            `Finset.sum_congr
            [`rfl (Term.fun "fun" (Term.basicFun [`i `hi] [] "=>" (Term.hole "_")))]))
          []
          (Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] (Term.app `hv.inner_right_sum [`l₂ `hi]))] "]")
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] (Term.app `hv.inner_right_sum [`l₂ `hi]))] "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `hv.inner_right_sum [`l₂ `hi])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hi
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `l₂
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `hv.inner_right_sum
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.refine'
       "refine'"
       (Term.app
        `Finset.sum_congr
        [`rfl (Term.fun "fun" (Term.basicFun [`i `hi] [] "=>" (Term.hole "_")))]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `Finset.sum_congr
       [`rfl (Term.fun "fun" (Term.basicFun [`i `hi] [] "=>" (Term.hole "_")))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun "fun" (Term.basicFun [`i `hi] [] "=>" (Term.hole "_")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hi
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `i
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      `rfl
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `Finset.sum_congr
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.tacticSimp_rw__
       "simp_rw"
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [] `sum_inner) "," (Tactic.rwRule [] `inner_smul_left)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_smul_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `sum_inner
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        (BigOperators.Algebra.BigOperators.Basic.finset.sum
         "∑"
         (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
         " in "
         `s
         ", "
         (Algebra.Group.Defs.«term_•_» (Term.app `l₁ [`i]) " • " (Term.app `v [`i])))
        ", "
        (BigOperators.Algebra.BigOperators.Basic.finset.sum
         "∑"
         (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
         " in "
         `s
         ", "
         (Algebra.Group.Defs.«term_•_» (Term.app `l₂ [`i]) " • " (Term.app `v [`i])))
        "⟫")
       "="
       (BigOperators.Algebra.BigOperators.Basic.finset.sum
        "∑"
        (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
        " in "
        `s
        ", "
        («term_*_»
         (Term.app (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj") [(Term.app `l₁ [`i])])
         "*"
         (Term.app `l₂ [`i]))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (BigOperators.Algebra.BigOperators.Basic.finset.sum
       "∑"
       (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
       " in "
       `s
       ", "
       («term_*_»
        (Term.app (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj") [(Term.app `l₁ [`i])])
        "*"
        (Term.app `l₂ [`i])))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (Term.app (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj") [(Term.app `l₁ [`i])])
       "*"
       (Term.app `l₂ [`i]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `l₂ [`i])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `i
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `l₂
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Term.app (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj") [(Term.app `l₁ [`i])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `l₁ [`i])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `i
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `l₁
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `l₁ [`i]) ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1022, (some 1023, term) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 70, (some 71, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `s
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1022, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
       "⟪"
       (BigOperators.Algebra.BigOperators.Basic.finset.sum
        "∑"
        (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
        " in "
        `s
        ", "
        (Algebra.Group.Defs.«term_•_» (Term.app `l₁ [`i]) " • " (Term.app `v [`i])))
       ", "
       (BigOperators.Algebra.BigOperators.Basic.finset.sum
        "∑"
        (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
        " in "
        `s
        ", "
        (Algebra.Group.Defs.«term_•_» (Term.app `l₂ [`i]) " • " (Term.app `v [`i])))
       "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    The inner product of two linear combinations of a set of orthonormal vectors, expressed as
    a sum. -/
  theorem
    Orthonormal.inner_sum
    { v : ι → E } ( hv : Orthonormal 𝕜 v ) ( l₁ l₂ : ι → 𝕜 ) ( s : Finset ι )
      : ⟪ ∑ i in s , l₁ i • v i , ∑ i in s , l₂ i • v i ⟫ = ∑ i in s , conj l₁ i * l₂ i
    :=
      by
        simp_rw [ sum_inner , inner_smul_left ]
          refine' Finset.sum_congr rfl fun i hi => _
          rw [ hv.inner_right_sum l₂ hi ]
#align orthonormal.inner_sum Orthonormal.inner_sum

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "The double sum of weighted inner products of pairs of vectors from an orthonormal sequence is the\nsum of the weights.\n-/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `Orthonormal.inner_left_right_finset [])
      (Command.declSig
       [(Term.implicitBinder "{" [`s] [":" (Term.app `Finset [`ι])] "}")
        (Term.implicitBinder "{" [`v] [":" (Term.arrow `ι "→" `E)] "}")
        (Term.explicitBinder "(" [`hv] [":" (Term.app `Orthonormal [`𝕜 `v])] [] ")")
        (Term.implicitBinder "{" [`a] [":" (Term.arrow `ι "→" (Term.arrow `ι "→" `𝕜))] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (BigOperators.Algebra.BigOperators.Basic.finset.sum
          "∑"
          (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
          " in "
          `s
          ", "
          (BigOperators.Algebra.BigOperators.Basic.finset.sum
           "∑"
           (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) []))
           " in "
           `s
           ", "
           (Algebra.Group.Defs.«term_•_»
            (Term.app `a [`i `j])
            " • "
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             (Term.app `v [`j])
             ", "
             (Term.app `v [`i])
             "⟫"))))
         "="
         (BigOperators.Algebra.BigOperators.Basic.finset.sum
          "∑"
          (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `k) []))
          " in "
          `s
          ", "
          (Term.app `a [`k `k])))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Mathlib.Tactic.tacticClassical_
            "classical"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.simp
                "simp"
                []
                []
                []
                ["["
                 [(Tactic.simpLemma [] [] (Term.app `orthonormal_iff_ite.mp [`hv]))
                  ","
                  (Tactic.simpLemma [] [] `Finset.sum_ite_of_true)]
                 "]"]
                [])])))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Mathlib.Tactic.tacticClassical_
           "classical"
           (Tactic.tacticSeq
            (Tactic.tacticSeq1Indented
             [(Tactic.simp
               "simp"
               []
               []
               []
               ["["
                [(Tactic.simpLemma [] [] (Term.app `orthonormal_iff_ite.mp [`hv]))
                 ","
                 (Tactic.simpLemma [] [] `Finset.sum_ite_of_true)]
                "]"]
               [])])))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.tacticClassical_
       "classical"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           []
           ["["
            [(Tactic.simpLemma [] [] (Term.app `orthonormal_iff_ite.mp [`hv]))
             ","
             (Tactic.simpLemma [] [] `Finset.sum_ite_of_true)]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       []
       ["["
        [(Tactic.simpLemma [] [] (Term.app `orthonormal_iff_ite.mp [`hv]))
         ","
         (Tactic.simpLemma [] [] `Finset.sum_ite_of_true)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Finset.sum_ite_of_true
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `orthonormal_iff_ite.mp [`hv])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hv
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `orthonormal_iff_ite.mp
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (BigOperators.Algebra.BigOperators.Basic.finset.sum
        "∑"
        (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
        " in "
        `s
        ", "
        (BigOperators.Algebra.BigOperators.Basic.finset.sum
         "∑"
         (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) []))
         " in "
         `s
         ", "
         (Algebra.Group.Defs.«term_•_»
          (Term.app `a [`i `j])
          " • "
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           (Term.app `v [`j])
           ", "
           (Term.app `v [`i])
           "⟫"))))
       "="
       (BigOperators.Algebra.BigOperators.Basic.finset.sum
        "∑"
        (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `k) []))
        " in "
        `s
        ", "
        (Term.app `a [`k `k])))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (BigOperators.Algebra.BigOperators.Basic.finset.sum
       "∑"
       (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `k) []))
       " in "
       `s
       ", "
       (Term.app `a [`k `k]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `a [`k `k])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `k
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `k
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `a
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `s
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1022, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (BigOperators.Algebra.BigOperators.Basic.finset.sum
       "∑"
       (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
       " in "
       `s
       ", "
       (BigOperators.Algebra.BigOperators.Basic.finset.sum
        "∑"
        (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) []))
        " in "
        `s
        ", "
        (Algebra.Group.Defs.«term_•_»
         (Term.app `a [`i `j])
         " • "
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (Term.app `v [`j])
          ", "
          (Term.app `v [`i])
          "⟫"))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (BigOperators.Algebra.BigOperators.Basic.finset.sum
       "∑"
       (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) []))
       " in "
       `s
       ", "
       (Algebra.Group.Defs.«term_•_»
        (Term.app `a [`i `j])
        " • "
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
         "⟪"
         (Term.app `v [`j])
         ", "
         (Term.app `v [`i])
         "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Algebra.Group.Defs.«term_•_»
       (Term.app `a [`i `j])
       " • "
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        (Term.app `v [`j])
        ", "
        (Term.app `v [`i])
        "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
       "⟪"
       (Term.app `v [`j])
       ", "
       (Term.app `v [`i])
       "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    The double sum of weighted inner products of pairs of vectors from an orthonormal sequence is the
    sum of the weights.
    -/
  theorem
    Orthonormal.inner_left_right_finset
    { s : Finset ι } { v : ι → E } ( hv : Orthonormal 𝕜 v ) { a : ι → ι → 𝕜 }
      : ∑ i in s , ∑ j in s , a i j • ⟪ v j , v i ⟫ = ∑ k in s , a k k
    := by classical simp [ orthonormal_iff_ite.mp hv , Finset.sum_ite_of_true ]
#align orthonormal.inner_left_right_finset Orthonormal.inner_left_right_finset

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment "/--" "An orthonormal set is linearly independent. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `Orthonormal.linear_independent [])
      (Command.declSig
       [(Term.implicitBinder "{" [`v] [":" (Term.arrow `ι "→" `E)] "}")
        (Term.explicitBinder "(" [`hv] [":" (Term.app `Orthonormal [`𝕜 `v])] [] ")")]
       (Term.typeSpec ":" (Term.app `LinearIndependent [`𝕜 `v])))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `linear_independent_iff)] "]")
            [])
           []
           (Tactic.intro "intro" [`l `hl])
           []
           (Std.Tactic.Ext.«tacticExt___:_»
            "ext"
            [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `i))]
            [])
           []
           (Tactic.tacticHave_
            "have"
            (Term.haveDecl
             (Term.haveIdDecl
              [`key []]
              [(Term.typeSpec
                ":"
                («term_=_»
                 (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                  "⟪"
                  (Term.app `v [`i])
                  ", "
                  (Term.app `Finsupp.total [`ι `E `𝕜 `v `l])
                  "⟫")
                 "="
                 (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                  "⟪"
                  (Term.app `v [`i])
                  ", "
                  (num "0")
                  "⟫")))]
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.rwSeq
                   "rw"
                   []
                   (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `hl)] "]")
                   [])]))))))
           []
           (Std.Tactic.Simpa.simpa
            "simpa"
            []
            []
            (Std.Tactic.Simpa.simpaArgsRest
             []
             []
             ["only"]
             [(Tactic.simpArgs
               "["
               [(Tactic.simpLemma [] [] `hv.inner_right_finsupp)
                ","
                (Tactic.simpLemma [] [] `inner_zero_right)]
               "]")]
             ["using" `key]))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `linear_independent_iff)] "]")
           [])
          []
          (Tactic.intro "intro" [`l `hl])
          []
          (Std.Tactic.Ext.«tacticExt___:_»
           "ext"
           [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `i))]
           [])
          []
          (Tactic.tacticHave_
           "have"
           (Term.haveDecl
            (Term.haveIdDecl
             [`key []]
             [(Term.typeSpec
               ":"
               («term_=_»
                (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                 "⟪"
                 (Term.app `v [`i])
                 ", "
                 (Term.app `Finsupp.total [`ι `E `𝕜 `v `l])
                 "⟫")
                "="
                (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                 "⟪"
                 (Term.app `v [`i])
                 ", "
                 (num "0")
                 "⟫")))]
             ":="
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Tactic.rwSeq
                  "rw"
                  []
                  (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `hl)] "]")
                  [])]))))))
          []
          (Std.Tactic.Simpa.simpa
           "simpa"
           []
           []
           (Std.Tactic.Simpa.simpaArgsRest
            []
            []
            ["only"]
            [(Tactic.simpArgs
              "["
              [(Tactic.simpLemma [] [] `hv.inner_right_finsupp)
               ","
               (Tactic.simpLemma [] [] `inner_zero_right)]
              "]")]
            ["using" `key]))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Std.Tactic.Simpa.simpa
       "simpa"
       []
       []
       (Std.Tactic.Simpa.simpaArgsRest
        []
        []
        ["only"]
        [(Tactic.simpArgs
          "["
          [(Tactic.simpLemma [] [] `hv.inner_right_finsupp)
           ","
           (Tactic.simpLemma [] [] `inner_zero_right)]
          "]")]
        ["using" `key]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `key
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_zero_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hv.inner_right_finsupp
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.tacticHave_
       "have"
       (Term.haveDecl
        (Term.haveIdDecl
         [`key []]
         [(Term.typeSpec
           ":"
           («term_=_»
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             (Term.app `v [`i])
             ", "
             (Term.app `Finsupp.total [`ι `E `𝕜 `v `l])
             "⟫")
            "="
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             (Term.app `v [`i])
             ", "
             (num "0")
             "⟫")))]
         ":="
         (Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `hl)] "]") [])]))))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `hl)] "]") [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `hl)] "]") [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hl
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        (Term.app `v [`i])
        ", "
        (Term.app `Finsupp.total [`ι `E `𝕜 `v `l])
        "⟫")
       "="
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " (num "0") "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " (num "0") "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.haveIdDecl', expected 'Lean.Parser.Term.letPatDecl'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.haveIdDecl', expected 'Lean.Parser.Term.haveEqnsDecl'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- An orthonormal set is linearly independent. -/
  theorem
    Orthonormal.linear_independent
    { v : ι → E } ( hv : Orthonormal 𝕜 v ) : LinearIndependent 𝕜 v
    :=
      by
        rw [ linear_independent_iff ]
          intro l hl
          ext i
          have key : ⟪ v i , Finsupp.total ι E 𝕜 v l ⟫ = ⟪ v i , 0 ⟫ := by rw [ hl ]
          simpa only [ hv.inner_right_finsupp , inner_zero_right ] using key
#align orthonormal.linear_independent Orthonormal.linear_independent

/-- A subfamily of an orthonormal family (i.e., a composition with an injective map) is an
orthonormal family. -/
theorem Orthonormal.comp {ι' : Type _} {v : ι → E} (hv : Orthonormal 𝕜 v) (f : ι' → ι)
    (hf : Function.Injective f) : Orthonormal 𝕜 (v ∘ f) := by
  classical
    rw [orthonormal_iff_ite] at hv⊢
    intro i j
    convert hv (f i) (f j) using 1
    simp [hf.eq_iff]
#align orthonormal.comp Orthonormal.comp

/-- An injective family `v : ι → E` is orthonormal if and only if `coe : (range v) → E` is
orthonormal. -/
theorem orthonormal_subtype_range {v : ι → E} (hv : Function.Injective v) :
    Orthonormal 𝕜 (coe : Set.range v → E) ↔ Orthonormal 𝕜 v :=
  by
  let f : ι ≃ Set.range v := Equiv.ofInjective v hv
  refine' ⟨fun h => h.comp f f.injective, fun h => _⟩
  rw [← Equiv.self_comp_ofInjective_symm hv]
  exact h.comp f.symm f.symm.injective
#align orthonormal_subtype_range orthonormal_subtype_range

/-- If `v : ι → E` is an orthonormal family, then `coe : (range v) → E` is an orthonormal
family. -/
theorem Orthonormal.toSubtypeRange {v : ι → E} (hv : Orthonormal 𝕜 v) :
    Orthonormal 𝕜 (coe : Set.range v → E) :=
  (orthonormal_subtype_range hv.LinearIndependent.Injective).2 hv
#align orthonormal.to_subtype_range Orthonormal.toSubtypeRange

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "A linear combination of some subset of an orthonormal set is orthogonal to other members of the\nset. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `Orthonormal.inner_finsupp_eq_zero [])
      (Command.declSig
       [(Term.implicitBinder "{" [`v] [":" (Term.arrow `ι "→" `E)] "}")
        (Term.explicitBinder "(" [`hv] [":" (Term.app `Orthonormal [`𝕜 `v])] [] ")")
        (Term.implicitBinder "{" [`s] [":" (Term.app `Set [`ι])] "}")
        (Term.implicitBinder "{" [`i] [":" `ι] "}")
        (Term.explicitBinder "(" [`hi] [":" («term_∉_» `i "∉" `s)] [] ")")
        (Term.implicitBinder "{" [`l] [":" (Data.Finsupp.Defs.«term_→₀_» `ι " →₀ " `𝕜)] "}")
        (Term.explicitBinder
         "("
         [`hl]
         [":" («term_∈_» `l "∈" (Term.app `Finsupp.supported [`𝕜 `𝕜 `s]))]
         []
         ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (Term.app `Finsupp.total [`ι `E `𝕜 `v `l])
          ", "
          (Term.app `v [`i])
          "⟫")
         "="
         (num "0"))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `Finsupp.mem_supported')] "]")
            [(Tactic.location "at" (Tactic.locationHyp [`hl] []))])
           []
           (Tactic.simp
            "simp"
            []
            []
            ["only"]
            ["["
             [(Tactic.simpLemma [] [] `hv.inner_left_finsupp)
              ","
              (Tactic.simpLemma [] [] (Term.app `hl [`i `hi]))
              ","
              (Tactic.simpLemma [] [] `map_zero)]
             "]"]
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `Finsupp.mem_supported')] "]")
           [(Tactic.location "at" (Tactic.locationHyp [`hl] []))])
          []
          (Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["["
            [(Tactic.simpLemma [] [] `hv.inner_left_finsupp)
             ","
             (Tactic.simpLemma [] [] (Term.app `hl [`i `hi]))
             ","
             (Tactic.simpLemma [] [] `map_zero)]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] `hv.inner_left_finsupp)
         ","
         (Tactic.simpLemma [] [] (Term.app `hl [`i `hi]))
         ","
         (Tactic.simpLemma [] [] `map_zero)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `map_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `hl [`i `hi])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hi
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `i
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `hl
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hv.inner_left_finsupp
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `Finsupp.mem_supported')] "]")
       [(Tactic.location "at" (Tactic.locationHyp [`hl] []))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.locationHyp', expected 'Lean.Parser.Tactic.locationWildcard'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hl
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Finsupp.mem_supported'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        (Term.app `Finsupp.total [`ι `E `𝕜 `v `l])
        ", "
        (Term.app `v [`i])
        "⟫")
       "="
       (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
       "⟪"
       (Term.app `Finsupp.total [`ι `E `𝕜 `v `l])
       ", "
       (Term.app `v [`i])
       "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    A linear combination of some subset of an orthonormal set is orthogonal to other members of the
    set. -/
  theorem
    Orthonormal.inner_finsupp_eq_zero
    { v : ι → E }
        ( hv : Orthonormal 𝕜 v )
        { s : Set ι }
        { i : ι }
        ( hi : i ∉ s )
        { l : ι →₀ 𝕜 }
        ( hl : l ∈ Finsupp.supported 𝕜 𝕜 s )
      : ⟪ Finsupp.total ι E 𝕜 v l , v i ⟫ = 0
    :=
      by
        rw [ Finsupp.mem_supported' ] at hl simp only [ hv.inner_left_finsupp , hl i hi , map_zero ]
#align orthonormal.inner_finsupp_eq_zero Orthonormal.inner_finsupp_eq_zero

/-- Given an orthonormal family, a second family of vectors is orthonormal if every vector equals
the corresponding vector in the original family or its negation. -/
theorem Orthonormal.orthonormalOfForallEqOrEqNeg {v w : ι → E} (hv : Orthonormal 𝕜 v)
    (hw : ∀ i, w i = v i ∨ w i = -v i) : Orthonormal 𝕜 w := by
  classical
    rw [orthonormal_iff_ite] at *
    intro i j
    cases' hw i with hi hi <;> cases' hw j with hj hj <;> split_ifs with h <;>
      simpa only [hi, hj, h, inner_neg_right, inner_neg_left, neg_neg, eq_self_iff_true,
        neg_eq_zero] using hv i j
#align orthonormal.orthonormal_of_forall_eq_or_eq_neg Orthonormal.orthonormalOfForallEqOrEqNeg

/- The material that follows, culminating in the existence of a maximal orthonormal subset, is
adapted from the corresponding development of the theory of linearly independents sets.  See
`exists_linear_independent` in particular. -/
variable (𝕜 E)

theorem orthonormalEmpty : Orthonormal 𝕜 (fun x => x : (∅ : Set E) → E) := by
  classical simp [orthonormal_subtype_iff_ite]
#align orthonormal_empty orthonormalEmpty

variable {𝕜 E}

theorem orthonormalUnionOfDirected {η : Type _} {s : η → Set E} (hs : Directed (· ⊆ ·) s)
    (h : ∀ i, Orthonormal 𝕜 (fun x => x : s i → E)) : Orthonormal 𝕜 (fun x => x : (⋃ i, s i) → E) :=
  by
  classical
    rw [orthonormal_subtype_iff_ite]
    rintro x ⟨_, ⟨i, rfl⟩, hxi⟩ y ⟨_, ⟨j, rfl⟩, hyj⟩
    obtain ⟨k, hik, hjk⟩ := hs i j
    have h_orth : Orthonormal 𝕜 (fun x => x : s k → E) := h k
    rw [orthonormal_subtype_iff_ite] at h_orth
    exact h_orth x (hik hxi) y (hjk hyj)
#align orthonormal_Union_of_directed orthonormalUnionOfDirected

theorem orthonormalSUnionOfDirected {s : Set (Set E)} (hs : DirectedOn (· ⊆ ·) s)
    (h : ∀ a ∈ s, Orthonormal 𝕜 (fun x => x : (a : Set E) → E)) :
    Orthonormal 𝕜 (fun x => x : ⋃₀ s → E) := by
  rw [Set.unionₛ_eq_unionᵢ] <;> exact orthonormalUnionOfDirected hs.directed_coe (by simpa using h)
#align orthonormal_sUnion_of_directed orthonormalSUnionOfDirected

/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (w «expr ⊇ » s) -/
/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (u «expr ⊇ » w) -/
/-- Given an orthonormal set `v` of vectors in `E`, there exists a maximal orthonormal set
containing it. -/
theorem exists_maximal_orthonormal {s : Set E} (hs : Orthonormal 𝕜 (coe : s → E)) :
    ∃ (w : _)(_ : w ⊇ s),
      Orthonormal 𝕜 (coe : w → E) ∧ ∀ (u) (_ : u ⊇ w), Orthonormal 𝕜 (coe : u → E) → u = w :=
  by
  obtain ⟨b, bi, sb, h⟩ := zorn_subset_nonempty { b | Orthonormal 𝕜 (coe : b → E) } _ _ hs
  · refine' ⟨b, sb, bi, _⟩
    exact fun u hus hu => h u hu hus
  · refine' fun c hc cc c0 => ⟨⋃₀ c, _, _⟩
    · exact orthonormalSUnionOfDirected cc.directed_on fun x xc => hc xc
    · exact fun _ => Set.subset_unionₛ_of_mem
#align exists_maximal_orthonormal exists_maximal_orthonormal

theorem Orthonormal.ne_zero {v : ι → E} (hv : Orthonormal 𝕜 v) (i : ι) : v i ≠ 0 :=
  by
  have : ‖v i‖ ≠ 0 := by
    rw [hv.1 i]
    norm_num
  simpa using this
#align orthonormal.ne_zero Orthonormal.ne_zero

open FiniteDimensional

/-- A family of orthonormal vectors with the correct cardinality forms a basis. -/
def basisOfOrthonormalOfCardEqFinrank [Fintype ι] [Nonempty ι] {v : ι → E} (hv : Orthonormal 𝕜 v)
    (card_eq : Fintype.card ι = finrank 𝕜 E) : Basis ι 𝕜 E :=
  basisOfLinearIndependentOfCardEqFinrank hv.LinearIndependent card_eq
#align basis_of_orthonormal_of_card_eq_finrank basisOfOrthonormalOfCardEqFinrank

@[simp]
theorem coe_basis_of_orthonormal_of_card_eq_finrank [Fintype ι] [Nonempty ι] {v : ι → E}
    (hv : Orthonormal 𝕜 v) (card_eq : Fintype.card ι = finrank 𝕜 E) :
    (basisOfOrthonormalOfCardEqFinrank hv card_eq : ι → E) = v :=
  coe_basis_of_linear_independent_of_card_eq_finrank _ _
#align coe_basis_of_orthonormal_of_card_eq_finrank coe_basis_of_orthonormal_of_card_eq_finrank

end OrthonormalSets

section Norm

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `norm_eq_sqrt_inner [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x] [":" `E] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
         "="
         (Term.app
          `sqrt
          [(Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])]))))
      (Command.declValSimple
       ":="
       (calc
        "calc"
        (calcStep
         («term_=_»
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
          "="
          (Term.app
           `sqrt
           [(«term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "^" (num "2"))]))
         ":="
         (Term.proj (Term.app `sqrt_sq [(Term.app `norm_nonneg [(Term.hole "_")])]) "." `symm))
        [(calcStep
          («term_=_»
           (Term.hole "_")
           "="
           (Term.app
            `sqrt
            [(Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])]))
          ":="
          (Term.app `congr_arg [(Term.hole "_") (Term.app `norm_sq_eq_inner [(Term.hole "_")])]))])
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (calc
       "calc"
       (calcStep
        («term_=_»
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
         "="
         (Term.app
          `sqrt
          [(«term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "^" (num "2"))]))
        ":="
        (Term.proj (Term.app `sqrt_sq [(Term.app `norm_nonneg [(Term.hole "_")])]) "." `symm))
       [(calcStep
         («term_=_»
          (Term.hole "_")
          "="
          (Term.app
           `sqrt
           [(Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])]))
         ":="
         (Term.app `congr_arg [(Term.hole "_") (Term.app `norm_sq_eq_inner [(Term.hole "_")])]))])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `congr_arg [(Term.hole "_") (Term.app `norm_sq_eq_inner [(Term.hole "_")])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `norm_sq_eq_inner [(Term.hole "_")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `norm_sq_eq_inner
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app `norm_sq_eq_inner [(Term.hole "_")])
     ")")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `congr_arg
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_»
       (Term.hole "_")
       "="
       (Term.app
        `sqrt
        [(Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `sqrt
       [(Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  norm_eq_sqrt_inner
  ( x : E ) : ‖ x ‖ = sqrt re ⟪ x , x ⟫
  :=
    calc
      ‖ x ‖ = sqrt ‖ x ‖ ^ 2 := sqrt_sq norm_nonneg _ . symm
      _ = sqrt re ⟪ x , x ⟫ := congr_arg _ norm_sq_eq_inner _
#align norm_eq_sqrt_inner norm_eq_sqrt_inner

theorem norm_eq_sqrt_real_inner (x : F) : ‖x‖ = sqrt ⟪x, x⟫_ℝ :=
  by
  have h := @norm_eq_sqrt_inner ℝ F _ _ x
  simpa using h
#align norm_eq_sqrt_real_inner norm_eq_sqrt_real_inner

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_self_eq_norm_mul_norm [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x] [":" `E] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
         "="
         («term_*_»
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
          "*"
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [] `norm_eq_sqrt_inner)
              ","
              (Tactic.rwRule
               [(patternIgnore (token.«← » "←"))]
               (Term.app
                `sqrt_mul
                [`inner_self_nonneg
                 (Term.app
                  `re
                  [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])]))
              ","
              (Tactic.rwRule [] (Term.app `sqrt_mul_self [`inner_self_nonneg]))]
             "]")
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] `norm_eq_sqrt_inner)
             ","
             (Tactic.rwRule
              [(patternIgnore (token.«← » "←"))]
              (Term.app
               `sqrt_mul
               [`inner_self_nonneg
                (Term.app
                 `re
                 [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])]))
             ","
             (Tactic.rwRule [] (Term.app `sqrt_mul_self [`inner_self_nonneg]))]
            "]")
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [] `norm_eq_sqrt_inner)
         ","
         (Tactic.rwRule
          [(patternIgnore (token.«← » "←"))]
          (Term.app
           `sqrt_mul
           [`inner_self_nonneg
            (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])]))
         ","
         (Tactic.rwRule [] (Term.app `sqrt_mul_self [`inner_self_nonneg]))]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `sqrt_mul_self [`inner_self_nonneg])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_self_nonneg
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `sqrt_mul_self
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `sqrt_mul
       [`inner_self_nonneg
        (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_self_eq_norm_mul_norm
  ( x : E ) : re ⟪ x , x ⟫ = ‖ x ‖ * ‖ x ‖
  :=
    by
      rw
        [
          norm_eq_sqrt_inner
            ,
            ← sqrt_mul inner_self_nonneg re ⟪ x , x ⟫
            ,
            sqrt_mul_self inner_self_nonneg
          ]
#align inner_self_eq_norm_mul_norm inner_self_eq_norm_mul_norm

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_self_eq_norm_sq [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x] [":" `E] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
         "="
         («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "^" (num "2")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [] `pow_two) "," (Tactic.rwRule [] `inner_self_eq_norm_mul_norm)]
             "]")
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] `pow_two) "," (Tactic.rwRule [] `inner_self_eq_norm_mul_norm)]
            "]")
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [] `pow_two) "," (Tactic.rwRule [] `inner_self_eq_norm_mul_norm)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_self_eq_norm_mul_norm
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `pow_two
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
       "="
       («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "^" (num "2")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "^" (num "2"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "2")
[PrettyPrinter.parenthesize] ...precedences are 80 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 80, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 81 >? 1024, (none, [anonymous]) <=? (some 80, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 80, (some 80, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  inner_self_eq_norm_sq
  ( x : E ) : re ⟪ x , x ⟫ = ‖ x ‖ ^ 2
  := by rw [ pow_two , inner_self_eq_norm_mul_norm ]
#align inner_self_eq_norm_sq inner_self_eq_norm_sq

theorem real_inner_self_eq_norm_mul_norm (x : F) : ⟪x, x⟫_ℝ = ‖x‖ * ‖x‖ :=
  by
  have h := @inner_self_eq_norm_mul_norm ℝ F _ _ x
  simpa using h
#align real_inner_self_eq_norm_mul_norm real_inner_self_eq_norm_mul_norm

theorem real_inner_self_eq_norm_sq (x : F) : ⟪x, x⟫_ℝ = ‖x‖ ^ 2 := by
  rw [pow_two, real_inner_self_eq_norm_mul_norm]
#align real_inner_self_eq_norm_sq real_inner_self_eq_norm_sq

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [(Command.docComment "/--" "Expand the square -/")] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `norm_add_sq [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         («term_^_»
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖")
          "^"
          (num "2"))
         "="
         («term_+_»
          («term_+_»
           («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "^" (num "2"))
           "+"
           («term_*_»
            (num "2")
            "*"
            (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))
          "+"
          («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖") "^" (num "2"))))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Std.Tactic.tacticRepeat'_
            "repeat'"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.rwSeq
                "rw"
                []
                (Tactic.rwRuleSeq
                 "["
                 [(Tactic.rwRule [] `sq)
                  ","
                  (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_self_eq_norm_mul_norm)]
                 "]")
                [])])))
           []
           (Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [] `inner_add_add_self) "," (Tactic.rwRule [] `two_mul)]
             "]")
            [])
           []
           (Tactic.simp
            "simp"
            []
            []
            ["only"]
            ["["
             [(Tactic.simpLemma [] [] `add_assoc)
              ","
              (Tactic.simpLemma [] [] `add_left_inj)
              ","
              (Tactic.simpLemma [] [] `add_right_inj)
              ","
              (Tactic.simpLemma [] [] `AddMonoidHom.map_add)]
             "]"]
            [])
           []
           (Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
              ","
              (Tactic.rwRule [] `conj_re)]
             "]")
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Std.Tactic.tacticRepeat'_
           "repeat'"
           (Tactic.tacticSeq
            (Tactic.tacticSeq1Indented
             [(Tactic.rwSeq
               "rw"
               []
               (Tactic.rwRuleSeq
                "["
                [(Tactic.rwRule [] `sq)
                 ","
                 (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_self_eq_norm_mul_norm)]
                "]")
               [])])))
          []
          (Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] `inner_add_add_self) "," (Tactic.rwRule [] `two_mul)]
            "]")
           [])
          []
          (Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["["
            [(Tactic.simpLemma [] [] `add_assoc)
             ","
             (Tactic.simpLemma [] [] `add_left_inj)
             ","
             (Tactic.simpLemma [] [] `add_right_inj)
             ","
             (Tactic.simpLemma [] [] `AddMonoidHom.map_add)]
            "]"]
           [])
          []
          (Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
             ","
             (Tactic.rwRule [] `conj_re)]
            "]")
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
         ","
         (Tactic.rwRule [] `conj_re)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `conj_re
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_conj_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] `add_assoc)
         ","
         (Tactic.simpLemma [] [] `add_left_inj)
         ","
         (Tactic.simpLemma [] [] `add_right_inj)
         ","
         (Tactic.simpLemma [] [] `AddMonoidHom.map_add)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `AddMonoidHom.map_add
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `add_right_inj
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `add_left_inj
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `add_assoc
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [] `inner_add_add_self) "," (Tactic.rwRule [] `two_mul)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `two_mul
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_add_add_self
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Std.Tactic.tacticRepeat'_
       "repeat'"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] `sq)
             ","
             (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_self_eq_norm_mul_norm)]
            "]")
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [] `sq)
         ","
         (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_self_eq_norm_mul_norm)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_self_eq_norm_mul_norm
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `sq
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       («term_^_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖")
        "^"
        (num "2"))
       "="
       («term_+_»
        («term_+_»
         («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "^" (num "2"))
         "+"
         («term_*_»
          (num "2")
          "*"
          (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))
        "+"
        («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖") "^" (num "2"))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_+_»
       («term_+_»
        («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "^" (num "2"))
        "+"
        («term_*_»
         (num "2")
         "*"
         (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))
       "+"
       («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖") "^" (num "2")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖") "^" (num "2"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "2")
[PrettyPrinter.parenthesize] ...precedences are 80 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 80, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 81 >? 1024, (none, [anonymous]) <=? (some 80, term)
[PrettyPrinter.parenthesize] ...precedences are 66 >? 80, (some 80, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 65, term))
      («term_+_»
       («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "^" (num "2"))
       "+"
       («term_*_»
        (num "2")
        "*"
        (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (num "2")
       "*"
       (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- Expand the square -/
  theorem
    norm_add_sq
    { x y : E } : ‖ x + y ‖ ^ 2 = ‖ x ‖ ^ 2 + 2 * re ⟪ x , y ⟫ + ‖ y ‖ ^ 2
    :=
      by
        repeat' rw [ sq , ← inner_self_eq_norm_mul_norm ]
          rw [ inner_add_add_self , two_mul ]
          simp only [ add_assoc , add_left_inj , add_right_inj , AddMonoidHom.map_add ]
          rw [ ← inner_conj_sym , conj_re ]
#align norm_add_sq norm_add_sq

alias norm_add_sq ← norm_add_pow_two

/-- Expand the square -/
theorem norm_add_sq_real {x y : F} : ‖x + y‖ ^ 2 = ‖x‖ ^ 2 + 2 * ⟪x, y⟫_ℝ + ‖y‖ ^ 2 :=
  by
  have h := @norm_add_sq ℝ F _ _
  simpa using h
#align norm_add_sq_real norm_add_sq_real

alias norm_add_sq_real ← norm_add_pow_two_real

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [(Command.docComment "/--" "Expand the square -/")] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `norm_add_mul_self [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         («term_*_»
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖")
          "*"
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖"))
         "="
         («term_+_»
          («term_+_»
           («term_*_»
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
            "*"
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
           "+"
           («term_*_»
            (num "2")
            "*"
            (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))
          "+"
          («term_*_»
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
           "*"
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Std.Tactic.tacticRepeat'_
            "repeat'"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.rwSeq
                "rw"
                []
                (Tactic.rwRuleSeq "[" [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `sq)] "]")
                [])])))
           []
           (Tactic.exact "exact" `norm_add_sq)])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Std.Tactic.tacticRepeat'_
           "repeat'"
           (Tactic.tacticSeq
            (Tactic.tacticSeq1Indented
             [(Tactic.rwSeq
               "rw"
               []
               (Tactic.rwRuleSeq "[" [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `sq)] "]")
               [])])))
          []
          (Tactic.exact "exact" `norm_add_sq)])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact "exact" `norm_add_sq)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `norm_add_sq
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Std.Tactic.tacticRepeat'_
       "repeat'"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq "[" [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `sq)] "]")
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq "[" [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `sq)] "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `sq
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖"))
       "="
       («term_+_»
        («term_+_»
         («term_*_»
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
          "*"
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
         "+"
         («term_*_»
          (num "2")
          "*"
          (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))
        "+"
        («term_*_»
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
         "*"
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_+_»
       («term_+_»
        («term_*_»
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
         "*"
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
        "+"
        («term_*_»
         (num "2")
         "*"
         (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))
       "+"
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
       "*"
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1024, (none, [anonymous]) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 66 >? 70, (some 71, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 65, term))
      («term_+_»
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
       "+"
       («term_*_»
        (num "2")
        "*"
        (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (num "2")
       "*"
       (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- Expand the square -/
  theorem
    norm_add_mul_self
    { x y : E } : ‖ x + y ‖ * ‖ x + y ‖ = ‖ x ‖ * ‖ x ‖ + 2 * re ⟪ x , y ⟫ + ‖ y ‖ * ‖ y ‖
    := by repeat' rw [ ← sq ] exact norm_add_sq
#align norm_add_mul_self norm_add_mul_self

/-- Expand the square -/
theorem norm_add_mul_self_real {x y : F} :
    ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + 2 * ⟪x, y⟫_ℝ + ‖y‖ * ‖y‖ :=
  by
  have h := @norm_add_mul_self ℝ F _ _
  simpa using h
#align norm_add_mul_self_real norm_add_mul_self_real

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [(Command.docComment "/--" "Expand the square -/")] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `norm_sub_sq [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         («term_^_»
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `x "-" `y) "‖")
          "^"
          (num "2"))
         "="
         («term_+_»
          («term_-_»
           («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "^" (num "2"))
           "-"
           («term_*_»
            (num "2")
            "*"
            (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))
          "+"
          («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖") "^" (num "2"))))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Std.Tactic.tacticRepeat'_
            "repeat'"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.rwSeq
                "rw"
                []
                (Tactic.rwRuleSeq
                 "["
                 [(Tactic.rwRule [] `sq)
                  ","
                  (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_self_eq_norm_mul_norm)]
                 "]")
                [])])))
           []
           (Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_sub_sub_self)] "]")
            [])
           []
           (calcTactic
            "calc"
            (calcStep
             («term_=_»
              (Term.app
               `re
               [(«term_+_»
                 («term_-_»
                  («term_-_»
                   (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
                   "-"
                   (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))
                  "-"
                  (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))
                 "+"
                 (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫"))])
              "="
              («term_+_»
               («term_-_»
                («term_-_»
                 (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                 "-"
                 (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")]))
                "-"
                (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")]))
               "+"
               (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")])))
             ":="
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Tactic.simp
                  "simp"
                  []
                  []
                  ["only"]
                  ["["
                   [(Tactic.simpLemma [] [] `map_add) "," (Tactic.simpLemma [] [] `map_sub)]
                   "]"]
                  [])]))))
            [(calcStep
              («term_=_»
               (Term.hole "_")
               "="
               («term_+_»
                («term_+_»
                 («term_-_»
                  («term-_»
                   "-"
                   (Term.app
                    `re
                    [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")]))
                  "-"
                  (Term.app
                   `re
                   [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")]))
                 "+"
                 (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")]))
                "+"
                (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")])))
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented [(Mathlib.Tactic.RingNF.ring "ring")]))))
             (calcStep
              («term_=_»
               (Term.hole "_")
               "="
               («term_+_»
                («term_+_»
                 («term_-_»
                  («term-_»
                   "-"
                   (Term.app
                    `re
                    [(Analysis.InnerProductSpace.Basic.«term_†»
                      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
                      "†")]))
                  "-"
                  (Term.app
                   `re
                   [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")]))
                 "+"
                 (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")]))
                "+"
                (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")])))
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.rwSeq
                   "rw"
                   []
                   (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_conj_sym)] "]")
                   [])]))))
             (calcStep
              («term_=_»
               (Term.hole "_")
               "="
               («term_+_»
                («term_+_»
                 («term_-_»
                  («term-_»
                   "-"
                   (Term.app
                    `re
                    [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")]))
                  "-"
                  (Term.app
                   `re
                   [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")]))
                 "+"
                 (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")]))
                "+"
                (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")])))
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.rwSeq
                   "rw"
                   []
                   (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `conj_re)] "]")
                   [])]))))
             (calcStep
              («term_=_»
               (Term.hole "_")
               "="
               («term_+_»
                («term_-_»
                 (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                 "-"
                 («term_*_»
                  (num "2")
                  "*"
                  (Term.app
                   `re
                   [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))
                "+"
                (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")])))
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented [(Mathlib.Tactic.RingNF.ring "ring")]))))])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Std.Tactic.tacticRepeat'_
           "repeat'"
           (Tactic.tacticSeq
            (Tactic.tacticSeq1Indented
             [(Tactic.rwSeq
               "rw"
               []
               (Tactic.rwRuleSeq
                "["
                [(Tactic.rwRule [] `sq)
                 ","
                 (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_self_eq_norm_mul_norm)]
                "]")
               [])])))
          []
          (Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_sub_sub_self)] "]")
           [])
          []
          (calcTactic
           "calc"
           (calcStep
            («term_=_»
             (Term.app
              `re
              [(«term_+_»
                («term_-_»
                 («term_-_»
                  (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
                  "-"
                  (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))
                 "-"
                 (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))
                "+"
                (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫"))])
             "="
             («term_+_»
              («term_-_»
               («term_-_»
                (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                "-"
                (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")]))
               "-"
               (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")]))
              "+"
              (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")])))
            ":="
            (Term.byTactic
             "by"
             (Tactic.tacticSeq
              (Tactic.tacticSeq1Indented
               [(Tactic.simp
                 "simp"
                 []
                 []
                 ["only"]
                 ["[" [(Tactic.simpLemma [] [] `map_add) "," (Tactic.simpLemma [] [] `map_sub)] "]"]
                 [])]))))
           [(calcStep
             («term_=_»
              (Term.hole "_")
              "="
              («term_+_»
               («term_+_»
                («term_-_»
                 («term-_»
                  "-"
                  (Term.app
                   `re
                   [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")]))
                 "-"
                 (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")]))
                "+"
                (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")]))
               "+"
               (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")])))
             ":="
             (Term.byTactic
              "by"
              (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(Mathlib.Tactic.RingNF.ring "ring")]))))
            (calcStep
             («term_=_»
              (Term.hole "_")
              "="
              («term_+_»
               («term_+_»
                («term_-_»
                 («term-_»
                  "-"
                  (Term.app
                   `re
                   [(Analysis.InnerProductSpace.Basic.«term_†»
                     (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
                     "†")]))
                 "-"
                 (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")]))
                "+"
                (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")]))
               "+"
               (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")])))
             ":="
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Tactic.rwSeq
                  "rw"
                  []
                  (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_conj_sym)] "]")
                  [])]))))
            (calcStep
             («term_=_»
              (Term.hole "_")
              "="
              («term_+_»
               («term_+_»
                («term_-_»
                 («term-_»
                  "-"
                  (Term.app
                   `re
                   [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")]))
                 "-"
                 (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")]))
                "+"
                (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")]))
               "+"
               (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")])))
             ":="
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Tactic.rwSeq
                  "rw"
                  []
                  (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `conj_re)] "]")
                  [])]))))
            (calcStep
             («term_=_»
              (Term.hole "_")
              "="
              («term_+_»
               («term_-_»
                (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                "-"
                («term_*_»
                 (num "2")
                 "*"
                 (Term.app
                  `re
                  [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))
               "+"
               (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")])))
             ":="
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented [(Mathlib.Tactic.RingNF.ring "ring")]))))])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (calcTactic
       "calc"
       (calcStep
        («term_=_»
         (Term.app
          `re
          [(«term_+_»
            («term_-_»
             («term_-_»
              (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
              "-"
              (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))
             "-"
             (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))
            "+"
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫"))])
         "="
         («term_+_»
          («term_-_»
           («term_-_»
            (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
            "-"
            (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")]))
           "-"
           (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")]))
          "+"
          (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")])))
        ":="
        (Term.byTactic
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(Tactic.simp
             "simp"
             []
             []
             ["only"]
             ["[" [(Tactic.simpLemma [] [] `map_add) "," (Tactic.simpLemma [] [] `map_sub)] "]"]
             [])]))))
       [(calcStep
         («term_=_»
          (Term.hole "_")
          "="
          («term_+_»
           («term_+_»
            («term_-_»
             («term-_»
              "-"
              (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")]))
             "-"
             (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")]))
            "+"
            (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")]))
           "+"
           (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")])))
         ":="
         (Term.byTactic
          "by"
          (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(Mathlib.Tactic.RingNF.ring "ring")]))))
        (calcStep
         («term_=_»
          (Term.hole "_")
          "="
          («term_+_»
           («term_+_»
            («term_-_»
             («term-_»
              "-"
              (Term.app
               `re
               [(Analysis.InnerProductSpace.Basic.«term_†»
                 (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
                 "†")]))
             "-"
             (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")]))
            "+"
            (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")]))
           "+"
           (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")])))
         ":="
         (Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(Tactic.rwSeq
              "rw"
              []
              (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_conj_sym)] "]")
              [])]))))
        (calcStep
         («term_=_»
          (Term.hole "_")
          "="
          («term_+_»
           («term_+_»
            («term_-_»
             («term-_»
              "-"
              (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")]))
             "-"
             (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")]))
            "+"
            (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")]))
           "+"
           (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")])))
         ":="
         (Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `conj_re)] "]") [])]))))
        (calcStep
         («term_=_»
          (Term.hole "_")
          "="
          («term_+_»
           («term_-_»
            (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
            "-"
            («term_*_»
             (num "2")
             "*"
             (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))
           "+"
           (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")])))
         ":="
         (Term.byTactic
          "by"
          (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(Mathlib.Tactic.RingNF.ring "ring")]))))])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(Mathlib.Tactic.RingNF.ring "ring")])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.RingNF.ring "ring")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_»
       (Term.hole "_")
       "="
       («term_+_»
        («term_-_»
         (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
         "-"
         («term_*_»
          (num "2")
          "*"
          (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))
        "+"
        (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")])))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_+_»
       («term_-_»
        (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
        "-"
        («term_*_»
         (num "2")
         "*"
         (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))
       "+"
       (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- Expand the square -/
  theorem
    norm_sub_sq
    { x y : E } : ‖ x - y ‖ ^ 2 = ‖ x ‖ ^ 2 - 2 * re ⟪ x , y ⟫ + ‖ y ‖ ^ 2
    :=
      by
        repeat' rw [ sq , ← inner_self_eq_norm_mul_norm ]
          rw [ inner_sub_sub_self ]
          calc
            re ⟪ x , x ⟫ - ⟪ x , y ⟫ - ⟪ y , x ⟫ + ⟪ y , y ⟫
                =
                re ⟪ x , x ⟫ - re ⟪ x , y ⟫ - re ⟪ y , x ⟫ + re ⟪ y , y ⟫
              :=
              by simp only [ map_add , map_sub ]
            _ = - re ⟪ y , x ⟫ - re ⟪ x , y ⟫ + re ⟪ x , x ⟫ + re ⟪ y , y ⟫ := by ring
              _ = - re ⟪ x , y ⟫ † - re ⟪ x , y ⟫ + re ⟪ x , x ⟫ + re ⟪ y , y ⟫
                :=
                by rw [ inner_conj_sym ]
              _ = - re ⟪ x , y ⟫ - re ⟪ x , y ⟫ + re ⟪ x , x ⟫ + re ⟪ y , y ⟫ := by rw [ conj_re ]
              _ = re ⟪ x , x ⟫ - 2 * re ⟪ x , y ⟫ + re ⟪ y , y ⟫ := by ring
#align norm_sub_sq norm_sub_sq

alias norm_sub_sq ← norm_sub_pow_two

/-- Expand the square -/
theorem norm_sub_sq_real {x y : F} : ‖x - y‖ ^ 2 = ‖x‖ ^ 2 - 2 * ⟪x, y⟫_ℝ + ‖y‖ ^ 2 :=
  norm_sub_sq
#align norm_sub_sq_real norm_sub_sq_real

alias norm_sub_sq_real ← norm_sub_pow_two_real

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [(Command.docComment "/--" "Expand the square -/")] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `norm_sub_mul_self [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         («term_*_»
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `x "-" `y) "‖")
          "*"
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `x "-" `y) "‖"))
         "="
         («term_+_»
          («term_-_»
           («term_*_»
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
            "*"
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
           "-"
           («term_*_»
            (num "2")
            "*"
            (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))
          "+"
          («term_*_»
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
           "*"
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Std.Tactic.tacticRepeat'_
            "repeat'"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.rwSeq
                "rw"
                []
                (Tactic.rwRuleSeq "[" [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `sq)] "]")
                [])])))
           []
           (Tactic.exact "exact" `norm_sub_sq)])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Std.Tactic.tacticRepeat'_
           "repeat'"
           (Tactic.tacticSeq
            (Tactic.tacticSeq1Indented
             [(Tactic.rwSeq
               "rw"
               []
               (Tactic.rwRuleSeq "[" [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `sq)] "]")
               [])])))
          []
          (Tactic.exact "exact" `norm_sub_sq)])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact "exact" `norm_sub_sq)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `norm_sub_sq
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Std.Tactic.tacticRepeat'_
       "repeat'"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq "[" [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `sq)] "]")
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq "[" [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `sq)] "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `sq
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `x "-" `y) "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `x "-" `y) "‖"))
       "="
       («term_+_»
        («term_-_»
         («term_*_»
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
          "*"
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
         "-"
         («term_*_»
          (num "2")
          "*"
          (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))
        "+"
        («term_*_»
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
         "*"
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_+_»
       («term_-_»
        («term_*_»
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
         "*"
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
        "-"
        («term_*_»
         (num "2")
         "*"
         (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))
       "+"
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
       "*"
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1024, (none, [anonymous]) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 66 >? 70, (some 71, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 65, term))
      («term_-_»
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
       "-"
       («term_*_»
        (num "2")
        "*"
        (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (num "2")
       "*"
       (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- Expand the square -/
  theorem
    norm_sub_mul_self
    { x y : E } : ‖ x - y ‖ * ‖ x - y ‖ = ‖ x ‖ * ‖ x ‖ - 2 * re ⟪ x , y ⟫ + ‖ y ‖ * ‖ y ‖
    := by repeat' rw [ ← sq ] exact norm_sub_sq
#align norm_sub_mul_self norm_sub_mul_self

/-- Expand the square -/
theorem norm_sub_mul_self_real {x y : F} :
    ‖x - y‖ * ‖x - y‖ = ‖x‖ * ‖x‖ - 2 * ⟪x, y⟫_ℝ + ‖y‖ * ‖y‖ :=
  by
  have h := @norm_sub_mul_self ℝ F _ _
  simpa using h
#align norm_sub_mul_self_real norm_sub_mul_self_real

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment "/--" "Cauchy–Schwarz inequality with norm -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `abs_inner_le_norm [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x `y] [":" `E] [] ")")]
       (Term.typeSpec
        ":"
        («term_≤_»
         (Term.app `abs [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
         "≤"
         («term_*_»
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
          "*"
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))))
      (Command.declValSimple
       ":="
       (Term.app
        `nonneg_le_nonneg_of_sq_le_sq
        [(Term.app
          `mul_nonneg
          [(Term.app `norm_nonneg [(Term.hole "_")]) (Term.app `norm_nonneg [(Term.hole "_")])])
         (Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(Mathlib.Tactic.tacticHave_
              "have"
              []
              [(Term.typeSpec
                ":"
                («term_=_»
                 («term_*_»
                  («term_*_»
                   (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                   "*"
                   (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
                  "*"
                  («term_*_»
                   (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                   "*"
                   (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
                 "="
                 («term_*_»
                  (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                  "*"
                  (Term.app
                   `re
                   [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")]))))])
             []
             (Tactic.simp
              "simp"
              []
              []
              ["only"]
              ["[" [(Tactic.simpLemma [] [] `inner_self_eq_norm_mul_norm)] "]"]
              [])
             ";"
             (Mathlib.Tactic.RingNF.ring "ring")
             []
             (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `this)] "]") [])
             []
             (Mathlib.Tactic.Conv.convLHS
              "conv_lhs"
              []
              []
              "=>"
              (Tactic.Conv.convSeq
               (Tactic.Conv.convSeq1Indented
                [(Tactic.Conv.congr "congr")
                 []
                 (Tactic.Conv.skip "skip")
                 []
                 (Tactic.Conv.convRw__
                  "rw"
                  []
                  (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_abs_conj_sym)] "]"))])))
             []
             (Tactic.exact
              "exact"
              (Term.app `inner_mul_inner_self_le [(Term.hole "_") (Term.hole "_")]))])))])
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `nonneg_le_nonneg_of_sq_le_sq
       [(Term.app
         `mul_nonneg
         [(Term.app `norm_nonneg [(Term.hole "_")]) (Term.app `norm_nonneg [(Term.hole "_")])])
        (Term.byTactic
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(Mathlib.Tactic.tacticHave_
             "have"
             []
             [(Term.typeSpec
               ":"
               («term_=_»
                («term_*_»
                 («term_*_»
                  (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                  "*"
                  (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
                 "*"
                 («term_*_»
                  (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                  "*"
                  (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
                "="
                («term_*_»
                 (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
                 "*"
                 (Term.app
                  `re
                  [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")]))))])
            []
            (Tactic.simp
             "simp"
             []
             []
             ["only"]
             ["[" [(Tactic.simpLemma [] [] `inner_self_eq_norm_mul_norm)] "]"]
             [])
            ";"
            (Mathlib.Tactic.RingNF.ring "ring")
            []
            (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `this)] "]") [])
            []
            (Mathlib.Tactic.Conv.convLHS
             "conv_lhs"
             []
             []
             "=>"
             (Tactic.Conv.convSeq
              (Tactic.Conv.convSeq1Indented
               [(Tactic.Conv.congr "congr")
                []
                (Tactic.Conv.skip "skip")
                []
                (Tactic.Conv.convRw__
                 "rw"
                 []
                 (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_abs_conj_sym)] "]"))])))
            []
            (Tactic.exact
             "exact"
             (Term.app `inner_mul_inner_self_le [(Term.hole "_") (Term.hole "_")]))])))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.byTactic', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.byTactic', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Mathlib.Tactic.tacticHave_
           "have"
           []
           [(Term.typeSpec
             ":"
             («term_=_»
              («term_*_»
               («term_*_»
                (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                "*"
                (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
               "*"
               («term_*_»
                (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                "*"
                (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
              "="
              («term_*_»
               (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
               "*"
               (Term.app
                `re
                [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")]))))])
          []
          (Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["[" [(Tactic.simpLemma [] [] `inner_self_eq_norm_mul_norm)] "]"]
           [])
          ";"
          (Mathlib.Tactic.RingNF.ring "ring")
          []
          (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `this)] "]") [])
          []
          (Mathlib.Tactic.Conv.convLHS
           "conv_lhs"
           []
           []
           "=>"
           (Tactic.Conv.convSeq
            (Tactic.Conv.convSeq1Indented
             [(Tactic.Conv.congr "congr")
              []
              (Tactic.Conv.skip "skip")
              []
              (Tactic.Conv.convRw__
               "rw"
               []
               (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_abs_conj_sym)] "]"))])))
          []
          (Tactic.exact
           "exact"
           (Term.app `inner_mul_inner_self_le [(Term.hole "_") (Term.hole "_")]))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact "exact" (Term.app `inner_mul_inner_self_le [(Term.hole "_") (Term.hole "_")]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `inner_mul_inner_self_le [(Term.hole "_") (Term.hole "_")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `inner_mul_inner_self_le
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.Conv.convLHS
       "conv_lhs"
       []
       []
       "=>"
       (Tactic.Conv.convSeq
        (Tactic.Conv.convSeq1Indented
         [(Tactic.Conv.congr "congr")
          []
          (Tactic.Conv.skip "skip")
          []
          (Tactic.Conv.convRw__
           "rw"
           []
           (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_abs_conj_sym)] "]"))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.Conv.convSeq1Indented', expected 'Lean.Parser.Tactic.Conv.convSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_abs_conj_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `this)] "]") [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `this
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.RingNF.ring "ring")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["[" [(Tactic.simpLemma [] [] `inner_self_eq_norm_mul_norm)] "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_self_eq_norm_mul_norm
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.tacticHave_
       "have"
       []
       [(Term.typeSpec
         ":"
         («term_=_»
          («term_*_»
           («term_*_»
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
            "*"
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
           "*"
           («term_*_»
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
            "*"
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
          "="
          («term_*_»
           (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
           "*"
           (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")]))))])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_»
       («term_*_»
        («term_*_»
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
         "*"
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
        "*"
        («term_*_»
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
         "*"
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
       "="
       («term_*_»
        (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
        "*"
        (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")])))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
       "*"
       (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- Cauchy–Schwarz inequality with norm -/
  theorem
    abs_inner_le_norm
    ( x y : E ) : abs ⟪ x , y ⟫ ≤ ‖ x ‖ * ‖ y ‖
    :=
      nonneg_le_nonneg_of_sq_le_sq
        mul_nonneg norm_nonneg _ norm_nonneg _
          by
            have : ‖ x ‖ * ‖ y ‖ * ‖ x ‖ * ‖ y ‖ = re ⟪ x , x ⟫ * re ⟪ y , y ⟫
              simp only [ inner_self_eq_norm_mul_norm ]
              ;
              ring
              rw [ this ]
              conv_lhs => congr skip rw [ inner_abs_conj_sym ]
              exact inner_mul_inner_self_le _ _
#align abs_inner_le_norm abs_inner_le_norm

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `norm_inner_le_norm [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x `y] [":" `E] [] ")")]
       (Term.typeSpec
        ":"
        («term_≤_»
         (Analysis.Normed.Group.Basic.«term‖_‖»
          "‖"
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
          "‖")
         "≤"
         («term_*_»
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
          "*"
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))))
      (Command.declValSimple
       ":="
       (Term.app
        (Term.proj (Term.proj (Term.app `IsROrC.norm_eq_abs [(Term.hole "_")]) "." `le) "." `trans)
        [(Term.app `abs_inner_le_norm [`x `y])])
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       (Term.proj (Term.proj (Term.app `IsROrC.norm_eq_abs [(Term.hole "_")]) "." `le) "." `trans)
       [(Term.app `abs_inner_le_norm [`x `y])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `abs_inner_le_norm [`x `y])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `abs_inner_le_norm
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app `abs_inner_le_norm [`x `y])
     ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.proj (Term.proj (Term.app `IsROrC.norm_eq_abs [(Term.hole "_")]) "." `le) "." `trans)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.proj (Term.app `IsROrC.norm_eq_abs [(Term.hole "_")]) "." `le)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.app `IsROrC.norm_eq_abs [(Term.hole "_")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `IsROrC.norm_eq_abs
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app `IsROrC.norm_eq_abs [(Term.hole "_")])
     ")")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_≤_»
       (Analysis.Normed.Group.Basic.«term‖_‖»
        "‖"
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
        "‖")
       "≤"
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
       "*"
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1024, (none, [anonymous]) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 70, (some 71, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.Normed.Group.Basic.«term‖_‖»
       "‖"
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
       "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  norm_inner_le_norm
  ( x y : E ) : ‖ ⟪ x , y ⟫ ‖ ≤ ‖ x ‖ * ‖ y ‖
  := IsROrC.norm_eq_abs _ . le . trans abs_inner_le_norm x y
#align norm_inner_le_norm norm_inner_le_norm

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `nnnorm_inner_le_nnnorm [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x `y] [":" `E] [] ")")]
       (Term.typeSpec
        ":"
        («term_≤_»
         (Analysis.Normed.Group.Basic.«term‖_‖₊»
          "‖"
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
          "‖₊")
         "≤"
         («term_*_»
          (Analysis.Normed.Group.Basic.«term‖_‖₊» "‖" `x "‖₊")
          "*"
          (Analysis.Normed.Group.Basic.«term‖_‖₊» "‖" `y "‖₊")))))
      (Command.declValSimple ":=" (Term.app `norm_inner_le_norm [`x `y]) [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `norm_inner_le_norm [`x `y])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `norm_inner_le_norm
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_≤_»
       (Analysis.Normed.Group.Basic.«term‖_‖₊»
        "‖"
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
        "‖₊")
       "≤"
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖₊» "‖" `x "‖₊")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖₊» "‖" `y "‖₊")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (Analysis.Normed.Group.Basic.«term‖_‖₊» "‖" `x "‖₊")
       "*"
       (Analysis.Normed.Group.Basic.«term‖_‖₊» "‖" `y "‖₊"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖₊» "‖" `y "‖₊")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Analysis.Normed.Group.Basic.«term‖_‖₊» "‖" `x "‖₊")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1024, (none, [anonymous]) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 70, (some 71, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.Normed.Group.Basic.«term‖_‖₊»
       "‖"
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
       "‖₊")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  nnnorm_inner_le_nnnorm
  ( x y : E ) : ‖ ⟪ x , y ⟫ ‖₊ ≤ ‖ x ‖₊ * ‖ y ‖₊
  := norm_inner_le_norm x y
#align nnnorm_inner_le_nnnorm nnnorm_inner_le_nnnorm

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `re_inner_le_norm [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x `y] [":" `E] [] ")")]
       (Term.typeSpec
        ":"
        («term_≤_»
         (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
         "≤"
         («term_*_»
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
          "*"
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))))
      (Command.declValSimple
       ":="
       (Term.app
        `le_trans
        [(Term.app `re_le_abs [(Term.app `inner [`x `y])]) (Term.app `abs_inner_le_norm [`x `y])])
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `le_trans
       [(Term.app `re_le_abs [(Term.app `inner [`x `y])]) (Term.app `abs_inner_le_norm [`x `y])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `abs_inner_le_norm [`x `y])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `abs_inner_le_norm
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app `abs_inner_le_norm [`x `y])
     ")")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.app `re_le_abs [(Term.app `inner [`x `y])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `inner [`x `y])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `inner
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `inner [`x `y]) ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `re_le_abs
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app `re_le_abs [(Term.paren "(" (Term.app `inner [`x `y]) ")")])
     ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `le_trans
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_≤_»
       (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
       "≤"
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
       "*"
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1024, (none, [anonymous]) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 70, (some 71, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  re_inner_le_norm
  ( x y : E ) : re ⟪ x , y ⟫ ≤ ‖ x ‖ * ‖ y ‖
  := le_trans re_le_abs inner x y abs_inner_le_norm x y
#align re_inner_le_norm re_inner_le_norm

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment "/--" "Cauchy–Schwarz inequality with norm -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `abs_real_inner_le_norm [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x `y] [":" `F] [] ")")]
       (Term.typeSpec
        ":"
        («term_≤_»
         (Term.app
          (Analysis.InnerProductSpace.Basic.termabsR "absR")
          [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫_ℝ» "⟪" `x ", " `y "⟫_ℝ")])
         "≤"
         («term_*_»
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
          "*"
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.tacticHave_
            "have"
            (Term.haveDecl
             (Term.haveIdDecl
              [`h []]
              []
              ":="
              (Term.app
               (Term.explicit "@" `abs_inner_le_norm)
               [(Data.Real.Basic.termℝ "ℝ") `F (Term.hole "_") (Term.hole "_") `x `y]))))
           []
           (Std.Tactic.Simpa.simpa
            "simpa"
            []
            []
            (Std.Tactic.Simpa.simpaArgsRest [] [] [] [] ["using" `h]))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.tacticHave_
           "have"
           (Term.haveDecl
            (Term.haveIdDecl
             [`h []]
             []
             ":="
             (Term.app
              (Term.explicit "@" `abs_inner_le_norm)
              [(Data.Real.Basic.termℝ "ℝ") `F (Term.hole "_") (Term.hole "_") `x `y]))))
          []
          (Std.Tactic.Simpa.simpa
           "simpa"
           []
           []
           (Std.Tactic.Simpa.simpaArgsRest [] [] [] [] ["using" `h]))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Std.Tactic.Simpa.simpa
       "simpa"
       []
       []
       (Std.Tactic.Simpa.simpaArgsRest [] [] [] [] ["using" `h]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.tacticHave_
       "have"
       (Term.haveDecl
        (Term.haveIdDecl
         [`h []]
         []
         ":="
         (Term.app
          (Term.explicit "@" `abs_inner_le_norm)
          [(Data.Real.Basic.termℝ "ℝ") `F (Term.hole "_") (Term.hole "_") `x `y]))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       (Term.explicit "@" `abs_inner_le_norm)
       [(Data.Real.Basic.termℝ "ℝ") `F (Term.hole "_") (Term.hole "_") `x `y])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      `F
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Data.Real.Basic.termℝ', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Data.Real.Basic.termℝ', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Data.Real.Basic.termℝ "ℝ")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.explicit "@" `abs_inner_le_norm)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `abs_inner_le_norm
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (some 1024,
     term) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_≤_»
       (Term.app
        (Analysis.InnerProductSpace.Basic.termabsR "absR")
        [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫_ℝ» "⟪" `x ", " `y "⟫_ℝ")])
       "≤"
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
       "*"
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1024, (none, [anonymous]) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 70, (some 71, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Term.app
       (Analysis.InnerProductSpace.Basic.termabsR "absR")
       [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫_ℝ» "⟪" `x ", " `y "⟫_ℝ")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫_ℝ»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫_ℝ»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫_ℝ» "⟪" `x ", " `y "⟫_ℝ")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Analysis.InnerProductSpace.Basic.termabsR "absR")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.termabsR', expected 'Analysis.InnerProductSpace.Basic.termabsR._@.Analysis.InnerProductSpace.Basic._hyg.1003'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- Cauchy–Schwarz inequality with norm -/
  theorem
    abs_real_inner_le_norm
    ( x y : F ) : absR ⟪ x , y ⟫_ℝ ≤ ‖ x ‖ * ‖ y ‖
    := by have h := @ abs_inner_le_norm ℝ F _ _ x y simpa using h
#align abs_real_inner_le_norm abs_real_inner_le_norm

/-- Cauchy–Schwarz inequality with norm -/
theorem real_inner_le_norm (x y : F) : ⟪x, y⟫_ℝ ≤ ‖x‖ * ‖y‖ :=
  le_trans (le_abs_self _) (abs_real_inner_le_norm _ _)
#align real_inner_le_norm real_inner_le_norm

include 𝕜

theorem parallelogram_law_with_norm (x y : E) :
    ‖x + y‖ * ‖x + y‖ + ‖x - y‖ * ‖x - y‖ = 2 * (‖x‖ * ‖x‖ + ‖y‖ * ‖y‖) :=
  by
  simp only [← inner_self_eq_norm_mul_norm]
  rw [← re.map_add, parallelogram_law, two_mul, two_mul]
  simp only [re.map_add]
#align parallelogram_law_with_norm parallelogram_law_with_norm

theorem parallelogram_law_with_nnnorm (x y : E) :
    ‖x + y‖₊ * ‖x + y‖₊ + ‖x - y‖₊ * ‖x - y‖₊ = 2 * (‖x‖₊ * ‖x‖₊ + ‖y‖₊ * ‖y‖₊) :=
  Subtype.ext <| parallelogram_law_with_norm x y
#align parallelogram_law_with_nnnorm parallelogram_law_with_nnnorm

omit 𝕜

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "Polarization identity: The real part of the  inner product, in terms of the norm. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `re_inner_eq_norm_add_mul_self_sub_norm_mul_self_sub_norm_mul_self_div_two [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x `y] [":" `E] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
         "="
         («term_/_»
          («term_-_»
           («term_-_»
            («term_*_»
             (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖")
             "*"
             (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖"))
            "-"
            («term_*_»
             (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
             "*"
             (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")))
           "-"
           («term_*_»
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
            "*"
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
          "/"
          (num "2")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `norm_add_mul_self)] "]")
            [])
           []
           (Mathlib.Tactic.RingNF.ring "ring")])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `norm_add_mul_self)] "]")
           [])
          []
          (Mathlib.Tactic.RingNF.ring "ring")])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.RingNF.ring "ring")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `norm_add_mul_self)] "]") [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `norm_add_mul_self
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
       "="
       («term_/_»
        («term_-_»
         («term_-_»
          («term_*_»
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖")
           "*"
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖"))
          "-"
          («term_*_»
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
           "*"
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")))
         "-"
         («term_*_»
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
          "*"
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
        "/"
        (num "2")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_/_»
       («term_-_»
        («term_-_»
         («term_*_»
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖")
          "*"
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖"))
         "-"
         («term_*_»
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
          "*"
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")))
        "-"
        («term_*_»
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
         "*"
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
       "/"
       (num "2"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "2")
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      («term_-_»
       («term_-_»
        («term_*_»
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖")
         "*"
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖"))
        "-"
        («term_*_»
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
         "*"
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")))
       "-"
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
       "*"
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1024, (none, [anonymous]) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 66 >? 70, (some 71, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 65, term))
      («term_-_»
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖"))
       "-"
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
       "*"
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1024, (none, [anonymous]) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 66 >? 70, (some 71, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 65, term))
      («term_*_»
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖")
       "*"
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_+_» `x "+" `y)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 66 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 65, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 65 >? 1024, (none, [anonymous]) <=? (some 65, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 65, (some 66, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_+_» `x "+" `y)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 66 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 65, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 65 >? 1024, (none, [anonymous]) <=? (some 65, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 65, (some 66, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1024, (none, [anonymous]) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 65 >? 70, (some 71, term) <=? (some 65, term)
[PrettyPrinter.parenthesize] ...precedences are 65 >? 65, (some 66, term) <=? (some 65, term)
[PrettyPrinter.parenthesize] ...precedences are 70 >? 65, (some 66, term) <=? (some 70, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     («term_-_»
      («term_-_»
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖"))
       "-"
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")))
      "-"
      («term_*_»
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
       "*"
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
     ")")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 70, (some 71, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- Polarization identity: The real part of the  inner product, in terms of the norm. -/
  theorem
    re_inner_eq_norm_add_mul_self_sub_norm_mul_self_sub_norm_mul_self_div_two
    ( x y : E ) : re ⟪ x , y ⟫ = ‖ x + y ‖ * ‖ x + y ‖ - ‖ x ‖ * ‖ x ‖ - ‖ y ‖ * ‖ y ‖ / 2
    := by rw [ norm_add_mul_self ] ring
#align
  re_inner_eq_norm_add_mul_self_sub_norm_mul_self_sub_norm_mul_self_div_two re_inner_eq_norm_add_mul_self_sub_norm_mul_self_sub_norm_mul_self_div_two

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "Polarization identity: The real part of the  inner product, in terms of the norm. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `re_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x `y] [":" `E] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
         "="
         («term_/_»
          («term_-_»
           («term_+_»
            («term_*_»
             (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
             "*"
             (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
            "+"
            («term_*_»
             (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
             "*"
             (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
           "-"
           («term_*_»
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `x "-" `y) "‖")
            "*"
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `x "-" `y) "‖")))
          "/"
          (num "2")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `norm_sub_mul_self)] "]")
            [])
           []
           (Mathlib.Tactic.RingNF.ring "ring")])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `norm_sub_mul_self)] "]")
           [])
          []
          (Mathlib.Tactic.RingNF.ring "ring")])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.RingNF.ring "ring")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `norm_sub_mul_self)] "]") [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `norm_sub_mul_self
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
       "="
       («term_/_»
        («term_-_»
         («term_+_»
          («term_*_»
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
           "*"
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
          "+"
          («term_*_»
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
           "*"
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
         "-"
         («term_*_»
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `x "-" `y) "‖")
          "*"
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `x "-" `y) "‖")))
        "/"
        (num "2")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_/_»
       («term_-_»
        («term_+_»
         («term_*_»
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
          "*"
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
         "+"
         («term_*_»
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
          "*"
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
        "-"
        («term_*_»
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `x "-" `y) "‖")
         "*"
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `x "-" `y) "‖")))
       "/"
       (num "2"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "2")
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      («term_-_»
       («term_+_»
        («term_*_»
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
         "*"
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
        "+"
        («term_*_»
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
         "*"
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
       "-"
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `x "-" `y) "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `x "-" `y) "‖")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `x "-" `y) "‖")
       "*"
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `x "-" `y) "‖"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `x "-" `y) "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_-_» `x "-" `y)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 66 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 65, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 65 >? 1024, (none, [anonymous]) <=? (some 65, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 65, (some 66, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `x "-" `y) "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_-_» `x "-" `y)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 66 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 65, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 65 >? 1024, (none, [anonymous]) <=? (some 65, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 65, (some 66, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1024, (none, [anonymous]) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 66 >? 70, (some 71, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 65, term))
      («term_+_»
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
       "+"
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
       "*"
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1024, (none, [anonymous]) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 66 >? 70, (some 71, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 65, term))
      («term_*_»
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
       "*"
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1024, (none, [anonymous]) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 65 >? 70, (some 71, term) <=? (some 65, term)
[PrettyPrinter.parenthesize] ...precedences are 65 >? 65, (some 66, term) <=? (some 65, term)
[PrettyPrinter.parenthesize] ...precedences are 70 >? 65, (some 66, term) <=? (some 70, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     («term_-_»
      («term_+_»
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
       "+"
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
      "-"
      («term_*_»
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `x "-" `y) "‖")
       "*"
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `x "-" `y) "‖")))
     ")")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 70, (some 71, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- Polarization identity: The real part of the  inner product, in terms of the norm. -/
  theorem
    re_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two
    ( x y : E ) : re ⟪ x , y ⟫ = ‖ x ‖ * ‖ x ‖ + ‖ y ‖ * ‖ y ‖ - ‖ x - y ‖ * ‖ x - y ‖ / 2
    := by rw [ norm_sub_mul_self ] ring
#align
  re_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two re_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "Polarization identity: The real part of the  inner product, in terms of the norm. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `re_inner_eq_norm_add_mul_self_sub_norm_sub_mul_self_div_four [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x `y] [":" `E] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
         "="
         («term_/_»
          («term_-_»
           («term_*_»
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖")
            "*"
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖"))
           "-"
           («term_*_»
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `x "-" `y) "‖")
            "*"
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `x "-" `y) "‖")))
          "/"
          (num "4")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [] `norm_add_mul_self) "," (Tactic.rwRule [] `norm_sub_mul_self)]
             "]")
            [])
           []
           (Mathlib.Tactic.RingNF.ring "ring")])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] `norm_add_mul_self) "," (Tactic.rwRule [] `norm_sub_mul_self)]
            "]")
           [])
          []
          (Mathlib.Tactic.RingNF.ring "ring")])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.RingNF.ring "ring")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [] `norm_add_mul_self) "," (Tactic.rwRule [] `norm_sub_mul_self)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `norm_sub_mul_self
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `norm_add_mul_self
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
       "="
       («term_/_»
        («term_-_»
         («term_*_»
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖")
          "*"
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖"))
         "-"
         («term_*_»
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `x "-" `y) "‖")
          "*"
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `x "-" `y) "‖")))
        "/"
        (num "4")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_/_»
       («term_-_»
        («term_*_»
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖")
         "*"
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖"))
        "-"
        («term_*_»
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `x "-" `y) "‖")
         "*"
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `x "-" `y) "‖")))
       "/"
       (num "4"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "4")
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      («term_-_»
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖"))
       "-"
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `x "-" `y) "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `x "-" `y) "‖")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `x "-" `y) "‖")
       "*"
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `x "-" `y) "‖"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `x "-" `y) "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_-_» `x "-" `y)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 66 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 65, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 65 >? 1024, (none, [anonymous]) <=? (some 65, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 65, (some 66, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `x "-" `y) "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_-_» `x "-" `y)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 66 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 65, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 65 >? 1024, (none, [anonymous]) <=? (some 65, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 65, (some 66, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1024, (none, [anonymous]) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 66 >? 70, (some 71, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 65, term))
      («term_*_»
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖")
       "*"
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_+_» `x "+" `y)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 66 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 65, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 65 >? 1024, (none, [anonymous]) <=? (some 65, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 65, (some 66, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_+_» `x "+" `y)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 66 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 65, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 65 >? 1024, (none, [anonymous]) <=? (some 65, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 65, (some 66, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1024, (none, [anonymous]) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 65 >? 70, (some 71, term) <=? (some 65, term)
[PrettyPrinter.parenthesize] ...precedences are 70 >? 65, (some 66, term) <=? (some 70, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     («term_-_»
      («term_*_»
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖")
       "*"
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖"))
      "-"
      («term_*_»
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `x "-" `y) "‖")
       "*"
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `x "-" `y) "‖")))
     ")")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 70, (some 71, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- Polarization identity: The real part of the  inner product, in terms of the norm. -/
  theorem
    re_inner_eq_norm_add_mul_self_sub_norm_sub_mul_self_div_four
    ( x y : E ) : re ⟪ x , y ⟫ = ‖ x + y ‖ * ‖ x + y ‖ - ‖ x - y ‖ * ‖ x - y ‖ / 4
    := by rw [ norm_add_mul_self , norm_sub_mul_self ] ring
#align
  re_inner_eq_norm_add_mul_self_sub_norm_sub_mul_self_div_four re_inner_eq_norm_add_mul_self_sub_norm_sub_mul_self_div_four

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "Polarization identity: The imaginary part of the inner product, in terms of the norm. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId
       `im_inner_eq_norm_sub_I_smul_mul_self_sub_norm_add_I_smul_mul_self_div_four
       [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x `y] [":" `E] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.app `im [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
         "="
         («term_/_»
          («term_-_»
           («term_*_»
            (Analysis.Normed.Group.Basic.«term‖_‖»
             "‖"
             («term_-_»
              `x
              "-"
              (Algebra.Group.Defs.«term_•_»
               (Analysis.InnerProductSpace.Basic.termIK "IK")
               " • "
               `y))
             "‖")
            "*"
            (Analysis.Normed.Group.Basic.«term‖_‖»
             "‖"
             («term_-_»
              `x
              "-"
              (Algebra.Group.Defs.«term_•_»
               (Analysis.InnerProductSpace.Basic.termIK "IK")
               " • "
               `y))
             "‖"))
           "-"
           («term_*_»
            (Analysis.Normed.Group.Basic.«term‖_‖»
             "‖"
             («term_+_»
              `x
              "+"
              (Algebra.Group.Defs.«term_•_»
               (Analysis.InnerProductSpace.Basic.termIK "IK")
               " • "
               `y))
             "‖")
            "*"
            (Analysis.Normed.Group.Basic.«term‖_‖»
             "‖"
             («term_+_»
              `x
              "+"
              (Algebra.Group.Defs.«term_•_»
               (Analysis.InnerProductSpace.Basic.termIK "IK")
               " • "
               `y))
             "‖")))
          "/"
          (num "4")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.simp
            "simp"
            []
            []
            ["only"]
            ["["
             [(Tactic.simpLemma [] [] `norm_add_mul_self)
              ","
              (Tactic.simpLemma [] [] `norm_sub_mul_self)
              ","
              (Tactic.simpLemma [] [] `inner_smul_right)
              ","
              (Tactic.simpLemma [] [] `I_mul_re)]
             "]"]
            [])
           []
           (Mathlib.Tactic.RingNF.ring "ring")])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["["
            [(Tactic.simpLemma [] [] `norm_add_mul_self)
             ","
             (Tactic.simpLemma [] [] `norm_sub_mul_self)
             ","
             (Tactic.simpLemma [] [] `inner_smul_right)
             ","
             (Tactic.simpLemma [] [] `I_mul_re)]
            "]"]
           [])
          []
          (Mathlib.Tactic.RingNF.ring "ring")])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.RingNF.ring "ring")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] `norm_add_mul_self)
         ","
         (Tactic.simpLemma [] [] `norm_sub_mul_self)
         ","
         (Tactic.simpLemma [] [] `inner_smul_right)
         ","
         (Tactic.simpLemma [] [] `I_mul_re)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `I_mul_re
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_smul_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `norm_sub_mul_self
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `norm_add_mul_self
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Term.app `im [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
       "="
       («term_/_»
        («term_-_»
         («term_*_»
          (Analysis.Normed.Group.Basic.«term‖_‖»
           "‖"
           («term_-_»
            `x
            "-"
            (Algebra.Group.Defs.«term_•_» (Analysis.InnerProductSpace.Basic.termIK "IK") " • " `y))
           "‖")
          "*"
          (Analysis.Normed.Group.Basic.«term‖_‖»
           "‖"
           («term_-_»
            `x
            "-"
            (Algebra.Group.Defs.«term_•_» (Analysis.InnerProductSpace.Basic.termIK "IK") " • " `y))
           "‖"))
         "-"
         («term_*_»
          (Analysis.Normed.Group.Basic.«term‖_‖»
           "‖"
           («term_+_»
            `x
            "+"
            (Algebra.Group.Defs.«term_•_» (Analysis.InnerProductSpace.Basic.termIK "IK") " • " `y))
           "‖")
          "*"
          (Analysis.Normed.Group.Basic.«term‖_‖»
           "‖"
           («term_+_»
            `x
            "+"
            (Algebra.Group.Defs.«term_•_» (Analysis.InnerProductSpace.Basic.termIK "IK") " • " `y))
           "‖")))
        "/"
        (num "4")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_/_»
       («term_-_»
        («term_*_»
         (Analysis.Normed.Group.Basic.«term‖_‖»
          "‖"
          («term_-_»
           `x
           "-"
           (Algebra.Group.Defs.«term_•_» (Analysis.InnerProductSpace.Basic.termIK "IK") " • " `y))
          "‖")
         "*"
         (Analysis.Normed.Group.Basic.«term‖_‖»
          "‖"
          («term_-_»
           `x
           "-"
           (Algebra.Group.Defs.«term_•_» (Analysis.InnerProductSpace.Basic.termIK "IK") " • " `y))
          "‖"))
        "-"
        («term_*_»
         (Analysis.Normed.Group.Basic.«term‖_‖»
          "‖"
          («term_+_»
           `x
           "+"
           (Algebra.Group.Defs.«term_•_» (Analysis.InnerProductSpace.Basic.termIK "IK") " • " `y))
          "‖")
         "*"
         (Analysis.Normed.Group.Basic.«term‖_‖»
          "‖"
          («term_+_»
           `x
           "+"
           (Algebra.Group.Defs.«term_•_» (Analysis.InnerProductSpace.Basic.termIK "IK") " • " `y))
          "‖")))
       "/"
       (num "4"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "4")
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      («term_-_»
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖»
         "‖"
         («term_-_»
          `x
          "-"
          (Algebra.Group.Defs.«term_•_» (Analysis.InnerProductSpace.Basic.termIK "IK") " • " `y))
         "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖»
         "‖"
         («term_-_»
          `x
          "-"
          (Algebra.Group.Defs.«term_•_» (Analysis.InnerProductSpace.Basic.termIK "IK") " • " `y))
         "‖"))
       "-"
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖»
         "‖"
         («term_+_»
          `x
          "+"
          (Algebra.Group.Defs.«term_•_» (Analysis.InnerProductSpace.Basic.termIK "IK") " • " `y))
         "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖»
         "‖"
         («term_+_»
          `x
          "+"
          (Algebra.Group.Defs.«term_•_» (Analysis.InnerProductSpace.Basic.termIK "IK") " • " `y))
         "‖")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (Analysis.Normed.Group.Basic.«term‖_‖»
        "‖"
        («term_+_»
         `x
         "+"
         (Algebra.Group.Defs.«term_•_» (Analysis.InnerProductSpace.Basic.termIK "IK") " • " `y))
        "‖")
       "*"
       (Analysis.Normed.Group.Basic.«term‖_‖»
        "‖"
        («term_+_»
         `x
         "+"
         (Algebra.Group.Defs.«term_•_» (Analysis.InnerProductSpace.Basic.termIK "IK") " • " `y))
        "‖"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖»
       "‖"
       («term_+_»
        `x
        "+"
        (Algebra.Group.Defs.«term_•_» (Analysis.InnerProductSpace.Basic.termIK "IK") " • " `y))
       "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_+_»
       `x
       "+"
       (Algebra.Group.Defs.«term_•_» (Analysis.InnerProductSpace.Basic.termIK "IK") " • " `y))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Algebra.Group.Defs.«term_•_» (Analysis.InnerProductSpace.Basic.termIK "IK") " • " `y)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 73 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 73, term))
      (Analysis.InnerProductSpace.Basic.termIK "IK")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.termIK', expected 'Analysis.InnerProductSpace.Basic.termIK._@.Analysis.InnerProductSpace.Basic._hyg.966'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- Polarization identity: The imaginary part of the inner product, in terms of the norm. -/
  theorem
    im_inner_eq_norm_sub_I_smul_mul_self_sub_norm_add_I_smul_mul_self_div_four
    ( x y : E )
      : im ⟪ x , y ⟫ = ‖ x - IK • y ‖ * ‖ x - IK • y ‖ - ‖ x + IK • y ‖ * ‖ x + IK • y ‖ / 4
    := by simp only [ norm_add_mul_self , norm_sub_mul_self , inner_smul_right , I_mul_re ] ring
#align
  im_inner_eq_norm_sub_I_smul_mul_self_sub_norm_add_I_smul_mul_self_div_four im_inner_eq_norm_sub_I_smul_mul_self_sub_norm_add_I_smul_mul_self_div_four

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "Polarization identity: The inner product, in terms of the norm. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_eq_sum_norm_sq_div_four [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x `y] [":" `E] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
         "="
         («term_/_»
          («term_+_»
           («term_-_»
            («term_^_»
             (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖")
             "^"
             (num "2"))
            "-"
            («term_^_»
             (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `x "-" `y) "‖")
             "^"
             (num "2")))
           "+"
           («term_*_»
            («term_-_»
             («term_^_»
              (Analysis.Normed.Group.Basic.«term‖_‖»
               "‖"
               («term_-_»
                `x
                "-"
                (Algebra.Group.Defs.«term_•_»
                 (Analysis.InnerProductSpace.Basic.termIK "IK")
                 " • "
                 `y))
               "‖")
              "^"
              (num "2"))
             "-"
             («term_^_»
              (Analysis.Normed.Group.Basic.«term‖_‖»
               "‖"
               («term_+_»
                `x
                "+"
                (Algebra.Group.Defs.«term_•_»
                 (Analysis.InnerProductSpace.Basic.termIK "IK")
                 " • "
                 `y))
               "‖")
              "^"
              (num "2")))
            "*"
            (Analysis.InnerProductSpace.Basic.termIK "IK")))
          "/"
          (num "4")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule
               [(patternIgnore (token.«← » "←"))]
               (Term.app
                `re_add_im
                [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")]))
              ","
              (Tactic.rwRule [] `re_inner_eq_norm_add_mul_self_sub_norm_sub_mul_self_div_four)
              ","
              (Tactic.rwRule
               []
               `im_inner_eq_norm_sub_I_smul_mul_self_sub_norm_add_I_smul_mul_self_div_four)]
             "]")
            [])
           []
           (Tactic.NormCast.pushCast "push_cast" [] [] [] [] [])
           []
           (Tactic.simp
            "simp"
            []
            []
            ["only"]
            ["["
             [(Tactic.simpLemma [] [] `sq)
              ","
              (Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `mul_div_right_comm)
              ","
              (Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `add_div)]
             "]"]
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule
              [(patternIgnore (token.«← » "←"))]
              (Term.app
               `re_add_im
               [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")]))
             ","
             (Tactic.rwRule [] `re_inner_eq_norm_add_mul_self_sub_norm_sub_mul_self_div_four)
             ","
             (Tactic.rwRule
              []
              `im_inner_eq_norm_sub_I_smul_mul_self_sub_norm_add_I_smul_mul_self_div_four)]
            "]")
           [])
          []
          (Tactic.NormCast.pushCast "push_cast" [] [] [] [] [])
          []
          (Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["["
            [(Tactic.simpLemma [] [] `sq)
             ","
             (Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `mul_div_right_comm)
             ","
             (Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `add_div)]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] `sq)
         ","
         (Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `mul_div_right_comm)
         ","
         (Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `add_div)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `add_div
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `mul_div_right_comm
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `sq
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.NormCast.pushCast "push_cast" [] [] [] [] [])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule
          [(patternIgnore (token.«← » "←"))]
          (Term.app `re_add_im [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")]))
         ","
         (Tactic.rwRule [] `re_inner_eq_norm_add_mul_self_sub_norm_sub_mul_self_div_four)
         ","
         (Tactic.rwRule
          []
          `im_inner_eq_norm_sub_I_smul_mul_self_sub_norm_add_I_smul_mul_self_div_four)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `im_inner_eq_norm_sub_I_smul_mul_self_sub_norm_add_I_smul_mul_self_div_four
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `re_inner_eq_norm_add_mul_self_sub_norm_sub_mul_self_div_four
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `re_add_im [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- Polarization identity: The inner product, in terms of the norm. -/
  theorem
    inner_eq_sum_norm_sq_div_four
    ( x y : E )
      : ⟪ x , y ⟫ = ‖ x + y ‖ ^ 2 - ‖ x - y ‖ ^ 2 + ‖ x - IK • y ‖ ^ 2 - ‖ x + IK • y ‖ ^ 2 * IK / 4
    :=
      by
        rw
            [
              ← re_add_im ⟪ x , y ⟫
                ,
                re_inner_eq_norm_add_mul_self_sub_norm_sub_mul_self_div_four
                ,
                im_inner_eq_norm_sub_I_smul_mul_self_sub_norm_add_I_smul_mul_self_div_four
              ]
          push_cast
          simp only [ sq , ← mul_div_right_comm , ← add_div ]
#align inner_eq_sum_norm_sq_div_four inner_eq_sum_norm_sq_div_four

/-- Formula for the distance between the images of two nonzero points under an inversion with center
zero. See also `euclidean_geometry.dist_inversion_inversion` for inversions around a general
point. -/
theorem dist_div_norm_sq_smul {x y : F} (hx : x ≠ 0) (hy : y ≠ 0) (R : ℝ) :
    dist ((R / ‖x‖) ^ 2 • x) ((R / ‖y‖) ^ 2 • y) = R ^ 2 / (‖x‖ * ‖y‖) * dist x y :=
  have hx' : ‖x‖ ≠ 0 := norm_ne_zero_iff.2 hx
  have hy' : ‖y‖ ≠ 0 := norm_ne_zero_iff.2 hy
  calc
    dist ((R / ‖x‖) ^ 2 • x) ((R / ‖y‖) ^ 2 • y) =
        sqrt (‖(R / ‖x‖) ^ 2 • x - (R / ‖y‖) ^ 2 • y‖ ^ 2) :=
      by rw [dist_eq_norm, sqrt_sq (norm_nonneg _)]
    _ = sqrt ((R ^ 2 / (‖x‖ * ‖y‖)) ^ 2 * ‖x - y‖ ^ 2) :=
      congr_arg sqrt <|
        by
        field_simp [sq, norm_sub_mul_self_real, norm_smul, real_inner_smul_left, inner_smul_right,
          Real.norm_of_nonneg (mul_self_nonneg _)]
        ring
    _ = R ^ 2 / (‖x‖ * ‖y‖) * dist x y := by
      rw [sqrt_mul (sq_nonneg _), sqrt_sq (norm_nonneg _),
        sqrt_sq (div_nonneg (sq_nonneg _) (mul_nonneg (norm_nonneg _) (norm_nonneg _))),
        dist_eq_norm]
    
#align dist_div_norm_sq_smul dist_div_norm_sq_smul

-- See note [lower instance priority]
instance (priority := 100) InnerProductSpace.to_uniform_convex_space : UniformConvexSpace F :=
  ⟨fun ε hε =>
    by
    refine'
      ⟨2 - sqrt (4 - ε ^ 2), sub_pos_of_lt <| (sqrt_lt' zero_lt_two).2 _, fun x hx y hy hxy => _⟩
    · norm_num
      exact pow_pos hε _
    rw [sub_sub_cancel]
    refine' le_sqrt_of_sq_le _
    rw [sq, eq_sub_iff_add_eq.2 (parallelogram_law_with_norm x y), ← sq ‖x - y‖, hx, hy]
    norm_num
    exact pow_le_pow_of_le_left hε.le hxy _⟩
#align inner_product_space.to_uniform_convex_space InnerProductSpace.to_uniform_convex_space

section Complex

variable {V : Type _} [InnerProductSpace ℂ V]

/-- A complex polarization identity, with a linear map
-/
theorem inner_map_polarization (T : V →ₗ[ℂ] V) (x y : V) :
    ⟪T y, x⟫_ℂ =
      (⟪T (x + y), x + y⟫_ℂ - ⟪T (x - y), x - y⟫_ℂ +
            Complex.i * ⟪T (x + Complex.i • y), x + Complex.i • y⟫_ℂ -
          Complex.i * ⟪T (x - Complex.i • y), x - Complex.i • y⟫_ℂ) /
        4 :=
  by
  simp only [map_add, map_sub, inner_add_left, inner_add_right, LinearMap.map_smul, inner_smul_left,
    inner_smul_right, Complex.conj_I, ← pow_two, Complex.I_sq, inner_sub_left, inner_sub_right,
    mul_add, ← mul_assoc, mul_neg, neg_neg, sub_neg_eq_add, one_mul, neg_one_mul, mul_sub, sub_sub]
  ring
#align inner_map_polarization inner_map_polarization

theorem inner_map_polarization' (T : V →ₗ[ℂ] V) (x y : V) :
    ⟪T x, y⟫_ℂ =
      (⟪T (x + y), x + y⟫_ℂ - ⟪T (x - y), x - y⟫_ℂ -
            Complex.i * ⟪T (x + Complex.i • y), x + Complex.i • y⟫_ℂ +
          Complex.i * ⟪T (x - Complex.i • y), x - Complex.i • y⟫_ℂ) /
        4 :=
  by
  simp only [map_add, map_sub, inner_add_left, inner_add_right, LinearMap.map_smul, inner_smul_left,
    inner_smul_right, Complex.conj_I, ← pow_two, Complex.I_sq, inner_sub_left, inner_sub_right,
    mul_add, ← mul_assoc, mul_neg, neg_neg, sub_neg_eq_add, one_mul, neg_one_mul, mul_sub, sub_sub]
  ring
#align inner_map_polarization' inner_map_polarization'

/-- A linear map `T` is zero, if and only if the identity `⟪T x, x⟫_ℂ = 0` holds for all `x`.
-/
theorem inner_map_self_eq_zero (T : V →ₗ[ℂ] V) : (∀ x : V, ⟪T x, x⟫_ℂ = 0) ↔ T = 0 :=
  by
  constructor
  · intro hT
    ext x
    simp only [LinearMap.zero_apply, ← inner_self_eq_zero, inner_map_polarization, hT]
    norm_num
  · rintro rfl x
    simp only [LinearMap.zero_apply, inner_zero_left]
#align inner_map_self_eq_zero inner_map_self_eq_zero

/--
Two linear maps `S` and `T` are equal, if and only if the identity `⟪S x, x⟫_ℂ = ⟪T x, x⟫_ℂ` holds
for all `x`.
-/
theorem ext_inner_map (S T : V →ₗ[ℂ] V) : (∀ x : V, ⟪S x, x⟫_ℂ = ⟪T x, x⟫_ℂ) ↔ S = T :=
  by
  rw [← sub_eq_zero, ← inner_map_self_eq_zero]
  refine' forall_congr' fun x => _
  rw [LinearMap.sub_apply, inner_sub_left, sub_eq_zero]
#align ext_inner_map ext_inner_map

end Complex

section

variable {ι : Type _} {ι' : Type _} {ι'' : Type _}

variable {E' : Type _} [InnerProductSpace 𝕜 E']

variable {E'' : Type _} [InnerProductSpace 𝕜 E'']

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment "/--" "A linear isometry preserves the inner product. -/")]
      [(Term.attributes "@[" [(Term.attrInstance (Term.attrKind []) (Attr.simp "simp" [] []))] "]")]
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `LinearIsometry.inner_map_map [])
      (Command.declSig
       [(Term.explicitBinder
         "("
         [`f]
         [":" (Analysis.NormedSpace.LinearIsometry.«term_→ₗᵢ[_]_» `E " →ₗᵢ[" `𝕜 "] " `E')]
         []
         ")")
        (Term.explicitBinder "(" [`x `y] [":" `E] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (Term.app `f [`x])
          ", "
          (Term.app `f [`y])
          "⟫")
         "="
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.simp
            "simp"
            []
            []
            []
            ["["
             [(Tactic.simpLemma [] [] `inner_eq_sum_norm_sq_div_four)
              ","
              (Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `f.norm_map)]
             "]"]
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           []
           ["["
            [(Tactic.simpLemma [] [] `inner_eq_sum_norm_sq_div_four)
             ","
             (Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `f.norm_map)]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       []
       ["["
        [(Tactic.simpLemma [] [] `inner_eq_sum_norm_sq_div_four)
         ","
         (Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `f.norm_map)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `f.norm_map
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_eq_sum_norm_sq_div_four
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        (Term.app `f [`x])
        ", "
        (Term.app `f [`y])
        "⟫")
       "="
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- A linear isometry preserves the inner product. -/ @[ simp ]
  theorem
    LinearIsometry.inner_map_map
    ( f : E →ₗᵢ[ 𝕜 ] E' ) ( x y : E ) : ⟪ f x , f y ⟫ = ⟪ x , y ⟫
    := by simp [ inner_eq_sum_norm_sq_div_four , ← f.norm_map ]
#align linear_isometry.inner_map_map LinearIsometry.inner_map_map

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment "/--" "A linear isometric equivalence preserves the inner product. -/")]
      [(Term.attributes "@[" [(Term.attrInstance (Term.attrKind []) (Attr.simp "simp" [] []))] "]")]
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `LinearIsometryEquiv.inner_map_map [])
      (Command.declSig
       [(Term.explicitBinder
         "("
         [`f]
         [":" (Analysis.NormedSpace.LinearIsometry.«term_≃ₗᵢ[_]_» `E " ≃ₗᵢ[" `𝕜 "] " `E')]
         []
         ")")
        (Term.explicitBinder "(" [`x `y] [":" `E] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (Term.app `f [`x])
          ", "
          (Term.app `f [`y])
          "⟫")
         "="
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))))
      (Command.declValSimple
       ":="
       (Term.app (Term.proj (Term.proj `f "." `toLinearIsometry) "." `inner_map_map) [`x `y])
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app (Term.proj (Term.proj `f "." `toLinearIsometry) "." `inner_map_map) [`x `y])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.proj (Term.proj `f "." `toLinearIsometry) "." `inner_map_map)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.proj `f "." `toLinearIsometry)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `f
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        (Term.app `f [`x])
        ", "
        (Term.app `f [`y])
        "⟫")
       "="
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- A linear isometric equivalence preserves the inner product. -/ @[ simp ]
  theorem
    LinearIsometryEquiv.inner_map_map
    ( f : E ≃ₗᵢ[ 𝕜 ] E' ) ( x y : E ) : ⟪ f x , f y ⟫ = ⟪ x , y ⟫
    := f . toLinearIsometry . inner_map_map x y
#align linear_isometry_equiv.inner_map_map LinearIsometryEquiv.inner_map_map

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "A linear map that preserves the inner product is a linear isometry. -/")]
      []
      []
      []
      []
      [])
     (Command.def
      "def"
      (Command.declId `LinearMap.isometryOfInner [])
      (Command.optDeclSig
       [(Term.explicitBinder
         "("
         [`f]
         [":" (Algebra.Module.LinearMap.«term_→ₗ[_]_» `E " →ₗ[" `𝕜 "] " `E')]
         []
         ")")
        (Term.explicitBinder
         "("
         [`h]
         [":"
          (Term.forall
           "∀"
           [`x `y]
           []
           ","
           («term_=_»
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             (Term.app `f [`x])
             ", "
             (Term.app `f [`y])
             "⟫")
            "="
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")))]
         []
         ")")]
       [(Term.typeSpec
         ":"
         (Analysis.NormedSpace.LinearIsometry.«term_→ₗᵢ[_]_» `E " →ₗᵢ[" `𝕜 "] " `E'))])
      (Command.declValSimple
       ":="
       (Term.anonymousCtor
        "⟨"
        [`f
         ","
         (Term.fun
          "fun"
          (Term.basicFun
           [`x]
           []
           "=>"
           (Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.simp
                "simp"
                []
                []
                ["only"]
                ["["
                 [(Tactic.simpLemma [] [] `norm_eq_sqrt_inner) "," (Tactic.simpLemma [] [] `h)]
                 "]"]
                [])])))))]
        "⟩")
       [])
      []
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.anonymousCtor
       "⟨"
       [`f
        ","
        (Term.fun
         "fun"
         (Term.basicFun
          [`x]
          []
          "=>"
          (Term.byTactic
           "by"
           (Tactic.tacticSeq
            (Tactic.tacticSeq1Indented
             [(Tactic.simp
               "simp"
               []
               []
               ["only"]
               ["["
                [(Tactic.simpLemma [] [] `norm_eq_sqrt_inner) "," (Tactic.simpLemma [] [] `h)]
                "]"]
               [])])))))]
       "⟩")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun
       "fun"
       (Term.basicFun
        [`x]
        []
        "=>"
        (Term.byTactic
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(Tactic.simp
             "simp"
             []
             []
             ["only"]
             ["["
              [(Tactic.simpLemma [] [] `norm_eq_sqrt_inner) "," (Tactic.simpLemma [] [] `h)]
              "]"]
             [])])))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["[" [(Tactic.simpLemma [] [] `norm_eq_sqrt_inner) "," (Tactic.simpLemma [] [] `h)] "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["[" [(Tactic.simpLemma [] [] `norm_eq_sqrt_inner) "," (Tactic.simpLemma [] [] `h)] "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `norm_eq_sqrt_inner
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `f
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      (Analysis.NormedSpace.LinearIsometry.«term_→ₗᵢ[_]_» `E " →ₗᵢ[" `𝕜 "] " `E')
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `E'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `𝕜
[PrettyPrinter.parenthesize] ...precedences are 25 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 25, term))
      `E
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 25, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 25, (some 0, term) <=? (some 1023, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'ident'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.hole'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.forall
       "∀"
       [`x `y]
       []
       ","
       («term_=_»
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
         "⟪"
         (Term.app `f [`x])
         ", "
         (Term.app `f [`y])
         "⟫")
        "="
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        (Term.app `f [`x])
        ", "
        (Term.app `f [`y])
        "⟫")
       "="
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.theorem'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- A linear map that preserves the inner product is a linear isometry. -/
  def
    LinearMap.isometryOfInner
    ( f : E →ₗ[ 𝕜 ] E' ) ( h : ∀ x y , ⟪ f x , f y ⟫ = ⟪ x , y ⟫ ) : E →ₗᵢ[ 𝕜 ] E'
    := ⟨ f , fun x => by simp only [ norm_eq_sqrt_inner , h ] ⟩
#align linear_map.isometry_of_inner LinearMap.isometryOfInner

@[simp]
theorem LinearMap.coe_isometry_of_inner (f : E →ₗ[𝕜] E') (h) : ⇑(f.isometryOfInner h) = f :=
  rfl
#align linear_map.coe_isometry_of_inner LinearMap.coe_isometry_of_inner

@[simp]
theorem LinearMap.isometry_of_inner_to_linear_map (f : E →ₗ[𝕜] E') (h) :
    (f.isometryOfInner h).toLinearMap = f :=
  rfl
#align linear_map.isometry_of_inner_to_linear_map LinearMap.isometry_of_inner_to_linear_map

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "A linear equivalence that preserves the inner product is a linear isometric equivalence. -/")]
      []
      []
      []
      []
      [])
     (Command.def
      "def"
      (Command.declId `LinearEquiv.isometryOfInner [])
      (Command.optDeclSig
       [(Term.explicitBinder
         "("
         [`f]
         [":" (Algebra.Module.Equiv.«term_≃ₗ[_]_» `E " ≃ₗ[" `𝕜 "] " `E')]
         []
         ")")
        (Term.explicitBinder
         "("
         [`h]
         [":"
          (Term.forall
           "∀"
           [`x `y]
           []
           ","
           («term_=_»
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             (Term.app `f [`x])
             ", "
             (Term.app `f [`y])
             "⟫")
            "="
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")))]
         []
         ")")]
       [(Term.typeSpec
         ":"
         (Analysis.NormedSpace.LinearIsometry.«term_≃ₗᵢ[_]_» `E " ≃ₗᵢ[" `𝕜 "] " `E'))])
      (Command.declValSimple
       ":="
       (Term.anonymousCtor
        "⟨"
        [`f
         ","
         (Term.proj
          (Term.app
           (Term.proj
            (Term.typeAscription
             "("
             `f
             ":"
             [(Algebra.Module.LinearMap.«term_→ₗ[_]_» `E " →ₗ[" `𝕜 "] " `E')]
             ")")
            "."
            `isometryOfInner)
           [`h])
          "."
          `norm_map)]
        "⟩")
       [])
      []
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.anonymousCtor
       "⟨"
       [`f
        ","
        (Term.proj
         (Term.app
          (Term.proj
           (Term.typeAscription
            "("
            `f
            ":"
            [(Algebra.Module.LinearMap.«term_→ₗ[_]_» `E " →ₗ[" `𝕜 "] " `E')]
            ")")
           "."
           `isometryOfInner)
          [`h])
         "."
         `norm_map)]
       "⟩")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.proj
       (Term.app
        (Term.proj
         (Term.typeAscription
          "("
          `f
          ":"
          [(Algebra.Module.LinearMap.«term_→ₗ[_]_» `E " →ₗ[" `𝕜 "] " `E')]
          ")")
         "."
         `isometryOfInner)
        [`h])
       "."
       `norm_map)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.app
       (Term.proj
        (Term.typeAscription
         "("
         `f
         ":"
         [(Algebra.Module.LinearMap.«term_→ₗ[_]_» `E " →ₗ[" `𝕜 "] " `E')]
         ")")
        "."
        `isometryOfInner)
       [`h])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.proj
       (Term.typeAscription
        "("
        `f
        ":"
        [(Algebra.Module.LinearMap.«term_→ₗ[_]_» `E " →ₗ[" `𝕜 "] " `E')]
        ")")
       "."
       `isometryOfInner)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.typeAscription
       "("
       `f
       ":"
       [(Algebra.Module.LinearMap.«term_→ₗ[_]_» `E " →ₗ[" `𝕜 "] " `E')]
       ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Algebra.Module.LinearMap.«term_→ₗ[_]_» `E " →ₗ[" `𝕜 "] " `E')
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `E'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `𝕜
[PrettyPrinter.parenthesize] ...precedences are 25 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 25, term))
      `E
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 25, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 25, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `f
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app
      (Term.proj
       (Term.typeAscription
        "("
        `f
        ":"
        [(Algebra.Module.LinearMap.«term_→ₗ[_]_» `E " →ₗ[" `𝕜 "] " `E')]
        ")")
       "."
       `isometryOfInner)
      [`h])
     ")")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `f
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      (Analysis.NormedSpace.LinearIsometry.«term_≃ₗᵢ[_]_» `E " ≃ₗᵢ[" `𝕜 "] " `E')
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `E'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `𝕜
[PrettyPrinter.parenthesize] ...precedences are 25 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 25, term))
      `E
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 25, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 25, (some 0, term) <=? (some 1023, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'ident'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.hole'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.forall
       "∀"
       [`x `y]
       []
       ","
       («term_=_»
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
         "⟪"
         (Term.app `f [`x])
         ", "
         (Term.app `f [`y])
         "⟫")
        "="
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        (Term.app `f [`x])
        ", "
        (Term.app `f [`y])
        "⟫")
       "="
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.theorem'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- A linear equivalence that preserves the inner product is a linear isometric equivalence. -/
  def
    LinearEquiv.isometryOfInner
    ( f : E ≃ₗ[ 𝕜 ] E' ) ( h : ∀ x y , ⟪ f x , f y ⟫ = ⟪ x , y ⟫ ) : E ≃ₗᵢ[ 𝕜 ] E'
    := ⟨ f , ( f : E →ₗ[ 𝕜 ] E' ) . isometryOfInner h . norm_map ⟩
#align linear_equiv.isometry_of_inner LinearEquiv.isometryOfInner

@[simp]
theorem LinearEquiv.coe_isometry_of_inner (f : E ≃ₗ[𝕜] E') (h) : ⇑(f.isometryOfInner h) = f :=
  rfl
#align linear_equiv.coe_isometry_of_inner LinearEquiv.coe_isometry_of_inner

@[simp]
theorem LinearEquiv.isometry_of_inner_to_linear_equiv (f : E ≃ₗ[𝕜] E') (h) :
    (f.isometryOfInner h).toLinearEquiv = f :=
  rfl
#align linear_equiv.isometry_of_inner_to_linear_equiv LinearEquiv.isometry_of_inner_to_linear_equiv

/-- A linear isometry preserves the property of being orthonormal. -/
theorem LinearIsometry.orthonormal_comp_iff {v : ι → E} (f : E →ₗᵢ[𝕜] E') :
    Orthonormal 𝕜 (f ∘ v) ↔ Orthonormal 𝕜 v := by
  classical simp_rw [orthonormal_iff_ite, LinearIsometry.inner_map_map]
#align linear_isometry.orthonormal_comp_iff LinearIsometry.orthonormal_comp_iff

/-- A linear isometry preserves the property of being orthonormal. -/
theorem Orthonormal.compLinearIsometry {v : ι → E} (hv : Orthonormal 𝕜 v) (f : E →ₗᵢ[𝕜] E') :
    Orthonormal 𝕜 (f ∘ v) := by rwa [f.orthonormal_comp_iff]
#align orthonormal.comp_linear_isometry Orthonormal.compLinearIsometry

/-- A linear isometric equivalence preserves the property of being orthonormal. -/
theorem Orthonormal.compLinearIsometryEquiv {v : ι → E} (hv : Orthonormal 𝕜 v) (f : E ≃ₗᵢ[𝕜] E') :
    Orthonormal 𝕜 (f ∘ v) :=
  hv.compLinearIsometry f.toLinearIsometry
#align orthonormal.comp_linear_isometry_equiv Orthonormal.compLinearIsometryEquiv

/-- A linear isometric equivalence, applied with `basis.map`, preserves the property of being
orthonormal. -/
theorem Orthonormal.mapLinearIsometryEquiv {v : Basis ι 𝕜 E} (hv : Orthonormal 𝕜 v)
    (f : E ≃ₗᵢ[𝕜] E') : Orthonormal 𝕜 (v.map f.toLinearEquiv) :=
  hv.compLinearIsometryEquiv f
#align orthonormal.map_linear_isometry_equiv Orthonormal.mapLinearIsometryEquiv

/-- A linear map that sends an orthonormal basis to orthonormal vectors is a linear isometry. -/
def LinearMap.isometryOfOrthonormal (f : E →ₗ[𝕜] E') {v : Basis ι 𝕜 E} (hv : Orthonormal 𝕜 v)
    (hf : Orthonormal 𝕜 (f ∘ v)) : E →ₗᵢ[𝕜] E' :=
  f.isometryOfInner fun x y => by
    rw [← v.total_repr x, ← v.total_repr y, Finsupp.apply_total, Finsupp.apply_total,
      hv.inner_finsupp_eq_sum_left, hf.inner_finsupp_eq_sum_left]
#align linear_map.isometry_of_orthonormal LinearMap.isometryOfOrthonormal

@[simp]
theorem LinearMap.coe_isometry_of_orthonormal (f : E →ₗ[𝕜] E') {v : Basis ι 𝕜 E}
    (hv : Orthonormal 𝕜 v) (hf : Orthonormal 𝕜 (f ∘ v)) : ⇑(f.isometryOfOrthonormal hv hf) = f :=
  rfl
#align linear_map.coe_isometry_of_orthonormal LinearMap.coe_isometry_of_orthonormal

@[simp]
theorem LinearMap.isometry_of_orthonormal_to_linear_map (f : E →ₗ[𝕜] E') {v : Basis ι 𝕜 E}
    (hv : Orthonormal 𝕜 v) (hf : Orthonormal 𝕜 (f ∘ v)) :
    (f.isometryOfOrthonormal hv hf).toLinearMap = f :=
  rfl
#align
  linear_map.isometry_of_orthonormal_to_linear_map LinearMap.isometry_of_orthonormal_to_linear_map

/-- A linear equivalence that sends an orthonormal basis to orthonormal vectors is a linear
isometric equivalence. -/
def LinearEquiv.isometryOfOrthonormal (f : E ≃ₗ[𝕜] E') {v : Basis ι 𝕜 E} (hv : Orthonormal 𝕜 v)
    (hf : Orthonormal 𝕜 (f ∘ v)) : E ≃ₗᵢ[𝕜] E' :=
  f.isometryOfInner fun x y => by
    rw [← LinearEquiv.coe_coe] at hf
    rw [← v.total_repr x, ← v.total_repr y, ← LinearEquiv.coe_coe, Finsupp.apply_total,
      Finsupp.apply_total, hv.inner_finsupp_eq_sum_left, hf.inner_finsupp_eq_sum_left]
#align linear_equiv.isometry_of_orthonormal LinearEquiv.isometryOfOrthonormal

@[simp]
theorem LinearEquiv.coe_isometry_of_orthonormal (f : E ≃ₗ[𝕜] E') {v : Basis ι 𝕜 E}
    (hv : Orthonormal 𝕜 v) (hf : Orthonormal 𝕜 (f ∘ v)) : ⇑(f.isometryOfOrthonormal hv hf) = f :=
  rfl
#align linear_equiv.coe_isometry_of_orthonormal LinearEquiv.coe_isometry_of_orthonormal

@[simp]
theorem LinearEquiv.isometry_of_orthonormal_to_linear_equiv (f : E ≃ₗ[𝕜] E') {v : Basis ι 𝕜 E}
    (hv : Orthonormal 𝕜 v) (hf : Orthonormal 𝕜 (f ∘ v)) :
    (f.isometryOfOrthonormal hv hf).toLinearEquiv = f :=
  rfl
#align
  linear_equiv.isometry_of_orthonormal_to_linear_equiv LinearEquiv.isometry_of_orthonormal_to_linear_equiv

/-- A linear isometric equivalence that sends an orthonormal basis to a given orthonormal basis. -/
def Orthonormal.equiv {v : Basis ι 𝕜 E} (hv : Orthonormal 𝕜 v) {v' : Basis ι' 𝕜 E'}
    (hv' : Orthonormal 𝕜 v') (e : ι ≃ ι') : E ≃ₗᵢ[𝕜] E' :=
  (v.Equiv v' e).isometryOfOrthonormal hv
    (by
      have h : v.equiv v' e ∘ v = v' ∘ e := by
        ext i
        simp
      rw [h]
      exact hv'.comp _ e.injective)
#align orthonormal.equiv Orthonormal.equiv

@[simp]
theorem Orthonormal.equiv_to_linear_equiv {v : Basis ι 𝕜 E} (hv : Orthonormal 𝕜 v)
    {v' : Basis ι' 𝕜 E'} (hv' : Orthonormal 𝕜 v') (e : ι ≃ ι') :
    (hv.Equiv hv' e).toLinearEquiv = v.Equiv v' e :=
  rfl
#align orthonormal.equiv_to_linear_equiv Orthonormal.equiv_to_linear_equiv

@[simp]
theorem Orthonormal.equiv_apply {ι' : Type _} {v : Basis ι 𝕜 E} (hv : Orthonormal 𝕜 v)
    {v' : Basis ι' 𝕜 E'} (hv' : Orthonormal 𝕜 v') (e : ι ≃ ι') (i : ι) :
    hv.Equiv hv' e (v i) = v' (e i) :=
  Basis.equiv_apply _ _ _ _
#align orthonormal.equiv_apply Orthonormal.equiv_apply

@[simp]
theorem Orthonormal.equiv_refl {v : Basis ι 𝕜 E} (hv : Orthonormal 𝕜 v) :
    hv.Equiv hv (Equiv.refl ι) = LinearIsometryEquiv.refl 𝕜 E :=
  v.ext_linear_isometry_equiv fun i => by
    simp only [Orthonormal.equiv_apply, Equiv.coe_refl, id.def, LinearIsometryEquiv.coe_refl]
#align orthonormal.equiv_refl Orthonormal.equiv_refl

@[simp]
theorem Orthonormal.equiv_symm {v : Basis ι 𝕜 E} (hv : Orthonormal 𝕜 v) {v' : Basis ι' 𝕜 E'}
    (hv' : Orthonormal 𝕜 v') (e : ι ≃ ι') : (hv.Equiv hv' e).symm = hv'.Equiv hv e.symm :=
  v'.ext_linear_isometry_equiv fun i =>
    (hv.Equiv hv' e).Injective <| by
      simp only [LinearIsometryEquiv.apply_symm_apply, Orthonormal.equiv_apply, e.apply_symm_apply]
#align orthonormal.equiv_symm Orthonormal.equiv_symm

@[simp]
theorem Orthonormal.equiv_trans {v : Basis ι 𝕜 E} (hv : Orthonormal 𝕜 v) {v' : Basis ι' 𝕜 E'}
    (hv' : Orthonormal 𝕜 v') (e : ι ≃ ι') {v'' : Basis ι'' 𝕜 E''} (hv'' : Orthonormal 𝕜 v'')
    (e' : ι' ≃ ι'') : (hv.Equiv hv' e).trans (hv'.Equiv hv'' e') = hv.Equiv hv'' (e.trans e') :=
  v.ext_linear_isometry_equiv fun i => by
    simp only [LinearIsometryEquiv.trans_apply, Orthonormal.equiv_apply, e.coe_trans]
#align orthonormal.equiv_trans Orthonormal.equiv_trans

theorem Orthonormal.map_equiv {v : Basis ι 𝕜 E} (hv : Orthonormal 𝕜 v) {v' : Basis ι' 𝕜 E'}
    (hv' : Orthonormal 𝕜 v') (e : ι ≃ ι') :
    v.map (hv.Equiv hv' e).toLinearEquiv = v'.reindex e.symm :=
  v.mapEquiv _ _
#align orthonormal.map_equiv Orthonormal.map_equiv

end

/-- Polarization identity: The real inner product, in terms of the norm. -/
theorem real_inner_eq_norm_add_mul_self_sub_norm_mul_self_sub_norm_mul_self_div_two (x y : F) :
    ⟪x, y⟫_ℝ = (‖x + y‖ * ‖x + y‖ - ‖x‖ * ‖x‖ - ‖y‖ * ‖y‖) / 2 :=
  re_to_real.symm.trans <|
    re_inner_eq_norm_add_mul_self_sub_norm_mul_self_sub_norm_mul_self_div_two x y
#align
  real_inner_eq_norm_add_mul_self_sub_norm_mul_self_sub_norm_mul_self_div_two real_inner_eq_norm_add_mul_self_sub_norm_mul_self_sub_norm_mul_self_div_two

/-- Polarization identity: The real inner product, in terms of the norm. -/
theorem real_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two (x y : F) :
    ⟪x, y⟫_ℝ = (‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ - ‖x - y‖ * ‖x - y‖) / 2 :=
  re_to_real.symm.trans <|
    re_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two x y
#align
  real_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two real_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two

/-- Pythagorean theorem, if-and-only-if vector inner product form. -/
theorem norm_add_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero (x y : F) :
    ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ ↔ ⟪x, y⟫_ℝ = 0 :=
  by
  rw [norm_add_mul_self, add_right_cancel_iff, add_right_eq_self, mul_eq_zero]
  norm_num
#align
  norm_add_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero norm_add_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero

/-- Pythagorean theorem, if-and-if vector inner product form using square roots. -/
theorem norm_add_eq_sqrt_iff_real_inner_eq_zero {x y : F} :
    ‖x + y‖ = sqrt (‖x‖ * ‖x‖ + ‖y‖ * ‖y‖) ↔ ⟪x, y⟫_ℝ = 0 := by
  rw [← norm_add_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero, eq_comm,
    sqrt_eq_iff_mul_self_eq (add_nonneg (mul_self_nonneg _) (mul_self_nonneg _)) (norm_nonneg _)]
#align norm_add_eq_sqrt_iff_real_inner_eq_zero norm_add_eq_sqrt_iff_real_inner_eq_zero

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment "/--" "Pythagorean theorem, vector inner product form. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `norm_add_sq_eq_norm_sq_add_norm_sq_of_inner_eq_zero [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x `y] [":" `E] [] ")")
        (Term.explicitBinder
         "("
         [`h]
         [":"
          («term_=_»
           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
           "="
           (num "0"))]
         []
         ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         («term_*_»
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖")
          "*"
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖"))
         "="
         («term_+_»
          («term_*_»
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
           "*"
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
          "+"
          («term_*_»
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
           "*"
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [] `norm_add_mul_self)
              ","
              (Tactic.rwRule [] `add_right_cancel_iff)
              ","
              (Tactic.rwRule [] `add_right_eq_self)
              ","
              (Tactic.rwRule [] `mul_eq_zero)]
             "]")
            [])
           []
           (Tactic.apply "apply" `Or.inr)
           []
           (Tactic.simp
            "simp"
            []
            []
            ["only"]
            ["[" [(Tactic.simpLemma [] [] `h) "," (Tactic.simpLemma [] [] `zero_re')] "]"]
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] `norm_add_mul_self)
             ","
             (Tactic.rwRule [] `add_right_cancel_iff)
             ","
             (Tactic.rwRule [] `add_right_eq_self)
             ","
             (Tactic.rwRule [] `mul_eq_zero)]
            "]")
           [])
          []
          (Tactic.apply "apply" `Or.inr)
          []
          (Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["[" [(Tactic.simpLemma [] [] `h) "," (Tactic.simpLemma [] [] `zero_re')] "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["[" [(Tactic.simpLemma [] [] `h) "," (Tactic.simpLemma [] [] `zero_re')] "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `zero_re'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.apply "apply" `Or.inr)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Or.inr
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [] `norm_add_mul_self)
         ","
         (Tactic.rwRule [] `add_right_cancel_iff)
         ","
         (Tactic.rwRule [] `add_right_eq_self)
         ","
         (Tactic.rwRule [] `mul_eq_zero)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `mul_eq_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `add_right_eq_self
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `add_right_cancel_iff
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `norm_add_mul_self
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖"))
       "="
       («term_+_»
        («term_*_»
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
         "*"
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
        "+"
        («term_*_»
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
         "*"
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_+_»
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
       "+"
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
       "*"
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1024, (none, [anonymous]) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 66 >? 70, (some 71, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 65, term))
      («term_*_»
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
       "*"
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1024, (none, [anonymous]) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 65 >? 70, (some 71, term) <=? (some 65, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 65, (some 66, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      («term_*_»
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖")
       "*"
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_+_» `x "+" `y)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 66 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 65, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 65 >? 1024, (none, [anonymous]) <=? (some 65, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 65, (some 66, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `x "+" `y) "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_+_» `x "+" `y)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 66 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 65, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 65 >? 1024, (none, [anonymous]) <=? (some 65, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 65, (some 66, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1024, (none, [anonymous]) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 70, (some 71, term) <=? (some 50, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 50, (some 51,
     term) <=? (some 1023, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'ident'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.hole'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_» (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫") "=" (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- Pythagorean theorem, vector inner product form. -/
  theorem
    norm_add_sq_eq_norm_sq_add_norm_sq_of_inner_eq_zero
    ( x y : E ) ( h : ⟪ x , y ⟫ = 0 ) : ‖ x + y ‖ * ‖ x + y ‖ = ‖ x ‖ * ‖ x ‖ + ‖ y ‖ * ‖ y ‖
    :=
      by
        rw [ norm_add_mul_self , add_right_cancel_iff , add_right_eq_self , mul_eq_zero ]
          apply Or.inr
          simp only [ h , zero_re' ]
#align
  norm_add_sq_eq_norm_sq_add_norm_sq_of_inner_eq_zero norm_add_sq_eq_norm_sq_add_norm_sq_of_inner_eq_zero

/-- Pythagorean theorem, vector inner product form. -/
theorem norm_add_sq_eq_norm_sq_add_norm_sq_real {x y : F} (h : ⟪x, y⟫_ℝ = 0) :
    ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ :=
  (norm_add_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero x y).2 h
#align norm_add_sq_eq_norm_sq_add_norm_sq_real norm_add_sq_eq_norm_sq_add_norm_sq_real

/-- Pythagorean theorem, subtracting vectors, if-and-only-if vector
inner product form. -/
theorem norm_sub_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero (x y : F) :
    ‖x - y‖ * ‖x - y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ ↔ ⟪x, y⟫_ℝ = 0 :=
  by
  rw [norm_sub_mul_self, add_right_cancel_iff, sub_eq_add_neg, add_right_eq_self, neg_eq_zero,
    mul_eq_zero]
  norm_num
#align
  norm_sub_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero norm_sub_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero

/-- Pythagorean theorem, subtracting vectors, if-and-if vector inner product form using square
roots. -/
theorem norm_sub_eq_sqrt_iff_real_inner_eq_zero {x y : F} :
    ‖x - y‖ = sqrt (‖x‖ * ‖x‖ + ‖y‖ * ‖y‖) ↔ ⟪x, y⟫_ℝ = 0 := by
  rw [← norm_sub_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero, eq_comm,
    sqrt_eq_iff_mul_self_eq (add_nonneg (mul_self_nonneg _) (mul_self_nonneg _)) (norm_nonneg _)]
#align norm_sub_eq_sqrt_iff_real_inner_eq_zero norm_sub_eq_sqrt_iff_real_inner_eq_zero

/-- Pythagorean theorem, subtracting vectors, vector inner product
form. -/
theorem norm_sub_sq_eq_norm_sq_add_norm_sq_real {x y : F} (h : ⟪x, y⟫_ℝ = 0) :
    ‖x - y‖ * ‖x - y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ :=
  (norm_sub_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero x y).2 h
#align norm_sub_sq_eq_norm_sq_add_norm_sq_real norm_sub_sq_eq_norm_sq_add_norm_sq_real

/-- The sum and difference of two vectors are orthogonal if and only
if they have the same norm. -/
theorem real_inner_add_sub_eq_zero_iff (x y : F) : ⟪x + y, x - y⟫_ℝ = 0 ↔ ‖x‖ = ‖y‖ :=
  by
  conv_rhs => rw [← mul_self_inj_of_nonneg (norm_nonneg _) (norm_nonneg _)]
  simp only [← inner_self_eq_norm_mul_norm, inner_add_left, inner_sub_right, real_inner_comm y x,
    sub_eq_zero, re_to_real]
  constructor
  · intro h
    rw [add_comm] at h
    linarith
  · intro h
    linarith
#align real_inner_add_sub_eq_zero_iff real_inner_add_sub_eq_zero_iff

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "Given two orthogonal vectors, their sum and difference have equal norms. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `norm_sub_eq_norm_add [])
      (Command.declSig
       [(Term.implicitBinder "{" [`v `w] [":" `E] "}")
        (Term.explicitBinder
         "("
         [`h]
         [":"
          («term_=_»
           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `w "⟫")
           "="
           (num "0"))]
         []
         ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `w "-" `v) "‖")
         "="
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `w "+" `v) "‖"))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule
               [(patternIgnore (token.«← » "←"))]
               (Term.app
                `mul_self_inj_of_nonneg
                [(Term.app `norm_nonneg [(Term.hole "_")])
                 (Term.app `norm_nonneg [(Term.hole "_")])]))]
             "]")
            [])
           []
           (Tactic.simp
            "simp"
            []
            []
            ["only"]
            ["["
             [(Tactic.simpLemma [] [] `h)
              ","
              (Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `inner_self_eq_norm_mul_norm)
              ","
              (Tactic.simpLemma [] [] `sub_neg_eq_add)
              ","
              (Tactic.simpLemma [] [] `sub_zero)
              ","
              (Tactic.simpLemma [] [] `map_sub)
              ","
              (Tactic.simpLemma [] [] `zero_re')
              ","
              (Tactic.simpLemma [] [] `zero_sub)
              ","
              (Tactic.simpLemma [] [] `add_zero)
              ","
              (Tactic.simpLemma [] [] `map_add)
              ","
              (Tactic.simpLemma [] [] `inner_add_right)
              ","
              (Tactic.simpLemma [] [] `inner_sub_left)
              ","
              (Tactic.simpLemma [] [] `inner_sub_right)
              ","
              (Tactic.simpLemma [] [] `inner_re_symm)
              ","
              (Tactic.simpLemma [] [] `zero_add)]
             "]"]
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule
              [(patternIgnore (token.«← » "←"))]
              (Term.app
               `mul_self_inj_of_nonneg
               [(Term.app `norm_nonneg [(Term.hole "_")])
                (Term.app `norm_nonneg [(Term.hole "_")])]))]
            "]")
           [])
          []
          (Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["["
            [(Tactic.simpLemma [] [] `h)
             ","
             (Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `inner_self_eq_norm_mul_norm)
             ","
             (Tactic.simpLemma [] [] `sub_neg_eq_add)
             ","
             (Tactic.simpLemma [] [] `sub_zero)
             ","
             (Tactic.simpLemma [] [] `map_sub)
             ","
             (Tactic.simpLemma [] [] `zero_re')
             ","
             (Tactic.simpLemma [] [] `zero_sub)
             ","
             (Tactic.simpLemma [] [] `add_zero)
             ","
             (Tactic.simpLemma [] [] `map_add)
             ","
             (Tactic.simpLemma [] [] `inner_add_right)
             ","
             (Tactic.simpLemma [] [] `inner_sub_left)
             ","
             (Tactic.simpLemma [] [] `inner_sub_right)
             ","
             (Tactic.simpLemma [] [] `inner_re_symm)
             ","
             (Tactic.simpLemma [] [] `zero_add)]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] `h)
         ","
         (Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `inner_self_eq_norm_mul_norm)
         ","
         (Tactic.simpLemma [] [] `sub_neg_eq_add)
         ","
         (Tactic.simpLemma [] [] `sub_zero)
         ","
         (Tactic.simpLemma [] [] `map_sub)
         ","
         (Tactic.simpLemma [] [] `zero_re')
         ","
         (Tactic.simpLemma [] [] `zero_sub)
         ","
         (Tactic.simpLemma [] [] `add_zero)
         ","
         (Tactic.simpLemma [] [] `map_add)
         ","
         (Tactic.simpLemma [] [] `inner_add_right)
         ","
         (Tactic.simpLemma [] [] `inner_sub_left)
         ","
         (Tactic.simpLemma [] [] `inner_sub_right)
         ","
         (Tactic.simpLemma [] [] `inner_re_symm)
         ","
         (Tactic.simpLemma [] [] `zero_add)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `zero_add
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_re_symm
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_sub_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_sub_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_add_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `map_add
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `add_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `zero_sub
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `zero_re'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `map_sub
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `sub_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `sub_neg_eq_add
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_self_eq_norm_mul_norm
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule
          [(patternIgnore (token.«← » "←"))]
          (Term.app
           `mul_self_inj_of_nonneg
           [(Term.app `norm_nonneg [(Term.hole "_")]) (Term.app `norm_nonneg [(Term.hole "_")])]))]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `mul_self_inj_of_nonneg
       [(Term.app `norm_nonneg [(Term.hole "_")]) (Term.app `norm_nonneg [(Term.hole "_")])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `norm_nonneg [(Term.hole "_")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `norm_nonneg
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app `norm_nonneg [(Term.hole "_")])
     ")")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.app `norm_nonneg [(Term.hole "_")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `norm_nonneg
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app `norm_nonneg [(Term.hole "_")])
     ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `mul_self_inj_of_nonneg
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `w "-" `v) "‖")
       "="
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `w "+" `v) "‖"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_+_» `w "+" `v) "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_+_» `w "+" `v)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `v
[PrettyPrinter.parenthesize] ...precedences are 66 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 65, term))
      `w
[PrettyPrinter.parenthesize] ...precedences are 65 >? 1024, (none, [anonymous]) <=? (some 65, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 65, (some 66, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" («term_-_» `w "-" `v) "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_-_» `w "-" `v)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `v
[PrettyPrinter.parenthesize] ...precedences are 66 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 65, term))
      `w
[PrettyPrinter.parenthesize] ...precedences are 65 >? 1024, (none, [anonymous]) <=? (some 65, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 65, (some 66, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none, [anonymous]) <=? (some 50, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 50, (some 51,
     term) <=? (some 1023, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'ident'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.hole'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_» (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `w "⟫") "=" (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `w "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- Given two orthogonal vectors, their sum and difference have equal norms. -/
  theorem
    norm_sub_eq_norm_add
    { v w : E } ( h : ⟪ v , w ⟫ = 0 ) : ‖ w - v ‖ = ‖ w + v ‖
    :=
      by
        rw [ ← mul_self_inj_of_nonneg norm_nonneg _ norm_nonneg _ ]
          simp
            only
            [
              h
                ,
                ← inner_self_eq_norm_mul_norm
                ,
                sub_neg_eq_add
                ,
                sub_zero
                ,
                map_sub
                ,
                zero_re'
                ,
                zero_sub
                ,
                add_zero
                ,
                map_add
                ,
                inner_add_right
                ,
                inner_sub_left
                ,
                inner_sub_right
                ,
                inner_re_symm
                ,
                zero_add
              ]
#align norm_sub_eq_norm_add norm_sub_eq_norm_add

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "The real inner product of two vectors, divided by the product of their\nnorms, has absolute value at most 1. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `abs_real_inner_div_norm_mul_norm_le_one [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x `y] [":" `F] [] ")")]
       (Term.typeSpec
        ":"
        («term_≤_»
         (Term.app
          (Analysis.InnerProductSpace.Basic.termabsR "absR")
          [(«term_/_»
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫_ℝ» "⟪" `x ", " `y "⟫_ℝ")
            "/"
            («term_*_»
             (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
             "*"
             (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))])
         "≤"
         (num "1"))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `_root_.abs_div)] "]") [])
           []
           (Classical.«tacticBy_cases_:_»
            "by_cases"
            [`h ":"]
            («term_=_»
             (num "0")
             "="
             (Term.app
              (Analysis.InnerProductSpace.Basic.termabsR "absR")
              [(«term_*_»
                (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                "*"
                (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))])))
           []
           (tactic__
            (cdotTk (patternIgnore (token.«· » "·")))
            [(Tactic.rwSeq
              "rw"
              []
              (Tactic.rwRuleSeq
               "["
               [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `h)
                ","
                (Tactic.rwRule [] `div_zero)]
               "]")
              [])
             []
             (Mathlib.Tactic.normNum "norm_num" [] [] [])])
           []
           (tactic__
            (cdotTk (patternIgnore (token.«· » "·")))
            [(Tactic.change
              "change"
              («term_≠_»
               (num "0")
               "≠"
               (Term.app
                (Analysis.InnerProductSpace.Basic.termabsR "absR")
                [(«term_*_»
                  (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                  "*"
                  (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))]))
              [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
             []
             (Tactic.rwSeq
              "rw"
              []
              (Tactic.rwRuleSeq
               "["
               [(Tactic.rwRule
                 []
                 (Term.app
                  `div_le_iff'
                  [(Term.app
                    `lt_of_le_of_ne
                    [(Term.app
                      `ge_iff_le.mp
                      [(Term.app
                        `_root_.abs_nonneg
                        [(«term_*_»
                          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                          "*"
                          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))])])
                     `h])]))]
               "]")
              [])
             []
             (convert "convert" [] (Term.app `abs_real_inner_le_norm [`x `y]) ["using" (num "1")])
             []
             (Tactic.rwSeq
              "rw"
              []
              (Tactic.rwRuleSeq
               "["
               [(Tactic.rwRule [] `_root_.abs_mul)
                ","
                (Tactic.rwRule [] (Term.app `_root_.abs_of_nonneg [(Term.app `norm_nonneg [`x])]))
                ","
                (Tactic.rwRule [] (Term.app `_root_.abs_of_nonneg [(Term.app `norm_nonneg [`y])]))
                ","
                (Tactic.rwRule [] `mul_one)]
               "]")
              [])])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `_root_.abs_div)] "]") [])
          []
          (Classical.«tacticBy_cases_:_»
           "by_cases"
           [`h ":"]
           («term_=_»
            (num "0")
            "="
            (Term.app
             (Analysis.InnerProductSpace.Basic.termabsR "absR")
             [(«term_*_»
               (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
               "*"
               (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))])))
          []
          (tactic__
           (cdotTk (patternIgnore (token.«· » "·")))
           [(Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq
              "["
              [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `h)
               ","
               (Tactic.rwRule [] `div_zero)]
              "]")
             [])
            []
            (Mathlib.Tactic.normNum "norm_num" [] [] [])])
          []
          (tactic__
           (cdotTk (patternIgnore (token.«· » "·")))
           [(Tactic.change
             "change"
             («term_≠_»
              (num "0")
              "≠"
              (Term.app
               (Analysis.InnerProductSpace.Basic.termabsR "absR")
               [(«term_*_»
                 (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                 "*"
                 (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))]))
             [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
            []
            (Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq
              "["
              [(Tactic.rwRule
                []
                (Term.app
                 `div_le_iff'
                 [(Term.app
                   `lt_of_le_of_ne
                   [(Term.app
                     `ge_iff_le.mp
                     [(Term.app
                       `_root_.abs_nonneg
                       [(«term_*_»
                         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                         "*"
                         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))])])
                    `h])]))]
              "]")
             [])
            []
            (convert "convert" [] (Term.app `abs_real_inner_le_norm [`x `y]) ["using" (num "1")])
            []
            (Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq
              "["
              [(Tactic.rwRule [] `_root_.abs_mul)
               ","
               (Tactic.rwRule [] (Term.app `_root_.abs_of_nonneg [(Term.app `norm_nonneg [`x])]))
               ","
               (Tactic.rwRule [] (Term.app `_root_.abs_of_nonneg [(Term.app `norm_nonneg [`y])]))
               ","
               (Tactic.rwRule [] `mul_one)]
              "]")
             [])])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.«· » "·")))
       [(Tactic.change
         "change"
         («term_≠_»
          (num "0")
          "≠"
          (Term.app
           (Analysis.InnerProductSpace.Basic.termabsR "absR")
           [(«term_*_»
             (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
             "*"
             (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))]))
         [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
        []
        (Tactic.rwSeq
         "rw"
         []
         (Tactic.rwRuleSeq
          "["
          [(Tactic.rwRule
            []
            (Term.app
             `div_le_iff'
             [(Term.app
               `lt_of_le_of_ne
               [(Term.app
                 `ge_iff_le.mp
                 [(Term.app
                   `_root_.abs_nonneg
                   [(«term_*_»
                     (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                     "*"
                     (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))])])
                `h])]))]
          "]")
         [])
        []
        (convert "convert" [] (Term.app `abs_real_inner_le_norm [`x `y]) ["using" (num "1")])
        []
        (Tactic.rwSeq
         "rw"
         []
         (Tactic.rwRuleSeq
          "["
          [(Tactic.rwRule [] `_root_.abs_mul)
           ","
           (Tactic.rwRule [] (Term.app `_root_.abs_of_nonneg [(Term.app `norm_nonneg [`x])]))
           ","
           (Tactic.rwRule [] (Term.app `_root_.abs_of_nonneg [(Term.app `norm_nonneg [`y])]))
           ","
           (Tactic.rwRule [] `mul_one)]
          "]")
         [])])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [] `_root_.abs_mul)
         ","
         (Tactic.rwRule [] (Term.app `_root_.abs_of_nonneg [(Term.app `norm_nonneg [`x])]))
         ","
         (Tactic.rwRule [] (Term.app `_root_.abs_of_nonneg [(Term.app `norm_nonneg [`y])]))
         ","
         (Tactic.rwRule [] `mul_one)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `mul_one
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `_root_.abs_of_nonneg [(Term.app `norm_nonneg [`y])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `norm_nonneg [`y])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `norm_nonneg
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `norm_nonneg [`y]) ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `_root_.abs_of_nonneg
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `_root_.abs_of_nonneg [(Term.app `norm_nonneg [`x])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `norm_nonneg [`x])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `norm_nonneg
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `norm_nonneg [`x]) ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `_root_.abs_of_nonneg
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `_root_.abs_mul
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (convert "convert" [] (Term.app `abs_real_inner_le_norm [`x `y]) ["using" (num "1")])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `abs_real_inner_le_norm [`x `y])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `abs_real_inner_le_norm
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule
          []
          (Term.app
           `div_le_iff'
           [(Term.app
             `lt_of_le_of_ne
             [(Term.app
               `ge_iff_le.mp
               [(Term.app
                 `_root_.abs_nonneg
                 [(«term_*_»
                   (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                   "*"
                   (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))])])
              `h])]))]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `div_le_iff'
       [(Term.app
         `lt_of_le_of_ne
         [(Term.app
           `ge_iff_le.mp
           [(Term.app
             `_root_.abs_nonneg
             [(«term_*_»
               (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
               "*"
               (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))])])
          `h])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `lt_of_le_of_ne
       [(Term.app
         `ge_iff_le.mp
         [(Term.app
           `_root_.abs_nonneg
           [(«term_*_»
             (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
             "*"
             (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))])])
        `h])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.app
       `ge_iff_le.mp
       [(Term.app
         `_root_.abs_nonneg
         [(«term_*_»
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
           "*"
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `_root_.abs_nonneg
       [(«term_*_»
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
         "*"
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_*_»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_*_»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
       "*"
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1024, (none, [anonymous]) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 70, (some 71, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     («term_*_»
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
      "*"
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
     ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `_root_.abs_nonneg
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app
      `_root_.abs_nonneg
      [(Term.paren
        "("
        («term_*_»
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
         "*"
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
        ")")])
     ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `ge_iff_le.mp
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app
      `ge_iff_le.mp
      [(Term.paren
        "("
        (Term.app
         `_root_.abs_nonneg
         [(Term.paren
           "("
           («term_*_»
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
            "*"
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
           ")")])
        ")")])
     ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `lt_of_le_of_ne
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app
      `lt_of_le_of_ne
      [(Term.paren
        "("
        (Term.app
         `ge_iff_le.mp
         [(Term.paren
           "("
           (Term.app
            `_root_.abs_nonneg
            [(Term.paren
              "("
              («term_*_»
               (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
               "*"
               (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
              ")")])
           ")")])
        ")")
       `h])
     ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `div_le_iff'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.change
       "change"
       («term_≠_»
        (num "0")
        "≠"
        (Term.app
         (Analysis.InnerProductSpace.Basic.termabsR "absR")
         [(«term_*_»
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
           "*"
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))]))
       [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.locationHyp', expected 'Lean.Parser.Tactic.locationWildcard'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_≠_»
       (num "0")
       "≠"
       (Term.app
        (Analysis.InnerProductSpace.Basic.termabsR "absR")
        [(«term_*_»
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
          "*"
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       (Analysis.InnerProductSpace.Basic.termabsR "absR")
       [(«term_*_»
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
         "*"
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_*_»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_*_»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
       "*"
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1024, (none, [anonymous]) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 70, (some 71, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     («term_*_»
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
      "*"
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
     ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Analysis.InnerProductSpace.Basic.termabsR "absR")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.termabsR', expected 'Analysis.InnerProductSpace.Basic.termabsR._@.Analysis.InnerProductSpace.Basic._hyg.1003'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    The real inner product of two vectors, divided by the product of their
    norms, has absolute value at most 1. -/
  theorem
    abs_real_inner_div_norm_mul_norm_le_one
    ( x y : F ) : absR ⟪ x , y ⟫_ℝ / ‖ x ‖ * ‖ y ‖ ≤ 1
    :=
      by
        rw [ _root_.abs_div ]
          by_cases h : 0 = absR ‖ x ‖ * ‖ y ‖
          · rw [ ← h , div_zero ] norm_num
          ·
            change 0 ≠ absR ‖ x ‖ * ‖ y ‖ at h
              rw [ div_le_iff' lt_of_le_of_ne ge_iff_le.mp _root_.abs_nonneg ‖ x ‖ * ‖ y ‖ h ]
              convert abs_real_inner_le_norm x y using 1
              rw
                [
                  _root_.abs_mul
                    ,
                    _root_.abs_of_nonneg norm_nonneg x
                    ,
                    _root_.abs_of_nonneg norm_nonneg y
                    ,
                    mul_one
                  ]
#align abs_real_inner_div_norm_mul_norm_le_one abs_real_inner_div_norm_mul_norm_le_one

/-- The inner product of a vector with a multiple of itself. -/
theorem real_inner_smul_self_left (x : F) (r : ℝ) : ⟪r • x, x⟫_ℝ = r * (‖x‖ * ‖x‖) := by
  rw [real_inner_smul_left, ← real_inner_self_eq_norm_mul_norm]
#align real_inner_smul_self_left real_inner_smul_self_left

/-- The inner product of a vector with a multiple of itself. -/
theorem real_inner_smul_self_right (x : F) (r : ℝ) : ⟪x, r • x⟫_ℝ = r * (‖x‖ * ‖x‖) := by
  rw [inner_smul_right, ← real_inner_self_eq_norm_mul_norm]
#align real_inner_smul_self_right real_inner_smul_self_right

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "The inner product of a nonzero vector with a nonzero multiple of\nitself, divided by the product of their norms, has absolute value\n1. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `abs_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x] [":" `E] "}")
        (Term.implicitBinder "{" [`r] [":" `𝕜] "}")
        (Term.explicitBinder "(" [`hx] [":" («term_≠_» `x "≠" (num "0"))] [] ")")
        (Term.explicitBinder "(" [`hr] [":" («term_≠_» `r "≠" (num "0"))] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         («term_/_»
          (Term.app
           `abs
           [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             `x
             ", "
             (Algebra.Group.Defs.«term_•_» `r " • " `x)
             "⟫")])
          "/"
          («term_*_»
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
           "*"
           (Analysis.Normed.Group.Basic.«term‖_‖»
            "‖"
            (Algebra.Group.Defs.«term_•_» `r " • " `x)
            "‖")))
         "="
         (num "1"))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.tacticHave_
            "have"
            (Term.haveDecl
             (Term.haveIdDecl
              [`hx' []]
              [(Term.typeSpec
                ":"
                («term_≠_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "≠" (num "0")))]
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.simp
                   "simp"
                   []
                   []
                   []
                   ["["
                    [(Tactic.simpLemma [] [] `norm_eq_zero) "," (Tactic.simpLemma [] [] `hx)]
                    "]"]
                   [])]))))))
           []
           (Tactic.tacticHave_
            "have"
            (Term.haveDecl
             (Term.haveIdDecl
              [`hr' []]
              [(Term.typeSpec ":" («term_≠_» (Term.app `abs [`r]) "≠" (num "0")))]
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.simp
                   "simp"
                   []
                   []
                   []
                   ["["
                    [(Tactic.simpLemma [] [] `IsROrC.abs_eq_zero) "," (Tactic.simpLemma [] [] `hr)]
                    "]"]
                   [])]))))))
           []
           (Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [] `inner_smul_right)
              ","
              (Tactic.rwRule [] `IsROrC.abs_mul)
              ","
              (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_self_re_abs)
              ","
              (Tactic.rwRule [] `inner_self_eq_norm_mul_norm)
              ","
              (Tactic.rwRule [] `norm_smul)]
             "]")
            [])
           []
           (Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [] `IsROrC.norm_eq_abs)
              ","
              (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `mul_assoc)
              ","
              (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `div_div)
              ","
              (Tactic.rwRule [] (Term.app `mul_div_cancel [(Term.hole "_") `hx']))
              ","
              (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `div_div)
              ","
              (Tactic.rwRule [] `mul_comm)
              ","
              (Tactic.rwRule [] (Term.app `mul_div_cancel [(Term.hole "_") `hr']))
              ","
              (Tactic.rwRule [] (Term.app `div_self [`hx']))]
             "]")
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.tacticHave_
           "have"
           (Term.haveDecl
            (Term.haveIdDecl
             [`hx' []]
             [(Term.typeSpec
               ":"
               («term_≠_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "≠" (num "0")))]
             ":="
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Tactic.simp
                  "simp"
                  []
                  []
                  []
                  ["["
                   [(Tactic.simpLemma [] [] `norm_eq_zero) "," (Tactic.simpLemma [] [] `hx)]
                   "]"]
                  [])]))))))
          []
          (Tactic.tacticHave_
           "have"
           (Term.haveDecl
            (Term.haveIdDecl
             [`hr' []]
             [(Term.typeSpec ":" («term_≠_» (Term.app `abs [`r]) "≠" (num "0")))]
             ":="
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Tactic.simp
                  "simp"
                  []
                  []
                  []
                  ["["
                   [(Tactic.simpLemma [] [] `IsROrC.abs_eq_zero) "," (Tactic.simpLemma [] [] `hr)]
                   "]"]
                  [])]))))))
          []
          (Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] `inner_smul_right)
             ","
             (Tactic.rwRule [] `IsROrC.abs_mul)
             ","
             (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_self_re_abs)
             ","
             (Tactic.rwRule [] `inner_self_eq_norm_mul_norm)
             ","
             (Tactic.rwRule [] `norm_smul)]
            "]")
           [])
          []
          (Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] `IsROrC.norm_eq_abs)
             ","
             (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `mul_assoc)
             ","
             (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `div_div)
             ","
             (Tactic.rwRule [] (Term.app `mul_div_cancel [(Term.hole "_") `hx']))
             ","
             (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `div_div)
             ","
             (Tactic.rwRule [] `mul_comm)
             ","
             (Tactic.rwRule [] (Term.app `mul_div_cancel [(Term.hole "_") `hr']))
             ","
             (Tactic.rwRule [] (Term.app `div_self [`hx']))]
            "]")
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [] `IsROrC.norm_eq_abs)
         ","
         (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `mul_assoc)
         ","
         (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `div_div)
         ","
         (Tactic.rwRule [] (Term.app `mul_div_cancel [(Term.hole "_") `hx']))
         ","
         (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `div_div)
         ","
         (Tactic.rwRule [] `mul_comm)
         ","
         (Tactic.rwRule [] (Term.app `mul_div_cancel [(Term.hole "_") `hr']))
         ","
         (Tactic.rwRule [] (Term.app `div_self [`hx']))]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `div_self [`hx'])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hx'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `div_self
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `mul_div_cancel [(Term.hole "_") `hr'])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hr'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `mul_div_cancel
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `mul_comm
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `div_div
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `mul_div_cancel [(Term.hole "_") `hx'])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hx'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `mul_div_cancel
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `div_div
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `mul_assoc
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `IsROrC.norm_eq_abs
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [] `inner_smul_right)
         ","
         (Tactic.rwRule [] `IsROrC.abs_mul)
         ","
         (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_self_re_abs)
         ","
         (Tactic.rwRule [] `inner_self_eq_norm_mul_norm)
         ","
         (Tactic.rwRule [] `norm_smul)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `norm_smul
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_self_eq_norm_mul_norm
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_self_re_abs
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `IsROrC.abs_mul
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_smul_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.tacticHave_
       "have"
       (Term.haveDecl
        (Term.haveIdDecl
         [`hr' []]
         [(Term.typeSpec ":" («term_≠_» (Term.app `abs [`r]) "≠" (num "0")))]
         ":="
         (Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(Tactic.simp
              "simp"
              []
              []
              []
              ["["
               [(Tactic.simpLemma [] [] `IsROrC.abs_eq_zero) "," (Tactic.simpLemma [] [] `hr)]
               "]"]
              [])]))))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           []
           ["[" [(Tactic.simpLemma [] [] `IsROrC.abs_eq_zero) "," (Tactic.simpLemma [] [] `hr)] "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       []
       ["[" [(Tactic.simpLemma [] [] `IsROrC.abs_eq_zero) "," (Tactic.simpLemma [] [] `hr)] "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hr
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `IsROrC.abs_eq_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_≠_» (Term.app `abs [`r]) "≠" (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Term.app `abs [`r])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `r
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `abs
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1022, (some 1023, term) <=? (some 50, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 50, (some 51, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.tacticHave_
       "have"
       (Term.haveDecl
        (Term.haveIdDecl
         [`hx' []]
         [(Term.typeSpec
           ":"
           («term_≠_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "≠" (num "0")))]
         ":="
         (Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(Tactic.simp
              "simp"
              []
              []
              []
              ["[" [(Tactic.simpLemma [] [] `norm_eq_zero) "," (Tactic.simpLemma [] [] `hx)] "]"]
              [])]))))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           []
           ["[" [(Tactic.simpLemma [] [] `norm_eq_zero) "," (Tactic.simpLemma [] [] `hx)] "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       []
       ["[" [(Tactic.simpLemma [] [] `norm_eq_zero) "," (Tactic.simpLemma [] [] `hx)] "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hx
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `norm_eq_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_≠_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "≠" (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none, [anonymous]) <=? (some 50, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 50, (some 51, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       («term_/_»
        (Term.app
         `abs
         [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           `x
           ", "
           (Algebra.Group.Defs.«term_•_» `r " • " `x)
           "⟫")])
        "/"
        («term_*_»
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
         "*"
         (Analysis.Normed.Group.Basic.«term‖_‖»
          "‖"
          (Algebra.Group.Defs.«term_•_» `r " • " `x)
          "‖")))
       "="
       (num "1"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "1")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      («term_/_»
       (Term.app
        `abs
        [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          `x
          ", "
          (Algebra.Group.Defs.«term_•_» `r " • " `x)
          "⟫")])
       "/"
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Algebra.Group.Defs.«term_•_» `r " • " `x) "‖")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
       "*"
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Algebra.Group.Defs.«term_•_» `r " • " `x) "‖"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Algebra.Group.Defs.«term_•_» `r " • " `x) "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Algebra.Group.Defs.«term_•_» `r " • " `x)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 73 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 73, term))
      `r
[PrettyPrinter.parenthesize] ...precedences are 74 >? 1024, (none, [anonymous]) <=? (some 73, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 73, (some 73, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1024, (none, [anonymous]) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 71 >? 70, (some 71, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     («term_*_»
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
      "*"
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Algebra.Group.Defs.«term_•_» `r " • " `x) "‖"))
     ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Term.app
       `abs
       [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
         "⟪"
         `x
         ", "
         (Algebra.Group.Defs.«term_•_» `r " • " `x)
         "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
       "⟪"
       `x
       ", "
       (Algebra.Group.Defs.«term_•_» `r " • " `x)
       "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    The inner product of a nonzero vector with a nonzero multiple of
    itself, divided by the product of their norms, has absolute value
    1. -/
  theorem
    abs_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul
    { x : E } { r : 𝕜 } ( hx : x ≠ 0 ) ( hr : r ≠ 0 ) : abs ⟪ x , r • x ⟫ / ‖ x ‖ * ‖ r • x ‖ = 1
    :=
      by
        have hx' : ‖ x ‖ ≠ 0 := by simp [ norm_eq_zero , hx ]
          have hr' : abs r ≠ 0 := by simp [ IsROrC.abs_eq_zero , hr ]
          rw
            [
              inner_smul_right
                ,
                IsROrC.abs_mul
                ,
                ← inner_self_re_abs
                ,
                inner_self_eq_norm_mul_norm
                ,
                norm_smul
              ]
          rw
            [
              IsROrC.norm_eq_abs
                ,
                ← mul_assoc
                ,
                ← div_div
                ,
                mul_div_cancel _ hx'
                ,
                ← div_div
                ,
                mul_comm
                ,
                mul_div_cancel _ hr'
                ,
                div_self hx'
              ]
#align
  abs_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul abs_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "The inner product of a nonzero vector with a nonzero multiple of\nitself, divided by the product of their norms, has absolute value\n1. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `abs_real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x] [":" `F] "}")
        (Term.implicitBinder "{" [`r] [":" (Data.Real.Basic.termℝ "ℝ")] "}")
        (Term.explicitBinder "(" [`hx] [":" («term_≠_» `x "≠" (num "0"))] [] ")")
        (Term.explicitBinder "(" [`hr] [":" («term_≠_» `r "≠" (num "0"))] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         («term_/_»
          (Term.app
           (Analysis.InnerProductSpace.Basic.termabsR "absR")
           [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫_ℝ»
             "⟪"
             `x
             ", "
             (Algebra.Group.Defs.«term_•_» `r " • " `x)
             "⟫_ℝ")])
          "/"
          («term_*_»
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
           "*"
           (Analysis.Normed.Group.Basic.«term‖_‖»
            "‖"
            (Algebra.Group.Defs.«term_•_» `r " • " `x)
            "‖")))
         "="
         (num "1"))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `abs_to_real)]
             "]")
            [])
           []
           (Tactic.exact
            "exact"
            (Term.app `abs_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul [`hx `hr]))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `abs_to_real)]
            "]")
           [])
          []
          (Tactic.exact
           "exact"
           (Term.app `abs_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul [`hx `hr]))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact
       "exact"
       (Term.app `abs_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul [`hx `hr]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `abs_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul [`hx `hr])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hr
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `hx
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `abs_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq "[" [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `abs_to_real)] "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `abs_to_real
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       («term_/_»
        (Term.app
         (Analysis.InnerProductSpace.Basic.termabsR "absR")
         [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫_ℝ»
           "⟪"
           `x
           ", "
           (Algebra.Group.Defs.«term_•_» `r " • " `x)
           "⟫_ℝ")])
        "/"
        («term_*_»
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
         "*"
         (Analysis.Normed.Group.Basic.«term‖_‖»
          "‖"
          (Algebra.Group.Defs.«term_•_» `r " • " `x)
          "‖")))
       "="
       (num "1"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "1")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      («term_/_»
       (Term.app
        (Analysis.InnerProductSpace.Basic.termabsR "absR")
        [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫_ℝ»
          "⟪"
          `x
          ", "
          (Algebra.Group.Defs.«term_•_» `r " • " `x)
          "⟫_ℝ")])
       "/"
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Algebra.Group.Defs.«term_•_» `r " • " `x) "‖")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
       "*"
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Algebra.Group.Defs.«term_•_» `r " • " `x) "‖"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Algebra.Group.Defs.«term_•_» `r " • " `x) "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Algebra.Group.Defs.«term_•_» `r " • " `x)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 73 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 73, term))
      `r
[PrettyPrinter.parenthesize] ...precedences are 74 >? 1024, (none, [anonymous]) <=? (some 73, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 73, (some 73, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1024, (none, [anonymous]) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 71 >? 70, (some 71, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     («term_*_»
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
      "*"
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Algebra.Group.Defs.«term_•_» `r " • " `x) "‖"))
     ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Term.app
       (Analysis.InnerProductSpace.Basic.termabsR "absR")
       [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫_ℝ»
         "⟪"
         `x
         ", "
         (Algebra.Group.Defs.«term_•_» `r " • " `x)
         "⟫_ℝ")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫_ℝ»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫_ℝ»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫_ℝ»
       "⟪"
       `x
       ", "
       (Algebra.Group.Defs.«term_•_» `r " • " `x)
       "⟫_ℝ")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Algebra.Group.Defs.«term_•_» `r " • " `x)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 73 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 73, term))
      `r
[PrettyPrinter.parenthesize] ...precedences are 74 >? 1024, (none, [anonymous]) <=? (some 73, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 73, (some 73, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Analysis.InnerProductSpace.Basic.termabsR "absR")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.termabsR', expected 'Analysis.InnerProductSpace.Basic.termabsR._@.Analysis.InnerProductSpace.Basic._hyg.1003'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    The inner product of a nonzero vector with a nonzero multiple of
    itself, divided by the product of their norms, has absolute value
    1. -/
  theorem
    abs_real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul
    { x : F } { r : ℝ } ( hx : x ≠ 0 ) ( hr : r ≠ 0 ) : absR ⟪ x , r • x ⟫_ℝ / ‖ x ‖ * ‖ r • x ‖ = 1
    :=
      by
        rw [ ← abs_to_real ]
          exact abs_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul hx hr
#align
  abs_real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul abs_real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "The inner product of a nonzero vector with a positive multiple of\nitself, divided by the product of their norms, has value 1. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_pos_mul [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x] [":" `F] "}")
        (Term.implicitBinder "{" [`r] [":" (Data.Real.Basic.termℝ "ℝ")] "}")
        (Term.explicitBinder "(" [`hx] [":" («term_≠_» `x "≠" (num "0"))] [] ")")
        (Term.explicitBinder "(" [`hr] [":" («term_<_» (num "0") "<" `r)] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         («term_/_»
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫_ℝ»
           "⟪"
           `x
           ", "
           (Algebra.Group.Defs.«term_•_» `r " • " `x)
           "⟫_ℝ")
          "/"
          («term_*_»
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
           "*"
           (Analysis.Normed.Group.Basic.«term‖_‖»
            "‖"
            (Algebra.Group.Defs.«term_•_» `r " • " `x)
            "‖")))
         "="
         (num "1"))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [] `real_inner_smul_self_right)
              ","
              (Tactic.rwRule [] `norm_smul)
              ","
              (Tactic.rwRule [] `Real.norm_eq_abs)
              ","
              (Tactic.rwRule
               [(patternIgnore (token.«← » "←"))]
               (Term.app `mul_assoc [(Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")]))
              ","
              (Tactic.rwRule
               []
               (Term.app
                `mul_comm
                [(Term.hole "_")
                 (Term.app (Analysis.InnerProductSpace.Basic.termabsR "absR") [`r])]))
              ","
              (Tactic.rwRule [] `mul_assoc)
              ","
              (Tactic.rwRule [] (Term.app `_root_.abs_of_nonneg [(Term.app `le_of_lt [`hr])]))
              ","
              (Tactic.rwRule [] `div_self)]
             "]")
            [])
           []
           (Tactic.exact
            "exact"
            (Term.app
             `mul_ne_zero
             [(Term.app `ne_of_gt [`hr])
              (Term.fun
               "fun"
               (Term.basicFun
                [`h]
                []
                "=>"
                (Term.app
                 `hx
                 [(Term.app
                   (Term.proj `norm_eq_zero "." (fieldIdx "1"))
                   [(Term.app `eq_zero_of_mul_self_eq_zero [`h])])])))]))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] `real_inner_smul_self_right)
             ","
             (Tactic.rwRule [] `norm_smul)
             ","
             (Tactic.rwRule [] `Real.norm_eq_abs)
             ","
             (Tactic.rwRule
              [(patternIgnore (token.«← » "←"))]
              (Term.app `mul_assoc [(Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")]))
             ","
             (Tactic.rwRule
              []
              (Term.app
               `mul_comm
               [(Term.hole "_")
                (Term.app (Analysis.InnerProductSpace.Basic.termabsR "absR") [`r])]))
             ","
             (Tactic.rwRule [] `mul_assoc)
             ","
             (Tactic.rwRule [] (Term.app `_root_.abs_of_nonneg [(Term.app `le_of_lt [`hr])]))
             ","
             (Tactic.rwRule [] `div_self)]
            "]")
           [])
          []
          (Tactic.exact
           "exact"
           (Term.app
            `mul_ne_zero
            [(Term.app `ne_of_gt [`hr])
             (Term.fun
              "fun"
              (Term.basicFun
               [`h]
               []
               "=>"
               (Term.app
                `hx
                [(Term.app
                  (Term.proj `norm_eq_zero "." (fieldIdx "1"))
                  [(Term.app `eq_zero_of_mul_self_eq_zero [`h])])])))]))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact
       "exact"
       (Term.app
        `mul_ne_zero
        [(Term.app `ne_of_gt [`hr])
         (Term.fun
          "fun"
          (Term.basicFun
           [`h]
           []
           "=>"
           (Term.app
            `hx
            [(Term.app
              (Term.proj `norm_eq_zero "." (fieldIdx "1"))
              [(Term.app `eq_zero_of_mul_self_eq_zero [`h])])])))]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `mul_ne_zero
       [(Term.app `ne_of_gt [`hr])
        (Term.fun
         "fun"
         (Term.basicFun
          [`h]
          []
          "=>"
          (Term.app
           `hx
           [(Term.app
             (Term.proj `norm_eq_zero "." (fieldIdx "1"))
             [(Term.app `eq_zero_of_mul_self_eq_zero [`h])])])))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun
       "fun"
       (Term.basicFun
        [`h]
        []
        "=>"
        (Term.app
         `hx
         [(Term.app
           (Term.proj `norm_eq_zero "." (fieldIdx "1"))
           [(Term.app `eq_zero_of_mul_self_eq_zero [`h])])])))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `hx
       [(Term.app
         (Term.proj `norm_eq_zero "." (fieldIdx "1"))
         [(Term.app `eq_zero_of_mul_self_eq_zero [`h])])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       (Term.proj `norm_eq_zero "." (fieldIdx "1"))
       [(Term.app `eq_zero_of_mul_self_eq_zero [`h])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `eq_zero_of_mul_self_eq_zero [`h])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `eq_zero_of_mul_self_eq_zero
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app `eq_zero_of_mul_self_eq_zero [`h])
     ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.proj `norm_eq_zero "." (fieldIdx "1"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `norm_eq_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app
      (Term.proj `norm_eq_zero "." (fieldIdx "1"))
      [(Term.paren "(" (Term.app `eq_zero_of_mul_self_eq_zero [`h]) ")")])
     ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `hx
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.app `ne_of_gt [`hr])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hr
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `ne_of_gt
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `ne_of_gt [`hr]) ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `mul_ne_zero
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [] `real_inner_smul_self_right)
         ","
         (Tactic.rwRule [] `norm_smul)
         ","
         (Tactic.rwRule [] `Real.norm_eq_abs)
         ","
         (Tactic.rwRule
          [(patternIgnore (token.«← » "←"))]
          (Term.app `mul_assoc [(Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")]))
         ","
         (Tactic.rwRule
          []
          (Term.app
           `mul_comm
           [(Term.hole "_") (Term.app (Analysis.InnerProductSpace.Basic.termabsR "absR") [`r])]))
         ","
         (Tactic.rwRule [] `mul_assoc)
         ","
         (Tactic.rwRule [] (Term.app `_root_.abs_of_nonneg [(Term.app `le_of_lt [`hr])]))
         ","
         (Tactic.rwRule [] `div_self)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `div_self
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `_root_.abs_of_nonneg [(Term.app `le_of_lt [`hr])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `le_of_lt [`hr])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hr
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `le_of_lt
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `le_of_lt [`hr]) ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `_root_.abs_of_nonneg
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `mul_assoc
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `mul_comm
       [(Term.hole "_") (Term.app (Analysis.InnerProductSpace.Basic.termabsR "absR") [`r])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app (Analysis.InnerProductSpace.Basic.termabsR "absR") [`r])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `r
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Analysis.InnerProductSpace.Basic.termabsR "absR")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.termabsR', expected 'Analysis.InnerProductSpace.Basic.termabsR._@.Analysis.InnerProductSpace.Basic._hyg.1003'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    The inner product of a nonzero vector with a positive multiple of
    itself, divided by the product of their norms, has value 1. -/
  theorem
    real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_pos_mul
    { x : F } { r : ℝ } ( hx : x ≠ 0 ) ( hr : 0 < r ) : ⟪ x , r • x ⟫_ℝ / ‖ x ‖ * ‖ r • x ‖ = 1
    :=
      by
        rw
            [
              real_inner_smul_self_right
                ,
                norm_smul
                ,
                Real.norm_eq_abs
                ,
                ← mul_assoc ‖ x ‖
                ,
                mul_comm _ absR r
                ,
                mul_assoc
                ,
                _root_.abs_of_nonneg le_of_lt hr
                ,
                div_self
              ]
          exact mul_ne_zero ne_of_gt hr fun h => hx norm_eq_zero . 1 eq_zero_of_mul_self_eq_zero h
#align
  real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_pos_mul real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_pos_mul

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "The inner product of a nonzero vector with a negative multiple of\nitself, divided by the product of their norms, has value -1. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `real_inner_div_norm_mul_norm_eq_neg_one_of_ne_zero_of_neg_mul [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x] [":" `F] "}")
        (Term.implicitBinder "{" [`r] [":" (Data.Real.Basic.termℝ "ℝ")] "}")
        (Term.explicitBinder "(" [`hx] [":" («term_≠_» `x "≠" (num "0"))] [] ")")
        (Term.explicitBinder "(" [`hr] [":" («term_<_» `r "<" (num "0"))] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         («term_/_»
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫_ℝ»
           "⟪"
           `x
           ", "
           (Algebra.Group.Defs.«term_•_» `r " • " `x)
           "⟫_ℝ")
          "/"
          («term_*_»
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
           "*"
           (Analysis.Normed.Group.Basic.«term‖_‖»
            "‖"
            (Algebra.Group.Defs.«term_•_» `r " • " `x)
            "‖")))
         "="
         («term-_» "-" (num "1")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [] `real_inner_smul_self_right)
              ","
              (Tactic.rwRule [] `norm_smul)
              ","
              (Tactic.rwRule [] `Real.norm_eq_abs)
              ","
              (Tactic.rwRule
               [(patternIgnore (token.«← » "←"))]
               (Term.app `mul_assoc [(Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")]))
              ","
              (Tactic.rwRule
               []
               (Term.app
                `mul_comm
                [(Term.hole "_")
                 (Term.app (Analysis.InnerProductSpace.Basic.termabsR "absR") [`r])]))
              ","
              (Tactic.rwRule [] `mul_assoc)
              ","
              (Tactic.rwRule [] (Term.app `abs_of_neg [`hr]))
              ","
              (Tactic.rwRule [] `neg_mul)
              ","
              (Tactic.rwRule [] `div_neg_eq_neg_div)
              ","
              (Tactic.rwRule [] `div_self)]
             "]")
            [])
           []
           (Tactic.exact
            "exact"
            (Term.app
             `mul_ne_zero
             [(Term.app `ne_of_lt [`hr])
              (Term.fun
               "fun"
               (Term.basicFun
                [`h]
                []
                "=>"
                (Term.app
                 `hx
                 [(Term.app
                   (Term.proj `norm_eq_zero "." (fieldIdx "1"))
                   [(Term.app `eq_zero_of_mul_self_eq_zero [`h])])])))]))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] `real_inner_smul_self_right)
             ","
             (Tactic.rwRule [] `norm_smul)
             ","
             (Tactic.rwRule [] `Real.norm_eq_abs)
             ","
             (Tactic.rwRule
              [(patternIgnore (token.«← » "←"))]
              (Term.app `mul_assoc [(Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")]))
             ","
             (Tactic.rwRule
              []
              (Term.app
               `mul_comm
               [(Term.hole "_")
                (Term.app (Analysis.InnerProductSpace.Basic.termabsR "absR") [`r])]))
             ","
             (Tactic.rwRule [] `mul_assoc)
             ","
             (Tactic.rwRule [] (Term.app `abs_of_neg [`hr]))
             ","
             (Tactic.rwRule [] `neg_mul)
             ","
             (Tactic.rwRule [] `div_neg_eq_neg_div)
             ","
             (Tactic.rwRule [] `div_self)]
            "]")
           [])
          []
          (Tactic.exact
           "exact"
           (Term.app
            `mul_ne_zero
            [(Term.app `ne_of_lt [`hr])
             (Term.fun
              "fun"
              (Term.basicFun
               [`h]
               []
               "=>"
               (Term.app
                `hx
                [(Term.app
                  (Term.proj `norm_eq_zero "." (fieldIdx "1"))
                  [(Term.app `eq_zero_of_mul_self_eq_zero [`h])])])))]))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact
       "exact"
       (Term.app
        `mul_ne_zero
        [(Term.app `ne_of_lt [`hr])
         (Term.fun
          "fun"
          (Term.basicFun
           [`h]
           []
           "=>"
           (Term.app
            `hx
            [(Term.app
              (Term.proj `norm_eq_zero "." (fieldIdx "1"))
              [(Term.app `eq_zero_of_mul_self_eq_zero [`h])])])))]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `mul_ne_zero
       [(Term.app `ne_of_lt [`hr])
        (Term.fun
         "fun"
         (Term.basicFun
          [`h]
          []
          "=>"
          (Term.app
           `hx
           [(Term.app
             (Term.proj `norm_eq_zero "." (fieldIdx "1"))
             [(Term.app `eq_zero_of_mul_self_eq_zero [`h])])])))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun
       "fun"
       (Term.basicFun
        [`h]
        []
        "=>"
        (Term.app
         `hx
         [(Term.app
           (Term.proj `norm_eq_zero "." (fieldIdx "1"))
           [(Term.app `eq_zero_of_mul_self_eq_zero [`h])])])))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `hx
       [(Term.app
         (Term.proj `norm_eq_zero "." (fieldIdx "1"))
         [(Term.app `eq_zero_of_mul_self_eq_zero [`h])])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       (Term.proj `norm_eq_zero "." (fieldIdx "1"))
       [(Term.app `eq_zero_of_mul_self_eq_zero [`h])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `eq_zero_of_mul_self_eq_zero [`h])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `eq_zero_of_mul_self_eq_zero
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app `eq_zero_of_mul_self_eq_zero [`h])
     ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.proj `norm_eq_zero "." (fieldIdx "1"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `norm_eq_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app
      (Term.proj `norm_eq_zero "." (fieldIdx "1"))
      [(Term.paren "(" (Term.app `eq_zero_of_mul_self_eq_zero [`h]) ")")])
     ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `hx
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.app `ne_of_lt [`hr])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hr
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `ne_of_lt
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `ne_of_lt [`hr]) ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `mul_ne_zero
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [] `real_inner_smul_self_right)
         ","
         (Tactic.rwRule [] `norm_smul)
         ","
         (Tactic.rwRule [] `Real.norm_eq_abs)
         ","
         (Tactic.rwRule
          [(patternIgnore (token.«← » "←"))]
          (Term.app `mul_assoc [(Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")]))
         ","
         (Tactic.rwRule
          []
          (Term.app
           `mul_comm
           [(Term.hole "_") (Term.app (Analysis.InnerProductSpace.Basic.termabsR "absR") [`r])]))
         ","
         (Tactic.rwRule [] `mul_assoc)
         ","
         (Tactic.rwRule [] (Term.app `abs_of_neg [`hr]))
         ","
         (Tactic.rwRule [] `neg_mul)
         ","
         (Tactic.rwRule [] `div_neg_eq_neg_div)
         ","
         (Tactic.rwRule [] `div_self)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `div_self
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `div_neg_eq_neg_div
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `neg_mul
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `abs_of_neg [`hr])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hr
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `abs_of_neg
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `mul_assoc
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `mul_comm
       [(Term.hole "_") (Term.app (Analysis.InnerProductSpace.Basic.termabsR "absR") [`r])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app (Analysis.InnerProductSpace.Basic.termabsR "absR") [`r])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `r
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Analysis.InnerProductSpace.Basic.termabsR "absR")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.termabsR', expected 'Analysis.InnerProductSpace.Basic.termabsR._@.Analysis.InnerProductSpace.Basic._hyg.1003'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    The inner product of a nonzero vector with a negative multiple of
    itself, divided by the product of their norms, has value -1. -/
  theorem
    real_inner_div_norm_mul_norm_eq_neg_one_of_ne_zero_of_neg_mul
    { x : F } { r : ℝ } ( hx : x ≠ 0 ) ( hr : r < 0 ) : ⟪ x , r • x ⟫_ℝ / ‖ x ‖ * ‖ r • x ‖ = - 1
    :=
      by
        rw
            [
              real_inner_smul_self_right
                ,
                norm_smul
                ,
                Real.norm_eq_abs
                ,
                ← mul_assoc ‖ x ‖
                ,
                mul_comm _ absR r
                ,
                mul_assoc
                ,
                abs_of_neg hr
                ,
                neg_mul
                ,
                div_neg_eq_neg_div
                ,
                div_self
              ]
          exact mul_ne_zero ne_of_lt hr fun h => hx norm_eq_zero . 1 eq_zero_of_mul_self_eq_zero h
#align
  real_inner_div_norm_mul_norm_eq_neg_one_of_ne_zero_of_neg_mul real_inner_div_norm_mul_norm_eq_neg_one_of_ne_zero_of_neg_mul

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "The inner product of two vectors, divided by the product of their\nnorms, has absolute value 1 if and only if they are nonzero and one is\na multiple of the other. One form of equality case for Cauchy-Schwarz. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `abs_inner_div_norm_mul_norm_eq_one_iff [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x `y] [":" `E] [] ")")]
       (Term.typeSpec
        ":"
        («term_↔_»
         («term_=_»
          (Term.app
           `abs
           [(«term_/_»
             (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
             "/"
             («term_*_»
              (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
              "*"
              (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))])
          "="
          (num "1"))
         "↔"
         («term_∧_»
          («term_≠_» `x "≠" (num "0"))
          "∧"
          («term∃_,_»
           "∃"
           (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `r)] [":" `𝕜]))
           ","
           («term_∧_»
            («term_≠_» `r "≠" (num "0"))
            "∧"
            («term_=_» `y "=" (Algebra.Group.Defs.«term_•_» `r " • " `x))))))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.constructor "constructor")
           []
           (tactic__
            (cdotTk (patternIgnore (token.«· » "·")))
            [(Tactic.intro "intro" [`h])
             []
             (Tactic.tacticHave_
              "have"
              (Term.haveDecl
               (Term.haveIdDecl
                [`hx0 []]
                [(Term.typeSpec ":" («term_≠_» `x "≠" (num "0")))]
                ":="
                (Term.byTactic
                 "by"
                 (Tactic.tacticSeq
                  (Tactic.tacticSeq1Indented
                   [(Tactic.intro "intro" [`hx0])
                    []
                    (Tactic.rwSeq
                     "rw"
                     []
                     (Tactic.rwRuleSeq
                      "["
                      [(Tactic.rwRule [] `hx0)
                       ","
                       (Tactic.rwRule [] `inner_zero_left)
                       ","
                       (Tactic.rwRule [] `zero_div)]
                      "]")
                     [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
                    []
                    (Mathlib.Tactic.normNum
                     "norm_num"
                     []
                     []
                     [(Tactic.location "at" (Tactic.locationHyp [`h] []))])]))))))
             []
             (Tactic.refine' "refine'" (Term.app `And.intro [`hx0 (Term.hole "_")]))
             []
             (Mathlib.Tactic.set
              "set"
              []
              (Mathlib.Tactic.setArgsRest
               `r
               []
               ":="
               («term_/_»
                (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
                "/"
                («term_*_»
                 (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                 "*"
                 (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")))
               ["with" [] `hr]))
             []
             (Mathlib.Tactic.«tacticUse_,,» "use" [`r])
             []
             (Mathlib.Tactic.set
              "set"
              []
              (Mathlib.Tactic.setArgsRest
               `t
               []
               ":="
               («term_-_» `y "-" (Algebra.Group.Defs.«term_•_» `r " • " `x))
               ["with" [] `ht]))
             []
             (Tactic.tacticHave_
              "have"
              (Term.haveDecl
               (Term.haveIdDecl
                [`ht0 []]
                [(Term.typeSpec
                  ":"
                  («term_=_»
                   (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `t "⟫")
                   "="
                   (num "0")))]
                ":="
                (Term.byTactic
                 "by"
                 (Tactic.tacticSeq
                  (Tactic.tacticSeq1Indented
                   [(Tactic.rwSeq
                     "rw"
                     []
                     (Tactic.rwRuleSeq
                      "["
                      [(Tactic.rwRule [] `ht)
                       ","
                       (Tactic.rwRule [] `inner_sub_right)
                       ","
                       (Tactic.rwRule [] `inner_smul_right)
                       ","
                       (Tactic.rwRule [] `hr)]
                      "]")
                     [])
                    []
                    (Tactic.NormCast.tacticNorm_cast__ "norm_cast" [])
                    []
                    (Tactic.rwSeq
                     "rw"
                     []
                     (Tactic.rwRuleSeq
                      "["
                      [(Tactic.rwRule
                        [(patternIgnore (token.«← » "←"))]
                        `inner_self_eq_norm_mul_norm)
                       ","
                       (Tactic.rwRule [] `inner_self_re_to_K)
                       ","
                       (Tactic.rwRule
                        []
                        (Term.app
                         `div_mul_cancel
                         [(Term.hole "_")
                          (Term.fun
                           "fun"
                           (Term.basicFun
                            [`h]
                            []
                            "=>"
                            (Term.app
                             `hx0
                             [(Term.app
                               (Term.proj `inner_self_eq_zero "." (fieldIdx "1"))
                               [`h])])))]))
                       ","
                       (Tactic.rwRule [] `sub_self)]
                      "]")
                     [])]))))))
             []
             (Mathlib.Tactic.replace'
              "replace"
              [`h []]
              [(Term.typeSpec
                ":"
                («term_=_»
                 («term_/_»
                  (Analysis.Normed.Group.Basic.«term‖_‖»
                   "‖"
                   (Algebra.Group.Defs.«term_•_» `r " • " `x)
                   "‖")
                  "/"
                  (Analysis.Normed.Group.Basic.«term‖_‖»
                   "‖"
                   («term_+_» `t "+" (Algebra.Group.Defs.«term_•_» `r " • " `x))
                   "‖"))
                 "="
                 (num "1")))])
             []
             (tactic__
              (cdotTk (patternIgnore (token.«· » "·")))
              [(Tactic.rwSeq
                "rw"
                []
                (Tactic.rwRuleSeq
                 "["
                 [(Tactic.rwRule
                   [(patternIgnore (token.«← » "←"))]
                   (Term.app `sub_add_cancel [`y (Algebra.Group.Defs.«term_•_» `r " • " `x)]))
                  ","
                  (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `ht)
                  ","
                  (Tactic.rwRule [] `inner_add_right)
                  ","
                  (Tactic.rwRule [] `ht0)
                  ","
                  (Tactic.rwRule [] `zero_add)
                  ","
                  (Tactic.rwRule [] `inner_smul_right)
                  ","
                  (Tactic.rwRule [] `IsROrC.abs_div)
                  ","
                  (Tactic.rwRule [] `IsROrC.abs_mul)
                  ","
                  (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_self_re_abs)
                  ","
                  (Tactic.rwRule [] `inner_self_eq_norm_mul_norm)]
                 "]")
                [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
               []
               (Tactic.NormCast.tacticNorm_cast__
                "norm_cast"
                [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
               []
               (Std.Tactic.tacticRwa__
                "rwa"
                (Tactic.rwRuleSeq
                 "["
                 [(Tactic.rwRule [] `_root_.abs_mul)
                  ","
                  (Tactic.rwRule [] `abs_norm_eq_norm)
                  ","
                  (Tactic.rwRule [] `abs_norm_eq_norm)
                  ","
                  (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `mul_assoc)
                  ","
                  (Tactic.rwRule [] `mul_comm)
                  ","
                  (Tactic.rwRule
                   []
                   (Term.app
                    `mul_div_mul_left
                    [(Term.hole "_")
                     (Term.hole "_")
                     (Term.fun
                      "fun"
                      (Term.basicFun
                       [`h]
                       []
                       "=>"
                       (Term.app
                        `hx0
                        [(Term.app (Term.proj `norm_eq_zero "." (fieldIdx "1")) [`h])])))]))
                  ","
                  (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `IsROrC.norm_eq_abs)
                  ","
                  (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `norm_smul)]
                 "]")
                [(Tactic.location "at" (Tactic.locationHyp [`h] []))])])
             []
             (Tactic.tacticHave_
              "have"
              (Term.haveDecl
               (Term.haveIdDecl
                [`hr0 []]
                [(Term.typeSpec ":" («term_≠_» `r "≠" (num "0")))]
                ":="
                (Term.byTactic
                 "by"
                 (Tactic.tacticSeq
                  (Tactic.tacticSeq1Indented
                   [(Tactic.intro "intro" [`hr0])
                    []
                    (Tactic.rwSeq
                     "rw"
                     []
                     (Tactic.rwRuleSeq
                      "["
                      [(Tactic.rwRule [] `hr0)
                       ","
                       (Tactic.rwRule [] `zero_smul)
                       ","
                       (Tactic.rwRule [] `norm_zero)
                       ","
                       (Tactic.rwRule [] `zero_div)]
                      "]")
                     [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
                    []
                    (Mathlib.Tactic.normNum
                     "norm_num"
                     []
                     []
                     [(Tactic.location "at" (Tactic.locationHyp [`h] []))])]))))))
             []
             (Tactic.refine' "refine'" (Term.app `And.intro [`hr0 (Term.hole "_")]))
             []
             (Tactic.tacticHave_
              "have"
              (Term.haveDecl
               (Term.haveIdDecl
                [`h2 []]
                [(Term.typeSpec
                  ":"
                  («term_=_»
                   («term_^_»
                    (Analysis.Normed.Group.Basic.«term‖_‖»
                     "‖"
                     (Algebra.Group.Defs.«term_•_» `r " • " `x)
                     "‖")
                    "^"
                    (num "2"))
                   "="
                   («term_^_»
                    (Analysis.Normed.Group.Basic.«term‖_‖»
                     "‖"
                     («term_+_» `t "+" (Algebra.Group.Defs.«term_•_» `r " • " `x))
                     "‖")
                    "^"
                    (num "2"))))]
                ":="
                (Term.byTactic
                 "by"
                 (Tactic.tacticSeq
                  (Tactic.tacticSeq1Indented
                   [(Tactic.rwSeq
                     "rw"
                     []
                     (Tactic.rwRuleSeq
                      "["
                      [(Tactic.rwRule [] (Term.app `eq_of_div_eq_one [`h]))]
                      "]")
                     [])]))))))
             []
             (Mathlib.Tactic.replace'
              "replace"
              [`h2 []]
              [(Term.typeSpec
                ":"
                («term_=_»
                 (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                  "⟪"
                  (Algebra.Group.Defs.«term_•_» `r " • " `x)
                  ", "
                  (Algebra.Group.Defs.«term_•_» `r " • " `x)
                  "⟫")
                 "="
                 («term_+_»
                  («term_+_»
                   («term_+_»
                    (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `t ", " `t "⟫")
                    "+"
                    (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     `t
                     ", "
                     (Algebra.Group.Defs.«term_•_» `r " • " `x)
                     "⟫"))
                   "+"
                   (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                    "⟪"
                    (Algebra.Group.Defs.«term_•_» `r " • " `x)
                    ", "
                    `t
                    "⟫"))
                  "+"
                  (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                   "⟪"
                   (Algebra.Group.Defs.«term_•_» `r " • " `x)
                   ", "
                   (Algebra.Group.Defs.«term_•_» `r " • " `x)
                   "⟫"))))])
             []
             (tactic__
              (cdotTk (patternIgnore (token.«· » "·")))
              [(Tactic.rwSeq
                "rw"
                []
                (Tactic.rwRuleSeq
                 "["
                 [(Tactic.rwRule [] `sq)
                  ","
                  (Tactic.rwRule [] `sq)
                  ","
                  (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_self_eq_norm_mul_norm)
                  ","
                  (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_self_eq_norm_mul_norm)]
                 "]")
                [(Tactic.location "at" (Tactic.locationHyp [`h2] []))])
               []
               (Tactic.tacticHave_
                "have"
                (Term.haveDecl
                 (Term.haveIdDecl
                  [`h2' []]
                  []
                  ":="
                  (Term.app
                   `congr_arg
                   [(Term.fun
                     "fun"
                     (Term.basicFun
                      [`z]
                      [(Term.typeSpec ":" (Data.Real.Basic.termℝ "ℝ"))]
                      "=>"
                      (Term.typeAscription "(" `z ":" [`𝕜] ")")))
                    `h2]))))
               []
               (Mathlib.Tactic.tacticSimp_rw__
                "simp_rw"
                (Tactic.rwRuleSeq
                 "["
                 [(Tactic.rwRule [] `inner_self_re_to_K) "," (Tactic.rwRule [] `inner_add_add_self)]
                 "]")
                [(Tactic.location "at" (Tactic.locationHyp [`h2'] []))])
               []
               (Tactic.exact "exact" `h2')])
             []
             (Tactic.Conv.conv
              "conv"
              ["at" `h2]
              ["in"
               []
               (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                "⟪"
                (Algebra.Group.Defs.«term_•_» `r " • " `x)
                ", "
                `t
                "⟫")]
              "=>"
              (Tactic.Conv.convSeq
               (Tactic.Conv.convSeq1Indented
                [(Tactic.Conv.convRw__
                  "rw"
                  []
                  (Tactic.rwRuleSeq
                   "["
                   [(Tactic.rwRule [] `inner_smul_left)
                    ","
                    (Tactic.rwRule [] `ht0)
                    ","
                    (Tactic.rwRule [] `mul_zero)]
                   "]"))])))
             []
             (Mathlib.Tactic.tacticSymm_
              "symm"
              [(Tactic.location "at" (Tactic.locationHyp [`h2] []))])
             []
             (Tactic.tacticHave_
              "have"
              (Term.haveDecl
               (Term.haveIdDecl
                [`h₁ []]
                [(Term.typeSpec
                  ":"
                  («term_=_»
                   (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                    "⟪"
                    `t
                    ", "
                    (Algebra.Group.Defs.«term_•_» `r " • " `x)
                    "⟫")
                   "="
                   (num "0")))]
                ":="
                (Term.byTactic
                 "by"
                 (Tactic.tacticSeq
                  (Tactic.tacticSeq1Indented
                   [(Tactic.rwSeq
                     "rw"
                     []
                     (Tactic.rwRuleSeq
                      "["
                      [(Tactic.rwRule [] `inner_smul_right)
                       ","
                       (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
                       ","
                       (Tactic.rwRule [] `ht0)]
                      "]")
                     [])
                    []
                    (Tactic.simp "simp" [] [] [] [] [])]))))))
             []
             (Tactic.rwSeq
              "rw"
              []
              (Tactic.rwRuleSeq
               "["
               [(Tactic.rwRule [] `add_zero)
                ","
                (Tactic.rwRule [] `h₁)
                ","
                (Tactic.rwRule [] `add_left_eq_self)
                ","
                (Tactic.rwRule [] `add_zero)
                ","
                (Tactic.rwRule [] `inner_self_eq_zero)]
               "]")
              [(Tactic.location "at" (Tactic.locationHyp [`h2] []))])
             []
             (Tactic.rwSeq
              "rw"
              []
              (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `h2)] "]")
              [(Tactic.location "at" (Tactic.locationHyp [`ht] []))])
             []
             (Tactic.exact "exact" (Term.app `eq_of_sub_eq_zero [`ht.symm]))])
           []
           (tactic__
            (cdotTk (patternIgnore (token.«· » "·")))
            [(Tactic.intro "intro" [`h])
             []
             (Std.Tactic.rcases
              "rcases"
              [(Tactic.casesTarget [] `h)]
              ["with"
               (Std.Tactic.RCases.rcasesPatLo
                (Std.Tactic.RCases.rcasesPatMed
                 [(Std.Tactic.RCases.rcasesPat.tuple
                   "⟨"
                   [(Std.Tactic.RCases.rcasesPatLo
                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx)])
                     [])
                    ","
                    (Std.Tactic.RCases.rcasesPatLo
                     (Std.Tactic.RCases.rcasesPatMed
                      [(Std.Tactic.RCases.rcasesPat.tuple
                        "⟨"
                        [(Std.Tactic.RCases.rcasesPatLo
                          (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `r)])
                          [])
                         ","
                         (Std.Tactic.RCases.rcasesPatLo
                          (Std.Tactic.RCases.rcasesPatMed
                           [(Std.Tactic.RCases.rcasesPat.tuple
                             "⟨"
                             [(Std.Tactic.RCases.rcasesPatLo
                               (Std.Tactic.RCases.rcasesPatMed
                                [(Std.Tactic.RCases.rcasesPat.one `hr)])
                               [])
                              ","
                              (Std.Tactic.RCases.rcasesPatLo
                               (Std.Tactic.RCases.rcasesPatMed
                                [(Std.Tactic.RCases.rcasesPat.one `hy)])
                               [])]
                             "⟩")])
                          [])]
                        "⟩")])
                     [])]
                   "⟩")])
                [])])
             []
             (Tactic.rwSeq
              "rw"
              []
              (Tactic.rwRuleSeq
               "["
               [(Tactic.rwRule [] `hy) "," (Tactic.rwRule [] `IsROrC.abs_div)]
               "]")
              [])
             []
             (Tactic.NormCast.tacticNorm_cast__ "norm_cast" [])
             []
             (Tactic.rwSeq
              "rw"
              []
              (Tactic.rwRuleSeq
               "["
               [(Tactic.rwRule [] `_root_.abs_mul)
                ","
                (Tactic.rwRule [] `abs_norm_eq_norm)
                ","
                (Tactic.rwRule [] `abs_norm_eq_norm)]
               "]")
              [])
             []
             (Tactic.exact
              "exact"
              (Term.app
               `abs_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul
               [`hx `hr]))])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.constructor "constructor")
          []
          (tactic__
           (cdotTk (patternIgnore (token.«· » "·")))
           [(Tactic.intro "intro" [`h])
            []
            (Tactic.tacticHave_
             "have"
             (Term.haveDecl
              (Term.haveIdDecl
               [`hx0 []]
               [(Term.typeSpec ":" («term_≠_» `x "≠" (num "0")))]
               ":="
               (Term.byTactic
                "by"
                (Tactic.tacticSeq
                 (Tactic.tacticSeq1Indented
                  [(Tactic.intro "intro" [`hx0])
                   []
                   (Tactic.rwSeq
                    "rw"
                    []
                    (Tactic.rwRuleSeq
                     "["
                     [(Tactic.rwRule [] `hx0)
                      ","
                      (Tactic.rwRule [] `inner_zero_left)
                      ","
                      (Tactic.rwRule [] `zero_div)]
                     "]")
                    [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
                   []
                   (Mathlib.Tactic.normNum
                    "norm_num"
                    []
                    []
                    [(Tactic.location "at" (Tactic.locationHyp [`h] []))])]))))))
            []
            (Tactic.refine' "refine'" (Term.app `And.intro [`hx0 (Term.hole "_")]))
            []
            (Mathlib.Tactic.set
             "set"
             []
             (Mathlib.Tactic.setArgsRest
              `r
              []
              ":="
              («term_/_»
               (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
               "/"
               («term_*_»
                (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                "*"
                (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")))
              ["with" [] `hr]))
            []
            (Mathlib.Tactic.«tacticUse_,,» "use" [`r])
            []
            (Mathlib.Tactic.set
             "set"
             []
             (Mathlib.Tactic.setArgsRest
              `t
              []
              ":="
              («term_-_» `y "-" (Algebra.Group.Defs.«term_•_» `r " • " `x))
              ["with" [] `ht]))
            []
            (Tactic.tacticHave_
             "have"
             (Term.haveDecl
              (Term.haveIdDecl
               [`ht0 []]
               [(Term.typeSpec
                 ":"
                 («term_=_»
                  (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `t "⟫")
                  "="
                  (num "0")))]
               ":="
               (Term.byTactic
                "by"
                (Tactic.tacticSeq
                 (Tactic.tacticSeq1Indented
                  [(Tactic.rwSeq
                    "rw"
                    []
                    (Tactic.rwRuleSeq
                     "["
                     [(Tactic.rwRule [] `ht)
                      ","
                      (Tactic.rwRule [] `inner_sub_right)
                      ","
                      (Tactic.rwRule [] `inner_smul_right)
                      ","
                      (Tactic.rwRule [] `hr)]
                     "]")
                    [])
                   []
                   (Tactic.NormCast.tacticNorm_cast__ "norm_cast" [])
                   []
                   (Tactic.rwSeq
                    "rw"
                    []
                    (Tactic.rwRuleSeq
                     "["
                     [(Tactic.rwRule
                       [(patternIgnore (token.«← » "←"))]
                       `inner_self_eq_norm_mul_norm)
                      ","
                      (Tactic.rwRule [] `inner_self_re_to_K)
                      ","
                      (Tactic.rwRule
                       []
                       (Term.app
                        `div_mul_cancel
                        [(Term.hole "_")
                         (Term.fun
                          "fun"
                          (Term.basicFun
                           [`h]
                           []
                           "=>"
                           (Term.app
                            `hx0
                            [(Term.app
                              (Term.proj `inner_self_eq_zero "." (fieldIdx "1"))
                              [`h])])))]))
                      ","
                      (Tactic.rwRule [] `sub_self)]
                     "]")
                    [])]))))))
            []
            (Mathlib.Tactic.replace'
             "replace"
             [`h []]
             [(Term.typeSpec
               ":"
               («term_=_»
                («term_/_»
                 (Analysis.Normed.Group.Basic.«term‖_‖»
                  "‖"
                  (Algebra.Group.Defs.«term_•_» `r " • " `x)
                  "‖")
                 "/"
                 (Analysis.Normed.Group.Basic.«term‖_‖»
                  "‖"
                  («term_+_» `t "+" (Algebra.Group.Defs.«term_•_» `r " • " `x))
                  "‖"))
                "="
                (num "1")))])
            []
            (tactic__
             (cdotTk (patternIgnore (token.«· » "·")))
             [(Tactic.rwSeq
               "rw"
               []
               (Tactic.rwRuleSeq
                "["
                [(Tactic.rwRule
                  [(patternIgnore (token.«← » "←"))]
                  (Term.app `sub_add_cancel [`y (Algebra.Group.Defs.«term_•_» `r " • " `x)]))
                 ","
                 (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `ht)
                 ","
                 (Tactic.rwRule [] `inner_add_right)
                 ","
                 (Tactic.rwRule [] `ht0)
                 ","
                 (Tactic.rwRule [] `zero_add)
                 ","
                 (Tactic.rwRule [] `inner_smul_right)
                 ","
                 (Tactic.rwRule [] `IsROrC.abs_div)
                 ","
                 (Tactic.rwRule [] `IsROrC.abs_mul)
                 ","
                 (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_self_re_abs)
                 ","
                 (Tactic.rwRule [] `inner_self_eq_norm_mul_norm)]
                "]")
               [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
              []
              (Tactic.NormCast.tacticNorm_cast__
               "norm_cast"
               [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
              []
              (Std.Tactic.tacticRwa__
               "rwa"
               (Tactic.rwRuleSeq
                "["
                [(Tactic.rwRule [] `_root_.abs_mul)
                 ","
                 (Tactic.rwRule [] `abs_norm_eq_norm)
                 ","
                 (Tactic.rwRule [] `abs_norm_eq_norm)
                 ","
                 (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `mul_assoc)
                 ","
                 (Tactic.rwRule [] `mul_comm)
                 ","
                 (Tactic.rwRule
                  []
                  (Term.app
                   `mul_div_mul_left
                   [(Term.hole "_")
                    (Term.hole "_")
                    (Term.fun
                     "fun"
                     (Term.basicFun
                      [`h]
                      []
                      "=>"
                      (Term.app
                       `hx0
                       [(Term.app (Term.proj `norm_eq_zero "." (fieldIdx "1")) [`h])])))]))
                 ","
                 (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `IsROrC.norm_eq_abs)
                 ","
                 (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `norm_smul)]
                "]")
               [(Tactic.location "at" (Tactic.locationHyp [`h] []))])])
            []
            (Tactic.tacticHave_
             "have"
             (Term.haveDecl
              (Term.haveIdDecl
               [`hr0 []]
               [(Term.typeSpec ":" («term_≠_» `r "≠" (num "0")))]
               ":="
               (Term.byTactic
                "by"
                (Tactic.tacticSeq
                 (Tactic.tacticSeq1Indented
                  [(Tactic.intro "intro" [`hr0])
                   []
                   (Tactic.rwSeq
                    "rw"
                    []
                    (Tactic.rwRuleSeq
                     "["
                     [(Tactic.rwRule [] `hr0)
                      ","
                      (Tactic.rwRule [] `zero_smul)
                      ","
                      (Tactic.rwRule [] `norm_zero)
                      ","
                      (Tactic.rwRule [] `zero_div)]
                     "]")
                    [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
                   []
                   (Mathlib.Tactic.normNum
                    "norm_num"
                    []
                    []
                    [(Tactic.location "at" (Tactic.locationHyp [`h] []))])]))))))
            []
            (Tactic.refine' "refine'" (Term.app `And.intro [`hr0 (Term.hole "_")]))
            []
            (Tactic.tacticHave_
             "have"
             (Term.haveDecl
              (Term.haveIdDecl
               [`h2 []]
               [(Term.typeSpec
                 ":"
                 («term_=_»
                  («term_^_»
                   (Analysis.Normed.Group.Basic.«term‖_‖»
                    "‖"
                    (Algebra.Group.Defs.«term_•_» `r " • " `x)
                    "‖")
                   "^"
                   (num "2"))
                  "="
                  («term_^_»
                   (Analysis.Normed.Group.Basic.«term‖_‖»
                    "‖"
                    («term_+_» `t "+" (Algebra.Group.Defs.«term_•_» `r " • " `x))
                    "‖")
                   "^"
                   (num "2"))))]
               ":="
               (Term.byTactic
                "by"
                (Tactic.tacticSeq
                 (Tactic.tacticSeq1Indented
                  [(Tactic.rwSeq
                    "rw"
                    []
                    (Tactic.rwRuleSeq
                     "["
                     [(Tactic.rwRule [] (Term.app `eq_of_div_eq_one [`h]))]
                     "]")
                    [])]))))))
            []
            (Mathlib.Tactic.replace'
             "replace"
             [`h2 []]
             [(Term.typeSpec
               ":"
               («term_=_»
                (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                 "⟪"
                 (Algebra.Group.Defs.«term_•_» `r " • " `x)
                 ", "
                 (Algebra.Group.Defs.«term_•_» `r " • " `x)
                 "⟫")
                "="
                («term_+_»
                 («term_+_»
                  («term_+_»
                   (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `t ", " `t "⟫")
                   "+"
                   (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                    "⟪"
                    `t
                    ", "
                    (Algebra.Group.Defs.«term_•_» `r " • " `x)
                    "⟫"))
                  "+"
                  (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                   "⟪"
                   (Algebra.Group.Defs.«term_•_» `r " • " `x)
                   ", "
                   `t
                   "⟫"))
                 "+"
                 (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                  "⟪"
                  (Algebra.Group.Defs.«term_•_» `r " • " `x)
                  ", "
                  (Algebra.Group.Defs.«term_•_» `r " • " `x)
                  "⟫"))))])
            []
            (tactic__
             (cdotTk (patternIgnore (token.«· » "·")))
             [(Tactic.rwSeq
               "rw"
               []
               (Tactic.rwRuleSeq
                "["
                [(Tactic.rwRule [] `sq)
                 ","
                 (Tactic.rwRule [] `sq)
                 ","
                 (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_self_eq_norm_mul_norm)
                 ","
                 (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_self_eq_norm_mul_norm)]
                "]")
               [(Tactic.location "at" (Tactic.locationHyp [`h2] []))])
              []
              (Tactic.tacticHave_
               "have"
               (Term.haveDecl
                (Term.haveIdDecl
                 [`h2' []]
                 []
                 ":="
                 (Term.app
                  `congr_arg
                  [(Term.fun
                    "fun"
                    (Term.basicFun
                     [`z]
                     [(Term.typeSpec ":" (Data.Real.Basic.termℝ "ℝ"))]
                     "=>"
                     (Term.typeAscription "(" `z ":" [`𝕜] ")")))
                   `h2]))))
              []
              (Mathlib.Tactic.tacticSimp_rw__
               "simp_rw"
               (Tactic.rwRuleSeq
                "["
                [(Tactic.rwRule [] `inner_self_re_to_K) "," (Tactic.rwRule [] `inner_add_add_self)]
                "]")
               [(Tactic.location "at" (Tactic.locationHyp [`h2'] []))])
              []
              (Tactic.exact "exact" `h2')])
            []
            (Tactic.Conv.conv
             "conv"
             ["at" `h2]
             ["in"
              []
              (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
               "⟪"
               (Algebra.Group.Defs.«term_•_» `r " • " `x)
               ", "
               `t
               "⟫")]
             "=>"
             (Tactic.Conv.convSeq
              (Tactic.Conv.convSeq1Indented
               [(Tactic.Conv.convRw__
                 "rw"
                 []
                 (Tactic.rwRuleSeq
                  "["
                  [(Tactic.rwRule [] `inner_smul_left)
                   ","
                   (Tactic.rwRule [] `ht0)
                   ","
                   (Tactic.rwRule [] `mul_zero)]
                  "]"))])))
            []
            (Mathlib.Tactic.tacticSymm_
             "symm"
             [(Tactic.location "at" (Tactic.locationHyp [`h2] []))])
            []
            (Tactic.tacticHave_
             "have"
             (Term.haveDecl
              (Term.haveIdDecl
               [`h₁ []]
               [(Term.typeSpec
                 ":"
                 («term_=_»
                  (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                   "⟪"
                   `t
                   ", "
                   (Algebra.Group.Defs.«term_•_» `r " • " `x)
                   "⟫")
                  "="
                  (num "0")))]
               ":="
               (Term.byTactic
                "by"
                (Tactic.tacticSeq
                 (Tactic.tacticSeq1Indented
                  [(Tactic.rwSeq
                    "rw"
                    []
                    (Tactic.rwRuleSeq
                     "["
                     [(Tactic.rwRule [] `inner_smul_right)
                      ","
                      (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
                      ","
                      (Tactic.rwRule [] `ht0)]
                     "]")
                    [])
                   []
                   (Tactic.simp "simp" [] [] [] [] [])]))))))
            []
            (Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq
              "["
              [(Tactic.rwRule [] `add_zero)
               ","
               (Tactic.rwRule [] `h₁)
               ","
               (Tactic.rwRule [] `add_left_eq_self)
               ","
               (Tactic.rwRule [] `add_zero)
               ","
               (Tactic.rwRule [] `inner_self_eq_zero)]
              "]")
             [(Tactic.location "at" (Tactic.locationHyp [`h2] []))])
            []
            (Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `h2)] "]")
             [(Tactic.location "at" (Tactic.locationHyp [`ht] []))])
            []
            (Tactic.exact "exact" (Term.app `eq_of_sub_eq_zero [`ht.symm]))])
          []
          (tactic__
           (cdotTk (patternIgnore (token.«· » "·")))
           [(Tactic.intro "intro" [`h])
            []
            (Std.Tactic.rcases
             "rcases"
             [(Tactic.casesTarget [] `h)]
             ["with"
              (Std.Tactic.RCases.rcasesPatLo
               (Std.Tactic.RCases.rcasesPatMed
                [(Std.Tactic.RCases.rcasesPat.tuple
                  "⟨"
                  [(Std.Tactic.RCases.rcasesPatLo
                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx)])
                    [])
                   ","
                   (Std.Tactic.RCases.rcasesPatLo
                    (Std.Tactic.RCases.rcasesPatMed
                     [(Std.Tactic.RCases.rcasesPat.tuple
                       "⟨"
                       [(Std.Tactic.RCases.rcasesPatLo
                         (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `r)])
                         [])
                        ","
                        (Std.Tactic.RCases.rcasesPatLo
                         (Std.Tactic.RCases.rcasesPatMed
                          [(Std.Tactic.RCases.rcasesPat.tuple
                            "⟨"
                            [(Std.Tactic.RCases.rcasesPatLo
                              (Std.Tactic.RCases.rcasesPatMed
                               [(Std.Tactic.RCases.rcasesPat.one `hr)])
                              [])
                             ","
                             (Std.Tactic.RCases.rcasesPatLo
                              (Std.Tactic.RCases.rcasesPatMed
                               [(Std.Tactic.RCases.rcasesPat.one `hy)])
                              [])]
                            "⟩")])
                         [])]
                       "⟩")])
                    [])]
                  "⟩")])
               [])])
            []
            (Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq
              "["
              [(Tactic.rwRule [] `hy) "," (Tactic.rwRule [] `IsROrC.abs_div)]
              "]")
             [])
            []
            (Tactic.NormCast.tacticNorm_cast__ "norm_cast" [])
            []
            (Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq
              "["
              [(Tactic.rwRule [] `_root_.abs_mul)
               ","
               (Tactic.rwRule [] `abs_norm_eq_norm)
               ","
               (Tactic.rwRule [] `abs_norm_eq_norm)]
              "]")
             [])
            []
            (Tactic.exact
             "exact"
             (Term.app
              `abs_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul
              [`hx `hr]))])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.«· » "·")))
       [(Tactic.intro "intro" [`h])
        []
        (Std.Tactic.rcases
         "rcases"
         [(Tactic.casesTarget [] `h)]
         ["with"
          (Std.Tactic.RCases.rcasesPatLo
           (Std.Tactic.RCases.rcasesPatMed
            [(Std.Tactic.RCases.rcasesPat.tuple
              "⟨"
              [(Std.Tactic.RCases.rcasesPatLo
                (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx)])
                [])
               ","
               (Std.Tactic.RCases.rcasesPatLo
                (Std.Tactic.RCases.rcasesPatMed
                 [(Std.Tactic.RCases.rcasesPat.tuple
                   "⟨"
                   [(Std.Tactic.RCases.rcasesPatLo
                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `r)])
                     [])
                    ","
                    (Std.Tactic.RCases.rcasesPatLo
                     (Std.Tactic.RCases.rcasesPatMed
                      [(Std.Tactic.RCases.rcasesPat.tuple
                        "⟨"
                        [(Std.Tactic.RCases.rcasesPatLo
                          (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hr)])
                          [])
                         ","
                         (Std.Tactic.RCases.rcasesPatLo
                          (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hy)])
                          [])]
                        "⟩")])
                     [])]
                   "⟩")])
                [])]
              "⟩")])
           [])])
        []
        (Tactic.rwSeq
         "rw"
         []
         (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `hy) "," (Tactic.rwRule [] `IsROrC.abs_div)] "]")
         [])
        []
        (Tactic.NormCast.tacticNorm_cast__ "norm_cast" [])
        []
        (Tactic.rwSeq
         "rw"
         []
         (Tactic.rwRuleSeq
          "["
          [(Tactic.rwRule [] `_root_.abs_mul)
           ","
           (Tactic.rwRule [] `abs_norm_eq_norm)
           ","
           (Tactic.rwRule [] `abs_norm_eq_norm)]
          "]")
         [])
        []
        (Tactic.exact
         "exact"
         (Term.app `abs_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul [`hx `hr]))])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact
       "exact"
       (Term.app `abs_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul [`hx `hr]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `abs_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul [`hx `hr])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hr
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `hx
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `abs_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [] `_root_.abs_mul)
         ","
         (Tactic.rwRule [] `abs_norm_eq_norm)
         ","
         (Tactic.rwRule [] `abs_norm_eq_norm)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `abs_norm_eq_norm
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `abs_norm_eq_norm
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `_root_.abs_mul
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.NormCast.tacticNorm_cast__ "norm_cast" [])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `hy) "," (Tactic.rwRule [] `IsROrC.abs_div)] "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `IsROrC.abs_div
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hy
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Std.Tactic.rcases
       "rcases"
       [(Tactic.casesTarget [] `h)]
       ["with"
        (Std.Tactic.RCases.rcasesPatLo
         (Std.Tactic.RCases.rcasesPatMed
          [(Std.Tactic.RCases.rcasesPat.tuple
            "⟨"
            [(Std.Tactic.RCases.rcasesPatLo
              (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx)])
              [])
             ","
             (Std.Tactic.RCases.rcasesPatLo
              (Std.Tactic.RCases.rcasesPatMed
               [(Std.Tactic.RCases.rcasesPat.tuple
                 "⟨"
                 [(Std.Tactic.RCases.rcasesPatLo
                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `r)])
                   [])
                  ","
                  (Std.Tactic.RCases.rcasesPatLo
                   (Std.Tactic.RCases.rcasesPatMed
                    [(Std.Tactic.RCases.rcasesPat.tuple
                      "⟨"
                      [(Std.Tactic.RCases.rcasesPatLo
                        (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hr)])
                        [])
                       ","
                       (Std.Tactic.RCases.rcasesPatLo
                        (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hy)])
                        [])]
                      "⟩")])
                   [])]
                 "⟩")])
              [])]
            "⟩")])
         [])])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.intro "intro" [`h])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.«· » "·")))
       [(Tactic.intro "intro" [`h])
        []
        (Tactic.tacticHave_
         "have"
         (Term.haveDecl
          (Term.haveIdDecl
           [`hx0 []]
           [(Term.typeSpec ":" («term_≠_» `x "≠" (num "0")))]
           ":="
           (Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.intro "intro" [`hx0])
               []
               (Tactic.rwSeq
                "rw"
                []
                (Tactic.rwRuleSeq
                 "["
                 [(Tactic.rwRule [] `hx0)
                  ","
                  (Tactic.rwRule [] `inner_zero_left)
                  ","
                  (Tactic.rwRule [] `zero_div)]
                 "]")
                [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
               []
               (Mathlib.Tactic.normNum
                "norm_num"
                []
                []
                [(Tactic.location "at" (Tactic.locationHyp [`h] []))])]))))))
        []
        (Tactic.refine' "refine'" (Term.app `And.intro [`hx0 (Term.hole "_")]))
        []
        (Mathlib.Tactic.set
         "set"
         []
         (Mathlib.Tactic.setArgsRest
          `r
          []
          ":="
          («term_/_»
           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
           "/"
           («term_*_»
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
            "*"
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")))
          ["with" [] `hr]))
        []
        (Mathlib.Tactic.«tacticUse_,,» "use" [`r])
        []
        (Mathlib.Tactic.set
         "set"
         []
         (Mathlib.Tactic.setArgsRest
          `t
          []
          ":="
          («term_-_» `y "-" (Algebra.Group.Defs.«term_•_» `r " • " `x))
          ["with" [] `ht]))
        []
        (Tactic.tacticHave_
         "have"
         (Term.haveDecl
          (Term.haveIdDecl
           [`ht0 []]
           [(Term.typeSpec
             ":"
             («term_=_»
              (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `t "⟫")
              "="
              (num "0")))]
           ":="
           (Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.rwSeq
                "rw"
                []
                (Tactic.rwRuleSeq
                 "["
                 [(Tactic.rwRule [] `ht)
                  ","
                  (Tactic.rwRule [] `inner_sub_right)
                  ","
                  (Tactic.rwRule [] `inner_smul_right)
                  ","
                  (Tactic.rwRule [] `hr)]
                 "]")
                [])
               []
               (Tactic.NormCast.tacticNorm_cast__ "norm_cast" [])
               []
               (Tactic.rwSeq
                "rw"
                []
                (Tactic.rwRuleSeq
                 "["
                 [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_self_eq_norm_mul_norm)
                  ","
                  (Tactic.rwRule [] `inner_self_re_to_K)
                  ","
                  (Tactic.rwRule
                   []
                   (Term.app
                    `div_mul_cancel
                    [(Term.hole "_")
                     (Term.fun
                      "fun"
                      (Term.basicFun
                       [`h]
                       []
                       "=>"
                       (Term.app
                        `hx0
                        [(Term.app (Term.proj `inner_self_eq_zero "." (fieldIdx "1")) [`h])])))]))
                  ","
                  (Tactic.rwRule [] `sub_self)]
                 "]")
                [])]))))))
        []
        (Mathlib.Tactic.replace'
         "replace"
         [`h []]
         [(Term.typeSpec
           ":"
           («term_=_»
            («term_/_»
             (Analysis.Normed.Group.Basic.«term‖_‖»
              "‖"
              (Algebra.Group.Defs.«term_•_» `r " • " `x)
              "‖")
             "/"
             (Analysis.Normed.Group.Basic.«term‖_‖»
              "‖"
              («term_+_» `t "+" (Algebra.Group.Defs.«term_•_» `r " • " `x))
              "‖"))
            "="
            (num "1")))])
        []
        (tactic__
         (cdotTk (patternIgnore (token.«· » "·")))
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule
              [(patternIgnore (token.«← » "←"))]
              (Term.app `sub_add_cancel [`y (Algebra.Group.Defs.«term_•_» `r " • " `x)]))
             ","
             (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `ht)
             ","
             (Tactic.rwRule [] `inner_add_right)
             ","
             (Tactic.rwRule [] `ht0)
             ","
             (Tactic.rwRule [] `zero_add)
             ","
             (Tactic.rwRule [] `inner_smul_right)
             ","
             (Tactic.rwRule [] `IsROrC.abs_div)
             ","
             (Tactic.rwRule [] `IsROrC.abs_mul)
             ","
             (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_self_re_abs)
             ","
             (Tactic.rwRule [] `inner_self_eq_norm_mul_norm)]
            "]")
           [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
          []
          (Tactic.NormCast.tacticNorm_cast__
           "norm_cast"
           [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
          []
          (Std.Tactic.tacticRwa__
           "rwa"
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] `_root_.abs_mul)
             ","
             (Tactic.rwRule [] `abs_norm_eq_norm)
             ","
             (Tactic.rwRule [] `abs_norm_eq_norm)
             ","
             (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `mul_assoc)
             ","
             (Tactic.rwRule [] `mul_comm)
             ","
             (Tactic.rwRule
              []
              (Term.app
               `mul_div_mul_left
               [(Term.hole "_")
                (Term.hole "_")
                (Term.fun
                 "fun"
                 (Term.basicFun
                  [`h]
                  []
                  "=>"
                  (Term.app
                   `hx0
                   [(Term.app (Term.proj `norm_eq_zero "." (fieldIdx "1")) [`h])])))]))
             ","
             (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `IsROrC.norm_eq_abs)
             ","
             (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `norm_smul)]
            "]")
           [(Tactic.location "at" (Tactic.locationHyp [`h] []))])])
        []
        (Tactic.tacticHave_
         "have"
         (Term.haveDecl
          (Term.haveIdDecl
           [`hr0 []]
           [(Term.typeSpec ":" («term_≠_» `r "≠" (num "0")))]
           ":="
           (Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.intro "intro" [`hr0])
               []
               (Tactic.rwSeq
                "rw"
                []
                (Tactic.rwRuleSeq
                 "["
                 [(Tactic.rwRule [] `hr0)
                  ","
                  (Tactic.rwRule [] `zero_smul)
                  ","
                  (Tactic.rwRule [] `norm_zero)
                  ","
                  (Tactic.rwRule [] `zero_div)]
                 "]")
                [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
               []
               (Mathlib.Tactic.normNum
                "norm_num"
                []
                []
                [(Tactic.location "at" (Tactic.locationHyp [`h] []))])]))))))
        []
        (Tactic.refine' "refine'" (Term.app `And.intro [`hr0 (Term.hole "_")]))
        []
        (Tactic.tacticHave_
         "have"
         (Term.haveDecl
          (Term.haveIdDecl
           [`h2 []]
           [(Term.typeSpec
             ":"
             («term_=_»
              («term_^_»
               (Analysis.Normed.Group.Basic.«term‖_‖»
                "‖"
                (Algebra.Group.Defs.«term_•_» `r " • " `x)
                "‖")
               "^"
               (num "2"))
              "="
              («term_^_»
               (Analysis.Normed.Group.Basic.«term‖_‖»
                "‖"
                («term_+_» `t "+" (Algebra.Group.Defs.«term_•_» `r " • " `x))
                "‖")
               "^"
               (num "2"))))]
           ":="
           (Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.rwSeq
                "rw"
                []
                (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] (Term.app `eq_of_div_eq_one [`h]))] "]")
                [])]))))))
        []
        (Mathlib.Tactic.replace'
         "replace"
         [`h2 []]
         [(Term.typeSpec
           ":"
           («term_=_»
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             (Algebra.Group.Defs.«term_•_» `r " • " `x)
             ", "
             (Algebra.Group.Defs.«term_•_» `r " • " `x)
             "⟫")
            "="
            («term_+_»
             («term_+_»
              («term_+_»
               (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `t ", " `t "⟫")
               "+"
               (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                "⟪"
                `t
                ", "
                (Algebra.Group.Defs.«term_•_» `r " • " `x)
                "⟫"))
              "+"
              (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
               "⟪"
               (Algebra.Group.Defs.«term_•_» `r " • " `x)
               ", "
               `t
               "⟫"))
             "+"
             (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
              "⟪"
              (Algebra.Group.Defs.«term_•_» `r " • " `x)
              ", "
              (Algebra.Group.Defs.«term_•_» `r " • " `x)
              "⟫"))))])
        []
        (tactic__
         (cdotTk (patternIgnore (token.«· » "·")))
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] `sq)
             ","
             (Tactic.rwRule [] `sq)
             ","
             (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_self_eq_norm_mul_norm)
             ","
             (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_self_eq_norm_mul_norm)]
            "]")
           [(Tactic.location "at" (Tactic.locationHyp [`h2] []))])
          []
          (Tactic.tacticHave_
           "have"
           (Term.haveDecl
            (Term.haveIdDecl
             [`h2' []]
             []
             ":="
             (Term.app
              `congr_arg
              [(Term.fun
                "fun"
                (Term.basicFun
                 [`z]
                 [(Term.typeSpec ":" (Data.Real.Basic.termℝ "ℝ"))]
                 "=>"
                 (Term.typeAscription "(" `z ":" [`𝕜] ")")))
               `h2]))))
          []
          (Mathlib.Tactic.tacticSimp_rw__
           "simp_rw"
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] `inner_self_re_to_K) "," (Tactic.rwRule [] `inner_add_add_self)]
            "]")
           [(Tactic.location "at" (Tactic.locationHyp [`h2'] []))])
          []
          (Tactic.exact "exact" `h2')])
        []
        (Tactic.Conv.conv
         "conv"
         ["at" `h2]
         ["in"
          []
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           (Algebra.Group.Defs.«term_•_» `r " • " `x)
           ", "
           `t
           "⟫")]
         "=>"
         (Tactic.Conv.convSeq
          (Tactic.Conv.convSeq1Indented
           [(Tactic.Conv.convRw__
             "rw"
             []
             (Tactic.rwRuleSeq
              "["
              [(Tactic.rwRule [] `inner_smul_left)
               ","
               (Tactic.rwRule [] `ht0)
               ","
               (Tactic.rwRule [] `mul_zero)]
              "]"))])))
        []
        (Mathlib.Tactic.tacticSymm_ "symm" [(Tactic.location "at" (Tactic.locationHyp [`h2] []))])
        []
        (Tactic.tacticHave_
         "have"
         (Term.haveDecl
          (Term.haveIdDecl
           [`h₁ []]
           [(Term.typeSpec
             ":"
             («term_=_»
              (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
               "⟪"
               `t
               ", "
               (Algebra.Group.Defs.«term_•_» `r " • " `x)
               "⟫")
              "="
              (num "0")))]
           ":="
           (Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.rwSeq
                "rw"
                []
                (Tactic.rwRuleSeq
                 "["
                 [(Tactic.rwRule [] `inner_smul_right)
                  ","
                  (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
                  ","
                  (Tactic.rwRule [] `ht0)]
                 "]")
                [])
               []
               (Tactic.simp "simp" [] [] [] [] [])]))))))
        []
        (Tactic.rwSeq
         "rw"
         []
         (Tactic.rwRuleSeq
          "["
          [(Tactic.rwRule [] `add_zero)
           ","
           (Tactic.rwRule [] `h₁)
           ","
           (Tactic.rwRule [] `add_left_eq_self)
           ","
           (Tactic.rwRule [] `add_zero)
           ","
           (Tactic.rwRule [] `inner_self_eq_zero)]
          "]")
         [(Tactic.location "at" (Tactic.locationHyp [`h2] []))])
        []
        (Tactic.rwSeq
         "rw"
         []
         (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `h2)] "]")
         [(Tactic.location "at" (Tactic.locationHyp [`ht] []))])
        []
        (Tactic.exact "exact" (Term.app `eq_of_sub_eq_zero [`ht.symm]))])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact "exact" (Term.app `eq_of_sub_eq_zero [`ht.symm]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `eq_of_sub_eq_zero [`ht.symm])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `ht.symm
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `eq_of_sub_eq_zero
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `h2)] "]")
       [(Tactic.location "at" (Tactic.locationHyp [`ht] []))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.locationHyp', expected 'Lean.Parser.Tactic.locationWildcard'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `ht
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h2
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [] `add_zero)
         ","
         (Tactic.rwRule [] `h₁)
         ","
         (Tactic.rwRule [] `add_left_eq_self)
         ","
         (Tactic.rwRule [] `add_zero)
         ","
         (Tactic.rwRule [] `inner_self_eq_zero)]
        "]")
       [(Tactic.location "at" (Tactic.locationHyp [`h2] []))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.locationHyp', expected 'Lean.Parser.Tactic.locationWildcard'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h2
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_self_eq_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `add_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `add_left_eq_self
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h₁
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `add_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.tacticHave_
       "have"
       (Term.haveDecl
        (Term.haveIdDecl
         [`h₁ []]
         [(Term.typeSpec
           ":"
           («term_=_»
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             `t
             ", "
             (Algebra.Group.Defs.«term_•_» `r " • " `x)
             "⟫")
            "="
            (num "0")))]
         ":="
         (Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(Tactic.rwSeq
              "rw"
              []
              (Tactic.rwRuleSeq
               "["
               [(Tactic.rwRule [] `inner_smul_right)
                ","
                (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
                ","
                (Tactic.rwRule [] `ht0)]
               "]")
              [])
             []
             (Tactic.simp "simp" [] [] [] [] [])]))))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] `inner_smul_right)
             ","
             (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
             ","
             (Tactic.rwRule [] `ht0)]
            "]")
           [])
          []
          (Tactic.simp "simp" [] [] [] [] [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp "simp" [] [] [] [] [])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [] `inner_smul_right)
         ","
         (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `inner_conj_sym)
         ","
         (Tactic.rwRule [] `ht0)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `ht0
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_conj_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_smul_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        `t
        ", "
        (Algebra.Group.Defs.«term_•_» `r " • " `x)
        "⟫")
       "="
       (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
       "⟪"
       `t
       ", "
       (Algebra.Group.Defs.«term_•_» `r " • " `x)
       "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.haveIdDecl', expected 'Lean.Parser.Term.letPatDecl'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.haveIdDecl', expected 'Lean.Parser.Term.haveEqnsDecl'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    The inner product of two vectors, divided by the product of their
    norms, has absolute value 1 if and only if they are nonzero and one is
    a multiple of the other. One form of equality case for Cauchy-Schwarz. -/
  theorem
    abs_inner_div_norm_mul_norm_eq_one_iff
    ( x y : E ) : abs ⟪ x , y ⟫ / ‖ x ‖ * ‖ y ‖ = 1 ↔ x ≠ 0 ∧ ∃ r : 𝕜 , r ≠ 0 ∧ y = r • x
    :=
      by
        constructor
          ·
            intro h
              have
                hx0
                  : x ≠ 0
                  :=
                  by intro hx0 rw [ hx0 , inner_zero_left , zero_div ] at h norm_num at h
              refine' And.intro hx0 _
              set r := ⟪ x , y ⟫ / ‖ x ‖ * ‖ x ‖ with hr
              use r
              set t := y - r • x with ht
              have
                ht0
                  : ⟪ x , t ⟫ = 0
                  :=
                  by
                    rw [ ht , inner_sub_right , inner_smul_right , hr ]
                      norm_cast
                      rw
                        [
                          ← inner_self_eq_norm_mul_norm
                            ,
                            inner_self_re_to_K
                            ,
                            div_mul_cancel _ fun h => hx0 inner_self_eq_zero . 1 h
                            ,
                            sub_self
                          ]
              replace h : ‖ r • x ‖ / ‖ t + r • x ‖ = 1
              ·
                rw
                    [
                      ← sub_add_cancel y r • x
                        ,
                        ← ht
                        ,
                        inner_add_right
                        ,
                        ht0
                        ,
                        zero_add
                        ,
                        inner_smul_right
                        ,
                        IsROrC.abs_div
                        ,
                        IsROrC.abs_mul
                        ,
                        ← inner_self_re_abs
                        ,
                        inner_self_eq_norm_mul_norm
                      ]
                    at h
                  norm_cast at h
                  rwa
                    [
                      _root_.abs_mul
                        ,
                        abs_norm_eq_norm
                        ,
                        abs_norm_eq_norm
                        ,
                        ← mul_assoc
                        ,
                        mul_comm
                        ,
                        mul_div_mul_left _ _ fun h => hx0 norm_eq_zero . 1 h
                        ,
                        ← IsROrC.norm_eq_abs
                        ,
                        ← norm_smul
                      ]
                    at h
              have
                hr0
                  : r ≠ 0
                  :=
                  by intro hr0 rw [ hr0 , zero_smul , norm_zero , zero_div ] at h norm_num at h
              refine' And.intro hr0 _
              have h2 : ‖ r • x ‖ ^ 2 = ‖ t + r • x ‖ ^ 2 := by rw [ eq_of_div_eq_one h ]
              replace
                h2
                : ⟪ r • x , r • x ⟫ = ⟪ t , t ⟫ + ⟪ t , r • x ⟫ + ⟪ r • x , t ⟫ + ⟪ r • x , r • x ⟫
              ·
                rw [ sq , sq , ← inner_self_eq_norm_mul_norm , ← inner_self_eq_norm_mul_norm ] at h2
                  have h2' := congr_arg fun z : ℝ => ( z : 𝕜 ) h2
                  simp_rw [ inner_self_re_to_K , inner_add_add_self ] at h2'
                  exact h2'
              conv at h2 in ⟪ r • x , t ⟫ => rw [ inner_smul_left , ht0 , mul_zero ]
              symm at h2
              have
                h₁ : ⟪ t , r • x ⟫ = 0 := by rw [ inner_smul_right , ← inner_conj_sym , ht0 ] simp
              rw [ add_zero , h₁ , add_left_eq_self , add_zero , inner_self_eq_zero ] at h2
              rw [ h2 ] at ht
              exact eq_of_sub_eq_zero ht.symm
          ·
            intro h
              rcases h with ⟨ hx , ⟨ r , ⟨ hr , hy ⟩ ⟩ ⟩
              rw [ hy , IsROrC.abs_div ]
              norm_cast
              rw [ _root_.abs_mul , abs_norm_eq_norm , abs_norm_eq_norm ]
              exact abs_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul hx hr
#align abs_inner_div_norm_mul_norm_eq_one_iff abs_inner_div_norm_mul_norm_eq_one_iff

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "The inner product of two vectors, divided by the product of their\nnorms, has absolute value 1 if and only if they are nonzero and one is\na multiple of the other. One form of equality case for Cauchy-Schwarz. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `abs_real_inner_div_norm_mul_norm_eq_one_iff [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x `y] [":" `F] [] ")")]
       (Term.typeSpec
        ":"
        («term_↔_»
         («term_=_»
          (Term.app
           (Analysis.InnerProductSpace.Basic.termabsR "absR")
           [(«term_/_»
             (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫_ℝ» "⟪" `x ", " `y "⟫_ℝ")
             "/"
             («term_*_»
              (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
              "*"
              (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))])
          "="
          (num "1"))
         "↔"
         («term_∧_»
          («term_≠_» `x "≠" (num "0"))
          "∧"
          («term∃_,_»
           "∃"
           (Lean.explicitBinders
            (Lean.unbracketedExplicitBinders
             [(Lean.binderIdent `r)]
             [":" (Data.Real.Basic.termℝ "ℝ")]))
           ","
           («term_∧_»
            («term_≠_» `r "≠" (num "0"))
            "∧"
            («term_=_» `y "=" (Algebra.Group.Defs.«term_•_» `r " • " `x))))))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.tacticHave_
            "have"
            (Term.haveDecl
             (Term.haveIdDecl
              []
              []
              ":="
              (Term.app
               (Term.explicit "@" `abs_inner_div_norm_mul_norm_eq_one_iff)
               [(Data.Real.Basic.termℝ "ℝ") `F (Term.hole "_") (Term.hole "_") `x `y]))))
           []
           (Std.Tactic.Simpa.simpa
            "simpa"
            []
            []
            (Std.Tactic.Simpa.simpaArgsRest
             []
             []
             []
             [(Tactic.simpArgs "[" [(Tactic.simpLemma [] [] `coe_real_eq_id)] "]")]
             ["using" `this]))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.tacticHave_
           "have"
           (Term.haveDecl
            (Term.haveIdDecl
             []
             []
             ":="
             (Term.app
              (Term.explicit "@" `abs_inner_div_norm_mul_norm_eq_one_iff)
              [(Data.Real.Basic.termℝ "ℝ") `F (Term.hole "_") (Term.hole "_") `x `y]))))
          []
          (Std.Tactic.Simpa.simpa
           "simpa"
           []
           []
           (Std.Tactic.Simpa.simpaArgsRest
            []
            []
            []
            [(Tactic.simpArgs "[" [(Tactic.simpLemma [] [] `coe_real_eq_id)] "]")]
            ["using" `this]))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Std.Tactic.Simpa.simpa
       "simpa"
       []
       []
       (Std.Tactic.Simpa.simpaArgsRest
        []
        []
        []
        [(Tactic.simpArgs "[" [(Tactic.simpLemma [] [] `coe_real_eq_id)] "]")]
        ["using" `this]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `this
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `coe_real_eq_id
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.tacticHave_
       "have"
       (Term.haveDecl
        (Term.haveIdDecl
         []
         []
         ":="
         (Term.app
          (Term.explicit "@" `abs_inner_div_norm_mul_norm_eq_one_iff)
          [(Data.Real.Basic.termℝ "ℝ") `F (Term.hole "_") (Term.hole "_") `x `y]))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       (Term.explicit "@" `abs_inner_div_norm_mul_norm_eq_one_iff)
       [(Data.Real.Basic.termℝ "ℝ") `F (Term.hole "_") (Term.hole "_") `x `y])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      `F
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Data.Real.Basic.termℝ', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Data.Real.Basic.termℝ', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Data.Real.Basic.termℝ "ℝ")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.explicit "@" `abs_inner_div_norm_mul_norm_eq_one_iff)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `abs_inner_div_norm_mul_norm_eq_one_iff
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (some 1024,
     term) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_↔_»
       («term_=_»
        (Term.app
         (Analysis.InnerProductSpace.Basic.termabsR "absR")
         [(«term_/_»
           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫_ℝ» "⟪" `x ", " `y "⟫_ℝ")
           "/"
           («term_*_»
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
            "*"
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))])
        "="
        (num "1"))
       "↔"
       («term_∧_»
        («term_≠_» `x "≠" (num "0"))
        "∧"
        («term∃_,_»
         "∃"
         (Lean.explicitBinders
          (Lean.unbracketedExplicitBinders
           [(Lean.binderIdent `r)]
           [":" (Data.Real.Basic.termℝ "ℝ")]))
         ","
         («term_∧_»
          («term_≠_» `r "≠" (num "0"))
          "∧"
          («term_=_» `y "=" (Algebra.Group.Defs.«term_•_» `r " • " `x))))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_∧_»
       («term_≠_» `x "≠" (num "0"))
       "∧"
       («term∃_,_»
        "∃"
        (Lean.explicitBinders
         (Lean.unbracketedExplicitBinders
          [(Lean.binderIdent `r)]
          [":" (Data.Real.Basic.termℝ "ℝ")]))
        ","
        («term_∧_»
         («term_≠_» `r "≠" (num "0"))
         "∧"
         («term_=_» `y "=" (Algebra.Group.Defs.«term_•_» `r " • " `x)))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term∃_,_»
       "∃"
       (Lean.explicitBinders
        (Lean.unbracketedExplicitBinders [(Lean.binderIdent `r)] [":" (Data.Real.Basic.termℝ "ℝ")]))
       ","
       («term_∧_»
        («term_≠_» `r "≠" (num "0"))
        "∧"
        («term_=_» `y "=" (Algebra.Group.Defs.«term_•_» `r " • " `x))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_∧_»
       («term_≠_» `r "≠" (num "0"))
       "∧"
       («term_=_» `y "=" (Algebra.Group.Defs.«term_•_» `r " • " `x)))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_» `y "=" (Algebra.Group.Defs.«term_•_» `r " • " `x))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Algebra.Group.Defs.«term_•_» `r " • " `x)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 73 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 73, term))
      `r
[PrettyPrinter.parenthesize] ...precedences are 74 >? 1024, (none, [anonymous]) <=? (some 73, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 73, (some 73, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      `y
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none, [anonymous]) <=? (some 50, term)
[PrettyPrinter.parenthesize] ...precedences are 35 >? 50, (some 51, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 35, term))
      («term_≠_» `r "≠" (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      `r
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none, [anonymous]) <=? (some 50, term)
[PrettyPrinter.parenthesize] ...precedences are 36 >? 50, (some 51, term) <=? (some 35, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 35, (some 35, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'null', expected 'Lean.bracketedExplicitBinders'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Data.Real.Basic.termℝ "ℝ")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 35 >? 1022, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 35, term))
      («term_≠_» `x "≠" (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none, [anonymous]) <=? (some 50, term)
[PrettyPrinter.parenthesize] ...precedences are 36 >? 50, (some 51, term) <=? (some 35, term)
[PrettyPrinter.parenthesize] ...precedences are 21 >? 35, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 20, term))
      («term_=_»
       (Term.app
        (Analysis.InnerProductSpace.Basic.termabsR "absR")
        [(«term_/_»
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫_ℝ» "⟪" `x ", " `y "⟫_ℝ")
          "/"
          («term_*_»
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
           "*"
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))])
       "="
       (num "1"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "1")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Term.app
       (Analysis.InnerProductSpace.Basic.termabsR "absR")
       [(«term_/_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫_ℝ» "⟪" `x ", " `y "⟫_ℝ")
         "/"
         («term_*_»
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
          "*"
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_/_»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_/_»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_/_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫_ℝ» "⟪" `x ", " `y "⟫_ℝ")
       "/"
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
       "*"
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1024, (none, [anonymous]) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 71 >? 70, (some 71, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     («term_*_»
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
      "*"
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
     ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫_ℝ» "⟪" `x ", " `y "⟫_ℝ")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1024, (none, [anonymous]) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 70, (some 71, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     («term_/_»
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫_ℝ» "⟪" `x ", " `y "⟫_ℝ")
      "/"
      (Term.paren
       "("
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
       ")"))
     ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Analysis.InnerProductSpace.Basic.termabsR "absR")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.termabsR', expected 'Analysis.InnerProductSpace.Basic.termabsR._@.Analysis.InnerProductSpace.Basic._hyg.1003'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    The inner product of two vectors, divided by the product of their
    norms, has absolute value 1 if and only if they are nonzero and one is
    a multiple of the other. One form of equality case for Cauchy-Schwarz. -/
  theorem
    abs_real_inner_div_norm_mul_norm_eq_one_iff
    ( x y : F ) : absR ⟪ x , y ⟫_ℝ / ‖ x ‖ * ‖ y ‖ = 1 ↔ x ≠ 0 ∧ ∃ r : ℝ , r ≠ 0 ∧ y = r • x
    :=
      by
        have := @ abs_inner_div_norm_mul_norm_eq_one_iff ℝ F _ _ x y
          simpa [ coe_real_eq_id ] using this
#align abs_real_inner_div_norm_mul_norm_eq_one_iff abs_real_inner_div_norm_mul_norm_eq_one_iff

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "If the inner product of two vectors is equal to the product of their norms, then the two vectors\nare multiples of each other. One form of the equality case for Cauchy-Schwarz.\nCompare `inner_eq_norm_mul_iff`, which takes the stronger hypothesis `⟪x, y⟫ = ‖x‖ * ‖y‖`. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `abs_inner_eq_norm_iff [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x `y] [":" `E] [] ")")
        (Term.explicitBinder "(" [`hx0] [":" («term_≠_» `x "≠" (num "0"))] [] ")")
        (Term.explicitBinder "(" [`hy0] [":" («term_≠_» `y "≠" (num "0"))] [] ")")]
       (Term.typeSpec
        ":"
        («term_↔_»
         («term_=_»
          (Term.app `abs [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
          "="
          («term_*_»
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
           "*"
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
         "↔"
         («term∃_,_»
          "∃"
          (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `r)] [":" `𝕜]))
          ","
          («term_∧_»
           («term_≠_» `r "≠" (num "0"))
           "∧"
           («term_=_» `y "=" (Algebra.Group.Defs.«term_•_» `r " • " `x)))))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.tacticHave_
            "have"
            (Term.haveDecl
             (Term.haveIdDecl
              [`hxy0 []]
              [(Term.typeSpec
                ":"
                («term_≠_»
                 («term_*_»
                  (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                  "*"
                  (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
                 "≠"
                 (num "0")))]
              ":="
              (Term.app
               `mul_ne_zero
               [(Term.app (Term.proj `norm_eq_zero.not "." (fieldIdx "2")) [`hx0])
                (Term.app (Term.proj `norm_eq_zero.not "." (fieldIdx "2")) [`hy0])]))))
           []
           (Tactic.tacticHave_
            "have"
            (Term.haveDecl
             (Term.haveIdDecl
              [`h₁ []]
              [(Term.typeSpec
                ":"
                («term_↔_»
                 («term_=_»
                  (Term.app
                   `abs
                   [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
                  "="
                  («term_*_»
                   (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                   "*"
                   (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
                 "↔"
                 («term_=_»
                  (Term.app
                   `abs
                   [(«term_/_»
                     (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
                     "/"
                     («term_*_»
                      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                      "*"
                      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))])
                  "="
                  (num "1"))))]
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.rwSeq
                   "rw"
                   []
                   (Tactic.rwRuleSeq
                    "["
                    [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `algebraMap.coe_mul)
                     ","
                     (Tactic.rwRule [] `IsROrC.abs_div)
                     ","
                     (Tactic.rwRule [] `IsROrC.abs_of_nonneg)
                     ","
                     (Tactic.rwRule [] (Term.app `div_eq_one_iff_eq [`hxy0]))]
                    "]")
                   [])
                  []
                  (Mathlib.Tactic.Positivity.positivity "positivity")]))))))
           []
           (Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [] `h₁)
              ","
              (Tactic.rwRule [] (Term.app `abs_inner_div_norm_mul_norm_eq_one_iff [`x `y]))]
             "]")
            [])
           []
           (Tactic.exact "exact" (Term.app `and_iff_right [`hx0]))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.tacticHave_
           "have"
           (Term.haveDecl
            (Term.haveIdDecl
             [`hxy0 []]
             [(Term.typeSpec
               ":"
               («term_≠_»
                («term_*_»
                 (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                 "*"
                 (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
                "≠"
                (num "0")))]
             ":="
             (Term.app
              `mul_ne_zero
              [(Term.app (Term.proj `norm_eq_zero.not "." (fieldIdx "2")) [`hx0])
               (Term.app (Term.proj `norm_eq_zero.not "." (fieldIdx "2")) [`hy0])]))))
          []
          (Tactic.tacticHave_
           "have"
           (Term.haveDecl
            (Term.haveIdDecl
             [`h₁ []]
             [(Term.typeSpec
               ":"
               («term_↔_»
                («term_=_»
                 (Term.app `abs [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
                 "="
                 («term_*_»
                  (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                  "*"
                  (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
                "↔"
                («term_=_»
                 (Term.app
                  `abs
                  [(«term_/_»
                    (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
                    "/"
                    («term_*_»
                     (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                     "*"
                     (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))])
                 "="
                 (num "1"))))]
             ":="
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Tactic.rwSeq
                  "rw"
                  []
                  (Tactic.rwRuleSeq
                   "["
                   [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `algebraMap.coe_mul)
                    ","
                    (Tactic.rwRule [] `IsROrC.abs_div)
                    ","
                    (Tactic.rwRule [] `IsROrC.abs_of_nonneg)
                    ","
                    (Tactic.rwRule [] (Term.app `div_eq_one_iff_eq [`hxy0]))]
                   "]")
                  [])
                 []
                 (Mathlib.Tactic.Positivity.positivity "positivity")]))))))
          []
          (Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] `h₁)
             ","
             (Tactic.rwRule [] (Term.app `abs_inner_div_norm_mul_norm_eq_one_iff [`x `y]))]
            "]")
           [])
          []
          (Tactic.exact "exact" (Term.app `and_iff_right [`hx0]))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact "exact" (Term.app `and_iff_right [`hx0]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `and_iff_right [`hx0])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hx0
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `and_iff_right
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [] `h₁)
         ","
         (Tactic.rwRule [] (Term.app `abs_inner_div_norm_mul_norm_eq_one_iff [`x `y]))]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `abs_inner_div_norm_mul_norm_eq_one_iff [`x `y])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `abs_inner_div_norm_mul_norm_eq_one_iff
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h₁
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.tacticHave_
       "have"
       (Term.haveDecl
        (Term.haveIdDecl
         [`h₁ []]
         [(Term.typeSpec
           ":"
           («term_↔_»
            («term_=_»
             (Term.app `abs [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
             "="
             («term_*_»
              (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
              "*"
              (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
            "↔"
            («term_=_»
             (Term.app
              `abs
              [(«term_/_»
                (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
                "/"
                («term_*_»
                 (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                 "*"
                 (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))])
             "="
             (num "1"))))]
         ":="
         (Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(Tactic.rwSeq
              "rw"
              []
              (Tactic.rwRuleSeq
               "["
               [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `algebraMap.coe_mul)
                ","
                (Tactic.rwRule [] `IsROrC.abs_div)
                ","
                (Tactic.rwRule [] `IsROrC.abs_of_nonneg)
                ","
                (Tactic.rwRule [] (Term.app `div_eq_one_iff_eq [`hxy0]))]
               "]")
              [])
             []
             (Mathlib.Tactic.Positivity.positivity "positivity")]))))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `algebraMap.coe_mul)
             ","
             (Tactic.rwRule [] `IsROrC.abs_div)
             ","
             (Tactic.rwRule [] `IsROrC.abs_of_nonneg)
             ","
             (Tactic.rwRule [] (Term.app `div_eq_one_iff_eq [`hxy0]))]
            "]")
           [])
          []
          (Mathlib.Tactic.Positivity.positivity "positivity")])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.Positivity.positivity "positivity")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `algebraMap.coe_mul)
         ","
         (Tactic.rwRule [] `IsROrC.abs_div)
         ","
         (Tactic.rwRule [] `IsROrC.abs_of_nonneg)
         ","
         (Tactic.rwRule [] (Term.app `div_eq_one_iff_eq [`hxy0]))]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `div_eq_one_iff_eq [`hxy0])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hxy0
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `div_eq_one_iff_eq
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `IsROrC.abs_of_nonneg
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `IsROrC.abs_div
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `algebraMap.coe_mul
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_↔_»
       («term_=_»
        (Term.app `abs [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
        "="
        («term_*_»
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
         "*"
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
       "↔"
       («term_=_»
        (Term.app
         `abs
         [(«term_/_»
           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
           "/"
           («term_*_»
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
            "*"
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))])
        "="
        (num "1")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_»
       (Term.app
        `abs
        [(«term_/_»
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
          "/"
          («term_*_»
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
           "*"
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))])
       "="
       (num "1"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "1")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Term.app
       `abs
       [(«term_/_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
         "/"
         («term_*_»
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
          "*"
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_/_»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_/_»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_/_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
       "/"
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
       "*"
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1024, (none, [anonymous]) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 71 >? 70, (some 71, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     («term_*_»
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
      "*"
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
     ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.haveIdDecl', expected 'Lean.Parser.Term.letPatDecl'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.haveIdDecl', expected 'Lean.Parser.Term.haveEqnsDecl'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    If the inner product of two vectors is equal to the product of their norms, then the two vectors
    are multiples of each other. One form of the equality case for Cauchy-Schwarz.
    Compare `inner_eq_norm_mul_iff`, which takes the stronger hypothesis `⟪x, y⟫ = ‖x‖ * ‖y‖`. -/
  theorem
    abs_inner_eq_norm_iff
    ( x y : E ) ( hx0 : x ≠ 0 ) ( hy0 : y ≠ 0 )
      : abs ⟪ x , y ⟫ = ‖ x ‖ * ‖ y ‖ ↔ ∃ r : 𝕜 , r ≠ 0 ∧ y = r • x
    :=
      by
        have
            hxy0
              : ‖ x ‖ * ‖ y ‖ ≠ 0
              :=
              mul_ne_zero norm_eq_zero.not . 2 hx0 norm_eq_zero.not . 2 hy0
          have
            h₁
              : abs ⟪ x , y ⟫ = ‖ x ‖ * ‖ y ‖ ↔ abs ⟪ x , y ⟫ / ‖ x ‖ * ‖ y ‖ = 1
              :=
              by
                rw
                    [
                      ← algebraMap.coe_mul
                        ,
                        IsROrC.abs_div
                        ,
                        IsROrC.abs_of_nonneg
                        ,
                        div_eq_one_iff_eq hxy0
                      ]
                  positivity
          rw [ h₁ , abs_inner_div_norm_mul_norm_eq_one_iff x y ]
          exact and_iff_right hx0
#align abs_inner_eq_norm_iff abs_inner_eq_norm_iff

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "The inner product of two vectors, divided by the product of their\nnorms, has value 1 if and only if they are nonzero and one is\na positive multiple of the other. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `real_inner_div_norm_mul_norm_eq_one_iff [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x `y] [":" `F] [] ")")]
       (Term.typeSpec
        ":"
        («term_↔_»
         («term_=_»
          («term_/_»
           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫_ℝ» "⟪" `x ", " `y "⟫_ℝ")
           "/"
           («term_*_»
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
            "*"
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
          "="
          (num "1"))
         "↔"
         («term_∧_»
          («term_≠_» `x "≠" (num "0"))
          "∧"
          («term∃_,_»
           "∃"
           (Lean.explicitBinders
            (Lean.unbracketedExplicitBinders
             [(Lean.binderIdent `r)]
             [":" (Data.Real.Basic.termℝ "ℝ")]))
           ","
           («term_∧_»
            («term_<_» (num "0") "<" `r)
            "∧"
            («term_=_» `y "=" (Algebra.Group.Defs.«term_•_» `r " • " `x))))))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.constructor "constructor")
           []
           (tactic__
            (cdotTk (patternIgnore (token.«· » "·")))
            [(Tactic.intro "intro" [`h])
             []
             (Tactic.tacticHave_ "have" (Term.haveDecl (Term.haveIdDecl [`ha []] [] ":=" `h)))
             []
             (Mathlib.Tactic.applyFun
              "apply_fun"
              (Analysis.InnerProductSpace.Basic.termabsR "absR")
              [(Tactic.location "at" (Tactic.locationHyp [`ha] []))]
              [])
             []
             (Mathlib.Tactic.normNum
              "norm_num"
              []
              []
              [(Tactic.location "at" (Tactic.locationHyp [`ha] []))])
             []
             (Std.Tactic.rcases
              "rcases"
              [(Tactic.casesTarget
                []
                (Term.app
                 (Term.proj
                  (Term.app `abs_real_inner_div_norm_mul_norm_eq_one_iff [`x `y])
                  "."
                  (fieldIdx "1"))
                 [`ha]))]
              ["with"
               (Std.Tactic.RCases.rcasesPatLo
                (Std.Tactic.RCases.rcasesPatMed
                 [(Std.Tactic.RCases.rcasesPat.tuple
                   "⟨"
                   [(Std.Tactic.RCases.rcasesPatLo
                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx)])
                     [])
                    ","
                    (Std.Tactic.RCases.rcasesPatLo
                     (Std.Tactic.RCases.rcasesPatMed
                      [(Std.Tactic.RCases.rcasesPat.tuple
                        "⟨"
                        [(Std.Tactic.RCases.rcasesPatLo
                          (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `r)])
                          [])
                         ","
                         (Std.Tactic.RCases.rcasesPatLo
                          (Std.Tactic.RCases.rcasesPatMed
                           [(Std.Tactic.RCases.rcasesPat.tuple
                             "⟨"
                             [(Std.Tactic.RCases.rcasesPatLo
                               (Std.Tactic.RCases.rcasesPatMed
                                [(Std.Tactic.RCases.rcasesPat.one `hr)])
                               [])
                              ","
                              (Std.Tactic.RCases.rcasesPatLo
                               (Std.Tactic.RCases.rcasesPatMed
                                [(Std.Tactic.RCases.rcasesPat.one `hy)])
                               [])]
                             "⟩")])
                          [])]
                        "⟩")])
                     [])]
                   "⟩")])
                [])])
             []
             (Mathlib.Tactic.«tacticUse_,,» "use" [`hx "," `r])
             []
             (Tactic.refine' "refine'" (Term.app `And.intro [(Term.hole "_") `hy]))
             []
             (Std.Tactic.byContra "by_contra" [(Lean.binderIdent `hrneg)])
             []
             (Tactic.rwSeq
              "rw"
              []
              (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `hy)] "]")
              [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
             []
             (Tactic.rwSeq
              "rw"
              []
              (Tactic.rwRuleSeq
               "["
               [(Tactic.rwRule
                 []
                 (Term.app
                  `real_inner_div_norm_mul_norm_eq_neg_one_of_ne_zero_of_neg_mul
                  [`hx (Term.app `lt_of_le_of_ne [(Term.app `le_of_not_lt [`hrneg]) `hr])]))]
               "]")
              [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
             []
             (Mathlib.Tactic.normNum
              "norm_num"
              []
              []
              [(Tactic.location "at" (Tactic.locationHyp [`h] []))])])
           []
           (tactic__
            (cdotTk (patternIgnore (token.«· » "·")))
            [(Tactic.intro "intro" [`h])
             []
             (Std.Tactic.rcases
              "rcases"
              [(Tactic.casesTarget [] `h)]
              ["with"
               (Std.Tactic.RCases.rcasesPatLo
                (Std.Tactic.RCases.rcasesPatMed
                 [(Std.Tactic.RCases.rcasesPat.tuple
                   "⟨"
                   [(Std.Tactic.RCases.rcasesPatLo
                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx)])
                     [])
                    ","
                    (Std.Tactic.RCases.rcasesPatLo
                     (Std.Tactic.RCases.rcasesPatMed
                      [(Std.Tactic.RCases.rcasesPat.tuple
                        "⟨"
                        [(Std.Tactic.RCases.rcasesPatLo
                          (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `r)])
                          [])
                         ","
                         (Std.Tactic.RCases.rcasesPatLo
                          (Std.Tactic.RCases.rcasesPatMed
                           [(Std.Tactic.RCases.rcasesPat.tuple
                             "⟨"
                             [(Std.Tactic.RCases.rcasesPatLo
                               (Std.Tactic.RCases.rcasesPatMed
                                [(Std.Tactic.RCases.rcasesPat.one `hr)])
                               [])
                              ","
                              (Std.Tactic.RCases.rcasesPatLo
                               (Std.Tactic.RCases.rcasesPatMed
                                [(Std.Tactic.RCases.rcasesPat.one `hy)])
                               [])]
                             "⟩")])
                          [])]
                        "⟩")])
                     [])]
                   "⟩")])
                [])])
             []
             (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `hy)] "]") [])
             []
             (Tactic.exact
              "exact"
              (Term.app `real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_pos_mul [`hx `hr]))])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.constructor "constructor")
          []
          (tactic__
           (cdotTk (patternIgnore (token.«· » "·")))
           [(Tactic.intro "intro" [`h])
            []
            (Tactic.tacticHave_ "have" (Term.haveDecl (Term.haveIdDecl [`ha []] [] ":=" `h)))
            []
            (Mathlib.Tactic.applyFun
             "apply_fun"
             (Analysis.InnerProductSpace.Basic.termabsR "absR")
             [(Tactic.location "at" (Tactic.locationHyp [`ha] []))]
             [])
            []
            (Mathlib.Tactic.normNum
             "norm_num"
             []
             []
             [(Tactic.location "at" (Tactic.locationHyp [`ha] []))])
            []
            (Std.Tactic.rcases
             "rcases"
             [(Tactic.casesTarget
               []
               (Term.app
                (Term.proj
                 (Term.app `abs_real_inner_div_norm_mul_norm_eq_one_iff [`x `y])
                 "."
                 (fieldIdx "1"))
                [`ha]))]
             ["with"
              (Std.Tactic.RCases.rcasesPatLo
               (Std.Tactic.RCases.rcasesPatMed
                [(Std.Tactic.RCases.rcasesPat.tuple
                  "⟨"
                  [(Std.Tactic.RCases.rcasesPatLo
                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx)])
                    [])
                   ","
                   (Std.Tactic.RCases.rcasesPatLo
                    (Std.Tactic.RCases.rcasesPatMed
                     [(Std.Tactic.RCases.rcasesPat.tuple
                       "⟨"
                       [(Std.Tactic.RCases.rcasesPatLo
                         (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `r)])
                         [])
                        ","
                        (Std.Tactic.RCases.rcasesPatLo
                         (Std.Tactic.RCases.rcasesPatMed
                          [(Std.Tactic.RCases.rcasesPat.tuple
                            "⟨"
                            [(Std.Tactic.RCases.rcasesPatLo
                              (Std.Tactic.RCases.rcasesPatMed
                               [(Std.Tactic.RCases.rcasesPat.one `hr)])
                              [])
                             ","
                             (Std.Tactic.RCases.rcasesPatLo
                              (Std.Tactic.RCases.rcasesPatMed
                               [(Std.Tactic.RCases.rcasesPat.one `hy)])
                              [])]
                            "⟩")])
                         [])]
                       "⟩")])
                    [])]
                  "⟩")])
               [])])
            []
            (Mathlib.Tactic.«tacticUse_,,» "use" [`hx "," `r])
            []
            (Tactic.refine' "refine'" (Term.app `And.intro [(Term.hole "_") `hy]))
            []
            (Std.Tactic.byContra "by_contra" [(Lean.binderIdent `hrneg)])
            []
            (Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `hy)] "]")
             [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
            []
            (Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq
              "["
              [(Tactic.rwRule
                []
                (Term.app
                 `real_inner_div_norm_mul_norm_eq_neg_one_of_ne_zero_of_neg_mul
                 [`hx (Term.app `lt_of_le_of_ne [(Term.app `le_of_not_lt [`hrneg]) `hr])]))]
              "]")
             [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
            []
            (Mathlib.Tactic.normNum
             "norm_num"
             []
             []
             [(Tactic.location "at" (Tactic.locationHyp [`h] []))])])
          []
          (tactic__
           (cdotTk (patternIgnore (token.«· » "·")))
           [(Tactic.intro "intro" [`h])
            []
            (Std.Tactic.rcases
             "rcases"
             [(Tactic.casesTarget [] `h)]
             ["with"
              (Std.Tactic.RCases.rcasesPatLo
               (Std.Tactic.RCases.rcasesPatMed
                [(Std.Tactic.RCases.rcasesPat.tuple
                  "⟨"
                  [(Std.Tactic.RCases.rcasesPatLo
                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx)])
                    [])
                   ","
                   (Std.Tactic.RCases.rcasesPatLo
                    (Std.Tactic.RCases.rcasesPatMed
                     [(Std.Tactic.RCases.rcasesPat.tuple
                       "⟨"
                       [(Std.Tactic.RCases.rcasesPatLo
                         (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `r)])
                         [])
                        ","
                        (Std.Tactic.RCases.rcasesPatLo
                         (Std.Tactic.RCases.rcasesPatMed
                          [(Std.Tactic.RCases.rcasesPat.tuple
                            "⟨"
                            [(Std.Tactic.RCases.rcasesPatLo
                              (Std.Tactic.RCases.rcasesPatMed
                               [(Std.Tactic.RCases.rcasesPat.one `hr)])
                              [])
                             ","
                             (Std.Tactic.RCases.rcasesPatLo
                              (Std.Tactic.RCases.rcasesPatMed
                               [(Std.Tactic.RCases.rcasesPat.one `hy)])
                              [])]
                            "⟩")])
                         [])]
                       "⟩")])
                    [])]
                  "⟩")])
               [])])
            []
            (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `hy)] "]") [])
            []
            (Tactic.exact
             "exact"
             (Term.app `real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_pos_mul [`hx `hr]))])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.«· » "·")))
       [(Tactic.intro "intro" [`h])
        []
        (Std.Tactic.rcases
         "rcases"
         [(Tactic.casesTarget [] `h)]
         ["with"
          (Std.Tactic.RCases.rcasesPatLo
           (Std.Tactic.RCases.rcasesPatMed
            [(Std.Tactic.RCases.rcasesPat.tuple
              "⟨"
              [(Std.Tactic.RCases.rcasesPatLo
                (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx)])
                [])
               ","
               (Std.Tactic.RCases.rcasesPatLo
                (Std.Tactic.RCases.rcasesPatMed
                 [(Std.Tactic.RCases.rcasesPat.tuple
                   "⟨"
                   [(Std.Tactic.RCases.rcasesPatLo
                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `r)])
                     [])
                    ","
                    (Std.Tactic.RCases.rcasesPatLo
                     (Std.Tactic.RCases.rcasesPatMed
                      [(Std.Tactic.RCases.rcasesPat.tuple
                        "⟨"
                        [(Std.Tactic.RCases.rcasesPatLo
                          (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hr)])
                          [])
                         ","
                         (Std.Tactic.RCases.rcasesPatLo
                          (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hy)])
                          [])]
                        "⟩")])
                     [])]
                   "⟩")])
                [])]
              "⟩")])
           [])])
        []
        (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `hy)] "]") [])
        []
        (Tactic.exact
         "exact"
         (Term.app `real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_pos_mul [`hx `hr]))])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact
       "exact"
       (Term.app `real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_pos_mul [`hx `hr]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_pos_mul [`hx `hr])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hr
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `hx
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_pos_mul
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `hy)] "]") [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hy
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Std.Tactic.rcases
       "rcases"
       [(Tactic.casesTarget [] `h)]
       ["with"
        (Std.Tactic.RCases.rcasesPatLo
         (Std.Tactic.RCases.rcasesPatMed
          [(Std.Tactic.RCases.rcasesPat.tuple
            "⟨"
            [(Std.Tactic.RCases.rcasesPatLo
              (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx)])
              [])
             ","
             (Std.Tactic.RCases.rcasesPatLo
              (Std.Tactic.RCases.rcasesPatMed
               [(Std.Tactic.RCases.rcasesPat.tuple
                 "⟨"
                 [(Std.Tactic.RCases.rcasesPatLo
                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `r)])
                   [])
                  ","
                  (Std.Tactic.RCases.rcasesPatLo
                   (Std.Tactic.RCases.rcasesPatMed
                    [(Std.Tactic.RCases.rcasesPat.tuple
                      "⟨"
                      [(Std.Tactic.RCases.rcasesPatLo
                        (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hr)])
                        [])
                       ","
                       (Std.Tactic.RCases.rcasesPatLo
                        (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hy)])
                        [])]
                      "⟩")])
                   [])]
                 "⟩")])
              [])]
            "⟩")])
         [])])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.intro "intro" [`h])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.«· » "·")))
       [(Tactic.intro "intro" [`h])
        []
        (Tactic.tacticHave_ "have" (Term.haveDecl (Term.haveIdDecl [`ha []] [] ":=" `h)))
        []
        (Mathlib.Tactic.applyFun
         "apply_fun"
         (Analysis.InnerProductSpace.Basic.termabsR "absR")
         [(Tactic.location "at" (Tactic.locationHyp [`ha] []))]
         [])
        []
        (Mathlib.Tactic.normNum
         "norm_num"
         []
         []
         [(Tactic.location "at" (Tactic.locationHyp [`ha] []))])
        []
        (Std.Tactic.rcases
         "rcases"
         [(Tactic.casesTarget
           []
           (Term.app
            (Term.proj
             (Term.app `abs_real_inner_div_norm_mul_norm_eq_one_iff [`x `y])
             "."
             (fieldIdx "1"))
            [`ha]))]
         ["with"
          (Std.Tactic.RCases.rcasesPatLo
           (Std.Tactic.RCases.rcasesPatMed
            [(Std.Tactic.RCases.rcasesPat.tuple
              "⟨"
              [(Std.Tactic.RCases.rcasesPatLo
                (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx)])
                [])
               ","
               (Std.Tactic.RCases.rcasesPatLo
                (Std.Tactic.RCases.rcasesPatMed
                 [(Std.Tactic.RCases.rcasesPat.tuple
                   "⟨"
                   [(Std.Tactic.RCases.rcasesPatLo
                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `r)])
                     [])
                    ","
                    (Std.Tactic.RCases.rcasesPatLo
                     (Std.Tactic.RCases.rcasesPatMed
                      [(Std.Tactic.RCases.rcasesPat.tuple
                        "⟨"
                        [(Std.Tactic.RCases.rcasesPatLo
                          (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hr)])
                          [])
                         ","
                         (Std.Tactic.RCases.rcasesPatLo
                          (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hy)])
                          [])]
                        "⟩")])
                     [])]
                   "⟩")])
                [])]
              "⟩")])
           [])])
        []
        (Mathlib.Tactic.«tacticUse_,,» "use" [`hx "," `r])
        []
        (Tactic.refine' "refine'" (Term.app `And.intro [(Term.hole "_") `hy]))
        []
        (Std.Tactic.byContra "by_contra" [(Lean.binderIdent `hrneg)])
        []
        (Tactic.rwSeq
         "rw"
         []
         (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `hy)] "]")
         [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
        []
        (Tactic.rwSeq
         "rw"
         []
         (Tactic.rwRuleSeq
          "["
          [(Tactic.rwRule
            []
            (Term.app
             `real_inner_div_norm_mul_norm_eq_neg_one_of_ne_zero_of_neg_mul
             [`hx (Term.app `lt_of_le_of_ne [(Term.app `le_of_not_lt [`hrneg]) `hr])]))]
          "]")
         [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
        []
        (Mathlib.Tactic.normNum
         "norm_num"
         []
         []
         [(Tactic.location "at" (Tactic.locationHyp [`h] []))])])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.normNum
       "norm_num"
       []
       []
       [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.locationHyp', expected 'Lean.Parser.Tactic.locationWildcard'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule
          []
          (Term.app
           `real_inner_div_norm_mul_norm_eq_neg_one_of_ne_zero_of_neg_mul
           [`hx (Term.app `lt_of_le_of_ne [(Term.app `le_of_not_lt [`hrneg]) `hr])]))]
        "]")
       [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.locationHyp', expected 'Lean.Parser.Tactic.locationWildcard'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `real_inner_div_norm_mul_norm_eq_neg_one_of_ne_zero_of_neg_mul
       [`hx (Term.app `lt_of_le_of_ne [(Term.app `le_of_not_lt [`hrneg]) `hr])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `lt_of_le_of_ne [(Term.app `le_of_not_lt [`hrneg]) `hr])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hr
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.app `le_of_not_lt [`hrneg])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hrneg
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `le_of_not_lt
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `le_of_not_lt [`hrneg]) ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `lt_of_le_of_ne
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app `lt_of_le_of_ne [(Term.paren "(" (Term.app `le_of_not_lt [`hrneg]) ")") `hr])
     ")")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `hx
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `real_inner_div_norm_mul_norm_eq_neg_one_of_ne_zero_of_neg_mul
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `hy)] "]")
       [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.locationHyp', expected 'Lean.Parser.Tactic.locationWildcard'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hy
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Std.Tactic.byContra "by_contra" [(Lean.binderIdent `hrneg)])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.refine' "refine'" (Term.app `And.intro [(Term.hole "_") `hy]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `And.intro [(Term.hole "_") `hy])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hy
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `And.intro
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.«tacticUse_,,» "use" [`hx "," `r])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `r
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hx
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Std.Tactic.rcases
       "rcases"
       [(Tactic.casesTarget
         []
         (Term.app
          (Term.proj
           (Term.app `abs_real_inner_div_norm_mul_norm_eq_one_iff [`x `y])
           "."
           (fieldIdx "1"))
          [`ha]))]
       ["with"
        (Std.Tactic.RCases.rcasesPatLo
         (Std.Tactic.RCases.rcasesPatMed
          [(Std.Tactic.RCases.rcasesPat.tuple
            "⟨"
            [(Std.Tactic.RCases.rcasesPatLo
              (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx)])
              [])
             ","
             (Std.Tactic.RCases.rcasesPatLo
              (Std.Tactic.RCases.rcasesPatMed
               [(Std.Tactic.RCases.rcasesPat.tuple
                 "⟨"
                 [(Std.Tactic.RCases.rcasesPatLo
                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `r)])
                   [])
                  ","
                  (Std.Tactic.RCases.rcasesPatLo
                   (Std.Tactic.RCases.rcasesPatMed
                    [(Std.Tactic.RCases.rcasesPat.tuple
                      "⟨"
                      [(Std.Tactic.RCases.rcasesPatLo
                        (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hr)])
                        [])
                       ","
                       (Std.Tactic.RCases.rcasesPatLo
                        (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hy)])
                        [])]
                      "⟩")])
                   [])]
                 "⟩")])
              [])]
            "⟩")])
         [])])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       (Term.proj
        (Term.app `abs_real_inner_div_norm_mul_norm_eq_one_iff [`x `y])
        "."
        (fieldIdx "1"))
       [`ha])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `ha
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.proj (Term.app `abs_real_inner_div_norm_mul_norm_eq_one_iff [`x `y]) "." (fieldIdx "1"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.app `abs_real_inner_div_norm_mul_norm_eq_one_iff [`x `y])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `abs_real_inner_div_norm_mul_norm_eq_one_iff
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app `abs_real_inner_div_norm_mul_norm_eq_one_iff [`x `y])
     ")")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.normNum
       "norm_num"
       []
       []
       [(Tactic.location "at" (Tactic.locationHyp [`ha] []))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.locationHyp', expected 'Lean.Parser.Tactic.locationWildcard'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `ha
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.applyFun
       "apply_fun"
       (Analysis.InnerProductSpace.Basic.termabsR "absR")
       [(Tactic.location "at" (Tactic.locationHyp [`ha] []))]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.locationHyp', expected 'Lean.Parser.Tactic.locationWildcard'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `ha
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.termabsR "absR")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.termabsR', expected 'Analysis.InnerProductSpace.Basic.termabsR._@.Analysis.InnerProductSpace.Basic._hyg.1003'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    The inner product of two vectors, divided by the product of their
    norms, has value 1 if and only if they are nonzero and one is
    a positive multiple of the other. -/
  theorem
    real_inner_div_norm_mul_norm_eq_one_iff
    ( x y : F ) : ⟪ x , y ⟫_ℝ / ‖ x ‖ * ‖ y ‖ = 1 ↔ x ≠ 0 ∧ ∃ r : ℝ , 0 < r ∧ y = r • x
    :=
      by
        constructor
          ·
            intro h
              have ha := h
              apply_fun absR at ha
              norm_num at ha
              rcases
                abs_real_inner_div_norm_mul_norm_eq_one_iff x y . 1 ha
                with ⟨ hx , ⟨ r , ⟨ hr , hy ⟩ ⟩ ⟩
              use hx , r
              refine' And.intro _ hy
              by_contra hrneg
              rw [ hy ] at h
              rw
                [
                  real_inner_div_norm_mul_norm_eq_neg_one_of_ne_zero_of_neg_mul
                    hx lt_of_le_of_ne le_of_not_lt hrneg hr
                  ]
                at h
              norm_num at h
          ·
            intro h
              rcases h with ⟨ hx , ⟨ r , ⟨ hr , hy ⟩ ⟩ ⟩
              rw [ hy ]
              exact real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_pos_mul hx hr
#align real_inner_div_norm_mul_norm_eq_one_iff real_inner_div_norm_mul_norm_eq_one_iff

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "The inner product of two vectors, divided by the product of their\nnorms, has value -1 if and only if they are nonzero and one is\na negative multiple of the other. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `real_inner_div_norm_mul_norm_eq_neg_one_iff [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x `y] [":" `F] [] ")")]
       (Term.typeSpec
        ":"
        («term_↔_»
         («term_=_»
          («term_/_»
           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫_ℝ» "⟪" `x ", " `y "⟫_ℝ")
           "/"
           («term_*_»
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
            "*"
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
          "="
          («term-_» "-" (num "1")))
         "↔"
         («term_∧_»
          («term_≠_» `x "≠" (num "0"))
          "∧"
          («term∃_,_»
           "∃"
           (Lean.explicitBinders
            (Lean.unbracketedExplicitBinders
             [(Lean.binderIdent `r)]
             [":" (Data.Real.Basic.termℝ "ℝ")]))
           ","
           («term_∧_»
            («term_<_» `r "<" (num "0"))
            "∧"
            («term_=_» `y "=" (Algebra.Group.Defs.«term_•_» `r " • " `x))))))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.constructor "constructor")
           []
           (tactic__
            (cdotTk (patternIgnore (token.«· » "·")))
            [(Tactic.intro "intro" [`h])
             []
             (Tactic.tacticHave_ "have" (Term.haveDecl (Term.haveIdDecl [`ha []] [] ":=" `h)))
             []
             (Mathlib.Tactic.applyFun
              "apply_fun"
              (Analysis.InnerProductSpace.Basic.termabsR "absR")
              [(Tactic.location "at" (Tactic.locationHyp [`ha] []))]
              [])
             []
             (Mathlib.Tactic.normNum
              "norm_num"
              []
              []
              [(Tactic.location "at" (Tactic.locationHyp [`ha] []))])
             []
             (Std.Tactic.rcases
              "rcases"
              [(Tactic.casesTarget
                []
                (Term.app
                 (Term.proj
                  (Term.app `abs_real_inner_div_norm_mul_norm_eq_one_iff [`x `y])
                  "."
                  (fieldIdx "1"))
                 [`ha]))]
              ["with"
               (Std.Tactic.RCases.rcasesPatLo
                (Std.Tactic.RCases.rcasesPatMed
                 [(Std.Tactic.RCases.rcasesPat.tuple
                   "⟨"
                   [(Std.Tactic.RCases.rcasesPatLo
                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx)])
                     [])
                    ","
                    (Std.Tactic.RCases.rcasesPatLo
                     (Std.Tactic.RCases.rcasesPatMed
                      [(Std.Tactic.RCases.rcasesPat.tuple
                        "⟨"
                        [(Std.Tactic.RCases.rcasesPatLo
                          (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `r)])
                          [])
                         ","
                         (Std.Tactic.RCases.rcasesPatLo
                          (Std.Tactic.RCases.rcasesPatMed
                           [(Std.Tactic.RCases.rcasesPat.tuple
                             "⟨"
                             [(Std.Tactic.RCases.rcasesPatLo
                               (Std.Tactic.RCases.rcasesPatMed
                                [(Std.Tactic.RCases.rcasesPat.one `hr)])
                               [])
                              ","
                              (Std.Tactic.RCases.rcasesPatLo
                               (Std.Tactic.RCases.rcasesPatMed
                                [(Std.Tactic.RCases.rcasesPat.one `hy)])
                               [])]
                             "⟩")])
                          [])]
                        "⟩")])
                     [])]
                   "⟩")])
                [])])
             []
             (Mathlib.Tactic.«tacticUse_,,» "use" [`hx "," `r])
             []
             (Tactic.refine' "refine'" (Term.app `And.intro [(Term.hole "_") `hy]))
             []
             (Std.Tactic.byContra "by_contra" [(Lean.binderIdent `hrpos)])
             []
             (Tactic.rwSeq
              "rw"
              []
              (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `hy)] "]")
              [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
             []
             (Tactic.rwSeq
              "rw"
              []
              (Tactic.rwRuleSeq
               "["
               [(Tactic.rwRule
                 []
                 (Term.app
                  `real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_pos_mul
                  [`hx (Term.app `lt_of_le_of_ne [(Term.app `le_of_not_lt [`hrpos]) `hr.symm])]))]
               "]")
              [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
             []
             (Mathlib.Tactic.normNum
              "norm_num"
              []
              []
              [(Tactic.location "at" (Tactic.locationHyp [`h] []))])])
           []
           (tactic__
            (cdotTk (patternIgnore (token.«· » "·")))
            [(Tactic.intro "intro" [`h])
             []
             (Std.Tactic.rcases
              "rcases"
              [(Tactic.casesTarget [] `h)]
              ["with"
               (Std.Tactic.RCases.rcasesPatLo
                (Std.Tactic.RCases.rcasesPatMed
                 [(Std.Tactic.RCases.rcasesPat.tuple
                   "⟨"
                   [(Std.Tactic.RCases.rcasesPatLo
                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx)])
                     [])
                    ","
                    (Std.Tactic.RCases.rcasesPatLo
                     (Std.Tactic.RCases.rcasesPatMed
                      [(Std.Tactic.RCases.rcasesPat.tuple
                        "⟨"
                        [(Std.Tactic.RCases.rcasesPatLo
                          (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `r)])
                          [])
                         ","
                         (Std.Tactic.RCases.rcasesPatLo
                          (Std.Tactic.RCases.rcasesPatMed
                           [(Std.Tactic.RCases.rcasesPat.tuple
                             "⟨"
                             [(Std.Tactic.RCases.rcasesPatLo
                               (Std.Tactic.RCases.rcasesPatMed
                                [(Std.Tactic.RCases.rcasesPat.one `hr)])
                               [])
                              ","
                              (Std.Tactic.RCases.rcasesPatLo
                               (Std.Tactic.RCases.rcasesPatMed
                                [(Std.Tactic.RCases.rcasesPat.one `hy)])
                               [])]
                             "⟩")])
                          [])]
                        "⟩")])
                     [])]
                   "⟩")])
                [])])
             []
             (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `hy)] "]") [])
             []
             (Tactic.exact
              "exact"
              (Term.app
               `real_inner_div_norm_mul_norm_eq_neg_one_of_ne_zero_of_neg_mul
               [`hx `hr]))])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.constructor "constructor")
          []
          (tactic__
           (cdotTk (patternIgnore (token.«· » "·")))
           [(Tactic.intro "intro" [`h])
            []
            (Tactic.tacticHave_ "have" (Term.haveDecl (Term.haveIdDecl [`ha []] [] ":=" `h)))
            []
            (Mathlib.Tactic.applyFun
             "apply_fun"
             (Analysis.InnerProductSpace.Basic.termabsR "absR")
             [(Tactic.location "at" (Tactic.locationHyp [`ha] []))]
             [])
            []
            (Mathlib.Tactic.normNum
             "norm_num"
             []
             []
             [(Tactic.location "at" (Tactic.locationHyp [`ha] []))])
            []
            (Std.Tactic.rcases
             "rcases"
             [(Tactic.casesTarget
               []
               (Term.app
                (Term.proj
                 (Term.app `abs_real_inner_div_norm_mul_norm_eq_one_iff [`x `y])
                 "."
                 (fieldIdx "1"))
                [`ha]))]
             ["with"
              (Std.Tactic.RCases.rcasesPatLo
               (Std.Tactic.RCases.rcasesPatMed
                [(Std.Tactic.RCases.rcasesPat.tuple
                  "⟨"
                  [(Std.Tactic.RCases.rcasesPatLo
                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx)])
                    [])
                   ","
                   (Std.Tactic.RCases.rcasesPatLo
                    (Std.Tactic.RCases.rcasesPatMed
                     [(Std.Tactic.RCases.rcasesPat.tuple
                       "⟨"
                       [(Std.Tactic.RCases.rcasesPatLo
                         (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `r)])
                         [])
                        ","
                        (Std.Tactic.RCases.rcasesPatLo
                         (Std.Tactic.RCases.rcasesPatMed
                          [(Std.Tactic.RCases.rcasesPat.tuple
                            "⟨"
                            [(Std.Tactic.RCases.rcasesPatLo
                              (Std.Tactic.RCases.rcasesPatMed
                               [(Std.Tactic.RCases.rcasesPat.one `hr)])
                              [])
                             ","
                             (Std.Tactic.RCases.rcasesPatLo
                              (Std.Tactic.RCases.rcasesPatMed
                               [(Std.Tactic.RCases.rcasesPat.one `hy)])
                              [])]
                            "⟩")])
                         [])]
                       "⟩")])
                    [])]
                  "⟩")])
               [])])
            []
            (Mathlib.Tactic.«tacticUse_,,» "use" [`hx "," `r])
            []
            (Tactic.refine' "refine'" (Term.app `And.intro [(Term.hole "_") `hy]))
            []
            (Std.Tactic.byContra "by_contra" [(Lean.binderIdent `hrpos)])
            []
            (Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `hy)] "]")
             [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
            []
            (Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq
              "["
              [(Tactic.rwRule
                []
                (Term.app
                 `real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_pos_mul
                 [`hx (Term.app `lt_of_le_of_ne [(Term.app `le_of_not_lt [`hrpos]) `hr.symm])]))]
              "]")
             [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
            []
            (Mathlib.Tactic.normNum
             "norm_num"
             []
             []
             [(Tactic.location "at" (Tactic.locationHyp [`h] []))])])
          []
          (tactic__
           (cdotTk (patternIgnore (token.«· » "·")))
           [(Tactic.intro "intro" [`h])
            []
            (Std.Tactic.rcases
             "rcases"
             [(Tactic.casesTarget [] `h)]
             ["with"
              (Std.Tactic.RCases.rcasesPatLo
               (Std.Tactic.RCases.rcasesPatMed
                [(Std.Tactic.RCases.rcasesPat.tuple
                  "⟨"
                  [(Std.Tactic.RCases.rcasesPatLo
                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx)])
                    [])
                   ","
                   (Std.Tactic.RCases.rcasesPatLo
                    (Std.Tactic.RCases.rcasesPatMed
                     [(Std.Tactic.RCases.rcasesPat.tuple
                       "⟨"
                       [(Std.Tactic.RCases.rcasesPatLo
                         (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `r)])
                         [])
                        ","
                        (Std.Tactic.RCases.rcasesPatLo
                         (Std.Tactic.RCases.rcasesPatMed
                          [(Std.Tactic.RCases.rcasesPat.tuple
                            "⟨"
                            [(Std.Tactic.RCases.rcasesPatLo
                              (Std.Tactic.RCases.rcasesPatMed
                               [(Std.Tactic.RCases.rcasesPat.one `hr)])
                              [])
                             ","
                             (Std.Tactic.RCases.rcasesPatLo
                              (Std.Tactic.RCases.rcasesPatMed
                               [(Std.Tactic.RCases.rcasesPat.one `hy)])
                              [])]
                            "⟩")])
                         [])]
                       "⟩")])
                    [])]
                  "⟩")])
               [])])
            []
            (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `hy)] "]") [])
            []
            (Tactic.exact
             "exact"
             (Term.app
              `real_inner_div_norm_mul_norm_eq_neg_one_of_ne_zero_of_neg_mul
              [`hx `hr]))])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.«· » "·")))
       [(Tactic.intro "intro" [`h])
        []
        (Std.Tactic.rcases
         "rcases"
         [(Tactic.casesTarget [] `h)]
         ["with"
          (Std.Tactic.RCases.rcasesPatLo
           (Std.Tactic.RCases.rcasesPatMed
            [(Std.Tactic.RCases.rcasesPat.tuple
              "⟨"
              [(Std.Tactic.RCases.rcasesPatLo
                (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx)])
                [])
               ","
               (Std.Tactic.RCases.rcasesPatLo
                (Std.Tactic.RCases.rcasesPatMed
                 [(Std.Tactic.RCases.rcasesPat.tuple
                   "⟨"
                   [(Std.Tactic.RCases.rcasesPatLo
                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `r)])
                     [])
                    ","
                    (Std.Tactic.RCases.rcasesPatLo
                     (Std.Tactic.RCases.rcasesPatMed
                      [(Std.Tactic.RCases.rcasesPat.tuple
                        "⟨"
                        [(Std.Tactic.RCases.rcasesPatLo
                          (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hr)])
                          [])
                         ","
                         (Std.Tactic.RCases.rcasesPatLo
                          (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hy)])
                          [])]
                        "⟩")])
                     [])]
                   "⟩")])
                [])]
              "⟩")])
           [])])
        []
        (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `hy)] "]") [])
        []
        (Tactic.exact
         "exact"
         (Term.app `real_inner_div_norm_mul_norm_eq_neg_one_of_ne_zero_of_neg_mul [`hx `hr]))])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact
       "exact"
       (Term.app `real_inner_div_norm_mul_norm_eq_neg_one_of_ne_zero_of_neg_mul [`hx `hr]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `real_inner_div_norm_mul_norm_eq_neg_one_of_ne_zero_of_neg_mul [`hx `hr])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hr
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `hx
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `real_inner_div_norm_mul_norm_eq_neg_one_of_ne_zero_of_neg_mul
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `hy)] "]") [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hy
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Std.Tactic.rcases
       "rcases"
       [(Tactic.casesTarget [] `h)]
       ["with"
        (Std.Tactic.RCases.rcasesPatLo
         (Std.Tactic.RCases.rcasesPatMed
          [(Std.Tactic.RCases.rcasesPat.tuple
            "⟨"
            [(Std.Tactic.RCases.rcasesPatLo
              (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx)])
              [])
             ","
             (Std.Tactic.RCases.rcasesPatLo
              (Std.Tactic.RCases.rcasesPatMed
               [(Std.Tactic.RCases.rcasesPat.tuple
                 "⟨"
                 [(Std.Tactic.RCases.rcasesPatLo
                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `r)])
                   [])
                  ","
                  (Std.Tactic.RCases.rcasesPatLo
                   (Std.Tactic.RCases.rcasesPatMed
                    [(Std.Tactic.RCases.rcasesPat.tuple
                      "⟨"
                      [(Std.Tactic.RCases.rcasesPatLo
                        (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hr)])
                        [])
                       ","
                       (Std.Tactic.RCases.rcasesPatLo
                        (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hy)])
                        [])]
                      "⟩")])
                   [])]
                 "⟩")])
              [])]
            "⟩")])
         [])])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.intro "intro" [`h])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.«· » "·")))
       [(Tactic.intro "intro" [`h])
        []
        (Tactic.tacticHave_ "have" (Term.haveDecl (Term.haveIdDecl [`ha []] [] ":=" `h)))
        []
        (Mathlib.Tactic.applyFun
         "apply_fun"
         (Analysis.InnerProductSpace.Basic.termabsR "absR")
         [(Tactic.location "at" (Tactic.locationHyp [`ha] []))]
         [])
        []
        (Mathlib.Tactic.normNum
         "norm_num"
         []
         []
         [(Tactic.location "at" (Tactic.locationHyp [`ha] []))])
        []
        (Std.Tactic.rcases
         "rcases"
         [(Tactic.casesTarget
           []
           (Term.app
            (Term.proj
             (Term.app `abs_real_inner_div_norm_mul_norm_eq_one_iff [`x `y])
             "."
             (fieldIdx "1"))
            [`ha]))]
         ["with"
          (Std.Tactic.RCases.rcasesPatLo
           (Std.Tactic.RCases.rcasesPatMed
            [(Std.Tactic.RCases.rcasesPat.tuple
              "⟨"
              [(Std.Tactic.RCases.rcasesPatLo
                (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx)])
                [])
               ","
               (Std.Tactic.RCases.rcasesPatLo
                (Std.Tactic.RCases.rcasesPatMed
                 [(Std.Tactic.RCases.rcasesPat.tuple
                   "⟨"
                   [(Std.Tactic.RCases.rcasesPatLo
                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `r)])
                     [])
                    ","
                    (Std.Tactic.RCases.rcasesPatLo
                     (Std.Tactic.RCases.rcasesPatMed
                      [(Std.Tactic.RCases.rcasesPat.tuple
                        "⟨"
                        [(Std.Tactic.RCases.rcasesPatLo
                          (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hr)])
                          [])
                         ","
                         (Std.Tactic.RCases.rcasesPatLo
                          (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hy)])
                          [])]
                        "⟩")])
                     [])]
                   "⟩")])
                [])]
              "⟩")])
           [])])
        []
        (Mathlib.Tactic.«tacticUse_,,» "use" [`hx "," `r])
        []
        (Tactic.refine' "refine'" (Term.app `And.intro [(Term.hole "_") `hy]))
        []
        (Std.Tactic.byContra "by_contra" [(Lean.binderIdent `hrpos)])
        []
        (Tactic.rwSeq
         "rw"
         []
         (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `hy)] "]")
         [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
        []
        (Tactic.rwSeq
         "rw"
         []
         (Tactic.rwRuleSeq
          "["
          [(Tactic.rwRule
            []
            (Term.app
             `real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_pos_mul
             [`hx (Term.app `lt_of_le_of_ne [(Term.app `le_of_not_lt [`hrpos]) `hr.symm])]))]
          "]")
         [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
        []
        (Mathlib.Tactic.normNum
         "norm_num"
         []
         []
         [(Tactic.location "at" (Tactic.locationHyp [`h] []))])])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.normNum
       "norm_num"
       []
       []
       [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.locationHyp', expected 'Lean.Parser.Tactic.locationWildcard'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule
          []
          (Term.app
           `real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_pos_mul
           [`hx (Term.app `lt_of_le_of_ne [(Term.app `le_of_not_lt [`hrpos]) `hr.symm])]))]
        "]")
       [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.locationHyp', expected 'Lean.Parser.Tactic.locationWildcard'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_pos_mul
       [`hx (Term.app `lt_of_le_of_ne [(Term.app `le_of_not_lt [`hrpos]) `hr.symm])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `lt_of_le_of_ne [(Term.app `le_of_not_lt [`hrpos]) `hr.symm])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hr.symm
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.app `le_of_not_lt [`hrpos])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hrpos
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `le_of_not_lt
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `le_of_not_lt [`hrpos]) ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `lt_of_le_of_ne
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app `lt_of_le_of_ne [(Term.paren "(" (Term.app `le_of_not_lt [`hrpos]) ")") `hr.symm])
     ")")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `hx
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_pos_mul
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `hy)] "]")
       [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.locationHyp', expected 'Lean.Parser.Tactic.locationWildcard'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hy
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Std.Tactic.byContra "by_contra" [(Lean.binderIdent `hrpos)])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.refine' "refine'" (Term.app `And.intro [(Term.hole "_") `hy]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `And.intro [(Term.hole "_") `hy])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hy
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `And.intro
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.«tacticUse_,,» "use" [`hx "," `r])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `r
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hx
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Std.Tactic.rcases
       "rcases"
       [(Tactic.casesTarget
         []
         (Term.app
          (Term.proj
           (Term.app `abs_real_inner_div_norm_mul_norm_eq_one_iff [`x `y])
           "."
           (fieldIdx "1"))
          [`ha]))]
       ["with"
        (Std.Tactic.RCases.rcasesPatLo
         (Std.Tactic.RCases.rcasesPatMed
          [(Std.Tactic.RCases.rcasesPat.tuple
            "⟨"
            [(Std.Tactic.RCases.rcasesPatLo
              (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx)])
              [])
             ","
             (Std.Tactic.RCases.rcasesPatLo
              (Std.Tactic.RCases.rcasesPatMed
               [(Std.Tactic.RCases.rcasesPat.tuple
                 "⟨"
                 [(Std.Tactic.RCases.rcasesPatLo
                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `r)])
                   [])
                  ","
                  (Std.Tactic.RCases.rcasesPatLo
                   (Std.Tactic.RCases.rcasesPatMed
                    [(Std.Tactic.RCases.rcasesPat.tuple
                      "⟨"
                      [(Std.Tactic.RCases.rcasesPatLo
                        (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hr)])
                        [])
                       ","
                       (Std.Tactic.RCases.rcasesPatLo
                        (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hy)])
                        [])]
                      "⟩")])
                   [])]
                 "⟩")])
              [])]
            "⟩")])
         [])])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       (Term.proj
        (Term.app `abs_real_inner_div_norm_mul_norm_eq_one_iff [`x `y])
        "."
        (fieldIdx "1"))
       [`ha])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `ha
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.proj (Term.app `abs_real_inner_div_norm_mul_norm_eq_one_iff [`x `y]) "." (fieldIdx "1"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.app `abs_real_inner_div_norm_mul_norm_eq_one_iff [`x `y])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `abs_real_inner_div_norm_mul_norm_eq_one_iff
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app `abs_real_inner_div_norm_mul_norm_eq_one_iff [`x `y])
     ")")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.normNum
       "norm_num"
       []
       []
       [(Tactic.location "at" (Tactic.locationHyp [`ha] []))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.locationHyp', expected 'Lean.Parser.Tactic.locationWildcard'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `ha
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.applyFun
       "apply_fun"
       (Analysis.InnerProductSpace.Basic.termabsR "absR")
       [(Tactic.location "at" (Tactic.locationHyp [`ha] []))]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.locationHyp', expected 'Lean.Parser.Tactic.locationWildcard'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `ha
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.termabsR "absR")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.termabsR', expected 'Analysis.InnerProductSpace.Basic.termabsR._@.Analysis.InnerProductSpace.Basic._hyg.1003'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    The inner product of two vectors, divided by the product of their
    norms, has value -1 if and only if they are nonzero and one is
    a negative multiple of the other. -/
  theorem
    real_inner_div_norm_mul_norm_eq_neg_one_iff
    ( x y : F ) : ⟪ x , y ⟫_ℝ / ‖ x ‖ * ‖ y ‖ = - 1 ↔ x ≠ 0 ∧ ∃ r : ℝ , r < 0 ∧ y = r • x
    :=
      by
        constructor
          ·
            intro h
              have ha := h
              apply_fun absR at ha
              norm_num at ha
              rcases
                abs_real_inner_div_norm_mul_norm_eq_one_iff x y . 1 ha
                with ⟨ hx , ⟨ r , ⟨ hr , hy ⟩ ⟩ ⟩
              use hx , r
              refine' And.intro _ hy
              by_contra hrpos
              rw [ hy ] at h
              rw
                [
                  real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_pos_mul
                    hx lt_of_le_of_ne le_of_not_lt hrpos hr.symm
                  ]
                at h
              norm_num at h
          ·
            intro h
              rcases h with ⟨ hx , ⟨ r , ⟨ hr , hy ⟩ ⟩ ⟩
              rw [ hy ]
              exact real_inner_div_norm_mul_norm_eq_neg_one_of_ne_zero_of_neg_mul hx hr
#align real_inner_div_norm_mul_norm_eq_neg_one_iff real_inner_div_norm_mul_norm_eq_neg_one_iff

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "If the inner product of two vectors is equal to the product of their norms (i.e.,\n`⟪x, y⟫ = ‖x‖ * ‖y‖`), then the two vectors are nonnegative real multiples of each other. One form\nof the equality case for Cauchy-Schwarz.\nCompare `abs_inner_eq_norm_iff`, which takes the weaker hypothesis `abs ⟪x, y⟫ = ‖x‖ * ‖y‖`. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_eq_norm_mul_iff [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_↔_»
         («term_=_»
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
          "="
          («term_*_»
           (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") ":" [`𝕜] ")")
           "*"
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
         "↔"
         («term_=_»
          (Algebra.Group.Defs.«term_•_»
           (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖") ":" [`𝕜] ")")
           " • "
           `x)
          "="
          (Algebra.Group.Defs.«term_•_»
           (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") ":" [`𝕜] ")")
           " • "
           `y)))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Classical.«tacticBy_cases_:_»
            "by_cases"
            [`h ":"]
            («term_∨_» («term_=_» `x "=" (num "0")) "∨" («term_=_» `y "=" (num "0"))))
           []
           (tactic__
            (cdotTk (patternIgnore (token.«· » "·")))
            [(Tactic.«tactic_<;>_»
              (Tactic.cases "cases" [(Tactic.casesTarget [] `h)] [] [])
              "<;>"
              (Tactic.simp "simp" [] [] [] ["[" [(Tactic.simpLemma [] [] `h)] "]"] []))])
           []
           (calcTactic
            "calc"
            (calcStep
             («term_↔_»
              («term_=_»
               (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
               "="
               («term_*_»
                (Term.typeAscription
                 "("
                 (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                 ":"
                 [`𝕜]
                 ")")
                "*"
                (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
              "↔"
              («term_=_»
               («term_*_»
                (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                "*"
                (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
               "="
               (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))
             ":="
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Tactic.NormCast.tacticNorm_cast__ "norm_cast" [])
                 []
                 (Tactic.constructor "constructor")
                 []
                 (tactic__
                  (cdotTk (patternIgnore (token.«· » "·")))
                  [(Tactic.intro "intro" [`h'])
                   []
                   (Tactic.simp "simp" [] [] [] ["[" [(Tactic.simpLemma [] [] `h')] "]"] [])])
                 []
                 (tactic__
                  (cdotTk (patternIgnore (token.«· » "·")))
                  [(Tactic.tacticHave_
                    "have"
                    (Term.haveDecl
                     (Term.haveIdDecl
                      [`cauchy_schwarz []]
                      []
                      ":="
                      (Term.app `abs_inner_le_norm [`x `y]))))
                   []
                   (Tactic.intro "intro" [`h'])
                   []
                   (Tactic.rwSeq
                    "rw"
                    []
                    (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `h')] "]")
                    [(Tactic.location
                      "at"
                      (Tactic.locationHyp [`cauchy_schwarz] [(patternIgnore (token.«⊢» "⊢"))]))])
                   []
                   (Std.Tactic.tacticRwa__
                    "rwa"
                    (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `re_eq_self_of_le)] "]")
                    [])])]))))
            [(calcStep
              («term_↔_»
               (Term.hole "_")
               "↔"
               («term_=_»
                («term_*_»
                 («term_*_»
                  («term_*_» (num "2") "*" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
                  "*"
                  (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
                 "*"
                 («term_-_»
                  («term_*_»
                   (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                   "*"
                   (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
                  "-"
                  (Term.app
                   `re
                   [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))
                "="
                (num "0")))
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.simp
                   "simp"
                   []
                   []
                   []
                   ["["
                    [(Tactic.simpLemma [] [] `h)
                     ","
                     (Tactic.simpLemma
                      []
                      []
                      (Term.show
                       "show"
                       («term_≠_»
                        (Term.typeAscription "(" (num "2") ":" [(Data.Real.Basic.termℝ "ℝ")] ")")
                        "≠"
                        (num "0"))
                       (Term.byTactic'
                        "by"
                        (Tactic.tacticSeq
                         (Tactic.tacticSeq1Indented
                          [(Mathlib.Tactic.normNum "norm_num" [] [] [])])))))
                     ","
                     (Tactic.simpLemma [] [] `sub_eq_zero)]
                    "]"]
                   [])]))))
             (calcStep
              («term_↔_»
               (Term.hole "_")
               "↔"
               («term_=_»
                («term_*_»
                 (Analysis.Normed.Group.Basic.«term‖_‖»
                  "‖"
                  («term_-_»
                   (Algebra.Group.Defs.«term_•_»
                    (Term.typeAscription
                     "("
                     (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
                     ":"
                     [`𝕜]
                     ")")
                    " • "
                    `x)
                   "-"
                   (Algebra.Group.Defs.«term_•_»
                    (Term.typeAscription
                     "("
                     (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                     ":"
                     [`𝕜]
                     ")")
                    " • "
                    `y))
                  "‖")
                 "*"
                 (Analysis.Normed.Group.Basic.«term‖_‖»
                  "‖"
                  («term_-_»
                   (Algebra.Group.Defs.«term_•_»
                    (Term.typeAscription
                     "("
                     (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
                     ":"
                     [`𝕜]
                     ")")
                    " • "
                    `x)
                   "-"
                   (Algebra.Group.Defs.«term_•_»
                    (Term.typeAscription
                     "("
                     (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                     ":"
                     [`𝕜]
                     ")")
                    " • "
                    `y))
                  "‖"))
                "="
                (num "0")))
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.simp
                   "simp"
                   []
                   []
                   ["only"]
                   ["["
                    [(Tactic.simpLemma [] [] `norm_sub_mul_self)
                     ","
                     (Tactic.simpLemma [] [] `inner_smul_left)
                     ","
                     (Tactic.simpLemma [] [] `inner_smul_right)
                     ","
                     (Tactic.simpLemma [] [] `norm_smul)
                     ","
                     (Tactic.simpLemma [] [] `conj_of_real)
                     ","
                     (Tactic.simpLemma [] [] `IsROrC.norm_eq_abs)
                     ","
                     (Tactic.simpLemma [] [] `abs_of_real)
                     ","
                     (Tactic.simpLemma [] [] `of_real_im)
                     ","
                     (Tactic.simpLemma [] [] `of_real_re)
                     ","
                     (Tactic.simpLemma [] [] `mul_re)
                     ","
                     (Tactic.simpLemma [] [] `abs_norm_eq_norm)]
                    "]"]
                   [])
                  []
                  (Tactic.refine' "refine'" (Term.app `Eq.congr [(Term.hole "_") `rfl]))
                  []
                  (Mathlib.Tactic.RingNF.ring "ring")]))))
             (calcStep
              («term_↔_»
               (Term.hole "_")
               "↔"
               («term_=_»
                (Algebra.Group.Defs.«term_•_»
                 (Term.typeAscription
                  "("
                  (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
                  ":"
                  [`𝕜]
                  ")")
                 " • "
                 `x)
                "="
                (Algebra.Group.Defs.«term_•_»
                 (Term.typeAscription
                  "("
                  (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                  ":"
                  [`𝕜]
                  ")")
                 " • "
                 `y)))
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.simp
                   "simp"
                   []
                   []
                   []
                   ["[" [(Tactic.simpLemma [] [] `norm_sub_eq_zero_iff)] "]"]
                   [])]))))])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Classical.«tacticBy_cases_:_»
           "by_cases"
           [`h ":"]
           («term_∨_» («term_=_» `x "=" (num "0")) "∨" («term_=_» `y "=" (num "0"))))
          []
          (tactic__
           (cdotTk (patternIgnore (token.«· » "·")))
           [(Tactic.«tactic_<;>_»
             (Tactic.cases "cases" [(Tactic.casesTarget [] `h)] [] [])
             "<;>"
             (Tactic.simp "simp" [] [] [] ["[" [(Tactic.simpLemma [] [] `h)] "]"] []))])
          []
          (calcTactic
           "calc"
           (calcStep
            («term_↔_»
             («term_=_»
              (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
              "="
              («term_*_»
               (Term.typeAscription
                "("
                (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                ":"
                [`𝕜]
                ")")
               "*"
               (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
             "↔"
             («term_=_»
              («term_*_»
               (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
               "*"
               (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
              "="
              (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))
            ":="
            (Term.byTactic
             "by"
             (Tactic.tacticSeq
              (Tactic.tacticSeq1Indented
               [(Tactic.NormCast.tacticNorm_cast__ "norm_cast" [])
                []
                (Tactic.constructor "constructor")
                []
                (tactic__
                 (cdotTk (patternIgnore (token.«· » "·")))
                 [(Tactic.intro "intro" [`h'])
                  []
                  (Tactic.simp "simp" [] [] [] ["[" [(Tactic.simpLemma [] [] `h')] "]"] [])])
                []
                (tactic__
                 (cdotTk (patternIgnore (token.«· » "·")))
                 [(Tactic.tacticHave_
                   "have"
                   (Term.haveDecl
                    (Term.haveIdDecl
                     [`cauchy_schwarz []]
                     []
                     ":="
                     (Term.app `abs_inner_le_norm [`x `y]))))
                  []
                  (Tactic.intro "intro" [`h'])
                  []
                  (Tactic.rwSeq
                   "rw"
                   []
                   (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `h')] "]")
                   [(Tactic.location
                     "at"
                     (Tactic.locationHyp [`cauchy_schwarz] [(patternIgnore (token.«⊢» "⊢"))]))])
                  []
                  (Std.Tactic.tacticRwa__
                   "rwa"
                   (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `re_eq_self_of_le)] "]")
                   [])])]))))
           [(calcStep
             («term_↔_»
              (Term.hole "_")
              "↔"
              («term_=_»
               («term_*_»
                («term_*_»
                 («term_*_» (num "2") "*" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
                 "*"
                 (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
                "*"
                («term_-_»
                 («term_*_»
                  (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                  "*"
                  (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
                 "-"
                 (Term.app
                  `re
                  [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))
               "="
               (num "0")))
             ":="
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Tactic.simp
                  "simp"
                  []
                  []
                  []
                  ["["
                   [(Tactic.simpLemma [] [] `h)
                    ","
                    (Tactic.simpLemma
                     []
                     []
                     (Term.show
                      "show"
                      («term_≠_»
                       (Term.typeAscription "(" (num "2") ":" [(Data.Real.Basic.termℝ "ℝ")] ")")
                       "≠"
                       (num "0"))
                      (Term.byTactic'
                       "by"
                       (Tactic.tacticSeq
                        (Tactic.tacticSeq1Indented
                         [(Mathlib.Tactic.normNum "norm_num" [] [] [])])))))
                    ","
                    (Tactic.simpLemma [] [] `sub_eq_zero)]
                   "]"]
                  [])]))))
            (calcStep
             («term_↔_»
              (Term.hole "_")
              "↔"
              («term_=_»
               («term_*_»
                (Analysis.Normed.Group.Basic.«term‖_‖»
                 "‖"
                 («term_-_»
                  (Algebra.Group.Defs.«term_•_»
                   (Term.typeAscription
                    "("
                    (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
                    ":"
                    [`𝕜]
                    ")")
                   " • "
                   `x)
                  "-"
                  (Algebra.Group.Defs.«term_•_»
                   (Term.typeAscription
                    "("
                    (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                    ":"
                    [`𝕜]
                    ")")
                   " • "
                   `y))
                 "‖")
                "*"
                (Analysis.Normed.Group.Basic.«term‖_‖»
                 "‖"
                 («term_-_»
                  (Algebra.Group.Defs.«term_•_»
                   (Term.typeAscription
                    "("
                    (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
                    ":"
                    [`𝕜]
                    ")")
                   " • "
                   `x)
                  "-"
                  (Algebra.Group.Defs.«term_•_»
                   (Term.typeAscription
                    "("
                    (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                    ":"
                    [`𝕜]
                    ")")
                   " • "
                   `y))
                 "‖"))
               "="
               (num "0")))
             ":="
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Tactic.simp
                  "simp"
                  []
                  []
                  ["only"]
                  ["["
                   [(Tactic.simpLemma [] [] `norm_sub_mul_self)
                    ","
                    (Tactic.simpLemma [] [] `inner_smul_left)
                    ","
                    (Tactic.simpLemma [] [] `inner_smul_right)
                    ","
                    (Tactic.simpLemma [] [] `norm_smul)
                    ","
                    (Tactic.simpLemma [] [] `conj_of_real)
                    ","
                    (Tactic.simpLemma [] [] `IsROrC.norm_eq_abs)
                    ","
                    (Tactic.simpLemma [] [] `abs_of_real)
                    ","
                    (Tactic.simpLemma [] [] `of_real_im)
                    ","
                    (Tactic.simpLemma [] [] `of_real_re)
                    ","
                    (Tactic.simpLemma [] [] `mul_re)
                    ","
                    (Tactic.simpLemma [] [] `abs_norm_eq_norm)]
                   "]"]
                  [])
                 []
                 (Tactic.refine' "refine'" (Term.app `Eq.congr [(Term.hole "_") `rfl]))
                 []
                 (Mathlib.Tactic.RingNF.ring "ring")]))))
            (calcStep
             («term_↔_»
              (Term.hole "_")
              "↔"
              («term_=_»
               (Algebra.Group.Defs.«term_•_»
                (Term.typeAscription
                 "("
                 (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
                 ":"
                 [`𝕜]
                 ")")
                " • "
                `x)
               "="
               (Algebra.Group.Defs.«term_•_»
                (Term.typeAscription
                 "("
                 (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                 ":"
                 [`𝕜]
                 ")")
                " • "
                `y)))
             ":="
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Tactic.simp
                  "simp"
                  []
                  []
                  []
                  ["[" [(Tactic.simpLemma [] [] `norm_sub_eq_zero_iff)] "]"]
                  [])]))))])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (calcTactic
       "calc"
       (calcStep
        («term_↔_»
         («term_=_»
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
          "="
          («term_*_»
           (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") ":" [`𝕜] ")")
           "*"
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")))
         "↔"
         («term_=_»
          («term_*_»
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
           "*"
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
          "="
          (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))
        ":="
        (Term.byTactic
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(Tactic.NormCast.tacticNorm_cast__ "norm_cast" [])
            []
            (Tactic.constructor "constructor")
            []
            (tactic__
             (cdotTk (patternIgnore (token.«· » "·")))
             [(Tactic.intro "intro" [`h'])
              []
              (Tactic.simp "simp" [] [] [] ["[" [(Tactic.simpLemma [] [] `h')] "]"] [])])
            []
            (tactic__
             (cdotTk (patternIgnore (token.«· » "·")))
             [(Tactic.tacticHave_
               "have"
               (Term.haveDecl
                (Term.haveIdDecl
                 [`cauchy_schwarz []]
                 []
                 ":="
                 (Term.app `abs_inner_le_norm [`x `y]))))
              []
              (Tactic.intro "intro" [`h'])
              []
              (Tactic.rwSeq
               "rw"
               []
               (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `h')] "]")
               [(Tactic.location
                 "at"
                 (Tactic.locationHyp [`cauchy_schwarz] [(patternIgnore (token.«⊢» "⊢"))]))])
              []
              (Std.Tactic.tacticRwa__
               "rwa"
               (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `re_eq_self_of_le)] "]")
               [])])]))))
       [(calcStep
         («term_↔_»
          (Term.hole "_")
          "↔"
          («term_=_»
           («term_*_»
            («term_*_»
             («term_*_» (num "2") "*" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
             "*"
             (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
            "*"
            («term_-_»
             («term_*_»
              (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
              "*"
              (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
             "-"
             (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))
           "="
           (num "0")))
         ":="
         (Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(Tactic.simp
              "simp"
              []
              []
              []
              ["["
               [(Tactic.simpLemma [] [] `h)
                ","
                (Tactic.simpLemma
                 []
                 []
                 (Term.show
                  "show"
                  («term_≠_»
                   (Term.typeAscription "(" (num "2") ":" [(Data.Real.Basic.termℝ "ℝ")] ")")
                   "≠"
                   (num "0"))
                  (Term.byTactic'
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented [(Mathlib.Tactic.normNum "norm_num" [] [] [])])))))
                ","
                (Tactic.simpLemma [] [] `sub_eq_zero)]
               "]"]
              [])]))))
        (calcStep
         («term_↔_»
          (Term.hole "_")
          "↔"
          («term_=_»
           («term_*_»
            (Analysis.Normed.Group.Basic.«term‖_‖»
             "‖"
             («term_-_»
              (Algebra.Group.Defs.«term_•_»
               (Term.typeAscription
                "("
                (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
                ":"
                [`𝕜]
                ")")
               " • "
               `x)
              "-"
              (Algebra.Group.Defs.«term_•_»
               (Term.typeAscription
                "("
                (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                ":"
                [`𝕜]
                ")")
               " • "
               `y))
             "‖")
            "*"
            (Analysis.Normed.Group.Basic.«term‖_‖»
             "‖"
             («term_-_»
              (Algebra.Group.Defs.«term_•_»
               (Term.typeAscription
                "("
                (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
                ":"
                [`𝕜]
                ")")
               " • "
               `x)
              "-"
              (Algebra.Group.Defs.«term_•_»
               (Term.typeAscription
                "("
                (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                ":"
                [`𝕜]
                ")")
               " • "
               `y))
             "‖"))
           "="
           (num "0")))
         ":="
         (Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(Tactic.simp
              "simp"
              []
              []
              ["only"]
              ["["
               [(Tactic.simpLemma [] [] `norm_sub_mul_self)
                ","
                (Tactic.simpLemma [] [] `inner_smul_left)
                ","
                (Tactic.simpLemma [] [] `inner_smul_right)
                ","
                (Tactic.simpLemma [] [] `norm_smul)
                ","
                (Tactic.simpLemma [] [] `conj_of_real)
                ","
                (Tactic.simpLemma [] [] `IsROrC.norm_eq_abs)
                ","
                (Tactic.simpLemma [] [] `abs_of_real)
                ","
                (Tactic.simpLemma [] [] `of_real_im)
                ","
                (Tactic.simpLemma [] [] `of_real_re)
                ","
                (Tactic.simpLemma [] [] `mul_re)
                ","
                (Tactic.simpLemma [] [] `abs_norm_eq_norm)]
               "]"]
              [])
             []
             (Tactic.refine' "refine'" (Term.app `Eq.congr [(Term.hole "_") `rfl]))
             []
             (Mathlib.Tactic.RingNF.ring "ring")]))))
        (calcStep
         («term_↔_»
          (Term.hole "_")
          "↔"
          («term_=_»
           (Algebra.Group.Defs.«term_•_»
            (Term.typeAscription
             "("
             (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
             ":"
             [`𝕜]
             ")")
            " • "
            `x)
           "="
           (Algebra.Group.Defs.«term_•_»
            (Term.typeAscription
             "("
             (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
             ":"
             [`𝕜]
             ")")
            " • "
            `y)))
         ":="
         (Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(Tactic.simp
              "simp"
              []
              []
              []
              ["[" [(Tactic.simpLemma [] [] `norm_sub_eq_zero_iff)] "]"]
              [])]))))])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           []
           ["[" [(Tactic.simpLemma [] [] `norm_sub_eq_zero_iff)] "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp "simp" [] [] [] ["[" [(Tactic.simpLemma [] [] `norm_sub_eq_zero_iff)] "]"] [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `norm_sub_eq_zero_iff
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_↔_»
       (Term.hole "_")
       "↔"
       («term_=_»
        (Algebra.Group.Defs.«term_•_»
         (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖") ":" [`𝕜] ")")
         " • "
         `x)
        "="
        (Algebra.Group.Defs.«term_•_»
         (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") ":" [`𝕜] ")")
         " • "
         `y)))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_»
       (Algebra.Group.Defs.«term_•_»
        (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖") ":" [`𝕜] ")")
        " • "
        `x)
       "="
       (Algebra.Group.Defs.«term_•_»
        (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") ":" [`𝕜] ")")
        " • "
        `y))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Algebra.Group.Defs.«term_•_»
       (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") ":" [`𝕜] ")")
       " • "
       `y)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 73 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 73, term))
      (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") ":" [`𝕜] ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `𝕜
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 74 >? 1024, (none, [anonymous]) <=? (some 73, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 73, (some 73, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Algebra.Group.Defs.«term_•_»
       (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖") ":" [`𝕜] ")")
       " • "
       `x)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 73 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 73, term))
      (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖") ":" [`𝕜] ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `𝕜
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 74 >? 1024, (none, [anonymous]) <=? (some 73, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 73, (some 73, term) <=? (some 50, term)
[PrettyPrinter.parenthesize] ...precedences are 21 >? 50, (some 51, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 20, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 21 >? 1024, (none, [anonymous]) <=? (some 20, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 20, (some 21, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, term))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["["
            [(Tactic.simpLemma [] [] `norm_sub_mul_self)
             ","
             (Tactic.simpLemma [] [] `inner_smul_left)
             ","
             (Tactic.simpLemma [] [] `inner_smul_right)
             ","
             (Tactic.simpLemma [] [] `norm_smul)
             ","
             (Tactic.simpLemma [] [] `conj_of_real)
             ","
             (Tactic.simpLemma [] [] `IsROrC.norm_eq_abs)
             ","
             (Tactic.simpLemma [] [] `abs_of_real)
             ","
             (Tactic.simpLemma [] [] `of_real_im)
             ","
             (Tactic.simpLemma [] [] `of_real_re)
             ","
             (Tactic.simpLemma [] [] `mul_re)
             ","
             (Tactic.simpLemma [] [] `abs_norm_eq_norm)]
            "]"]
           [])
          []
          (Tactic.refine' "refine'" (Term.app `Eq.congr [(Term.hole "_") `rfl]))
          []
          (Mathlib.Tactic.RingNF.ring "ring")])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.RingNF.ring "ring")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.refine' "refine'" (Term.app `Eq.congr [(Term.hole "_") `rfl]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `Eq.congr [(Term.hole "_") `rfl])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `rfl
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `Eq.congr
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] `norm_sub_mul_self)
         ","
         (Tactic.simpLemma [] [] `inner_smul_left)
         ","
         (Tactic.simpLemma [] [] `inner_smul_right)
         ","
         (Tactic.simpLemma [] [] `norm_smul)
         ","
         (Tactic.simpLemma [] [] `conj_of_real)
         ","
         (Tactic.simpLemma [] [] `IsROrC.norm_eq_abs)
         ","
         (Tactic.simpLemma [] [] `abs_of_real)
         ","
         (Tactic.simpLemma [] [] `of_real_im)
         ","
         (Tactic.simpLemma [] [] `of_real_re)
         ","
         (Tactic.simpLemma [] [] `mul_re)
         ","
         (Tactic.simpLemma [] [] `abs_norm_eq_norm)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `abs_norm_eq_norm
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `mul_re
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `of_real_re
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `of_real_im
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `abs_of_real
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `IsROrC.norm_eq_abs
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `conj_of_real
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `norm_smul
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_smul_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_smul_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `norm_sub_mul_self
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_↔_»
       (Term.hole "_")
       "↔"
       («term_=_»
        («term_*_»
         (Analysis.Normed.Group.Basic.«term‖_‖»
          "‖"
          («term_-_»
           (Algebra.Group.Defs.«term_•_»
            (Term.typeAscription
             "("
             (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
             ":"
             [`𝕜]
             ")")
            " • "
            `x)
           "-"
           (Algebra.Group.Defs.«term_•_»
            (Term.typeAscription
             "("
             (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
             ":"
             [`𝕜]
             ")")
            " • "
            `y))
          "‖")
         "*"
         (Analysis.Normed.Group.Basic.«term‖_‖»
          "‖"
          («term_-_»
           (Algebra.Group.Defs.«term_•_»
            (Term.typeAscription
             "("
             (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
             ":"
             [`𝕜]
             ")")
            " • "
            `x)
           "-"
           (Algebra.Group.Defs.«term_•_»
            (Term.typeAscription
             "("
             (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
             ":"
             [`𝕜]
             ")")
            " • "
            `y))
          "‖"))
        "="
        (num "0")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_»
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖»
         "‖"
         («term_-_»
          (Algebra.Group.Defs.«term_•_»
           (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖") ":" [`𝕜] ")")
           " • "
           `x)
          "-"
          (Algebra.Group.Defs.«term_•_»
           (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") ":" [`𝕜] ")")
           " • "
           `y))
         "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖»
         "‖"
         («term_-_»
          (Algebra.Group.Defs.«term_•_»
           (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖") ":" [`𝕜] ")")
           " • "
           `x)
          "-"
          (Algebra.Group.Defs.«term_•_»
           (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") ":" [`𝕜] ")")
           " • "
           `y))
         "‖"))
       "="
       (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      («term_*_»
       (Analysis.Normed.Group.Basic.«term‖_‖»
        "‖"
        («term_-_»
         (Algebra.Group.Defs.«term_•_»
          (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖") ":" [`𝕜] ")")
          " • "
          `x)
         "-"
         (Algebra.Group.Defs.«term_•_»
          (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") ":" [`𝕜] ")")
          " • "
          `y))
        "‖")
       "*"
       (Analysis.Normed.Group.Basic.«term‖_‖»
        "‖"
        («term_-_»
         (Algebra.Group.Defs.«term_•_»
          (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖") ":" [`𝕜] ")")
          " • "
          `x)
         "-"
         (Algebra.Group.Defs.«term_•_»
          (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") ":" [`𝕜] ")")
          " • "
          `y))
        "‖"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖»
       "‖"
       («term_-_»
        (Algebra.Group.Defs.«term_•_»
         (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖") ":" [`𝕜] ")")
         " • "
         `x)
        "-"
        (Algebra.Group.Defs.«term_•_»
         (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") ":" [`𝕜] ")")
         " • "
         `y))
       "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_-_»
       (Algebra.Group.Defs.«term_•_»
        (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖") ":" [`𝕜] ")")
        " • "
        `x)
       "-"
       (Algebra.Group.Defs.«term_•_»
        (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") ":" [`𝕜] ")")
        " • "
        `y))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Algebra.Group.Defs.«term_•_»
       (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") ":" [`𝕜] ")")
       " • "
       `y)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 73 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 73, term))
      (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") ":" [`𝕜] ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `𝕜
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 74 >? 1024, (none, [anonymous]) <=? (some 73, term)
[PrettyPrinter.parenthesize] ...precedences are 66 >? 73, (some 73, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 65, term))
      (Algebra.Group.Defs.«term_•_»
       (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖") ":" [`𝕜] ")")
       " • "
       `x)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 73 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 73, term))
      (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖") ":" [`𝕜] ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `𝕜
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 74 >? 1024, (none, [anonymous]) <=? (some 73, term)
[PrettyPrinter.parenthesize] ...precedences are 65 >? 73, (some 73, term) <=? (some 65, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 65, (some 66, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Analysis.Normed.Group.Basic.«term‖_‖»
       "‖"
       («term_-_»
        (Algebra.Group.Defs.«term_•_»
         (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖") ":" [`𝕜] ")")
         " • "
         `x)
        "-"
        (Algebra.Group.Defs.«term_•_»
         (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") ":" [`𝕜] ")")
         " • "
         `y))
       "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_-_»
       (Algebra.Group.Defs.«term_•_»
        (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖") ":" [`𝕜] ")")
        " • "
        `x)
       "-"
       (Algebra.Group.Defs.«term_•_»
        (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") ":" [`𝕜] ")")
        " • "
        `y))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Algebra.Group.Defs.«term_•_»
       (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") ":" [`𝕜] ")")
       " • "
       `y)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 73 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 73, term))
      (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") ":" [`𝕜] ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `𝕜
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 74 >? 1024, (none, [anonymous]) <=? (some 73, term)
[PrettyPrinter.parenthesize] ...precedences are 66 >? 73, (some 73, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 65, term))
      (Algebra.Group.Defs.«term_•_»
       (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖") ":" [`𝕜] ")")
       " • "
       `x)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 73 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 73, term))
      (Term.typeAscription "(" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖") ":" [`𝕜] ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `𝕜
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 74 >? 1024, (none, [anonymous]) <=? (some 73, term)
[PrettyPrinter.parenthesize] ...precedences are 65 >? 73, (some 73, term) <=? (some 65, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 65, (some 66, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1024, (none, [anonymous]) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 70, (some 71, term) <=? (some 50, term)
[PrettyPrinter.parenthesize] ...precedences are 21 >? 50, (some 51, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 20, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 21 >? 1024, (none, [anonymous]) <=? (some 20, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 20, (some 21, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, term))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           []
           ["["
            [(Tactic.simpLemma [] [] `h)
             ","
             (Tactic.simpLemma
              []
              []
              (Term.show
               "show"
               («term_≠_»
                (Term.typeAscription "(" (num "2") ":" [(Data.Real.Basic.termℝ "ℝ")] ")")
                "≠"
                (num "0"))
               (Term.byTactic'
                "by"
                (Tactic.tacticSeq
                 (Tactic.tacticSeq1Indented [(Mathlib.Tactic.normNum "norm_num" [] [] [])])))))
             ","
             (Tactic.simpLemma [] [] `sub_eq_zero)]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       []
       ["["
        [(Tactic.simpLemma [] [] `h)
         ","
         (Tactic.simpLemma
          []
          []
          (Term.show
           "show"
           («term_≠_»
            (Term.typeAscription "(" (num "2") ":" [(Data.Real.Basic.termℝ "ℝ")] ")")
            "≠"
            (num "0"))
           (Term.byTactic'
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented [(Mathlib.Tactic.normNum "norm_num" [] [] [])])))))
         ","
         (Tactic.simpLemma [] [] `sub_eq_zero)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `sub_eq_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.show
       "show"
       («term_≠_»
        (Term.typeAscription "(" (num "2") ":" [(Data.Real.Basic.termℝ "ℝ")] ")")
        "≠"
        (num "0"))
       (Term.byTactic'
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented [(Mathlib.Tactic.normNum "norm_num" [] [] [])]))))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.byTactic'', expected 'Lean.Parser.Term.fromTerm'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.normNum "norm_num" [] [] [])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_≠_»
       (Term.typeAscription "(" (num "2") ":" [(Data.Real.Basic.termℝ "ℝ")] ")")
       "≠"
       (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Term.typeAscription "(" (num "2") ":" [(Data.Real.Basic.termℝ "ℝ")] ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Data.Real.Basic.termℝ "ℝ")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "2")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none, [anonymous]) <=? (some 50, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 50, (some 51,
     term) <=? (some 1023, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_↔_»
       (Term.hole "_")
       "↔"
       («term_=_»
        («term_*_»
         («term_*_»
          («term_*_» (num "2") "*" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
          "*"
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
         "*"
         («term_-_»
          («term_*_»
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
           "*"
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
          "-"
          (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))
        "="
        (num "0")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_»
       («term_*_»
        («term_*_»
         («term_*_» (num "2") "*" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
         "*"
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
        "*"
        («term_-_»
         («term_*_»
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
          "*"
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
         "-"
         (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))
       "="
       (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      («term_*_»
       («term_*_»
        («term_*_» (num "2") "*" (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
       "*"
       («term_-_»
        («term_*_»
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
         "*"
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
        "-"
        (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_-_»
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖"))
       "-"
       (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    If the inner product of two vectors is equal to the product of their norms (i.e.,
    `⟪x, y⟫ = ‖x‖ * ‖y‖`), then the two vectors are nonnegative real multiples of each other. One form
    of the equality case for Cauchy-Schwarz.
    Compare `abs_inner_eq_norm_iff`, which takes the weaker hypothesis `abs ⟪x, y⟫ = ‖x‖ * ‖y‖`. -/
  theorem
    inner_eq_norm_mul_iff
    { x y : E } : ⟪ x , y ⟫ = ( ‖ x ‖ : 𝕜 ) * ‖ y ‖ ↔ ( ‖ y ‖ : 𝕜 ) • x = ( ‖ x ‖ : 𝕜 ) • y
    :=
      by
        by_cases h : x = 0 ∨ y = 0
          · cases h <;> simp [ h ]
          calc
            ⟪ x , y ⟫ = ( ‖ x ‖ : 𝕜 ) * ‖ y ‖ ↔ ‖ x ‖ * ‖ y ‖ = re ⟪ x , y ⟫
              :=
              by
                norm_cast
                  constructor
                  · intro h' simp [ h' ]
                  ·
                    have cauchy_schwarz := abs_inner_le_norm x y
                      intro h'
                      rw [ h' ] at cauchy_schwarz ⊢
                      rwa [ re_eq_self_of_le ]
            _ ↔ 2 * ‖ x ‖ * ‖ y ‖ * ‖ x ‖ * ‖ y ‖ - re ⟪ x , y ⟫ = 0
                :=
                by simp [ h , show ( 2 : ℝ ) ≠ 0 by norm_num , sub_eq_zero ]
              _
                  ↔
                  ‖ ( ‖ y ‖ : 𝕜 ) • x - ( ‖ x ‖ : 𝕜 ) • y ‖
                      *
                      ‖ ( ‖ y ‖ : 𝕜 ) • x - ( ‖ x ‖ : 𝕜 ) • y ‖
                    =
                    0
                :=
                by
                  simp
                      only
                      [
                        norm_sub_mul_self
                          ,
                          inner_smul_left
                          ,
                          inner_smul_right
                          ,
                          norm_smul
                          ,
                          conj_of_real
                          ,
                          IsROrC.norm_eq_abs
                          ,
                          abs_of_real
                          ,
                          of_real_im
                          ,
                          of_real_re
                          ,
                          mul_re
                          ,
                          abs_norm_eq_norm
                        ]
                    refine' Eq.congr _ rfl
                    ring
              _ ↔ ( ‖ y ‖ : 𝕜 ) • x = ( ‖ x ‖ : 𝕜 ) • y := by simp [ norm_sub_eq_zero_iff ]
#align inner_eq_norm_mul_iff inner_eq_norm_mul_iff

/-- If the inner product of two vectors is equal to the product of their norms (i.e.,
`⟪x, y⟫ = ‖x‖ * ‖y‖`), then the two vectors are nonnegative real multiples of each other. One form
of the equality case for Cauchy-Schwarz.
Compare `abs_inner_eq_norm_iff`, which takes the weaker hypothesis `abs ⟪x, y⟫ = ‖x‖ * ‖y‖`. -/
theorem inner_eq_norm_mul_iff_real {x y : F} : ⟪x, y⟫_ℝ = ‖x‖ * ‖y‖ ↔ ‖y‖ • x = ‖x‖ • y :=
  inner_eq_norm_mul_iff
#align inner_eq_norm_mul_iff_real inner_eq_norm_mul_iff_real

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "If the inner product of two unit vectors is `1`, then the two vectors are equal. One form of\nthe equality case for Cauchy-Schwarz. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `inner_eq_norm_mul_iff_of_norm_one [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `E] "}")
        (Term.explicitBinder
         "("
         [`hx]
         [":" («term_=_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "=" (num "1"))]
         []
         ")")
        (Term.explicitBinder
         "("
         [`hy]
         [":" («term_=_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `y "‖") "=" (num "1"))]
         []
         ")")]
       (Term.typeSpec
        ":"
        («term_↔_»
         («term_=_» (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫") "=" (num "1"))
         "↔"
         («term_=_» `x "=" `y))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.«tactic_<;>_»
            (convert "convert" [] `inner_eq_norm_mul_iff ["using" (num "2")])
            "<;>"
            (Tactic.simp
             "simp"
             []
             []
             []
             ["[" [(Tactic.simpLemma [] [] `hx) "," (Tactic.simpLemma [] [] `hy)] "]"]
             []))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.«tactic_<;>_»
           (convert "convert" [] `inner_eq_norm_mul_iff ["using" (num "2")])
           "<;>"
           (Tactic.simp
            "simp"
            []
            []
            []
            ["[" [(Tactic.simpLemma [] [] `hx) "," (Tactic.simpLemma [] [] `hy)] "]"]
            []))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.«tactic_<;>_»
       (convert "convert" [] `inner_eq_norm_mul_iff ["using" (num "2")])
       "<;>"
       (Tactic.simp
        "simp"
        []
        []
        []
        ["[" [(Tactic.simpLemma [] [] `hx) "," (Tactic.simpLemma [] [] `hy)] "]"]
        []))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       []
       ["[" [(Tactic.simpLemma [] [] `hx) "," (Tactic.simpLemma [] [] `hy)] "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hy
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hx
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 2 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1, tactic))
      (convert "convert" [] `inner_eq_norm_mul_iff ["using" (num "2")])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_eq_norm_mul_iff
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_↔_»
       («term_=_» (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫") "=" (num "1"))
       "↔"
       («term_=_» `x "=" `y))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_» `x "=" `y)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none, [anonymous]) <=? (some 50, term)
[PrettyPrinter.parenthesize] ...precedences are 21 >? 50, (some 51, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 20, term))
      («term_=_» (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫") "=" (num "1"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "1")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    If the inner product of two unit vectors is `1`, then the two vectors are equal. One form of
    the equality case for Cauchy-Schwarz. -/
  theorem
    inner_eq_norm_mul_iff_of_norm_one
    { x y : E } ( hx : ‖ x ‖ = 1 ) ( hy : ‖ y ‖ = 1 ) : ⟪ x , y ⟫ = 1 ↔ x = y
    := by convert inner_eq_norm_mul_iff using 2 <;> simp [ hx , hy ]
#align inner_eq_norm_mul_iff_of_norm_one inner_eq_norm_mul_iff_of_norm_one

theorem inner_lt_norm_mul_iff_real {x y : F} : ⟪x, y⟫_ℝ < ‖x‖ * ‖y‖ ↔ ‖y‖ • x ≠ ‖x‖ • y :=
  calc
    ⟪x, y⟫_ℝ < ‖x‖ * ‖y‖ ↔ ⟪x, y⟫_ℝ ≠ ‖x‖ * ‖y‖ :=
      ⟨ne_of_lt, lt_of_le_of_ne (real_inner_le_norm _ _)⟩
    _ ↔ ‖y‖ • x ≠ ‖x‖ • y := not_congr inner_eq_norm_mul_iff_real
    
#align inner_lt_norm_mul_iff_real inner_lt_norm_mul_iff_real

/-- If the inner product of two unit vectors is strictly less than `1`, then the two vectors are
distinct. One form of the equality case for Cauchy-Schwarz. -/
theorem inner_lt_one_iff_real_of_norm_one {x y : F} (hx : ‖x‖ = 1) (hy : ‖y‖ = 1) :
    ⟪x, y⟫_ℝ < 1 ↔ x ≠ y := by convert inner_lt_norm_mul_iff_real <;> simp [hx, hy]
#align inner_lt_one_iff_real_of_norm_one inner_lt_one_iff_real_of_norm_one

/-- The inner product of two weighted sums, where the weights in each
sum add to 0, in terms of the norms of pairwise differences. -/
theorem inner_sum_smul_sum_smul_of_sum_eq_zero {ι₁ : Type _} {s₁ : Finset ι₁} {w₁ : ι₁ → ℝ}
    (v₁ : ι₁ → F) (h₁ : (∑ i in s₁, w₁ i) = 0) {ι₂ : Type _} {s₂ : Finset ι₂} {w₂ : ι₂ → ℝ}
    (v₂ : ι₂ → F) (h₂ : (∑ i in s₂, w₂ i) = 0) :
    ⟪∑ i₁ in s₁, w₁ i₁ • v₁ i₁, ∑ i₂ in s₂, w₂ i₂ • v₂ i₂⟫_ℝ =
      (-∑ i₁ in s₁, ∑ i₂ in s₂, w₁ i₁ * w₂ i₂ * (‖v₁ i₁ - v₂ i₂‖ * ‖v₁ i₁ - v₂ i₂‖)) / 2 :=
  by
  simp_rw [sum_inner, inner_sum, real_inner_smul_left, real_inner_smul_right,
    real_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two, ← div_sub_div_same,
    ← div_add_div_same, mul_sub_left_distrib, left_distrib, Finset.sum_sub_distrib,
    Finset.sum_add_distrib, ← Finset.mul_sum, ← Finset.sum_mul, h₁, h₂, zero_mul, mul_zero,
    Finset.sum_const_zero, zero_add, zero_sub, Finset.mul_sum, neg_div, Finset.sum_div,
    mul_div_assoc, mul_assoc]
#align inner_sum_smul_sum_smul_of_sum_eq_zero inner_sum_smul_sum_smul_of_sum_eq_zero

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment "/--" "The inner product as a sesquilinear map. -/")]
      []
      []
      []
      []
      [])
     (Command.def
      "def"
      (Command.declId `innerₛₗ [])
      (Command.optDeclSig
       []
       [(Term.typeSpec
         ":"
         (Algebra.Module.LinearMap.«term_→ₗ⋆[_]_»
          `E
          " →ₗ⋆["
          `𝕜
          "] "
          (Algebra.Module.LinearMap.«term_→ₗ[_]_» `E " →ₗ[" `𝕜 "] " `𝕜)))])
      (Command.declValSimple
       ":="
       (Term.app
        `LinearMap.mk₂'ₛₗ
        [(Term.hole "_")
         (Term.hole "_")
         (Term.fun
          "fun"
          (Term.basicFun
           [`v `w]
           []
           "=>"
           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `w "⟫")))
         (Term.fun
          "fun"
          (Term.basicFun [(Term.hole "_") (Term.hole "_") (Term.hole "_")] [] "=>" `inner_add_left))
         (Term.fun
          "fun"
          (Term.basicFun
           [(Term.hole "_") (Term.hole "_") (Term.hole "_")]
           []
           "=>"
           `inner_smul_left))
         (Term.fun
          "fun"
          (Term.basicFun
           [(Term.hole "_") (Term.hole "_") (Term.hole "_")]
           []
           "=>"
           `inner_add_right))
         (Term.fun
          "fun"
          (Term.basicFun
           [(Term.hole "_") (Term.hole "_") (Term.hole "_")]
           []
           "=>"
           `inner_smul_right))])
       [])
      []
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `LinearMap.mk₂'ₛₗ
       [(Term.hole "_")
        (Term.hole "_")
        (Term.fun
         "fun"
         (Term.basicFun
          [`v `w]
          []
          "=>"
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `w "⟫")))
        (Term.fun
         "fun"
         (Term.basicFun [(Term.hole "_") (Term.hole "_") (Term.hole "_")] [] "=>" `inner_add_left))
        (Term.fun
         "fun"
         (Term.basicFun [(Term.hole "_") (Term.hole "_") (Term.hole "_")] [] "=>" `inner_smul_left))
        (Term.fun
         "fun"
         (Term.basicFun [(Term.hole "_") (Term.hole "_") (Term.hole "_")] [] "=>" `inner_add_right))
        (Term.fun
         "fun"
         (Term.basicFun
          [(Term.hole "_") (Term.hole "_") (Term.hole "_")]
          []
          "=>"
          `inner_smul_right))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun
       "fun"
       (Term.basicFun [(Term.hole "_") (Term.hole "_") (Term.hole "_")] [] "=>" `inner_smul_right))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_smul_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.fun
       "fun"
       (Term.basicFun [(Term.hole "_") (Term.hole "_") (Term.hole "_")] [] "=>" `inner_add_right))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_add_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (some 0, term) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.fun
      "fun"
      (Term.basicFun [(Term.hole "_") (Term.hole "_") (Term.hole "_")] [] "=>" `inner_add_right))
     ")")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.fun
       "fun"
       (Term.basicFun [(Term.hole "_") (Term.hole "_") (Term.hole "_")] [] "=>" `inner_smul_left))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_smul_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (some 0, term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.fun
      "fun"
      (Term.basicFun [(Term.hole "_") (Term.hole "_") (Term.hole "_")] [] "=>" `inner_smul_left))
     ")")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.fun
       "fun"
       (Term.basicFun [(Term.hole "_") (Term.hole "_") (Term.hole "_")] [] "=>" `inner_add_left))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_add_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (some 0, term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.fun
      "fun"
      (Term.basicFun [(Term.hole "_") (Term.hole "_") (Term.hole "_")] [] "=>" `inner_add_left))
     ")")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.fun
       "fun"
       (Term.basicFun
        [`v `w]
        []
        "=>"
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `w "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `w "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.matchAlts'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.theorem'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- The inner product as a sesquilinear map. -/
  def
    innerₛₗ
    : E →ₗ⋆[ 𝕜 ] E →ₗ[ 𝕜 ] 𝕜
    :=
      LinearMap.mk₂'ₛₗ
        _
          _
          fun v w => ⟪ v , w ⟫
          fun _ _ _ => inner_add_left
          fun _ _ _ => inner_smul_left
          fun _ _ _ => inner_add_right
          fun _ _ _ => inner_smul_right
#align innerₛₗ innerₛₗ

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      []
      [(Term.attributes "@[" [(Term.attrInstance (Term.attrKind []) (Attr.simp "simp" [] []))] "]")]
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `innerₛₗ_apply_coe [])
      (Command.declSig
       [(Term.explicitBinder "(" [`v] [":" `E] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.typeAscription "(" (Term.app `innerₛₗ [`v]) ":" [(Term.arrow `E "→" `𝕜)] ")")
         "="
         (Term.fun
          "fun"
          (Term.basicFun
           [`w]
           []
           "=>"
           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `w "⟫"))))))
      (Command.declValSimple ":=" `rfl [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `rfl
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Term.typeAscription "(" (Term.app `innerₛₗ [`v]) ":" [(Term.arrow `E "→" `𝕜)] ")")
       "="
       (Term.fun
        "fun"
        (Term.basicFun
         [`w]
         []
         "=>"
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `w "⟫"))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun
       "fun"
       (Term.basicFun
        [`w]
        []
        "=>"
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `w "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `w "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.matchAlts'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
@[ simp ] theorem innerₛₗ_apply_coe ( v : E ) : ( innerₛₗ v : E → 𝕜 ) = fun w => ⟪ v , w ⟫ := rfl
#align innerₛₗ_apply_coe innerₛₗ_apply_coe

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      []
      [(Term.attributes "@[" [(Term.attrInstance (Term.attrKind []) (Attr.simp "simp" [] []))] "]")]
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `innerₛₗ_apply [])
      (Command.declSig
       [(Term.explicitBinder "(" [`v `w] [":" `E] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.app `innerₛₗ [`v `w])
         "="
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `w "⟫"))))
      (Command.declValSimple ":=" `rfl [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `rfl
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Term.app `innerₛₗ [`v `w])
       "="
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `w "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `w "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
@[ simp ] theorem innerₛₗ_apply ( v w : E ) : innerₛₗ v w = ⟪ v , w ⟫ := rfl
#align innerₛₗ_apply innerₛₗ_apply

/-- The inner product as a continuous sesquilinear map. Note that `to_dual_map` (resp. `to_dual`)
in `inner_product_space.dual` is a version of this given as a linear isometry (resp. linear
isometric equivalence). -/
def innerSL : E →L⋆[𝕜] E →L[𝕜] 𝕜 :=
  LinearMap.mkContinuous₂ innerₛₗ 1 fun x y => by
    simp only [norm_inner_le_norm, one_mul, innerₛₗ_apply]
#align innerSL innerSL

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      []
      [(Term.attributes "@[" [(Term.attrInstance (Term.attrKind []) (Attr.simp "simp" [] []))] "]")]
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `innerSL_apply_coe [])
      (Command.declSig
       [(Term.explicitBinder "(" [`v] [":" `E] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.typeAscription "(" (Term.app `innerSL [`v]) ":" [(Term.arrow `E "→" `𝕜)] ")")
         "="
         (Term.fun
          "fun"
          (Term.basicFun
           [`w]
           []
           "=>"
           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `w "⟫"))))))
      (Command.declValSimple ":=" `rfl [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `rfl
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Term.typeAscription "(" (Term.app `innerSL [`v]) ":" [(Term.arrow `E "→" `𝕜)] ")")
       "="
       (Term.fun
        "fun"
        (Term.basicFun
         [`w]
         []
         "=>"
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `w "⟫"))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun
       "fun"
       (Term.basicFun
        [`w]
        []
        "=>"
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `w "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `w "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.matchAlts'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
@[ simp ] theorem innerSL_apply_coe ( v : E ) : ( innerSL v : E → 𝕜 ) = fun w => ⟪ v , w ⟫ := rfl
#align innerSL_apply_coe innerSL_apply_coe

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      []
      [(Term.attributes "@[" [(Term.attrInstance (Term.attrKind []) (Attr.simp "simp" [] []))] "]")]
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `innerSL_apply [])
      (Command.declSig
       [(Term.explicitBinder "(" [`v `w] [":" `E] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.app `innerSL [`v `w])
         "="
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `w "⟫"))))
      (Command.declValSimple ":=" `rfl [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `rfl
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Term.app `innerSL [`v `w])
       "="
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `w "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `w "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
@[ simp ] theorem innerSL_apply ( v w : E ) : innerSL v w = ⟪ v , w ⟫ := rfl
#align innerSL_apply innerSL_apply

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "`innerSL` is an isometry. Note that the associated `linear_isometry` is defined in\n`inner_product_space.dual` as `to_dual_map`.  -/")]
      [(Term.attributes "@[" [(Term.attrInstance (Term.attrKind []) (Attr.simp "simp" [] []))] "]")]
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `innerSL_apply_norm [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.Normed.Group.Basic.«term‖_‖»
          "‖"
          (Term.typeAscription
           "("
           (Term.app `innerSL [`x])
           ":"
           [(Topology.Algebra.Module.Basic.«term_→L[_]_» `E " →L[" `𝕜 "] " `𝕜)]
           ")")
          "‖")
         "="
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.refine'
            "refine'"
            (Term.app
             `le_antisymm
             [(Term.app
               (Term.proj
                (Term.typeAscription
                 "("
                 (Term.app `innerSL [`x])
                 ":"
                 [(Topology.Algebra.Module.Basic.«term_→L[_]_» `E " →L[" `𝕜 "] " `𝕜)]
                 ")")
                "."
                `op_norm_le_bound)
               [(Term.app `norm_nonneg [(Term.hole "_")])
                (Term.fun
                 "fun"
                 (Term.basicFun
                  [`y]
                  []
                  "=>"
                  (Term.app `norm_inner_le_norm [(Term.hole "_") (Term.hole "_")])))])
              (Term.hole "_")]))
           []
           (Tactic.cases'
            "cases'"
            [(Tactic.casesTarget [] (Term.app `eq_or_lt_of_le [(Term.app `norm_nonneg [`x])]))]
            []
            ["with" [(Lean.binderIdent `h) (Lean.binderIdent `h)]])
           []
           (tactic__
            (cdotTk (patternIgnore (token.«· » "·")))
            [(Tactic.tacticHave_
              "have"
              (Term.haveDecl
               (Term.haveIdDecl
                []
                [(Term.typeSpec ":" («term_=_» `x "=" (num "0")))]
                ":="
                (Term.app `norm_eq_zero.mp [(Term.app `Eq.symm [`h])]))))
             []
             (Tactic.simp "simp" [] [] [] ["[" [(Tactic.simpLemma [] [] `this)] "]"] [])])
           []
           (tactic__
            (cdotTk (patternIgnore (token.«· » "·")))
            [(Tactic.refine'
              "refine'"
              (Term.app (Term.proj (Term.app `mul_le_mul_right [`h]) "." `mp) [(Term.hole "_")]))
             []
             (calcTactic
              "calc"
              (calcStep
               («term_=_»
                («term_*_»
                 (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                 "*"
                 (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
                "="
                («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "^" (num "2")))
               ":="
               (Term.byTactic
                "by"
                (Tactic.tacticSeq
                 (Tactic.tacticSeq1Indented [(Mathlib.Tactic.RingNF.ring "ring")]))))
              [(calcStep
                («term_=_»
                 (Term.hole "_")
                 "="
                 (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")]))
                ":="
                (Term.app `norm_sq_eq_inner [(Term.hole "_")]))
               (calcStep
                («term_≤_»
                 (Term.hole "_")
                 "≤"
                 (Term.app
                  `abs
                  [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")]))
                ":="
                (Term.app `re_le_abs [(Term.hole "_")]))
               (calcStep
                («term_=_»
                 (Term.hole "_")
                 "="
                 (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `innerSL [`x `x]) "‖"))
                ":="
                (Term.byTactic
                 "by"
                 (Tactic.tacticSeq
                  (Tactic.tacticSeq1Indented
                   [(Tactic.rwSeq
                     "rw"
                     []
                     (Tactic.rwRuleSeq
                      "["
                      [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `IsROrC.norm_eq_abs)]
                      "]")
                     [])
                    []
                    (Tactic.tacticRfl "rfl")]))))
               (calcStep
                («term_≤_»
                 (Term.hole "_")
                 "≤"
                 («term_*_»
                  (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `innerSL [`x]) "‖")
                  "*"
                  (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")))
                ":="
                (Term.app
                 (Term.proj
                  (Term.typeAscription
                   "("
                   (Term.app `innerSL [`x])
                   ":"
                   [(Topology.Algebra.Module.Basic.«term_→L[_]_» `E " →L[" `𝕜 "] " `𝕜)]
                   ")")
                  "."
                  `le_op_norm)
                 [(Term.hole "_")]))])])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.refine'
           "refine'"
           (Term.app
            `le_antisymm
            [(Term.app
              (Term.proj
               (Term.typeAscription
                "("
                (Term.app `innerSL [`x])
                ":"
                [(Topology.Algebra.Module.Basic.«term_→L[_]_» `E " →L[" `𝕜 "] " `𝕜)]
                ")")
               "."
               `op_norm_le_bound)
              [(Term.app `norm_nonneg [(Term.hole "_")])
               (Term.fun
                "fun"
                (Term.basicFun
                 [`y]
                 []
                 "=>"
                 (Term.app `norm_inner_le_norm [(Term.hole "_") (Term.hole "_")])))])
             (Term.hole "_")]))
          []
          (Tactic.cases'
           "cases'"
           [(Tactic.casesTarget [] (Term.app `eq_or_lt_of_le [(Term.app `norm_nonneg [`x])]))]
           []
           ["with" [(Lean.binderIdent `h) (Lean.binderIdent `h)]])
          []
          (tactic__
           (cdotTk (patternIgnore (token.«· » "·")))
           [(Tactic.tacticHave_
             "have"
             (Term.haveDecl
              (Term.haveIdDecl
               []
               [(Term.typeSpec ":" («term_=_» `x "=" (num "0")))]
               ":="
               (Term.app `norm_eq_zero.mp [(Term.app `Eq.symm [`h])]))))
            []
            (Tactic.simp "simp" [] [] [] ["[" [(Tactic.simpLemma [] [] `this)] "]"] [])])
          []
          (tactic__
           (cdotTk (patternIgnore (token.«· » "·")))
           [(Tactic.refine'
             "refine'"
             (Term.app (Term.proj (Term.app `mul_le_mul_right [`h]) "." `mp) [(Term.hole "_")]))
            []
            (calcTactic
             "calc"
             (calcStep
              («term_=_»
               («term_*_»
                (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
                "*"
                (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
               "="
               («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "^" (num "2")))
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented [(Mathlib.Tactic.RingNF.ring "ring")]))))
             [(calcStep
               («term_=_»
                (Term.hole "_")
                "="
                (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")]))
               ":="
               (Term.app `norm_sq_eq_inner [(Term.hole "_")]))
              (calcStep
               («term_≤_»
                (Term.hole "_")
                "≤"
                (Term.app `abs [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")]))
               ":="
               (Term.app `re_le_abs [(Term.hole "_")]))
              (calcStep
               («term_=_»
                (Term.hole "_")
                "="
                (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `innerSL [`x `x]) "‖"))
               ":="
               (Term.byTactic
                "by"
                (Tactic.tacticSeq
                 (Tactic.tacticSeq1Indented
                  [(Tactic.rwSeq
                    "rw"
                    []
                    (Tactic.rwRuleSeq
                     "["
                     [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `IsROrC.norm_eq_abs)]
                     "]")
                    [])
                   []
                   (Tactic.tacticRfl "rfl")]))))
              (calcStep
               («term_≤_»
                (Term.hole "_")
                "≤"
                («term_*_»
                 (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `innerSL [`x]) "‖")
                 "*"
                 (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")))
               ":="
               (Term.app
                (Term.proj
                 (Term.typeAscription
                  "("
                  (Term.app `innerSL [`x])
                  ":"
                  [(Topology.Algebra.Module.Basic.«term_→L[_]_» `E " →L[" `𝕜 "] " `𝕜)]
                  ")")
                 "."
                 `le_op_norm)
                [(Term.hole "_")]))])])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.«· » "·")))
       [(Tactic.refine'
         "refine'"
         (Term.app (Term.proj (Term.app `mul_le_mul_right [`h]) "." `mp) [(Term.hole "_")]))
        []
        (calcTactic
         "calc"
         (calcStep
          («term_=_»
           («term_*_»
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
            "*"
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
           "="
           («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "^" (num "2")))
          ":="
          (Term.byTactic
           "by"
           (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(Mathlib.Tactic.RingNF.ring "ring")]))))
         [(calcStep
           («term_=_»
            (Term.hole "_")
            "="
            (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")]))
           ":="
           (Term.app `norm_sq_eq_inner [(Term.hole "_")]))
          (calcStep
           («term_≤_»
            (Term.hole "_")
            "≤"
            (Term.app `abs [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")]))
           ":="
           (Term.app `re_le_abs [(Term.hole "_")]))
          (calcStep
           («term_=_»
            (Term.hole "_")
            "="
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `innerSL [`x `x]) "‖"))
           ":="
           (Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.rwSeq
                "rw"
                []
                (Tactic.rwRuleSeq
                 "["
                 [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `IsROrC.norm_eq_abs)]
                 "]")
                [])
               []
               (Tactic.tacticRfl "rfl")]))))
          (calcStep
           («term_≤_»
            (Term.hole "_")
            "≤"
            («term_*_»
             (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `innerSL [`x]) "‖")
             "*"
             (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")))
           ":="
           (Term.app
            (Term.proj
             (Term.typeAscription
              "("
              (Term.app `innerSL [`x])
              ":"
              [(Topology.Algebra.Module.Basic.«term_→L[_]_» `E " →L[" `𝕜 "] " `𝕜)]
              ")")
             "."
             `le_op_norm)
            [(Term.hole "_")]))])])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (calcTactic
       "calc"
       (calcStep
        («term_=_»
         («term_*_»
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
          "*"
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
         "="
         («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "^" (num "2")))
        ":="
        (Term.byTactic
         "by"
         (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(Mathlib.Tactic.RingNF.ring "ring")]))))
       [(calcStep
         («term_=_»
          (Term.hole "_")
          "="
          (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")]))
         ":="
         (Term.app `norm_sq_eq_inner [(Term.hole "_")]))
        (calcStep
         («term_≤_»
          (Term.hole "_")
          "≤"
          (Term.app `abs [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")]))
         ":="
         (Term.app `re_le_abs [(Term.hole "_")]))
        (calcStep
         («term_=_»
          (Term.hole "_")
          "="
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `innerSL [`x `x]) "‖"))
         ":="
         (Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(Tactic.rwSeq
              "rw"
              []
              (Tactic.rwRuleSeq
               "["
               [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `IsROrC.norm_eq_abs)]
               "]")
              [])
             []
             (Tactic.tacticRfl "rfl")]))))
        (calcStep
         («term_≤_»
          (Term.hole "_")
          "≤"
          («term_*_»
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `innerSL [`x]) "‖")
           "*"
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")))
         ":="
         (Term.app
          (Term.proj
           (Term.typeAscription
            "("
            (Term.app `innerSL [`x])
            ":"
            [(Topology.Algebra.Module.Basic.«term_→L[_]_» `E " →L[" `𝕜 "] " `𝕜)]
            ")")
           "."
           `le_op_norm)
          [(Term.hole "_")]))])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       (Term.proj
        (Term.typeAscription
         "("
         (Term.app `innerSL [`x])
         ":"
         [(Topology.Algebra.Module.Basic.«term_→L[_]_» `E " →L[" `𝕜 "] " `𝕜)]
         ")")
        "."
        `le_op_norm)
       [(Term.hole "_")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.proj
       (Term.typeAscription
        "("
        (Term.app `innerSL [`x])
        ":"
        [(Topology.Algebra.Module.Basic.«term_→L[_]_» `E " →L[" `𝕜 "] " `𝕜)]
        ")")
       "."
       `le_op_norm)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.typeAscription
       "("
       (Term.app `innerSL [`x])
       ":"
       [(Topology.Algebra.Module.Basic.«term_→L[_]_» `E " →L[" `𝕜 "] " `𝕜)]
       ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Topology.Algebra.Module.Basic.«term_→L[_]_» `E " →L[" `𝕜 "] " `𝕜)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `𝕜
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `𝕜
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 25, term))
      `E
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 25, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 25, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `innerSL [`x])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `innerSL
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_≤_»
       (Term.hole "_")
       "≤"
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `innerSL [`x]) "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `innerSL [`x]) "‖")
       "*"
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `innerSL [`x]) "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `innerSL [`x])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `innerSL
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1024, (none, [anonymous]) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 70, (some 71, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none, [anonymous]) <=? (some 50, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 50, (some 51, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, term))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `IsROrC.norm_eq_abs)]
            "]")
           [])
          []
          (Tactic.tacticRfl "rfl")])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.tacticRfl "rfl")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `IsROrC.norm_eq_abs)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `IsROrC.norm_eq_abs
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_»
       (Term.hole "_")
       "="
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `innerSL [`x `x]) "‖"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `innerSL [`x `x]) "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `innerSL [`x `x])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `innerSL
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none, [anonymous]) <=? (some 50, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 50, (some 51, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, term))
      (Term.app `re_le_abs [(Term.hole "_")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `re_le_abs
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_≤_»
       (Term.hole "_")
       "≤"
       (Term.app `abs [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `abs [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
      `innerSL` is an isometry. Note that the associated `linear_isometry` is defined in
      `inner_product_space.dual` as `to_dual_map`.  -/
    @[ simp ]
  theorem
    innerSL_apply_norm
    { x : E } : ‖ ( innerSL x : E →L[ 𝕜 ] 𝕜 ) ‖ = ‖ x ‖
    :=
      by
        refine'
            le_antisymm
              ( innerSL x : E →L[ 𝕜 ] 𝕜 ) . op_norm_le_bound
                  norm_nonneg _ fun y => norm_inner_le_norm _ _
                _
          cases' eq_or_lt_of_le norm_nonneg x with h h
          · have : x = 0 := norm_eq_zero.mp Eq.symm h simp [ this ]
          ·
            refine' mul_le_mul_right h . mp _
              calc
                ‖ x ‖ * ‖ x ‖ = ‖ x ‖ ^ 2 := by ring
                _ = re ⟪ x , x ⟫ := norm_sq_eq_inner _
                  _ ≤ abs ⟪ x , x ⟫ := re_le_abs _
                  _ = ‖ innerSL x x ‖ := by rw [ ← IsROrC.norm_eq_abs ] rfl
                  _ ≤ ‖ innerSL x ‖ * ‖ x ‖ := ( innerSL x : E →L[ 𝕜 ] 𝕜 ) . le_op_norm _
#align innerSL_apply_norm innerSL_apply_norm

/-- The inner product as a continuous sesquilinear map, with the two arguments flipped. -/
def innerSLFlip : E →L[𝕜] E →L⋆[𝕜] 𝕜 :=
  @ContinuousLinearMap.flipₗᵢ' 𝕜 𝕜 𝕜 E E 𝕜 _ _ _ _ _ _ _ _ _ (RingHom.id 𝕜) (starRingEnd 𝕜) _ _
    innerSL
#align innerSL_flip innerSLFlip

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      []
      [(Term.attributes "@[" [(Term.attrInstance (Term.attrKind []) (Attr.simp "simp" [] []))] "]")]
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `innerSL_flip_apply [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.app `innerSLFlip [`x `y])
         "="
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))))
      (Command.declValSimple ":=" `rfl [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `rfl
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Term.app `innerSLFlip [`x `y])
       "="
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
@[ simp ] theorem innerSL_flip_apply { x y : E } : innerSLFlip x y = ⟪ y , x ⟫ := rfl
#align innerSL_flip_apply innerSL_flip_apply

namespace ContinuousLinearMap

variable {E' : Type _} [InnerProductSpace 𝕜 E']

/-- Given `f : E →L[𝕜] E'`, construct the continuous sesquilinear form `λ x y, ⟪x, A y⟫`, given
as a continuous linear map. -/
def toSesqForm : (E →L[𝕜] E') →L[𝕜] E' →L⋆[𝕜] E →L[𝕜] 𝕜 :=
  ↑(ContinuousLinearMap.flipₗᵢ' E E' 𝕜 (starRingEnd 𝕜) (RingHom.id 𝕜)).toContinuousLinearEquiv ∘L
    ContinuousLinearMap.compSL E E' (E' →L⋆[𝕜] 𝕜) (RingHom.id 𝕜) (RingHom.id 𝕜) innerSLFlip
#align continuous_linear_map.to_sesq_form ContinuousLinearMap.toSesqForm

@[simp]
theorem to_sesq_form_apply_coe (f : E →L[𝕜] E') (x : E') : toSesqForm f x = (innerSL x).comp f :=
  rfl
#align continuous_linear_map.to_sesq_form_apply_coe ContinuousLinearMap.to_sesq_form_apply_coe

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `to_sesq_form_apply_norm_le [])
      (Command.declSig
       [(Term.implicitBinder
         "{"
         [`f]
         [":" (Topology.Algebra.Module.Basic.«term_→L[_]_» `E " →L[" `𝕜 "] " `E')]
         "}")
        (Term.implicitBinder "{" [`v] [":" `E'] "}")]
       (Term.typeSpec
        ":"
        («term_≤_»
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `toSesqForm [`f `v]) "‖")
         "≤"
         («term_*_»
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `f "‖")
          "*"
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `v "‖")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.refine'
            "refine'"
            (Term.app
             `op_norm_le_bound
             [(Term.hole "_")
              (Term.app
               `mul_nonneg
               [(Term.app `norm_nonneg [(Term.hole "_")])
                (Term.app `norm_nonneg [(Term.hole "_")])])
              (Term.hole "_")]))
           []
           (Tactic.intro "intro" [`x])
           []
           (Tactic.tacticHave_
            "have"
            (Term.haveDecl
             (Term.haveIdDecl
              [`h₁ []]
              [(Term.typeSpec
                ":"
                («term_≤_»
                 (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `f [`x]) "‖")
                 "≤"
                 («term_*_»
                  (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `f "‖")
                  "*"
                  (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))))]
              ":="
              (Term.app `le_op_norm [(Term.hole "_") (Term.hole "_")]))))
           []
           (Tactic.tacticHave_
            "have"
            (Term.haveDecl
             (Term.haveIdDecl
              [`h₂ []]
              []
              ":="
              (Term.app
               (Term.explicit "@" `norm_inner_le_norm)
               [`𝕜 `E' (Term.hole "_") (Term.hole "_") `v (Term.app `f [`x])]))))
           []
           (calcTactic
            "calc"
            (calcStep
             («term_≤_»
              (Analysis.Normed.Group.Basic.«term‖_‖»
               "‖"
               (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " (Term.app `f [`x]) "⟫")
               "‖")
              "≤"
              («term_*_»
               (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `v "‖")
               "*"
               (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `f [`x]) "‖")))
             ":="
             `h₂)
            [(calcStep
              («term_≤_»
               (Term.hole "_")
               "≤"
               («term_*_»
                (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `v "‖")
                "*"
                («term_*_»
                 (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `f "‖")
                 "*"
                 (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))))
              ":="
              (Term.app `mul_le_mul_of_nonneg_left [`h₁ (Term.app `norm_nonneg [`v])]))
             (calcStep
              («term_=_»
               (Term.hole "_")
               "="
               («term_*_»
                («term_*_»
                 (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `f "‖")
                 "*"
                 (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `v "‖"))
                "*"
                (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")))
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented [(Mathlib.Tactic.RingNF.ring "ring")]))))])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.refine'
           "refine'"
           (Term.app
            `op_norm_le_bound
            [(Term.hole "_")
             (Term.app
              `mul_nonneg
              [(Term.app `norm_nonneg [(Term.hole "_")]) (Term.app `norm_nonneg [(Term.hole "_")])])
             (Term.hole "_")]))
          []
          (Tactic.intro "intro" [`x])
          []
          (Tactic.tacticHave_
           "have"
           (Term.haveDecl
            (Term.haveIdDecl
             [`h₁ []]
             [(Term.typeSpec
               ":"
               («term_≤_»
                (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `f [`x]) "‖")
                "≤"
                («term_*_»
                 (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `f "‖")
                 "*"
                 (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))))]
             ":="
             (Term.app `le_op_norm [(Term.hole "_") (Term.hole "_")]))))
          []
          (Tactic.tacticHave_
           "have"
           (Term.haveDecl
            (Term.haveIdDecl
             [`h₂ []]
             []
             ":="
             (Term.app
              (Term.explicit "@" `norm_inner_le_norm)
              [`𝕜 `E' (Term.hole "_") (Term.hole "_") `v (Term.app `f [`x])]))))
          []
          (calcTactic
           "calc"
           (calcStep
            («term_≤_»
             (Analysis.Normed.Group.Basic.«term‖_‖»
              "‖"
              (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " (Term.app `f [`x]) "⟫")
              "‖")
             "≤"
             («term_*_»
              (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `v "‖")
              "*"
              (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `f [`x]) "‖")))
            ":="
            `h₂)
           [(calcStep
             («term_≤_»
              (Term.hole "_")
              "≤"
              («term_*_»
               (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `v "‖")
               "*"
               («term_*_»
                (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `f "‖")
                "*"
                (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))))
             ":="
             (Term.app `mul_le_mul_of_nonneg_left [`h₁ (Term.app `norm_nonneg [`v])]))
            (calcStep
             («term_=_»
              (Term.hole "_")
              "="
              («term_*_»
               («term_*_»
                (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `f "‖")
                "*"
                (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `v "‖"))
               "*"
               (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")))
             ":="
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented [(Mathlib.Tactic.RingNF.ring "ring")]))))])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (calcTactic
       "calc"
       (calcStep
        («term_≤_»
         (Analysis.Normed.Group.Basic.«term‖_‖»
          "‖"
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " (Term.app `f [`x]) "⟫")
          "‖")
         "≤"
         («term_*_»
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `v "‖")
          "*"
          (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `f [`x]) "‖")))
        ":="
        `h₂)
       [(calcStep
         («term_≤_»
          (Term.hole "_")
          "≤"
          («term_*_»
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `v "‖")
           "*"
           («term_*_»
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `f "‖")
            "*"
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))))
         ":="
         (Term.app `mul_le_mul_of_nonneg_left [`h₁ (Term.app `norm_nonneg [`v])]))
        (calcStep
         («term_=_»
          (Term.hole "_")
          "="
          («term_*_»
           («term_*_»
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `f "‖")
            "*"
            (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `v "‖"))
           "*"
           (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")))
         ":="
         (Term.byTactic
          "by"
          (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(Mathlib.Tactic.RingNF.ring "ring")]))))])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(Mathlib.Tactic.RingNF.ring "ring")])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.RingNF.ring "ring")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_»
       (Term.hole "_")
       "="
       («term_*_»
        («term_*_»
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `f "‖")
         "*"
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `v "‖"))
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `f "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `v "‖"))
       "*"
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      («term_*_»
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `f "‖")
       "*"
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `v "‖"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `v "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `v
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `f "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `f
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1024, (none, [anonymous]) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 70 >? 70, (some 71, term) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 70, (some 71, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none, [anonymous]) <=? (some 50, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 50, (some 51, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, term))
      (Term.app `mul_le_mul_of_nonneg_left [`h₁ (Term.app `norm_nonneg [`v])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `norm_nonneg [`v])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `v
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `norm_nonneg
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `norm_nonneg [`v]) ")")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `h₁
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `mul_le_mul_of_nonneg_left
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_≤_»
       (Term.hole "_")
       "≤"
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `v "‖")
        "*"
        («term_*_»
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `f "‖")
         "*"
         (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `v "‖")
       "*"
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `f "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `f "‖")
       "*"
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `f "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `f
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1024, (none, [anonymous]) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 71 >? 70, (some 71, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     («term_*_»
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `f "‖")
      "*"
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖"))
     ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `v "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `v
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1024, (none, [anonymous]) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 70, (some 71, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none, [anonymous]) <=? (some 50, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 50, (some 51, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, term))
      `h₂
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_≤_»
       (Analysis.Normed.Group.Basic.«term‖_‖»
        "‖"
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " (Term.app `f [`x]) "⟫")
        "‖")
       "≤"
       («term_*_»
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `v "‖")
        "*"
        (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `f [`x]) "‖")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `v "‖")
       "*"
       (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `f [`x]) "‖"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" (Term.app `f [`x]) "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `f [`x])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `f
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `v "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `v
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1024, (none, [anonymous]) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 70, (some 71, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.Normed.Group.Basic.«term‖_‖»
       "‖"
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " (Term.app `f [`x]) "⟫")
       "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " (Term.app `f [`x]) "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  to_sesq_form_apply_norm_le
  { f : E →L[ 𝕜 ] E' } { v : E' } : ‖ toSesqForm f v ‖ ≤ ‖ f ‖ * ‖ v ‖
  :=
    by
      refine' op_norm_le_bound _ mul_nonneg norm_nonneg _ norm_nonneg _ _
        intro x
        have h₁ : ‖ f x ‖ ≤ ‖ f ‖ * ‖ x ‖ := le_op_norm _ _
        have h₂ := @ norm_inner_le_norm 𝕜 E' _ _ v f x
        calc
          ‖ ⟪ v , f x ⟫ ‖ ≤ ‖ v ‖ * ‖ f x ‖ := h₂
          _ ≤ ‖ v ‖ * ‖ f ‖ * ‖ x ‖ := mul_le_mul_of_nonneg_left h₁ norm_nonneg v
            _ = ‖ f ‖ * ‖ v ‖ * ‖ x ‖ := by ring
#align
  continuous_linear_map.to_sesq_form_apply_norm_le ContinuousLinearMap.to_sesq_form_apply_norm_le

end ContinuousLinearMap

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "When an inner product space `E` over `𝕜` is considered as a real normed space, its inner\nproduct satisfies `is_bounded_bilinear_map`.\n\nIn order to state these results, we need a `normed_space ℝ E` instance. We will later establish\nsuch an instance by restriction-of-scalars, `inner_product_space.is_R_or_C_to_real 𝕜 E`, but this\ninstance may be not definitionally equal to some other “natural” instance. So, we assume\n`[normed_space ℝ E]`.\n-/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `isBoundedBilinearMapInner [])
      (Command.declSig
       [(Term.instBinder "[" [] (Term.app `NormedSpace [(Data.Real.Basic.termℝ "ℝ") `E]) "]")]
       (Term.typeSpec
        ":"
        (Term.app
         `IsBoundedBilinearMap
         [(Data.Real.Basic.termℝ "ℝ")
          (Term.fun
           "fun"
           (Term.basicFun
            [`p]
            [(Term.typeSpec ":" («term_×_» `E "×" `E))]
            "=>"
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             (Term.proj `p "." (fieldIdx "1"))
             ", "
             (Term.proj `p "." (fieldIdx "2"))
             "⟫")))])))
      (Command.declValSimple
       ":="
       (Term.structInst
        "{"
        []
        [(Term.structInstField
          (Term.structInstLVal `add_left [])
          ":="
          (Term.fun
           "fun"
           (Term.basicFun
            [(Term.hole "_") (Term.hole "_") (Term.hole "_")]
            []
            "=>"
            `inner_add_left)))
         []
         (Term.structInstField
          (Term.structInstLVal `smul_left [])
          ":="
          (Term.fun
           "fun"
           (Term.basicFun
            [`r `x `y]
            []
            "=>"
            (Term.byTactic
             "by"
             (Tactic.tacticSeq
              (Tactic.tacticSeq1Indented
               [(Tactic.simp
                 "simp"
                 []
                 []
                 ["only"]
                 ["["
                  [(Tactic.simpLemma
                    []
                    [(patternIgnore (token.«← » "←"))]
                    (Term.app `algebra_map_smul [`𝕜 `r `x]))
                   ","
                   (Tactic.simpLemma [] [] `algebra_map_eq_of_real)
                   ","
                   (Tactic.simpLemma [] [] `inner_smul_real_left)]
                  "]"]
                 [])]))))))
         []
         (Term.structInstField
          (Term.structInstLVal `add_right [])
          ":="
          (Term.fun
           "fun"
           (Term.basicFun
            [(Term.hole "_") (Term.hole "_") (Term.hole "_")]
            []
            "=>"
            `inner_add_right)))
         []
         (Term.structInstField
          (Term.structInstLVal `smul_right [])
          ":="
          (Term.fun
           "fun"
           (Term.basicFun
            [`r `x `y]
            []
            "=>"
            (Term.byTactic
             "by"
             (Tactic.tacticSeq
              (Tactic.tacticSeq1Indented
               [(Tactic.simp
                 "simp"
                 []
                 []
                 ["only"]
                 ["["
                  [(Tactic.simpLemma
                    []
                    [(patternIgnore (token.«← » "←"))]
                    (Term.app `algebra_map_smul [`𝕜 `r `y]))
                   ","
                   (Tactic.simpLemma [] [] `algebra_map_eq_of_real)
                   ","
                   (Tactic.simpLemma [] [] `inner_smul_real_right)]
                  "]"]
                 [])]))))))
         []
         (Term.structInstField
          (Term.structInstLVal `bound [])
          ":="
          (Term.anonymousCtor
           "⟨"
           [(num "1")
            ","
            `zero_lt_one
            ","
            (Term.fun
             "fun"
             (Term.basicFun
              [`x `y]
              []
              "=>"
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `one_mul)] "]") [])
                  []
                  (Tactic.exact "exact" (Term.app `norm_inner_le_norm [`x `y]))])))))]
           "⟩"))]
        (Term.optEllipsis [])
        []
        "}")
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.structInst
       "{"
       []
       [(Term.structInstField
         (Term.structInstLVal `add_left [])
         ":="
         (Term.fun
          "fun"
          (Term.basicFun
           [(Term.hole "_") (Term.hole "_") (Term.hole "_")]
           []
           "=>"
           `inner_add_left)))
        []
        (Term.structInstField
         (Term.structInstLVal `smul_left [])
         ":="
         (Term.fun
          "fun"
          (Term.basicFun
           [`r `x `y]
           []
           "=>"
           (Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.simp
                "simp"
                []
                []
                ["only"]
                ["["
                 [(Tactic.simpLemma
                   []
                   [(patternIgnore (token.«← » "←"))]
                   (Term.app `algebra_map_smul [`𝕜 `r `x]))
                  ","
                  (Tactic.simpLemma [] [] `algebra_map_eq_of_real)
                  ","
                  (Tactic.simpLemma [] [] `inner_smul_real_left)]
                 "]"]
                [])]))))))
        []
        (Term.structInstField
         (Term.structInstLVal `add_right [])
         ":="
         (Term.fun
          "fun"
          (Term.basicFun
           [(Term.hole "_") (Term.hole "_") (Term.hole "_")]
           []
           "=>"
           `inner_add_right)))
        []
        (Term.structInstField
         (Term.structInstLVal `smul_right [])
         ":="
         (Term.fun
          "fun"
          (Term.basicFun
           [`r `x `y]
           []
           "=>"
           (Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.simp
                "simp"
                []
                []
                ["only"]
                ["["
                 [(Tactic.simpLemma
                   []
                   [(patternIgnore (token.«← » "←"))]
                   (Term.app `algebra_map_smul [`𝕜 `r `y]))
                  ","
                  (Tactic.simpLemma [] [] `algebra_map_eq_of_real)
                  ","
                  (Tactic.simpLemma [] [] `inner_smul_real_right)]
                 "]"]
                [])]))))))
        []
        (Term.structInstField
         (Term.structInstLVal `bound [])
         ":="
         (Term.anonymousCtor
          "⟨"
          [(num "1")
           ","
           `zero_lt_one
           ","
           (Term.fun
            "fun"
            (Term.basicFun
             [`x `y]
             []
             "=>"
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `one_mul)] "]") [])
                 []
                 (Tactic.exact "exact" (Term.app `norm_inner_le_norm [`x `y]))])))))]
          "⟩"))]
       (Term.optEllipsis [])
       []
       "}")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstField', expected 'Lean.Parser.Term.structInstFieldAbbrev'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.anonymousCtor
       "⟨"
       [(num "1")
        ","
        `zero_lt_one
        ","
        (Term.fun
         "fun"
         (Term.basicFun
          [`x `y]
          []
          "=>"
          (Term.byTactic
           "by"
           (Tactic.tacticSeq
            (Tactic.tacticSeq1Indented
             [(Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `one_mul)] "]") [])
              []
              (Tactic.exact "exact" (Term.app `norm_inner_le_norm [`x `y]))])))))]
       "⟩")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun
       "fun"
       (Term.basicFun
        [`x `y]
        []
        "=>"
        (Term.byTactic
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `one_mul)] "]") [])
            []
            (Tactic.exact "exact" (Term.app `norm_inner_le_norm [`x `y]))])))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `one_mul)] "]") [])
          []
          (Tactic.exact "exact" (Term.app `norm_inner_le_norm [`x `y]))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact "exact" (Term.app `norm_inner_le_norm [`x `y]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `norm_inner_le_norm [`x `y])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `norm_inner_le_norm
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `one_mul)] "]") [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `one_mul
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `zero_lt_one
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "1")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstField', expected 'Lean.Parser.Term.structInstFieldAbbrev'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun
       "fun"
       (Term.basicFun
        [`r `x `y]
        []
        "=>"
        (Term.byTactic
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(Tactic.simp
             "simp"
             []
             []
             ["only"]
             ["["
              [(Tactic.simpLemma
                []
                [(patternIgnore (token.«← » "←"))]
                (Term.app `algebra_map_smul [`𝕜 `r `y]))
               ","
               (Tactic.simpLemma [] [] `algebra_map_eq_of_real)
               ","
               (Tactic.simpLemma [] [] `inner_smul_real_right)]
              "]"]
             [])])))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["["
            [(Tactic.simpLemma
              []
              [(patternIgnore (token.«← » "←"))]
              (Term.app `algebra_map_smul [`𝕜 `r `y]))
             ","
             (Tactic.simpLemma [] [] `algebra_map_eq_of_real)
             ","
             (Tactic.simpLemma [] [] `inner_smul_real_right)]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma
          []
          [(patternIgnore (token.«← » "←"))]
          (Term.app `algebra_map_smul [`𝕜 `r `y]))
         ","
         (Tactic.simpLemma [] [] `algebra_map_eq_of_real)
         ","
         (Tactic.simpLemma [] [] `inner_smul_real_right)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_smul_real_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `algebra_map_eq_of_real
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `algebra_map_smul [`𝕜 `r `y])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `r
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `𝕜
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `algebra_map_smul
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `r
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstField', expected 'Lean.Parser.Term.structInstFieldAbbrev'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun
       "fun"
       (Term.basicFun [(Term.hole "_") (Term.hole "_") (Term.hole "_")] [] "=>" `inner_add_right))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_add_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstField', expected 'Lean.Parser.Term.structInstFieldAbbrev'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun
       "fun"
       (Term.basicFun
        [`r `x `y]
        []
        "=>"
        (Term.byTactic
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(Tactic.simp
             "simp"
             []
             []
             ["only"]
             ["["
              [(Tactic.simpLemma
                []
                [(patternIgnore (token.«← » "←"))]
                (Term.app `algebra_map_smul [`𝕜 `r `x]))
               ","
               (Tactic.simpLemma [] [] `algebra_map_eq_of_real)
               ","
               (Tactic.simpLemma [] [] `inner_smul_real_left)]
              "]"]
             [])])))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["["
            [(Tactic.simpLemma
              []
              [(patternIgnore (token.«← » "←"))]
              (Term.app `algebra_map_smul [`𝕜 `r `x]))
             ","
             (Tactic.simpLemma [] [] `algebra_map_eq_of_real)
             ","
             (Tactic.simpLemma [] [] `inner_smul_real_left)]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma
          []
          [(patternIgnore (token.«← » "←"))]
          (Term.app `algebra_map_smul [`𝕜 `r `x]))
         ","
         (Tactic.simpLemma [] [] `algebra_map_eq_of_real)
         ","
         (Tactic.simpLemma [] [] `inner_smul_real_left)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_smul_real_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `algebra_map_eq_of_real
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `algebra_map_smul [`𝕜 `r `x])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `r
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `𝕜
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `algebra_map_smul
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `r
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstField', expected 'Lean.Parser.Term.structInstFieldAbbrev'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun
       "fun"
       (Term.basicFun [(Term.hole "_") (Term.hole "_") (Term.hole "_")] [] "=>" `inner_add_left))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_add_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      (Term.app
       `IsBoundedBilinearMap
       [(Data.Real.Basic.termℝ "ℝ")
        (Term.fun
         "fun"
         (Term.basicFun
          [`p]
          [(Term.typeSpec ":" («term_×_» `E "×" `E))]
          "=>"
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           (Term.proj `p "." (fieldIdx "1"))
           ", "
           (Term.proj `p "." (fieldIdx "2"))
           "⟫")))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun
       "fun"
       (Term.basicFun
        [`p]
        [(Term.typeSpec ":" («term_×_» `E "×" `E))]
        "=>"
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
         "⟪"
         (Term.proj `p "." (fieldIdx "1"))
         ", "
         (Term.proj `p "." (fieldIdx "2"))
         "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
       "⟪"
       (Term.proj `p "." (fieldIdx "1"))
       ", "
       (Term.proj `p "." (fieldIdx "2"))
       "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.matchAlts'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    When an inner product space `E` over `𝕜` is considered as a real normed space, its inner
    product satisfies `is_bounded_bilinear_map`.
    
    In order to state these results, we need a `normed_space ℝ E` instance. We will later establish
    such an instance by restriction-of-scalars, `inner_product_space.is_R_or_C_to_real 𝕜 E`, but this
    instance may be not definitionally equal to some other “natural” instance. So, we assume
    `[normed_space ℝ E]`.
    -/
  theorem
    isBoundedBilinearMapInner
    [ NormedSpace ℝ E ] : IsBoundedBilinearMap ℝ fun p : E × E => ⟪ p . 1 , p . 2 ⟫
    :=
      {
        add_left := fun _ _ _ => inner_add_left
          smul_left
            :=
            fun
              r x y
                =>
                by
                  simp
                    only
                    [ ← algebra_map_smul 𝕜 r x , algebra_map_eq_of_real , inner_smul_real_left ]
          add_right := fun _ _ _ => inner_add_right
          smul_right
            :=
            fun
              r x y
                =>
                by
                  simp
                    only
                    [ ← algebra_map_smul 𝕜 r y , algebra_map_eq_of_real , inner_smul_real_right ]
          bound := ⟨ 1 , zero_lt_one , fun x y => by rw [ one_mul ] exact norm_inner_le_norm x y ⟩
        }
#align is_bounded_bilinear_map_inner isBoundedBilinearMapInner

end Norm

section BesselsInequality

variable {ι : Type _} (x : E) {v : ι → E}

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment "/--" "Bessel's inequality for finite sums. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `Orthonormal.sum_inner_products_le [])
      (Command.declSig
       [(Term.implicitBinder "{" [`s] [":" (Term.app `Finset [`ι])] "}")
        (Term.explicitBinder "(" [`hv] [":" (Term.app `Orthonormal [`𝕜 `v])] [] ")")]
       (Term.typeSpec
        ":"
        («term_≤_»
         (BigOperators.Algebra.BigOperators.Basic.finset.sum
          "∑"
          (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
          " in "
          `s
          ", "
          («term_^_»
           (Analysis.Normed.Group.Basic.«term‖_‖»
            "‖"
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " `x "⟫")
            "‖")
           "^"
           (num "2")))
         "≤"
         («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "^" (num "2")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.tacticHave_
            "have"
            (Term.haveDecl
             (Term.haveIdDecl
              [`h₂ []]
              [(Term.typeSpec
                ":"
                («term_=_»
                 (BigOperators.Algebra.BigOperators.Basic.finset.sum
                  "∑"
                  (Std.ExtendedBinder.extBinders
                   (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
                  " in "
                  `s
                  ", "
                  (BigOperators.Algebra.BigOperators.Basic.finset.sum
                   "∑"
                   (Std.ExtendedBinder.extBinders
                    (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) []))
                   " in "
                   `s
                   ", "
                   («term_*_»
                    («term_*_»
                     (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                      "⟪"
                      (Term.app `v [`i])
                      ", "
                      `x
                      "⟫")
                     "*"
                     (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                      "⟪"
                      `x
                      ", "
                      (Term.app `v [`j])
                      "⟫"))
                    "*"
                    (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     (Term.app `v [`j])
                     ", "
                     (Term.app `v [`i])
                     "⟫"))))
                 "="
                 (Term.typeAscription
                  "("
                  (BigOperators.Algebra.BigOperators.Basic.finset.sum
                   "∑"
                   (Std.ExtendedBinder.extBinders
                    (Std.ExtendedBinder.extBinder (Lean.binderIdent `k) []))
                   " in "
                   `s
                   ", "
                   («term_*_»
                    (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     (Term.app `v [`k])
                     ", "
                     `x
                     "⟫")
                    "*"
                    (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     `x
                     ", "
                     (Term.app `v [`k])
                     "⟫")))
                  ":"
                  [`𝕜]
                  ")")))]
              ":="
              `hv.inner_left_right_finset)))
           []
           (Tactic.tacticHave_
            "have"
            (Term.haveDecl
             (Term.haveIdDecl
              [`h₃ []]
              [(Term.typeSpec
                ":"
                (Term.forall
                 "∀"
                 [`z]
                 [(Term.typeSpec ":" `𝕜)]
                 ","
                 («term_=_»
                  (Term.app
                   `re
                   [(«term_*_»
                     `z
                     "*"
                     (Term.app (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj") [`z]))])
                  "="
                  («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `z "‖") "^" (num "2")))))]
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.intro "intro" [`z])
                  []
                  (Tactic.simp
                   "simp"
                   []
                   []
                   ["only"]
                   ["["
                    [(Tactic.simpLemma [] [] `mul_conj)
                     ","
                     (Tactic.simpLemma [] [] `norm_sq_eq_def')]
                    "]"]
                   [])
                  []
                  (Tactic.NormCast.tacticNorm_cast__ "norm_cast" [])]))))))
           []
           (Mathlib.Tactic.tacticSuffices_
            "suffices"
            [`hbf []]
            [(Term.typeSpec
              ":"
              («term_=_»
               («term_^_»
                (Analysis.Normed.Group.Basic.«term‖_‖»
                 "‖"
                 («term_-_»
                  `x
                  "-"
                  (BigOperators.Algebra.BigOperators.Basic.finset.sum
                   "∑"
                   (Std.ExtendedBinder.extBinders
                    (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
                   " in "
                   `s
                   ", "
                   (Algebra.Group.Defs.«term_•_»
                    (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     (Term.app `v [`i])
                     ", "
                     `x
                     "⟫")
                    " • "
                    (Term.app `v [`i]))))
                 "‖")
                "^"
                (num "2"))
               "="
               («term_-_»
                («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "^" (num "2"))
                "-"
                (BigOperators.Algebra.BigOperators.Basic.finset.sum
                 "∑"
                 (Std.ExtendedBinder.extBinders
                  (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
                 " in "
                 `s
                 ", "
                 («term_^_»
                  (Analysis.Normed.Group.Basic.«term‖_‖»
                   "‖"
                   (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " `x "⟫")
                   "‖")
                  "^"
                  (num "2"))))))])
           []
           (tactic__
            (cdotTk (patternIgnore (token.«· » "·")))
            [(Tactic.rwSeq
              "rw"
              []
              (Tactic.rwRuleSeq
               "["
               [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `sub_nonneg)
                ","
                (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `hbf)]
               "]")
              [])
             []
             (Tactic.simp
              "simp"
              []
              []
              ["only"]
              ["["
               [(Tactic.simpLemma [] [] `norm_nonneg) "," (Tactic.simpLemma [] [] `pow_nonneg)]
               "]"]
              [])])
           []
           (Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [] `norm_sub_sq) "," (Tactic.rwRule [] `sub_add)]
             "]")
            [])
           []
           (Tactic.simp
            "simp"
            []
            []
            ["only"]
            ["["
             [(Tactic.simpLemma [] [] `InnerProductSpace.norm_sq_eq_inner)
              ","
              (Tactic.simpLemma [] [] `inner_sum)]
             "]"]
            [])
           []
           (Tactic.simp
            "simp"
            []
            []
            ["only"]
            ["["
             [(Tactic.simpLemma [] [] `sum_inner)
              ","
              (Tactic.simpLemma [] [] `two_mul)
              ","
              (Tactic.simpLemma [] [] `inner_smul_right)
              ","
              (Tactic.simpLemma [] [] `inner_conj_sym)
              ","
              (Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `mul_assoc)
              ","
              (Tactic.simpLemma [] [] `h₂)
              ","
              (Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `h₃)
              ","
              (Tactic.simpLemma [] [] `inner_conj_sym)
              ","
              (Tactic.simpLemma [] [] `AddMonoidHom.map_sum)
              ","
              (Tactic.simpLemma [] [] `Finset.mul_sum)
              ","
              (Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `Finset.sum_sub_distrib)
              ","
              (Tactic.simpLemma [] [] `inner_smul_left)
              ","
              (Tactic.simpLemma [] [] `add_sub_cancel')]
             "]"]
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.tacticHave_
           "have"
           (Term.haveDecl
            (Term.haveIdDecl
             [`h₂ []]
             [(Term.typeSpec
               ":"
               («term_=_»
                (BigOperators.Algebra.BigOperators.Basic.finset.sum
                 "∑"
                 (Std.ExtendedBinder.extBinders
                  (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
                 " in "
                 `s
                 ", "
                 (BigOperators.Algebra.BigOperators.Basic.finset.sum
                  "∑"
                  (Std.ExtendedBinder.extBinders
                   (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) []))
                  " in "
                  `s
                  ", "
                  («term_*_»
                   («term_*_»
                    (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     (Term.app `v [`i])
                     ", "
                     `x
                     "⟫")
                    "*"
                    (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     `x
                     ", "
                     (Term.app `v [`j])
                     "⟫"))
                   "*"
                   (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                    "⟪"
                    (Term.app `v [`j])
                    ", "
                    (Term.app `v [`i])
                    "⟫"))))
                "="
                (Term.typeAscription
                 "("
                 (BigOperators.Algebra.BigOperators.Basic.finset.sum
                  "∑"
                  (Std.ExtendedBinder.extBinders
                   (Std.ExtendedBinder.extBinder (Lean.binderIdent `k) []))
                  " in "
                  `s
                  ", "
                  («term_*_»
                   (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`k]) ", " `x "⟫")
                   "*"
                   (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                    "⟪"
                    `x
                    ", "
                    (Term.app `v [`k])
                    "⟫")))
                 ":"
                 [`𝕜]
                 ")")))]
             ":="
             `hv.inner_left_right_finset)))
          []
          (Tactic.tacticHave_
           "have"
           (Term.haveDecl
            (Term.haveIdDecl
             [`h₃ []]
             [(Term.typeSpec
               ":"
               (Term.forall
                "∀"
                [`z]
                [(Term.typeSpec ":" `𝕜)]
                ","
                («term_=_»
                 (Term.app
                  `re
                  [(«term_*_»
                    `z
                    "*"
                    (Term.app (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj") [`z]))])
                 "="
                 («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `z "‖") "^" (num "2")))))]
             ":="
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Tactic.intro "intro" [`z])
                 []
                 (Tactic.simp
                  "simp"
                  []
                  []
                  ["only"]
                  ["["
                   [(Tactic.simpLemma [] [] `mul_conj)
                    ","
                    (Tactic.simpLemma [] [] `norm_sq_eq_def')]
                   "]"]
                  [])
                 []
                 (Tactic.NormCast.tacticNorm_cast__ "norm_cast" [])]))))))
          []
          (Mathlib.Tactic.tacticSuffices_
           "suffices"
           [`hbf []]
           [(Term.typeSpec
             ":"
             («term_=_»
              («term_^_»
               (Analysis.Normed.Group.Basic.«term‖_‖»
                "‖"
                («term_-_»
                 `x
                 "-"
                 (BigOperators.Algebra.BigOperators.Basic.finset.sum
                  "∑"
                  (Std.ExtendedBinder.extBinders
                   (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
                  " in "
                  `s
                  ", "
                  (Algebra.Group.Defs.«term_•_»
                   (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " `x "⟫")
                   " • "
                   (Term.app `v [`i]))))
                "‖")
               "^"
               (num "2"))
              "="
              («term_-_»
               («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "^" (num "2"))
               "-"
               (BigOperators.Algebra.BigOperators.Basic.finset.sum
                "∑"
                (Std.ExtendedBinder.extBinders
                 (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
                " in "
                `s
                ", "
                («term_^_»
                 (Analysis.Normed.Group.Basic.«term‖_‖»
                  "‖"
                  (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " `x "⟫")
                  "‖")
                 "^"
                 (num "2"))))))])
          []
          (tactic__
           (cdotTk (patternIgnore (token.«· » "·")))
           [(Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq
              "["
              [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `sub_nonneg)
               ","
               (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `hbf)]
              "]")
             [])
            []
            (Tactic.simp
             "simp"
             []
             []
             ["only"]
             ["["
              [(Tactic.simpLemma [] [] `norm_nonneg) "," (Tactic.simpLemma [] [] `pow_nonneg)]
              "]"]
             [])])
          []
          (Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] `norm_sub_sq) "," (Tactic.rwRule [] `sub_add)]
            "]")
           [])
          []
          (Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["["
            [(Tactic.simpLemma [] [] `InnerProductSpace.norm_sq_eq_inner)
             ","
             (Tactic.simpLemma [] [] `inner_sum)]
            "]"]
           [])
          []
          (Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["["
            [(Tactic.simpLemma [] [] `sum_inner)
             ","
             (Tactic.simpLemma [] [] `two_mul)
             ","
             (Tactic.simpLemma [] [] `inner_smul_right)
             ","
             (Tactic.simpLemma [] [] `inner_conj_sym)
             ","
             (Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `mul_assoc)
             ","
             (Tactic.simpLemma [] [] `h₂)
             ","
             (Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `h₃)
             ","
             (Tactic.simpLemma [] [] `inner_conj_sym)
             ","
             (Tactic.simpLemma [] [] `AddMonoidHom.map_sum)
             ","
             (Tactic.simpLemma [] [] `Finset.mul_sum)
             ","
             (Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `Finset.sum_sub_distrib)
             ","
             (Tactic.simpLemma [] [] `inner_smul_left)
             ","
             (Tactic.simpLemma [] [] `add_sub_cancel')]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] `sum_inner)
         ","
         (Tactic.simpLemma [] [] `two_mul)
         ","
         (Tactic.simpLemma [] [] `inner_smul_right)
         ","
         (Tactic.simpLemma [] [] `inner_conj_sym)
         ","
         (Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `mul_assoc)
         ","
         (Tactic.simpLemma [] [] `h₂)
         ","
         (Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `h₃)
         ","
         (Tactic.simpLemma [] [] `inner_conj_sym)
         ","
         (Tactic.simpLemma [] [] `AddMonoidHom.map_sum)
         ","
         (Tactic.simpLemma [] [] `Finset.mul_sum)
         ","
         (Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `Finset.sum_sub_distrib)
         ","
         (Tactic.simpLemma [] [] `inner_smul_left)
         ","
         (Tactic.simpLemma [] [] `add_sub_cancel')]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `add_sub_cancel'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_smul_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Finset.sum_sub_distrib
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Finset.mul_sum
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `AddMonoidHom.map_sum
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_conj_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h₃
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h₂
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `mul_assoc
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_conj_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_smul_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `two_mul
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `sum_inner
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] `InnerProductSpace.norm_sq_eq_inner)
         ","
         (Tactic.simpLemma [] [] `inner_sum)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_sum
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `InnerProductSpace.norm_sq_eq_inner
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `norm_sub_sq) "," (Tactic.rwRule [] `sub_add)] "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `sub_add
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `norm_sub_sq
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.«· » "·")))
       [(Tactic.rwSeq
         "rw"
         []
         (Tactic.rwRuleSeq
          "["
          [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `sub_nonneg)
           ","
           (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `hbf)]
          "]")
         [])
        []
        (Tactic.simp
         "simp"
         []
         []
         ["only"]
         ["[" [(Tactic.simpLemma [] [] `norm_nonneg) "," (Tactic.simpLemma [] [] `pow_nonneg)] "]"]
         [])])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["[" [(Tactic.simpLemma [] [] `norm_nonneg) "," (Tactic.simpLemma [] [] `pow_nonneg)] "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `pow_nonneg
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `norm_nonneg
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [(patternIgnore (token.«← » "←"))] `sub_nonneg)
         ","
         (Tactic.rwRule [(patternIgnore (token.«← » "←"))] `hbf)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hbf
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `sub_nonneg
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.tacticSuffices_
       "suffices"
       [`hbf []]
       [(Term.typeSpec
         ":"
         («term_=_»
          («term_^_»
           (Analysis.Normed.Group.Basic.«term‖_‖»
            "‖"
            («term_-_»
             `x
             "-"
             (BigOperators.Algebra.BigOperators.Basic.finset.sum
              "∑"
              (Std.ExtendedBinder.extBinders
               (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
              " in "
              `s
              ", "
              (Algebra.Group.Defs.«term_•_»
               (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " `x "⟫")
               " • "
               (Term.app `v [`i]))))
            "‖")
           "^"
           (num "2"))
          "="
          («term_-_»
           («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "^" (num "2"))
           "-"
           (BigOperators.Algebra.BigOperators.Basic.finset.sum
            "∑"
            (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
            " in "
            `s
            ", "
            («term_^_»
             (Analysis.Normed.Group.Basic.«term‖_‖»
              "‖"
              (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " `x "⟫")
              "‖")
             "^"
             (num "2"))))))])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_»
       («term_^_»
        (Analysis.Normed.Group.Basic.«term‖_‖»
         "‖"
         («term_-_»
          `x
          "-"
          (BigOperators.Algebra.BigOperators.Basic.finset.sum
           "∑"
           (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
           " in "
           `s
           ", "
           (Algebra.Group.Defs.«term_•_»
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " `x "⟫")
            " • "
            (Term.app `v [`i]))))
         "‖")
        "^"
        (num "2"))
       "="
       («term_-_»
        («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "^" (num "2"))
        "-"
        (BigOperators.Algebra.BigOperators.Basic.finset.sum
         "∑"
         (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
         " in "
         `s
         ", "
         («term_^_»
          (Analysis.Normed.Group.Basic.«term‖_‖»
           "‖"
           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " `x "⟫")
           "‖")
          "^"
          (num "2")))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_-_»
       («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "^" (num "2"))
       "-"
       (BigOperators.Algebra.BigOperators.Basic.finset.sum
        "∑"
        (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
        " in "
        `s
        ", "
        («term_^_»
         (Analysis.Normed.Group.Basic.«term‖_‖»
          "‖"
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " `x "⟫")
          "‖")
         "^"
         (num "2"))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (BigOperators.Algebra.BigOperators.Basic.finset.sum
       "∑"
       (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
       " in "
       `s
       ", "
       («term_^_»
        (Analysis.Normed.Group.Basic.«term‖_‖»
         "‖"
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " `x "⟫")
         "‖")
        "^"
        (num "2")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_^_»
       (Analysis.Normed.Group.Basic.«term‖_‖»
        "‖"
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " `x "⟫")
        "‖")
       "^"
       (num "2"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "2")
[PrettyPrinter.parenthesize] ...precedences are 80 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 80, term))
      (Analysis.Normed.Group.Basic.«term‖_‖»
       "‖"
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " `x "⟫")
       "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- Bessel's inequality for finite sums. -/
  theorem
    Orthonormal.sum_inner_products_le
    { s : Finset ι } ( hv : Orthonormal 𝕜 v ) : ∑ i in s , ‖ ⟪ v i , x ⟫ ‖ ^ 2 ≤ ‖ x ‖ ^ 2
    :=
      by
        have
            h₂
              :
                ∑ i in s , ∑ j in s , ⟪ v i , x ⟫ * ⟪ x , v j ⟫ * ⟪ v j , v i ⟫
                  =
                  ( ∑ k in s , ⟪ v k , x ⟫ * ⟪ x , v k ⟫ : 𝕜 )
              :=
              hv.inner_left_right_finset
          have
            h₃
              : ∀ z : 𝕜 , re z * conj z = ‖ z ‖ ^ 2
              :=
              by intro z simp only [ mul_conj , norm_sq_eq_def' ] norm_cast
          suffices
            hbf
            : ‖ x - ∑ i in s , ⟪ v i , x ⟫ • v i ‖ ^ 2 = ‖ x ‖ ^ 2 - ∑ i in s , ‖ ⟪ v i , x ⟫ ‖ ^ 2
          · rw [ ← sub_nonneg , ← hbf ] simp only [ norm_nonneg , pow_nonneg ]
          rw [ norm_sub_sq , sub_add ]
          simp only [ InnerProductSpace.norm_sq_eq_inner , inner_sum ]
          simp
            only
            [
              sum_inner
                ,
                two_mul
                ,
                inner_smul_right
                ,
                inner_conj_sym
                ,
                ← mul_assoc
                ,
                h₂
                ,
                ← h₃
                ,
                inner_conj_sym
                ,
                AddMonoidHom.map_sum
                ,
                Finset.mul_sum
                ,
                ← Finset.sum_sub_distrib
                ,
                inner_smul_left
                ,
                add_sub_cancel'
              ]
#align orthonormal.sum_inner_products_le Orthonormal.sum_inner_products_le

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [(Command.docComment "/--" "Bessel's inequality. -/")] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `Orthonormal.tsum_inner_products_le [])
      (Command.declSig
       [(Term.explicitBinder "(" [`hv] [":" (Term.app `Orthonormal [`𝕜 `v])] [] ")")]
       (Term.typeSpec
        ":"
        («term_≤_»
         (Topology.Algebra.InfiniteSum.«term∑'_,_»
          "∑'"
          (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
          ", "
          («term_^_»
           (Analysis.Normed.Group.Basic.«term‖_‖»
            "‖"
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " `x "⟫")
            "‖")
           "^"
           (num "2")))
         "≤"
         («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "^" (num "2")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.refine'
            "refine'"
            (Term.app
             `tsum_le_of_sum_le'
             [(Term.hole "_")
              (Term.fun
               "fun"
               (Term.basicFun [`s] [] "=>" (Term.app `hv.sum_inner_products_le [`x])))]))
           []
           (Tactic.simp
            "simp"
            []
            []
            ["only"]
            ["["
             [(Tactic.simpLemma [] [] `norm_nonneg) "," (Tactic.simpLemma [] [] `pow_nonneg)]
             "]"]
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.refine'
           "refine'"
           (Term.app
            `tsum_le_of_sum_le'
            [(Term.hole "_")
             (Term.fun
              "fun"
              (Term.basicFun [`s] [] "=>" (Term.app `hv.sum_inner_products_le [`x])))]))
          []
          (Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["["
            [(Tactic.simpLemma [] [] `norm_nonneg) "," (Tactic.simpLemma [] [] `pow_nonneg)]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["[" [(Tactic.simpLemma [] [] `norm_nonneg) "," (Tactic.simpLemma [] [] `pow_nonneg)] "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `pow_nonneg
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `norm_nonneg
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.refine'
       "refine'"
       (Term.app
        `tsum_le_of_sum_le'
        [(Term.hole "_")
         (Term.fun "fun" (Term.basicFun [`s] [] "=>" (Term.app `hv.sum_inner_products_le [`x])))]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `tsum_le_of_sum_le'
       [(Term.hole "_")
        (Term.fun "fun" (Term.basicFun [`s] [] "=>" (Term.app `hv.sum_inner_products_le [`x])))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun "fun" (Term.basicFun [`s] [] "=>" (Term.app `hv.sum_inner_products_le [`x])))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `hv.sum_inner_products_le [`x])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `hv.sum_inner_products_le
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `s
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `tsum_le_of_sum_le'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_≤_»
       (Topology.Algebra.InfiniteSum.«term∑'_,_»
        "∑'"
        (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
        ", "
        («term_^_»
         (Analysis.Normed.Group.Basic.«term‖_‖»
          "‖"
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " `x "⟫")
          "‖")
         "^"
         (num "2")))
       "≤"
       («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "^" (num "2")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "^" (num "2"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "2")
[PrettyPrinter.parenthesize] ...precedences are 80 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 80, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 81 >? 1024, (none, [anonymous]) <=? (some 80, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 80, (some 80, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Topology.Algebra.InfiniteSum.«term∑'_,_»
       "∑'"
       (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
       ", "
       («term_^_»
        (Analysis.Normed.Group.Basic.«term‖_‖»
         "‖"
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " `x "⟫")
         "‖")
        "^"
        (num "2")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_^_»
       (Analysis.Normed.Group.Basic.«term‖_‖»
        "‖"
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " `x "⟫")
        "‖")
       "^"
       (num "2"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "2")
[PrettyPrinter.parenthesize] ...precedences are 80 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 80, term))
      (Analysis.Normed.Group.Basic.«term‖_‖»
       "‖"
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " `x "⟫")
       "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- Bessel's inequality. -/
  theorem
    Orthonormal.tsum_inner_products_le
    ( hv : Orthonormal 𝕜 v ) : ∑' i , ‖ ⟪ v i , x ⟫ ‖ ^ 2 ≤ ‖ x ‖ ^ 2
    :=
      by
        refine' tsum_le_of_sum_le' _ fun s => hv.sum_inner_products_le x
          simp only [ norm_nonneg , pow_nonneg ]
#align orthonormal.tsum_inner_products_le Orthonormal.tsum_inner_products_le

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment "/--" "The sum defined in Bessel's inequality is summable. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `Orthonormal.inner_products_summable [])
      (Command.declSig
       [(Term.explicitBinder "(" [`hv] [":" (Term.app `Orthonormal [`𝕜 `v])] [] ")")]
       (Term.typeSpec
        ":"
        (Term.app
         `Summable
         [(Term.fun
           "fun"
           (Term.basicFun
            [`i]
            []
            "=>"
            («term_^_»
             (Analysis.Normed.Group.Basic.«term‖_‖»
              "‖"
              (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " `x "⟫")
              "‖")
             "^"
             (num "2"))))])))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Mathlib.Tactic.«tacticUse_,,»
            "use"
            [(Order.CompleteLattice.«term⨆_,_»
              "⨆"
              (Std.ExtendedBinder.extBinders
               (Std.ExtendedBinder.extBinder
                (Lean.binderIdent `s)
                [(group ":" (Term.app `Finset [`ι]))]))
              ", "
              (BigOperators.Algebra.BigOperators.Basic.finset.sum
               "∑"
               (Std.ExtendedBinder.extBinders
                (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
               " in "
               `s
               ", "
               («term_^_»
                (Analysis.Normed.Group.Basic.«term‖_‖»
                 "‖"
                 (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " `x "⟫")
                 "‖")
                "^"
                (num "2"))))])
           []
           (Tactic.apply "apply" `has_sum_of_is_lub_of_nonneg)
           []
           (tactic__
            (cdotTk (patternIgnore (token.«· » "·")))
            [(Tactic.intro "intro" [`b])
             []
             (Tactic.simp
              "simp"
              []
              []
              ["only"]
              ["["
               [(Tactic.simpLemma [] [] `norm_nonneg) "," (Tactic.simpLemma [] [] `pow_nonneg)]
               "]"]
              [])])
           []
           (tactic__
            (cdotTk (patternIgnore (token.«· » "·")))
            [(Tactic.refine' "refine'" (Term.app `isLUB_csupᵢ [(Term.hole "_")]))
             []
             (Mathlib.Tactic.«tacticUse_,,»
              "use"
              [(«term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "^" (num "2"))])
             []
             (Std.Tactic.rintro
              "rintro"
              [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `y))
               (Std.Tactic.RCases.rintroPat.one
                (Std.Tactic.RCases.rcasesPat.tuple
                 "⟨"
                 [(Std.Tactic.RCases.rcasesPatLo
                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `s)])
                   [])
                  ","
                  (Std.Tactic.RCases.rcasesPatLo
                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `rfl)])
                   [])]
                 "⟩"))]
              [])
             []
             (Tactic.exact "exact" (Term.app `hv.sum_inner_products_le [`x]))])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Mathlib.Tactic.«tacticUse_,,»
           "use"
           [(Order.CompleteLattice.«term⨆_,_»
             "⨆"
             (Std.ExtendedBinder.extBinders
              (Std.ExtendedBinder.extBinder
               (Lean.binderIdent `s)
               [(group ":" (Term.app `Finset [`ι]))]))
             ", "
             (BigOperators.Algebra.BigOperators.Basic.finset.sum
              "∑"
              (Std.ExtendedBinder.extBinders
               (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
              " in "
              `s
              ", "
              («term_^_»
               (Analysis.Normed.Group.Basic.«term‖_‖»
                "‖"
                (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " `x "⟫")
                "‖")
               "^"
               (num "2"))))])
          []
          (Tactic.apply "apply" `has_sum_of_is_lub_of_nonneg)
          []
          (tactic__
           (cdotTk (patternIgnore (token.«· » "·")))
           [(Tactic.intro "intro" [`b])
            []
            (Tactic.simp
             "simp"
             []
             []
             ["only"]
             ["["
              [(Tactic.simpLemma [] [] `norm_nonneg) "," (Tactic.simpLemma [] [] `pow_nonneg)]
              "]"]
             [])])
          []
          (tactic__
           (cdotTk (patternIgnore (token.«· » "·")))
           [(Tactic.refine' "refine'" (Term.app `isLUB_csupᵢ [(Term.hole "_")]))
            []
            (Mathlib.Tactic.«tacticUse_,,»
             "use"
             [(«term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "^" (num "2"))])
            []
            (Std.Tactic.rintro
             "rintro"
             [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `y))
              (Std.Tactic.RCases.rintroPat.one
               (Std.Tactic.RCases.rcasesPat.tuple
                "⟨"
                [(Std.Tactic.RCases.rcasesPatLo
                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `s)])
                  [])
                 ","
                 (Std.Tactic.RCases.rcasesPatLo
                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `rfl)])
                  [])]
                "⟩"))]
             [])
            []
            (Tactic.exact "exact" (Term.app `hv.sum_inner_products_le [`x]))])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.«· » "·")))
       [(Tactic.refine' "refine'" (Term.app `isLUB_csupᵢ [(Term.hole "_")]))
        []
        (Mathlib.Tactic.«tacticUse_,,»
         "use"
         [(«term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "^" (num "2"))])
        []
        (Std.Tactic.rintro
         "rintro"
         [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `y))
          (Std.Tactic.RCases.rintroPat.one
           (Std.Tactic.RCases.rcasesPat.tuple
            "⟨"
            [(Std.Tactic.RCases.rcasesPatLo
              (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `s)])
              [])
             ","
             (Std.Tactic.RCases.rcasesPatLo
              (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `rfl)])
              [])]
            "⟩"))]
         [])
        []
        (Tactic.exact "exact" (Term.app `hv.sum_inner_products_le [`x]))])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact "exact" (Term.app `hv.sum_inner_products_le [`x]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `hv.sum_inner_products_le [`x])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `hv.sum_inner_products_le
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Std.Tactic.rintro
       "rintro"
       [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `y))
        (Std.Tactic.RCases.rintroPat.one
         (Std.Tactic.RCases.rcasesPat.tuple
          "⟨"
          [(Std.Tactic.RCases.rcasesPatLo
            (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `s)])
            [])
           ","
           (Std.Tactic.RCases.rcasesPatLo
            (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `rfl)])
            [])]
          "⟩"))]
       [])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.«tacticUse_,,»
       "use"
       [(«term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "^" (num "2"))])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖") "^" (num "2"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "2")
[PrettyPrinter.parenthesize] ...precedences are 80 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 80, term))
      (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `x "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 81 >? 1024, (none, [anonymous]) <=? (some 80, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 80, (some 80, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.refine' "refine'" (Term.app `isLUB_csupᵢ [(Term.hole "_")]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `isLUB_csupᵢ [(Term.hole "_")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `isLUB_csupᵢ
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.«· » "·")))
       [(Tactic.intro "intro" [`b])
        []
        (Tactic.simp
         "simp"
         []
         []
         ["only"]
         ["[" [(Tactic.simpLemma [] [] `norm_nonneg) "," (Tactic.simpLemma [] [] `pow_nonneg)] "]"]
         [])])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["[" [(Tactic.simpLemma [] [] `norm_nonneg) "," (Tactic.simpLemma [] [] `pow_nonneg)] "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `pow_nonneg
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `norm_nonneg
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.intro "intro" [`b])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `b
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.apply "apply" `has_sum_of_is_lub_of_nonneg)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `has_sum_of_is_lub_of_nonneg
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.«tacticUse_,,»
       "use"
       [(Order.CompleteLattice.«term⨆_,_»
         "⨆"
         (Std.ExtendedBinder.extBinders
          (Std.ExtendedBinder.extBinder
           (Lean.binderIdent `s)
           [(group ":" (Term.app `Finset [`ι]))]))
         ", "
         (BigOperators.Algebra.BigOperators.Basic.finset.sum
          "∑"
          (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
          " in "
          `s
          ", "
          («term_^_»
           (Analysis.Normed.Group.Basic.«term‖_‖»
            "‖"
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " `x "⟫")
            "‖")
           "^"
           (num "2"))))])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Order.CompleteLattice.«term⨆_,_»
       "⨆"
       (Std.ExtendedBinder.extBinders
        (Std.ExtendedBinder.extBinder (Lean.binderIdent `s) [(group ":" (Term.app `Finset [`ι]))]))
       ", "
       (BigOperators.Algebra.BigOperators.Basic.finset.sum
        "∑"
        (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
        " in "
        `s
        ", "
        («term_^_»
         (Analysis.Normed.Group.Basic.«term‖_‖»
          "‖"
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " `x "⟫")
          "‖")
         "^"
         (num "2"))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (BigOperators.Algebra.BigOperators.Basic.finset.sum
       "∑"
       (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
       " in "
       `s
       ", "
       («term_^_»
        (Analysis.Normed.Group.Basic.«term‖_‖»
         "‖"
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " `x "⟫")
         "‖")
        "^"
        (num "2")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_^_»
       (Analysis.Normed.Group.Basic.«term‖_‖»
        "‖"
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " `x "⟫")
        "‖")
       "^"
       (num "2"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "2")
[PrettyPrinter.parenthesize] ...precedences are 80 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 80, term))
      (Analysis.Normed.Group.Basic.«term‖_‖»
       "‖"
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " `x "⟫")
       "‖")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `v [`i]) ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- The sum defined in Bessel's inequality is summable. -/
  theorem
    Orthonormal.inner_products_summable
    ( hv : Orthonormal 𝕜 v ) : Summable fun i => ‖ ⟪ v i , x ⟫ ‖ ^ 2
    :=
      by
        use ⨆ s : Finset ι , ∑ i in s , ‖ ⟪ v i , x ⟫ ‖ ^ 2
          apply has_sum_of_is_lub_of_nonneg
          · intro b simp only [ norm_nonneg , pow_nonneg ]
          ·
            refine' isLUB_csupᵢ _
              use ‖ x ‖ ^ 2
              rintro y ⟨ s , rfl ⟩
              exact hv.sum_inner_products_le x
#align orthonormal.inner_products_summable Orthonormal.inner_products_summable

end BesselsInequality

/-- A field `𝕜` satisfying `is_R_or_C` is itself a `𝕜`-inner product space. -/
instance IsROrC.innerProductSpace : InnerProductSpace 𝕜 𝕜
    where
  toNormedAddCommGroup := NonUnitalNormedRing.toNormedAddCommGroup
  inner x y := conj x * y
  norm_sq_eq_inner x := by
    unfold inner
    rw [mul_comm, mul_conj, of_real_re, norm_sq_eq_def']
  conj_sym x y := by simp only [mul_comm, map_mul, star_ring_end_self_apply]
  add_left x y z := by simp only [add_mul, map_add]
  smul_left x y z := by simp only [mul_assoc, smul_eq_mul, map_mul]
#align is_R_or_C.inner_product_space IsROrC.innerProductSpace

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      []
      [(Term.attributes "@[" [(Term.attrInstance (Term.attrKind []) (Attr.simp "simp" [] []))] "]")]
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `IsROrC.inner_apply [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x `y] [":" `𝕜] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
         "="
         («term_*_»
          (Term.app (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj") [`x])
          "*"
          `y))))
      (Command.declValSimple ":=" `rfl [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `rfl
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
       "="
       («term_*_»
        (Term.app (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj") [`x])
        "*"
        `y))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_» (Term.app (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj") [`x]) "*" `y)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (Term.app (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj") [`x])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (ComplexConjugate.Algebra.Star.Basic.star_ring_end "conj")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1022, (some 1023, term) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 70, (some 71, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
@[ simp ] theorem IsROrC.inner_apply ( x y : 𝕜 ) : ⟪ x , y ⟫ = conj x * y := rfl
#align is_R_or_C.inner_apply IsROrC.inner_apply

/-! ### Inner product space structure on subspaces -/


/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment "/--" "Induced inner product on a submodule. -/")]
      []
      []
      []
      []
      [])
     (Command.instance
      (Term.attrKind [])
      "instance"
      []
      [(Command.declId `Submodule.innerProductSpace [])]
      (Command.declSig
       [(Term.explicitBinder "(" [`W] [":" (Term.app `Submodule [`𝕜 `E])] [] ")")]
       (Term.typeSpec ":" (Term.app `InnerProductSpace [`𝕜 `W])))
      (Command.declValSimple
       ":="
       (Term.structInst
        "{"
        [[(Term.app `Submodule.normedSpace [`W])] "with"]
        [(Term.structInstField
          (Term.structInstLVal `toNormedAddCommGroup [])
          ":="
          (Term.app `Submodule.normedAddCommGroup [(Term.hole "_")]))
         []
         (Term.structInstField
          (Term.structInstLVal `inner [])
          ":="
          (Term.fun
           "fun"
           (Term.basicFun
            [`x `y]
            []
            "=>"
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             (Term.typeAscription "(" `x ":" [`E] ")")
             ", "
             (Term.typeAscription "(" `y ":" [`E] ")")
             "⟫"))))
         []
         (Term.structInstField
          (Term.structInstLVal `conj_sym [])
          ":="
          (Term.fun
           "fun"
           (Term.basicFun
            [(Term.hole "_") (Term.hole "_")]
            []
            "=>"
            (Term.app `inner_conj_sym [(Term.hole "_") (Term.hole "_")]))))
         []
         (Term.structInstField
          (Term.structInstLVal `norm_sq_eq_inner [])
          ":="
          (Term.fun
           "fun"
           (Term.basicFun
            [(Term.hole "_")]
            []
            "=>"
            (Term.app `norm_sq_eq_inner [(Term.hole "_")]))))
         []
         (Term.structInstField
          (Term.structInstLVal `add_left [])
          ":="
          (Term.fun
           "fun"
           (Term.basicFun
            [(Term.hole "_") (Term.hole "_") (Term.hole "_")]
            []
            "=>"
            `inner_add_left)))
         []
         (Term.structInstField
          (Term.structInstLVal `smul_left [])
          ":="
          (Term.fun
           "fun"
           (Term.basicFun
            [(Term.hole "_") (Term.hole "_") (Term.hole "_")]
            []
            "=>"
            `inner_smul_left)))]
        (Term.optEllipsis [])
        []
        "}")
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.instance', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.instance', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.instance', expected 'Lean.Parser.Command.theorem'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.instance', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.structInst
       "{"
       [[(Term.app `Submodule.normedSpace [`W])] "with"]
       [(Term.structInstField
         (Term.structInstLVal `toNormedAddCommGroup [])
         ":="
         (Term.app `Submodule.normedAddCommGroup [(Term.hole "_")]))
        []
        (Term.structInstField
         (Term.structInstLVal `inner [])
         ":="
         (Term.fun
          "fun"
          (Term.basicFun
           [`x `y]
           []
           "=>"
           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
            "⟪"
            (Term.typeAscription "(" `x ":" [`E] ")")
            ", "
            (Term.typeAscription "(" `y ":" [`E] ")")
            "⟫"))))
        []
        (Term.structInstField
         (Term.structInstLVal `conj_sym [])
         ":="
         (Term.fun
          "fun"
          (Term.basicFun
           [(Term.hole "_") (Term.hole "_")]
           []
           "=>"
           (Term.app `inner_conj_sym [(Term.hole "_") (Term.hole "_")]))))
        []
        (Term.structInstField
         (Term.structInstLVal `norm_sq_eq_inner [])
         ":="
         (Term.fun
          "fun"
          (Term.basicFun [(Term.hole "_")] [] "=>" (Term.app `norm_sq_eq_inner [(Term.hole "_")]))))
        []
        (Term.structInstField
         (Term.structInstLVal `add_left [])
         ":="
         (Term.fun
          "fun"
          (Term.basicFun
           [(Term.hole "_") (Term.hole "_") (Term.hole "_")]
           []
           "=>"
           `inner_add_left)))
        []
        (Term.structInstField
         (Term.structInstLVal `smul_left [])
         ":="
         (Term.fun
          "fun"
          (Term.basicFun
           [(Term.hole "_") (Term.hole "_") (Term.hole "_")]
           []
           "=>"
           `inner_smul_left)))]
       (Term.optEllipsis [])
       []
       "}")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstField', expected 'Lean.Parser.Term.structInstFieldAbbrev'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun
       "fun"
       (Term.basicFun [(Term.hole "_") (Term.hole "_") (Term.hole "_")] [] "=>" `inner_smul_left))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_smul_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstField', expected 'Lean.Parser.Term.structInstFieldAbbrev'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun
       "fun"
       (Term.basicFun [(Term.hole "_") (Term.hole "_") (Term.hole "_")] [] "=>" `inner_add_left))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_add_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstField', expected 'Lean.Parser.Term.structInstFieldAbbrev'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun
       "fun"
       (Term.basicFun [(Term.hole "_")] [] "=>" (Term.app `norm_sq_eq_inner [(Term.hole "_")])))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `norm_sq_eq_inner [(Term.hole "_")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `norm_sq_eq_inner
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstField', expected 'Lean.Parser.Term.structInstFieldAbbrev'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun
       "fun"
       (Term.basicFun
        [(Term.hole "_") (Term.hole "_")]
        []
        "=>"
        (Term.app `inner_conj_sym [(Term.hole "_") (Term.hole "_")])))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `inner_conj_sym [(Term.hole "_") (Term.hole "_")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `inner_conj_sym
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstField', expected 'Lean.Parser.Term.structInstFieldAbbrev'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun
       "fun"
       (Term.basicFun
        [`x `y]
        []
        "=>"
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
         "⟪"
         (Term.typeAscription "(" `x ":" [`E] ")")
         ", "
         (Term.typeAscription "(" `y ":" [`E] ")")
         "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
       "⟪"
       (Term.typeAscription "(" `x ":" [`E] ")")
       ", "
       (Term.typeAscription "(" `y ":" [`E] ")")
       "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.matchAlts'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.instance', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.instance', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.instance', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.instance', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.instance', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- Induced inner product on a submodule. -/
  instance
    Submodule.innerProductSpace
    ( W : Submodule 𝕜 E ) : InnerProductSpace 𝕜 W
    :=
      {
        Submodule.normedSpace W with
        toNormedAddCommGroup := Submodule.normedAddCommGroup _
          inner := fun x y => ⟪ ( x : E ) , ( y : E ) ⟫
          conj_sym := fun _ _ => inner_conj_sym _ _
          norm_sq_eq_inner := fun _ => norm_sq_eq_inner _
          add_left := fun _ _ _ => inner_add_left
          smul_left := fun _ _ _ => inner_smul_left
        }
#align submodule.inner_product_space Submodule.innerProductSpace

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "The inner product on submodules is the same as on the ambient space. -/")]
      [(Term.attributes "@[" [(Term.attrInstance (Term.attrKind []) (Attr.simp "simp" [] []))] "]")]
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `Submodule.coe_inner [])
      (Command.declSig
       [(Term.explicitBinder "(" [`W] [":" (Term.app `Submodule [`𝕜 `E])] [] ")")
        (Term.explicitBinder "(" [`x `y] [":" `W] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
         "="
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (Term.typeAscription "(" `x ":" [`E] ")")
          ", "
          (coeNotation "↑" `y)
          "⟫"))))
      (Command.declValSimple ":=" `rfl [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `rfl
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
       "="
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        (Term.typeAscription "(" `x ":" [`E] ")")
        ", "
        (coeNotation "↑" `y)
        "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
       "⟪"
       (Term.typeAscription "(" `x ":" [`E] ")")
       ", "
       (coeNotation "↑" `y)
       "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- The inner product on submodules is the same as on the ambient space. -/ @[ simp ]
  theorem
    Submodule.coe_inner
    ( W : Submodule 𝕜 E ) ( x y : W ) : ⟪ x , y ⟫ = ⟪ ( x : E ) , ↑ y ⟫
    := rfl
#align submodule.coe_inner Submodule.coe_inner

theorem Orthonormal.codRestrict {ι : Type _} {v : ι → E} (hv : Orthonormal 𝕜 v) (s : Submodule 𝕜 E)
    (hvs : ∀ i, v i ∈ s) : @Orthonormal 𝕜 s _ _ ι (Set.codRestrict v s hvs) :=
  s.subtypeₗᵢ.orthonormal_comp_iff.mp hv
#align orthonormal.cod_restrict Orthonormal.codRestrict

theorem orthonormalSpan {ι : Type _} {v : ι → E} (hv : Orthonormal 𝕜 v) :
    @Orthonormal 𝕜 (Submodule.span 𝕜 (Set.range v)) _ _ ι fun i : ι =>
      ⟨v i, Submodule.subset_span (Set.mem_range_self i)⟩ :=
  hv.codRestrict (Submodule.span 𝕜 (Set.range v)) fun i =>
    Submodule.subset_span (Set.mem_range_self i)
#align orthonormal_span orthonormalSpan

/-! ### Families of mutually-orthogonal subspaces of an inner product space -/


section OrthogonalFamily

variable {ι : Type _} [dec_ι : DecidableEq ι] (𝕜)

open DirectSum

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "An indexed family of mutually-orthogonal subspaces of an inner product space `E`.\n\nThe simple way to express this concept would be as a condition on `V : ι → submodule 𝕜 E`.  We\nWe instead implement it as a condition on a family of inner product spaces each equipped with an\nisometric embedding into `E`, thus making it a property of morphisms rather than subobjects.\n\nThis definition is less lightweight, but allows for better definitional properties when the inner\nproduct space structure on each of the submodules is important -- for example, when considering\ntheir Hilbert sum (`pi_lp V 2`).  For example, given an orthonormal set of vectors `v : ι → E`,\nwe have an associated orthogonal family of one-dimensional subspaces of `E`, which it is convenient\nto be able to discuss using `ι → 𝕜` rather than `Π i : ι, span 𝕜 (v i)`. -/")]
      []
      []
      []
      []
      [])
     (Command.def
      "def"
      (Command.declId `OrthogonalFamily [])
      (Command.optDeclSig
       [(Term.implicitBinder
         "{"
         [`G]
         [":" (Term.arrow `ι "→" (Term.type "Type" [(Level.hole "_")]))]
         "}")
        (Term.instBinder
         "["
         []
         (Term.forall "∀" [`i] [] "," (Term.app `InnerProductSpace [`𝕜 (Term.app `G [`i])]))
         "]")
        (Term.explicitBinder
         "("
         [`V]
         [":"
          (Term.forall
           "∀"
           [`i]
           []
           ","
           (Analysis.NormedSpace.LinearIsometry.«term_→ₗᵢ[_]_»
            (Term.app `G [`i])
            " →ₗᵢ["
            `𝕜
            "] "
            `E))]
         []
         ")")]
       [(Term.typeSpec ":" (Term.prop "Prop"))])
      (Command.declValSimple
       ":="
       (Term.forall
        "∀"
        [(Term.strictImplicitBinder "⦃" [`i `j] [] "⦄")]
        []
        ","
        (Term.arrow
         («term_≠_» `i "≠" `j)
         "→"
         (Term.forall
          "∀"
          [`v]
          [(Term.typeSpec ":" (Term.app `G [`i]))]
          ","
          (Term.forall
           "∀"
           [`w]
           [(Term.typeSpec ":" (Term.app `G [`j]))]
           ","
           («term_=_»
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             (Term.app `V [`i `v])
             ", "
             (Term.app `V [`j `w])
             "⟫")
            "="
            (num "0"))))))
       [])
      []
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.forall
       "∀"
       [(Term.strictImplicitBinder "⦃" [`i `j] [] "⦄")]
       []
       ","
       (Term.arrow
        («term_≠_» `i "≠" `j)
        "→"
        (Term.forall
         "∀"
         [`v]
         [(Term.typeSpec ":" (Term.app `G [`i]))]
         ","
         (Term.forall
          "∀"
          [`w]
          [(Term.typeSpec ":" (Term.app `G [`j]))]
          ","
          («term_=_»
           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
            "⟪"
            (Term.app `V [`i `v])
            ", "
            (Term.app `V [`j `w])
            "⟫")
           "="
           (num "0"))))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.arrow
       («term_≠_» `i "≠" `j)
       "→"
       (Term.forall
        "∀"
        [`v]
        [(Term.typeSpec ":" (Term.app `G [`i]))]
        ","
        (Term.forall
         "∀"
         [`w]
         [(Term.typeSpec ":" (Term.app `G [`j]))]
         ","
         («term_=_»
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           (Term.app `V [`i `v])
           ", "
           (Term.app `V [`j `w])
           "⟫")
          "="
          (num "0")))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.forall
       "∀"
       [`v]
       [(Term.typeSpec ":" (Term.app `G [`i]))]
       ","
       (Term.forall
        "∀"
        [`w]
        [(Term.typeSpec ":" (Term.app `G [`j]))]
        ","
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (Term.app `V [`i `v])
          ", "
          (Term.app `V [`j `w])
          "⟫")
         "="
         (num "0"))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.forall
       "∀"
       [`w]
       [(Term.typeSpec ":" (Term.app `G [`j]))]
       ","
       («term_=_»
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
         "⟪"
         (Term.app `V [`i `v])
         ", "
         (Term.app `V [`j `w])
         "⟫")
        "="
        (num "0")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        (Term.app `V [`i `v])
        ", "
        (Term.app `V [`j `w])
        "⟫")
       "="
       (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
       "⟪"
       (Term.app `V [`i `v])
       ", "
       (Term.app `V [`j `w])
       "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.theorem'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    An indexed family of mutually-orthogonal subspaces of an inner product space `E`.
    
    The simple way to express this concept would be as a condition on `V : ι → submodule 𝕜 E`.  We
    We instead implement it as a condition on a family of inner product spaces each equipped with an
    isometric embedding into `E`, thus making it a property of morphisms rather than subobjects.
    
    This definition is less lightweight, but allows for better definitional properties when the inner
    product space structure on each of the submodules is important -- for example, when considering
    their Hilbert sum (`pi_lp V 2`).  For example, given an orthonormal set of vectors `v : ι → E`,
    we have an associated orthogonal family of one-dimensional subspaces of `E`, which it is convenient
    to be able to discuss using `ι → 𝕜` rather than `Π i : ι, span 𝕜 (v i)`. -/
  def
    OrthogonalFamily
    { G : ι → Type _ } [ ∀ i , InnerProductSpace 𝕜 G i ] ( V : ∀ i , G i →ₗᵢ[ 𝕜 ] E ) : Prop
    := ∀ ⦃ i j ⦄ , i ≠ j → ∀ v : G i , ∀ w : G j , ⟪ V i v , V j w ⟫ = 0
#align orthogonal_family OrthogonalFamily

variable {𝕜} {G : ι → Type _} [∀ i, InnerProductSpace 𝕜 (G i)] {V : ∀ i, G i →ₗᵢ[𝕜] E}
  (hV : OrthogonalFamily 𝕜 V) [dec_V : ∀ (i) (x : G i), Decidable (x ≠ 0)]

theorem Orthonormal.orthogonalFamily {v : ι → E} (hv : Orthonormal 𝕜 v) :
    @OrthogonalFamily 𝕜 _ _ _ _ (fun i : ι => 𝕜) _ fun i =>
      LinearIsometry.toSpanSingleton 𝕜 E (hv.1 i) :=
  fun i j hij a b => by simp [inner_smul_left, inner_smul_right, hv.2 hij]
#align orthonormal.orthogonal_family Orthonormal.orthogonalFamily

include hV dec_ι

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `OrthogonalFamily.eq_ite [])
      (Command.declSig
       [(Term.implicitBinder "{" [`i `j] [":" `ι] "}")
        (Term.explicitBinder "(" [`v] [":" (Term.app `G [`i])] [] ")")
        (Term.explicitBinder "(" [`w] [":" (Term.app `G [`j])] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (Term.app `V [`i `v])
          ", "
          (Term.app `V [`j `w])
          "⟫")
         "="
         (Term.app
          `ite
          [(«term_=_» `i "=" `j)
           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
            "⟪"
            (Term.app `V [`i `v])
            ", "
            (Term.app `V [`j `w])
            "⟫")
           (num "0")]))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Mathlib.Tactic.splitIfs "split_ifs" [] [])
           []
           (tactic__ (cdotTk (patternIgnore (token.«· » "·"))) [(Tactic.tacticRfl "rfl")])
           []
           (tactic__
            (cdotTk (patternIgnore (token.«· » "·")))
            [(Tactic.exact "exact" (Term.app `hV [`h `v `w]))])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Mathlib.Tactic.splitIfs "split_ifs" [] [])
          []
          (tactic__ (cdotTk (patternIgnore (token.«· » "·"))) [(Tactic.tacticRfl "rfl")])
          []
          (tactic__
           (cdotTk (patternIgnore (token.«· » "·")))
           [(Tactic.exact "exact" (Term.app `hV [`h `v `w]))])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.«· » "·")))
       [(Tactic.exact "exact" (Term.app `hV [`h `v `w]))])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact "exact" (Term.app `hV [`h `v `w]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `hV [`h `v `w])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `w
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `v
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `hV
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__ (cdotTk (patternIgnore (token.«· » "·"))) [(Tactic.tacticRfl "rfl")])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.tacticRfl "rfl")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.splitIfs "split_ifs" [] [])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        (Term.app `V [`i `v])
        ", "
        (Term.app `V [`j `w])
        "⟫")
       "="
       (Term.app
        `ite
        [(«term_=_» `i "=" `j)
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (Term.app `V [`i `v])
          ", "
          (Term.app `V [`j `w])
          "⟫")
         (num "0")]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `ite
       [(«term_=_» `i "=" `j)
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
         "⟪"
         (Term.app `V [`i `v])
         ", "
         (Term.app `V [`j `w])
         "⟫")
        (num "0")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'num', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'num', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
       "⟪"
       (Term.app `V [`i `v])
       ", "
       (Term.app `V [`j `w])
       "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  OrthogonalFamily.eq_ite
  { i j : ι } ( v : G i ) ( w : G j ) : ⟪ V i v , V j w ⟫ = ite i = j ⟪ V i v , V j w ⟫ 0
  := by split_ifs · rfl · exact hV h v w
#align orthogonal_family.eq_ite OrthogonalFamily.eq_ite

include dec_V

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `OrthogonalFamily.inner_right_dfinsupp [])
      (Command.declSig
       [(Term.explicitBinder
         "("
         [`l]
         [":"
          (DirectSum.Algebra.DirectSum.Basic.direct_sum
           "⨁"
           (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
           ", "
           (Term.app `G [`i]))]
         []
         ")")
        (Term.explicitBinder "(" [`i] [":" `ι] [] ")")
        (Term.explicitBinder "(" [`v] [":" (Term.app `G [`i])] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (Term.app `V [`i `v])
          ", "
          (Term.app
           (Term.proj `l "." `Sum)
           [(Term.fun "fun" (Term.basicFun [`j] [] "=>" (Term.app `V [`j])))])
          "⟫")
         "="
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " (Term.app `l [`i]) "⟫"))))
      (Command.declValSimple
       ":="
       (calc
        "calc"
        (calcStep
         («term_=_»
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           (Term.app `V [`i `v])
           ", "
           (Term.app
            (Term.proj `l "." `Sum)
            [(Term.fun "fun" (Term.basicFun [`j] [] "=>" (Term.app `V [`j])))])
           "⟫")
          "="
          (Term.app
           (Term.proj `l "." `Sum)
           [(Term.fun
             "fun"
             (Term.basicFun
              [`j]
              []
              "=>"
              (Term.fun
               "fun"
               (Term.basicFun
                [`w]
                []
                "=>"
                (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                 "⟪"
                 (Term.app `V [`i `v])
                 ", "
                 (Term.app `V [`j `w])
                 "⟫")))))]))
         ":="
         (Term.app
          `Dfinsupp.inner_sum
          [(Term.fun "fun" (Term.basicFun [`j] [] "=>" (Term.app `V [`j])))
           `l
           (Term.app `V [`i `v])]))
        [(calcStep
          («term_=_»
           (Term.hole "_")
           "="
           (Term.app
            (Term.proj `l "." `Sum)
            [(Term.fun
              "fun"
              (Term.basicFun
               [`j]
               []
               "=>"
               (Term.fun
                "fun"
                (Term.basicFun
                 [`w]
                 []
                 "=>"
                 (Term.app
                  `ite
                  [(«term_=_» `i "=" `j)
                   (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                    "⟪"
                    (Term.app `V [`i `v])
                    ", "
                    (Term.app `V [`j `w])
                    "⟫")
                   (num "0")])))))]))
          ":="
          («term_<|_»
           (Term.app `congr_arg [(Term.proj `l "." `Sum)])
           "<|"
           (Term.app
            `funext
            [(Term.fun
              "fun"
              (Term.basicFun
               [`j]
               []
               "=>"
               («term_<|_» `funext "<|" (Term.app (Term.proj `hV "." `eq_ite) [`v]))))])))
         (calcStep
          («term_=_»
           (Term.hole "_")
           "="
           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " (Term.app `l [`i]) "⟫"))
          ":="
          (Term.byTactic
           "by"
           (Tactic.tacticSeq
            (Tactic.tacticSeq1Indented
             [(Tactic.simp
               "simp"
               []
               []
               ["only"]
               ["["
                [(Tactic.simpLemma [] [] `Dfinsupp.sum)
                 ","
                 (Tactic.simpLemma [] [] `Submodule.coe_inner)
                 ","
                 (Tactic.simpLemma [] [] `Finset.sum_ite_eq)
                 ","
                 (Tactic.simpLemma [] [] `ite_eq_left_iff)
                 ","
                 (Tactic.simpLemma [] [] `Dfinsupp.mem_support_to_fun)]
                "]"]
               [])
              []
              (Mathlib.Tactic.splitIfs
               "split_ifs"
               []
               ["with" [(Lean.binderIdent `h) (Lean.binderIdent `h)]])
              []
              (tactic__
               (cdotTk (patternIgnore (token.«· » "·")))
               [(Tactic.simp
                 "simp"
                 []
                 []
                 ["only"]
                 ["[" [(Tactic.simpLemma [] [] `LinearIsometry.inner_map_map)] "]"]
                 [])])
              []
              (tactic__
               (cdotTk (patternIgnore (token.«· » "·")))
               [(Tactic.simp
                 "simp"
                 []
                 []
                 ["only"]
                 ["["
                  [(Tactic.simpLemma [] [] (Term.app `of_not_not [`h]))
                   ","
                   (Tactic.simpLemma [] [] `inner_zero_right)]
                  "]"]
                 [])])]))))])
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (calc
       "calc"
       (calcStep
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (Term.app `V [`i `v])
          ", "
          (Term.app
           (Term.proj `l "." `Sum)
           [(Term.fun "fun" (Term.basicFun [`j] [] "=>" (Term.app `V [`j])))])
          "⟫")
         "="
         (Term.app
          (Term.proj `l "." `Sum)
          [(Term.fun
            "fun"
            (Term.basicFun
             [`j]
             []
             "=>"
             (Term.fun
              "fun"
              (Term.basicFun
               [`w]
               []
               "=>"
               (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                "⟪"
                (Term.app `V [`i `v])
                ", "
                (Term.app `V [`j `w])
                "⟫")))))]))
        ":="
        (Term.app
         `Dfinsupp.inner_sum
         [(Term.fun "fun" (Term.basicFun [`j] [] "=>" (Term.app `V [`j])))
          `l
          (Term.app `V [`i `v])]))
       [(calcStep
         («term_=_»
          (Term.hole "_")
          "="
          (Term.app
           (Term.proj `l "." `Sum)
           [(Term.fun
             "fun"
             (Term.basicFun
              [`j]
              []
              "=>"
              (Term.fun
               "fun"
               (Term.basicFun
                [`w]
                []
                "=>"
                (Term.app
                 `ite
                 [(«term_=_» `i "=" `j)
                  (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                   "⟪"
                   (Term.app `V [`i `v])
                   ", "
                   (Term.app `V [`j `w])
                   "⟫")
                  (num "0")])))))]))
         ":="
         («term_<|_»
          (Term.app `congr_arg [(Term.proj `l "." `Sum)])
          "<|"
          (Term.app
           `funext
           [(Term.fun
             "fun"
             (Term.basicFun
              [`j]
              []
              "=>"
              («term_<|_» `funext "<|" (Term.app (Term.proj `hV "." `eq_ite) [`v]))))])))
        (calcStep
         («term_=_»
          (Term.hole "_")
          "="
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " (Term.app `l [`i]) "⟫"))
         ":="
         (Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(Tactic.simp
              "simp"
              []
              []
              ["only"]
              ["["
               [(Tactic.simpLemma [] [] `Dfinsupp.sum)
                ","
                (Tactic.simpLemma [] [] `Submodule.coe_inner)
                ","
                (Tactic.simpLemma [] [] `Finset.sum_ite_eq)
                ","
                (Tactic.simpLemma [] [] `ite_eq_left_iff)
                ","
                (Tactic.simpLemma [] [] `Dfinsupp.mem_support_to_fun)]
               "]"]
              [])
             []
             (Mathlib.Tactic.splitIfs
              "split_ifs"
              []
              ["with" [(Lean.binderIdent `h) (Lean.binderIdent `h)]])
             []
             (tactic__
              (cdotTk (patternIgnore (token.«· » "·")))
              [(Tactic.simp
                "simp"
                []
                []
                ["only"]
                ["[" [(Tactic.simpLemma [] [] `LinearIsometry.inner_map_map)] "]"]
                [])])
             []
             (tactic__
              (cdotTk (patternIgnore (token.«· » "·")))
              [(Tactic.simp
                "simp"
                []
                []
                ["only"]
                ["["
                 [(Tactic.simpLemma [] [] (Term.app `of_not_not [`h]))
                  ","
                  (Tactic.simpLemma [] [] `inner_zero_right)]
                 "]"]
                [])])]))))])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["["
            [(Tactic.simpLemma [] [] `Dfinsupp.sum)
             ","
             (Tactic.simpLemma [] [] `Submodule.coe_inner)
             ","
             (Tactic.simpLemma [] [] `Finset.sum_ite_eq)
             ","
             (Tactic.simpLemma [] [] `ite_eq_left_iff)
             ","
             (Tactic.simpLemma [] [] `Dfinsupp.mem_support_to_fun)]
            "]"]
           [])
          []
          (Mathlib.Tactic.splitIfs
           "split_ifs"
           []
           ["with" [(Lean.binderIdent `h) (Lean.binderIdent `h)]])
          []
          (tactic__
           (cdotTk (patternIgnore (token.«· » "·")))
           [(Tactic.simp
             "simp"
             []
             []
             ["only"]
             ["[" [(Tactic.simpLemma [] [] `LinearIsometry.inner_map_map)] "]"]
             [])])
          []
          (tactic__
           (cdotTk (patternIgnore (token.«· » "·")))
           [(Tactic.simp
             "simp"
             []
             []
             ["only"]
             ["["
              [(Tactic.simpLemma [] [] (Term.app `of_not_not [`h]))
               ","
               (Tactic.simpLemma [] [] `inner_zero_right)]
              "]"]
             [])])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.«· » "·")))
       [(Tactic.simp
         "simp"
         []
         []
         ["only"]
         ["["
          [(Tactic.simpLemma [] [] (Term.app `of_not_not [`h]))
           ","
           (Tactic.simpLemma [] [] `inner_zero_right)]
          "]"]
         [])])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] (Term.app `of_not_not [`h]))
         ","
         (Tactic.simpLemma [] [] `inner_zero_right)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_zero_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `of_not_not [`h])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `of_not_not
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.«· » "·")))
       [(Tactic.simp
         "simp"
         []
         []
         ["only"]
         ["[" [(Tactic.simpLemma [] [] `LinearIsometry.inner_map_map)] "]"]
         [])])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["[" [(Tactic.simpLemma [] [] `LinearIsometry.inner_map_map)] "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `LinearIsometry.inner_map_map
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.splitIfs
       "split_ifs"
       []
       ["with" [(Lean.binderIdent `h) (Lean.binderIdent `h)]])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] `Dfinsupp.sum)
         ","
         (Tactic.simpLemma [] [] `Submodule.coe_inner)
         ","
         (Tactic.simpLemma [] [] `Finset.sum_ite_eq)
         ","
         (Tactic.simpLemma [] [] `ite_eq_left_iff)
         ","
         (Tactic.simpLemma [] [] `Dfinsupp.mem_support_to_fun)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Dfinsupp.mem_support_to_fun
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `ite_eq_left_iff
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Finset.sum_ite_eq
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Submodule.coe_inner
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Dfinsupp.sum
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_»
       (Term.hole "_")
       "="
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " (Term.app `l [`i]) "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " (Term.app `l [`i]) "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  OrthogonalFamily.inner_right_dfinsupp
  ( l : ⨁ i , G i ) ( i : ι ) ( v : G i ) : ⟪ V i v , l . Sum fun j => V j ⟫ = ⟪ v , l i ⟫
  :=
    calc
      ⟪ V i v , l . Sum fun j => V j ⟫ = l . Sum fun j => fun w => ⟪ V i v , V j w ⟫
        :=
        Dfinsupp.inner_sum fun j => V j l V i v
      _ = l . Sum fun j => fun w => ite i = j ⟪ V i v , V j w ⟫ 0
          :=
          congr_arg l . Sum <| funext fun j => funext <| hV . eq_ite v
        _ = ⟪ v , l i ⟫
          :=
          by
            simp
                only
                [
                  Dfinsupp.sum
                    ,
                    Submodule.coe_inner
                    ,
                    Finset.sum_ite_eq
                    ,
                    ite_eq_left_iff
                    ,
                    Dfinsupp.mem_support_to_fun
                  ]
              split_ifs with h h
              · simp only [ LinearIsometry.inner_map_map ]
              · simp only [ of_not_not h , inner_zero_right ]
#align orthogonal_family.inner_right_dfinsupp OrthogonalFamily.inner_right_dfinsupp

omit dec_ι dec_V

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `OrthogonalFamily.inner_right_fintype [])
      (Command.declSig
       [(Term.instBinder "[" [] (Term.app `Fintype [`ι]) "]")
        (Term.explicitBinder "(" [`l] [":" (Term.forall "∀" [`i] [] "," (Term.app `G [`i]))] [] ")")
        (Term.explicitBinder "(" [`i] [":" `ι] [] ")")
        (Term.explicitBinder "(" [`v] [":" (Term.app `G [`i])] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (Term.app `V [`i `v])
          ", "
          (BigOperators.Algebra.BigOperators.Basic.finset.sum_univ
           "∑"
           (Std.ExtendedBinder.extBinders
            (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) [(group ":" `ι)]))
           ", "
           (Term.app `V [`j (Term.app `l [`j])]))
          "⟫")
         "="
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " (Term.app `l [`i]) "⟫"))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Mathlib.Tactic.tacticClassical_
            "classical"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(calcTactic
                "calc"
                (calcStep
                 («term_=_»
                  (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                   "⟪"
                   (Term.app `V [`i `v])
                   ", "
                   (BigOperators.Algebra.BigOperators.Basic.finset.sum_univ
                    "∑"
                    (Std.ExtendedBinder.extBinders
                     (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) [(group ":" `ι)]))
                    ", "
                    (Term.app `V [`j (Term.app `l [`j])]))
                   "⟫")
                  "="
                  (BigOperators.Algebra.BigOperators.Basic.finset.sum_univ
                   "∑"
                   (Std.ExtendedBinder.extBinders
                    (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) [(group ":" `ι)]))
                   ", "
                   (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                    "⟪"
                    (Term.app `V [`i `v])
                    ", "
                    (Term.app `V [`j (Term.app `l [`j])])
                    "⟫")))
                 ":="
                 (Term.byTactic
                  "by"
                  (Tactic.tacticSeq
                   (Tactic.tacticSeq1Indented
                    [(Tactic.rwSeq
                      "rw"
                      []
                      (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_sum)] "]")
                      [])]))))
                [(calcStep
                  («term_=_»
                   (Term.hole "_")
                   "="
                   (BigOperators.Algebra.BigOperators.Basic.finset.sum_univ
                    "∑"
                    (Std.ExtendedBinder.extBinders
                     (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) []))
                    ", "
                    (Term.app
                     `ite
                     [(«term_=_» `i "=" `j)
                      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                       "⟪"
                       (Term.app `V [`i `v])
                       ", "
                       (Term.app `V [`j (Term.app `l [`j])])
                       "⟫")
                      (num "0")])))
                  ":="
                  («term_<|_»
                   (Term.app `congr_arg [(Term.app `Finset.sum [`Finset.univ])])
                   "<|"
                   (Term.app
                    `funext
                    [(Term.fun
                      "fun"
                      (Term.basicFun
                       [`j]
                       []
                       "=>"
                       (Term.app `hV.eq_ite [`v (Term.app `l [`j])])))])))
                 (calcStep
                  («term_=_»
                   (Term.hole "_")
                   "="
                   (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                    "⟪"
                    `v
                    ", "
                    (Term.app `l [`i])
                    "⟫"))
                  ":="
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(Tactic.simp
                       "simp"
                       []
                       []
                       ["only"]
                       ["["
                        [(Tactic.simpLemma [] [] `Finset.sum_ite_eq)
                         ","
                         (Tactic.simpLemma [] [] `Finset.mem_univ)
                         ","
                         (Tactic.simpLemma [] [] (Term.proj (Term.app `V [`i]) "." `inner_map_map))
                         ","
                         (Tactic.simpLemma [] [] `if_true)]
                        "]"]
                       [])]))))])])))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Mathlib.Tactic.tacticClassical_
           "classical"
           (Tactic.tacticSeq
            (Tactic.tacticSeq1Indented
             [(calcTactic
               "calc"
               (calcStep
                («term_=_»
                 (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                  "⟪"
                  (Term.app `V [`i `v])
                  ", "
                  (BigOperators.Algebra.BigOperators.Basic.finset.sum_univ
                   "∑"
                   (Std.ExtendedBinder.extBinders
                    (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) [(group ":" `ι)]))
                   ", "
                   (Term.app `V [`j (Term.app `l [`j])]))
                  "⟫")
                 "="
                 (BigOperators.Algebra.BigOperators.Basic.finset.sum_univ
                  "∑"
                  (Std.ExtendedBinder.extBinders
                   (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) [(group ":" `ι)]))
                  ", "
                  (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                   "⟪"
                   (Term.app `V [`i `v])
                   ", "
                   (Term.app `V [`j (Term.app `l [`j])])
                   "⟫")))
                ":="
                (Term.byTactic
                 "by"
                 (Tactic.tacticSeq
                  (Tactic.tacticSeq1Indented
                   [(Tactic.rwSeq
                     "rw"
                     []
                     (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_sum)] "]")
                     [])]))))
               [(calcStep
                 («term_=_»
                  (Term.hole "_")
                  "="
                  (BigOperators.Algebra.BigOperators.Basic.finset.sum_univ
                   "∑"
                   (Std.ExtendedBinder.extBinders
                    (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) []))
                   ", "
                   (Term.app
                    `ite
                    [(«term_=_» `i "=" `j)
                     (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                      "⟪"
                      (Term.app `V [`i `v])
                      ", "
                      (Term.app `V [`j (Term.app `l [`j])])
                      "⟫")
                     (num "0")])))
                 ":="
                 («term_<|_»
                  (Term.app `congr_arg [(Term.app `Finset.sum [`Finset.univ])])
                  "<|"
                  (Term.app
                   `funext
                   [(Term.fun
                     "fun"
                     (Term.basicFun [`j] [] "=>" (Term.app `hV.eq_ite [`v (Term.app `l [`j])])))])))
                (calcStep
                 («term_=_»
                  (Term.hole "_")
                  "="
                  (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " (Term.app `l [`i]) "⟫"))
                 ":="
                 (Term.byTactic
                  "by"
                  (Tactic.tacticSeq
                   (Tactic.tacticSeq1Indented
                    [(Tactic.simp
                      "simp"
                      []
                      []
                      ["only"]
                      ["["
                       [(Tactic.simpLemma [] [] `Finset.sum_ite_eq)
                        ","
                        (Tactic.simpLemma [] [] `Finset.mem_univ)
                        ","
                        (Tactic.simpLemma [] [] (Term.proj (Term.app `V [`i]) "." `inner_map_map))
                        ","
                        (Tactic.simpLemma [] [] `if_true)]
                       "]"]
                      [])]))))])])))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.tacticClassical_
       "classical"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(calcTactic
           "calc"
           (calcStep
            («term_=_»
             (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
              "⟪"
              (Term.app `V [`i `v])
              ", "
              (BigOperators.Algebra.BigOperators.Basic.finset.sum_univ
               "∑"
               (Std.ExtendedBinder.extBinders
                (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) [(group ":" `ι)]))
               ", "
               (Term.app `V [`j (Term.app `l [`j])]))
              "⟫")
             "="
             (BigOperators.Algebra.BigOperators.Basic.finset.sum_univ
              "∑"
              (Std.ExtendedBinder.extBinders
               (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) [(group ":" `ι)]))
              ", "
              (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
               "⟪"
               (Term.app `V [`i `v])
               ", "
               (Term.app `V [`j (Term.app `l [`j])])
               "⟫")))
            ":="
            (Term.byTactic
             "by"
             (Tactic.tacticSeq
              (Tactic.tacticSeq1Indented
               [(Tactic.rwSeq
                 "rw"
                 []
                 (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_sum)] "]")
                 [])]))))
           [(calcStep
             («term_=_»
              (Term.hole "_")
              "="
              (BigOperators.Algebra.BigOperators.Basic.finset.sum_univ
               "∑"
               (Std.ExtendedBinder.extBinders
                (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) []))
               ", "
               (Term.app
                `ite
                [(«term_=_» `i "=" `j)
                 (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                  "⟪"
                  (Term.app `V [`i `v])
                  ", "
                  (Term.app `V [`j (Term.app `l [`j])])
                  "⟫")
                 (num "0")])))
             ":="
             («term_<|_»
              (Term.app `congr_arg [(Term.app `Finset.sum [`Finset.univ])])
              "<|"
              (Term.app
               `funext
               [(Term.fun
                 "fun"
                 (Term.basicFun [`j] [] "=>" (Term.app `hV.eq_ite [`v (Term.app `l [`j])])))])))
            (calcStep
             («term_=_»
              (Term.hole "_")
              "="
              (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " (Term.app `l [`i]) "⟫"))
             ":="
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Tactic.simp
                  "simp"
                  []
                  []
                  ["only"]
                  ["["
                   [(Tactic.simpLemma [] [] `Finset.sum_ite_eq)
                    ","
                    (Tactic.simpLemma [] [] `Finset.mem_univ)
                    ","
                    (Tactic.simpLemma [] [] (Term.proj (Term.app `V [`i]) "." `inner_map_map))
                    ","
                    (Tactic.simpLemma [] [] `if_true)]
                   "]"]
                  [])]))))])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (calcTactic
       "calc"
       (calcStep
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (Term.app `V [`i `v])
          ", "
          (BigOperators.Algebra.BigOperators.Basic.finset.sum_univ
           "∑"
           (Std.ExtendedBinder.extBinders
            (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) [(group ":" `ι)]))
           ", "
           (Term.app `V [`j (Term.app `l [`j])]))
          "⟫")
         "="
         (BigOperators.Algebra.BigOperators.Basic.finset.sum_univ
          "∑"
          (Std.ExtendedBinder.extBinders
           (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) [(group ":" `ι)]))
          ", "
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           (Term.app `V [`i `v])
           ", "
           (Term.app `V [`j (Term.app `l [`j])])
           "⟫")))
        ":="
        (Term.byTactic
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_sum)] "]")
             [])]))))
       [(calcStep
         («term_=_»
          (Term.hole "_")
          "="
          (BigOperators.Algebra.BigOperators.Basic.finset.sum_univ
           "∑"
           (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) []))
           ", "
           (Term.app
            `ite
            [(«term_=_» `i "=" `j)
             (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
              "⟪"
              (Term.app `V [`i `v])
              ", "
              (Term.app `V [`j (Term.app `l [`j])])
              "⟫")
             (num "0")])))
         ":="
         («term_<|_»
          (Term.app `congr_arg [(Term.app `Finset.sum [`Finset.univ])])
          "<|"
          (Term.app
           `funext
           [(Term.fun
             "fun"
             (Term.basicFun [`j] [] "=>" (Term.app `hV.eq_ite [`v (Term.app `l [`j])])))])))
        (calcStep
         («term_=_»
          (Term.hole "_")
          "="
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " (Term.app `l [`i]) "⟫"))
         ":="
         (Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(Tactic.simp
              "simp"
              []
              []
              ["only"]
              ["["
               [(Tactic.simpLemma [] [] `Finset.sum_ite_eq)
                ","
                (Tactic.simpLemma [] [] `Finset.mem_univ)
                ","
                (Tactic.simpLemma [] [] (Term.proj (Term.app `V [`i]) "." `inner_map_map))
                ","
                (Tactic.simpLemma [] [] `if_true)]
               "]"]
              [])]))))])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["["
            [(Tactic.simpLemma [] [] `Finset.sum_ite_eq)
             ","
             (Tactic.simpLemma [] [] `Finset.mem_univ)
             ","
             (Tactic.simpLemma [] [] (Term.proj (Term.app `V [`i]) "." `inner_map_map))
             ","
             (Tactic.simpLemma [] [] `if_true)]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] `Finset.sum_ite_eq)
         ","
         (Tactic.simpLemma [] [] `Finset.mem_univ)
         ","
         (Tactic.simpLemma [] [] (Term.proj (Term.app `V [`i]) "." `inner_map_map))
         ","
         (Tactic.simpLemma [] [] `if_true)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `if_true
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.proj (Term.app `V [`i]) "." `inner_map_map)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.app `V [`i])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `i
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `V
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `V [`i]) ")")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Finset.mem_univ
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Finset.sum_ite_eq
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_»
       (Term.hole "_")
       "="
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " (Term.app `l [`i]) "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " (Term.app `l [`i]) "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  OrthogonalFamily.inner_right_fintype
  [ Fintype ι ] ( l : ∀ i , G i ) ( i : ι ) ( v : G i )
    : ⟪ V i v , ∑ j : ι , V j l j ⟫ = ⟪ v , l i ⟫
  :=
    by
      classical
        calc
          ⟪ V i v , ∑ j : ι , V j l j ⟫ = ∑ j : ι , ⟪ V i v , V j l j ⟫ := by rw [ inner_sum ]
          _ = ∑ j , ite i = j ⟪ V i v , V j l j ⟫ 0
              :=
              congr_arg Finset.sum Finset.univ <| funext fun j => hV.eq_ite v l j
            _ = ⟪ v , l i ⟫
              :=
              by simp only [ Finset.sum_ite_eq , Finset.mem_univ , V i . inner_map_map , if_true ]
#align orthogonal_family.inner_right_fintype OrthogonalFamily.inner_right_fintype

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `OrthogonalFamily.inner_sum [])
      (Command.declSig
       [(Term.explicitBinder
         "("
         [`l₁ `l₂]
         [":" (Term.forall "∀" [`i] [] "," (Term.app `G [`i]))]
         []
         ")")
        (Term.explicitBinder "(" [`s] [":" (Term.app `Finset [`ι])] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (BigOperators.Algebra.BigOperators.Basic.finset.sum
           "∑"
           (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
           " in "
           `s
           ", "
           (Term.app `V [`i (Term.app `l₁ [`i])]))
          ", "
          (BigOperators.Algebra.BigOperators.Basic.finset.sum
           "∑"
           (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) []))
           " in "
           `s
           ", "
           (Term.app `V [`j (Term.app `l₂ [`j])]))
          "⟫")
         "="
         (BigOperators.Algebra.BigOperators.Basic.finset.sum
          "∑"
          (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
          " in "
          `s
          ", "
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           (Term.app `l₁ [`i])
           ", "
           (Term.app `l₂ [`i])
           "⟫")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Mathlib.Tactic.tacticClassical_
            "classical"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(calcTactic
                "calc"
                (calcStep
                 («term_=_»
                  (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                   "⟪"
                   (BigOperators.Algebra.BigOperators.Basic.finset.sum
                    "∑"
                    (Std.ExtendedBinder.extBinders
                     (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
                    " in "
                    `s
                    ", "
                    (Term.app `V [`i (Term.app `l₁ [`i])]))
                   ", "
                   (BigOperators.Algebra.BigOperators.Basic.finset.sum
                    "∑"
                    (Std.ExtendedBinder.extBinders
                     (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) []))
                    " in "
                    `s
                    ", "
                    (Term.app `V [`j (Term.app `l₂ [`j])]))
                   "⟫")
                  "="
                  (BigOperators.Algebra.BigOperators.Basic.finset.sum
                   "∑"
                   (Std.ExtendedBinder.extBinders
                    (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) []))
                   " in "
                   `s
                   ", "
                   (BigOperators.Algebra.BigOperators.Basic.finset.sum
                    "∑"
                    (Std.ExtendedBinder.extBinders
                     (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
                    " in "
                    `s
                    ", "
                    (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     (Term.app `V [`i (Term.app `l₁ [`i])])
                     ", "
                     (Term.app `V [`j (Term.app `l₂ [`j])])
                     "⟫"))))
                 ":="
                 (Term.byTactic
                  "by"
                  (Tactic.tacticSeq
                   (Tactic.tacticSeq1Indented
                    [(Tactic.simp
                      "simp"
                      []
                      []
                      ["only"]
                      ["["
                       [(Tactic.simpLemma [] [] `sum_inner) "," (Tactic.simpLemma [] [] `inner_sum)]
                       "]"]
                      [])]))))
                [(calcStep
                  («term_=_»
                   (Term.hole "_")
                   "="
                   (BigOperators.Algebra.BigOperators.Basic.finset.sum
                    "∑"
                    (Std.ExtendedBinder.extBinders
                     (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) []))
                    " in "
                    `s
                    ", "
                    (BigOperators.Algebra.BigOperators.Basic.finset.sum
                     "∑"
                     (Std.ExtendedBinder.extBinders
                      (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
                     " in "
                     `s
                     ", "
                     (Term.app
                      `ite
                      [(«term_=_» `i "=" `j)
                       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                        "⟪"
                        (Term.app `V [`i (Term.app `l₁ [`i])])
                        ", "
                        (Term.app `V [`j (Term.app `l₂ [`j])])
                        "⟫")
                       (num "0")]))))
                  ":="
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(Std.Tactic.congrWith
                       "congr"
                       []
                       "with"
                       [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `i))]
                       [])
                      []
                      (Std.Tactic.congrWith
                       "congr"
                       []
                       "with"
                       [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `j))]
                       [])
                      []
                      (Tactic.apply "apply" `hV.eq_ite)]))))
                 (calcStep
                  («term_=_»
                   (Term.hole "_")
                   "="
                   (BigOperators.Algebra.BigOperators.Basic.finset.sum
                    "∑"
                    (Std.ExtendedBinder.extBinders
                     (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
                    " in "
                    `s
                    ", "
                    (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     (Term.app `l₁ [`i])
                     ", "
                     (Term.app `l₂ [`i])
                     "⟫")))
                  ":="
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(Tactic.simp
                       "simp"
                       []
                       []
                       ["only"]
                       ["["
                        [(Tactic.simpLemma [] [] `Finset.sum_ite_of_true)
                         ","
                         (Tactic.simpLemma [] [] `Finset.sum_ite_eq')
                         ","
                         (Tactic.simpLemma [] [] `LinearIsometry.inner_map_map)
                         ","
                         (Tactic.simpLemma [] [] `imp_self)
                         ","
                         (Tactic.simpLemma [] [] `imp_true_iff)]
                        "]"]
                       [])]))))])])))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Mathlib.Tactic.tacticClassical_
           "classical"
           (Tactic.tacticSeq
            (Tactic.tacticSeq1Indented
             [(calcTactic
               "calc"
               (calcStep
                («term_=_»
                 (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                  "⟪"
                  (BigOperators.Algebra.BigOperators.Basic.finset.sum
                   "∑"
                   (Std.ExtendedBinder.extBinders
                    (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
                   " in "
                   `s
                   ", "
                   (Term.app `V [`i (Term.app `l₁ [`i])]))
                  ", "
                  (BigOperators.Algebra.BigOperators.Basic.finset.sum
                   "∑"
                   (Std.ExtendedBinder.extBinders
                    (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) []))
                   " in "
                   `s
                   ", "
                   (Term.app `V [`j (Term.app `l₂ [`j])]))
                  "⟫")
                 "="
                 (BigOperators.Algebra.BigOperators.Basic.finset.sum
                  "∑"
                  (Std.ExtendedBinder.extBinders
                   (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) []))
                  " in "
                  `s
                  ", "
                  (BigOperators.Algebra.BigOperators.Basic.finset.sum
                   "∑"
                   (Std.ExtendedBinder.extBinders
                    (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
                   " in "
                   `s
                   ", "
                   (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                    "⟪"
                    (Term.app `V [`i (Term.app `l₁ [`i])])
                    ", "
                    (Term.app `V [`j (Term.app `l₂ [`j])])
                    "⟫"))))
                ":="
                (Term.byTactic
                 "by"
                 (Tactic.tacticSeq
                  (Tactic.tacticSeq1Indented
                   [(Tactic.simp
                     "simp"
                     []
                     []
                     ["only"]
                     ["["
                      [(Tactic.simpLemma [] [] `sum_inner) "," (Tactic.simpLemma [] [] `inner_sum)]
                      "]"]
                     [])]))))
               [(calcStep
                 («term_=_»
                  (Term.hole "_")
                  "="
                  (BigOperators.Algebra.BigOperators.Basic.finset.sum
                   "∑"
                   (Std.ExtendedBinder.extBinders
                    (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) []))
                   " in "
                   `s
                   ", "
                   (BigOperators.Algebra.BigOperators.Basic.finset.sum
                    "∑"
                    (Std.ExtendedBinder.extBinders
                     (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
                    " in "
                    `s
                    ", "
                    (Term.app
                     `ite
                     [(«term_=_» `i "=" `j)
                      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                       "⟪"
                       (Term.app `V [`i (Term.app `l₁ [`i])])
                       ", "
                       (Term.app `V [`j (Term.app `l₂ [`j])])
                       "⟫")
                      (num "0")]))))
                 ":="
                 (Term.byTactic
                  "by"
                  (Tactic.tacticSeq
                   (Tactic.tacticSeq1Indented
                    [(Std.Tactic.congrWith
                      "congr"
                      []
                      "with"
                      [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `i))]
                      [])
                     []
                     (Std.Tactic.congrWith
                      "congr"
                      []
                      "with"
                      [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `j))]
                      [])
                     []
                     (Tactic.apply "apply" `hV.eq_ite)]))))
                (calcStep
                 («term_=_»
                  (Term.hole "_")
                  "="
                  (BigOperators.Algebra.BigOperators.Basic.finset.sum
                   "∑"
                   (Std.ExtendedBinder.extBinders
                    (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
                   " in "
                   `s
                   ", "
                   (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                    "⟪"
                    (Term.app `l₁ [`i])
                    ", "
                    (Term.app `l₂ [`i])
                    "⟫")))
                 ":="
                 (Term.byTactic
                  "by"
                  (Tactic.tacticSeq
                   (Tactic.tacticSeq1Indented
                    [(Tactic.simp
                      "simp"
                      []
                      []
                      ["only"]
                      ["["
                       [(Tactic.simpLemma [] [] `Finset.sum_ite_of_true)
                        ","
                        (Tactic.simpLemma [] [] `Finset.sum_ite_eq')
                        ","
                        (Tactic.simpLemma [] [] `LinearIsometry.inner_map_map)
                        ","
                        (Tactic.simpLemma [] [] `imp_self)
                        ","
                        (Tactic.simpLemma [] [] `imp_true_iff)]
                       "]"]
                      [])]))))])])))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.tacticClassical_
       "classical"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(calcTactic
           "calc"
           (calcStep
            («term_=_»
             (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
              "⟪"
              (BigOperators.Algebra.BigOperators.Basic.finset.sum
               "∑"
               (Std.ExtendedBinder.extBinders
                (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
               " in "
               `s
               ", "
               (Term.app `V [`i (Term.app `l₁ [`i])]))
              ", "
              (BigOperators.Algebra.BigOperators.Basic.finset.sum
               "∑"
               (Std.ExtendedBinder.extBinders
                (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) []))
               " in "
               `s
               ", "
               (Term.app `V [`j (Term.app `l₂ [`j])]))
              "⟫")
             "="
             (BigOperators.Algebra.BigOperators.Basic.finset.sum
              "∑"
              (Std.ExtendedBinder.extBinders
               (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) []))
              " in "
              `s
              ", "
              (BigOperators.Algebra.BigOperators.Basic.finset.sum
               "∑"
               (Std.ExtendedBinder.extBinders
                (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
               " in "
               `s
               ", "
               (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                "⟪"
                (Term.app `V [`i (Term.app `l₁ [`i])])
                ", "
                (Term.app `V [`j (Term.app `l₂ [`j])])
                "⟫"))))
            ":="
            (Term.byTactic
             "by"
             (Tactic.tacticSeq
              (Tactic.tacticSeq1Indented
               [(Tactic.simp
                 "simp"
                 []
                 []
                 ["only"]
                 ["["
                  [(Tactic.simpLemma [] [] `sum_inner) "," (Tactic.simpLemma [] [] `inner_sum)]
                  "]"]
                 [])]))))
           [(calcStep
             («term_=_»
              (Term.hole "_")
              "="
              (BigOperators.Algebra.BigOperators.Basic.finset.sum
               "∑"
               (Std.ExtendedBinder.extBinders
                (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) []))
               " in "
               `s
               ", "
               (BigOperators.Algebra.BigOperators.Basic.finset.sum
                "∑"
                (Std.ExtendedBinder.extBinders
                 (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
                " in "
                `s
                ", "
                (Term.app
                 `ite
                 [(«term_=_» `i "=" `j)
                  (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                   "⟪"
                   (Term.app `V [`i (Term.app `l₁ [`i])])
                   ", "
                   (Term.app `V [`j (Term.app `l₂ [`j])])
                   "⟫")
                  (num "0")]))))
             ":="
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Std.Tactic.congrWith
                  "congr"
                  []
                  "with"
                  [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `i))]
                  [])
                 []
                 (Std.Tactic.congrWith
                  "congr"
                  []
                  "with"
                  [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `j))]
                  [])
                 []
                 (Tactic.apply "apply" `hV.eq_ite)]))))
            (calcStep
             («term_=_»
              (Term.hole "_")
              "="
              (BigOperators.Algebra.BigOperators.Basic.finset.sum
               "∑"
               (Std.ExtendedBinder.extBinders
                (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
               " in "
               `s
               ", "
               (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                "⟪"
                (Term.app `l₁ [`i])
                ", "
                (Term.app `l₂ [`i])
                "⟫")))
             ":="
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Tactic.simp
                  "simp"
                  []
                  []
                  ["only"]
                  ["["
                   [(Tactic.simpLemma [] [] `Finset.sum_ite_of_true)
                    ","
                    (Tactic.simpLemma [] [] `Finset.sum_ite_eq')
                    ","
                    (Tactic.simpLemma [] [] `LinearIsometry.inner_map_map)
                    ","
                    (Tactic.simpLemma [] [] `imp_self)
                    ","
                    (Tactic.simpLemma [] [] `imp_true_iff)]
                   "]"]
                  [])]))))])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (calcTactic
       "calc"
       (calcStep
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (BigOperators.Algebra.BigOperators.Basic.finset.sum
           "∑"
           (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
           " in "
           `s
           ", "
           (Term.app `V [`i (Term.app `l₁ [`i])]))
          ", "
          (BigOperators.Algebra.BigOperators.Basic.finset.sum
           "∑"
           (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) []))
           " in "
           `s
           ", "
           (Term.app `V [`j (Term.app `l₂ [`j])]))
          "⟫")
         "="
         (BigOperators.Algebra.BigOperators.Basic.finset.sum
          "∑"
          (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) []))
          " in "
          `s
          ", "
          (BigOperators.Algebra.BigOperators.Basic.finset.sum
           "∑"
           (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
           " in "
           `s
           ", "
           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
            "⟪"
            (Term.app `V [`i (Term.app `l₁ [`i])])
            ", "
            (Term.app `V [`j (Term.app `l₂ [`j])])
            "⟫"))))
        ":="
        (Term.byTactic
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(Tactic.simp
             "simp"
             []
             []
             ["only"]
             ["[" [(Tactic.simpLemma [] [] `sum_inner) "," (Tactic.simpLemma [] [] `inner_sum)] "]"]
             [])]))))
       [(calcStep
         («term_=_»
          (Term.hole "_")
          "="
          (BigOperators.Algebra.BigOperators.Basic.finset.sum
           "∑"
           (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `j) []))
           " in "
           `s
           ", "
           (BigOperators.Algebra.BigOperators.Basic.finset.sum
            "∑"
            (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
            " in "
            `s
            ", "
            (Term.app
             `ite
             [(«term_=_» `i "=" `j)
              (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
               "⟪"
               (Term.app `V [`i (Term.app `l₁ [`i])])
               ", "
               (Term.app `V [`j (Term.app `l₂ [`j])])
               "⟫")
              (num "0")]))))
         ":="
         (Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(Std.Tactic.congrWith
              "congr"
              []
              "with"
              [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `i))]
              [])
             []
             (Std.Tactic.congrWith
              "congr"
              []
              "with"
              [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `j))]
              [])
             []
             (Tactic.apply "apply" `hV.eq_ite)]))))
        (calcStep
         («term_=_»
          (Term.hole "_")
          "="
          (BigOperators.Algebra.BigOperators.Basic.finset.sum
           "∑"
           (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
           " in "
           `s
           ", "
           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
            "⟪"
            (Term.app `l₁ [`i])
            ", "
            (Term.app `l₂ [`i])
            "⟫")))
         ":="
         (Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(Tactic.simp
              "simp"
              []
              []
              ["only"]
              ["["
               [(Tactic.simpLemma [] [] `Finset.sum_ite_of_true)
                ","
                (Tactic.simpLemma [] [] `Finset.sum_ite_eq')
                ","
                (Tactic.simpLemma [] [] `LinearIsometry.inner_map_map)
                ","
                (Tactic.simpLemma [] [] `imp_self)
                ","
                (Tactic.simpLemma [] [] `imp_true_iff)]
               "]"]
              [])]))))])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["["
            [(Tactic.simpLemma [] [] `Finset.sum_ite_of_true)
             ","
             (Tactic.simpLemma [] [] `Finset.sum_ite_eq')
             ","
             (Tactic.simpLemma [] [] `LinearIsometry.inner_map_map)
             ","
             (Tactic.simpLemma [] [] `imp_self)
             ","
             (Tactic.simpLemma [] [] `imp_true_iff)]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] `Finset.sum_ite_of_true)
         ","
         (Tactic.simpLemma [] [] `Finset.sum_ite_eq')
         ","
         (Tactic.simpLemma [] [] `LinearIsometry.inner_map_map)
         ","
         (Tactic.simpLemma [] [] `imp_self)
         ","
         (Tactic.simpLemma [] [] `imp_true_iff)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `imp_true_iff
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `imp_self
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `LinearIsometry.inner_map_map
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Finset.sum_ite_eq'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Finset.sum_ite_of_true
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_»
       (Term.hole "_")
       "="
       (BigOperators.Algebra.BigOperators.Basic.finset.sum
        "∑"
        (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
        " in "
        `s
        ", "
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
         "⟪"
         (Term.app `l₁ [`i])
         ", "
         (Term.app `l₂ [`i])
         "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (BigOperators.Algebra.BigOperators.Basic.finset.sum
       "∑"
       (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `i) []))
       " in "
       `s
       ", "
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        (Term.app `l₁ [`i])
        ", "
        (Term.app `l₂ [`i])
        "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
       "⟪"
       (Term.app `l₁ [`i])
       ", "
       (Term.app `l₂ [`i])
       "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  OrthogonalFamily.inner_sum
  ( l₁ l₂ : ∀ i , G i ) ( s : Finset ι )
    : ⟪ ∑ i in s , V i l₁ i , ∑ j in s , V j l₂ j ⟫ = ∑ i in s , ⟪ l₁ i , l₂ i ⟫
  :=
    by
      classical
        calc
          ⟪ ∑ i in s , V i l₁ i , ∑ j in s , V j l₂ j ⟫
              =
              ∑ j in s , ∑ i in s , ⟪ V i l₁ i , V j l₂ j ⟫
            :=
            by simp only [ sum_inner , inner_sum ]
          _ = ∑ j in s , ∑ i in s , ite i = j ⟪ V i l₁ i , V j l₂ j ⟫ 0
              :=
              by congr with i congr with j apply hV.eq_ite
            _ = ∑ i in s , ⟪ l₁ i , l₂ i ⟫
              :=
              by
                simp
                  only
                  [
                    Finset.sum_ite_of_true
                      ,
                      Finset.sum_ite_eq'
                      ,
                      LinearIsometry.inner_map_map
                      ,
                      imp_self
                      ,
                      imp_true_iff
                    ]
#align orthogonal_family.inner_sum OrthogonalFamily.inner_sum

theorem OrthogonalFamily.norm_sum (l : ∀ i, G i) (s : Finset ι) :
    ‖∑ i in s, V i (l i)‖ ^ 2 = ∑ i in s, ‖l i‖ ^ 2 :=
  by
  have : (‖∑ i in s, V i (l i)‖ ^ 2 : 𝕜) = ∑ i in s, ‖l i‖ ^ 2 := by
    simp only [← inner_self_eq_norm_sq_to_K, hV.inner_sum]
  exact_mod_cast this
#align orthogonal_family.norm_sum OrthogonalFamily.norm_sum

/-- The composition of an orthogonal family of subspaces with an injective function is also an
orthogonal family. -/
theorem OrthogonalFamily.comp {γ : Type _} {f : γ → ι} (hf : Function.Injective f) :
    OrthogonalFamily 𝕜 fun g : γ => (V (f g) : G (f g) →ₗᵢ[𝕜] E) := fun i j hij v w =>
  hV (hf.Ne hij) v w
#align orthogonal_family.comp OrthogonalFamily.comp

theorem OrthogonalFamily.orthonormalSigmaOrthonormal {α : ι → Type _} {v_family : ∀ i, α i → G i}
    (hv_family : ∀ i, Orthonormal 𝕜 (v_family i)) :
    Orthonormal 𝕜 fun a : Σi, α i => V a.1 (v_family a.1 a.2) :=
  by
  constructor
  · rintro ⟨i, v⟩
    simpa only [LinearIsometry.norm_map] using (hv_family i).left v
  rintro ⟨i, v⟩ ⟨j, w⟩ hvw
  by_cases hij : i = j
  · subst hij
    have : v ≠ w := fun h => by
      subst h
      exact hvw rfl
    simpa only [LinearIsometry.inner_map_map] using (hv_family i).2 this
  · exact hV hij (v_family i v) (v_family j w)
#align orthogonal_family.orthonormal_sigma_orthonormal OrthogonalFamily.orthonormalSigmaOrthonormal

include dec_ι

theorem OrthogonalFamily.norm_sq_diff_sum (f : ∀ i, G i) (s₁ s₂ : Finset ι) :
    ‖(∑ i in s₁, V i (f i)) - ∑ i in s₂, V i (f i)‖ ^ 2 =
      (∑ i in s₁ \ s₂, ‖f i‖ ^ 2) + ∑ i in s₂ \ s₁, ‖f i‖ ^ 2 :=
  by
  rw [← Finset.sum_sdiff_sub_sum_sdiff, sub_eq_add_neg, ← Finset.sum_neg_distrib]
  let F : ∀ i, G i := fun i => if i ∈ s₁ then f i else -f i
  have hF₁ : ∀ i ∈ s₁ \ s₂, F i = f i := fun i hi => if_pos (Finset.sdiff_subset _ _ hi)
  have hF₂ : ∀ i ∈ s₂ \ s₁, F i = -f i := fun i hi => if_neg (finset.mem_sdiff.mp hi).2
  have hF : ∀ i, ‖F i‖ = ‖f i‖ := by
    intro i
    dsimp only [F]
    split_ifs <;> simp only [eq_self_iff_true, norm_neg]
  have :
    ‖(∑ i in s₁ \ s₂, V i (F i)) + ∑ i in s₂ \ s₁, V i (F i)‖ ^ 2 =
      (∑ i in s₁ \ s₂, ‖F i‖ ^ 2) + ∑ i in s₂ \ s₁, ‖F i‖ ^ 2 :=
    by
    have hs : Disjoint (s₁ \ s₂) (s₂ \ s₁) := disjoint_sdiff_sdiff
    simpa only [Finset.sum_union hs] using hV.norm_sum F (s₁ \ s₂ ∪ s₂ \ s₁)
  convert this using 4
  · refine' Finset.sum_congr rfl fun i hi => _
    simp only [hF₁ i hi]
  · refine' Finset.sum_congr rfl fun i hi => _
    simp only [hF₂ i hi, LinearIsometry.map_neg]
  · simp only [hF]
  · simp only [hF]
#align orthogonal_family.norm_sq_diff_sum OrthogonalFamily.norm_sq_diff_sum

omit dec_ι

/-- A family `f` of mutually-orthogonal elements of `E` is summable, if and only if
`(λ i, ‖f i‖ ^ 2)` is summable. -/
theorem OrthogonalFamily.summable_iff_norm_sq_summable [CompleteSpace E] (f : ∀ i, G i) :
    (Summable fun i => V i (f i)) ↔ Summable fun i => ‖f i‖ ^ 2 := by
  classical
    simp only [summable_iff_cauchy_seq_finset, NormedAddCommGroup.cauchy_seq_iff, Real.norm_eq_abs]
    constructor
    · intro hf ε hε
      obtain ⟨a, H⟩ := hf _ (sqrt_pos.mpr hε)
      use a
      intro s₁ hs₁ s₂ hs₂
      rw [← Finset.sum_sdiff_sub_sum_sdiff]
      refine' (_root_.abs_sub _ _).trans_lt _
      have : ∀ i, 0 ≤ ‖f i‖ ^ 2 := fun i : ι => sq_nonneg _
      simp only [Finset.abs_sum_of_nonneg' this]
      have : ((∑ i in s₁ \ s₂, ‖f i‖ ^ 2) + ∑ i in s₂ \ s₁, ‖f i‖ ^ 2) < sqrt ε ^ 2 :=
        by
        rw [← hV.norm_sq_diff_sum, sq_lt_sq, _root_.abs_of_nonneg (sqrt_nonneg _),
          _root_.abs_of_nonneg (norm_nonneg _)]
        exact H s₁ hs₁ s₂ hs₂
      have hη := sq_sqrt (le_of_lt hε)
      linarith
    · intro hf ε hε
      have hε' : 0 < ε ^ 2 / 2 := half_pos (sq_pos_of_pos hε)
      obtain ⟨a, H⟩ := hf _ hε'
      use a
      intro s₁ hs₁ s₂ hs₂
      refine' (abs_lt_of_sq_lt_sq' _ (le_of_lt hε)).2
      have has : a ≤ s₁ ⊓ s₂ := le_inf hs₁ hs₂
      rw [hV.norm_sq_diff_sum]
      have Hs₁ : (∑ x : ι in s₁ \ s₂, ‖f x‖ ^ 2) < ε ^ 2 / 2 :=
        by
        convert H _ hs₁ _ has
        have : s₁ ⊓ s₂ ⊆ s₁ := Finset.inter_subset_left _ _
        rw [← Finset.sum_sdiff this, add_tsub_cancel_right, Finset.abs_sum_of_nonneg']
        · simp
        · exact fun i => sq_nonneg _
      have Hs₂ : (∑ x : ι in s₂ \ s₁, ‖f x‖ ^ 2) < ε ^ 2 / 2 :=
        by
        convert H _ hs₂ _ has
        have : s₁ ⊓ s₂ ⊆ s₂ := Finset.inter_subset_right _ _
        rw [← Finset.sum_sdiff this, add_tsub_cancel_right, Finset.abs_sum_of_nonneg']
        · simp
        · exact fun i => sq_nonneg _
      linarith
#align
  orthogonal_family.summable_iff_norm_sq_summable OrthogonalFamily.summable_iff_norm_sq_summable

omit hV

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "An orthogonal family forms an independent family of subspaces; that is, any collection of\nelements each from a different subspace in the family is linearly independent. In particular, the\npairwise intersections of elements of the family are 0. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `OrthogonalFamily.independent [])
      (Command.declSig
       [(Term.implicitBinder "{" [`V] [":" (Term.arrow `ι "→" (Term.app `Submodule [`𝕜 `E]))] "}")
        (Term.explicitBinder
         "("
         [`hV]
         [":"
          (Term.app
           (Term.explicit "@" `OrthogonalFamily)
           [`𝕜
            (Term.hole "_")
            (Term.hole "_")
            (Term.hole "_")
            (Term.hole "_")
            (Term.fun "fun" (Term.basicFun [`i] [] "=>" (Term.app `V [`i])))
            (Term.hole "_")
            (Term.fun
             "fun"
             (Term.basicFun [`i] [] "=>" (Term.proj (Term.app `V [`i]) "." `subtypeₗᵢ)))])]
         []
         ")")]
       (Term.typeSpec ":" (Term.app `CompleteLattice.Independent [`V])))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Mathlib.Tactic.tacticClassical_
            "classical"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.apply "apply" `CompleteLattice.independent_of_dfinsupp_lsum_injective)
               []
               (Tactic.rwSeq
                "rw"
                []
                (Tactic.rwRuleSeq
                 "["
                 [(Tactic.rwRule
                   [(patternIgnore (token.«← » "←"))]
                   (Term.app
                    (Term.explicit "@" `LinearMap.ker_eq_bot)
                    [(Term.hole "_")
                     (Term.hole "_")
                     (Term.hole "_")
                     (Term.hole "_")
                     (Term.hole "_")
                     (Term.hole "_")
                     (Term.app
                      `DirectSum.addCommGroup
                      [(Term.fun "fun" (Term.basicFun [`i] [] "=>" (Term.app `V [`i])))])]))
                  ","
                  (Tactic.rwRule [] `Submodule.eq_bot_iff)]
                 "]")
                [])
               []
               (Tactic.intro "intro" [`v `hv])
               []
               (Tactic.rwSeq
                "rw"
                []
                (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `LinearMap.mem_ker)] "]")
                [(Tactic.location "at" (Tactic.locationHyp [`hv] []))])
               []
               (Std.Tactic.Ext.«tacticExt___:_»
                "ext"
                [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `i))]
                [])
               []
               (Tactic.tacticSuffices_
                "suffices"
                (Term.sufficesDecl
                 []
                 («term_=_»
                  (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                   "⟪"
                   (Term.typeAscription "(" (Term.app `v [`i]) ":" [`E] ")")
                   ", "
                   (Term.app `v [`i])
                   "⟫")
                  "="
                  (num "0"))
                 (Term.byTactic'
                  "by"
                  (Tactic.tacticSeq
                   (Tactic.tacticSeq1Indented
                    [(Std.Tactic.Simpa.simpa
                      "simpa"
                      []
                      []
                      (Std.Tactic.Simpa.simpaArgsRest
                       []
                       []
                       ["only"]
                       [(Tactic.simpArgs "[" [(Tactic.simpLemma [] [] `inner_self_eq_zero)] "]")]
                       ["using" `this]))])))))
               []
               (calcTactic
                "calc"
                (calcStep
                 («term_=_»
                  (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                   "⟪"
                   (Term.typeAscription "(" (Term.app `v [`i]) ":" [`E] ")")
                   ", "
                   (Term.app `v [`i])
                   "⟫")
                  "="
                  (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                   "⟪"
                   (Term.typeAscription "(" (Term.app `v [`i]) ":" [`E] ")")
                   ", "
                   (Term.app
                    `Dfinsupp.lsum
                    [(termℕ "ℕ")
                     (Term.fun
                      "fun"
                      (Term.basicFun [`i] [] "=>" (Term.proj (Term.app `V [`i]) "." `Subtype)))
                     `v])
                   "⟫"))
                 ":="
                 (Term.byTactic
                  "by"
                  (Tactic.tacticSeq
                   (Tactic.tacticSeq1Indented
                    [(Std.Tactic.Simpa.simpa
                      "simpa"
                      []
                      []
                      (Std.Tactic.Simpa.simpaArgsRest
                       []
                       []
                       ["only"]
                       [(Tactic.simpArgs
                         "["
                         [(Tactic.simpLemma [] [] `Dfinsupp.sum_add_hom_apply)
                          ","
                          (Tactic.simpLemma [] [] `Dfinsupp.lsum_apply_apply)]
                         "]")]
                       ["using"
                        (Term.proj
                         (Term.app `hV.inner_right_dfinsupp [`v `i (Term.app `v [`i])])
                         "."
                         `symm)]))]))))
                [(calcStep
                  («term_=_» (Term.hole "_") "=" (num "0"))
                  ":="
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(Tactic.simp
                       "simp"
                       []
                       []
                       ["only"]
                       ["["
                        [(Tactic.simpLemma [] [] `hv)
                         ","
                         (Tactic.simpLemma [] [] `inner_zero_right)]
                        "]"]
                       [])]))))])])))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Mathlib.Tactic.tacticClassical_
           "classical"
           (Tactic.tacticSeq
            (Tactic.tacticSeq1Indented
             [(Tactic.apply "apply" `CompleteLattice.independent_of_dfinsupp_lsum_injective)
              []
              (Tactic.rwSeq
               "rw"
               []
               (Tactic.rwRuleSeq
                "["
                [(Tactic.rwRule
                  [(patternIgnore (token.«← » "←"))]
                  (Term.app
                   (Term.explicit "@" `LinearMap.ker_eq_bot)
                   [(Term.hole "_")
                    (Term.hole "_")
                    (Term.hole "_")
                    (Term.hole "_")
                    (Term.hole "_")
                    (Term.hole "_")
                    (Term.app
                     `DirectSum.addCommGroup
                     [(Term.fun "fun" (Term.basicFun [`i] [] "=>" (Term.app `V [`i])))])]))
                 ","
                 (Tactic.rwRule [] `Submodule.eq_bot_iff)]
                "]")
               [])
              []
              (Tactic.intro "intro" [`v `hv])
              []
              (Tactic.rwSeq
               "rw"
               []
               (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `LinearMap.mem_ker)] "]")
               [(Tactic.location "at" (Tactic.locationHyp [`hv] []))])
              []
              (Std.Tactic.Ext.«tacticExt___:_»
               "ext"
               [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `i))]
               [])
              []
              (Tactic.tacticSuffices_
               "suffices"
               (Term.sufficesDecl
                []
                («term_=_»
                 (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                  "⟪"
                  (Term.typeAscription "(" (Term.app `v [`i]) ":" [`E] ")")
                  ", "
                  (Term.app `v [`i])
                  "⟫")
                 "="
                 (num "0"))
                (Term.byTactic'
                 "by"
                 (Tactic.tacticSeq
                  (Tactic.tacticSeq1Indented
                   [(Std.Tactic.Simpa.simpa
                     "simpa"
                     []
                     []
                     (Std.Tactic.Simpa.simpaArgsRest
                      []
                      []
                      ["only"]
                      [(Tactic.simpArgs "[" [(Tactic.simpLemma [] [] `inner_self_eq_zero)] "]")]
                      ["using" `this]))])))))
              []
              (calcTactic
               "calc"
               (calcStep
                («term_=_»
                 (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                  "⟪"
                  (Term.typeAscription "(" (Term.app `v [`i]) ":" [`E] ")")
                  ", "
                  (Term.app `v [`i])
                  "⟫")
                 "="
                 (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                  "⟪"
                  (Term.typeAscription "(" (Term.app `v [`i]) ":" [`E] ")")
                  ", "
                  (Term.app
                   `Dfinsupp.lsum
                   [(termℕ "ℕ")
                    (Term.fun
                     "fun"
                     (Term.basicFun [`i] [] "=>" (Term.proj (Term.app `V [`i]) "." `Subtype)))
                    `v])
                  "⟫"))
                ":="
                (Term.byTactic
                 "by"
                 (Tactic.tacticSeq
                  (Tactic.tacticSeq1Indented
                   [(Std.Tactic.Simpa.simpa
                     "simpa"
                     []
                     []
                     (Std.Tactic.Simpa.simpaArgsRest
                      []
                      []
                      ["only"]
                      [(Tactic.simpArgs
                        "["
                        [(Tactic.simpLemma [] [] `Dfinsupp.sum_add_hom_apply)
                         ","
                         (Tactic.simpLemma [] [] `Dfinsupp.lsum_apply_apply)]
                        "]")]
                      ["using"
                       (Term.proj
                        (Term.app `hV.inner_right_dfinsupp [`v `i (Term.app `v [`i])])
                        "."
                        `symm)]))]))))
               [(calcStep
                 («term_=_» (Term.hole "_") "=" (num "0"))
                 ":="
                 (Term.byTactic
                  "by"
                  (Tactic.tacticSeq
                   (Tactic.tacticSeq1Indented
                    [(Tactic.simp
                      "simp"
                      []
                      []
                      ["only"]
                      ["["
                       [(Tactic.simpLemma [] [] `hv) "," (Tactic.simpLemma [] [] `inner_zero_right)]
                       "]"]
                      [])]))))])])))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.tacticClassical_
       "classical"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.apply "apply" `CompleteLattice.independent_of_dfinsupp_lsum_injective)
          []
          (Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule
              [(patternIgnore (token.«← » "←"))]
              (Term.app
               (Term.explicit "@" `LinearMap.ker_eq_bot)
               [(Term.hole "_")
                (Term.hole "_")
                (Term.hole "_")
                (Term.hole "_")
                (Term.hole "_")
                (Term.hole "_")
                (Term.app
                 `DirectSum.addCommGroup
                 [(Term.fun "fun" (Term.basicFun [`i] [] "=>" (Term.app `V [`i])))])]))
             ","
             (Tactic.rwRule [] `Submodule.eq_bot_iff)]
            "]")
           [])
          []
          (Tactic.intro "intro" [`v `hv])
          []
          (Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `LinearMap.mem_ker)] "]")
           [(Tactic.location "at" (Tactic.locationHyp [`hv] []))])
          []
          (Std.Tactic.Ext.«tacticExt___:_»
           "ext"
           [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `i))]
           [])
          []
          (Tactic.tacticSuffices_
           "suffices"
           (Term.sufficesDecl
            []
            («term_=_»
             (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
              "⟪"
              (Term.typeAscription "(" (Term.app `v [`i]) ":" [`E] ")")
              ", "
              (Term.app `v [`i])
              "⟫")
             "="
             (num "0"))
            (Term.byTactic'
             "by"
             (Tactic.tacticSeq
              (Tactic.tacticSeq1Indented
               [(Std.Tactic.Simpa.simpa
                 "simpa"
                 []
                 []
                 (Std.Tactic.Simpa.simpaArgsRest
                  []
                  []
                  ["only"]
                  [(Tactic.simpArgs "[" [(Tactic.simpLemma [] [] `inner_self_eq_zero)] "]")]
                  ["using" `this]))])))))
          []
          (calcTactic
           "calc"
           (calcStep
            («term_=_»
             (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
              "⟪"
              (Term.typeAscription "(" (Term.app `v [`i]) ":" [`E] ")")
              ", "
              (Term.app `v [`i])
              "⟫")
             "="
             (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
              "⟪"
              (Term.typeAscription "(" (Term.app `v [`i]) ":" [`E] ")")
              ", "
              (Term.app
               `Dfinsupp.lsum
               [(termℕ "ℕ")
                (Term.fun
                 "fun"
                 (Term.basicFun [`i] [] "=>" (Term.proj (Term.app `V [`i]) "." `Subtype)))
                `v])
              "⟫"))
            ":="
            (Term.byTactic
             "by"
             (Tactic.tacticSeq
              (Tactic.tacticSeq1Indented
               [(Std.Tactic.Simpa.simpa
                 "simpa"
                 []
                 []
                 (Std.Tactic.Simpa.simpaArgsRest
                  []
                  []
                  ["only"]
                  [(Tactic.simpArgs
                    "["
                    [(Tactic.simpLemma [] [] `Dfinsupp.sum_add_hom_apply)
                     ","
                     (Tactic.simpLemma [] [] `Dfinsupp.lsum_apply_apply)]
                    "]")]
                  ["using"
                   (Term.proj
                    (Term.app `hV.inner_right_dfinsupp [`v `i (Term.app `v [`i])])
                    "."
                    `symm)]))]))))
           [(calcStep
             («term_=_» (Term.hole "_") "=" (num "0"))
             ":="
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Tactic.simp
                  "simp"
                  []
                  []
                  ["only"]
                  ["["
                   [(Tactic.simpLemma [] [] `hv) "," (Tactic.simpLemma [] [] `inner_zero_right)]
                   "]"]
                  [])]))))])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (calcTactic
       "calc"
       (calcStep
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (Term.typeAscription "(" (Term.app `v [`i]) ":" [`E] ")")
          ", "
          (Term.app `v [`i])
          "⟫")
         "="
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (Term.typeAscription "(" (Term.app `v [`i]) ":" [`E] ")")
          ", "
          (Term.app
           `Dfinsupp.lsum
           [(termℕ "ℕ")
            (Term.fun
             "fun"
             (Term.basicFun [`i] [] "=>" (Term.proj (Term.app `V [`i]) "." `Subtype)))
            `v])
          "⟫"))
        ":="
        (Term.byTactic
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(Std.Tactic.Simpa.simpa
             "simpa"
             []
             []
             (Std.Tactic.Simpa.simpaArgsRest
              []
              []
              ["only"]
              [(Tactic.simpArgs
                "["
                [(Tactic.simpLemma [] [] `Dfinsupp.sum_add_hom_apply)
                 ","
                 (Tactic.simpLemma [] [] `Dfinsupp.lsum_apply_apply)]
                "]")]
              ["using"
               (Term.proj
                (Term.app `hV.inner_right_dfinsupp [`v `i (Term.app `v [`i])])
                "."
                `symm)]))]))))
       [(calcStep
         («term_=_» (Term.hole "_") "=" (num "0"))
         ":="
         (Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(Tactic.simp
              "simp"
              []
              []
              ["only"]
              ["["
               [(Tactic.simpLemma [] [] `hv) "," (Tactic.simpLemma [] [] `inner_zero_right)]
               "]"]
              [])]))))])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["[" [(Tactic.simpLemma [] [] `hv) "," (Tactic.simpLemma [] [] `inner_zero_right)] "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["[" [(Tactic.simpLemma [] [] `hv) "," (Tactic.simpLemma [] [] `inner_zero_right)] "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_zero_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hv
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_» (Term.hole "_") "=" (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none, [anonymous]) <=? (some 50, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 50, (some 51, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, term))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Std.Tactic.Simpa.simpa
           "simpa"
           []
           []
           (Std.Tactic.Simpa.simpaArgsRest
            []
            []
            ["only"]
            [(Tactic.simpArgs
              "["
              [(Tactic.simpLemma [] [] `Dfinsupp.sum_add_hom_apply)
               ","
               (Tactic.simpLemma [] [] `Dfinsupp.lsum_apply_apply)]
              "]")]
            ["using"
             (Term.proj
              (Term.app `hV.inner_right_dfinsupp [`v `i (Term.app `v [`i])])
              "."
              `symm)]))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Std.Tactic.Simpa.simpa
       "simpa"
       []
       []
       (Std.Tactic.Simpa.simpaArgsRest
        []
        []
        ["only"]
        [(Tactic.simpArgs
          "["
          [(Tactic.simpLemma [] [] `Dfinsupp.sum_add_hom_apply)
           ","
           (Tactic.simpLemma [] [] `Dfinsupp.lsum_apply_apply)]
          "]")]
        ["using"
         (Term.proj (Term.app `hV.inner_right_dfinsupp [`v `i (Term.app `v [`i])]) "." `symm)]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.proj (Term.app `hV.inner_right_dfinsupp [`v `i (Term.app `v [`i])]) "." `symm)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.app `hV.inner_right_dfinsupp [`v `i (Term.app `v [`i])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `v [`i])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `i
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `v
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `v [`i]) ")")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `i
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `v
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `hV.inner_right_dfinsupp
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app `hV.inner_right_dfinsupp [`v `i (Term.paren "(" (Term.app `v [`i]) ")")])
     ")")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Dfinsupp.lsum_apply_apply
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Dfinsupp.sum_add_hom_apply
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        (Term.typeAscription "(" (Term.app `v [`i]) ":" [`E] ")")
        ", "
        (Term.app `v [`i])
        "⟫")
       "="
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        (Term.typeAscription "(" (Term.app `v [`i]) ":" [`E] ")")
        ", "
        (Term.app
         `Dfinsupp.lsum
         [(termℕ "ℕ")
          (Term.fun "fun" (Term.basicFun [`i] [] "=>" (Term.proj (Term.app `V [`i]) "." `Subtype)))
          `v])
        "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
       "⟪"
       (Term.typeAscription "(" (Term.app `v [`i]) ":" [`E] ")")
       ", "
       (Term.app
        `Dfinsupp.lsum
        [(termℕ "ℕ")
         (Term.fun "fun" (Term.basicFun [`i] [] "=>" (Term.proj (Term.app `V [`i]) "." `Subtype)))
         `v])
       "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    An orthogonal family forms an independent family of subspaces; that is, any collection of
    elements each from a different subspace in the family is linearly independent. In particular, the
    pairwise intersections of elements of the family are 0. -/
  theorem
    OrthogonalFamily.independent
    { V : ι → Submodule 𝕜 E }
        ( hV : @ OrthogonalFamily 𝕜 _ _ _ _ fun i => V i _ fun i => V i . subtypeₗᵢ )
      : CompleteLattice.Independent V
    :=
      by
        classical
          apply CompleteLattice.independent_of_dfinsupp_lsum_injective
            rw
              [
                ← @ LinearMap.ker_eq_bot _ _ _ _ _ _ DirectSum.addCommGroup fun i => V i
                  ,
                  Submodule.eq_bot_iff
                ]
            intro v hv
            rw [ LinearMap.mem_ker ] at hv
            ext i
            suffices ⟪ ( v i : E ) , v i ⟫ = 0 by simpa only [ inner_self_eq_zero ] using this
            calc
              ⟪ ( v i : E ) , v i ⟫ = ⟪ ( v i : E ) , Dfinsupp.lsum ℕ fun i => V i . Subtype v ⟫
                :=
                by
                  simpa
                    only
                      [ Dfinsupp.sum_add_hom_apply , Dfinsupp.lsum_apply_apply ]
                      using hV.inner_right_dfinsupp v i v i . symm
              _ = 0 := by simp only [ hv , inner_zero_right ]
#align orthogonal_family.independent OrthogonalFamily.independent

include dec_ι

theorem DirectSum.IsInternal.collectedBasisOrthonormal {V : ι → Submodule 𝕜 E}
    (hV : @OrthogonalFamily 𝕜 _ _ _ _ (fun i => V i) _ fun i => (V i).subtypeₗᵢ)
    (hV_sum : DirectSum.IsInternal fun i => V i) {α : ι → Type _}
    {v_family : ∀ i, Basis (α i) 𝕜 (V i)} (hv_family : ∀ i, Orthonormal 𝕜 (v_family i)) :
    Orthonormal 𝕜 (hV_sum.collectedBasis v_family) := by
  simpa only [hV_sum.collected_basis_coe] using hV.orthonormal_sigma_orthonormal hv_family
#align
  direct_sum.is_internal.collected_basis_orthonormal DirectSum.IsInternal.collectedBasisOrthonormal

end OrthogonalFamily

section IsROrCToReal

variable {G : Type _}

variable (𝕜 E)

include 𝕜

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "A general inner product implies a real inner product. This is not registered as an instance\nsince it creates problems with the case `𝕜 = ℝ`. -/")]
      []
      []
      []
      []
      [])
     (Command.def
      "def"
      (Command.declId `HasInner.isROrCToReal [])
      (Command.optDeclSig
       []
       [(Term.typeSpec ":" (Term.app `HasInner [(Data.Real.Basic.termℝ "ℝ") `E]))])
      (Command.whereStructInst
       "where"
       [(Command.whereStructField
         (Term.letDecl
          (Term.letIdDecl
           `inner
           [`x `y]
           []
           ":="
           (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")]))))]
       [])
      []
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.whereStructInst', expected 'Lean.Parser.Command.declValSimple'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.whereStructInst', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.letIdDecl', expected 'Lean.Parser.Term.letPatDecl'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.letIdDecl', expected 'Lean.Parser.Term.letEqnsDecl'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.theorem'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    A general inner product implies a real inner product. This is not registered as an instance
    since it creates problems with the case `𝕜 = ℝ`. -/
  def HasInner.isROrCToReal : HasInner ℝ E where inner x y := re ⟪ x , y ⟫
#align has_inner.is_R_or_C_to_real HasInner.isROrCToReal

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "A general inner product space structure implies a real inner product structure. This is not\nregistered as an instance since it creates problems with the case `𝕜 = ℝ`, but in can be used in a\nproof to obtain a real inner product space structure from a given `𝕜`-inner product space\nstructure. -/")]
      []
      []
      []
      []
      [])
     (Command.def
      "def"
      (Command.declId `InnerProductSpace.isROrCToReal [])
      (Command.optDeclSig
       []
       [(Term.typeSpec ":" (Term.app `InnerProductSpace [(Data.Real.Basic.termℝ "ℝ") `E]))])
      (Command.declValSimple
       ":="
       (Term.structInst
        "{"
        [[(Term.app `HasInner.isROrCToReal [`𝕜 `E])
          ","
          (Term.app `NormedSpace.restrictScalars [(Data.Real.Basic.termℝ "ℝ") `𝕜 `E])]
         "with"]
        [(Term.structInstField
          (Term.structInstLVal `toNormedAddCommGroup [])
          ":="
          (Term.app `InnerProductSpace.toNormedAddCommGroup [`𝕜]))
         []
         (Term.structInstField (Term.structInstLVal `norm_sq_eq_inner []) ":=" `norm_sq_eq_inner)
         []
         (Term.structInstField
          (Term.structInstLVal `conj_sym [])
          ":="
          (Term.fun "fun" (Term.basicFun [`x `y] [] "=>" `inner_re_symm)))
         []
         (Term.structInstField
          (Term.structInstLVal `add_left [])
          ":="
          (Term.fun
           "fun"
           (Term.basicFun
            [`x `y `z]
            []
            "=>"
            (Term.byTactic
             "by"
             (Tactic.tacticSeq
              (Tactic.tacticSeq1Indented
               [(Tactic.change
                 "change"
                 («term_=_»
                  (Term.app
                   `re
                   [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     («term_+_» `x "+" `y)
                     ", "
                     `z
                     "⟫")])
                  "="
                  («term_+_»
                   (Term.app
                    `re
                    [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `z "⟫")])
                   "+"
                   (Term.app
                    `re
                    [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `z "⟫")])))
                 [])
                []
                (Tactic.simp
                 "simp"
                 []
                 []
                 ["only"]
                 ["["
                  [(Tactic.simpLemma [] [] `inner_add_left) "," (Tactic.simpLemma [] [] `map_add)]
                  "]"]
                 [])]))))))
         []
         (Term.structInstField
          (Term.structInstLVal `smul_left [])
          ":="
          (Term.fun
           "fun"
           (Term.basicFun
            [`x `y `r]
            []
            "=>"
            (Term.byTactic
             "by"
             (Tactic.tacticSeq
              (Tactic.tacticSeq1Indented
               [(Tactic.change
                 "change"
                 («term_=_»
                  (Term.app
                   `re
                   [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                     "⟪"
                     (Algebra.Group.Defs.«term_•_»
                      (Term.typeAscription "(" `r ":" [`𝕜] ")")
                      " • "
                      `x)
                     ", "
                     `y
                     "⟫")])
                  "="
                  («term_*_»
                   `r
                   "*"
                   (Term.app
                    `re
                    [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))
                 [])
                []
                (Tactic.simp
                 "simp"
                 []
                 []
                 ["only"]
                 ["["
                  [(Tactic.simpLemma [] [] `inner_smul_left)
                   ","
                   (Tactic.simpLemma [] [] `conj_of_real)
                   ","
                   (Tactic.simpLemma [] [] `of_real_mul_re)]
                  "]"]
                 [])]))))))]
        (Term.optEllipsis [])
        []
        "}")
       [])
      []
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.structInst
       "{"
       [[(Term.app `HasInner.isROrCToReal [`𝕜 `E])
         ","
         (Term.app `NormedSpace.restrictScalars [(Data.Real.Basic.termℝ "ℝ") `𝕜 `E])]
        "with"]
       [(Term.structInstField
         (Term.structInstLVal `toNormedAddCommGroup [])
         ":="
         (Term.app `InnerProductSpace.toNormedAddCommGroup [`𝕜]))
        []
        (Term.structInstField (Term.structInstLVal `norm_sq_eq_inner []) ":=" `norm_sq_eq_inner)
        []
        (Term.structInstField
         (Term.structInstLVal `conj_sym [])
         ":="
         (Term.fun "fun" (Term.basicFun [`x `y] [] "=>" `inner_re_symm)))
        []
        (Term.structInstField
         (Term.structInstLVal `add_left [])
         ":="
         (Term.fun
          "fun"
          (Term.basicFun
           [`x `y `z]
           []
           "=>"
           (Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.change
                "change"
                («term_=_»
                 (Term.app
                  `re
                  [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                    "⟪"
                    («term_+_» `x "+" `y)
                    ", "
                    `z
                    "⟫")])
                 "="
                 («term_+_»
                  (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `z "⟫")])
                  "+"
                  (Term.app
                   `re
                   [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `z "⟫")])))
                [])
               []
               (Tactic.simp
                "simp"
                []
                []
                ["only"]
                ["["
                 [(Tactic.simpLemma [] [] `inner_add_left) "," (Tactic.simpLemma [] [] `map_add)]
                 "]"]
                [])]))))))
        []
        (Term.structInstField
         (Term.structInstLVal `smul_left [])
         ":="
         (Term.fun
          "fun"
          (Term.basicFun
           [`x `y `r]
           []
           "=>"
           (Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.change
                "change"
                («term_=_»
                 (Term.app
                  `re
                  [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                    "⟪"
                    (Algebra.Group.Defs.«term_•_»
                     (Term.typeAscription "(" `r ":" [`𝕜] ")")
                     " • "
                     `x)
                    ", "
                    `y
                    "⟫")])
                 "="
                 («term_*_»
                  `r
                  "*"
                  (Term.app
                   `re
                   [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))
                [])
               []
               (Tactic.simp
                "simp"
                []
                []
                ["only"]
                ["["
                 [(Tactic.simpLemma [] [] `inner_smul_left)
                  ","
                  (Tactic.simpLemma [] [] `conj_of_real)
                  ","
                  (Tactic.simpLemma [] [] `of_real_mul_re)]
                 "]"]
                [])]))))))]
       (Term.optEllipsis [])
       []
       "}")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstField', expected 'Lean.Parser.Term.structInstFieldAbbrev'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun
       "fun"
       (Term.basicFun
        [`x `y `r]
        []
        "=>"
        (Term.byTactic
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(Tactic.change
             "change"
             («term_=_»
              (Term.app
               `re
               [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                 "⟪"
                 (Algebra.Group.Defs.«term_•_» (Term.typeAscription "(" `r ":" [`𝕜] ")") " • " `x)
                 ", "
                 `y
                 "⟫")])
              "="
              («term_*_»
               `r
               "*"
               (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))
             [])
            []
            (Tactic.simp
             "simp"
             []
             []
             ["only"]
             ["["
              [(Tactic.simpLemma [] [] `inner_smul_left)
               ","
               (Tactic.simpLemma [] [] `conj_of_real)
               ","
               (Tactic.simpLemma [] [] `of_real_mul_re)]
              "]"]
             [])])))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.change
           "change"
           («term_=_»
            (Term.app
             `re
             [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
               "⟪"
               (Algebra.Group.Defs.«term_•_» (Term.typeAscription "(" `r ":" [`𝕜] ")") " • " `x)
               ", "
               `y
               "⟫")])
            "="
            («term_*_»
             `r
             "*"
             (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))
           [])
          []
          (Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["["
            [(Tactic.simpLemma [] [] `inner_smul_left)
             ","
             (Tactic.simpLemma [] [] `conj_of_real)
             ","
             (Tactic.simpLemma [] [] `of_real_mul_re)]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] `inner_smul_left)
         ","
         (Tactic.simpLemma [] [] `conj_of_real)
         ","
         (Tactic.simpLemma [] [] `of_real_mul_re)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `of_real_mul_re
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `conj_of_real
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_smul_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.change
       "change"
       («term_=_»
        (Term.app
         `re
         [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           (Algebra.Group.Defs.«term_•_» (Term.typeAscription "(" `r ":" [`𝕜] ")") " • " `x)
           ", "
           `y
           "⟫")])
        "="
        («term_*_»
         `r
         "*"
         (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_»
       (Term.app
        `re
        [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
          "⟪"
          (Algebra.Group.Defs.«term_•_» (Term.typeAscription "(" `r ":" [`𝕜] ")") " • " `x)
          ", "
          `y
          "⟫")])
       "="
       («term_*_»
        `r
        "*"
        (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       `r
       "*"
       (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.matchAlts'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.theorem'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    A general inner product space structure implies a real inner product structure. This is not
    registered as an instance since it creates problems with the case `𝕜 = ℝ`, but in can be used in a
    proof to obtain a real inner product space structure from a given `𝕜`-inner product space
    structure. -/
  def
    InnerProductSpace.isROrCToReal
    : InnerProductSpace ℝ E
    :=
      {
        HasInner.isROrCToReal 𝕜 E , NormedSpace.restrictScalars ℝ 𝕜 E with
        toNormedAddCommGroup := InnerProductSpace.toNormedAddCommGroup 𝕜
          norm_sq_eq_inner := norm_sq_eq_inner
          conj_sym := fun x y => inner_re_symm
          add_left
            :=
            fun
              x y z
                =>
                by
                  change re ⟪ x + y , z ⟫ = re ⟪ x , z ⟫ + re ⟪ y , z ⟫
                    simp only [ inner_add_left , map_add ]
          smul_left
            :=
            fun
              x y r
                =>
                by
                  change re ⟪ ( r : 𝕜 ) • x , y ⟫ = r * re ⟪ x , y ⟫
                    simp only [ inner_smul_left , conj_of_real , of_real_mul_re ]
        }
#align inner_product_space.is_R_or_C_to_real InnerProductSpace.isROrCToReal

variable {E}

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `real_inner_eq_re_inner [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x `y] [":" `E] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.app
          (Term.explicit "@" `HasInner.inner)
          [(Data.Real.Basic.termℝ "ℝ") `E (Term.app `HasInner.isROrCToReal [`𝕜 `E]) `x `y])
         "="
         (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")]))))
      (Command.declValSimple ":=" `rfl [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `rfl
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Term.app
        (Term.explicit "@" `HasInner.inner)
        [(Data.Real.Basic.termℝ "ℝ") `E (Term.app `HasInner.isROrCToReal [`𝕜 `E]) `x `y])
       "="
       (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `re [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  real_inner_eq_re_inner
  ( x y : E ) : @ HasInner.inner ℝ E HasInner.isROrCToReal 𝕜 E x y = re ⟪ x , y ⟫
  := rfl
#align real_inner_eq_re_inner real_inner_eq_re_inner

theorem real_inner_I_smul_self (x : E) :
    @HasInner.inner ℝ E (HasInner.isROrCToReal 𝕜 E) x ((i : 𝕜) • x) = 0 := by
  simp [real_inner_eq_re_inner, inner_smul_right]
#align real_inner_I_smul_self real_inner_I_smul_self

omit 𝕜

/-- A complex inner product implies a real inner product -/
instance InnerProductSpace.complexToReal [InnerProductSpace ℂ G] : InnerProductSpace ℝ G :=
  InnerProductSpace.isROrCToReal ℂ G
#align inner_product_space.complex_to_real InnerProductSpace.complexToReal

@[simp]
protected theorem Complex.inner (w z : ℂ) : ⟪w, z⟫_ℝ = (conj w * z).re :=
  rfl
#align complex.inner Complex.inner

/-- The inner product on an inner product space of dimension 2 can be evaluated in terms
of a complex-number representation of the space. -/
theorem inner_map_complex [InnerProductSpace ℝ G] (f : G ≃ₗᵢ[ℝ] ℂ) (x y : G) :
    ⟪x, y⟫_ℝ = (conj (f x) * f y).re := by rw [← Complex.inner, f.inner_map_map]
#align inner_map_complex inner_map_complex

end IsROrCToReal

section Continuous

/-!
### Continuity of the inner product
-/


/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `continuous_inner [])
      (Command.declSig
       []
       (Term.typeSpec
        ":"
        (Term.app
         `Continuous
         [(Term.fun
           "fun"
           (Term.basicFun
            [`p]
            [(Term.typeSpec ":" («term_×_» `E "×" `E))]
            "=>"
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             (Term.proj `p "." (fieldIdx "1"))
             ", "
             (Term.proj `p "." (fieldIdx "2"))
             "⟫")))])))
      (Command.declValSimple
       ":="
       (Std.Tactic.letI
        "letI"
        (Term.haveDecl
         (Term.haveIdDecl
          []
          [(Term.typeSpec ":" (Term.app `InnerProductSpace [(Data.Real.Basic.termℝ "ℝ") `E]))]
          ":="
          (Term.app `InnerProductSpace.isROrCToReal [`𝕜 `E])))
        []
        `is_bounded_bilinear_map_inner.continuous)
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Std.Tactic.letI
       "letI"
       (Term.haveDecl
        (Term.haveIdDecl
         []
         [(Term.typeSpec ":" (Term.app `InnerProductSpace [(Data.Real.Basic.termℝ "ℝ") `E]))]
         ":="
         (Term.app `InnerProductSpace.isROrCToReal [`𝕜 `E])))
       []
       `is_bounded_bilinear_map_inner.continuous)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `is_bounded_bilinear_map_inner.continuous
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `InnerProductSpace.isROrCToReal [`𝕜 `E])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `E
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `𝕜
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `InnerProductSpace.isROrCToReal
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `InnerProductSpace [(Data.Real.Basic.termℝ "ℝ") `E])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `E
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Data.Real.Basic.termℝ', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Data.Real.Basic.termℝ', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Data.Real.Basic.termℝ "ℝ")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `InnerProductSpace
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      (Term.app
       `Continuous
       [(Term.fun
         "fun"
         (Term.basicFun
          [`p]
          [(Term.typeSpec ":" («term_×_» `E "×" `E))]
          "=>"
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           (Term.proj `p "." (fieldIdx "1"))
           ", "
           (Term.proj `p "." (fieldIdx "2"))
           "⟫")))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun
       "fun"
       (Term.basicFun
        [`p]
        [(Term.typeSpec ":" («term_×_» `E "×" `E))]
        "=>"
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
         "⟪"
         (Term.proj `p "." (fieldIdx "1"))
         ", "
         (Term.proj `p "." (fieldIdx "2"))
         "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
       "⟪"
       (Term.proj `p "." (fieldIdx "1"))
       ", "
       (Term.proj `p "." (fieldIdx "2"))
       "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.matchAlts'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  continuous_inner
  : Continuous fun p : E × E => ⟪ p . 1 , p . 2 ⟫
  :=
    letI
      : InnerProductSpace ℝ E := InnerProductSpace.isROrCToReal 𝕜 E
      is_bounded_bilinear_map_inner.continuous
#align continuous_inner continuous_inner

variable {α : Type _}

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `Filter.Tendsto.inner [])
      (Command.declSig
       [(Term.implicitBinder "{" [`f `g] [":" (Term.arrow `α "→" `E)] "}")
        (Term.implicitBinder "{" [`l] [":" (Term.app `Filter [`α])] "}")
        (Term.implicitBinder "{" [`x `y] [":" `E] "}")
        (Term.explicitBinder
         "("
         [`hf]
         [":"
          (Term.app `Tendsto [`f `l (Term.app (TopologicalSpace.Topology.Basic.nhds "𝓝") [`x])])]
         []
         ")")
        (Term.explicitBinder
         "("
         [`hg]
         [":"
          (Term.app `Tendsto [`g `l (Term.app (TopologicalSpace.Topology.Basic.nhds "𝓝") [`y])])]
         []
         ")")]
       (Term.typeSpec
        ":"
        (Term.app
         `Tendsto
         [(Term.fun
           "fun"
           (Term.basicFun
            [`t]
            []
            "=>"
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             (Term.app `f [`t])
             ", "
             (Term.app `g [`t])
             "⟫")))
          `l
          (Term.app
           (TopologicalSpace.Topology.Basic.nhds "𝓝")
           [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])])))
      (Command.declValSimple
       ":="
       (Term.app
        (Term.proj
         (Term.app (Term.proj `continuous_inner "." `Tendsto) [(Term.hole "_")])
         "."
         `comp)
        [(Term.app (Term.proj `hf "." `prod_mk_nhds) [`hg])])
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       (Term.proj (Term.app (Term.proj `continuous_inner "." `Tendsto) [(Term.hole "_")]) "." `comp)
       [(Term.app (Term.proj `hf "." `prod_mk_nhds) [`hg])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app (Term.proj `hf "." `prod_mk_nhds) [`hg])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hg
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.proj `hf "." `prod_mk_nhds)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `hf
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app (Term.proj `hf "." `prod_mk_nhds) [`hg])
     ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.proj (Term.app (Term.proj `continuous_inner "." `Tendsto) [(Term.hole "_")]) "." `comp)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.app (Term.proj `continuous_inner "." `Tendsto) [(Term.hole "_")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.proj `continuous_inner "." `Tendsto)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `continuous_inner
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app (Term.proj `continuous_inner "." `Tendsto) [(Term.hole "_")])
     ")")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      (Term.app
       `Tendsto
       [(Term.fun
         "fun"
         (Term.basicFun
          [`t]
          []
          "=>"
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           (Term.app `f [`t])
           ", "
           (Term.app `g [`t])
           "⟫")))
        `l
        (Term.app
         (TopologicalSpace.Topology.Basic.nhds "𝓝")
         [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       (TopologicalSpace.Topology.Basic.nhds "𝓝")
       [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `y "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  Filter.Tendsto.inner
  { f g : α → E } { l : Filter α } { x y : E } ( hf : Tendsto f l 𝓝 x ) ( hg : Tendsto g l 𝓝 y )
    : Tendsto fun t => ⟪ f t , g t ⟫ l 𝓝 ⟪ x , y ⟫
  := continuous_inner . Tendsto _ . comp hf . prod_mk_nhds hg
#align filter.tendsto.inner Filter.Tendsto.inner

variable [TopologicalSpace α] {f g : α → E} {x : α} {s : Set α}

include 𝕜

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `ContinuousWithinAt.inner [])
      (Command.declSig
       [(Term.explicitBinder "(" [`hf] [":" (Term.app `ContinuousWithinAt [`f `s `x])] [] ")")
        (Term.explicitBinder "(" [`hg] [":" (Term.app `ContinuousWithinAt [`g `s `x])] [] ")")]
       (Term.typeSpec
        ":"
        (Term.app
         `ContinuousWithinAt
         [(Term.fun
           "fun"
           (Term.basicFun
            [`t]
            []
            "=>"
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             (Term.app `f [`t])
             ", "
             (Term.app `g [`t])
             "⟫")))
          `s
          `x])))
      (Command.declValSimple ":=" (Term.app (Term.proj `hf "." `inner) [`hg]) [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app (Term.proj `hf "." `inner) [`hg])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hg
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.proj `hf "." `inner)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `hf
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      (Term.app
       `ContinuousWithinAt
       [(Term.fun
         "fun"
         (Term.basicFun
          [`t]
          []
          "=>"
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           (Term.app `f [`t])
           ", "
           (Term.app `g [`t])
           "⟫")))
        `s
        `x])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `s
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.fun
       "fun"
       (Term.basicFun
        [`t]
        []
        "=>"
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
         "⟪"
         (Term.app `f [`t])
         ", "
         (Term.app `g [`t])
         "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
       "⟪"
       (Term.app `f [`t])
       ", "
       (Term.app `g [`t])
       "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.matchAlts'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  ContinuousWithinAt.inner
  ( hf : ContinuousWithinAt f s x ) ( hg : ContinuousWithinAt g s x )
    : ContinuousWithinAt fun t => ⟪ f t , g t ⟫ s x
  := hf . inner hg
#align continuous_within_at.inner ContinuousWithinAt.inner

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `ContinuousAt.inner [])
      (Command.declSig
       [(Term.explicitBinder "(" [`hf] [":" (Term.app `ContinuousAt [`f `x])] [] ")")
        (Term.explicitBinder "(" [`hg] [":" (Term.app `ContinuousAt [`g `x])] [] ")")]
       (Term.typeSpec
        ":"
        (Term.app
         `ContinuousAt
         [(Term.fun
           "fun"
           (Term.basicFun
            [`t]
            []
            "=>"
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             (Term.app `f [`t])
             ", "
             (Term.app `g [`t])
             "⟫")))
          `x])))
      (Command.declValSimple ":=" (Term.app (Term.proj `hf "." `inner) [`hg]) [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app (Term.proj `hf "." `inner) [`hg])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hg
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.proj `hf "." `inner)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `hf
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      (Term.app
       `ContinuousAt
       [(Term.fun
         "fun"
         (Term.basicFun
          [`t]
          []
          "=>"
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           (Term.app `f [`t])
           ", "
           (Term.app `g [`t])
           "⟫")))
        `x])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.fun
       "fun"
       (Term.basicFun
        [`t]
        []
        "=>"
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
         "⟪"
         (Term.app `f [`t])
         ", "
         (Term.app `g [`t])
         "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
       "⟪"
       (Term.app `f [`t])
       ", "
       (Term.app `g [`t])
       "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.matchAlts'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  ContinuousAt.inner
  ( hf : ContinuousAt f x ) ( hg : ContinuousAt g x ) : ContinuousAt fun t => ⟪ f t , g t ⟫ x
  := hf . inner hg
#align continuous_at.inner ContinuousAt.inner

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `ContinuousOn.inner [])
      (Command.declSig
       [(Term.explicitBinder "(" [`hf] [":" (Term.app `ContinuousOn [`f `s])] [] ")")
        (Term.explicitBinder "(" [`hg] [":" (Term.app `ContinuousOn [`g `s])] [] ")")]
       (Term.typeSpec
        ":"
        (Term.app
         `ContinuousOn
         [(Term.fun
           "fun"
           (Term.basicFun
            [`t]
            []
            "=>"
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             (Term.app `f [`t])
             ", "
             (Term.app `g [`t])
             "⟫")))
          `s])))
      (Command.declValSimple
       ":="
       (Term.fun
        "fun"
        (Term.basicFun
         [`x `hx]
         []
         "=>"
         (Term.app (Term.proj (Term.app `hf [`x `hx]) "." `inner) [(Term.app `hg [`x `hx])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun
       "fun"
       (Term.basicFun
        [`x `hx]
        []
        "=>"
        (Term.app (Term.proj (Term.app `hf [`x `hx]) "." `inner) [(Term.app `hg [`x `hx])])))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app (Term.proj (Term.app `hf [`x `hx]) "." `inner) [(Term.app `hg [`x `hx])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `hg [`x `hx])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hx
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `hg
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `hg [`x `hx]) ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.proj (Term.app `hf [`x `hx]) "." `inner)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.app `hf [`x `hx])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hx
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `hf
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `hf [`x `hx]) ")")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hx
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      (Term.app
       `ContinuousOn
       [(Term.fun
         "fun"
         (Term.basicFun
          [`t]
          []
          "=>"
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           (Term.app `f [`t])
           ", "
           (Term.app `g [`t])
           "⟫")))
        `s])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `s
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.fun
       "fun"
       (Term.basicFun
        [`t]
        []
        "=>"
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
         "⟪"
         (Term.app `f [`t])
         ", "
         (Term.app `g [`t])
         "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
       "⟪"
       (Term.app `f [`t])
       ", "
       (Term.app `g [`t])
       "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.matchAlts'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  ContinuousOn.inner
  ( hf : ContinuousOn f s ) ( hg : ContinuousOn g s ) : ContinuousOn fun t => ⟪ f t , g t ⟫ s
  := fun x hx => hf x hx . inner hg x hx
#align continuous_on.inner ContinuousOn.inner

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      []
      [(Term.attributes
        "@["
        [(Term.attrInstance (Term.attrKind []) (Attr.simple `continuity []))]
        "]")]
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `Continuous.inner [])
      (Command.declSig
       [(Term.explicitBinder "(" [`hf] [":" (Term.app `Continuous [`f])] [] ")")
        (Term.explicitBinder "(" [`hg] [":" (Term.app `Continuous [`g])] [] ")")]
       (Term.typeSpec
        ":"
        (Term.app
         `Continuous
         [(Term.fun
           "fun"
           (Term.basicFun
            [`t]
            []
            "=>"
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             (Term.app `f [`t])
             ", "
             (Term.app `g [`t])
             "⟫")))])))
      (Command.declValSimple
       ":="
       (Term.app
        (Term.proj `continuous_iff_continuous_at "." (fieldIdx "2"))
        [(Term.fun
          "fun"
          (Term.basicFun
           [`x]
           []
           "=>"
           (Term.app
            (Term.proj (Term.proj `hf "." `ContinuousAt) "." `inner)
            [(Term.proj `hg "." `ContinuousAt)])))])
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       (Term.proj `continuous_iff_continuous_at "." (fieldIdx "2"))
       [(Term.fun
         "fun"
         (Term.basicFun
          [`x]
          []
          "=>"
          (Term.app
           (Term.proj (Term.proj `hf "." `ContinuousAt) "." `inner)
           [(Term.proj `hg "." `ContinuousAt)])))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun
       "fun"
       (Term.basicFun
        [`x]
        []
        "=>"
        (Term.app
         (Term.proj (Term.proj `hf "." `ContinuousAt) "." `inner)
         [(Term.proj `hg "." `ContinuousAt)])))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       (Term.proj (Term.proj `hf "." `ContinuousAt) "." `inner)
       [(Term.proj `hg "." `ContinuousAt)])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.proj `hg "." `ContinuousAt)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `hg
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.proj (Term.proj `hf "." `ContinuousAt) "." `inner)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.proj `hf "." `ContinuousAt)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `hf
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.proj `continuous_iff_continuous_at "." (fieldIdx "2"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `continuous_iff_continuous_at
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      (Term.app
       `Continuous
       [(Term.fun
         "fun"
         (Term.basicFun
          [`t]
          []
          "=>"
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
           "⟪"
           (Term.app `f [`t])
           ", "
           (Term.app `g [`t])
           "⟫")))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun
       "fun"
       (Term.basicFun
        [`t]
        []
        "=>"
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
         "⟪"
         (Term.app `f [`t])
         ", "
         (Term.app `g [`t])
         "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
       "⟪"
       (Term.app `f [`t])
       ", "
       (Term.app `g [`t])
       "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.matchAlts'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
@[ continuity ]
  theorem
    Continuous.inner
    ( hf : Continuous f ) ( hg : Continuous g ) : Continuous fun t => ⟪ f t , g t ⟫
    := continuous_iff_continuous_at . 2 fun x => hf . ContinuousAt . inner hg . ContinuousAt
#align continuous.inner Continuous.inner

end Continuous

section ReApplyInnerSelf

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "Extract a real bilinear form from an operator `T`, by taking the pairing `λ x, re ⟪T x, x⟫`. -/")]
      []
      []
      []
      []
      [])
     (Command.def
      "def"
      (Command.declId `ContinuousLinearMap.reApplyInnerSelf [])
      (Command.optDeclSig
       [(Term.explicitBinder
         "("
         [`T]
         [":" (Topology.Algebra.Module.Basic.«term_→L[_]_» `E " →L[" `𝕜 "] " `E)]
         []
         ")")
        (Term.explicitBinder "(" [`x] [":" `E] [] ")")]
       [(Term.typeSpec ":" (Data.Real.Basic.termℝ "ℝ"))])
      (Command.declValSimple
       ":="
       (Term.app
        `re
        [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `T [`x]) ", " `x "⟫")])
       [])
      []
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `re
       [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `T [`x]) ", " `x "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `T [`x]) ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.theorem'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- Extract a real bilinear form from an operator `T`, by taking the pairing `λ x, re ⟪T x, x⟫`. -/
  def ContinuousLinearMap.reApplyInnerSelf ( T : E →L[ 𝕜 ] E ) ( x : E ) : ℝ := re ⟪ T x , x ⟫
#align continuous_linear_map.re_apply_inner_self ContinuousLinearMap.reApplyInnerSelf

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `ContinuousLinearMap.re_apply_inner_self_apply [])
      (Command.declSig
       [(Term.explicitBinder
         "("
         [`T]
         [":" (Topology.Algebra.Module.Basic.«term_→L[_]_» `E " →L[" `𝕜 "] " `E)]
         []
         ")")
        (Term.explicitBinder "(" [`x] [":" `E] [] ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.app (Term.proj `T "." `reApplyInnerSelf) [`x])
         "="
         (Term.app
          `re
          [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `T [`x]) ", " `x "⟫")]))))
      (Command.declValSimple ":=" `rfl [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `rfl
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Term.app (Term.proj `T "." `reApplyInnerSelf) [`x])
       "="
       (Term.app
        `re
        [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `T [`x]) ", " `x "⟫")]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `re
       [(Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `T [`x]) ", " `x "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `T [`x]) ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  ContinuousLinearMap.re_apply_inner_self_apply
  ( T : E →L[ 𝕜 ] E ) ( x : E ) : T . reApplyInnerSelf x = re ⟪ T x , x ⟫
  := rfl
#align continuous_linear_map.re_apply_inner_self_apply ContinuousLinearMap.re_apply_inner_self_apply

theorem ContinuousLinearMap.re_apply_inner_self_continuous (T : E →L[𝕜] E) :
    Continuous T.reApplyInnerSelf :=
  reClm.Continuous.comp <| T.Continuous.inner continuous_id
#align
  continuous_linear_map.re_apply_inner_self_continuous ContinuousLinearMap.re_apply_inner_self_continuous

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `ContinuousLinearMap.re_apply_inner_self_smul [])
      (Command.declSig
       [(Term.explicitBinder
         "("
         [`T]
         [":" (Topology.Algebra.Module.Basic.«term_→L[_]_» `E " →L[" `𝕜 "] " `E)]
         []
         ")")
        (Term.explicitBinder "(" [`x] [":" `E] [] ")")
        (Term.implicitBinder "{" [`c] [":" `𝕜] "}")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Term.app
          (Term.proj `T "." `reApplyInnerSelf)
          [(Algebra.Group.Defs.«term_•_» `c " • " `x)])
         "="
         («term_*_»
          («term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `c "‖") "^" (num "2"))
          "*"
          (Term.app (Term.proj `T "." `reApplyInnerSelf) [`x])))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.simp
            "simp"
            []
            []
            ["only"]
            ["["
             [(Tactic.simpLemma [] [] `ContinuousLinearMap.map_smul)
              ","
              (Tactic.simpLemma [] [] `ContinuousLinearMap.re_apply_inner_self_apply)
              ","
              (Tactic.simpLemma [] [] `inner_smul_left)
              ","
              (Tactic.simpLemma [] [] `inner_smul_right)
              ","
              (Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `mul_assoc)
              ","
              (Tactic.simpLemma [] [] `mul_conj)
              ","
              (Tactic.simpLemma [] [] `norm_sq_eq_def')
              ","
              (Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `smul_re)
              ","
              (Tactic.simpLemma
               []
               []
               (Term.app
                `Algebra.smul_def
                [(«term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `c "‖") "^" (num "2"))
                 (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
                  "⟪"
                  (Term.app `T [`x])
                  ", "
                  `x
                  "⟫")]))
              ","
              (Tactic.simpLemma [] [] `algebra_map_eq_of_real)]
             "]"]
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["["
            [(Tactic.simpLemma [] [] `ContinuousLinearMap.map_smul)
             ","
             (Tactic.simpLemma [] [] `ContinuousLinearMap.re_apply_inner_self_apply)
             ","
             (Tactic.simpLemma [] [] `inner_smul_left)
             ","
             (Tactic.simpLemma [] [] `inner_smul_right)
             ","
             (Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `mul_assoc)
             ","
             (Tactic.simpLemma [] [] `mul_conj)
             ","
             (Tactic.simpLemma [] [] `norm_sq_eq_def')
             ","
             (Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `smul_re)
             ","
             (Tactic.simpLemma
              []
              []
              (Term.app
               `Algebra.smul_def
               [(«term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `c "‖") "^" (num "2"))
                (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `T [`x]) ", " `x "⟫")]))
             ","
             (Tactic.simpLemma [] [] `algebra_map_eq_of_real)]
            "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] `ContinuousLinearMap.map_smul)
         ","
         (Tactic.simpLemma [] [] `ContinuousLinearMap.re_apply_inner_self_apply)
         ","
         (Tactic.simpLemma [] [] `inner_smul_left)
         ","
         (Tactic.simpLemma [] [] `inner_smul_right)
         ","
         (Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `mul_assoc)
         ","
         (Tactic.simpLemma [] [] `mul_conj)
         ","
         (Tactic.simpLemma [] [] `norm_sq_eq_def')
         ","
         (Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `smul_re)
         ","
         (Tactic.simpLemma
          []
          []
          (Term.app
           `Algebra.smul_def
           [(«term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `c "‖") "^" (num "2"))
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `T [`x]) ", " `x "⟫")]))
         ","
         (Tactic.simpLemma [] [] `algebra_map_eq_of_real)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `algebra_map_eq_of_real
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `Algebra.smul_def
       [(«term_^_» (Analysis.Normed.Group.Basic.«term‖_‖» "‖" `c "‖") "^" (num "2"))
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `T [`x]) ", " `x "⟫")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" (Term.app `T [`x]) ", " `x "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  ContinuousLinearMap.re_apply_inner_self_smul
  ( T : E →L[ 𝕜 ] E ) ( x : E ) { c : 𝕜 }
    : T . reApplyInnerSelf c • x = ‖ c ‖ ^ 2 * T . reApplyInnerSelf x
  :=
    by
      simp
        only
        [
          ContinuousLinearMap.map_smul
            ,
            ContinuousLinearMap.re_apply_inner_self_apply
            ,
            inner_smul_left
            ,
            inner_smul_right
            ,
            ← mul_assoc
            ,
            mul_conj
            ,
            norm_sq_eq_def'
            ,
            ← smul_re
            ,
            Algebra.smul_def ‖ c ‖ ^ 2 ⟪ T x , x ⟫
            ,
            algebra_map_eq_of_real
          ]
#align continuous_linear_map.re_apply_inner_self_smul ContinuousLinearMap.re_apply_inner_self_smul

end ReApplyInnerSelf

/-! ### The orthogonal complement -/


section Orthogonal

variable (K : Submodule 𝕜 E)

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment "/--" "The subspace of vectors orthogonal to a given subspace. -/")]
      []
      []
      []
      []
      [])
     (Command.def
      "def"
      (Command.declId `Submodule.orthogonal [])
      (Command.optDeclSig [] [(Term.typeSpec ":" (Term.app `Submodule [`𝕜 `E]))])
      (Command.whereStructInst
       "where"
       [(Command.whereStructField
         (Term.letDecl
          (Term.letIdDecl
           `carrier
           []
           []
           ":="
           (Set.«term{_|_}»
            "{"
            (Std.ExtendedBinder.extBinder (Lean.binderIdent `v) [])
            "|"
            (Std.ExtendedBinder.«term∀__,_»
             "∀"
             (Lean.binderIdent `u)
             («binderTerm∈_» "∈" `K)
             ","
             («term_=_»
              (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `u ", " `v "⟫")
              "="
              (num "0")))
            "}"))))
        []
        (Command.whereStructField
         (Term.letDecl
          (Term.letIdDecl `zero_mem' [(Term.hole "_") (Term.hole "_")] [] ":=" `inner_zero_right)))
        []
        (Command.whereStructField
         (Term.letDecl
          (Term.letIdDecl
           `add_mem'
           [`x `y `hx `hy `u `hu]
           []
           ":="
           (Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.rwSeq
                "rw"
                []
                (Tactic.rwRuleSeq
                 "["
                 [(Tactic.rwRule [] `inner_add_right)
                  ","
                  (Tactic.rwRule [] (Term.app `hx [`u `hu]))
                  ","
                  (Tactic.rwRule [] (Term.app `hy [`u `hu]))
                  ","
                  (Tactic.rwRule [] `add_zero)]
                 "]")
                [])]))))))
        []
        (Command.whereStructField
         (Term.letDecl
          (Term.letIdDecl
           `smul_mem'
           [`c `x `hx `u `hu]
           []
           ":="
           (Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.rwSeq
                "rw"
                []
                (Tactic.rwRuleSeq
                 "["
                 [(Tactic.rwRule [] `inner_smul_right)
                  ","
                  (Tactic.rwRule [] (Term.app `hx [`u `hu]))
                  ","
                  (Tactic.rwRule [] `mul_zero)]
                 "]")
                [])]))))))]
       [])
      []
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.whereStructInst', expected 'Lean.Parser.Command.declValSimple'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.whereStructInst', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] `inner_smul_right)
             ","
             (Tactic.rwRule [] (Term.app `hx [`u `hu]))
             ","
             (Tactic.rwRule [] `mul_zero)]
            "]")
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [] `inner_smul_right)
         ","
         (Tactic.rwRule [] (Term.app `hx [`u `hu]))
         ","
         (Tactic.rwRule [] `mul_zero)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `mul_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `hx [`u `hu])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hu
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `u
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `hx
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_smul_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] `inner_add_right)
             ","
             (Tactic.rwRule [] (Term.app `hx [`u `hu]))
             ","
             (Tactic.rwRule [] (Term.app `hy [`u `hu]))
             ","
             (Tactic.rwRule [] `add_zero)]
            "]")
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [] `inner_add_right)
         ","
         (Tactic.rwRule [] (Term.app `hx [`u `hu]))
         ","
         (Tactic.rwRule [] (Term.app `hy [`u `hu]))
         ","
         (Tactic.rwRule [] `add_zero)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `add_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `hy [`u `hu])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hu
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `u
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `hy
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `hx [`u `hu])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hu
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `u
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `hx
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_add_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_zero_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'ident'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'ident'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Set.«term{_|_}»
       "{"
       (Std.ExtendedBinder.extBinder (Lean.binderIdent `v) [])
       "|"
       (Std.ExtendedBinder.«term∀__,_»
        "∀"
        (Lean.binderIdent `u)
        («binderTerm∈_» "∈" `K)
        ","
        («term_=_» (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `u ", " `v "⟫") "=" (num "0")))
       "}")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Std.ExtendedBinder.«term∀__,_»
       "∀"
       (Lean.binderIdent `u)
       («binderTerm∈_» "∈" `K)
       ","
       («term_=_» (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `u ", " `v "⟫") "=" (num "0")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_» (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `u ", " `v "⟫") "=" (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `u ", " `v "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.letIdDecl', expected 'Lean.Parser.Term.letPatDecl'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.letIdDecl', expected 'Lean.Parser.Term.letEqnsDecl'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.theorem'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- The subspace of vectors orthogonal to a given subspace. -/
  def
    Submodule.orthogonal
    : Submodule 𝕜 E
    where
      carrier := { v | ∀ u ∈ K , ⟪ u , v ⟫ = 0 }
        zero_mem' _ _ := inner_zero_right
        add_mem' x y hx hy u hu := by rw [ inner_add_right , hx u hu , hy u hu , add_zero ]
        smul_mem' c x hx u hu := by rw [ inner_smul_right , hx u hu , mul_zero ]
#align submodule.orthogonal Submodule.orthogonal

-- mathport name: «expr ᗮ»
notation:1200 K "ᗮ" => Submodule.orthogonal K

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment "/--" "When a vector is in `Kᗮ`. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `Submodule.mem_orthogonal [])
      (Command.declSig
       [(Term.explicitBinder "(" [`v] [":" `E] [] ")")]
       (Term.typeSpec
        ":"
        («term_↔_»
         («term_∈_» `v "∈" (Analysis.InnerProductSpace.Basic.«term_ᗮ» `K "ᗮ"))
         "↔"
         (Std.ExtendedBinder.«term∀__,_»
          "∀"
          (Lean.binderIdent `u)
          («binderTerm∈_» "∈" `K)
          ","
          («term_=_»
           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `u ", " `v "⟫")
           "="
           (num "0"))))))
      (Command.declValSimple ":=" `Iff.rfl [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Iff.rfl
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_↔_»
       («term_∈_» `v "∈" (Analysis.InnerProductSpace.Basic.«term_ᗮ» `K "ᗮ"))
       "↔"
       (Std.ExtendedBinder.«term∀__,_»
        "∀"
        (Lean.binderIdent `u)
        («binderTerm∈_» "∈" `K)
        ","
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `u ", " `v "⟫")
         "="
         (num "0"))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Std.ExtendedBinder.«term∀__,_»
       "∀"
       (Lean.binderIdent `u)
       («binderTerm∈_» "∈" `K)
       ","
       («term_=_» (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `u ", " `v "⟫") "=" (num "0")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_» (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `u ", " `v "⟫") "=" (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `u ", " `v "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- When a vector is in `Kᗮ`. -/
  theorem Submodule.mem_orthogonal ( v : E ) : v ∈ K ᗮ ↔ ∀ u ∈ K , ⟪ u , v ⟫ = 0 := Iff.rfl
#align submodule.mem_orthogonal Submodule.mem_orthogonal

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "When a vector is in `Kᗮ`, with the inner product the\nother way round. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `Submodule.mem_orthogonal' [])
      (Command.declSig
       [(Term.explicitBinder "(" [`v] [":" `E] [] ")")]
       (Term.typeSpec
        ":"
        («term_↔_»
         («term_∈_» `v "∈" (Analysis.InnerProductSpace.Basic.«term_ᗮ» `K "ᗮ"))
         "↔"
         (Std.ExtendedBinder.«term∀__,_»
          "∀"
          (Lean.binderIdent `u)
          («binderTerm∈_» "∈" `K)
          ","
          («term_=_»
           (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `u "⟫")
           "="
           (num "0"))))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Mathlib.Tactic.tacticSimp_rw__
            "simp_rw"
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [] `Submodule.mem_orthogonal)
              ","
              (Tactic.rwRule [] `inner_eq_zero_sym)]
             "]")
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Mathlib.Tactic.tacticSimp_rw__
           "simp_rw"
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] `Submodule.mem_orthogonal) "," (Tactic.rwRule [] `inner_eq_zero_sym)]
            "]")
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.tacticSimp_rw__
       "simp_rw"
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [] `Submodule.mem_orthogonal) "," (Tactic.rwRule [] `inner_eq_zero_sym)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_eq_zero_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Submodule.mem_orthogonal
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_↔_»
       («term_∈_» `v "∈" (Analysis.InnerProductSpace.Basic.«term_ᗮ» `K "ᗮ"))
       "↔"
       (Std.ExtendedBinder.«term∀__,_»
        "∀"
        (Lean.binderIdent `u)
        («binderTerm∈_» "∈" `K)
        ","
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `u "⟫")
         "="
         (num "0"))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Std.ExtendedBinder.«term∀__,_»
       "∀"
       (Lean.binderIdent `u)
       («binderTerm∈_» "∈" `K)
       ","
       («term_=_» (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `u "⟫") "=" (num "0")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_» (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `u "⟫") "=" (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `u "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    When a vector is in `Kᗮ`, with the inner product the
    other way round. -/
  theorem
    Submodule.mem_orthogonal'
    ( v : E ) : v ∈ K ᗮ ↔ ∀ u ∈ K , ⟪ v , u ⟫ = 0
    := by simp_rw [ Submodule.mem_orthogonal , inner_eq_zero_sym ]
#align submodule.mem_orthogonal' Submodule.mem_orthogonal'

variable {K}

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment "/--" "A vector in `K` is orthogonal to one in `Kᗮ`. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `Submodule.inner_right_of_mem_orthogonal [])
      (Command.declSig
       [(Term.implicitBinder "{" [`u `v] [":" `E] "}")
        (Term.explicitBinder "(" [`hu] [":" («term_∈_» `u "∈" `K)] [] ")")
        (Term.explicitBinder
         "("
         [`hv]
         [":" («term_∈_» `v "∈" (Analysis.InnerProductSpace.Basic.«term_ᗮ» `K "ᗮ"))]
         []
         ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `u ", " `v "⟫")
         "="
         (num "0"))))
      (Command.declValSimple
       ":="
       (Term.app
        (Term.proj (Term.app (Term.proj `K "." `mem_orthogonal) [`v]) "." (fieldIdx "1"))
        [`hv `u `hu])
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       (Term.proj (Term.app (Term.proj `K "." `mem_orthogonal) [`v]) "." (fieldIdx "1"))
       [`hv `u `hu])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hu
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `u
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `hv
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.proj (Term.app (Term.proj `K "." `mem_orthogonal) [`v]) "." (fieldIdx "1"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.app (Term.proj `K "." `mem_orthogonal) [`v])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `v
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.proj `K "." `mem_orthogonal)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `K
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app (Term.proj `K "." `mem_orthogonal) [`v])
     ")")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_» (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `u ", " `v "⟫") "=" (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `u ", " `v "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- A vector in `K` is orthogonal to one in `Kᗮ`. -/
  theorem
    Submodule.inner_right_of_mem_orthogonal
    { u v : E } ( hu : u ∈ K ) ( hv : v ∈ K ᗮ ) : ⟪ u , v ⟫ = 0
    := K . mem_orthogonal v . 1 hv u hu
#align submodule.inner_right_of_mem_orthogonal Submodule.inner_right_of_mem_orthogonal

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment "/--" "A vector in `Kᗮ` is orthogonal to one in `K`. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `Submodule.inner_left_of_mem_orthogonal [])
      (Command.declSig
       [(Term.implicitBinder "{" [`u `v] [":" `E] "}")
        (Term.explicitBinder "(" [`hu] [":" («term_∈_» `u "∈" `K)] [] ")")
        (Term.explicitBinder
         "("
         [`hv]
         [":" («term_∈_» `v "∈" (Analysis.InnerProductSpace.Basic.«term_ᗮ» `K "ᗮ"))]
         []
         ")")]
       (Term.typeSpec
        ":"
        («term_=_»
         (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `u "⟫")
         "="
         (num "0"))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.«tactic_<;>_»
            (Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_eq_zero_sym)] "]")
             [])
            "<;>"
            (Tactic.exact
             "exact"
             (Term.app `Submodule.inner_right_of_mem_orthogonal [`hu `hv])))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.«tactic_<;>_»
           (Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_eq_zero_sym)] "]")
            [])
           "<;>"
           (Tactic.exact "exact" (Term.app `Submodule.inner_right_of_mem_orthogonal [`hu `hv])))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.«tactic_<;>_»
       (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_eq_zero_sym)] "]") [])
       "<;>"
       (Tactic.exact "exact" (Term.app `Submodule.inner_right_of_mem_orthogonal [`hu `hv])))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact "exact" (Term.app `Submodule.inner_right_of_mem_orthogonal [`hu `hv]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `Submodule.inner_right_of_mem_orthogonal [`hu `hv])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hv
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `hu
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `Submodule.inner_right_of_mem_orthogonal
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 2 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1, tactic))
      (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `inner_eq_zero_sym)] "]") [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_eq_zero_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_» (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `u "⟫") "=" (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `u "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- A vector in `Kᗮ` is orthogonal to one in `K`. -/
  theorem
    Submodule.inner_left_of_mem_orthogonal
    { u v : E } ( hu : u ∈ K ) ( hv : v ∈ K ᗮ ) : ⟪ v , u ⟫ = 0
    := by rw [ inner_eq_zero_sym ] <;> exact Submodule.inner_right_of_mem_orthogonal hu hv
#align submodule.inner_left_of_mem_orthogonal Submodule.inner_left_of_mem_orthogonal

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment "/--" "A vector is in `(𝕜 ∙ u)ᗮ` iff it is orthogonal to `u`. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `Submodule.mem_orthogonal_singleton_iff_inner_right [])
      (Command.declSig
       [(Term.implicitBinder "{" [`u `v] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_↔_»
         («term_∈_»
          `v
          "∈"
          (Analysis.InnerProductSpace.Basic.«term_ᗮ»
           (Submodule.LinearAlgebra.Span.«term_∙_» `𝕜 " ∙ " `u)
           "ᗮ"))
         "↔"
         («term_=_»
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `u ", " `v "⟫")
          "="
          (num "0")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.refine'
            "refine'"
            (Term.anonymousCtor
             "⟨"
             [(Term.app
               `Submodule.inner_right_of_mem_orthogonal
               [(Term.app `Submodule.mem_span_singleton_self [`u])])
              ","
              (Term.hole "_")]
             "⟩"))
           []
           (Tactic.intro "intro" [`hv `w `hw])
           []
           (Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `Submodule.mem_span_singleton)] "]")
            [(Tactic.location "at" (Tactic.locationHyp [`hw] []))])
           []
           (Std.Tactic.obtain
            "obtain"
            [(Std.Tactic.RCases.rcasesPatMed
              [(Std.Tactic.RCases.rcasesPat.tuple
                "⟨"
                [(Std.Tactic.RCases.rcasesPatLo
                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `c)])
                  [])
                 ","
                 (Std.Tactic.RCases.rcasesPatLo
                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `rfl)])
                  [])]
                "⟩")])]
            []
            [":=" [`hw]])
           []
           (Tactic.simp
            "simp"
            []
            []
            []
            ["[" [(Tactic.simpLemma [] [] `inner_smul_left) "," (Tactic.simpLemma [] [] `hv)] "]"]
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.refine'
           "refine'"
           (Term.anonymousCtor
            "⟨"
            [(Term.app
              `Submodule.inner_right_of_mem_orthogonal
              [(Term.app `Submodule.mem_span_singleton_self [`u])])
             ","
             (Term.hole "_")]
            "⟩"))
          []
          (Tactic.intro "intro" [`hv `w `hw])
          []
          (Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `Submodule.mem_span_singleton)] "]")
           [(Tactic.location "at" (Tactic.locationHyp [`hw] []))])
          []
          (Std.Tactic.obtain
           "obtain"
           [(Std.Tactic.RCases.rcasesPatMed
             [(Std.Tactic.RCases.rcasesPat.tuple
               "⟨"
               [(Std.Tactic.RCases.rcasesPatLo
                 (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `c)])
                 [])
                ","
                (Std.Tactic.RCases.rcasesPatLo
                 (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `rfl)])
                 [])]
               "⟩")])]
           []
           [":=" [`hw]])
          []
          (Tactic.simp
           "simp"
           []
           []
           []
           ["[" [(Tactic.simpLemma [] [] `inner_smul_left) "," (Tactic.simpLemma [] [] `hv)] "]"]
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       []
       ["[" [(Tactic.simpLemma [] [] `inner_smul_left) "," (Tactic.simpLemma [] [] `hv)] "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hv
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_smul_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Std.Tactic.obtain
       "obtain"
       [(Std.Tactic.RCases.rcasesPatMed
         [(Std.Tactic.RCases.rcasesPat.tuple
           "⟨"
           [(Std.Tactic.RCases.rcasesPatLo
             (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `c)])
             [])
            ","
            (Std.Tactic.RCases.rcasesPatLo
             (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `rfl)])
             [])]
           "⟩")])]
       []
       [":=" [`hw]])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hw
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `Submodule.mem_span_singleton)] "]")
       [(Tactic.location "at" (Tactic.locationHyp [`hw] []))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.locationHyp', expected 'Lean.Parser.Tactic.locationWildcard'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hw
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Submodule.mem_span_singleton
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.intro "intro" [`hv `w `hw])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hw
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `w
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `hv
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.refine'
       "refine'"
       (Term.anonymousCtor
        "⟨"
        [(Term.app
          `Submodule.inner_right_of_mem_orthogonal
          [(Term.app `Submodule.mem_span_singleton_self [`u])])
         ","
         (Term.hole "_")]
        "⟩"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.anonymousCtor
       "⟨"
       [(Term.app
         `Submodule.inner_right_of_mem_orthogonal
         [(Term.app `Submodule.mem_span_singleton_self [`u])])
        ","
        (Term.hole "_")]
       "⟩")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `Submodule.inner_right_of_mem_orthogonal
       [(Term.app `Submodule.mem_span_singleton_self [`u])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `Submodule.mem_span_singleton_self [`u])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `u
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `Submodule.mem_span_singleton_self
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app `Submodule.mem_span_singleton_self [`u])
     ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `Submodule.inner_right_of_mem_orthogonal
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_↔_»
       («term_∈_»
        `v
        "∈"
        (Analysis.InnerProductSpace.Basic.«term_ᗮ»
         (Submodule.LinearAlgebra.Span.«term_∙_» `𝕜 " ∙ " `u)
         "ᗮ"))
       "↔"
       («term_=_» (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `u ", " `v "⟫") "=" (num "0")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_» (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `u ", " `v "⟫") "=" (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `u ", " `v "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- A vector is in `(𝕜 ∙ u)ᗮ` iff it is orthogonal to `u`. -/
  theorem
    Submodule.mem_orthogonal_singleton_iff_inner_right
    { u v : E } : v ∈ 𝕜 ∙ u ᗮ ↔ ⟪ u , v ⟫ = 0
    :=
      by
        refine' ⟨ Submodule.inner_right_of_mem_orthogonal Submodule.mem_span_singleton_self u , _ ⟩
          intro hv w hw
          rw [ Submodule.mem_span_singleton ] at hw
          obtain ⟨ c , rfl ⟩ := hw
          simp [ inner_smul_left , hv ]
#align
  submodule.mem_orthogonal_singleton_iff_inner_right Submodule.mem_orthogonal_singleton_iff_inner_right

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment "/--" "A vector in `(𝕜 ∙ u)ᗮ` is orthogonal to `u`. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `Submodule.mem_orthogonal_singleton_iff_inner_left [])
      (Command.declSig
       [(Term.implicitBinder "{" [`u `v] [":" `E] "}")]
       (Term.typeSpec
        ":"
        («term_↔_»
         («term_∈_»
          `v
          "∈"
          (Analysis.InnerProductSpace.Basic.«term_ᗮ»
           (Submodule.LinearAlgebra.Span.«term_∙_» `𝕜 " ∙ " `u)
           "ᗮ"))
         "↔"
         («term_=_»
          (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `u "⟫")
          "="
          (num "0")))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [] `Submodule.mem_orthogonal_singleton_iff_inner_right)
              ","
              (Tactic.rwRule [] `inner_eq_zero_sym)]
             "]")
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] `Submodule.mem_orthogonal_singleton_iff_inner_right)
             ","
             (Tactic.rwRule [] `inner_eq_zero_sym)]
            "]")
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [] `Submodule.mem_orthogonal_singleton_iff_inner_right)
         ","
         (Tactic.rwRule [] `inner_eq_zero_sym)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_eq_zero_sym
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Submodule.mem_orthogonal_singleton_iff_inner_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_↔_»
       («term_∈_»
        `v
        "∈"
        (Analysis.InnerProductSpace.Basic.«term_ᗮ»
         (Submodule.LinearAlgebra.Span.«term_∙_» `𝕜 " ∙ " `u)
         "ᗮ"))
       "↔"
       («term_=_» (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `u "⟫") "=" (num "0")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_» (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `u "⟫") "=" (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `v ", " `u "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- A vector in `(𝕜 ∙ u)ᗮ` is orthogonal to `u`. -/
  theorem
    Submodule.mem_orthogonal_singleton_iff_inner_left
    { u v : E } : v ∈ 𝕜 ∙ u ᗮ ↔ ⟪ v , u ⟫ = 0
    := by rw [ Submodule.mem_orthogonal_singleton_iff_inner_right , inner_eq_zero_sym ]
#align
  submodule.mem_orthogonal_singleton_iff_inner_left Submodule.mem_orthogonal_singleton_iff_inner_left

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `Submodule.sub_mem_orthogonal_of_inner_left [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `E] "}")
        (Term.explicitBinder
         "("
         [`h]
         [":"
          (Term.forall
           "∀"
           [`v]
           [(Term.typeSpec ":" `K)]
           ","
           («term_=_»
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `v "⟫")
            "="
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `v "⟫")))]
         []
         ")")]
       (Term.typeSpec
        ":"
        («term_∈_» («term_-_» `x "-" `y) "∈" (Analysis.InnerProductSpace.Basic.«term_ᗮ» `K "ᗮ"))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `Submodule.mem_orthogonal')] "]")
            [])
           []
           (Tactic.intro "intro" [`u `hu])
           []
           (Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [] `inner_sub_left) "," (Tactic.rwRule [] `sub_eq_zero)]
             "]")
            [])
           []
           (Tactic.exact "exact" (Term.app `h [(Term.anonymousCtor "⟨" [`u "," `hu] "⟩")]))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `Submodule.mem_orthogonal')] "]")
           [])
          []
          (Tactic.intro "intro" [`u `hu])
          []
          (Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] `inner_sub_left) "," (Tactic.rwRule [] `sub_eq_zero)]
            "]")
           [])
          []
          (Tactic.exact "exact" (Term.app `h [(Term.anonymousCtor "⟨" [`u "," `hu] "⟩")]))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact "exact" (Term.app `h [(Term.anonymousCtor "⟨" [`u "," `hu] "⟩")]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `h [(Term.anonymousCtor "⟨" [`u "," `hu] "⟩")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.anonymousCtor "⟨" [`u "," `hu] "⟩")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hu
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `u
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [] `inner_sub_left) "," (Tactic.rwRule [] `sub_eq_zero)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `sub_eq_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_sub_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.intro "intro" [`u `hu])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hu
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `u
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `Submodule.mem_orthogonal')] "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Submodule.mem_orthogonal'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_∈_» («term_-_» `x "-" `y) "∈" (Analysis.InnerProductSpace.Basic.«term_ᗮ» `K "ᗮ"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term_ᗮ» `K "ᗮ")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1200, term))
      `K
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1200, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1200, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      («term_-_» `x "-" `y)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 66 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 65, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 65 >? 1024, (none, [anonymous]) <=? (some 65, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 65, (some 66, term) <=? (some 50, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 50, (some 51,
     term) <=? (some 1023, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'ident'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.hole'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.forall
       "∀"
       [`v]
       [(Term.typeSpec ":" `K)]
       ","
       («term_=_»
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `v "⟫")
        "="
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `v "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `x ", " `v "⟫")
       "="
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `v "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫» "⟪" `y ", " `v "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  Submodule.sub_mem_orthogonal_of_inner_left
  { x y : E } ( h : ∀ v : K , ⟪ x , v ⟫ = ⟪ y , v ⟫ ) : x - y ∈ K ᗮ
  :=
    by
      rw [ Submodule.mem_orthogonal' ]
        intro u hu
        rw [ inner_sub_left , sub_eq_zero ]
        exact h ⟨ u , hu ⟩
#align submodule.sub_mem_orthogonal_of_inner_left Submodule.sub_mem_orthogonal_of_inner_left

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `Submodule.sub_mem_orthogonal_of_inner_right [])
      (Command.declSig
       [(Term.implicitBinder "{" [`x `y] [":" `E] "}")
        (Term.explicitBinder
         "("
         [`h]
         [":"
          (Term.forall
           "∀"
           [`v]
           [(Term.typeSpec ":" `K)]
           ","
           («term_=_»
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             (Term.typeAscription "(" `v ":" [`E] ")")
             ", "
             `x
             "⟫")
            "="
            (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
             "⟪"
             (Term.typeAscription "(" `v ":" [`E] ")")
             ", "
             `y
             "⟫")))]
         []
         ")")]
       (Term.typeSpec
        ":"
        («term_∈_» («term_-_» `x "-" `y) "∈" (Analysis.InnerProductSpace.Basic.«term_ᗮ» `K "ᗮ"))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.intro "intro" [`u `hu])
           []
           (Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [] `inner_sub_right) "," (Tactic.rwRule [] `sub_eq_zero)]
             "]")
            [])
           []
           (Tactic.exact "exact" (Term.app `h [(Term.anonymousCtor "⟨" [`u "," `hu] "⟩")]))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.intro "intro" [`u `hu])
          []
          (Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] `inner_sub_right) "," (Tactic.rwRule [] `sub_eq_zero)]
            "]")
           [])
          []
          (Tactic.exact "exact" (Term.app `h [(Term.anonymousCtor "⟨" [`u "," `hu] "⟩")]))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact "exact" (Term.app `h [(Term.anonymousCtor "⟨" [`u "," `hu] "⟩")]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `h [(Term.anonymousCtor "⟨" [`u "," `hu] "⟩")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.anonymousCtor "⟨" [`u "," `hu] "⟩")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hu
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `u
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [] `inner_sub_right) "," (Tactic.rwRule [] `sub_eq_zero)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `sub_eq_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `inner_sub_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.intro "intro" [`u `hu])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hu
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `u
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_∈_» («term_-_» `x "-" `y) "∈" (Analysis.InnerProductSpace.Basic.«term_ᗮ» `K "ᗮ"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term_ᗮ» `K "ᗮ")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1200, term))
      `K
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1200, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1200, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      («term_-_» `x "-" `y)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 66 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 65, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 65 >? 1024, (none, [anonymous]) <=? (some 65, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 65, (some 66, term) <=? (some 50, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 50, (some 51,
     term) <=? (some 1023, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'ident'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.hole'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.forall
       "∀"
       [`v]
       [(Term.typeSpec ":" `K)]
       ","
       («term_=_»
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
         "⟪"
         (Term.typeAscription "(" `v ":" [`E] ")")
         ", "
         `x
         "⟫")
        "="
        (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
         "⟪"
         (Term.typeAscription "(" `v ":" [`E] ")")
         ", "
         `y
         "⟫")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_=_»
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        (Term.typeAscription "(" `v ":" [`E] ")")
        ", "
        `x
        "⟫")
       "="
       (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
        "⟪"
        (Term.typeAscription "(" `v ":" [`E] ")")
        ", "
        `y
        "⟫"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»
       "⟪"
       (Term.typeAscription "(" `v ":" [`E] ")")
       ", "
       `y
       "⟫")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Analysis.InnerProductSpace.Basic.«term⟪_,_⟫»', expected 'Analysis.InnerProductSpace.Basic.term⟪_,_⟫._@.Analysis.InnerProductSpace.Basic._hyg.911'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicitBinder', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  Submodule.sub_mem_orthogonal_of_inner_right
  { x y : E } ( h : ∀ v : K , ⟪ ( v : E ) , x ⟫ = ⟪ ( v : E ) , y ⟫ ) : x - y ∈ K ᗮ
  := by intro u hu rw [ inner_sub_right , sub_eq_zero ] exact h ⟨ u , hu ⟩
#align submodule.sub_mem_orthogonal_of_inner_right Submodule.sub_mem_orthogonal_of_inner_right

variable (K)

/-- `K` and `Kᗮ` have trivial intersection. -/
theorem Submodule.inf_orthogonal_eq_bot : K ⊓ Kᗮ = ⊥ :=
  by
  rw [Submodule.eq_bot_iff]
  intro x
  rw [Submodule.mem_inf]
  exact fun ⟨hx, ho⟩ => inner_self_eq_zero.1 (ho x hx)
#align submodule.inf_orthogonal_eq_bot Submodule.inf_orthogonal_eq_bot

/-- `K` and `Kᗮ` have trivial intersection. -/
theorem Submodule.orthogonal_disjoint : Disjoint K Kᗮ := by
  simp [disjoint_iff, K.inf_orthogonal_eq_bot]
#align submodule.orthogonal_disjoint Submodule.orthogonal_disjoint

/-- `Kᗮ` can be characterized as the intersection of the kernels of the operations of
inner product with each of the elements of `K`. -/
theorem orthogonal_eq_inter : Kᗮ = ⨅ v : K, LinearMap.ker (innerSL (v : E) : E →L[𝕜] 𝕜) :=
  by
  apply le_antisymm
  · rw [le_infᵢ_iff]
    rintro ⟨v, hv⟩ w hw
    simpa using hw _ hv
  · intro v hv w hw
    simp only [Submodule.mem_infi] at hv
    exact hv ⟨w, hw⟩
#align orthogonal_eq_inter orthogonal_eq_inter

/-- The orthogonal complement of any submodule `K` is closed. -/
theorem Submodule.is_closed_orthogonal : IsClosed (Kᗮ : Set E) :=
  by
  rw [orthogonal_eq_inter K]
  have := fun v : K => ContinuousLinearMap.is_closed_ker (innerSL (v : E) : E →L[𝕜] 𝕜)
  convert is_closed_Inter this
  simp only [Submodule.infi_coe]
#align submodule.is_closed_orthogonal Submodule.is_closed_orthogonal

/-- In a complete space, the orthogonal complement of any submodule `K` is complete. -/
instance [CompleteSpace E] : CompleteSpace Kᗮ :=
  K.is_closed_orthogonal.complete_space_coe

variable (𝕜 E)

/-- `submodule.orthogonal` gives a `galois_connection` between
`submodule 𝕜 E` and its `order_dual`. -/
theorem Submodule.orthogonal_gc :
    @GaloisConnection (Submodule 𝕜 E) (Submodule 𝕜 E)ᵒᵈ _ _ Submodule.orthogonal
      Submodule.orthogonal :=
  fun K₁ K₂ =>
  ⟨fun h v hv u hu => Submodule.inner_left_of_mem_orthogonal hv (h hu), fun h v hv u hu =>
    Submodule.inner_left_of_mem_orthogonal hv (h hu)⟩
#align submodule.orthogonal_gc Submodule.orthogonal_gc

variable {𝕜 E}

/-- `submodule.orthogonal` reverses the `≤` ordering of two
subspaces. -/
theorem Submodule.orthogonal_le {K₁ K₂ : Submodule 𝕜 E} (h : K₁ ≤ K₂) : K₂ᗮ ≤ K₁ᗮ :=
  (Submodule.orthogonal_gc 𝕜 E).monotone_l h
#align submodule.orthogonal_le Submodule.orthogonal_le

/-- `submodule.orthogonal.orthogonal` preserves the `≤` ordering of two
subspaces. -/
theorem Submodule.orthogonal_orthogonal_monotone {K₁ K₂ : Submodule 𝕜 E} (h : K₁ ≤ K₂) :
    K₁ᗮᗮ ≤ K₂ᗮᗮ :=
  Submodule.orthogonal_le (Submodule.orthogonal_le h)
#align submodule.orthogonal_orthogonal_monotone Submodule.orthogonal_orthogonal_monotone

/-- `K` is contained in `Kᗮᗮ`. -/
theorem Submodule.le_orthogonal_orthogonal : K ≤ Kᗮᗮ :=
  (Submodule.orthogonal_gc 𝕜 E).le_u_l _
#align submodule.le_orthogonal_orthogonal Submodule.le_orthogonal_orthogonal

/-- The inf of two orthogonal subspaces equals the subspace orthogonal
to the sup. -/
theorem Submodule.inf_orthogonal (K₁ K₂ : Submodule 𝕜 E) : K₁ᗮ ⊓ K₂ᗮ = (K₁ ⊔ K₂)ᗮ :=
  (Submodule.orthogonal_gc 𝕜 E).l_sup.symm
#align submodule.inf_orthogonal Submodule.inf_orthogonal

/-- The inf of an indexed family of orthogonal subspaces equals the
subspace orthogonal to the sup. -/
theorem Submodule.infi_orthogonal {ι : Type _} (K : ι → Submodule 𝕜 E) :
    (⨅ i, (K i)ᗮ) = (supᵢ K)ᗮ :=
  (Submodule.orthogonal_gc 𝕜 E).l_supr.symm
#align submodule.infi_orthogonal Submodule.infi_orthogonal

/-- The inf of a set of orthogonal subspaces equals the subspace orthogonal to the sup. -/
theorem Submodule.Inf_orthogonal (s : Set <| Submodule 𝕜 E) : (⨅ K ∈ s, Kᗮ) = (supₛ s)ᗮ :=
  (Submodule.orthogonal_gc 𝕜 E).l_Sup.symm
#align submodule.Inf_orthogonal Submodule.Inf_orthogonal

@[simp]
theorem Submodule.top_orthogonal_eq_bot : (⊤ : Submodule 𝕜 E)ᗮ = ⊥ :=
  by
  ext
  rw [Submodule.mem_bot, Submodule.mem_orthogonal]
  exact
    ⟨fun h => inner_self_eq_zero.mp (h x Submodule.mem_top),
      by
      rintro rfl
      simp⟩
#align submodule.top_orthogonal_eq_bot Submodule.top_orthogonal_eq_bot

@[simp]
theorem Submodule.bot_orthogonal_eq_top : (⊥ : Submodule 𝕜 E)ᗮ = ⊤ :=
  by
  rw [← Submodule.top_orthogonal_eq_bot, eq_top_iff]
  exact Submodule.le_orthogonal_orthogonal ⊤
#align submodule.bot_orthogonal_eq_top Submodule.bot_orthogonal_eq_top

@[simp]
theorem Submodule.orthogonal_eq_top_iff : Kᗮ = ⊤ ↔ K = ⊥ :=
  by
  refine'
    ⟨_, by
      rintro rfl
      exact Submodule.bot_orthogonal_eq_top⟩
  intro h
  have : K ⊓ Kᗮ = ⊥ := K.orthogonal_disjoint.eq_bot
  rwa [h, inf_comm, top_inf_eq] at this
#align submodule.orthogonal_eq_top_iff Submodule.orthogonal_eq_top_iff

theorem Submodule.orthogonalFamilySelf :
    @OrthogonalFamily 𝕜 E _ _ _ (fun b => ((cond b K Kᗮ : Submodule 𝕜 E) : Type _)) _ fun b =>
      (cond b K Kᗮ).subtypeₗᵢ
  | tt, tt => absurd rfl
  | tt, ff => fun _ x y => Submodule.inner_right_of_mem_orthogonal x.Prop y.Prop
  | ff, tt => fun _ x y => Submodule.inner_left_of_mem_orthogonal y.Prop x.Prop
  | ff, ff => absurd rfl
#align submodule.orthogonal_family_self Submodule.orthogonalFamilySelf

end Orthogonal

namespace UniformSpace.Completion

open UniformSpace Function

instance {𝕜' E' : Type _} [TopologicalSpace 𝕜'] [UniformSpace E'] [HasInner 𝕜' E'] :
    HasInner 𝕜' (Completion E')
    where inner := curry <| (dense_inducing_coe.Prod dense_inducing_coe).extend (uncurry inner)

@[simp]
theorem inner_coe (a b : E) : inner (a : Completion E) (b : Completion E) = (inner a b : 𝕜) :=
  (dense_inducing_coe.Prod dense_inducing_coe).extend_eq
    (continuous_inner : Continuous (uncurry inner : E × E → 𝕜)) (a, b)
#align uniform_space.completion.inner_coe UniformSpace.Completion.inner_coe

protected theorem continuous_inner : Continuous (uncurry inner : Completion E × Completion E → 𝕜) :=
  by
  let inner' : E →+ E →+ 𝕜 :=
    { toFun := fun x => (innerₛₗ x).toAddMonoidHom
      map_zero' := by ext x <;> exact inner_zero_left
      map_add' := fun x y => by ext z <;> exact inner_add_left }
  have : Continuous fun p : E × E => inner' p.1 p.2 := continuous_inner
  rw [completion.has_inner, uncurry_curry _]
  change
    Continuous
      (((dense_inducing_to_compl E).Prod (dense_inducing_to_compl E)).extend fun p : E × E =>
        inner' p.1 p.2)
  exact (dense_inducing_to_compl E).extend_Z_bilin (dense_inducing_to_compl E) this
#align uniform_space.completion.continuous_inner UniformSpace.Completion.continuous_inner

protected theorem Continuous.inner {α : Type _} [TopologicalSpace α] {f g : α → Completion E}
    (hf : Continuous f) (hg : Continuous g) : Continuous (fun x : α => inner (f x) (g x) : α → 𝕜) :=
  UniformSpace.Completion.continuous_inner.comp (hf.prod_mk hg : _)
#align uniform_space.completion.continuous.inner UniformSpace.Completion.Continuous.inner

instance : InnerProductSpace 𝕜 (Completion E)
    where
  toNormedAddCommGroup := inferInstance
  norm_sq_eq_inner x :=
    Completion.induction_on x
      (is_closed_eq (continuous_norm.pow 2)
        (continuous_re.comp (Continuous.inner continuous_id' continuous_id')))
      fun a => by simp only [norm_coe, inner_coe, inner_self_eq_norm_sq]
  conj_sym x y :=
    Completion.induction_on₂ x y
      (is_closed_eq (continuous_conj.comp (Continuous.inner continuous_snd continuous_fst))
        (Continuous.inner continuous_fst continuous_snd))
      fun a b => by simp only [inner_coe, inner_conj_sym]
  add_left x y z :=
    Completion.induction_on₃ x y z
      (is_closed_eq
        (Continuous.inner (continuous_fst.add (continuous_fst.comp continuous_snd))
          (continuous_snd.comp continuous_snd))
        ((Continuous.inner continuous_fst (continuous_snd.comp continuous_snd)).add
          (Continuous.inner (continuous_fst.comp continuous_snd)
            (continuous_snd.comp continuous_snd))))
      fun a b c => by simp only [← coe_add, inner_coe, inner_add_left]
  smul_left x y c :=
    Completion.induction_on₂ x y
      (is_closed_eq (Continuous.inner (continuous_fst.const_smul c) continuous_snd)
        ((continuous_mul_left _).comp (Continuous.inner continuous_fst continuous_snd)))
      fun a b => by simp only [← coe_smul c a, inner_coe, inner_smul_left]

end UniformSpace.Completion

