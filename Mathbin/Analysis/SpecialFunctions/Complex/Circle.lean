/-
Copyright (c) 2021 Yury G. Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury G. Kudryashov

! This file was ported from Lean 3 source module analysis.special_functions.complex.circle
! leanprover-community/mathlib commit 4280f5f32e16755ec7985ce11e189b6cd6ff6735
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Analysis.Complex.Circle
import Mathbin.Analysis.SpecialFunctions.Complex.Log

/-!
# Maps on the unit circle

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file we prove some basic lemmas about `exp_map_circle` and the restriction of `complex.arg`
to the unit circle. These two maps define a local equivalence between `circle` and `ℝ`, see
`circle.arg_local_equiv` and `circle.arg_equiv`, that sends the whole circle to `(-π, π]`.
-/


open Complex Function Set

open Real

namespace circle

/- warning: circle.injective_arg -> circle.injective_arg is a dubious translation:
lean 3 declaration is
  Function.Injective.{1, 1} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) Real (fun (z : coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) => Complex.arg ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) Complex (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) Complex (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) Complex (coeBase.{1, 1} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) Complex (coeSubtype.{1} Complex (fun (x : Complex) => Membership.Mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) (SetLike.hasMem.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) x circle))))) z))
but is expected to have type
  Function.Injective.{1, 1} (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) Real (fun (z : Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) => Complex.arg (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (SetLike.coe.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) circle)) z))
Case conversion may be inaccurate. Consider using '#align circle.injective_arg circle.injective_argₓ'. -/
theorem injective_arg : Injective fun z : circle => arg z := fun z w h =>
  Subtype.ext <| ext_abs_arg ((abs_coe_circle z).trans (abs_coe_circle w).symm) h
#align circle.injective_arg circle.injective_arg

/- warning: circle.arg_eq_arg -> circle.arg_eq_arg is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align circle.arg_eq_arg circle.arg_eq_argₓ'. -/
@[simp]
theorem arg_eq_arg {z w : circle} : arg z = arg w ↔ z = w :=
  injective_arg.eq_iff
#align circle.arg_eq_arg circle.arg_eq_arg

end circle

/- warning: arg_exp_map_circle -> arg_expMapCircle is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align arg_exp_map_circle arg_expMapCircleₓ'. -/
theorem arg_expMapCircle {x : ℝ} (h₁ : -π < x) (h₂ : x ≤ π) : arg (expMapCircle x) = x := by
  rw [expMapCircle_apply, exp_mul_I, arg_cos_add_sin_mul_I ⟨h₁, h₂⟩]
#align arg_exp_map_circle arg_expMapCircle

/- warning: exp_map_circle_arg -> expMapCircle_arg is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align exp_map_circle_arg expMapCircle_argₓ'. -/
@[simp]
theorem expMapCircle_arg (z : circle) : expMapCircle (arg z) = z :=
  circle.injective_arg <| arg_expMapCircle (neg_pi_lt_arg _) (arg_le_pi _)
#align exp_map_circle_arg expMapCircle_arg

namespace circle

/- warning: circle.arg_local_equiv -> circle.argLocalEquiv is a dubious translation:
lean 3 declaration is
  LocalEquiv.{0, 0} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) Real
but is expected to have type
  LocalEquiv.{0, 0} (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) Real
Case conversion may be inaccurate. Consider using '#align circle.arg_local_equiv circle.argLocalEquivₓ'. -/
/-- `complex.arg ∘ coe` and `exp_map_circle` define a local equivalence between `circle and `ℝ` with
`source = set.univ` and `target = set.Ioc (-π) π`. -/
@[simps (config := { fullyApplied := false })]
noncomputable def argLocalEquiv : LocalEquiv circle ℝ
    where
  toFun := arg ∘ coe
  invFun := expMapCircle
  source := univ
  target := Ioc (-π) π
  map_source' z _ := ⟨neg_pi_lt_arg _, arg_le_pi _⟩
  map_target' := mapsTo_univ _ _
  left_inv' z _ := expMapCircle_arg z
  right_inv' x hx := arg_expMapCircle hx.1 hx.2
#align circle.arg_local_equiv circle.argLocalEquiv

/- warning: circle.arg_equiv -> circle.argEquiv is a dubious translation:
lean 3 declaration is
  Equiv.{1, 1} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) (Set.Ioc.{0} Real Real.preorder (Neg.neg.{0} Real Real.hasNeg Real.pi) Real.pi))
but is expected to have type
  Equiv.{1, 1} (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) (Set.Elem.{0} Real (Set.Ioc.{0} Real Real.instPreorderReal (Neg.neg.{0} Real Real.instNegReal Real.pi) Real.pi))
Case conversion may be inaccurate. Consider using '#align circle.arg_equiv circle.argEquivₓ'. -/
/-- `complex.arg` and `exp_map_circle` define an equivalence between `circle and `(-π, π]`. -/
@[simps (config := { fullyApplied := false })]
noncomputable def argEquiv : circle ≃ Ioc (-π) π
    where
  toFun z := ⟨arg z, neg_pi_lt_arg _, arg_le_pi _⟩
  invFun := expMapCircle ∘ coe
  left_inv z := argLocalEquiv.left_inv trivial
  right_inv x := Subtype.ext <| argLocalEquiv.right_inv x.2
#align circle.arg_equiv circle.argEquiv

end circle

/- warning: left_inverse_exp_map_circle_arg -> leftInverse_expMapCircle_arg is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align left_inverse_exp_map_circle_arg leftInverse_expMapCircle_argₓ'. -/
theorem leftInverse_expMapCircle_arg : LeftInverse expMapCircle (arg ∘ coe) :=
  expMapCircle_arg
#align left_inverse_exp_map_circle_arg leftInverse_expMapCircle_arg

/- warning: inv_on_arg_exp_map_circle -> invOn_arg_expMapCircle is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align inv_on_arg_exp_map_circle invOn_arg_expMapCircleₓ'. -/
theorem invOn_arg_expMapCircle : InvOn (arg ∘ coe) expMapCircle (Ioc (-π) π) univ :=
  circle.argLocalEquiv.symm.InvOn
#align inv_on_arg_exp_map_circle invOn_arg_expMapCircle

/- warning: surj_on_exp_map_circle_neg_pi_pi -> surjOn_expMapCircle_neg_pi_pi is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align surj_on_exp_map_circle_neg_pi_pi surjOn_expMapCircle_neg_pi_piₓ'. -/
theorem surjOn_expMapCircle_neg_pi_pi : SurjOn expMapCircle (Ioc (-π) π) univ :=
  circle.argLocalEquiv.symm.SurjOn
#align surj_on_exp_map_circle_neg_pi_pi surjOn_expMapCircle_neg_pi_pi

/- warning: exp_map_circle_eq_exp_map_circle -> expMapCircle_eq_expMapCircle is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align exp_map_circle_eq_exp_map_circle expMapCircle_eq_expMapCircleₓ'. -/
theorem expMapCircle_eq_expMapCircle {x y : ℝ} :
    expMapCircle x = expMapCircle y ↔ ∃ m : ℤ, x = y + m * (2 * π) :=
  by
  rw [Subtype.ext_iff, expMapCircle_apply, expMapCircle_apply, exp_eq_exp_iff_exists_int]
  refine' exists_congr fun n => _
  rw [← mul_assoc, ← add_mul, mul_left_inj' I_ne_zero, ← of_real_one, ← of_real_bit0, ← of_real_mul,
    ← of_real_int_cast, ← of_real_mul, ← of_real_add, of_real_inj]
#align exp_map_circle_eq_exp_map_circle expMapCircle_eq_expMapCircle

/- warning: periodic_exp_map_circle -> periodic_expMapCircle is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align periodic_exp_map_circle periodic_expMapCircleₓ'. -/
theorem periodic_expMapCircle : Periodic expMapCircle (2 * π) := fun z =>
  expMapCircle_eq_expMapCircle.2 ⟨1, by rw [Int.cast_one, one_mul]⟩
#align periodic_exp_map_circle periodic_expMapCircle

/- warning: exp_map_circle_two_pi -> expMapCircle_two_pi is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align exp_map_circle_two_pi expMapCircle_two_piₓ'. -/
@[simp]
theorem expMapCircle_two_pi : expMapCircle (2 * π) = 1 :=
  periodic_expMapCircle.Eq.trans expMapCircle_zero
#align exp_map_circle_two_pi expMapCircle_two_pi

/- warning: exp_map_circle_sub_two_pi -> expMapCircle_sub_two_pi is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align exp_map_circle_sub_two_pi expMapCircle_sub_two_piₓ'. -/
theorem expMapCircle_sub_two_pi (x : ℝ) : expMapCircle (x - 2 * π) = expMapCircle x :=
  periodic_expMapCircle.sub_eq x
#align exp_map_circle_sub_two_pi expMapCircle_sub_two_pi

/- warning: exp_map_circle_add_two_pi -> expMapCircle_add_two_pi is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align exp_map_circle_add_two_pi expMapCircle_add_two_piₓ'. -/
theorem expMapCircle_add_two_pi (x : ℝ) : expMapCircle (x + 2 * π) = expMapCircle x :=
  periodic_expMapCircle x
#align exp_map_circle_add_two_pi expMapCircle_add_two_pi

/- warning: real.angle.exp_map_circle -> Real.Angle.expMapCircle is a dubious translation:
lean 3 declaration is
  Real.Angle -> (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle)
but is expected to have type
  Real.Angle -> (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle))
Case conversion may be inaccurate. Consider using '#align real.angle.exp_map_circle Real.Angle.expMapCircleₓ'. -/
/-- `exp_map_circle`, applied to a `real.angle`. -/
noncomputable def Real.Angle.expMapCircle (θ : Real.Angle) : circle :=
  periodic_expMapCircle.lift θ
#align real.angle.exp_map_circle Real.Angle.expMapCircle

/- warning: real.angle.exp_map_circle_coe -> Real.Angle.expMapCircle_coe is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align real.angle.exp_map_circle_coe Real.Angle.expMapCircle_coeₓ'. -/
@[simp]
theorem Real.Angle.expMapCircle_coe (x : ℝ) : Real.Angle.expMapCircle x = expMapCircle x :=
  rfl
#align real.angle.exp_map_circle_coe Real.Angle.expMapCircle_coe

/- warning: real.angle.coe_exp_map_circle -> Real.Angle.coe_expMapCircle is a dubious translation:
lean 3 declaration is
  forall (θ : Real.Angle), Eq.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) Complex (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) Complex (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) Complex (coeBase.{1, 1} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) Complex (coeSubtype.{1} Complex (fun (x : Complex) => Membership.Mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) (SetLike.hasMem.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) x circle))))) (Real.Angle.expMapCircle θ)) (HAdd.hAdd.{0, 0, 0} Complex Complex Complex (instHAdd.{0} Complex Complex.hasAdd) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) (Real.Angle.cos θ)) (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.hasMul) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) (Real.Angle.sin θ)) Complex.I))
but is expected to have type
  forall (θ : Real.Angle), Eq.{1} Complex (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (SetLike.coe.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) circle)) (Real.Angle.expMapCircle θ)) (HAdd.hAdd.{0, 0, 0} Complex Complex Complex (instHAdd.{0} Complex Complex.instAddComplex) (Complex.ofReal' (Real.Angle.cos θ)) (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.instMulComplex) (Complex.ofReal' (Real.Angle.sin θ)) Complex.I))
Case conversion may be inaccurate. Consider using '#align real.angle.coe_exp_map_circle Real.Angle.coe_expMapCircleₓ'. -/
theorem Real.Angle.coe_expMapCircle (θ : Real.Angle) : (θ.expMapCircle : ℂ) = θ.cos + θ.sin * I :=
  by
  induction θ using Real.Angle.induction_on
  simp [Complex.exp_mul_I]
#align real.angle.coe_exp_map_circle Real.Angle.coe_expMapCircle

/- warning: real.angle.exp_map_circle_zero -> Real.Angle.expMapCircle_zero is a dubious translation:
lean 3 declaration is
  Eq.{1} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) (Real.Angle.expMapCircle (OfNat.ofNat.{0} Real.Angle 0 (OfNat.mk.{0} Real.Angle 0 (Zero.zero.{0} Real.Angle (AddZeroClass.toHasZero.{0} Real.Angle (AddMonoid.toAddZeroClass.{0} Real.Angle (SubNegMonoid.toAddMonoid.{0} Real.Angle (AddGroup.toSubNegMonoid.{0} Real.Angle (NormedAddGroup.toAddGroup.{0} Real.Angle (NormedAddCommGroup.toNormedAddGroup.{0} Real.Angle Real.Angle.normedAddCommGroup)))))))))) (OfNat.ofNat.{0} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) 1 (OfNat.mk.{0} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) 1 (One.one.{0} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) (Submonoid.one.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))) circle))))
but is expected to have type
  Eq.{1} (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) (Real.Angle.expMapCircle (OfNat.ofNat.{0} Real.Angle 0 (Zero.toOfNat0.{0} Real.Angle (NegZeroClass.toZero.{0} Real.Angle (SubNegZeroMonoid.toNegZeroClass.{0} Real.Angle (SubtractionMonoid.toSubNegZeroMonoid.{0} Real.Angle (SubtractionCommMonoid.toSubtractionMonoid.{0} Real.Angle (AddCommGroup.toDivisionAddCommMonoid.{0} Real.Angle (NormedAddCommGroup.toAddCommGroup.{0} Real.Angle Real.Angle.instNormedAddCommGroupAngle))))))))) (OfNat.ofNat.{0} (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) 1 (One.toOfNat1.{0} (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) (Submonoid.one.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))) circle)))
Case conversion may be inaccurate. Consider using '#align real.angle.exp_map_circle_zero Real.Angle.expMapCircle_zeroₓ'. -/
@[simp]
theorem Real.Angle.expMapCircle_zero : Real.Angle.expMapCircle 0 = 1 := by
  rw [← Real.Angle.coe_zero, Real.Angle.expMapCircle_coe, expMapCircle_zero]
#align real.angle.exp_map_circle_zero Real.Angle.expMapCircle_zero

/- warning: real.angle.exp_map_circle_neg -> Real.Angle.expMapCircle_neg is a dubious translation:
lean 3 declaration is
  forall (θ : Real.Angle), Eq.{1} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) (Real.Angle.expMapCircle (Neg.neg.{0} Real.Angle (SubNegMonoid.toHasNeg.{0} Real.Angle (AddGroup.toSubNegMonoid.{0} Real.Angle (NormedAddGroup.toAddGroup.{0} Real.Angle (NormedAddCommGroup.toNormedAddGroup.{0} Real.Angle Real.Angle.normedAddCommGroup)))) θ)) (Inv.inv.{0} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) (DivInvMonoid.toHasInv.{0} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) (Group.toDivInvMonoid.{0} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) (CommGroup.toGroup.{0} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) circle.commGroup))) (Real.Angle.expMapCircle θ))
but is expected to have type
  forall (θ : Real.Angle), Eq.{1} (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) (Real.Angle.expMapCircle (Neg.neg.{0} Real.Angle (NegZeroClass.toNeg.{0} Real.Angle (SubNegZeroMonoid.toNegZeroClass.{0} Real.Angle (SubtractionMonoid.toSubNegZeroMonoid.{0} Real.Angle (SubtractionCommMonoid.toSubtractionMonoid.{0} Real.Angle (AddCommGroup.toDivisionAddCommMonoid.{0} Real.Angle (NormedAddCommGroup.toAddCommGroup.{0} Real.Angle Real.Angle.instNormedAddCommGroupAngle)))))) θ)) (Inv.inv.{0} (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) (InvOneClass.toInv.{0} (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) (DivInvOneMonoid.toInvOneClass.{0} (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) (DivisionMonoid.toDivInvOneMonoid.{0} (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) (DivisionCommMonoid.toDivisionMonoid.{0} (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) (CommGroup.toDivisionCommMonoid.{0} (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) commGroup))))) (Real.Angle.expMapCircle θ))
Case conversion may be inaccurate. Consider using '#align real.angle.exp_map_circle_neg Real.Angle.expMapCircle_negₓ'. -/
@[simp]
theorem Real.Angle.expMapCircle_neg (θ : Real.Angle) :
    Real.Angle.expMapCircle (-θ) = (Real.Angle.expMapCircle θ)⁻¹ :=
  by
  induction θ using Real.Angle.induction_on
  simp_rw [← Real.Angle.coe_neg, Real.Angle.expMapCircle_coe, expMapCircle_neg]
#align real.angle.exp_map_circle_neg Real.Angle.expMapCircle_neg

/- warning: real.angle.exp_map_circle_add -> Real.Angle.expMapCircle_add is a dubious translation:
lean 3 declaration is
  forall (θ₁ : Real.Angle) (θ₂ : Real.Angle), Eq.{1} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) (Real.Angle.expMapCircle (HAdd.hAdd.{0, 0, 0} Real.Angle Real.Angle Real.Angle (instHAdd.{0} Real.Angle (AddZeroClass.toHasAdd.{0} Real.Angle (AddMonoid.toAddZeroClass.{0} Real.Angle (SubNegMonoid.toAddMonoid.{0} Real.Angle (AddGroup.toSubNegMonoid.{0} Real.Angle (NormedAddGroup.toAddGroup.{0} Real.Angle (NormedAddCommGroup.toNormedAddGroup.{0} Real.Angle Real.Angle.normedAddCommGroup))))))) θ₁ θ₂)) (HMul.hMul.{0, 0, 0} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) (instHMul.{0} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) (Submonoid.mul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))) circle)) (Real.Angle.expMapCircle θ₁) (Real.Angle.expMapCircle θ₂))
but is expected to have type
  forall (θ₁ : Real.Angle) (θ₂ : Real.Angle), Eq.{1} (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) (Real.Angle.expMapCircle (HAdd.hAdd.{0, 0, 0} Real.Angle Real.Angle Real.Angle (instHAdd.{0} Real.Angle (AddZeroClass.toAdd.{0} Real.Angle (AddMonoid.toAddZeroClass.{0} Real.Angle (SubNegMonoid.toAddMonoid.{0} Real.Angle (AddGroup.toSubNegMonoid.{0} Real.Angle (NormedAddGroup.toAddGroup.{0} Real.Angle (NormedAddCommGroup.toNormedAddGroup.{0} Real.Angle Real.Angle.instNormedAddCommGroupAngle))))))) θ₁ θ₂)) (HMul.hMul.{0, 0, 0} (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) (instHMul.{0} (Subtype.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) (SetLike.instMembership.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))))) x circle)) (Submonoid.mul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex))) circle)) (Real.Angle.expMapCircle θ₁) (Real.Angle.expMapCircle θ₂))
Case conversion may be inaccurate. Consider using '#align real.angle.exp_map_circle_add Real.Angle.expMapCircle_addₓ'. -/
@[simp]
theorem Real.Angle.expMapCircle_add (θ₁ θ₂ : Real.Angle) :
    Real.Angle.expMapCircle (θ₁ + θ₂) = Real.Angle.expMapCircle θ₁ * Real.Angle.expMapCircle θ₂ :=
  by
  induction θ₁ using Real.Angle.induction_on
  induction θ₂ using Real.Angle.induction_on
  exact expMapCircle_add θ₁ θ₂
#align real.angle.exp_map_circle_add Real.Angle.expMapCircle_add

/- warning: real.angle.arg_exp_map_circle -> Real.Angle.arg_expMapCircle is a dubious translation:
lean 3 declaration is
  forall (θ : Real.Angle), Eq.{1} Real.Angle ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Real.Angle (HasLiftT.mk.{1, 1} Real Real.Angle (CoeTCₓ.coe.{1, 1} Real Real.Angle Real.Angle.hasCoeT)) (Complex.arg ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) Complex (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) Complex (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) Complex (coeBase.{1, 1} (coeSort.{1, 2} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Type (SetLike.hasCoeToSort.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) circle) Complex (coeSubtype.{1} Complex (fun (x : Complex) => Membership.Mem.{0, 0} Complex (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) (SetLike.hasMem.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))))) Complex (Submonoid.setLike.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring)))))) x circle))))) (Real.Angle.expMapCircle θ)))) θ
but is expected to have type
  forall (θ : Real.Angle), Eq.{1} Real.Angle (Real.Angle.coe (Complex.arg (Subtype.val.{1} Complex (fun (x : Complex) => Membership.mem.{0, 0} Complex (Set.{0} Complex) (Set.instMembershipSet.{0} Complex) x (SetLike.coe.{0, 0} (Submonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) Complex (Submonoid.instSetLikeSubmonoid.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex Complex.instSemiringComplex)))) circle)) (Real.Angle.expMapCircle θ)))) θ
Case conversion may be inaccurate. Consider using '#align real.angle.arg_exp_map_circle Real.Angle.arg_expMapCircleₓ'. -/
@[simp]
theorem Real.Angle.arg_expMapCircle (θ : Real.Angle) :
    (arg (Real.Angle.expMapCircle θ) : Real.Angle) = θ :=
  by
  induction θ using Real.Angle.induction_on
  rw [Real.Angle.expMapCircle_coe, expMapCircle_apply, exp_mul_I, ← of_real_cos, ← of_real_sin, ←
    Real.Angle.cos_coe, ← Real.Angle.sin_coe, arg_cos_add_sin_mul_I_coe_angle]
#align real.angle.arg_exp_map_circle Real.Angle.arg_expMapCircle

