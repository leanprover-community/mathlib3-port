import Mathbin.Analysis.Complex.Basic 
import Mathbin.Data.Complex.Exponential

/-!
# Complex and real exponential

In this file we prove continuity of `complex.exp` and `real.exp`. We also prove a few facts about
limits of `real.exp` at infinity.

## Tags

exp
-/


noncomputable theory

open Finset Filter Metric Asymptotics Set Function

open_locale Classical TopologicalSpace

namespace Complex

variable{z y x : ‚Ñù}

theorem exp_bound_sq (x z : ‚ÑÇ) (hz : ‚à•z‚à• ‚â§ 1) : ‚à•exp (x+z) - exp x - z ‚Ä¢ exp x‚à• ‚â§ ‚à•exp x‚à•*‚à•z‚à•^2 :=
  calc ‚à•exp (x+z) - exp x - z*exp x‚à• = ‚à•exp x*exp z - 1 - z‚à• :=
    by 
      congr 
      rw [exp_add]
      ring 
    _ = ‚à•exp x‚à•*‚à•exp z - 1 - z‚à• := NormedField.norm_mul _ _ 
    _ ‚â§ ‚à•exp x‚à•*‚à•z‚à•^2 := mul_le_mul_of_nonneg_left (abs_exp_sub_one_sub_id_le hz) (norm_nonneg _)
    

-- error in Analysis.SpecialFunctions.Exp: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem locally_lipschitz_exp
{r : expr‚Ñù()}
(hr_nonneg : ¬´expr ‚â§ ¬ª(0, r))
(hr_le : ¬´expr ‚â§ ¬ª(r, 1))
(x y : expr‚ÑÇ())
(hyx : ¬´expr < ¬ª(¬´expr‚à• ‚à•¬ª(¬´expr - ¬ª(y, x)), r)) : ¬´expr ‚â§ ¬ª(¬´expr‚à• ‚à•¬ª(¬´expr - ¬ª(exp y, exp x)), ¬´expr * ¬ª(¬´expr * ¬ª(¬´expr + ¬ª(1, r), ¬´expr‚à• ‚à•¬ª(exp x)), ¬´expr‚à• ‚à•¬ª(¬´expr - ¬ª(y, x)))) :=
begin
  have [ident hy_eq] [":", expr ¬´expr = ¬ª(y, ¬´expr + ¬ª(x, ¬´expr - ¬ª(y, x)))] [],
  by abel [] [] [],
  have [ident hyx_sq_le] [":", expr ¬´expr ‚â§ ¬ª(¬´expr ^ ¬ª(¬´expr‚à• ‚à•¬ª(¬´expr - ¬ª(y, x)), 2), ¬´expr * ¬ª(r, ¬´expr‚à• ‚à•¬ª(¬´expr - ¬ª(y, x))))] [],
  { rw [expr pow_two] [],
    exact [expr mul_le_mul hyx.le le_rfl (norm_nonneg _) hr_nonneg] },
  have [ident h_sq] [":", expr ‚àÄ
   z, ¬´expr ‚â§ ¬ª(¬´expr‚à• ‚à•¬ª(z), 1) ‚Üí ¬´expr ‚â§ ¬ª(¬´expr‚à• ‚à•¬ª(¬´expr - ¬ª(exp ¬´expr + ¬ª(x, z), exp x)), ¬´expr + ¬ª(¬´expr * ¬ª(¬´expr‚à• ‚à•¬ª(z), ¬´expr‚à• ‚à•¬ª(exp x)), ¬´expr * ¬ª(¬´expr‚à• ‚à•¬ª(exp x), ¬´expr ^ ¬ª(¬´expr‚à• ‚à•¬ª(z), 2))))] [],
  { intros [ident z, ident hz],
    have [] [":", expr ¬´expr ‚â§ ¬ª(¬´expr‚à• ‚à•¬ª(¬´expr - ¬ª(¬´expr - ¬ª(exp ¬´expr + ¬ª(x, z), exp x), ¬´expr ‚Ä¢ ¬ª(z, exp x))), ¬´expr * ¬ª(¬´expr‚à• ‚à•¬ª(exp x), ¬´expr ^ ¬ª(¬´expr‚à• ‚à•¬ª(z), 2)))] [],
    from [expr exp_bound_sq x z hz],
    rw ["[", "<-", expr sub_le_iff_le_add', ",", "<-", expr norm_smul z, "]"] [],
    exact [expr (norm_sub_norm_le _ _).trans this] },
  calc
    ¬´expr = ¬ª(¬´expr‚à• ‚à•¬ª(¬´expr - ¬ª(exp y, exp x)), ¬´expr‚à• ‚à•¬ª(¬´expr - ¬ª(exp ¬´expr + ¬ª(x, ¬´expr - ¬ª(y, x)), exp x))) : by nth_rewrite [0] [expr hy_eq] []
    ¬´expr ‚â§ ¬ª(..., ¬´expr + ¬ª(¬´expr * ¬ª(¬´expr‚à• ‚à•¬ª(¬´expr - ¬ª(y, x)), ¬´expr‚à• ‚à•¬ª(exp x)), ¬´expr * ¬ª(¬´expr‚à• ‚à•¬ª(exp x), ¬´expr ^ ¬ª(¬´expr‚à• ‚à•¬ª(¬´expr - ¬ª(y, x)), 2)))) : h_sq ¬´expr - ¬ª(y, x) (hyx.le.trans hr_le)
    ¬´expr ‚â§ ¬ª(..., ¬´expr + ¬ª(¬´expr * ¬ª(¬´expr‚à• ‚à•¬ª(¬´expr - ¬ª(y, x)), ¬´expr‚à• ‚à•¬ª(exp x)), ¬´expr * ¬ª(¬´expr‚à• ‚à•¬ª(exp x), ¬´expr * ¬ª(r, ¬´expr‚à• ‚à•¬ª(¬´expr - ¬ª(y, x)))))) : add_le_add_left (mul_le_mul le_rfl hyx_sq_le (sq_nonneg _) (norm_nonneg _)) _
    ¬´expr = ¬ª(..., ¬´expr * ¬ª(¬´expr * ¬ª(¬´expr + ¬ª(1, r), ¬´expr‚à• ‚à•¬ª(exp x)), ¬´expr‚à• ‚à•¬ª(¬´expr - ¬ª(y, x)))) : by ring []
end

@[continuity]
theorem continuous_exp : Continuous exp :=
  continuous_iff_continuous_at.mpr$
    fun x => continuous_at_of_locally_lipschitz zero_lt_one (2*‚à•exp x‚à•) (locally_lipschitz_exp zero_le_one le_rfl x)

theorem continuous_on_exp {s : Set ‚ÑÇ} : ContinuousOn exp s :=
  continuous_exp.ContinuousOn

end Complex

section ComplexContinuousExpComp

variable{Œ± : Type _}

open Complex

theorem Filter.Tendsto.cexp {l : Filter Œ±} {f : Œ± ‚Üí ‚ÑÇ} {z : ‚ÑÇ} (hf : tendsto f l (ùìù z)) :
  tendsto (fun x => exp (f x)) l (ùìù (exp z)) :=
  (continuous_exp.Tendsto _).comp hf

variable[TopologicalSpace Œ±]{f : Œ± ‚Üí ‚ÑÇ}{s : Set Œ±}{x : Œ±}

theorem ContinuousWithinAt.cexp (h : ContinuousWithinAt f s x) : ContinuousWithinAt (fun y => exp (f y)) s x :=
  h.cexp

theorem ContinuousAt.cexp (h : ContinuousAt f x) : ContinuousAt (fun y => exp (f y)) x :=
  h.cexp

theorem ContinuousOn.cexp (h : ContinuousOn f s) : ContinuousOn (fun y => exp (f y)) s :=
  fun x hx => (h x hx).cexp

theorem Continuous.cexp (h : Continuous f) : Continuous fun y => exp (f y) :=
  continuous_iff_continuous_at.2$ fun x => h.continuous_at.cexp

end ComplexContinuousExpComp

namespace Real

@[continuity]
theorem continuous_exp : Continuous exp :=
  Complex.continuous_re.comp Complex.continuous_of_real.cexp

theorem continuous_on_exp {s : Set ‚Ñù} : ContinuousOn exp s :=
  continuous_exp.ContinuousOn

end Real

section RealContinuousExpComp

variable{Œ± : Type _}

open Real

theorem Filter.Tendsto.exp {l : Filter Œ±} {f : Œ± ‚Üí ‚Ñù} {z : ‚Ñù} (hf : tendsto f l (ùìù z)) :
  tendsto (fun x => exp (f x)) l (ùìù (exp z)) :=
  (continuous_exp.Tendsto _).comp hf

variable[TopologicalSpace Œ±]{f : Œ± ‚Üí ‚Ñù}{s : Set Œ±}{x : Œ±}

theorem ContinuousWithinAt.exp (h : ContinuousWithinAt f s x) : ContinuousWithinAt (fun y => exp (f y)) s x :=
  h.exp

theorem ContinuousAt.exp (h : ContinuousAt f x) : ContinuousAt (fun y => exp (f y)) x :=
  h.exp

theorem ContinuousOn.exp (h : ContinuousOn f s) : ContinuousOn (fun y => exp (f y)) s :=
  fun x hx => (h x hx).exp

theorem Continuous.exp (h : Continuous f) : Continuous fun y => exp (f y) :=
  continuous_iff_continuous_at.2$ fun x => h.continuous_at.exp

end RealContinuousExpComp

namespace Real

variable{x y z : ‚Ñù}

-- error in Analysis.SpecialFunctions.Exp: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The real exponential function tends to `+‚àû` at `+‚àû`. -/ theorem tendsto_exp_at_top : tendsto exp at_top at_top :=
begin
  have [ident A] [":", expr tendsto (Œª
    x : expr‚Ñù(), ¬´expr + ¬ª(x, 1)) at_top at_top] [":=", expr tendsto_at_top_add_const_right at_top 1 tendsto_id],
  have [ident B] [":", expr ¬´expr‚àÄ·∂† in , ¬ª((x), at_top, ¬´expr ‚â§ ¬ª(¬´expr + ¬ª(x, 1), exp x))] [":=", expr eventually_at_top.2 ‚ü®0, Œª
    x hx, add_one_le_exp x‚ü©],
  exact [expr tendsto_at_top_mono' at_top B A]
end

/-- The real exponential function tends to `0` at `-‚àû` or, equivalently, `exp(-x)` tends to `0`
at `+‚àû` -/
theorem tendsto_exp_neg_at_top_nhds_0 : tendsto (fun x => exp (-x)) at_top (ùìù 0) :=
  (tendsto_inv_at_top_zero.comp tendsto_exp_at_top).congr fun x => (exp_neg x).symm

/-- The real exponential function tends to `1` at `0`. -/
theorem tendsto_exp_nhds_0_nhds_1 : tendsto exp (ùìù 0) (ùìù 1) :=
  by 
    convert continuous_exp.tendsto 0
    simp 

theorem tendsto_exp_at_bot : tendsto exp at_bot (ùìù 0) :=
  (tendsto_exp_neg_at_top_nhds_0.comp tendsto_neg_at_bot_at_top).congr$ fun x => congr_arg‚Çì exp$ neg_neg‚Çì x

theorem tendsto_exp_at_bot_nhds_within : tendsto exp at_bot (ùìù[Ioi 0] 0) :=
  tendsto_inf.2 ‚ü®tendsto_exp_at_bot, tendsto_principal.2$ eventually_of_forall exp_pos‚ü©

-- error in Analysis.SpecialFunctions.Exp: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The function `exp(x)/x^n` tends to `+‚àû` at `+‚àû`, for any natural number `n` -/
theorem tendsto_exp_div_pow_at_top (n : expr‚Ñï()) : tendsto (Œª x, ¬´expr / ¬ª(exp x, ¬´expr ^ ¬ª(x, n))) at_top at_top :=
begin
  refine [expr (at_top_basis_Ioi.tendsto_iff (at_top_basis' 1)).2 (Œª C hC‚ÇÅ, _)],
  have [ident hC‚ÇÄ] [":", expr ¬´expr < ¬ª(0, C)] [],
  from [expr zero_lt_one.trans_le hC‚ÇÅ],
  have [] [":", expr ¬´expr < ¬ª(0, ¬´expr ‚Åª¬π¬ª(¬´expr * ¬ª(exp 1, C)))] [":=", expr inv_pos.2 (mul_pos (exp_pos _) hC‚ÇÄ)],
  obtain ["‚ü®", ident N, ",", ident hN, "‚ü©", ":", expr ¬´expr‚àÉ , ¬ª((N), ‚àÄ
    k ¬´expr ‚â• ¬ª N, ¬´expr < ¬ª(¬´expr / ¬ª((¬´expr ^ ¬ª(¬´expr‚Üë ¬ª(k), n) : expr‚Ñù()), ¬´expr ^ ¬ª(exp 1, k)), ¬´expr ‚Åª¬π¬ª(¬´expr * ¬ª(exp 1, C)))), ":=", expr eventually_at_top.1 ((tendsto_pow_const_div_const_pow_of_one_lt n (one_lt_exp_iff.2 zero_lt_one)).eventually (gt_mem_nhds this))],
  simp [] [] ["only"] ["[", "<-", expr exp_nat_mul, ",", expr mul_one, ",", expr div_lt_iff, ",", expr exp_pos, ",", "<-", expr div_eq_inv_mul, "]"] [] ["at", ident hN],
  refine [expr ‚ü®N, trivial, Œª x hx, _‚ü©],
  rw [expr set.mem_Ioi] ["at", ident hx],
  have [ident hx‚ÇÄ] [":", expr ¬´expr < ¬ª(0, x)] [],
  from [expr N.cast_nonneg.trans_lt hx],
  rw ["[", expr set.mem_Ici, ",", expr le_div_iff (pow_pos hx‚ÇÄ _), ",", "<-", expr le_div_iff' hC‚ÇÄ, "]"] [],
  calc
    ¬´expr ‚â§ ¬ª(¬´expr ^ ¬ª(x, n), ¬´expr ^ ¬ª(¬´expr‚åà ‚åâ‚Çä¬ª(x), n)) : pow_le_pow_of_le_left hx‚ÇÄ.le (nat.le_ceil _) _
    ¬´expr ‚â§ ¬ª(..., ¬´expr / ¬ª(exp ¬´expr‚åà ‚åâ‚Çä¬ª(x), ¬´expr * ¬ª(exp 1, C))) : (hN _ (nat.lt_ceil.2 hx).le).le
    ¬´expr ‚â§ ¬ª(..., ¬´expr / ¬ª(exp ¬´expr + ¬ª(x, 1), ¬´expr * ¬ª(exp 1, C))) : div_le_div_of_le (mul_pos (exp_pos _) hC‚ÇÄ).le ¬´expr $ ¬ª(exp_le_exp.2, (nat.ceil_lt_add_one hx‚ÇÄ.le).le)
    ¬´expr = ¬ª(..., ¬´expr / ¬ª(exp x, C)) : by rw ["[", expr add_comm, ",", expr exp_add, ",", expr mul_div_mul_left _ _ (exp_pos _).ne', "]"] []
end

/-- The function `x^n * exp(-x)` tends to `0` at `+‚àû`, for any natural number `n`. -/
theorem tendsto_pow_mul_exp_neg_at_top_nhds_0 (n : ‚Ñï) : tendsto (fun x => (x^n)*exp (-x)) at_top (ùìù 0) :=
  (tendsto_inv_at_top_zero.comp (tendsto_exp_div_pow_at_top n)).congr$
    fun x =>
      by 
        rw [comp_app, inv_eq_one_div, div_div_eq_mul_div, one_mul‚Çì, div_eq_mul_inv, exp_neg]

/-- The function `(b * exp x + c) / (x ^ n)` tends to `+‚àû` at `+‚àû`, for any positive natural number
`n` and any real numbers `b` and `c` such that `b` is positive. -/
theorem tendsto_mul_exp_add_div_pow_at_top (b c : ‚Ñù) (n : ‚Ñï) (hb : 0 < b) (hn : 1 ‚â§ n) :
  tendsto (fun x => ((b*exp x)+c) / (x^n)) at_top at_top :=
  by 
    refine'
      tendsto.congr' (eventually_eq_of_mem (Ioi_mem_at_top 0) _)
        (((tendsto_exp_div_pow_at_top n).const_mul_at_top hb).at_top_add
          ((tendsto_pow_neg_at_top hn).mul (@tendsto_const_nhds _ _ _ c _)))
    intro x hx 
    simp only [zpow_neg‚ÇÄ x n]
    ring

-- error in Analysis.SpecialFunctions.Exp: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The function `(x ^ n) / (b * exp x + c)` tends to `0` at `+‚àû`, for any positive natural number
`n` and any real numbers `b` and `c` such that `b` is nonzero. -/
theorem tendsto_div_pow_mul_exp_add_at_top
(b c : expr‚Ñù())
(n : expr‚Ñï())
(hb : ¬´expr ‚â† ¬ª(0, b))
(hn : ¬´expr ‚â§ ¬ª(1, n)) : tendsto (Œª
 x, ¬´expr / ¬ª(¬´expr ^ ¬ª(x, n), ¬´expr + ¬ª(¬´expr * ¬ª(b, exp x), c))) at_top (exprùìù() 0) :=
begin
  have [ident H] [":", expr ‚àÄ
   d
   e, ¬´expr < ¬ª(0, d) ‚Üí tendsto (Œª
    x : expr‚Ñù(), ¬´expr / ¬ª(¬´expr ^ ¬ª(x, n), ¬´expr + ¬ª(¬´expr * ¬ª(d, exp x), e))) at_top (exprùìù() 0)] [],
  { intros [ident b', ident c', ident h],
    convert [] [expr (tendsto_mul_exp_add_div_pow_at_top b' c' n h hn).inv_tendsto_at_top] [],
    ext [] [ident x] [],
    simpa [] [] ["only"] ["[", expr pi.inv_apply, "]"] [] ["using", expr inv_div.symm] },
  cases [expr lt_or_gt_of_ne hb] [],
  { exact [expr H b c h] },
  { convert [] [expr (H ¬´expr- ¬ª(b) ¬´expr- ¬ª(c) (neg_pos.mpr h)).neg] [],
    { ext [] [ident x] [],
      field_simp [] [] [] [],
      rw ["[", "<-", expr neg_add ¬´expr * ¬ª(b, exp x) c, ",", expr neg_div_neg_eq, "]"] [] },
    { exact [expr neg_zero.symm] } }
end

/-- `real.exp` as an order isomorphism between `‚Ñù` and `(0, +‚àû)`. -/
def exp_order_iso : ‚Ñù ‚âÉo Ioi (0 : ‚Ñù) :=
  StrictMono.orderIsoOfSurjective _ (exp_strict_mono.codRestrict exp_pos)$
    (continuous_subtype_mk _ continuous_exp).Surjective
      (by 
        simp only [tendsto_Ioi_at_top, Subtype.coe_mk, tendsto_exp_at_top])
      (by 
        simp [tendsto_exp_at_bot_nhds_within])

@[simp]
theorem coe_exp_order_iso_apply (x : ‚Ñù) : (exp_order_iso x : ‚Ñù) = exp x :=
  rfl

@[simp]
theorem coe_comp_exp_order_iso : (coe‚Çì ‚àò exp_order_iso) = exp :=
  rfl

@[simp]
theorem range_exp : range exp = Ioi 0 :=
  by 
    rw [‚Üêcoe_comp_exp_order_iso, range_comp, exp_order_iso.range_eq, image_univ, Subtype.range_coe]

@[simp]
theorem map_exp_at_top : map exp at_top = at_top :=
  by 
    rw [‚Üêcoe_comp_exp_order_iso, ‚ÜêFilter.map_map, OrderIso.map_at_top, map_coe_Ioi_at_top]

@[simp]
theorem comap_exp_at_top : comap exp at_top = at_top :=
  by 
    rw [‚Üêmap_exp_at_top, comap_map exp_injective, map_exp_at_top]

@[simp]
theorem tendsto_exp_comp_at_top {Œ± : Type _} {l : Filter Œ±} {f : Œ± ‚Üí ‚Ñù} :
  tendsto (fun x => exp (f x)) l at_top ‚Üî tendsto f l at_top :=
  by 
    rw [‚Üêtendsto_comap_iff, comap_exp_at_top]

theorem tendsto_comp_exp_at_top {Œ± : Type _} {l : Filter Œ±} {f : ‚Ñù ‚Üí Œ±} :
  tendsto (fun x => f (exp x)) at_top l ‚Üî tendsto f at_top l :=
  by 
    rw [‚Üêtendsto_map'_iff, map_exp_at_top]

@[simp]
theorem map_exp_at_bot : map exp at_bot = ùìù[Ioi 0] 0 :=
  by 
    rw [‚Üêcoe_comp_exp_order_iso, ‚ÜêFilter.map_map, exp_order_iso.map_at_bot, ‚Üêmap_coe_Ioi_at_bot]

theorem comap_exp_nhds_within_Ioi_zero : comap exp (ùìù[Ioi 0] 0) = at_bot :=
  by 
    rw [‚Üêmap_exp_at_bot, comap_map exp_injective]

theorem tendsto_comp_exp_at_bot {Œ± : Type _} {l : Filter Œ±} {f : ‚Ñù ‚Üí Œ±} :
  tendsto (fun x => f (exp x)) at_bot l ‚Üî tendsto f (ùìù[Ioi 0] 0) l :=
  by 
    rw [‚Üêmap_exp_at_bot, tendsto_map'_iff]

end Real

