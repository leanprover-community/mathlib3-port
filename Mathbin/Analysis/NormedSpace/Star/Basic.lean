/-
Copyright (c) 2021 Fr√©d√©ric Dupuis. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Fr√©d√©ric Dupuis

! This file was ported from Lean 3 source module analysis.normed_space.star.basic
! leanprover-community/mathlib commit e65771194f9e923a70dfb49b6ca7be6e400d8b6f
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Analysis.Normed.Group.Hom
import Mathbin.Analysis.NormedSpace.Basic
import Mathbin.Analysis.NormedSpace.LinearIsometry
import Mathbin.Algebra.Star.SelfAdjoint
import Mathbin.Algebra.Star.Unitary
import Mathbin.Topology.Algebra.StarSubalgebra

/-!
# Normed star rings and algebras

A normed star group is a normed group with a compatible `star` which is isometric.

A C‚ãÜ-ring is a normed star group that is also a ring and that verifies the stronger
condition `‚Äñx‚ãÜ * x‚Äñ = ‚Äñx‚Äñ^2` for all `x`.  If a C‚ãÜ-ring is also a star algebra, then it is a
C‚ãÜ-algebra.

To get a C‚ãÜ-algebra `E` over field `ùïú`, use
`[normed_field ùïú] [star_ring ùïú] [normed_ring E] [star_ring E] [cstar_ring E]
 [normed_algebra ùïú E] [star_module ùïú E]`.

## TODO

- Show that `‚Äñx‚ãÜ * x‚Äñ = ‚Äñx‚Äñ^2` is equivalent to `‚Äñx‚ãÜ * x‚Äñ = ‚Äñx‚ãÜ‚Äñ * ‚Äñx‚Äñ`, which is used as the
  definition of C*-algebras in some sources (e.g. Wikipedia).

-/


open Topology

-- mathport name: ¬´expr ‚ãÜ¬ª
local postfix:max "‚ãÜ" => star

#print NormedStarGroup /-
/-- A normed star group is a normed group with a compatible `star` which is isometric. -/
class NormedStarGroup (E : Type _) [SeminormedAddCommGroup E] [StarAddMonoid E] : Prop where
  norm_star : ‚àÄ x : E, ‚Äñx‚ãÜ‚Äñ = ‚Äñx‚Äñ
#align normed_star_group NormedStarGroup
-/

export NormedStarGroup (norm_star)

attribute [simp] norm_star

variable {ùïú E Œ± : Type _}

section NormedStarGroup

variable [SeminormedAddCommGroup E] [StarAddMonoid E] [NormedStarGroup E]

#print nnnorm_star /-
@[simp]
theorem nnnorm_star (x : E) : ‚Äñstar x‚Äñ‚Çä = ‚Äñx‚Äñ‚Çä :=
  Subtype.ext <| norm_star _
#align nnnorm_star nnnorm_star
-/

#print starNormedAddGroupHom /-
/-- The `star` map in a normed star group is a normed group homomorphism. -/
def starNormedAddGroupHom : NormedAddGroupHom E E :=
  { starAddEquiv with bound' := ‚ü®1, fun v => le_trans (norm_star _).le (one_mul _).symm.le‚ü© }
#align star_normed_add_group_hom starNormedAddGroupHom
-/

#print star_isometry /-
/-- The `star` map in a normed star group is an isometry -/
theorem star_isometry : Isometry (star : E ‚Üí E) :=
  show Isometry starAddEquiv from
    AddMonoidHomClass.isometry_of_norm starAddEquiv (show ‚àÄ x, ‚Äñx‚ãÜ‚Äñ = ‚Äñx‚Äñ from norm_star)
#align star_isometry star_isometry
-/

#print NormedStarGroup.to_continuousStar /-
instance (priority := 100) NormedStarGroup.to_continuousStar : ContinuousStar E :=
  ‚ü®star_isometry.Continuous‚ü©
#align normed_star_group.to_has_continuous_star NormedStarGroup.to_continuousStar
-/

end NormedStarGroup

#print RingHomIsometric.starRingEnd /-
instance RingHomIsometric.starRingEnd [NormedCommRing E] [StarRing E] [NormedStarGroup E] :
    RingHomIsometric (starRingEnd E) :=
  ‚ü®norm_star‚ü©
#align ring_hom_isometric.star_ring_end RingHomIsometric.starRingEnd
-/

#print CstarRing /-
/-- A C*-ring is a normed star ring that satifies the stronger condition `‚Äñx‚ãÜ * x‚Äñ = ‚Äñx‚Äñ^2`
for every `x`. -/
class CstarRing (E : Type _) [NonUnitalNormedRing E] [StarRing E] : Prop where
  norm_star_mul_self : ‚àÄ {x : E}, ‚Äñx‚ãÜ * x‚Äñ = ‚Äñx‚Äñ * ‚Äñx‚Äñ
#align cstar_ring CstarRing
-/

instance : CstarRing ‚Ñù where norm_star_mul_self x := by simp only [star, id.def, norm_mul]

namespace CstarRing

section NonUnital

variable [NonUnitalNormedRing E] [StarRing E] [CstarRing E]

#print CstarRing.to_normedStarGroup /-
-- see Note [lower instance priority]
/-- In a C*-ring, star preserves the norm. -/
instance (priority := 100) to_normedStarGroup : NormedStarGroup E :=
  ‚ü®by
    intro x
    by_cases htriv : x = 0
    ¬∑ simp only [htriv, star_zero]
    ¬∑ have hnt : 0 < ‚Äñx‚Äñ := norm_pos_iff.mpr htriv
      have hnt_star : 0 < ‚Äñx‚ãÜ‚Äñ :=
        norm_pos_iff.mpr ((AddEquiv.map_ne_zero_iff starAddEquiv).mpr htriv)
      have h‚ÇÅ :=
        calc
          ‚Äñx‚Äñ * ‚Äñx‚Äñ = ‚Äñx‚ãÜ * x‚Äñ := norm_star_mul_self.symm
          _ ‚â§ ‚Äñx‚ãÜ‚Äñ * ‚Äñx‚Äñ := norm_mul_le _ _
          
      have h‚ÇÇ :=
        calc
          ‚Äñx‚ãÜ‚Äñ * ‚Äñx‚ãÜ‚Äñ = ‚Äñx * x‚ãÜ‚Äñ := by rw [‚Üê norm_star_mul_self, star_star]
          _ ‚â§ ‚Äñx‚Äñ * ‚Äñx‚ãÜ‚Äñ := norm_mul_le _ _
          
      exact le_antisymm (le_of_mul_le_mul_right h‚ÇÇ hnt_star) (le_of_mul_le_mul_right h‚ÇÅ hnt)‚ü©
#align cstar_ring.to_normed_star_group CstarRing.to_normedStarGroup
-/

/- warning: cstar_ring.norm_self_mul_star -> CstarRing.norm_self_mul_star is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_1 : NonUnitalNormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1))] [_inst_3 : CstarRing.{u1} E _inst_1 _inst_2] {x : E}, Eq.{1} Real (Norm.norm.{u1} E (NonUnitalNormedRing.toHasNorm.{u1} E _inst_1) (HMul.hMul.{u1, u1, u1} E E E (instHMul.{u1} E (Distrib.toHasMul.{u1} E (NonUnitalNonAssocSemiring.toDistrib.{u1} E (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} E (NonUnitalRing.toNonUnitalNonAssocRing.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)))))) x (Star.star.{u1} E (InvolutiveStar.toHasStar.{u1} E (StarAddMonoid.toHasInvolutiveStar.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1))))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)) _inst_2))) x))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Norm.norm.{u1} E (NonUnitalNormedRing.toHasNorm.{u1} E _inst_1) x) (Norm.norm.{u1} E (NonUnitalNormedRing.toHasNorm.{u1} E _inst_1) x))
but is expected to have type
  forall {E : Type.{u1}} [_inst_1 : NonUnitalNormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1))] [_inst_3 : CstarRing.{u1} E _inst_1 _inst_2] {x : E}, Eq.{1} Real (Norm.norm.{u1} E (NonUnitalNormedRing.toNorm.{u1} E _inst_1) (HMul.hMul.{u1, u1, u1} E E E (instHMul.{u1} E (NonUnitalNonAssocRing.toMul.{u1} E (NonUnitalRing.toNonUnitalNonAssocRing.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)))) x (Star.star.{u1} E (InvolutiveStar.toStar.{u1} E (StarAddMonoid.toInvolutiveStar.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E _inst_1))))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)) _inst_2))) x))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Norm.norm.{u1} E (NonUnitalNormedRing.toNorm.{u1} E _inst_1) x) (Norm.norm.{u1} E (NonUnitalNormedRing.toNorm.{u1} E _inst_1) x))
Case conversion may be inaccurate. Consider using '#align cstar_ring.norm_self_mul_star CstarRing.norm_self_mul_star‚Çì'. -/
theorem norm_self_mul_star {x : E} : ‚Äñx * x‚ãÜ‚Äñ = ‚Äñx‚Äñ * ‚Äñx‚Äñ :=
  by
  nth_rw 1 [‚Üê star_star x]
  simp only [norm_star_mul_self, norm_star]
#align cstar_ring.norm_self_mul_star CstarRing.norm_self_mul_star

/- warning: cstar_ring.norm_star_mul_self' -> CstarRing.norm_star_mul_self' is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_1 : NonUnitalNormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1))] [_inst_3 : CstarRing.{u1} E _inst_1 _inst_2] {x : E}, Eq.{1} Real (Norm.norm.{u1} E (NonUnitalNormedRing.toHasNorm.{u1} E _inst_1) (HMul.hMul.{u1, u1, u1} E E E (instHMul.{u1} E (Distrib.toHasMul.{u1} E (NonUnitalNonAssocSemiring.toDistrib.{u1} E (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} E (NonUnitalRing.toNonUnitalNonAssocRing.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)))))) (Star.star.{u1} E (InvolutiveStar.toHasStar.{u1} E (StarAddMonoid.toHasInvolutiveStar.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1))))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)) _inst_2))) x) x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Norm.norm.{u1} E (NonUnitalNormedRing.toHasNorm.{u1} E _inst_1) (Star.star.{u1} E (InvolutiveStar.toHasStar.{u1} E (StarAddMonoid.toHasInvolutiveStar.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1))))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)) _inst_2))) x)) (Norm.norm.{u1} E (NonUnitalNormedRing.toHasNorm.{u1} E _inst_1) x))
but is expected to have type
  forall {E : Type.{u1}} [_inst_1 : NonUnitalNormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1))] [_inst_3 : CstarRing.{u1} E _inst_1 _inst_2] {x : E}, Eq.{1} Real (Norm.norm.{u1} E (NonUnitalNormedRing.toNorm.{u1} E _inst_1) (HMul.hMul.{u1, u1, u1} E E E (instHMul.{u1} E (NonUnitalNonAssocRing.toMul.{u1} E (NonUnitalRing.toNonUnitalNonAssocRing.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)))) (Star.star.{u1} E (InvolutiveStar.toStar.{u1} E (StarAddMonoid.toInvolutiveStar.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E _inst_1))))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)) _inst_2))) x) x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Norm.norm.{u1} E (NonUnitalNormedRing.toNorm.{u1} E _inst_1) (Star.star.{u1} E (InvolutiveStar.toStar.{u1} E (StarAddMonoid.toInvolutiveStar.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E _inst_1))))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)) _inst_2))) x)) (Norm.norm.{u1} E (NonUnitalNormedRing.toNorm.{u1} E _inst_1) x))
Case conversion may be inaccurate. Consider using '#align cstar_ring.norm_star_mul_self' CstarRing.norm_star_mul_self'‚Çì'. -/
theorem norm_star_mul_self' {x : E} : ‚Äñx‚ãÜ * x‚Äñ = ‚Äñx‚ãÜ‚Äñ * ‚Äñx‚Äñ := by rw [norm_star_mul_self, norm_star]
#align cstar_ring.norm_star_mul_self' CstarRing.norm_star_mul_self'

/- warning: cstar_ring.nnnorm_self_mul_star -> CstarRing.nnnorm_self_mul_star is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_1 : NonUnitalNormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1))] [_inst_3 : CstarRing.{u1} E _inst_1 _inst_2] {x : E}, Eq.{1} NNReal (NNNorm.nnnorm.{u1} E (SeminormedAddGroup.toNNNorm.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} E (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u1} E _inst_1)))) (HMul.hMul.{u1, u1, u1} E E E (instHMul.{u1} E (Distrib.toHasMul.{u1} E (NonUnitalNonAssocSemiring.toDistrib.{u1} E (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} E (NonUnitalRing.toNonUnitalNonAssocRing.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)))))) x (Star.star.{u1} E (InvolutiveStar.toHasStar.{u1} E (StarAddMonoid.toHasInvolutiveStar.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1))))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)) _inst_2))) x))) (HMul.hMul.{0, 0, 0} NNReal NNReal NNReal (instHMul.{0} NNReal (Distrib.toHasMul.{0} NNReal (NonUnitalNonAssocSemiring.toDistrib.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))) (NNNorm.nnnorm.{u1} E (SeminormedAddGroup.toNNNorm.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} E (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u1} E _inst_1)))) x) (NNNorm.nnnorm.{u1} E (SeminormedAddGroup.toNNNorm.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} E (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u1} E _inst_1)))) x))
but is expected to have type
  forall {E : Type.{u1}} [_inst_1 : NonUnitalNormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1))] [_inst_3 : CstarRing.{u1} E _inst_1 _inst_2] {x : E}, Eq.{1} NNReal (NNNorm.nnnorm.{u1} E (SeminormedAddGroup.toNNNorm.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} E (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u1} E _inst_1)))) (HMul.hMul.{u1, u1, u1} E E E (instHMul.{u1} E (NonUnitalNonAssocRing.toMul.{u1} E (NonUnitalRing.toNonUnitalNonAssocRing.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)))) x (Star.star.{u1} E (InvolutiveStar.toStar.{u1} E (StarAddMonoid.toInvolutiveStar.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E _inst_1))))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)) _inst_2))) x))) (HMul.hMul.{0, 0, 0} NNReal NNReal NNReal (instHMul.{0} NNReal (CanonicallyOrderedCommSemiring.toMul.{0} NNReal instNNRealCanonicallyOrderedCommSemiring)) (NNNorm.nnnorm.{u1} E (SeminormedAddGroup.toNNNorm.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} E (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u1} E _inst_1)))) x) (NNNorm.nnnorm.{u1} E (SeminormedAddGroup.toNNNorm.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} E (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u1} E _inst_1)))) x))
Case conversion may be inaccurate. Consider using '#align cstar_ring.nnnorm_self_mul_star CstarRing.nnnorm_self_mul_star‚Çì'. -/
theorem nnnorm_self_mul_star {x : E} : ‚Äñx * star x‚Äñ‚Çä = ‚Äñx‚Äñ‚Çä * ‚Äñx‚Äñ‚Çä :=
  Subtype.ext norm_self_mul_star
#align cstar_ring.nnnorm_self_mul_star CstarRing.nnnorm_self_mul_star

/- warning: cstar_ring.nnnorm_star_mul_self -> CstarRing.nnnorm_star_mul_self is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_1 : NonUnitalNormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1))] [_inst_3 : CstarRing.{u1} E _inst_1 _inst_2] {x : E}, Eq.{1} NNReal (NNNorm.nnnorm.{u1} E (SeminormedAddGroup.toNNNorm.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} E (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u1} E _inst_1)))) (HMul.hMul.{u1, u1, u1} E E E (instHMul.{u1} E (Distrib.toHasMul.{u1} E (NonUnitalNonAssocSemiring.toDistrib.{u1} E (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} E (NonUnitalRing.toNonUnitalNonAssocRing.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)))))) (Star.star.{u1} E (InvolutiveStar.toHasStar.{u1} E (StarAddMonoid.toHasInvolutiveStar.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1))))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)) _inst_2))) x) x)) (HMul.hMul.{0, 0, 0} NNReal NNReal NNReal (instHMul.{0} NNReal (Distrib.toHasMul.{0} NNReal (NonUnitalNonAssocSemiring.toDistrib.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))) (NNNorm.nnnorm.{u1} E (SeminormedAddGroup.toNNNorm.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} E (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u1} E _inst_1)))) x) (NNNorm.nnnorm.{u1} E (SeminormedAddGroup.toNNNorm.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} E (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u1} E _inst_1)))) x))
but is expected to have type
  forall {E : Type.{u1}} [_inst_1 : NonUnitalNormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1))] [_inst_3 : CstarRing.{u1} E _inst_1 _inst_2] {x : E}, Eq.{1} NNReal (NNNorm.nnnorm.{u1} E (SeminormedAddGroup.toNNNorm.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} E (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u1} E _inst_1)))) (HMul.hMul.{u1, u1, u1} E E E (instHMul.{u1} E (NonUnitalNonAssocRing.toMul.{u1} E (NonUnitalRing.toNonUnitalNonAssocRing.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)))) (Star.star.{u1} E (InvolutiveStar.toStar.{u1} E (StarAddMonoid.toInvolutiveStar.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E _inst_1))))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)) _inst_2))) x) x)) (HMul.hMul.{0, 0, 0} NNReal NNReal NNReal (instHMul.{0} NNReal (CanonicallyOrderedCommSemiring.toMul.{0} NNReal instNNRealCanonicallyOrderedCommSemiring)) (NNNorm.nnnorm.{u1} E (SeminormedAddGroup.toNNNorm.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} E (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u1} E _inst_1)))) x) (NNNorm.nnnorm.{u1} E (SeminormedAddGroup.toNNNorm.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} E (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u1} E _inst_1)))) x))
Case conversion may be inaccurate. Consider using '#align cstar_ring.nnnorm_star_mul_self CstarRing.nnnorm_star_mul_self‚Çì'. -/
theorem nnnorm_star_mul_self {x : E} : ‚Äñx‚ãÜ * x‚Äñ‚Çä = ‚Äñx‚Äñ‚Çä * ‚Äñx‚Äñ‚Çä :=
  Subtype.ext norm_star_mul_self
#align cstar_ring.nnnorm_star_mul_self CstarRing.nnnorm_star_mul_self

/- warning: cstar_ring.star_mul_self_eq_zero_iff -> CstarRing.star_mul_self_eq_zero_iff is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_1 : NonUnitalNormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1))] [_inst_3 : CstarRing.{u1} E _inst_1 _inst_2] (x : E), Iff (Eq.{succ u1} E (HMul.hMul.{u1, u1, u1} E E E (instHMul.{u1} E (Distrib.toHasMul.{u1} E (NonUnitalNonAssocSemiring.toDistrib.{u1} E (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} E (NonUnitalRing.toNonUnitalNonAssocRing.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)))))) (Star.star.{u1} E (InvolutiveStar.toHasStar.{u1} E (StarAddMonoid.toHasInvolutiveStar.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1))))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)) _inst_2))) x) x) (OfNat.ofNat.{u1} E 0 (OfNat.mk.{u1} E 0 (Zero.zero.{u1} E (MulZeroClass.toHasZero.{u1} E (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} E (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} E (NonUnitalRing.toNonUnitalNonAssocRing.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1))))))))) (Eq.{succ u1} E x (OfNat.ofNat.{u1} E 0 (OfNat.mk.{u1} E 0 (Zero.zero.{u1} E (MulZeroClass.toHasZero.{u1} E (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} E (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} E (NonUnitalRing.toNonUnitalNonAssocRing.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)))))))))
but is expected to have type
  forall {E : Type.{u1}} [_inst_1 : NonUnitalNormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1))] [_inst_3 : CstarRing.{u1} E _inst_1 _inst_2] (x : E), Iff (Eq.{succ u1} E (HMul.hMul.{u1, u1, u1} E E E (instHMul.{u1} E (NonUnitalNonAssocRing.toMul.{u1} E (NonUnitalRing.toNonUnitalNonAssocRing.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)))) (Star.star.{u1} E (InvolutiveStar.toStar.{u1} E (StarAddMonoid.toInvolutiveStar.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E _inst_1))))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)) _inst_2))) x) x) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (SemigroupWithZero.toZero.{u1} E (NonUnitalSemiring.toSemigroupWithZero.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1))))))) (Eq.{succ u1} E x (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (SemigroupWithZero.toZero.{u1} E (NonUnitalSemiring.toSemigroupWithZero.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align cstar_ring.star_mul_self_eq_zero_iff CstarRing.star_mul_self_eq_zero_iff‚Çì'. -/
@[simp]
theorem star_mul_self_eq_zero_iff (x : E) : star x * x = 0 ‚Üî x = 0 :=
  by
  rw [‚Üê norm_eq_zero, norm_star_mul_self]
  exact mul_self_eq_zero.trans norm_eq_zero
#align cstar_ring.star_mul_self_eq_zero_iff CstarRing.star_mul_self_eq_zero_iff

/- warning: cstar_ring.star_mul_self_ne_zero_iff -> CstarRing.star_mul_self_ne_zero_iff is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_1 : NonUnitalNormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1))] [_inst_3 : CstarRing.{u1} E _inst_1 _inst_2] (x : E), Iff (Ne.{succ u1} E (HMul.hMul.{u1, u1, u1} E E E (instHMul.{u1} E (Distrib.toHasMul.{u1} E (NonUnitalNonAssocSemiring.toDistrib.{u1} E (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} E (NonUnitalRing.toNonUnitalNonAssocRing.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)))))) (Star.star.{u1} E (InvolutiveStar.toHasStar.{u1} E (StarAddMonoid.toHasInvolutiveStar.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1))))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)) _inst_2))) x) x) (OfNat.ofNat.{u1} E 0 (OfNat.mk.{u1} E 0 (Zero.zero.{u1} E (MulZeroClass.toHasZero.{u1} E (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} E (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} E (NonUnitalRing.toNonUnitalNonAssocRing.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1))))))))) (Ne.{succ u1} E x (OfNat.ofNat.{u1} E 0 (OfNat.mk.{u1} E 0 (Zero.zero.{u1} E (MulZeroClass.toHasZero.{u1} E (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} E (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} E (NonUnitalRing.toNonUnitalNonAssocRing.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)))))))))
but is expected to have type
  forall {E : Type.{u1}} [_inst_1 : NonUnitalNormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1))] [_inst_3 : CstarRing.{u1} E _inst_1 _inst_2] (x : E), Iff (Ne.{succ u1} E (HMul.hMul.{u1, u1, u1} E E E (instHMul.{u1} E (NonUnitalNonAssocRing.toMul.{u1} E (NonUnitalRing.toNonUnitalNonAssocRing.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)))) (Star.star.{u1} E (InvolutiveStar.toStar.{u1} E (StarAddMonoid.toInvolutiveStar.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E _inst_1))))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)) _inst_2))) x) x) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (SemigroupWithZero.toZero.{u1} E (NonUnitalSemiring.toSemigroupWithZero.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1))))))) (Ne.{succ u1} E x (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (SemigroupWithZero.toZero.{u1} E (NonUnitalSemiring.toSemigroupWithZero.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align cstar_ring.star_mul_self_ne_zero_iff CstarRing.star_mul_self_ne_zero_iff‚Çì'. -/
theorem star_mul_self_ne_zero_iff (x : E) : star x * x ‚â† 0 ‚Üî x ‚â† 0 := by
  simp only [Ne.def, star_mul_self_eq_zero_iff]
#align cstar_ring.star_mul_self_ne_zero_iff CstarRing.star_mul_self_ne_zero_iff

/- warning: cstar_ring.mul_star_self_eq_zero_iff -> CstarRing.mul_star_self_eq_zero_iff is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_1 : NonUnitalNormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1))] [_inst_3 : CstarRing.{u1} E _inst_1 _inst_2] (x : E), Iff (Eq.{succ u1} E (HMul.hMul.{u1, u1, u1} E E E (instHMul.{u1} E (Distrib.toHasMul.{u1} E (NonUnitalNonAssocSemiring.toDistrib.{u1} E (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} E (NonUnitalRing.toNonUnitalNonAssocRing.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)))))) x (Star.star.{u1} E (InvolutiveStar.toHasStar.{u1} E (StarAddMonoid.toHasInvolutiveStar.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1))))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)) _inst_2))) x)) (OfNat.ofNat.{u1} E 0 (OfNat.mk.{u1} E 0 (Zero.zero.{u1} E (MulZeroClass.toHasZero.{u1} E (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} E (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} E (NonUnitalRing.toNonUnitalNonAssocRing.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1))))))))) (Eq.{succ u1} E x (OfNat.ofNat.{u1} E 0 (OfNat.mk.{u1} E 0 (Zero.zero.{u1} E (MulZeroClass.toHasZero.{u1} E (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} E (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} E (NonUnitalRing.toNonUnitalNonAssocRing.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)))))))))
but is expected to have type
  forall {E : Type.{u1}} [_inst_1 : NonUnitalNormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1))] [_inst_3 : CstarRing.{u1} E _inst_1 _inst_2] (x : E), Iff (Eq.{succ u1} E (HMul.hMul.{u1, u1, u1} E E E (instHMul.{u1} E (NonUnitalNonAssocRing.toMul.{u1} E (NonUnitalRing.toNonUnitalNonAssocRing.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)))) x (Star.star.{u1} E (InvolutiveStar.toStar.{u1} E (StarAddMonoid.toInvolutiveStar.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E _inst_1))))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)) _inst_2))) x)) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (SemigroupWithZero.toZero.{u1} E (NonUnitalSemiring.toSemigroupWithZero.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1))))))) (Eq.{succ u1} E x (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (SemigroupWithZero.toZero.{u1} E (NonUnitalSemiring.toSemigroupWithZero.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align cstar_ring.mul_star_self_eq_zero_iff CstarRing.mul_star_self_eq_zero_iff‚Çì'. -/
@[simp]
theorem mul_star_self_eq_zero_iff (x : E) : x * star x = 0 ‚Üî x = 0 := by
  simpa only [star_eq_zero, star_star] using @star_mul_self_eq_zero_iff _ _ _ _ (star x)
#align cstar_ring.mul_star_self_eq_zero_iff CstarRing.mul_star_self_eq_zero_iff

/- warning: cstar_ring.mul_star_self_ne_zero_iff -> CstarRing.mul_star_self_ne_zero_iff is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_1 : NonUnitalNormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1))] [_inst_3 : CstarRing.{u1} E _inst_1 _inst_2] (x : E), Iff (Ne.{succ u1} E (HMul.hMul.{u1, u1, u1} E E E (instHMul.{u1} E (Distrib.toHasMul.{u1} E (NonUnitalNonAssocSemiring.toDistrib.{u1} E (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} E (NonUnitalRing.toNonUnitalNonAssocRing.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)))))) x (Star.star.{u1} E (InvolutiveStar.toHasStar.{u1} E (StarAddMonoid.toHasInvolutiveStar.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1))))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)) _inst_2))) x)) (OfNat.ofNat.{u1} E 0 (OfNat.mk.{u1} E 0 (Zero.zero.{u1} E (MulZeroClass.toHasZero.{u1} E (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} E (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} E (NonUnitalRing.toNonUnitalNonAssocRing.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1))))))))) (Ne.{succ u1} E x (OfNat.ofNat.{u1} E 0 (OfNat.mk.{u1} E 0 (Zero.zero.{u1} E (MulZeroClass.toHasZero.{u1} E (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} E (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} E (NonUnitalRing.toNonUnitalNonAssocRing.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)))))))))
but is expected to have type
  forall {E : Type.{u1}} [_inst_1 : NonUnitalNormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1))] [_inst_3 : CstarRing.{u1} E _inst_1 _inst_2] (x : E), Iff (Ne.{succ u1} E (HMul.hMul.{u1, u1, u1} E E E (instHMul.{u1} E (NonUnitalNonAssocRing.toMul.{u1} E (NonUnitalRing.toNonUnitalNonAssocRing.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)))) x (Star.star.{u1} E (InvolutiveStar.toStar.{u1} E (StarAddMonoid.toInvolutiveStar.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E _inst_1))))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)) _inst_2))) x)) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (SemigroupWithZero.toZero.{u1} E (NonUnitalSemiring.toSemigroupWithZero.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1))))))) (Ne.{succ u1} E x (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (SemigroupWithZero.toZero.{u1} E (NonUnitalSemiring.toSemigroupWithZero.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align cstar_ring.mul_star_self_ne_zero_iff CstarRing.mul_star_self_ne_zero_iff‚Çì'. -/
theorem mul_star_self_ne_zero_iff (x : E) : x * star x ‚â† 0 ‚Üî x ‚â† 0 := by
  simp only [Ne.def, mul_star_self_eq_zero_iff]
#align cstar_ring.mul_star_self_ne_zero_iff CstarRing.mul_star_self_ne_zero_iff

end NonUnital

section ProdPi

variable {Œπ R‚ÇÅ R‚ÇÇ : Type _} {R : Œπ ‚Üí Type _}

variable [NonUnitalNormedRing R‚ÇÅ] [StarRing R‚ÇÅ] [CstarRing R‚ÇÅ]

variable [NonUnitalNormedRing R‚ÇÇ] [StarRing R‚ÇÇ] [CstarRing R‚ÇÇ]

variable [‚àÄ i, NonUnitalNormedRing (R i)] [‚àÄ i, StarRing (R i)]

#print Pi.starRing' /-
/-- This instance exists to short circuit type class resolution because of problems with
inference involving Œ†-types. -/
instance Pi.starRing' : StarRing (‚àÄ i, R i) :=
  inferInstance
#align pi.star_ring' Pi.starRing'
-/

variable [Fintype Œπ] [‚àÄ i, CstarRing (R i)]

/- warning: prod.cstar_ring -> Prod.cstarRing is a dubious translation:
lean 3 declaration is
  forall {R‚ÇÅ : Type.{u1}} {R‚ÇÇ : Type.{u2}} [_inst_1 : NonUnitalNormedRing.{u1} R‚ÇÅ] [_inst_2 : StarRing.{u1} R‚ÇÅ (NonUnitalRing.toNonUnitalSemiring.{u1} R‚ÇÅ (NonUnitalNormedRing.toNonUnitalRing.{u1} R‚ÇÅ _inst_1))] [_inst_3 : CstarRing.{u1} R‚ÇÅ _inst_1 _inst_2] [_inst_4 : NonUnitalNormedRing.{u2} R‚ÇÇ] [_inst_5 : StarRing.{u2} R‚ÇÇ (NonUnitalRing.toNonUnitalSemiring.{u2} R‚ÇÇ (NonUnitalNormedRing.toNonUnitalRing.{u2} R‚ÇÇ _inst_4))] [_inst_6 : CstarRing.{u2} R‚ÇÇ _inst_4 _inst_5], CstarRing.{max u1 u2} (Prod.{u1, u2} R‚ÇÅ R‚ÇÇ) (Prod.nonUnitalNormedRing.{u1, u2} R‚ÇÅ R‚ÇÇ _inst_1 _inst_4) (Prod.starRing.{u1, u2} R‚ÇÅ R‚ÇÇ (NonUnitalRing.toNonUnitalSemiring.{u1} R‚ÇÅ (NonUnitalNormedRing.toNonUnitalRing.{u1} R‚ÇÅ _inst_1)) (NonUnitalRing.toNonUnitalSemiring.{u2} R‚ÇÇ (NonUnitalNormedRing.toNonUnitalRing.{u2} R‚ÇÇ _inst_4)) _inst_2 _inst_5)
but is expected to have type
  forall {R‚ÇÅ : Type.{u1}} {R‚ÇÇ : Type.{u2}} [_inst_1 : NonUnitalNormedRing.{u1} R‚ÇÅ] [_inst_2 : StarRing.{u1} R‚ÇÅ (NonUnitalRing.toNonUnitalSemiring.{u1} R‚ÇÅ (NonUnitalNormedRing.toNonUnitalRing.{u1} R‚ÇÅ _inst_1))] [_inst_3 : CstarRing.{u1} R‚ÇÅ _inst_1 _inst_2] [_inst_4 : NonUnitalNormedRing.{u2} R‚ÇÇ] [_inst_5 : StarRing.{u2} R‚ÇÇ (NonUnitalRing.toNonUnitalSemiring.{u2} R‚ÇÇ (NonUnitalNormedRing.toNonUnitalRing.{u2} R‚ÇÇ _inst_4))] [_inst_6 : CstarRing.{u2} R‚ÇÇ _inst_4 _inst_5], CstarRing.{max u2 u1} (Prod.{u1, u2} R‚ÇÅ R‚ÇÇ) (Prod.nonUnitalNormedRing.{u1, u2} R‚ÇÅ R‚ÇÇ _inst_1 _inst_4) (Prod.instStarRingProdInstNonUnitalSemiringProd.{u1, u2} R‚ÇÅ R‚ÇÇ (NonUnitalRing.toNonUnitalSemiring.{u1} R‚ÇÅ (NonUnitalNormedRing.toNonUnitalRing.{u1} R‚ÇÅ _inst_1)) (NonUnitalRing.toNonUnitalSemiring.{u2} R‚ÇÇ (NonUnitalNormedRing.toNonUnitalRing.{u2} R‚ÇÇ _inst_4)) _inst_2 _inst_5)
Case conversion may be inaccurate. Consider using '#align prod.cstar_ring Prod.cstarRing‚Çì'. -/
instance Prod.cstarRing : CstarRing (R‚ÇÅ √ó R‚ÇÇ)
    where norm_star_mul_self x := by
    unfold norm
    simp only [Prod.fst_mul, Prod.fst_star, Prod.snd_mul, Prod.snd_star, norm_star_mul_self, ‚Üê sq]
    refine' le_antisymm _ _
    ¬∑ refine' max_le _ _ <;> rw [sq_le_sq, abs_of_nonneg (norm_nonneg _)]
      exact (le_max_left _ _).trans (le_abs_self _)
      exact (le_max_right _ _).trans (le_abs_self _)
    ¬∑ rw [le_sup_iff]
      rcases le_total ‚Äñx.fst‚Äñ ‚Äñx.snd‚Äñ with (h | h) <;> simp [h]
#align prod.cstar_ring Prod.cstarRing

#print Pi.cstarRing /-
instance Pi.cstarRing : CstarRing (‚àÄ i, R i)
    where norm_star_mul_self x :=
    by
    simp only [norm, Pi.mul_apply, Pi.star_apply, nnnorm_star_mul_self, ‚Üê sq]
    norm_cast
    exact
      (Finset.comp_sup_eq_sup_comp_of_is_total (fun x : NNReal => x ^ 2)
          (fun x y h => by simpa only [sq] using mul_le_mul' h h) (by simp)).symm
#align pi.cstar_ring Pi.cstarRing
-/

#print Pi.cstar_ring' /-
instance Pi.cstar_ring' : CstarRing (Œπ ‚Üí R‚ÇÅ) :=
  Pi.cstarRing
#align pi.cstar_ring' Pi.cstar_ring'
-/

end ProdPi

section Unital

variable [NormedRing E] [StarRing E] [CstarRing E]

/- warning: cstar_ring.norm_one -> CstarRing.norm_one is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_1 : NormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))] [_inst_3 : CstarRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1) _inst_2] [_inst_4 : Nontrivial.{u1} E], Eq.{1} Real (Norm.norm.{u1} E (NormedRing.toHasNorm.{u1} E _inst_1) (OfNat.ofNat.{u1} E 1 (OfNat.mk.{u1} E 1 (One.one.{u1} E (AddMonoidWithOne.toOne.{u1} E (AddGroupWithOne.toAddMonoidWithOne.{u1} E (AddCommGroupWithOne.toAddGroupWithOne.{u1} E (Ring.toAddCommGroupWithOne.{u1} E (NormedRing.toRing.{u1} E _inst_1))))))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))
but is expected to have type
  forall {E : Type.{u1}} [_inst_1 : NormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))] [_inst_3 : CstarRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1) _inst_2] [_inst_4 : Nontrivial.{u1} E], Eq.{1} Real (Norm.norm.{u1} E (NormedRing.toNorm.{u1} E _inst_1) (OfNat.ofNat.{u1} E 1 (One.toOfNat1.{u1} E (NonAssocRing.toOne.{u1} E (Ring.toNonAssocRing.{u1} E (NormedRing.toRing.{u1} E _inst_1)))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))
Case conversion may be inaccurate. Consider using '#align cstar_ring.norm_one CstarRing.norm_one‚Çì'. -/
@[simp]
theorem norm_one [Nontrivial E] : ‚Äñ(1 : E)‚Äñ = 1 :=
  by
  have : 0 < ‚Äñ(1 : E)‚Äñ := norm_pos_iff.mpr one_ne_zero
  rw [‚Üê mul_left_inj' this.ne', ‚Üê norm_star_mul_self, mul_one, star_one, one_mul]
#align cstar_ring.norm_one CstarRing.norm_one

-- see Note [lower instance priority]
instance (priority := 100) [Nontrivial E] : NormOneClass E :=
  ‚ü®norm_one‚ü©

/- warning: cstar_ring.norm_coe_unitary -> CstarRing.norm_coe_unitary is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_1 : NormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))] [_inst_3 : CstarRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1) _inst_2] [_inst_4 : Nontrivial.{u1} E] (U : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) E (Submonoid.setLike.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1))))) (unitary.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))), Eq.{1} Real (Norm.norm.{u1} E (NormedRing.toHasNorm.{u1} E _inst_1) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) E (Submonoid.setLike.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1))))) (unitary.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))) E (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) E (Submonoid.setLike.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1))))) (unitary.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))) E (CoeTC‚Çì.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) E (Submonoid.setLike.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1))))) (unitary.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))) E (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) E (Submonoid.setLike.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1))))) (unitary.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))) E (coeSubtype.{succ u1} E (fun (x : E) => Membership.Mem.{u1, u1} E (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) E (Submonoid.setLike.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1))))) x (unitary.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))))))) U)) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))
but is expected to have type
  forall {E : Type.{u1}} [_inst_1 : NormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))] [_inst_3 : CstarRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1) _inst_2] [_inst_4 : Nontrivial.{u1} E] (U : Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))))) E (Submonoid.instSetLikeSubmonoid.{u1} E (Monoid.toMulOneClass.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1))))))) x (unitary.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2)))), Eq.{1} Real (Norm.norm.{u1} E (NormedRing.toNorm.{u1} E _inst_1) (Subtype.val.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x (SetLike.coe.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))))) E (Submonoid.instSetLikeSubmonoid.{u1} E (Monoid.toMulOneClass.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))))) (unitary.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2)))) U)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))
Case conversion may be inaccurate. Consider using '#align cstar_ring.norm_coe_unitary CstarRing.norm_coe_unitary‚Çì'. -/
theorem norm_coe_unitary [Nontrivial E] (U : unitary E) : ‚Äñ(U : E)‚Äñ = 1 := by
  rw [‚Üê sq_eq_sq (norm_nonneg _) zero_le_one, one_pow 2, sq, ‚Üê CstarRing.norm_star_mul_self,
    unitary.coe_star_mul_self, CstarRing.norm_one]
#align cstar_ring.norm_coe_unitary CstarRing.norm_coe_unitary

/- warning: cstar_ring.norm_of_mem_unitary -> CstarRing.norm_of_mem_unitary is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_1 : NormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))] [_inst_3 : CstarRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1) _inst_2] [_inst_4 : Nontrivial.{u1} E] {U : E}, (Membership.Mem.{u1, u1} E (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) E (Submonoid.setLike.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1))))) U (unitary.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))) -> (Eq.{1} Real (Norm.norm.{u1} E (NormedRing.toHasNorm.{u1} E _inst_1) U) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))
but is expected to have type
  forall {E : Type.{u1}} [_inst_1 : NormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))] [_inst_3 : CstarRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1) _inst_2] [_inst_4 : Nontrivial.{u1} E] {U : E}, (Membership.mem.{u1, u1} E (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))))) E (Submonoid.instSetLikeSubmonoid.{u1} E (Monoid.toMulOneClass.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1))))))) U (unitary.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))) -> (Eq.{1} Real (Norm.norm.{u1} E (NormedRing.toNorm.{u1} E _inst_1) U) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))
Case conversion may be inaccurate. Consider using '#align cstar_ring.norm_of_mem_unitary CstarRing.norm_of_mem_unitary‚Çì'. -/
@[simp]
theorem norm_of_mem_unitary [Nontrivial E] {U : E} (hU : U ‚àà unitary E) : ‚ÄñU‚Äñ = 1 :=
  norm_coe_unitary ‚ü®U, hU‚ü©
#align cstar_ring.norm_of_mem_unitary CstarRing.norm_of_mem_unitary

/- warning: cstar_ring.norm_coe_unitary_mul -> CstarRing.norm_coe_unitary_mul is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_1 : NormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))] [_inst_3 : CstarRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1) _inst_2] (U : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) E (Submonoid.setLike.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1))))) (unitary.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))) (A : E), Eq.{1} Real (Norm.norm.{u1} E (NormedRing.toHasNorm.{u1} E _inst_1) (HMul.hMul.{u1, u1, u1} E E E (instHMul.{u1} E (Distrib.toHasMul.{u1} E (Ring.toDistrib.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) E (Submonoid.setLike.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1))))) (unitary.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))) E (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) E (Submonoid.setLike.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1))))) (unitary.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))) E (CoeTC‚Çì.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) E (Submonoid.setLike.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1))))) (unitary.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))) E (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) E (Submonoid.setLike.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1))))) (unitary.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))) E (coeSubtype.{succ u1} E (fun (x : E) => Membership.Mem.{u1, u1} E (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) E (Submonoid.setLike.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1))))) x (unitary.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))))))) U) A)) (Norm.norm.{u1} E (NormedRing.toHasNorm.{u1} E _inst_1) A)
but is expected to have type
  forall {E : Type.{u1}} [_inst_1 : NormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))] [_inst_3 : CstarRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1) _inst_2] (U : Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))))) E (Submonoid.instSetLikeSubmonoid.{u1} E (Monoid.toMulOneClass.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1))))))) x (unitary.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2)))) (A : E), Eq.{1} Real (Norm.norm.{u1} E (NormedRing.toNorm.{u1} E _inst_1) (HMul.hMul.{u1, u1, u1} E E E (instHMul.{u1} E (NonUnitalNonAssocRing.toMul.{u1} E (NonAssocRing.toNonUnitalNonAssocRing.{u1} E (Ring.toNonAssocRing.{u1} E (NormedRing.toRing.{u1} E _inst_1))))) (Subtype.val.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x (SetLike.coe.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))))) E (Submonoid.instSetLikeSubmonoid.{u1} E (Monoid.toMulOneClass.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))))) (unitary.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2)))) U) A)) (Norm.norm.{u1} E (NormedRing.toNorm.{u1} E _inst_1) A)
Case conversion may be inaccurate. Consider using '#align cstar_ring.norm_coe_unitary_mul CstarRing.norm_coe_unitary_mul‚Çì'. -/
@[simp]
theorem norm_coe_unitary_mul (U : unitary E) (A : E) : ‚Äñ(U : E) * A‚Äñ = ‚ÄñA‚Äñ :=
  by
  nontriviality E
  refine' le_antisymm _ _
  ¬∑
    calc
      _ ‚â§ ‚Äñ(U : E)‚Äñ * ‚ÄñA‚Äñ := norm_mul_le _ _
      _ = ‚ÄñA‚Äñ := by rw [norm_coe_unitary, one_mul]
      
  ¬∑
    calc
      _ = ‚Äñ(U : E)‚ãÜ * U * A‚Äñ := by rw [unitary.coe_star_mul_self U, one_mul]
      _ ‚â§ ‚Äñ(U : E)‚ãÜ‚Äñ * ‚Äñ(U : E) * A‚Äñ := by
        rw [mul_assoc]
        exact norm_mul_le _ _
      _ = ‚Äñ(U : E) * A‚Äñ := by rw [norm_star, norm_coe_unitary, one_mul]
      
#align cstar_ring.norm_coe_unitary_mul CstarRing.norm_coe_unitary_mul

/- warning: cstar_ring.norm_unitary_smul -> CstarRing.norm_unitary_smul is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_1 : NormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))] [_inst_3 : CstarRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1) _inst_2] (U : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) E (Submonoid.setLike.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1))))) (unitary.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))) (A : E), Eq.{1} Real (Norm.norm.{u1} E (NormedRing.toHasNorm.{u1} E _inst_1) (SMul.smul.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) E (Submonoid.setLike.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1))))) (unitary.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))) E (Submonoid.hasSmul.{u1, u1} E E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1))) (Mul.toSMul.{u1} E (Distrib.toHasMul.{u1} E (Ring.toDistrib.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) (unitary.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))) U A)) (Norm.norm.{u1} E (NormedRing.toHasNorm.{u1} E _inst_1) A)
but is expected to have type
  forall {E : Type.{u1}} [_inst_1 : NormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))] [_inst_3 : CstarRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1) _inst_2] (U : Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))))) E (Submonoid.instSetLikeSubmonoid.{u1} E (Monoid.toMulOneClass.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1))))))) x (unitary.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2)))) (A : E), Eq.{1} Real (Norm.norm.{u1} E (NormedRing.toNorm.{u1} E _inst_1) (HSMul.hSMul.{u1, u1, u1} (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))))) E (Submonoid.instSetLikeSubmonoid.{u1} E (Monoid.toMulOneClass.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1))))))) x (unitary.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2)))) E E (instHSMul.{u1, u1} (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))))) E (Submonoid.instSetLikeSubmonoid.{u1} E (Monoid.toMulOneClass.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1))))))) x (unitary.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2)))) E (Submonoid.smul.{u1, u1} E E (Monoid.toMulOneClass.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1))))) (SMulZeroClass.toSMul.{u1, u1} E E (MonoidWithZero.toZero.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) (SMulWithZero.toSMulZeroClass.{u1, u1} E E (MonoidWithZero.toZero.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) (MonoidWithZero.toZero.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) (MulZeroClass.toSMulWithZero.{u1} E (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} E (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} E (NonAssocRing.toNonUnitalNonAssocRing.{u1} E (Ring.toNonAssocRing.{u1} E (NormedRing.toRing.{u1} E _inst_1)))))))) (unitary.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2)))) U A)) (Norm.norm.{u1} E (NormedRing.toNorm.{u1} E _inst_1) A)
Case conversion may be inaccurate. Consider using '#align cstar_ring.norm_unitary_smul CstarRing.norm_unitary_smul‚Çì'. -/
@[simp]
theorem norm_unitary_smul (U : unitary E) (A : E) : ‚ÄñU ‚Ä¢ A‚Äñ = ‚ÄñA‚Äñ :=
  norm_coe_unitary_mul U A
#align cstar_ring.norm_unitary_smul CstarRing.norm_unitary_smul

/- warning: cstar_ring.norm_mem_unitary_mul -> CstarRing.norm_mem_unitary_mul is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_1 : NormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))] [_inst_3 : CstarRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1) _inst_2] {U : E} (A : E), (Membership.Mem.{u1, u1} E (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) E (Submonoid.setLike.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1))))) U (unitary.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))) -> (Eq.{1} Real (Norm.norm.{u1} E (NormedRing.toHasNorm.{u1} E _inst_1) (HMul.hMul.{u1, u1, u1} E E E (instHMul.{u1} E (Distrib.toHasMul.{u1} E (Ring.toDistrib.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) U A)) (Norm.norm.{u1} E (NormedRing.toHasNorm.{u1} E _inst_1) A))
but is expected to have type
  forall {E : Type.{u1}} [_inst_1 : NormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))] [_inst_3 : CstarRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1) _inst_2] {U : E} (A : E), (Membership.mem.{u1, u1} E (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))))) E (Submonoid.instSetLikeSubmonoid.{u1} E (Monoid.toMulOneClass.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1))))))) U (unitary.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))) -> (Eq.{1} Real (Norm.norm.{u1} E (NormedRing.toNorm.{u1} E _inst_1) (HMul.hMul.{u1, u1, u1} E E E (instHMul.{u1} E (NonUnitalNonAssocRing.toMul.{u1} E (NonAssocRing.toNonUnitalNonAssocRing.{u1} E (Ring.toNonAssocRing.{u1} E (NormedRing.toRing.{u1} E _inst_1))))) U A)) (Norm.norm.{u1} E (NormedRing.toNorm.{u1} E _inst_1) A))
Case conversion may be inaccurate. Consider using '#align cstar_ring.norm_mem_unitary_mul CstarRing.norm_mem_unitary_mul‚Çì'. -/
theorem norm_mem_unitary_mul {U : E} (A : E) (hU : U ‚àà unitary E) : ‚ÄñU * A‚Äñ = ‚ÄñA‚Äñ :=
  norm_coe_unitary_mul ‚ü®U, hU‚ü© A
#align cstar_ring.norm_mem_unitary_mul CstarRing.norm_mem_unitary_mul

/- warning: cstar_ring.norm_mul_coe_unitary -> CstarRing.norm_mul_coe_unitary is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_1 : NormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))] [_inst_3 : CstarRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1) _inst_2] (A : E) (U : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) E (Submonoid.setLike.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1))))) (unitary.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))), Eq.{1} Real (Norm.norm.{u1} E (NormedRing.toHasNorm.{u1} E _inst_1) (HMul.hMul.{u1, u1, u1} E E E (instHMul.{u1} E (Distrib.toHasMul.{u1} E (Ring.toDistrib.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) A ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) E (Submonoid.setLike.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1))))) (unitary.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))) E (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) E (Submonoid.setLike.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1))))) (unitary.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))) E (CoeTC‚Çì.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) E (Submonoid.setLike.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1))))) (unitary.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))) E (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) E (Submonoid.setLike.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1))))) (unitary.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))) E (coeSubtype.{succ u1} E (fun (x : E) => Membership.Mem.{u1, u1} E (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) E (Submonoid.setLike.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1))))) x (unitary.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))))))) U))) (Norm.norm.{u1} E (NormedRing.toHasNorm.{u1} E _inst_1) A)
but is expected to have type
  forall {E : Type.{u1}} [_inst_1 : NormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))] [_inst_3 : CstarRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1) _inst_2] (A : E) (U : Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))))) E (Submonoid.instSetLikeSubmonoid.{u1} E (Monoid.toMulOneClass.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1))))))) x (unitary.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2)))), Eq.{1} Real (Norm.norm.{u1} E (NormedRing.toNorm.{u1} E _inst_1) (HMul.hMul.{u1, u1, u1} E E E (instHMul.{u1} E (NonUnitalNonAssocRing.toMul.{u1} E (NonAssocRing.toNonUnitalNonAssocRing.{u1} E (Ring.toNonAssocRing.{u1} E (NormedRing.toRing.{u1} E _inst_1))))) A (Subtype.val.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x (SetLike.coe.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))))) E (Submonoid.instSetLikeSubmonoid.{u1} E (Monoid.toMulOneClass.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))))) (unitary.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2)))) U))) (Norm.norm.{u1} E (NormedRing.toNorm.{u1} E _inst_1) A)
Case conversion may be inaccurate. Consider using '#align cstar_ring.norm_mul_coe_unitary CstarRing.norm_mul_coe_unitary‚Çì'. -/
@[simp]
theorem norm_mul_coe_unitary (A : E) (U : unitary E) : ‚ÄñA * U‚Äñ = ‚ÄñA‚Äñ :=
  calc
    _ = ‚Äñ((U : E)‚ãÜ * A‚ãÜ)‚ãÜ‚Äñ := by simp only [star_star, star_mul]
    _ = ‚Äñ(U : E)‚ãÜ * A‚ãÜ‚Äñ := by rw [norm_star]
    _ = ‚ÄñA‚ãÜ‚Äñ := (norm_mem_unitary_mul (star A) (unitary.star_mem U.Prop))
    _ = ‚ÄñA‚Äñ := norm_star _
    
#align cstar_ring.norm_mul_coe_unitary CstarRing.norm_mul_coe_unitary

/- warning: cstar_ring.norm_mul_mem_unitary -> CstarRing.norm_mul_mem_unitary is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_1 : NormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))] [_inst_3 : CstarRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1) _inst_2] (A : E) {U : E}, (Membership.Mem.{u1, u1} E (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) E (Submonoid.setLike.{u1} E (Monoid.toMulOneClass.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1))))) U (unitary.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))) -> (Eq.{1} Real (Norm.norm.{u1} E (NormedRing.toHasNorm.{u1} E _inst_1) (HMul.hMul.{u1, u1, u1} E E E (instHMul.{u1} E (Distrib.toHasMul.{u1} E (Ring.toDistrib.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) A U)) (Norm.norm.{u1} E (NormedRing.toHasNorm.{u1} E _inst_1) A))
but is expected to have type
  forall {E : Type.{u1}} [_inst_1 : NormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))] [_inst_3 : CstarRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1) _inst_2] (A : E) {U : E}, (Membership.mem.{u1, u1} E (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} E (Monoid.toMulOneClass.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))))) E (Submonoid.instSetLikeSubmonoid.{u1} E (Monoid.toMulOneClass.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1))))))) U (unitary.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) (StarRing.toStarSemigroup.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))) -> (Eq.{1} Real (Norm.norm.{u1} E (NormedRing.toNorm.{u1} E _inst_1) (HMul.hMul.{u1, u1, u1} E E E (instHMul.{u1} E (NonUnitalNonAssocRing.toMul.{u1} E (NonAssocRing.toNonUnitalNonAssocRing.{u1} E (Ring.toNonAssocRing.{u1} E (NormedRing.toRing.{u1} E _inst_1))))) A U)) (Norm.norm.{u1} E (NormedRing.toNorm.{u1} E _inst_1) A))
Case conversion may be inaccurate. Consider using '#align cstar_ring.norm_mul_mem_unitary CstarRing.norm_mul_mem_unitary‚Çì'. -/
theorem norm_mul_mem_unitary (A : E) {U : E} (hU : U ‚àà unitary E) : ‚ÄñA * U‚Äñ = ‚ÄñA‚Äñ :=
  norm_mul_coe_unitary A ‚ü®U, hU‚ü©
#align cstar_ring.norm_mul_mem_unitary CstarRing.norm_mul_mem_unitary

end Unital

end CstarRing

/- warning: is_self_adjoint.nnnorm_pow_two_pow -> IsSelfAdjoint.nnnorm_pow_two_pow is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_1 : NormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))] [_inst_3 : CstarRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1) _inst_2] {x : E}, (IsSelfAdjoint.{u1} E (InvolutiveStar.toHasStar.{u1} E (StarAddMonoid.toHasInvolutiveStar.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))) x) -> (forall (n : Nat), Eq.{1} NNReal (NNNorm.nnnorm.{u1} E (SeminormedAddGroup.toNNNorm.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} E (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) (HPow.hPow.{u1, 0, u1} E Nat E (instHPow.{u1, 0} E Nat (Monoid.Pow.{u1} E (Ring.toMonoid.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) x (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) n))) (HPow.hPow.{0, 0, 0} NNReal Nat NNReal (instHPow.{0, 0} NNReal Nat (Monoid.Pow.{0} NNReal (MonoidWithZero.toMonoid.{0} NNReal (Semiring.toMonoidWithZero.{0} NNReal NNReal.semiring)))) (NNNorm.nnnorm.{u1} E (SeminormedAddGroup.toNNNorm.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} E (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) x) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) n)))
but is expected to have type
  forall {E : Type.{u1}} [_inst_1 : NormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))] [_inst_3 : CstarRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1) _inst_2] {x : E}, (IsSelfAdjoint.{u1} E (InvolutiveStar.toStar.{u1} E (StarAddMonoid.toInvolutiveStar.{u1} E (AddMonoidWithOne.toAddMonoid.{u1} E (AddGroupWithOne.toAddMonoidWithOne.{u1} E (Ring.toAddGroupWithOne.{u1} E (NormedRing.toRing.{u1} E _inst_1)))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))) x) -> (forall (n : Nat), Eq.{1} NNReal (NNNorm.nnnorm.{u1} E (SeminormedAddGroup.toNNNorm.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} E (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) (HPow.hPow.{u1, 0, u1} E Nat E (instHPow.{u1, 0} E Nat (Monoid.Pow.{u1} E (MonoidWithZero.toMonoid.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E (NormedRing.toRing.{u1} E _inst_1)))))) x (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) n))) (HPow.hPow.{0, 0, 0} NNReal Nat NNReal (instHPow.{0, 0} NNReal Nat (Monoid.Pow.{0} NNReal (MonoidWithZero.toMonoid.{0} NNReal (Semiring.toMonoidWithZero.{0} NNReal instNNRealSemiring)))) (NNNorm.nnnorm.{u1} E (SeminormedAddGroup.toNNNorm.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} E (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) x) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) n)))
Case conversion may be inaccurate. Consider using '#align is_self_adjoint.nnnorm_pow_two_pow IsSelfAdjoint.nnnorm_pow_two_pow‚Çì'. -/
theorem IsSelfAdjoint.nnnorm_pow_two_pow [NormedRing E] [StarRing E] [CstarRing E] {x : E}
    (hx : IsSelfAdjoint x) (n : ‚Ñï) : ‚Äñx ^ 2 ^ n‚Äñ‚Çä = ‚Äñx‚Äñ‚Çä ^ 2 ^ n :=
  by
  induction' n with k hk
  ¬∑ simp only [pow_zero, pow_one]
  ¬∑ rw [pow_succ, pow_mul', sq]
    nth_rw 1 [‚Üê self_adjoint.mem_iff.mp hx]
    rw [‚Üê star_pow, CstarRing.nnnorm_star_mul_self, ‚Üê sq, hk, pow_mul']
#align is_self_adjoint.nnnorm_pow_two_pow IsSelfAdjoint.nnnorm_pow_two_pow

/- warning: self_adjoint.nnnorm_pow_two_pow -> selfAdjoint.nnnorm_pow_two_pow is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_1 : NormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))] [_inst_3 : CstarRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1) _inst_2] (x : coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) E (AddSubgroup.setLike.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))))) (selfAdjoint.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))) (n : Nat), Eq.{1} NNReal (NNNorm.nnnorm.{u1} (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) E (AddSubgroup.setLike.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))))) (selfAdjoint.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))) (SeminormedAddGroup.toNNNorm.{u1} (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) E (AddSubgroup.setLike.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))))) (selfAdjoint.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))) (AddSubgroup.seminormedAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} E (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))) (selfAdjoint.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2)))) (HPow.hPow.{u1, 0, u1} (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) E (AddSubgroup.setLike.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))))) (selfAdjoint.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))) Nat (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) E (AddSubgroup.setLike.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))))) (selfAdjoint.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))) (instHPow.{u1, 0} (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) E (AddSubgroup.setLike.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))))) (selfAdjoint.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))) Nat (selfAdjoint.Nat.hasPow.{u1} E (NormedRing.toRing.{u1} E _inst_1) _inst_2)) x (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) n))) (HPow.hPow.{0, 0, 0} NNReal Nat NNReal (instHPow.{0, 0} NNReal Nat (Monoid.Pow.{0} NNReal (MonoidWithZero.toMonoid.{0} NNReal (Semiring.toMonoidWithZero.{0} NNReal NNReal.semiring)))) (NNNorm.nnnorm.{u1} (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) E (AddSubgroup.setLike.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))))) (selfAdjoint.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))) (SeminormedAddGroup.toNNNorm.{u1} (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) E (AddSubgroup.setLike.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))))) (selfAdjoint.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2))) (AddSubgroup.seminormedAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} E (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))) (selfAdjoint.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2)))) x) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) n))
but is expected to have type
  forall {E : Type.{u1}} [_inst_1 : NormedRing.{u1} E] [_inst_2 : StarRing.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))] [_inst_3 : CstarRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1) _inst_2] (x : Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (AddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) (SetLike.instMembership.{u1, u1} (AddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) E (AddSubgroup.instSetLikeAddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))))) x (selfAdjoint.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2)))) (n : Nat), Eq.{1} NNReal (NNNorm.nnnorm.{u1} (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (AddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) (SetLike.instMembership.{u1, u1} (AddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) E (AddSubgroup.instSetLikeAddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))))) x (selfAdjoint.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2)))) (SeminormedAddGroup.toNNNorm.{u1} (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (AddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) (SetLike.instMembership.{u1, u1} (AddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) E (AddSubgroup.instSetLikeAddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))))) x (selfAdjoint.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2)))) (AddSubgroup.seminormedAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} E (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))) (selfAdjoint.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2)))) (HPow.hPow.{u1, 0, u1} (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (AddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) (SetLike.instMembership.{u1, u1} (AddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) E (AddSubgroup.instSetLikeAddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))))) x (selfAdjoint.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2)))) Nat (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (AddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) (SetLike.instMembership.{u1, u1} (AddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) E (AddSubgroup.instSetLikeAddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))))) x (selfAdjoint.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2)))) (instHPow.{u1, 0} (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (AddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) (SetLike.instMembership.{u1, u1} (AddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) E (AddSubgroup.instSetLikeAddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))))) x (selfAdjoint.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2)))) Nat (selfAdjoint.instPowSubtypeMemAddSubgroupToAddGroupToAddGroupWithOneInstMembershipInstSetLikeAddSubgroupSelfAdjointToStarAddMonoidToNonUnitalSemiringToNonUnitalRingNat.{u1} E (NormedRing.toRing.{u1} E _inst_1) _inst_2)) x (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) n))) (HPow.hPow.{0, 0, 0} NNReal Nat NNReal (instHPow.{0, 0} NNReal Nat (Monoid.Pow.{0} NNReal (MonoidWithZero.toMonoid.{0} NNReal (Semiring.toMonoidWithZero.{0} NNReal instNNRealSemiring)))) (NNNorm.nnnorm.{u1} (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (AddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) (SetLike.instMembership.{u1, u1} (AddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) E (AddSubgroup.instSetLikeAddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))))) x (selfAdjoint.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2)))) (SeminormedAddGroup.toNNNorm.{u1} (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (AddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) (SetLike.instMembership.{u1, u1} (AddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))))) E (AddSubgroup.instSetLikeAddSubgroup.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))))) x (selfAdjoint.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2)))) (AddSubgroup.seminormedAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} E (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))) (selfAdjoint.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E (NonUnitalNormedRing.toNormedAddCommGroup.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1)))) (StarRing.toStarAddMonoid.{u1} E (NonUnitalRing.toNonUnitalSemiring.{u1} E (NonUnitalNormedRing.toNonUnitalRing.{u1} E (NormedRing.toNonUnitalNormedRing.{u1} E _inst_1))) _inst_2)))) x) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) n))
Case conversion may be inaccurate. Consider using '#align self_adjoint.nnnorm_pow_two_pow selfAdjoint.nnnorm_pow_two_pow‚Çì'. -/
theorem selfAdjoint.nnnorm_pow_two_pow [NormedRing E] [StarRing E] [CstarRing E] (x : selfAdjoint E)
    (n : ‚Ñï) : ‚Äñx ^ 2 ^ n‚Äñ‚Çä = ‚Äñx‚Äñ‚Çä ^ 2 ^ n :=
  x.Prop.nnnorm_pow_two_pow _
#align self_adjoint.nnnorm_pow_two_pow selfAdjoint.nnnorm_pow_two_pow

section star‚Çó·µ¢

variable [CommSemiring ùïú] [StarRing ùïú]

variable [SeminormedAddCommGroup E] [StarAddMonoid E] [NormedStarGroup E]

variable [Module ùïú E] [StarModule ùïú E]

variable (ùïú)

#print star‚Çó·µ¢ /-
/-- `star` bundled as a linear isometric equivalence -/
def star‚Çó·µ¢ : E ‚âÉ‚Çó·µ¢‚ãÜ[ùïú] E :=
  { starAddEquiv with
    map_smul' := star_smul
    norm_map' := norm_star }
#align star‚Çó·µ¢ star‚Çó·µ¢
-/

variable {ùïú}

/- warning: coe_star‚Çó·µ¢ -> coe_star‚Çó·µ¢ is a dubious translation:
lean 3 declaration is
  forall {ùïú : Type.{u1}} {E : Type.{u2}} [_inst_1 : CommSemiring.{u1} ùïú] [_inst_2 : StarRing.{u1} ùïú (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} ùïú (CommSemiring.toNonUnitalCommSemiring.{u1} ùïú _inst_1))] [_inst_3 : SeminormedAddCommGroup.{u2} E] [_inst_4 : StarAddMonoid.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (SeminormedAddGroup.toAddGroup.{u2} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E _inst_3))))] [_inst_5 : NormedStarGroup.{u2} E _inst_3 _inst_4] [_inst_6 : Module.{u1, u2} ùïú E (CommSemiring.toSemiring.{u1} ùïú _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3))] [_inst_7 : StarModule.{u1, u2} ùïú E (InvolutiveStar.toHasStar.{u1} ùïú (StarAddMonoid.toHasInvolutiveStar.{u1} ùïú (AddCommMonoid.toAddMonoid.{u1} ùïú (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ùïú (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} ùïú (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} ùïú (CommSemiring.toNonUnitalCommSemiring.{u1} ùïú _inst_1))))) (StarRing.toStarAddMonoid.{u1} ùïú (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} ùïú (CommSemiring.toNonUnitalCommSemiring.{u1} ùïú _inst_1)) _inst_2))) (InvolutiveStar.toHasStar.{u2} E (StarAddMonoid.toHasInvolutiveStar.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (SeminormedAddGroup.toAddGroup.{u2} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E _inst_3)))) _inst_4)) (SMulZeroClass.toHasSmul.{u1, u2} ùïú E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ùïú E (MulZeroClass.toHasZero.{u1} ùïú (MulZeroOneClass.toMulZeroClass.{u1} ùïú (MonoidWithZero.toMulZeroOneClass.{u1} ùïú (Semiring.toMonoidWithZero.{u1} ùïú (CommSemiring.toSemiring.{u1} ùïú _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ùïú E (Semiring.toMonoidWithZero.{u1} ùïú (CommSemiring.toSemiring.{u1} ùïú _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3))))) (Module.toMulActionWithZero.{u1, u2} ùïú E (CommSemiring.toSemiring.{u1} ùïú _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3)) _inst_6))))], Eq.{succ u2} ((fun (_x : LinearIsometryEquiv.{u1, u1, u2, u2} ùïú ùïú (CommSemiring.toSemiring.{u1} ùïú _inst_1) (CommSemiring.toSemiring.{u1} ùïú _inst_1) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.StarRingEnd.ringHomInvPair.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.StarRingEnd.ringHomInvPair.{u1} ùïú _inst_1 _inst_2) E E _inst_3 _inst_3 _inst_6 _inst_6) => E -> E) (star‚Çó·µ¢.{u1, u2} ùïú E _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)) (coeFn.{succ u2, succ u2} (LinearIsometryEquiv.{u1, u1, u2, u2} ùïú ùïú (CommSemiring.toSemiring.{u1} ùïú _inst_1) (CommSemiring.toSemiring.{u1} ùïú _inst_1) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.StarRingEnd.ringHomInvPair.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.StarRingEnd.ringHomInvPair.{u1} ùïú _inst_1 _inst_2) E E _inst_3 _inst_3 _inst_6 _inst_6) (fun (_x : LinearIsometryEquiv.{u1, u1, u2, u2} ùïú ùïú (CommSemiring.toSemiring.{u1} ùïú _inst_1) (CommSemiring.toSemiring.{u1} ùïú _inst_1) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.StarRingEnd.ringHomInvPair.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.StarRingEnd.ringHomInvPair.{u1} ùïú _inst_1 _inst_2) E E _inst_3 _inst_3 _inst_6 _inst_6) => E -> E) (LinearIsometryEquiv.hasCoeToFun.{u1, u1, u2, u2} ùïú ùïú E E (CommSemiring.toSemiring.{u1} ùïú _inst_1) (CommSemiring.toSemiring.{u1} ùïú _inst_1) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.StarRingEnd.ringHomInvPair.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.StarRingEnd.ringHomInvPair.{u1} ùïú _inst_1 _inst_2) _inst_3 _inst_3 _inst_6 _inst_6) (star‚Çó·µ¢.{u1, u2} ùïú E _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)) (Star.star.{u2} E (InvolutiveStar.toHasStar.{u2} E (StarAddMonoid.toHasInvolutiveStar.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (SeminormedAddGroup.toAddGroup.{u2} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E _inst_3)))) _inst_4)))
but is expected to have type
  forall {ùïú : Type.{u1}} {E : Type.{u2}} [_inst_1 : CommSemiring.{u1} ùïú] [_inst_2 : StarRing.{u1} ùïú (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} ùïú (CommSemiring.toNonUnitalCommSemiring.{u1} ùïú _inst_1))] [_inst_3 : SeminormedAddCommGroup.{u2} E] [_inst_4 : StarAddMonoid.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (SeminormedAddGroup.toAddGroup.{u2} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E _inst_3))))] [_inst_5 : NormedStarGroup.{u2} E _inst_3 _inst_4] [_inst_6 : Module.{u1, u2} ùïú E (CommSemiring.toSemiring.{u1} ùïú _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3))] [_inst_7 : StarModule.{u1, u2} ùïú E (InvolutiveStar.toStar.{u1} ùïú (StarAddMonoid.toInvolutiveStar.{u1} ùïú (AddMonoidWithOne.toAddMonoid.{u1} ùïú (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} ùïú (NonAssocSemiring.toAddCommMonoidWithOne.{u1} ùïú (Semiring.toNonAssocSemiring.{u1} ùïú (CommSemiring.toSemiring.{u1} ùïú _inst_1))))) (StarRing.toStarAddMonoid.{u1} ùïú (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} ùïú (CommSemiring.toNonUnitalCommSemiring.{u1} ùïú _inst_1)) _inst_2))) (InvolutiveStar.toStar.{u2} E (StarAddMonoid.toInvolutiveStar.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (SeminormedAddGroup.toAddGroup.{u2} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E _inst_3)))) _inst_4)) (SMulZeroClass.toSMul.{u1, u2} ùïú E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3)))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ùïú E (CommMonoidWithZero.toZero.{u1} ùïú (CommSemiring.toCommMonoidWithZero.{u1} ùïú _inst_1)) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ùïú E (Semiring.toMonoidWithZero.{u1} ùïú (CommSemiring.toSemiring.{u1} ùïú _inst_1)) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3)))))) (Module.toMulActionWithZero.{u1, u2} ùïú E (CommSemiring.toSemiring.{u1} ùïú _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3)) _inst_6))))], Eq.{succ u2} (forall (a : E), (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : E) => E) a) (FunLike.coe.{succ u2, succ u2, succ u2} (LinearIsometryEquiv.{u1, u1, u2, u2} ùïú ùïú (CommSemiring.toSemiring.{u1} ùïú _inst_1) (CommSemiring.toSemiring.{u1} ùïú _inst_1) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.instRingHomInvPairToSemiringStarRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.instRingHomInvPairToSemiringStarRingEnd.{u1} ùïú _inst_1 _inst_2) E E _inst_3 _inst_3 _inst_6 _inst_6) E (fun (_x : E) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : E) => E) _x) (ContinuousMapClass.toFunLike.{u2, u2, u2} (LinearIsometryEquiv.{u1, u1, u2, u2} ùïú ùïú (CommSemiring.toSemiring.{u1} ùïú _inst_1) (CommSemiring.toSemiring.{u1} ùïú _inst_1) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.instRingHomInvPairToSemiringStarRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.instRingHomInvPairToSemiringStarRingEnd.{u1} ùïú _inst_1 _inst_2) E E _inst_3 _inst_3 _inst_6 _inst_6) E E (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_3))) (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_3))) (ContinuousSemilinearMapClass.toContinuousMapClass.{u2, u1, u1, u2, u2} (LinearIsometryEquiv.{u1, u1, u2, u2} ùïú ùïú (CommSemiring.toSemiring.{u1} ùïú _inst_1) (CommSemiring.toSemiring.{u1} ùïú _inst_1) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.instRingHomInvPairToSemiringStarRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.instRingHomInvPairToSemiringStarRingEnd.{u1} ùïú _inst_1 _inst_2) E E _inst_3 _inst_3 _inst_6 _inst_6) ùïú ùïú (CommSemiring.toSemiring.{u1} ùïú _inst_1) (CommSemiring.toSemiring.{u1} ùïú _inst_1) (starRingEnd.{u1} ùïú _inst_1 _inst_2) E (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3)) E (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3)) _inst_6 _inst_6 (SemilinearIsometryClass.instContinuousSemilinearMapClassToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToAddCommMonoidToAddCommGroupToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToAddCommMonoidToAddCommGroup.{u1, u1, u2, u2, u2} ùïú ùïú E E (LinearIsometryEquiv.{u1, u1, u2, u2} ùïú ùïú (CommSemiring.toSemiring.{u1} ùïú _inst_1) (CommSemiring.toSemiring.{u1} ùïú _inst_1) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.instRingHomInvPairToSemiringStarRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.instRingHomInvPairToSemiringStarRingEnd.{u1} ùïú _inst_1 _inst_2) E E _inst_3 _inst_3 _inst_6 _inst_6) (CommSemiring.toSemiring.{u1} ùïú _inst_1) (CommSemiring.toSemiring.{u1} ùïú _inst_1) (starRingEnd.{u1} ùïú _inst_1 _inst_2) _inst_3 _inst_3 _inst_6 _inst_6 (SemilinearIsometryEquivClass.instSemilinearIsometryClass.{u1, u1, u2, u2, u2} ùïú ùïú E E (LinearIsometryEquiv.{u1, u1, u2, u2} ùïú ùïú (CommSemiring.toSemiring.{u1} ùïú _inst_1) (CommSemiring.toSemiring.{u1} ùïú _inst_1) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.instRingHomInvPairToSemiringStarRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.instRingHomInvPairToSemiringStarRingEnd.{u1} ùïú _inst_1 _inst_2) E E _inst_3 _inst_3 _inst_6 _inst_6) (CommSemiring.toSemiring.{u1} ùïú _inst_1) (CommSemiring.toSemiring.{u1} ùïú _inst_1) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.instRingHomInvPairToSemiringStarRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.instRingHomInvPairToSemiringStarRingEnd.{u1} ùïú _inst_1 _inst_2) _inst_3 _inst_3 _inst_6 _inst_6 (LinearIsometryEquiv.instSemilinearIsometryEquivClassLinearIsometryEquiv.{u1, u1, u2, u2} ùïú ùïú E E (CommSemiring.toSemiring.{u1} ùïú _inst_1) (CommSemiring.toSemiring.{u1} ùïú _inst_1) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.instRingHomInvPairToSemiringStarRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.instRingHomInvPairToSemiringStarRingEnd.{u1} ùïú _inst_1 _inst_2) _inst_3 _inst_3 _inst_6 _inst_6))))) (star‚Çó·µ¢.{u1, u2} ùïú E _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)) (Star.star.{u2} E (InvolutiveStar.toStar.{u2} E (StarAddMonoid.toInvolutiveStar.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (SeminormedAddGroup.toAddGroup.{u2} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E _inst_3)))) _inst_4)))
Case conversion may be inaccurate. Consider using '#align coe_star‚Çó·µ¢ coe_star‚Çó·µ¢‚Çì'. -/
@[simp]
theorem coe_star‚Çó·µ¢ : (star‚Çó·µ¢ ùïú : E ‚Üí E) = star :=
  rfl
#align coe_star‚Çó·µ¢ coe_star‚Çó·µ¢

/- warning: star‚Çó·µ¢_apply -> star‚Çó·µ¢_apply is a dubious translation:
lean 3 declaration is
  forall {ùïú : Type.{u1}} {E : Type.{u2}} [_inst_1 : CommSemiring.{u1} ùïú] [_inst_2 : StarRing.{u1} ùïú (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} ùïú (CommSemiring.toNonUnitalCommSemiring.{u1} ùïú _inst_1))] [_inst_3 : SeminormedAddCommGroup.{u2} E] [_inst_4 : StarAddMonoid.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (SeminormedAddGroup.toAddGroup.{u2} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E _inst_3))))] [_inst_5 : NormedStarGroup.{u2} E _inst_3 _inst_4] [_inst_6 : Module.{u1, u2} ùïú E (CommSemiring.toSemiring.{u1} ùïú _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3))] [_inst_7 : StarModule.{u1, u2} ùïú E (InvolutiveStar.toHasStar.{u1} ùïú (StarAddMonoid.toHasInvolutiveStar.{u1} ùïú (AddCommMonoid.toAddMonoid.{u1} ùïú (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ùïú (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} ùïú (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} ùïú (CommSemiring.toNonUnitalCommSemiring.{u1} ùïú _inst_1))))) (StarRing.toStarAddMonoid.{u1} ùïú (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} ùïú (CommSemiring.toNonUnitalCommSemiring.{u1} ùïú _inst_1)) _inst_2))) (InvolutiveStar.toHasStar.{u2} E (StarAddMonoid.toHasInvolutiveStar.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (SeminormedAddGroup.toAddGroup.{u2} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E _inst_3)))) _inst_4)) (SMulZeroClass.toHasSmul.{u1, u2} ùïú E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ùïú E (MulZeroClass.toHasZero.{u1} ùïú (MulZeroOneClass.toMulZeroClass.{u1} ùïú (MonoidWithZero.toMulZeroOneClass.{u1} ùïú (Semiring.toMonoidWithZero.{u1} ùïú (CommSemiring.toSemiring.{u1} ùïú _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ùïú E (Semiring.toMonoidWithZero.{u1} ùïú (CommSemiring.toSemiring.{u1} ùïú _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3))))) (Module.toMulActionWithZero.{u1, u2} ùïú E (CommSemiring.toSemiring.{u1} ùïú _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3)) _inst_6))))] {x : E}, Eq.{succ u2} E (coeFn.{succ u2, succ u2} (LinearIsometryEquiv.{u1, u1, u2, u2} ùïú ùïú (CommSemiring.toSemiring.{u1} ùïú _inst_1) (CommSemiring.toSemiring.{u1} ùïú _inst_1) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.StarRingEnd.ringHomInvPair.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.StarRingEnd.ringHomInvPair.{u1} ùïú _inst_1 _inst_2) E E _inst_3 _inst_3 _inst_6 _inst_6) (fun (_x : LinearIsometryEquiv.{u1, u1, u2, u2} ùïú ùïú (CommSemiring.toSemiring.{u1} ùïú _inst_1) (CommSemiring.toSemiring.{u1} ùïú _inst_1) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.StarRingEnd.ringHomInvPair.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.StarRingEnd.ringHomInvPair.{u1} ùïú _inst_1 _inst_2) E E _inst_3 _inst_3 _inst_6 _inst_6) => E -> E) (LinearIsometryEquiv.hasCoeToFun.{u1, u1, u2, u2} ùïú ùïú E E (CommSemiring.toSemiring.{u1} ùïú _inst_1) (CommSemiring.toSemiring.{u1} ùïú _inst_1) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.StarRingEnd.ringHomInvPair.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.StarRingEnd.ringHomInvPair.{u1} ùïú _inst_1 _inst_2) _inst_3 _inst_3 _inst_6 _inst_6) (star‚Çó·µ¢.{u1, u2} ùïú E _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) x) (Star.star.{u2} E (InvolutiveStar.toHasStar.{u2} E (StarAddMonoid.toHasInvolutiveStar.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (SeminormedAddGroup.toAddGroup.{u2} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E _inst_3)))) _inst_4)) x)
but is expected to have type
  forall {ùïú : Type.{u1}} {E : Type.{u2}} [_inst_1 : CommSemiring.{u1} ùïú] [_inst_2 : StarRing.{u1} ùïú (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} ùïú (CommSemiring.toNonUnitalCommSemiring.{u1} ùïú _inst_1))] [_inst_3 : SeminormedAddCommGroup.{u2} E] [_inst_4 : StarAddMonoid.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (SeminormedAddGroup.toAddGroup.{u2} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E _inst_3))))] [_inst_5 : NormedStarGroup.{u2} E _inst_3 _inst_4] [_inst_6 : Module.{u1, u2} ùïú E (CommSemiring.toSemiring.{u1} ùïú _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3))] [_inst_7 : StarModule.{u1, u2} ùïú E (InvolutiveStar.toStar.{u1} ùïú (StarAddMonoid.toInvolutiveStar.{u1} ùïú (AddMonoidWithOne.toAddMonoid.{u1} ùïú (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} ùïú (NonAssocSemiring.toAddCommMonoidWithOne.{u1} ùïú (Semiring.toNonAssocSemiring.{u1} ùïú (CommSemiring.toSemiring.{u1} ùïú _inst_1))))) (StarRing.toStarAddMonoid.{u1} ùïú (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} ùïú (CommSemiring.toNonUnitalCommSemiring.{u1} ùïú _inst_1)) _inst_2))) (InvolutiveStar.toStar.{u2} E (StarAddMonoid.toInvolutiveStar.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (SeminormedAddGroup.toAddGroup.{u2} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E _inst_3)))) _inst_4)) (SMulZeroClass.toSMul.{u1, u2} ùïú E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3)))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ùïú E (CommMonoidWithZero.toZero.{u1} ùïú (CommSemiring.toCommMonoidWithZero.{u1} ùïú _inst_1)) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ùïú E (Semiring.toMonoidWithZero.{u1} ùïú (CommSemiring.toSemiring.{u1} ùïú _inst_1)) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3)))))) (Module.toMulActionWithZero.{u1, u2} ùïú E (CommSemiring.toSemiring.{u1} ùïú _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3)) _inst_6))))] {x : E}, Eq.{succ u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : E) => E) x) (FunLike.coe.{succ u2, succ u2, succ u2} (LinearIsometryEquiv.{u1, u1, u2, u2} ùïú ùïú (CommSemiring.toSemiring.{u1} ùïú _inst_1) (CommSemiring.toSemiring.{u1} ùïú _inst_1) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.instRingHomInvPairToSemiringStarRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.instRingHomInvPairToSemiringStarRingEnd.{u1} ùïú _inst_1 _inst_2) E E _inst_3 _inst_3 _inst_6 _inst_6) E (fun (_x : E) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : E) => E) _x) (ContinuousMapClass.toFunLike.{u2, u2, u2} (LinearIsometryEquiv.{u1, u1, u2, u2} ùïú ùïú (CommSemiring.toSemiring.{u1} ùïú _inst_1) (CommSemiring.toSemiring.{u1} ùïú _inst_1) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.instRingHomInvPairToSemiringStarRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.instRingHomInvPairToSemiringStarRingEnd.{u1} ùïú _inst_1 _inst_2) E E _inst_3 _inst_3 _inst_6 _inst_6) E E (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_3))) (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_3))) (ContinuousSemilinearMapClass.toContinuousMapClass.{u2, u1, u1, u2, u2} (LinearIsometryEquiv.{u1, u1, u2, u2} ùïú ùïú (CommSemiring.toSemiring.{u1} ùïú _inst_1) (CommSemiring.toSemiring.{u1} ùïú _inst_1) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.instRingHomInvPairToSemiringStarRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.instRingHomInvPairToSemiringStarRingEnd.{u1} ùïú _inst_1 _inst_2) E E _inst_3 _inst_3 _inst_6 _inst_6) ùïú ùïú (CommSemiring.toSemiring.{u1} ùïú _inst_1) (CommSemiring.toSemiring.{u1} ùïú _inst_1) (starRingEnd.{u1} ùïú _inst_1 _inst_2) E (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3)) E (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3)) _inst_6 _inst_6 (SemilinearIsometryClass.instContinuousSemilinearMapClassToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToAddCommMonoidToAddCommGroupToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToAddCommMonoidToAddCommGroup.{u1, u1, u2, u2, u2} ùïú ùïú E E (LinearIsometryEquiv.{u1, u1, u2, u2} ùïú ùïú (CommSemiring.toSemiring.{u1} ùïú _inst_1) (CommSemiring.toSemiring.{u1} ùïú _inst_1) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.instRingHomInvPairToSemiringStarRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.instRingHomInvPairToSemiringStarRingEnd.{u1} ùïú _inst_1 _inst_2) E E _inst_3 _inst_3 _inst_6 _inst_6) (CommSemiring.toSemiring.{u1} ùïú _inst_1) (CommSemiring.toSemiring.{u1} ùïú _inst_1) (starRingEnd.{u1} ùïú _inst_1 _inst_2) _inst_3 _inst_3 _inst_6 _inst_6 (SemilinearIsometryEquivClass.instSemilinearIsometryClass.{u1, u1, u2, u2, u2} ùïú ùïú E E (LinearIsometryEquiv.{u1, u1, u2, u2} ùïú ùïú (CommSemiring.toSemiring.{u1} ùïú _inst_1) (CommSemiring.toSemiring.{u1} ùïú _inst_1) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.instRingHomInvPairToSemiringStarRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.instRingHomInvPairToSemiringStarRingEnd.{u1} ùïú _inst_1 _inst_2) E E _inst_3 _inst_3 _inst_6 _inst_6) (CommSemiring.toSemiring.{u1} ùïú _inst_1) (CommSemiring.toSemiring.{u1} ùïú _inst_1) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.instRingHomInvPairToSemiringStarRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.instRingHomInvPairToSemiringStarRingEnd.{u1} ùïú _inst_1 _inst_2) _inst_3 _inst_3 _inst_6 _inst_6 (LinearIsometryEquiv.instSemilinearIsometryEquivClassLinearIsometryEquiv.{u1, u1, u2, u2} ùïú ùïú E E (CommSemiring.toSemiring.{u1} ùïú _inst_1) (CommSemiring.toSemiring.{u1} ùïú _inst_1) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (starRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.instRingHomInvPairToSemiringStarRingEnd.{u1} ùïú _inst_1 _inst_2) (RingHomInvPair.instRingHomInvPairToSemiringStarRingEnd.{u1} ùïú _inst_1 _inst_2) _inst_3 _inst_3 _inst_6 _inst_6))))) (star‚Çó·µ¢.{u1, u2} ùïú E _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) x) (Star.star.{u2} E (InvolutiveStar.toStar.{u2} E (StarAddMonoid.toInvolutiveStar.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (SeminormedAddGroup.toAddGroup.{u2} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E _inst_3)))) _inst_4)) x)
Case conversion may be inaccurate. Consider using '#align star‚Çó·µ¢_apply star‚Çó·µ¢_apply‚Çì'. -/
theorem star‚Çó·µ¢_apply {x : E} : star‚Çó·µ¢ ùïú x = star x :=
  rfl
#align star‚Çó·µ¢_apply star‚Çó·µ¢_apply

end star‚Çó·µ¢

namespace StarSubalgebra

#print StarSubalgebra.toNormedAlgebra /-
instance toNormedAlgebra {ùïú A : Type _} [NormedField ùïú] [StarRing ùïú] [SeminormedRing A] [StarRing A]
    [NormedAlgebra ùïú A] [StarModule ùïú A] (S : StarSubalgebra ùïú A) : NormedAlgebra ùïú S :=
  @NormedAlgebra.induced _ ùïú S A _ (SubringClass.toRing S) S.Algebra _ _ _ S.Subtype
#align star_subalgebra.to_normed_algebra StarSubalgebra.toNormedAlgebra
-/

#print StarSubalgebra.to_cstarRing /-
instance to_cstarRing {R A} [CommRing R] [StarRing R] [NormedRing A] [StarRing A] [CstarRing A]
    [Algebra R A] [StarModule R A] (S : StarSubalgebra R A) : CstarRing S
    where norm_star_mul_self x := @CstarRing.norm_star_mul_self A _ _ _ x
#align star_subalgebra.to_cstar_ring StarSubalgebra.to_cstarRing
-/

end StarSubalgebra

