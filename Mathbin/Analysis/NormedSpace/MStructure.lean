/-
Copyright (c) 2022 Christopher Hoskin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Christopher Hoskin

! This file was ported from Lean 3 source module analysis.normed_space.M_structure
! leanprover-community/mathlib commit 17ef379e997badd73e5eabb4d38f11919ab3c4b3
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Ring.Idempotents
import Mathbin.Tactic.NoncommRing
import Mathbin.Analysis.Normed.Group.Basic

/-!
# M-structure

A projection P on a normed space X is said to be an L-projection (`is_Lprojection`) if, for all `x`
in `X`,
$\|x\| = \|P x\| + \|(1 - P) x\|$.

A projection P on a normed space X is said to be an M-projection if, for all `x` in `X`,
$\|x\| = max(\|P x\|,\|(1 - P) x\|)$.

The L-projections on `X` form a Boolean algebra (`is_Lprojection.subtype.boolean_algebra`).

## TODO (Motivational background)

The M-projections on a normed space form a Boolean algebra.

The range of an L-projection on a normed space `X` is said to be an L-summand of `X`. The range of
an M-projection is said to be an M-summand of `X`.

When `X` is a Banach space, the Boolean algebra of L-projections is complete. Let `X` be a normed
space with dual `X^*`. A closed subspace `M` of `X` is said to be an M-ideal if the topological
annihilator `M^∘` is an L-summand of `X^*`.

M-ideal, M-summands and L-summands were introduced by Alfsen and Effros in [alfseneffros1972] to
study the structure of general Banach spaces. When `A` is a JB*-triple, the M-ideals of `A` are
exactly the norm-closed ideals of `A`. When `A` is a JBW*-triple with predual `X`, the M-summands of
`A` are exactly the weak*-closed ideals, and their pre-duals can be identified with the L-summands
of `X`. In the special case when `A` is a C*-algebra, the M-ideals are exactly the norm-closed
two-sided ideals of `A`, when `A` is also a W*-algebra the M-summands are exactly the weak*-closed
two-sided ideals of `A`.

## Implementation notes

The approach to showing that the L-projections form a Boolean algebra is inspired by
`measure_theory.measurable_space`.

Instead of using `P : X →L[𝕜] X` to represent projections, we use an arbitrary ring `M` with a
faithful action on `X`. `continuous_linear_map.apply_module` can be used to recover the `X →L[𝕜] X`
special case.

## References

* [Behrends, M-structure and the Banach-Stone Theorem][behrends1979]
* [Harmand, Werner, Werner, M-ideals in Banach spaces and Banach algebras][harmandwernerwerner1993]

## Tags

M-summand, M-projection, L-summand, L-projection, M-ideal, M-structure

-/


variable (X : Type _) [NormedAddCommGroup X]

variable {M : Type} [Ring M] [Module M X]

#print IsLprojection /-
/-- A projection on a normed space `X` is said to be an L-projection if, for all `x` in `X`,
$\|x\| = \|P x\| + \|(1 - P) x\|$.

Note that we write `P • x` instead of `P x` for reasons described in the module docstring.
-/
structure IsLprojection (P : M) : Prop where
  proj : IsIdempotentElem P
  Lnorm : ∀ x : X, ‖x‖ = ‖P • x‖ + ‖(1 - P) • x‖
#align is_Lprojection IsLprojection
-/

#print IsMprojection /-
/-- A projection on a normed space `X` is said to be an M-projection if, for all `x` in `X`,
$\|x\| = max(\|P x\|,\|(1 - P) x\|)$.

Note that we write `P • x` instead of `P x` for reasons described in the module docstring.
-/
structure IsMprojection (P : M) : Prop where
  proj : IsIdempotentElem P
  Mnorm : ∀ x : X, ‖x‖ = max ‖P • x‖ ‖(1 - P) • x‖
#align is_Mprojection IsMprojection
-/

variable {X}

namespace IsLprojection

/- warning: is_Lprojection.Lcomplement -> IsLprojection.Lcomplement is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} [_inst_1 : NormedAddCommGroup.{u1} X] {M : Type} [_inst_2 : Ring.{0} M] [_inst_3 : Module.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))] {P : M}, (IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) -> (IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 (HSub.hSub.{0, 0, 0} M M M (instHSub.{0} M (SubNegMonoid.toHasSub.{0} M (AddGroup.toSubNegMonoid.{0} M (AddGroupWithOne.toAddGroup.{0} M (NonAssocRing.toAddGroupWithOne.{0} M (Ring.toNonAssocRing.{0} M _inst_2)))))) (OfNat.ofNat.{0} M 1 (OfNat.mk.{0} M 1 (One.one.{0} M (AddMonoidWithOne.toOne.{0} M (AddGroupWithOne.toAddMonoidWithOne.{0} M (NonAssocRing.toAddGroupWithOne.{0} M (Ring.toNonAssocRing.{0} M _inst_2))))))) P))
but is expected to have type
  forall {X : Type.{u1}} [_inst_1 : NormedAddCommGroup.{u1} X] {M : Type} [_inst_2 : Ring.{0} M] [_inst_3 : Module.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))] {P : M}, (IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) -> (IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 (HSub.hSub.{0, 0, 0} M M M (instHSub.{0} M (Ring.toSub.{0} M _inst_2)) (OfNat.ofNat.{0} M 1 (One.toOfNat1.{0} M (NonAssocRing.toOne.{0} M (Ring.toNonAssocRing.{0} M _inst_2)))) P))
Case conversion may be inaccurate. Consider using '#align is_Lprojection.Lcomplement IsLprojection.Lcomplementₓ'. -/
theorem Lcomplement {P : M} (h : IsLprojection X P) : IsLprojection X (1 - P) :=
  ⟨h.proj.one_sub, fun x => by
    rw [add_comm, sub_sub_cancel]
    exact h.Lnorm x⟩
#align is_Lprojection.Lcomplement IsLprojection.Lcomplement

/- warning: is_Lprojection.Lcomplement_iff -> IsLprojection.Lcomplement_iff is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} [_inst_1 : NormedAddCommGroup.{u1} X] {M : Type} [_inst_2 : Ring.{0} M] [_inst_3 : Module.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))] (P : M), Iff (IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) (IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 (HSub.hSub.{0, 0, 0} M M M (instHSub.{0} M (SubNegMonoid.toHasSub.{0} M (AddGroup.toSubNegMonoid.{0} M (AddGroupWithOne.toAddGroup.{0} M (NonAssocRing.toAddGroupWithOne.{0} M (Ring.toNonAssocRing.{0} M _inst_2)))))) (OfNat.ofNat.{0} M 1 (OfNat.mk.{0} M 1 (One.one.{0} M (AddMonoidWithOne.toOne.{0} M (AddGroupWithOne.toAddMonoidWithOne.{0} M (NonAssocRing.toAddGroupWithOne.{0} M (Ring.toNonAssocRing.{0} M _inst_2))))))) P))
but is expected to have type
  forall {X : Type.{u1}} [_inst_1 : NormedAddCommGroup.{u1} X] {M : Type} [_inst_2 : Ring.{0} M] [_inst_3 : Module.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))] (P : M), Iff (IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) (IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 (HSub.hSub.{0, 0, 0} M M M (instHSub.{0} M (Ring.toSub.{0} M _inst_2)) (OfNat.ofNat.{0} M 1 (One.toOfNat1.{0} M (NonAssocRing.toOne.{0} M (Ring.toNonAssocRing.{0} M _inst_2)))) P))
Case conversion may be inaccurate. Consider using '#align is_Lprojection.Lcomplement_iff IsLprojection.Lcomplement_iffₓ'. -/
theorem Lcomplement_iff (P : M) : IsLprojection X P ↔ IsLprojection X (1 - P) :=
  ⟨Lcomplement, fun h => sub_sub_cancel 1 P ▸ h.Lcomplement⟩
#align is_Lprojection.Lcomplement_iff IsLprojection.Lcomplement_iff

/- warning: is_Lprojection.commute -> IsLprojection.commute is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} [_inst_1 : NormedAddCommGroup.{u1} X] {M : Type} [_inst_2 : Ring.{0} M] [_inst_3 : Module.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))] [_inst_4 : FaithfulSMul.{0, u1} M X (SMulZeroClass.toHasSmul.{0, u1} M X (AddZeroClass.toHasZero.{u1} X (AddMonoid.toAddZeroClass.{u1} X (AddCommMonoid.toAddMonoid.{u1} X (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))))) (SMulWithZero.toSmulZeroClass.{0, u1} M X (MulZeroClass.toHasZero.{0} M (MulZeroOneClass.toMulZeroClass.{0} M (MonoidWithZero.toMulZeroOneClass.{0} M (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2))))) (AddZeroClass.toHasZero.{u1} X (AddMonoid.toAddZeroClass.{u1} X (AddCommMonoid.toAddMonoid.{u1} X (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))))) (MulActionWithZero.toSMulWithZero.{0, u1} M X (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2)) (AddZeroClass.toHasZero.{u1} X (AddMonoid.toAddZeroClass.{u1} X (AddCommMonoid.toAddMonoid.{u1} X (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))))) (Module.toMulActionWithZero.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)) _inst_3))))] {P : M} {Q : M}, (IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) -> (IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 Q) -> (Commute.{0} M (Distrib.toHasMul.{0} M (Ring.toDistrib.{0} M _inst_2)) P Q)
but is expected to have type
  forall {X : Type.{u1}} [_inst_1 : NormedAddCommGroup.{u1} X] {M : Type} [_inst_2 : Ring.{0} M] [_inst_3 : Module.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))] [_inst_4 : FaithfulSMul.{0, u1} M X (SMulZeroClass.toSMul.{0, u1} M X (NegZeroClass.toZero.{u1} X (SubNegZeroMonoid.toNegZeroClass.{u1} X (SubtractionMonoid.toSubNegZeroMonoid.{u1} X (SubtractionCommMonoid.toSubtractionMonoid.{u1} X (AddCommGroup.toDivisionAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)))))) (SMulWithZero.toSMulZeroClass.{0, u1} M X (MonoidWithZero.toZero.{0} M (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2))) (NegZeroClass.toZero.{u1} X (SubNegZeroMonoid.toNegZeroClass.{u1} X (SubtractionMonoid.toSubNegZeroMonoid.{u1} X (SubtractionCommMonoid.toSubtractionMonoid.{u1} X (AddCommGroup.toDivisionAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)))))) (MulActionWithZero.toSMulWithZero.{0, u1} M X (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2)) (NegZeroClass.toZero.{u1} X (SubNegZeroMonoid.toNegZeroClass.{u1} X (SubtractionMonoid.toSubNegZeroMonoid.{u1} X (SubtractionCommMonoid.toSubtractionMonoid.{u1} X (AddCommGroup.toDivisionAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)))))) (Module.toMulActionWithZero.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)) _inst_3))))] {P : M} {Q : M}, (IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) -> (IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 Q) -> (Commute.{0} M (NonUnitalNonAssocRing.toMul.{0} M (NonAssocRing.toNonUnitalNonAssocRing.{0} M (Ring.toNonAssocRing.{0} M _inst_2))) P Q)
Case conversion may be inaccurate. Consider using '#align is_Lprojection.commute IsLprojection.commuteₓ'. -/
theorem commute [FaithfulSMul M X] {P Q : M} (h₁ : IsLprojection X P) (h₂ : IsLprojection X Q) :
    Commute P Q :=
  by
  have PR_eq_RPR : ∀ R : M, IsLprojection X R → P * R = R * P * R := fun R h₃ =>
    by
    refine' @eq_of_smul_eq_smul _ X _ _ _ _ fun x => _
    rw [← norm_sub_eq_zero_iff]
    have e1 : ‖R • x‖ ≥ ‖R • x‖ + 2 • ‖(P * R) • x - (R * P * R) • x‖ :=
      calc
        ‖R • x‖ =
            ‖R • P • R • x‖ + ‖(1 - R) • P • R • x‖ +
              (‖(R * R) • x - R • P • R • x‖ + ‖(1 - R) • (1 - P) • R • x‖) :=
          by
          rw [h₁.Lnorm, h₃.Lnorm, h₃.Lnorm ((1 - P) • R • x), sub_smul 1 P, one_smul, smul_sub,
            mul_smul]
        _ =
            ‖R • P • R • x‖ + ‖(1 - R) • P • R • x‖ +
              (‖R • x - R • P • R • x‖ + ‖((1 - R) * R) • x - (1 - R) • P • R • x‖) :=
          by rw [h₃.proj.eq, sub_smul 1 P, one_smul, smul_sub, mul_smul]
        _ =
            ‖R • P • R • x‖ + ‖(1 - R) • P • R • x‖ +
              (‖R • x - R • P • R • x‖ + ‖(1 - R) • P • R • x‖) :=
          by rw [sub_mul, h₃.proj.eq, one_mul, sub_self, zero_smul, zero_sub, norm_neg]
        _ = ‖R • P • R • x‖ + ‖R • x - R • P • R • x‖ + 2 • ‖(1 - R) • P • R • x‖ := by abel
        _ ≥ ‖R • x‖ + 2 • ‖(P * R) • x - (R * P * R) • x‖ :=
          by
          rw [GE.ge]
          have :=
            add_le_add_right (norm_le_insert' (R • x) (R • P • R • x)) (2 • ‖(1 - R) • P • R • x‖)
          simpa only [mul_smul, sub_smul, one_smul] using this
        
    rw [GE.ge] at e1
    nth_rw_rhs 1 [← add_zero ‖R • x‖]  at e1
    rw [add_le_add_iff_left, two_smul, ← two_mul] at e1
    rw [le_antisymm_iff]
    refine' ⟨_, norm_nonneg _⟩
    rwa [← MulZeroClass.mul_zero (2 : ℝ), mul_le_mul_left (show (0 : ℝ) < 2 by norm_num)] at e1
  have QP_eq_QPQ : Q * P = Q * P * Q :=
    by
    have e1 : P * (1 - Q) = P * (1 - Q) - (Q * P - Q * P * Q) :=
      calc
        P * (1 - Q) = (1 - Q) * P * (1 - Q) := by rw [PR_eq_RPR (1 - Q) h₂.Lcomplement]
        _ = P * (1 - Q) - (Q * P - Q * P * Q) := by noncomm_ring
        
    rwa [eq_sub_iff_add_eq, add_right_eq_self, sub_eq_zero] at e1
  show P * Q = Q * P
  · rw [QP_eq_QPQ, PR_eq_RPR Q h₂]
#align is_Lprojection.commute IsLprojection.commute

/- warning: is_Lprojection.mul -> IsLprojection.mul is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} [_inst_1 : NormedAddCommGroup.{u1} X] {M : Type} [_inst_2 : Ring.{0} M] [_inst_3 : Module.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))] [_inst_4 : FaithfulSMul.{0, u1} M X (SMulZeroClass.toHasSmul.{0, u1} M X (AddZeroClass.toHasZero.{u1} X (AddMonoid.toAddZeroClass.{u1} X (AddCommMonoid.toAddMonoid.{u1} X (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))))) (SMulWithZero.toSmulZeroClass.{0, u1} M X (MulZeroClass.toHasZero.{0} M (MulZeroOneClass.toMulZeroClass.{0} M (MonoidWithZero.toMulZeroOneClass.{0} M (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2))))) (AddZeroClass.toHasZero.{u1} X (AddMonoid.toAddZeroClass.{u1} X (AddCommMonoid.toAddMonoid.{u1} X (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))))) (MulActionWithZero.toSMulWithZero.{0, u1} M X (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2)) (AddZeroClass.toHasZero.{u1} X (AddMonoid.toAddZeroClass.{u1} X (AddCommMonoid.toAddMonoid.{u1} X (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))))) (Module.toMulActionWithZero.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)) _inst_3))))] {P : M} {Q : M}, (IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) -> (IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 Q) -> (IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 (HMul.hMul.{0, 0, 0} M M M (instHMul.{0} M (Distrib.toHasMul.{0} M (Ring.toDistrib.{0} M _inst_2))) P Q))
but is expected to have type
  forall {X : Type.{u1}} [_inst_1 : NormedAddCommGroup.{u1} X] {M : Type} [_inst_2 : Ring.{0} M] [_inst_3 : Module.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))] [_inst_4 : FaithfulSMul.{0, u1} M X (SMulZeroClass.toSMul.{0, u1} M X (NegZeroClass.toZero.{u1} X (SubNegZeroMonoid.toNegZeroClass.{u1} X (SubtractionMonoid.toSubNegZeroMonoid.{u1} X (SubtractionCommMonoid.toSubtractionMonoid.{u1} X (AddCommGroup.toDivisionAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)))))) (SMulWithZero.toSMulZeroClass.{0, u1} M X (MonoidWithZero.toZero.{0} M (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2))) (NegZeroClass.toZero.{u1} X (SubNegZeroMonoid.toNegZeroClass.{u1} X (SubtractionMonoid.toSubNegZeroMonoid.{u1} X (SubtractionCommMonoid.toSubtractionMonoid.{u1} X (AddCommGroup.toDivisionAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)))))) (MulActionWithZero.toSMulWithZero.{0, u1} M X (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2)) (NegZeroClass.toZero.{u1} X (SubNegZeroMonoid.toNegZeroClass.{u1} X (SubtractionMonoid.toSubNegZeroMonoid.{u1} X (SubtractionCommMonoid.toSubtractionMonoid.{u1} X (AddCommGroup.toDivisionAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)))))) (Module.toMulActionWithZero.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)) _inst_3))))] {P : M} {Q : M}, (IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) -> (IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 Q) -> (IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 (HMul.hMul.{0, 0, 0} M M M (instHMul.{0} M (NonUnitalNonAssocRing.toMul.{0} M (NonAssocRing.toNonUnitalNonAssocRing.{0} M (Ring.toNonAssocRing.{0} M _inst_2)))) P Q))
Case conversion may be inaccurate. Consider using '#align is_Lprojection.mul IsLprojection.mulₓ'. -/
theorem mul [FaithfulSMul M X] {P Q : M} (h₁ : IsLprojection X P) (h₂ : IsLprojection X Q) :
    IsLprojection X (P * Q) :=
  by
  refine' ⟨IsIdempotentElem.mul_of_commute (h₁.commute h₂) h₁.proj h₂.proj, _⟩
  intro x
  refine' le_antisymm _ _
  ·
    calc
      ‖x‖ = ‖(P * Q) • x + (x - (P * Q) • x)‖ := by rw [add_sub_cancel'_right ((P * Q) • x) x]
      _ ≤ ‖(P * Q) • x‖ + ‖x - (P * Q) • x‖ := by apply norm_add_le
      _ = ‖(P * Q) • x‖ + ‖(1 - P * Q) • x‖ := by rw [sub_smul, one_smul]
      
  ·
    calc
      ‖x‖ = ‖P • Q • x‖ + (‖Q • x - P • Q • x‖ + ‖x - Q • x‖) := by
        rw [h₂.Lnorm x, h₁.Lnorm (Q • x), sub_smul, one_smul, sub_smul, one_smul, add_assoc]
      _ ≥ ‖P • Q • x‖ + ‖Q • x - P • Q • x + (x - Q • x)‖ :=
        ((add_le_add_iff_left ‖P • Q • x‖).mpr (norm_add_le (Q • x - P • Q • x) (x - Q • x)))
      _ = ‖(P * Q) • x‖ + ‖(1 - P * Q) • x‖ := by
        rw [sub_add_sub_cancel', sub_smul, one_smul, mul_smul]
      
#align is_Lprojection.mul IsLprojection.mul

/- warning: is_Lprojection.join -> IsLprojection.join is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} [_inst_1 : NormedAddCommGroup.{u1} X] {M : Type} [_inst_2 : Ring.{0} M] [_inst_3 : Module.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))] [_inst_4 : FaithfulSMul.{0, u1} M X (SMulZeroClass.toHasSmul.{0, u1} M X (AddZeroClass.toHasZero.{u1} X (AddMonoid.toAddZeroClass.{u1} X (AddCommMonoid.toAddMonoid.{u1} X (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))))) (SMulWithZero.toSmulZeroClass.{0, u1} M X (MulZeroClass.toHasZero.{0} M (MulZeroOneClass.toMulZeroClass.{0} M (MonoidWithZero.toMulZeroOneClass.{0} M (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2))))) (AddZeroClass.toHasZero.{u1} X (AddMonoid.toAddZeroClass.{u1} X (AddCommMonoid.toAddMonoid.{u1} X (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))))) (MulActionWithZero.toSMulWithZero.{0, u1} M X (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2)) (AddZeroClass.toHasZero.{u1} X (AddMonoid.toAddZeroClass.{u1} X (AddCommMonoid.toAddMonoid.{u1} X (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))))) (Module.toMulActionWithZero.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)) _inst_3))))] {P : M} {Q : M}, (IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) -> (IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 Q) -> (IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 (HSub.hSub.{0, 0, 0} M M M (instHSub.{0} M (SubNegMonoid.toHasSub.{0} M (AddGroup.toSubNegMonoid.{0} M (AddGroupWithOne.toAddGroup.{0} M (NonAssocRing.toAddGroupWithOne.{0} M (Ring.toNonAssocRing.{0} M _inst_2)))))) (HAdd.hAdd.{0, 0, 0} M M M (instHAdd.{0} M (Distrib.toHasAdd.{0} M (Ring.toDistrib.{0} M _inst_2))) P Q) (HMul.hMul.{0, 0, 0} M M M (instHMul.{0} M (Distrib.toHasMul.{0} M (Ring.toDistrib.{0} M _inst_2))) P Q)))
but is expected to have type
  forall {X : Type.{u1}} [_inst_1 : NormedAddCommGroup.{u1} X] {M : Type} [_inst_2 : Ring.{0} M] [_inst_3 : Module.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))] [_inst_4 : FaithfulSMul.{0, u1} M X (SMulZeroClass.toSMul.{0, u1} M X (NegZeroClass.toZero.{u1} X (SubNegZeroMonoid.toNegZeroClass.{u1} X (SubtractionMonoid.toSubNegZeroMonoid.{u1} X (SubtractionCommMonoid.toSubtractionMonoid.{u1} X (AddCommGroup.toDivisionAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)))))) (SMulWithZero.toSMulZeroClass.{0, u1} M X (MonoidWithZero.toZero.{0} M (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2))) (NegZeroClass.toZero.{u1} X (SubNegZeroMonoid.toNegZeroClass.{u1} X (SubtractionMonoid.toSubNegZeroMonoid.{u1} X (SubtractionCommMonoid.toSubtractionMonoid.{u1} X (AddCommGroup.toDivisionAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)))))) (MulActionWithZero.toSMulWithZero.{0, u1} M X (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2)) (NegZeroClass.toZero.{u1} X (SubNegZeroMonoid.toNegZeroClass.{u1} X (SubtractionMonoid.toSubNegZeroMonoid.{u1} X (SubtractionCommMonoid.toSubtractionMonoid.{u1} X (AddCommGroup.toDivisionAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)))))) (Module.toMulActionWithZero.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)) _inst_3))))] {P : M} {Q : M}, (IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) -> (IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 Q) -> (IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 (HSub.hSub.{0, 0, 0} M M M (instHSub.{0} M (Ring.toSub.{0} M _inst_2)) (HAdd.hAdd.{0, 0, 0} M M M (instHAdd.{0} M (Distrib.toAdd.{0} M (NonUnitalNonAssocSemiring.toDistrib.{0} M (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{0} M (NonAssocRing.toNonUnitalNonAssocRing.{0} M (Ring.toNonAssocRing.{0} M _inst_2)))))) P Q) (HMul.hMul.{0, 0, 0} M M M (instHMul.{0} M (NonUnitalNonAssocRing.toMul.{0} M (NonAssocRing.toNonUnitalNonAssocRing.{0} M (Ring.toNonAssocRing.{0} M _inst_2)))) P Q)))
Case conversion may be inaccurate. Consider using '#align is_Lprojection.join IsLprojection.joinₓ'. -/
theorem join [FaithfulSMul M X] {P Q : M} (h₁ : IsLprojection X P) (h₂ : IsLprojection X Q) :
    IsLprojection X (P + Q - P * Q) :=
  by
  convert(Lcomplement_iff _).mp (h₁.Lcomplement.mul h₂.Lcomplement) using 1
  noncomm_ring
#align is_Lprojection.join IsLprojection.join

instance : HasCompl { f : M // IsLprojection X f } :=
  ⟨fun P => ⟨1 - P, P.Prop.Lcomplement⟩⟩

/- warning: is_Lprojection.coe_compl -> IsLprojection.coe_compl is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} [_inst_1 : NormedAddCommGroup.{u1} X] {M : Type} [_inst_2 : Ring.{0} M] [_inst_3 : Module.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))] (P : Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)), Eq.{1} M ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (HasLiftT.mk.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (CoeTCₓ.coe.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeBase.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeSubtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P))))) (HasCompl.compl.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (IsLprojection.Subtype.hasCompl.{u1} X _inst_1 M _inst_2 _inst_3) P)) (HSub.hSub.{0, 0, 0} M M M (instHSub.{0} M (SubNegMonoid.toHasSub.{0} M (AddGroup.toSubNegMonoid.{0} M (AddGroupWithOne.toAddGroup.{0} M (NonAssocRing.toAddGroupWithOne.{0} M (Ring.toNonAssocRing.{0} M _inst_2)))))) (OfNat.ofNat.{0} M 1 (OfNat.mk.{0} M 1 (One.one.{0} M (AddMonoidWithOne.toOne.{0} M (AddGroupWithOne.toAddMonoidWithOne.{0} M (NonAssocRing.toAddGroupWithOne.{0} M (Ring.toNonAssocRing.{0} M _inst_2))))))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (HasLiftT.mk.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (CoeTCₓ.coe.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeBase.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeSubtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P))))) P))
but is expected to have type
  forall {X : Type.{u1}} [_inst_1 : NormedAddCommGroup.{u1} X] {M : Type} [_inst_2 : Ring.{0} M] [_inst_3 : Module.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))] (P : Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)), Eq.{1} M (Subtype.val.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) (HasCompl.compl.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (IsLprojection.IsLprojection.Subtype.HasCompl.{u1} X _inst_1 M _inst_2 _inst_3) P)) (HSub.hSub.{0, 0, 0} M M M (instHSub.{0} M (Ring.toSub.{0} M _inst_2)) (OfNat.ofNat.{0} M 1 (One.toOfNat1.{0} M (NonAssocRing.toOne.{0} M (Ring.toNonAssocRing.{0} M _inst_2)))) (Subtype.val.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) P))
Case conversion may be inaccurate. Consider using '#align is_Lprojection.coe_compl IsLprojection.coe_complₓ'. -/
@[simp]
theorem coe_compl (P : { P : M // IsLprojection X P }) : ↑(Pᶜ) = (1 : M) - ↑P :=
  rfl
#align is_Lprojection.coe_compl IsLprojection.coe_compl

instance [FaithfulSMul M X] : Inf { P : M // IsLprojection X P } :=
  ⟨fun P Q => ⟨P * Q, P.Prop.mul Q.Prop⟩⟩

/- warning: is_Lprojection.coe_inf -> IsLprojection.coe_inf is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} [_inst_1 : NormedAddCommGroup.{u1} X] {M : Type} [_inst_2 : Ring.{0} M] [_inst_3 : Module.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))] [_inst_4 : FaithfulSMul.{0, u1} M X (SMulZeroClass.toHasSmul.{0, u1} M X (AddZeroClass.toHasZero.{u1} X (AddMonoid.toAddZeroClass.{u1} X (AddCommMonoid.toAddMonoid.{u1} X (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))))) (SMulWithZero.toSmulZeroClass.{0, u1} M X (MulZeroClass.toHasZero.{0} M (MulZeroOneClass.toMulZeroClass.{0} M (MonoidWithZero.toMulZeroOneClass.{0} M (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2))))) (AddZeroClass.toHasZero.{u1} X (AddMonoid.toAddZeroClass.{u1} X (AddCommMonoid.toAddMonoid.{u1} X (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))))) (MulActionWithZero.toSMulWithZero.{0, u1} M X (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2)) (AddZeroClass.toHasZero.{u1} X (AddMonoid.toAddZeroClass.{u1} X (AddCommMonoid.toAddMonoid.{u1} X (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))))) (Module.toMulActionWithZero.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)) _inst_3))))] (P : Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (Q : Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)), Eq.{1} M ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (HasLiftT.mk.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (CoeTCₓ.coe.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeBase.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeSubtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P))))) (Inf.inf.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (IsLprojection.Subtype.hasInf.{u1} X _inst_1 M _inst_2 _inst_3 _inst_4) P Q)) (HMul.hMul.{0, 0, 0} M M M (instHMul.{0} M (Distrib.toHasMul.{0} M (Ring.toDistrib.{0} M _inst_2))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (HasLiftT.mk.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (CoeTCₓ.coe.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeBase.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeSubtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P))))) P) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (HasLiftT.mk.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (CoeTCₓ.coe.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeBase.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeSubtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P))))) Q))
but is expected to have type
  forall {X : Type.{u1}} [_inst_1 : NormedAddCommGroup.{u1} X] {M : Type} [_inst_2 : Ring.{0} M] [_inst_3 : Module.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))] [_inst_4 : FaithfulSMul.{0, u1} M X (SMulZeroClass.toSMul.{0, u1} M X (NegZeroClass.toZero.{u1} X (SubNegZeroMonoid.toNegZeroClass.{u1} X (SubtractionMonoid.toSubNegZeroMonoid.{u1} X (SubtractionCommMonoid.toSubtractionMonoid.{u1} X (AddCommGroup.toDivisionAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)))))) (SMulWithZero.toSMulZeroClass.{0, u1} M X (MonoidWithZero.toZero.{0} M (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2))) (NegZeroClass.toZero.{u1} X (SubNegZeroMonoid.toNegZeroClass.{u1} X (SubtractionMonoid.toSubNegZeroMonoid.{u1} X (SubtractionCommMonoid.toSubtractionMonoid.{u1} X (AddCommGroup.toDivisionAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)))))) (MulActionWithZero.toSMulWithZero.{0, u1} M X (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2)) (NegZeroClass.toZero.{u1} X (SubNegZeroMonoid.toNegZeroClass.{u1} X (SubtractionMonoid.toSubNegZeroMonoid.{u1} X (SubtractionCommMonoid.toSubtractionMonoid.{u1} X (AddCommGroup.toDivisionAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)))))) (Module.toMulActionWithZero.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)) _inst_3))))] (P : Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (Q : Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)), Eq.{1} M (Subtype.val.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) (Inf.inf.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (IsLprojection.IsLprojection.Subtype.Inf.{u1} X _inst_1 M _inst_2 _inst_3 _inst_4) P Q)) (HMul.hMul.{0, 0, 0} M M M (instHMul.{0} M (NonUnitalNonAssocRing.toMul.{0} M (NonAssocRing.toNonUnitalNonAssocRing.{0} M (Ring.toNonAssocRing.{0} M _inst_2)))) (Subtype.val.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) P) (Subtype.val.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) Q))
Case conversion may be inaccurate. Consider using '#align is_Lprojection.coe_inf IsLprojection.coe_infₓ'. -/
@[simp]
theorem coe_inf [FaithfulSMul M X] (P Q : { P : M // IsLprojection X P }) :
    ↑(P ⊓ Q) = (↑P : M) * ↑Q :=
  rfl
#align is_Lprojection.coe_inf IsLprojection.coe_inf

instance [FaithfulSMul M X] : Sup { P : M // IsLprojection X P } :=
  ⟨fun P Q => ⟨P + Q - P * Q, P.Prop.join Q.Prop⟩⟩

/- warning: is_Lprojection.coe_sup -> IsLprojection.coe_sup is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} [_inst_1 : NormedAddCommGroup.{u1} X] {M : Type} [_inst_2 : Ring.{0} M] [_inst_3 : Module.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))] [_inst_4 : FaithfulSMul.{0, u1} M X (SMulZeroClass.toHasSmul.{0, u1} M X (AddZeroClass.toHasZero.{u1} X (AddMonoid.toAddZeroClass.{u1} X (AddCommMonoid.toAddMonoid.{u1} X (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))))) (SMulWithZero.toSmulZeroClass.{0, u1} M X (MulZeroClass.toHasZero.{0} M (MulZeroOneClass.toMulZeroClass.{0} M (MonoidWithZero.toMulZeroOneClass.{0} M (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2))))) (AddZeroClass.toHasZero.{u1} X (AddMonoid.toAddZeroClass.{u1} X (AddCommMonoid.toAddMonoid.{u1} X (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))))) (MulActionWithZero.toSMulWithZero.{0, u1} M X (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2)) (AddZeroClass.toHasZero.{u1} X (AddMonoid.toAddZeroClass.{u1} X (AddCommMonoid.toAddMonoid.{u1} X (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))))) (Module.toMulActionWithZero.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)) _inst_3))))] (P : Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (Q : Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)), Eq.{1} M ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (HasLiftT.mk.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (CoeTCₓ.coe.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeBase.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeSubtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P))))) (Sup.sup.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (IsLprojection.Subtype.hasSup.{u1} X _inst_1 M _inst_2 _inst_3 _inst_4) P Q)) (HSub.hSub.{0, 0, 0} M M M (instHSub.{0} M (SubNegMonoid.toHasSub.{0} M (AddGroup.toSubNegMonoid.{0} M (AddGroupWithOne.toAddGroup.{0} M (NonAssocRing.toAddGroupWithOne.{0} M (Ring.toNonAssocRing.{0} M _inst_2)))))) (HAdd.hAdd.{0, 0, 0} M M M (instHAdd.{0} M (Distrib.toHasAdd.{0} M (Ring.toDistrib.{0} M _inst_2))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (HasLiftT.mk.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (CoeTCₓ.coe.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeBase.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeSubtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P))))) P) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (HasLiftT.mk.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (CoeTCₓ.coe.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeBase.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeSubtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P))))) Q)) (HMul.hMul.{0, 0, 0} M M M (instHMul.{0} M (Distrib.toHasMul.{0} M (Ring.toDistrib.{0} M _inst_2))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (HasLiftT.mk.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (CoeTCₓ.coe.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeBase.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeSubtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P))))) P) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (HasLiftT.mk.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (CoeTCₓ.coe.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeBase.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeSubtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P))))) Q)))
but is expected to have type
  forall {X : Type.{u1}} [_inst_1 : NormedAddCommGroup.{u1} X] {M : Type} [_inst_2 : Ring.{0} M] [_inst_3 : Module.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))] [_inst_4 : FaithfulSMul.{0, u1} M X (SMulZeroClass.toSMul.{0, u1} M X (NegZeroClass.toZero.{u1} X (SubNegZeroMonoid.toNegZeroClass.{u1} X (SubtractionMonoid.toSubNegZeroMonoid.{u1} X (SubtractionCommMonoid.toSubtractionMonoid.{u1} X (AddCommGroup.toDivisionAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)))))) (SMulWithZero.toSMulZeroClass.{0, u1} M X (MonoidWithZero.toZero.{0} M (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2))) (NegZeroClass.toZero.{u1} X (SubNegZeroMonoid.toNegZeroClass.{u1} X (SubtractionMonoid.toSubNegZeroMonoid.{u1} X (SubtractionCommMonoid.toSubtractionMonoid.{u1} X (AddCommGroup.toDivisionAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)))))) (MulActionWithZero.toSMulWithZero.{0, u1} M X (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2)) (NegZeroClass.toZero.{u1} X (SubNegZeroMonoid.toNegZeroClass.{u1} X (SubtractionMonoid.toSubNegZeroMonoid.{u1} X (SubtractionCommMonoid.toSubtractionMonoid.{u1} X (AddCommGroup.toDivisionAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)))))) (Module.toMulActionWithZero.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)) _inst_3))))] (P : Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (Q : Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)), Eq.{1} M (Subtype.val.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) (Sup.sup.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (IsLprojection.IsLprojection.Subtype.Sup.{u1} X _inst_1 M _inst_2 _inst_3 _inst_4) P Q)) (HSub.hSub.{0, 0, 0} M M M (instHSub.{0} M (Ring.toSub.{0} M _inst_2)) (HAdd.hAdd.{0, 0, 0} M M M (instHAdd.{0} M (Distrib.toAdd.{0} M (NonUnitalNonAssocSemiring.toDistrib.{0} M (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{0} M (NonAssocRing.toNonUnitalNonAssocRing.{0} M (Ring.toNonAssocRing.{0} M _inst_2)))))) (Subtype.val.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) P) (Subtype.val.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) Q)) (HMul.hMul.{0, 0, 0} M M M (instHMul.{0} M (NonUnitalNonAssocRing.toMul.{0} M (NonAssocRing.toNonUnitalNonAssocRing.{0} M (Ring.toNonAssocRing.{0} M _inst_2)))) (Subtype.val.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) P) (Subtype.val.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) Q)))
Case conversion may be inaccurate. Consider using '#align is_Lprojection.coe_sup IsLprojection.coe_supₓ'. -/
@[simp]
theorem coe_sup [FaithfulSMul M X] (P Q : { P : M // IsLprojection X P }) :
    ↑(P ⊔ Q) = (↑P : M) + ↑Q - ↑P * ↑Q :=
  rfl
#align is_Lprojection.coe_sup IsLprojection.coe_sup

instance [FaithfulSMul M X] : SDiff { P : M // IsLprojection X P } :=
  ⟨fun P Q => ⟨P * (1 - Q), P.prop.mul Q.prop.Lcomplement⟩⟩

/- warning: is_Lprojection.coe_sdiff -> IsLprojection.coe_sdiff is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} [_inst_1 : NormedAddCommGroup.{u1} X] {M : Type} [_inst_2 : Ring.{0} M] [_inst_3 : Module.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))] [_inst_4 : FaithfulSMul.{0, u1} M X (SMulZeroClass.toHasSmul.{0, u1} M X (AddZeroClass.toHasZero.{u1} X (AddMonoid.toAddZeroClass.{u1} X (AddCommMonoid.toAddMonoid.{u1} X (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))))) (SMulWithZero.toSmulZeroClass.{0, u1} M X (MulZeroClass.toHasZero.{0} M (MulZeroOneClass.toMulZeroClass.{0} M (MonoidWithZero.toMulZeroOneClass.{0} M (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2))))) (AddZeroClass.toHasZero.{u1} X (AddMonoid.toAddZeroClass.{u1} X (AddCommMonoid.toAddMonoid.{u1} X (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))))) (MulActionWithZero.toSMulWithZero.{0, u1} M X (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2)) (AddZeroClass.toHasZero.{u1} X (AddMonoid.toAddZeroClass.{u1} X (AddCommMonoid.toAddMonoid.{u1} X (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))))) (Module.toMulActionWithZero.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)) _inst_3))))] (P : Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (Q : Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)), Eq.{1} M ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (HasLiftT.mk.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (CoeTCₓ.coe.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeBase.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeSubtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P))))) (SDiff.sdiff.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (IsLprojection.Subtype.hasSdiff.{u1} X _inst_1 M _inst_2 _inst_3 _inst_4) P Q)) (HMul.hMul.{0, 0, 0} M M M (instHMul.{0} M (Distrib.toHasMul.{0} M (Ring.toDistrib.{0} M _inst_2))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (HasLiftT.mk.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (CoeTCₓ.coe.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeBase.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeSubtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P))))) P) (HSub.hSub.{0, 0, 0} M M M (instHSub.{0} M (SubNegMonoid.toHasSub.{0} M (AddGroup.toSubNegMonoid.{0} M (AddGroupWithOne.toAddGroup.{0} M (NonAssocRing.toAddGroupWithOne.{0} M (Ring.toNonAssocRing.{0} M _inst_2)))))) (OfNat.ofNat.{0} M 1 (OfNat.mk.{0} M 1 (One.one.{0} M (AddMonoidWithOne.toOne.{0} M (AddGroupWithOne.toAddMonoidWithOne.{0} M (NonAssocRing.toAddGroupWithOne.{0} M (Ring.toNonAssocRing.{0} M _inst_2))))))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (HasLiftT.mk.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (CoeTCₓ.coe.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeBase.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeSubtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P))))) Q)))
but is expected to have type
  forall {X : Type.{u1}} [_inst_1 : NormedAddCommGroup.{u1} X] {M : Type} [_inst_2 : Ring.{0} M] [_inst_3 : Module.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))] [_inst_4 : FaithfulSMul.{0, u1} M X (SMulZeroClass.toSMul.{0, u1} M X (NegZeroClass.toZero.{u1} X (SubNegZeroMonoid.toNegZeroClass.{u1} X (SubtractionMonoid.toSubNegZeroMonoid.{u1} X (SubtractionCommMonoid.toSubtractionMonoid.{u1} X (AddCommGroup.toDivisionAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)))))) (SMulWithZero.toSMulZeroClass.{0, u1} M X (MonoidWithZero.toZero.{0} M (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2))) (NegZeroClass.toZero.{u1} X (SubNegZeroMonoid.toNegZeroClass.{u1} X (SubtractionMonoid.toSubNegZeroMonoid.{u1} X (SubtractionCommMonoid.toSubtractionMonoid.{u1} X (AddCommGroup.toDivisionAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)))))) (MulActionWithZero.toSMulWithZero.{0, u1} M X (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2)) (NegZeroClass.toZero.{u1} X (SubNegZeroMonoid.toNegZeroClass.{u1} X (SubtractionMonoid.toSubNegZeroMonoid.{u1} X (SubtractionCommMonoid.toSubtractionMonoid.{u1} X (AddCommGroup.toDivisionAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)))))) (Module.toMulActionWithZero.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)) _inst_3))))] (P : Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (Q : Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)), Eq.{1} M (Subtype.val.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) (SDiff.sdiff.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (IsLprojection.IsLprojection.Subtype.SDiff.{u1} X _inst_1 M _inst_2 _inst_3 _inst_4) P Q)) (HMul.hMul.{0, 0, 0} M M M (instHMul.{0} M (NonUnitalNonAssocRing.toMul.{0} M (NonAssocRing.toNonUnitalNonAssocRing.{0} M (Ring.toNonAssocRing.{0} M _inst_2)))) (Subtype.val.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) P) (HSub.hSub.{0, 0, 0} M M M (instHSub.{0} M (Ring.toSub.{0} M _inst_2)) (OfNat.ofNat.{0} M 1 (One.toOfNat1.{0} M (NonAssocRing.toOne.{0} M (Ring.toNonAssocRing.{0} M _inst_2)))) (Subtype.val.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) Q)))
Case conversion may be inaccurate. Consider using '#align is_Lprojection.coe_sdiff IsLprojection.coe_sdiffₓ'. -/
@[simp]
theorem coe_sdiff [FaithfulSMul M X] (P Q : { P : M // IsLprojection X P }) :
    ↑(P \ Q) = (↑P : M) * (1 - ↑Q) :=
  rfl
#align is_Lprojection.coe_sdiff IsLprojection.coe_sdiff

instance [FaithfulSMul M X] : PartialOrder { P : M // IsLprojection X P }
    where
  le P Q := (↑P : M) = ↑(P ⊓ Q)
  le_refl P := by simpa only [coe_inf, ← sq] using P.prop.proj.eq.symm
  le_trans P Q R h₁ h₂ := by
    simp only [coe_inf] at h₁ h₂⊢
    rw [h₁, mul_assoc, ← h₂]
  le_antisymm P Q h₁ h₂ := Subtype.eq (by convert(P.prop.commute Q.prop).Eq)

/- warning: is_Lprojection.le_def -> IsLprojection.le_def is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} [_inst_1 : NormedAddCommGroup.{u1} X] {M : Type} [_inst_2 : Ring.{0} M] [_inst_3 : Module.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))] [_inst_4 : FaithfulSMul.{0, u1} M X (SMulZeroClass.toHasSmul.{0, u1} M X (AddZeroClass.toHasZero.{u1} X (AddMonoid.toAddZeroClass.{u1} X (AddCommMonoid.toAddMonoid.{u1} X (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))))) (SMulWithZero.toSmulZeroClass.{0, u1} M X (MulZeroClass.toHasZero.{0} M (MulZeroOneClass.toMulZeroClass.{0} M (MonoidWithZero.toMulZeroOneClass.{0} M (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2))))) (AddZeroClass.toHasZero.{u1} X (AddMonoid.toAddZeroClass.{u1} X (AddCommMonoid.toAddMonoid.{u1} X (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))))) (MulActionWithZero.toSMulWithZero.{0, u1} M X (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2)) (AddZeroClass.toHasZero.{u1} X (AddMonoid.toAddZeroClass.{u1} X (AddCommMonoid.toAddMonoid.{u1} X (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))))) (Module.toMulActionWithZero.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)) _inst_3))))] (P : Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (Q : Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)), Iff (LE.le.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (Preorder.toLE.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (PartialOrder.toPreorder.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (IsLprojection.Subtype.partialOrder.{u1} X _inst_1 M _inst_2 _inst_3 _inst_4))) P Q) (Eq.{1} M ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (HasLiftT.mk.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (CoeTCₓ.coe.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeBase.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeSubtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P))))) P) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (HasLiftT.mk.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (CoeTCₓ.coe.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeBase.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeSubtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P))))) (Inf.inf.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (IsLprojection.Subtype.hasInf.{u1} X _inst_1 M _inst_2 _inst_3 _inst_4) P Q)))
but is expected to have type
  forall {X : Type.{u1}} [_inst_1 : NormedAddCommGroup.{u1} X] {M : Type} [_inst_2 : Ring.{0} M] [_inst_3 : Module.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))] [_inst_4 : FaithfulSMul.{0, u1} M X (SMulZeroClass.toSMul.{0, u1} M X (NegZeroClass.toZero.{u1} X (SubNegZeroMonoid.toNegZeroClass.{u1} X (SubtractionMonoid.toSubNegZeroMonoid.{u1} X (SubtractionCommMonoid.toSubtractionMonoid.{u1} X (AddCommGroup.toDivisionAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)))))) (SMulWithZero.toSMulZeroClass.{0, u1} M X (MonoidWithZero.toZero.{0} M (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2))) (NegZeroClass.toZero.{u1} X (SubNegZeroMonoid.toNegZeroClass.{u1} X (SubtractionMonoid.toSubNegZeroMonoid.{u1} X (SubtractionCommMonoid.toSubtractionMonoid.{u1} X (AddCommGroup.toDivisionAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)))))) (MulActionWithZero.toSMulWithZero.{0, u1} M X (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2)) (NegZeroClass.toZero.{u1} X (SubNegZeroMonoid.toNegZeroClass.{u1} X (SubtractionMonoid.toSubNegZeroMonoid.{u1} X (SubtractionCommMonoid.toSubtractionMonoid.{u1} X (AddCommGroup.toDivisionAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)))))) (Module.toMulActionWithZero.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)) _inst_3))))] (P : Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (Q : Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)), Iff (LE.le.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (Preorder.toLE.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (PartialOrder.toPreorder.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (IsLprojection.IsLprojection.Subtype.PartialOrder.{u1} X _inst_1 M _inst_2 _inst_3 _inst_4))) P Q) (Eq.{1} M (Subtype.val.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) P) (Subtype.val.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) (Inf.inf.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (IsLprojection.IsLprojection.Subtype.Inf.{u1} X _inst_1 M _inst_2 _inst_3 _inst_4) P Q)))
Case conversion may be inaccurate. Consider using '#align is_Lprojection.le_def IsLprojection.le_defₓ'. -/
theorem le_def [FaithfulSMul M X] (P Q : { P : M // IsLprojection X P }) :
    P ≤ Q ↔ (P : M) = ↑(P ⊓ Q) :=
  Iff.rfl
#align is_Lprojection.le_def IsLprojection.le_def

instance : Zero { P : M // IsLprojection X P } :=
  ⟨⟨0,
      ⟨by rw [IsIdempotentElem, MulZeroClass.zero_mul], fun x => by
        simp only [zero_smul, norm_zero, sub_zero, one_smul, zero_add]⟩⟩⟩

/- warning: is_Lprojection.coe_zero -> IsLprojection.coe_zero is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} [_inst_1 : NormedAddCommGroup.{u1} X] {M : Type} [_inst_2 : Ring.{0} M] [_inst_3 : Module.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))], Eq.{1} M ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (HasLiftT.mk.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (CoeTCₓ.coe.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeBase.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeSubtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P))))) (OfNat.ofNat.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) 0 (OfNat.mk.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) 0 (Zero.zero.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (IsLprojection.Subtype.hasZero.{u1} X _inst_1 M _inst_2 _inst_3))))) (OfNat.ofNat.{0} M 0 (OfNat.mk.{0} M 0 (Zero.zero.{0} M (MulZeroClass.toHasZero.{0} M (NonUnitalNonAssocSemiring.toMulZeroClass.{0} M (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{0} M (NonAssocRing.toNonUnitalNonAssocRing.{0} M (Ring.toNonAssocRing.{0} M _inst_2))))))))
but is expected to have type
  forall {X : Type.{u1}} [_inst_1 : NormedAddCommGroup.{u1} X] {M : Type} [_inst_2 : Ring.{0} M] [_inst_3 : Module.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))], Eq.{1} M (Subtype.val.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) (OfNat.ofNat.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) 0 (Zero.toOfNat0.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (IsLprojection.IsLprojection.Subtype.Zero.{u1} X _inst_1 M _inst_2 _inst_3)))) (OfNat.ofNat.{0} M 0 (Zero.toOfNat0.{0} M (MonoidWithZero.toZero.{0} M (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2)))))
Case conversion may be inaccurate. Consider using '#align is_Lprojection.coe_zero IsLprojection.coe_zeroₓ'. -/
@[simp]
theorem coe_zero : ↑(0 : { P : M // IsLprojection X P }) = (0 : M) :=
  rfl
#align is_Lprojection.coe_zero IsLprojection.coe_zero

instance : One { P : M // IsLprojection X P } :=
  ⟨⟨1, sub_zero (1 : M) ▸ (0 : { P : M // IsLprojection X P }).Prop.Lcomplement⟩⟩

/- warning: is_Lprojection.coe_one -> IsLprojection.coe_one is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} [_inst_1 : NormedAddCommGroup.{u1} X] {M : Type} [_inst_2 : Ring.{0} M] [_inst_3 : Module.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))], Eq.{1} M ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (HasLiftT.mk.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (CoeTCₓ.coe.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeBase.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeSubtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P))))) (OfNat.ofNat.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) 1 (OfNat.mk.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) 1 (One.one.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (IsLprojection.Subtype.hasOne.{u1} X _inst_1 M _inst_2 _inst_3))))) (OfNat.ofNat.{0} M 1 (OfNat.mk.{0} M 1 (One.one.{0} M (AddMonoidWithOne.toOne.{0} M (AddGroupWithOne.toAddMonoidWithOne.{0} M (NonAssocRing.toAddGroupWithOne.{0} M (Ring.toNonAssocRing.{0} M _inst_2)))))))
but is expected to have type
  forall {X : Type.{u1}} [_inst_1 : NormedAddCommGroup.{u1} X] {M : Type} [_inst_2 : Ring.{0} M] [_inst_3 : Module.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))], Eq.{1} M (Subtype.val.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) (OfNat.ofNat.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) 1 (One.toOfNat1.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (IsLprojection.IsLprojection.Subtype.One.{u1} X _inst_1 M _inst_2 _inst_3)))) (OfNat.ofNat.{0} M 1 (One.toOfNat1.{0} M (NonAssocRing.toOne.{0} M (Ring.toNonAssocRing.{0} M _inst_2))))
Case conversion may be inaccurate. Consider using '#align is_Lprojection.coe_one IsLprojection.coe_oneₓ'. -/
@[simp]
theorem coe_one : ↑(1 : { P : M // IsLprojection X P }) = (1 : M) :=
  rfl
#align is_Lprojection.coe_one IsLprojection.coe_one

instance [FaithfulSMul M X] : BoundedOrder { P : M // IsLprojection X P }
    where
  top := 1
  le_top P := (mul_one (P : M)).symm
  bot := 0
  bot_le P := (MulZeroClass.zero_mul (P : M)).symm

/- warning: is_Lprojection.coe_bot -> IsLprojection.coe_bot is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} [_inst_1 : NormedAddCommGroup.{u1} X] {M : Type} [_inst_2 : Ring.{0} M] [_inst_3 : Module.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))] [_inst_4 : FaithfulSMul.{0, u1} M X (SMulZeroClass.toHasSmul.{0, u1} M X (AddZeroClass.toHasZero.{u1} X (AddMonoid.toAddZeroClass.{u1} X (AddCommMonoid.toAddMonoid.{u1} X (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))))) (SMulWithZero.toSmulZeroClass.{0, u1} M X (MulZeroClass.toHasZero.{0} M (MulZeroOneClass.toMulZeroClass.{0} M (MonoidWithZero.toMulZeroOneClass.{0} M (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2))))) (AddZeroClass.toHasZero.{u1} X (AddMonoid.toAddZeroClass.{u1} X (AddCommMonoid.toAddMonoid.{u1} X (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))))) (MulActionWithZero.toSMulWithZero.{0, u1} M X (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2)) (AddZeroClass.toHasZero.{u1} X (AddMonoid.toAddZeroClass.{u1} X (AddCommMonoid.toAddMonoid.{u1} X (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))))) (Module.toMulActionWithZero.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)) _inst_3))))], Eq.{1} M ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (HasLiftT.mk.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (CoeTCₓ.coe.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeBase.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeSubtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P))))) (BoundedOrder.bot.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (Preorder.toLE.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (PartialOrder.toPreorder.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (IsLprojection.Subtype.partialOrder.{u1} X _inst_1 M _inst_2 _inst_3 _inst_4))) (IsLprojection.Subtype.boundedOrder.{u1} X _inst_1 M _inst_2 _inst_3 _inst_4))) (OfNat.ofNat.{0} M 0 (OfNat.mk.{0} M 0 (Zero.zero.{0} M (MulZeroClass.toHasZero.{0} M (NonUnitalNonAssocSemiring.toMulZeroClass.{0} M (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{0} M (NonAssocRing.toNonUnitalNonAssocRing.{0} M (Ring.toNonAssocRing.{0} M _inst_2))))))))
but is expected to have type
  forall {X : Type.{u1}} [_inst_1 : NormedAddCommGroup.{u1} X] {M : Type} [_inst_2 : Ring.{0} M] [_inst_3 : Module.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))] [_inst_4 : FaithfulSMul.{0, u1} M X (SMulZeroClass.toSMul.{0, u1} M X (NegZeroClass.toZero.{u1} X (SubNegZeroMonoid.toNegZeroClass.{u1} X (SubtractionMonoid.toSubNegZeroMonoid.{u1} X (SubtractionCommMonoid.toSubtractionMonoid.{u1} X (AddCommGroup.toDivisionAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)))))) (SMulWithZero.toSMulZeroClass.{0, u1} M X (MonoidWithZero.toZero.{0} M (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2))) (NegZeroClass.toZero.{u1} X (SubNegZeroMonoid.toNegZeroClass.{u1} X (SubtractionMonoid.toSubNegZeroMonoid.{u1} X (SubtractionCommMonoid.toSubtractionMonoid.{u1} X (AddCommGroup.toDivisionAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)))))) (MulActionWithZero.toSMulWithZero.{0, u1} M X (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2)) (NegZeroClass.toZero.{u1} X (SubNegZeroMonoid.toNegZeroClass.{u1} X (SubtractionMonoid.toSubNegZeroMonoid.{u1} X (SubtractionCommMonoid.toSubtractionMonoid.{u1} X (AddCommGroup.toDivisionAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)))))) (Module.toMulActionWithZero.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)) _inst_3))))], Eq.{1} M (Subtype.val.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) (Bot.bot.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (OrderBot.toBot.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (Preorder.toLE.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (PartialOrder.toPreorder.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (IsLprojection.IsLprojection.Subtype.PartialOrder.{u1} X _inst_1 M _inst_2 _inst_3 _inst_4))) (BoundedOrder.toOrderBot.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (Preorder.toLE.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (PartialOrder.toPreorder.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (IsLprojection.IsLprojection.Subtype.PartialOrder.{u1} X _inst_1 M _inst_2 _inst_3 _inst_4))) (IsLprojection.IsLprojection.Subtype.BoundedOrder.{u1} X _inst_1 M _inst_2 _inst_3 _inst_4))))) (OfNat.ofNat.{0} M 0 (Zero.toOfNat0.{0} M (MonoidWithZero.toZero.{0} M (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2)))))
Case conversion may be inaccurate. Consider using '#align is_Lprojection.coe_bot IsLprojection.coe_botₓ'. -/
@[simp]
theorem coe_bot [FaithfulSMul M X] :
    ↑(BoundedOrder.bot : { P : M // IsLprojection X P }) = (0 : M) :=
  rfl
#align is_Lprojection.coe_bot IsLprojection.coe_bot

/- warning: is_Lprojection.coe_top -> IsLprojection.coe_top is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} [_inst_1 : NormedAddCommGroup.{u1} X] {M : Type} [_inst_2 : Ring.{0} M] [_inst_3 : Module.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))] [_inst_4 : FaithfulSMul.{0, u1} M X (SMulZeroClass.toHasSmul.{0, u1} M X (AddZeroClass.toHasZero.{u1} X (AddMonoid.toAddZeroClass.{u1} X (AddCommMonoid.toAddMonoid.{u1} X (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))))) (SMulWithZero.toSmulZeroClass.{0, u1} M X (MulZeroClass.toHasZero.{0} M (MulZeroOneClass.toMulZeroClass.{0} M (MonoidWithZero.toMulZeroOneClass.{0} M (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2))))) (AddZeroClass.toHasZero.{u1} X (AddMonoid.toAddZeroClass.{u1} X (AddCommMonoid.toAddMonoid.{u1} X (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))))) (MulActionWithZero.toSMulWithZero.{0, u1} M X (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2)) (AddZeroClass.toHasZero.{u1} X (AddMonoid.toAddZeroClass.{u1} X (AddCommMonoid.toAddMonoid.{u1} X (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))))) (Module.toMulActionWithZero.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)) _inst_3))))], Eq.{1} M ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (HasLiftT.mk.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (CoeTCₓ.coe.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeBase.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeSubtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P))))) (BoundedOrder.top.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (Preorder.toLE.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (PartialOrder.toPreorder.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (IsLprojection.Subtype.partialOrder.{u1} X _inst_1 M _inst_2 _inst_3 _inst_4))) (IsLprojection.Subtype.boundedOrder.{u1} X _inst_1 M _inst_2 _inst_3 _inst_4))) (OfNat.ofNat.{0} M 1 (OfNat.mk.{0} M 1 (One.one.{0} M (AddMonoidWithOne.toOne.{0} M (AddGroupWithOne.toAddMonoidWithOne.{0} M (NonAssocRing.toAddGroupWithOne.{0} M (Ring.toNonAssocRing.{0} M _inst_2)))))))
but is expected to have type
  forall {X : Type.{u1}} [_inst_1 : NormedAddCommGroup.{u1} X] {M : Type} [_inst_2 : Ring.{0} M] [_inst_3 : Module.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))] [_inst_4 : FaithfulSMul.{0, u1} M X (SMulZeroClass.toSMul.{0, u1} M X (NegZeroClass.toZero.{u1} X (SubNegZeroMonoid.toNegZeroClass.{u1} X (SubtractionMonoid.toSubNegZeroMonoid.{u1} X (SubtractionCommMonoid.toSubtractionMonoid.{u1} X (AddCommGroup.toDivisionAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)))))) (SMulWithZero.toSMulZeroClass.{0, u1} M X (MonoidWithZero.toZero.{0} M (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2))) (NegZeroClass.toZero.{u1} X (SubNegZeroMonoid.toNegZeroClass.{u1} X (SubtractionMonoid.toSubNegZeroMonoid.{u1} X (SubtractionCommMonoid.toSubtractionMonoid.{u1} X (AddCommGroup.toDivisionAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)))))) (MulActionWithZero.toSMulWithZero.{0, u1} M X (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2)) (NegZeroClass.toZero.{u1} X (SubNegZeroMonoid.toNegZeroClass.{u1} X (SubtractionMonoid.toSubNegZeroMonoid.{u1} X (SubtractionCommMonoid.toSubtractionMonoid.{u1} X (AddCommGroup.toDivisionAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)))))) (Module.toMulActionWithZero.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)) _inst_3))))], Eq.{1} M (Subtype.val.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) (Top.top.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (OrderTop.toTop.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (Preorder.toLE.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (PartialOrder.toPreorder.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (IsLprojection.IsLprojection.Subtype.PartialOrder.{u1} X _inst_1 M _inst_2 _inst_3 _inst_4))) (BoundedOrder.toOrderTop.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (Preorder.toLE.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (PartialOrder.toPreorder.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (IsLprojection.IsLprojection.Subtype.PartialOrder.{u1} X _inst_1 M _inst_2 _inst_3 _inst_4))) (IsLprojection.IsLprojection.Subtype.BoundedOrder.{u1} X _inst_1 M _inst_2 _inst_3 _inst_4))))) (OfNat.ofNat.{0} M 1 (One.toOfNat1.{0} M (NonAssocRing.toOne.{0} M (Ring.toNonAssocRing.{0} M _inst_2))))
Case conversion may be inaccurate. Consider using '#align is_Lprojection.coe_top IsLprojection.coe_topₓ'. -/
@[simp]
theorem coe_top [FaithfulSMul M X] :
    ↑(BoundedOrder.top : { P : M // IsLprojection X P }) = (1 : M) :=
  rfl
#align is_Lprojection.coe_top IsLprojection.coe_top

/- warning: is_Lprojection.compl_mul -> IsLprojection.compl_mul is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} [_inst_1 : NormedAddCommGroup.{u1} X] {M : Type} [_inst_2 : Ring.{0} M] [_inst_3 : Module.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))] {P : Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)} {Q : M}, Eq.{1} M (HMul.hMul.{0, 0, 0} M M M (instHMul.{0} M (Distrib.toHasMul.{0} M (Ring.toDistrib.{0} M _inst_2))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (HasLiftT.mk.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (CoeTCₓ.coe.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeBase.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeSubtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P))))) (HasCompl.compl.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (IsLprojection.Subtype.hasCompl.{u1} X _inst_1 M _inst_2 _inst_3) P)) Q) (HSub.hSub.{0, 0, 0} M M M (instHSub.{0} M (SubNegMonoid.toHasSub.{0} M (AddGroup.toSubNegMonoid.{0} M (AddGroupWithOne.toAddGroup.{0} M (NonAssocRing.toAddGroupWithOne.{0} M (Ring.toNonAssocRing.{0} M _inst_2)))))) Q (HMul.hMul.{0, 0, 0} M M M (instHMul.{0} M (Distrib.toHasMul.{0} M (Ring.toDistrib.{0} M _inst_2))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (HasLiftT.mk.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (CoeTCₓ.coe.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeBase.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeSubtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P))))) P) Q))
but is expected to have type
  forall {X : Type.{u1}} [_inst_1 : NormedAddCommGroup.{u1} X] {M : Type} [_inst_2 : Ring.{0} M] [_inst_3 : Module.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))] {P : Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)} {Q : M}, Eq.{1} M (HMul.hMul.{0, 0, 0} M M M (instHMul.{0} M (NonUnitalNonAssocRing.toMul.{0} M (NonAssocRing.toNonUnitalNonAssocRing.{0} M (Ring.toNonAssocRing.{0} M _inst_2)))) (Subtype.val.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) (HasCompl.compl.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (IsLprojection.IsLprojection.Subtype.HasCompl.{u1} X _inst_1 M _inst_2 _inst_3) P)) Q) (HSub.hSub.{0, 0, 0} M M M (instHSub.{0} M (Ring.toSub.{0} M _inst_2)) Q (HMul.hMul.{0, 0, 0} M M M (instHMul.{0} M (NonUnitalNonAssocRing.toMul.{0} M (NonAssocRing.toNonUnitalNonAssocRing.{0} M (Ring.toNonAssocRing.{0} M _inst_2)))) (Subtype.val.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) P) Q))
Case conversion may be inaccurate. Consider using '#align is_Lprojection.compl_mul IsLprojection.compl_mulₓ'. -/
theorem compl_mul {P : { P : M // IsLprojection X P }} {Q : M} : ↑(Pᶜ) * Q = Q - ↑P * Q := by
  rw [coe_compl, sub_mul, one_mul]
#align is_Lprojection.compl_mul IsLprojection.compl_mul

/- warning: is_Lprojection.mul_compl_self -> IsLprojection.mul_compl_self is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} [_inst_1 : NormedAddCommGroup.{u1} X] {M : Type} [_inst_2 : Ring.{0} M] [_inst_3 : Module.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))] {P : Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)}, Eq.{1} M (HMul.hMul.{0, 0, 0} M M M (instHMul.{0} M (Distrib.toHasMul.{0} M (Ring.toDistrib.{0} M _inst_2))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (HasLiftT.mk.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (CoeTCₓ.coe.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeBase.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeSubtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P))))) P) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (HasLiftT.mk.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (CoeTCₓ.coe.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeBase.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeSubtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P))))) (HasCompl.compl.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (IsLprojection.Subtype.hasCompl.{u1} X _inst_1 M _inst_2 _inst_3) P))) (OfNat.ofNat.{0} M 0 (OfNat.mk.{0} M 0 (Zero.zero.{0} M (MulZeroClass.toHasZero.{0} M (NonUnitalNonAssocSemiring.toMulZeroClass.{0} M (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{0} M (NonAssocRing.toNonUnitalNonAssocRing.{0} M (Ring.toNonAssocRing.{0} M _inst_2))))))))
but is expected to have type
  forall {X : Type.{u1}} [_inst_1 : NormedAddCommGroup.{u1} X] {M : Type} [_inst_2 : Ring.{0} M] [_inst_3 : Module.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))] {P : Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)}, Eq.{1} M (HMul.hMul.{0, 0, 0} M M M (instHMul.{0} M (NonUnitalNonAssocRing.toMul.{0} M (NonAssocRing.toNonUnitalNonAssocRing.{0} M (Ring.toNonAssocRing.{0} M _inst_2)))) (Subtype.val.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) P) (Subtype.val.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) (HasCompl.compl.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (IsLprojection.IsLprojection.Subtype.HasCompl.{u1} X _inst_1 M _inst_2 _inst_3) P))) (OfNat.ofNat.{0} M 0 (Zero.toOfNat0.{0} M (MonoidWithZero.toZero.{0} M (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2)))))
Case conversion may be inaccurate. Consider using '#align is_Lprojection.mul_compl_self IsLprojection.mul_compl_selfₓ'. -/
theorem mul_compl_self {P : { P : M // IsLprojection X P }} : (↑P : M) * ↑(Pᶜ) = 0 := by
  rw [coe_compl, mul_sub, mul_one, P.prop.proj.eq, sub_self]
#align is_Lprojection.mul_compl_self IsLprojection.mul_compl_self

/- warning: is_Lprojection.distrib_lattice_lemma -> IsLprojection.distrib_lattice_lemma is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} [_inst_1 : NormedAddCommGroup.{u1} X] {M : Type} [_inst_2 : Ring.{0} M] [_inst_3 : Module.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))] [_inst_4 : FaithfulSMul.{0, u1} M X (SMulZeroClass.toHasSmul.{0, u1} M X (AddZeroClass.toHasZero.{u1} X (AddMonoid.toAddZeroClass.{u1} X (AddCommMonoid.toAddMonoid.{u1} X (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))))) (SMulWithZero.toSmulZeroClass.{0, u1} M X (MulZeroClass.toHasZero.{0} M (MulZeroOneClass.toMulZeroClass.{0} M (MonoidWithZero.toMulZeroOneClass.{0} M (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2))))) (AddZeroClass.toHasZero.{u1} X (AddMonoid.toAddZeroClass.{u1} X (AddCommMonoid.toAddMonoid.{u1} X (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))))) (MulActionWithZero.toSMulWithZero.{0, u1} M X (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2)) (AddZeroClass.toHasZero.{u1} X (AddMonoid.toAddZeroClass.{u1} X (AddCommMonoid.toAddMonoid.{u1} X (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))))) (Module.toMulActionWithZero.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)) _inst_3))))] {P : Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)} {Q : Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)} {R : Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)}, Eq.{1} M (HMul.hMul.{0, 0, 0} M M M (instHMul.{0} M (Distrib.toHasMul.{0} M (Ring.toDistrib.{0} M _inst_2))) (HAdd.hAdd.{0, 0, 0} M M M (instHAdd.{0} M (Distrib.toHasAdd.{0} M (Ring.toDistrib.{0} M _inst_2))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (HasLiftT.mk.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (CoeTCₓ.coe.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeBase.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeSubtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P))))) P) (HMul.hMul.{0, 0, 0} M M M (instHMul.{0} M (Distrib.toHasMul.{0} M (Ring.toDistrib.{0} M _inst_2))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (HasLiftT.mk.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (CoeTCₓ.coe.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeBase.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeSubtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P))))) (HasCompl.compl.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (IsLprojection.Subtype.hasCompl.{u1} X _inst_1 M _inst_2 _inst_3) P)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (HasLiftT.mk.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (CoeTCₓ.coe.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeBase.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeSubtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P))))) R))) (HAdd.hAdd.{0, 0, 0} M M M (instHAdd.{0} M (Distrib.toHasAdd.{0} M (Ring.toDistrib.{0} M _inst_2))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (HasLiftT.mk.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (CoeTCₓ.coe.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeBase.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeSubtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P))))) P) (HMul.hMul.{0, 0, 0} M M M (instHMul.{0} M (Distrib.toHasMul.{0} M (Ring.toDistrib.{0} M _inst_2))) (HMul.hMul.{0, 0, 0} M M M (instHMul.{0} M (Distrib.toHasMul.{0} M (Ring.toDistrib.{0} M _inst_2))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (HasLiftT.mk.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (CoeTCₓ.coe.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeBase.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeSubtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P))))) Q) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (HasLiftT.mk.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (CoeTCₓ.coe.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeBase.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeSubtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P))))) R)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (HasLiftT.mk.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (CoeTCₓ.coe.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeBase.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeSubtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P))))) (HasCompl.compl.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (IsLprojection.Subtype.hasCompl.{u1} X _inst_1 M _inst_2 _inst_3) P))))) (HAdd.hAdd.{0, 0, 0} M M M (instHAdd.{0} M (Distrib.toHasAdd.{0} M (Ring.toDistrib.{0} M _inst_2))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (HasLiftT.mk.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (CoeTCₓ.coe.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeBase.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeSubtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P))))) P) (HMul.hMul.{0, 0, 0} M M M (instHMul.{0} M (Distrib.toHasMul.{0} M (Ring.toDistrib.{0} M _inst_2))) (HMul.hMul.{0, 0, 0} M M M (instHMul.{0} M (Distrib.toHasMul.{0} M (Ring.toDistrib.{0} M _inst_2))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (HasLiftT.mk.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (CoeTCₓ.coe.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeBase.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeSubtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P))))) Q) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (HasLiftT.mk.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (CoeTCₓ.coe.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeBase.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeSubtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P))))) R)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (HasLiftT.mk.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (CoeTCₓ.coe.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeBase.{1, 1} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) M (coeSubtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P))))) (HasCompl.compl.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (IsLprojection.Subtype.hasCompl.{u1} X _inst_1 M _inst_2 _inst_3) P))))
but is expected to have type
  forall {X : Type.{u1}} [_inst_1 : NormedAddCommGroup.{u1} X] {M : Type} [_inst_2 : Ring.{0} M] [_inst_3 : Module.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1))] [_inst_4 : FaithfulSMul.{0, u1} M X (SMulZeroClass.toSMul.{0, u1} M X (NegZeroClass.toZero.{u1} X (SubNegZeroMonoid.toNegZeroClass.{u1} X (SubtractionMonoid.toSubNegZeroMonoid.{u1} X (SubtractionCommMonoid.toSubtractionMonoid.{u1} X (AddCommGroup.toDivisionAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)))))) (SMulWithZero.toSMulZeroClass.{0, u1} M X (MonoidWithZero.toZero.{0} M (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2))) (NegZeroClass.toZero.{u1} X (SubNegZeroMonoid.toNegZeroClass.{u1} X (SubtractionMonoid.toSubNegZeroMonoid.{u1} X (SubtractionCommMonoid.toSubtractionMonoid.{u1} X (AddCommGroup.toDivisionAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)))))) (MulActionWithZero.toSMulWithZero.{0, u1} M X (Semiring.toMonoidWithZero.{0} M (Ring.toSemiring.{0} M _inst_2)) (NegZeroClass.toZero.{u1} X (SubNegZeroMonoid.toNegZeroClass.{u1} X (SubtractionMonoid.toSubNegZeroMonoid.{u1} X (SubtractionCommMonoid.toSubtractionMonoid.{u1} X (AddCommGroup.toDivisionAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)))))) (Module.toMulActionWithZero.{0, u1} M X (Ring.toSemiring.{0} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} X (NormedAddCommGroup.toAddCommGroup.{u1} X _inst_1)) _inst_3))))] {P : Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)} {Q : Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)} {R : Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)}, Eq.{1} M (HMul.hMul.{0, 0, 0} M M M (instHMul.{0} M (NonUnitalNonAssocRing.toMul.{0} M (NonAssocRing.toNonUnitalNonAssocRing.{0} M (Ring.toNonAssocRing.{0} M _inst_2)))) (HAdd.hAdd.{0, 0, 0} M M M (instHAdd.{0} M (Distrib.toAdd.{0} M (NonUnitalNonAssocSemiring.toDistrib.{0} M (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{0} M (NonAssocRing.toNonUnitalNonAssocRing.{0} M (Ring.toNonAssocRing.{0} M _inst_2)))))) (Subtype.val.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) P) (HMul.hMul.{0, 0, 0} M M M (instHMul.{0} M (NonUnitalNonAssocRing.toMul.{0} M (NonAssocRing.toNonUnitalNonAssocRing.{0} M (Ring.toNonAssocRing.{0} M _inst_2)))) (Subtype.val.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) (HasCompl.compl.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (IsLprojection.IsLprojection.Subtype.HasCompl.{u1} X _inst_1 M _inst_2 _inst_3) P)) (Subtype.val.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) R))) (HAdd.hAdd.{0, 0, 0} M M M (instHAdd.{0} M (Distrib.toAdd.{0} M (NonUnitalNonAssocSemiring.toDistrib.{0} M (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{0} M (NonAssocRing.toNonUnitalNonAssocRing.{0} M (Ring.toNonAssocRing.{0} M _inst_2)))))) (Subtype.val.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) P) (HMul.hMul.{0, 0, 0} M M M (instHMul.{0} M (NonUnitalNonAssocRing.toMul.{0} M (NonAssocRing.toNonUnitalNonAssocRing.{0} M (Ring.toNonAssocRing.{0} M _inst_2)))) (HMul.hMul.{0, 0, 0} M M M (instHMul.{0} M (NonUnitalNonAssocRing.toMul.{0} M (NonAssocRing.toNonUnitalNonAssocRing.{0} M (Ring.toNonAssocRing.{0} M _inst_2)))) (Subtype.val.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) Q) (Subtype.val.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) R)) (Subtype.val.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) (HasCompl.compl.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (IsLprojection.IsLprojection.Subtype.HasCompl.{u1} X _inst_1 M _inst_2 _inst_3) P))))) (HAdd.hAdd.{0, 0, 0} M M M (instHAdd.{0} M (Distrib.toAdd.{0} M (NonUnitalNonAssocSemiring.toDistrib.{0} M (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{0} M (NonAssocRing.toNonUnitalNonAssocRing.{0} M (Ring.toNonAssocRing.{0} M _inst_2)))))) (Subtype.val.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) P) (HMul.hMul.{0, 0, 0} M M M (instHMul.{0} M (NonUnitalNonAssocRing.toMul.{0} M (NonAssocRing.toNonUnitalNonAssocRing.{0} M (Ring.toNonAssocRing.{0} M _inst_2)))) (HMul.hMul.{0, 0, 0} M M M (instHMul.{0} M (NonUnitalNonAssocRing.toMul.{0} M (NonAssocRing.toNonUnitalNonAssocRing.{0} M (Ring.toNonAssocRing.{0} M _inst_2)))) (Subtype.val.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) Q) (Subtype.val.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) R)) (Subtype.val.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P) (HasCompl.compl.{0} (Subtype.{1} M (fun (P : M) => IsLprojection.{u1} X _inst_1 M _inst_2 _inst_3 P)) (IsLprojection.IsLprojection.Subtype.HasCompl.{u1} X _inst_1 M _inst_2 _inst_3) P))))
Case conversion may be inaccurate. Consider using '#align is_Lprojection.distrib_lattice_lemma IsLprojection.distrib_lattice_lemmaₓ'. -/
theorem distrib_lattice_lemma [FaithfulSMul M X] {P Q R : { P : M // IsLprojection X P }} :
    ((↑P : M) + ↑(Pᶜ) * R) * (↑P + ↑Q * ↑R * ↑(Pᶜ)) = ↑P + ↑Q * ↑R * ↑(Pᶜ) := by
  rw [add_mul, mul_add, mul_add, mul_assoc (↑(Pᶜ)) (↑R) (↑Q * ↑R * ↑(Pᶜ)), ←
    mul_assoc (↑R) (↑Q * ↑R) ↑(Pᶜ), ← coe_inf Q, (Pᶜ.Prop.Commute R.prop).Eq,
    ((Q ⊓ R).Prop.Commute Pᶜ.Prop).Eq, (R.prop.commute (Q ⊓ R).Prop).Eq, coe_inf Q, mul_assoc ↑Q, ←
    mul_assoc, mul_assoc ↑R, (Pᶜ.Prop.Commute P.prop).Eq, mul_compl_self, MulZeroClass.zero_mul,
    MulZeroClass.mul_zero, zero_add, add_zero, ← mul_assoc, P.prop.proj.eq, R.prop.proj.eq, ←
    coe_inf Q, mul_assoc, ((Q ⊓ R).Prop.Commute Pᶜ.Prop).Eq, ← mul_assoc, Pᶜ.Prop.proj.Eq]
#align is_Lprojection.distrib_lattice_lemma IsLprojection.distrib_lattice_lemma

instance [FaithfulSMul M X] : DistribLattice { P : M // IsLprojection X P } :=
  { IsLprojection.Subtype.hasInf, IsLprojection.Subtype.hasSup,
    IsLprojection.Subtype.partialOrder with
    le_sup_left := fun P Q => by
      rw [le_def, coe_inf, coe_sup, ← add_sub, mul_add, mul_sub, ← mul_assoc, P.prop.proj.eq,
        sub_self, add_zero]
    le_sup_right := fun P Q => by
      rw [le_def, coe_inf, coe_sup, ← add_sub, mul_add, mul_sub, Commute.eq (Commute P.prop Q.prop),
        ← mul_assoc, Q.prop.proj.eq, add_sub_cancel'_right]
    sup_le := fun P Q R =>
      by
      rw [le_def, le_def, le_def, coe_inf, coe_inf, coe_sup, coe_inf, coe_sup, ← add_sub, add_mul,
        sub_mul, mul_assoc]
      intro h₁ h₂
      rw [← h₂, ← h₁]
    inf_le_left := fun P Q => by
      rw [le_def, coe_inf, coe_inf, coe_inf, mul_assoc, (Q.prop.commute P.prop).Eq, ← mul_assoc,
        P.prop.proj.eq]
    inf_le_right := fun P Q => by rw [le_def, coe_inf, coe_inf, coe_inf, mul_assoc, Q.prop.proj.eq]
    le_inf := fun P Q R =>
      by
      rw [le_def, le_def, le_def, coe_inf, coe_inf, coe_inf, coe_inf, ← mul_assoc]
      intro h₁ h₂
      rw [← h₁, ← h₂]
    le_sup_inf := fun P Q R =>
      by
      have e₁ : ↑((P ⊔ Q) ⊓ (P ⊔ R)) = ↑P + ↑Q * ↑R * ↑(Pᶜ) := by
        rw [coe_inf, coe_sup, coe_sup, ← add_sub, ← add_sub, ← compl_mul, ← compl_mul, add_mul,
          mul_add, (Pᶜ.Prop.Commute Q.prop).Eq, mul_add, ← mul_assoc, mul_assoc ↑Q,
          (Pᶜ.Prop.Commute P.prop).Eq, mul_compl_self, MulZeroClass.zero_mul, MulZeroClass.mul_zero,
          zero_add, add_zero, ← mul_assoc, mul_assoc ↑Q, P.prop.proj.eq, Pᶜ.Prop.proj.Eq, mul_assoc,
          (Pᶜ.Prop.Commute R.prop).Eq, ← mul_assoc]
      have e₂ : ↑((P ⊔ Q) ⊓ (P ⊔ R)) * ↑(P ⊔ Q ⊓ R) = ↑P + ↑Q * ↑R * ↑(Pᶜ) := by
        rw [coe_inf, coe_sup, coe_sup, coe_sup, ← add_sub, ← add_sub, ← add_sub, ← compl_mul, ←
          compl_mul, ← compl_mul, (Pᶜ.Prop.Commute (Q ⊓ R).Prop).Eq, coe_inf, mul_assoc,
          distrib_lattice_lemma, (Q.prop.commute R.prop).Eq, distrib_lattice_lemma]
      rw [le_def, e₁, coe_inf, e₂] }

instance [FaithfulSMul M X] : BooleanAlgebra { P : M // IsLprojection X P } :=
  { IsLprojection.Subtype.hasCompl, IsLprojection.Subtype.hasSdiff,
    IsLprojection.Subtype.boundedOrder,
    IsLprojection.Subtype.distribLattice with
    inf_compl_le_bot := fun P =>
      (Subtype.ext (by rw [coe_inf, coe_compl, coe_bot, ← coe_compl, mul_compl_self])).le
    top_le_sup_compl := fun P =>
      (Subtype.ext
          (by
            rw [coe_top, coe_sup, coe_compl, add_sub_cancel'_right, ← coe_compl, mul_compl_self,
              sub_zero])).le
    sdiff_eq := fun P Q => Subtype.ext <| by rw [coe_sdiff, ← coe_compl, coe_inf] }

end IsLprojection

