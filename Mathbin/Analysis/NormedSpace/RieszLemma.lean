/-
Copyright (c) 2019 Jean Lo. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jean Lo, Yury Kudryashov

! This file was ported from Lean 3 source module analysis.normed_space.riesz_lemma
! leanprover-community/mathlib commit 9a48a083b390d9b84a71efbdc4e8dfa26a687104
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Analysis.NormedSpace.Basic
import Mathbin.Topology.MetricSpace.HausdorffDistance

/-!
# Applications of the Hausdorff distance in normed spaces

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

Riesz's lemma, stated for a normed space over a normed field: for any
closed proper subspace `F` of `E`, there is a nonzero `x` such that `‚Äñx - F‚Äñ`
is at least `r * ‚Äñx‚Äñ` for any `r < 1`. This is `riesz_lemma`.

In a nontrivially normed field (with an element `c` of norm `> 1`) and any `R > ‚Äñc‚Äñ`, one can
guarantee `‚Äñx‚Äñ ‚â§ R` and `‚Äñx - y‚Äñ ‚â• 1` for any `y` in `F`. This is `riesz_lemma_of_norm_lt`.

A further lemma, `metric.closed_ball_inf_dist_compl_subset_closure`, finds a *closed* ball within
the closure of a set `s` of optimal distance from a point in `x` to the frontier of `s`.
-/


open Set Metric

open Topology

variable {ùïú : Type _} [NormedField ùïú]

variable {E : Type _} [NormedAddCommGroup E] [NormedSpace ùïú E]

variable {F : Type _} [SeminormedAddCommGroup F] [NormedSpace ‚Ñù F]

/- warning: riesz_lemma -> riesz_lemma is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align riesz_lemma riesz_lemma‚Çì'. -/
/-- Riesz's lemma, which usually states that it is possible to find a
vector with norm 1 whose distance to a closed proper subspace is
arbitrarily close to 1. The statement here is in terms of multiples of
norms, since in general the existence of an element of norm exactly 1
is not guaranteed. For a variant giving an element with norm in `[1, R]`, see
`riesz_lemma_of_norm_lt`. -/
theorem riesz_lemma {F : Subspace ùïú E} (hFc : IsClosed (F : Set E)) (hF : ‚àÉ x : E, x ‚àâ F) {r : ‚Ñù}
    (hr : r < 1) : ‚àÉ x‚ÇÄ : E, x‚ÇÄ ‚àâ F ‚àß ‚àÄ y ‚àà F, r * ‚Äñx‚ÇÄ‚Äñ ‚â§ ‚Äñx‚ÇÄ - y‚Äñ := by
  classical
    obtain ‚ü®x, hx‚ü© : ‚àÉ x : E, x ‚àâ F := hF
    let d := Metric.infDist x F
    have hFn : (F : Set E).Nonempty := ‚ü®_, F.zero_mem‚ü©
    have hdp : 0 < d :=
      lt_of_le_of_ne Metric.infDist_nonneg fun heq =>
        hx ((hFc.mem_iff_inf_dist_zero hFn).2 HEq.symm)
    let r' := max r 2‚Åª¬π
    have hr' : r' < 1 := by simp [r', hr]; norm_num
    have hlt : 0 < r' := lt_of_lt_of_le (by norm_num) (le_max_right r 2‚Åª¬π)
    have hdlt : d < d / r' := (lt_div_iff hlt).mpr ((mul_lt_iff_lt_one_right hdp).2 hr')
    obtain ‚ü®y‚ÇÄ, hy‚ÇÄF, hxy‚ÇÄ‚ü© : ‚àÉ y ‚àà F, dist x y < d / r' := (Metric.infDist_lt_iff hFn).mp hdlt
    have x_ne_y‚ÇÄ : x - y‚ÇÄ ‚àâ F := by
      by_contra h
      have : x - y‚ÇÄ + y‚ÇÄ ‚àà F := F.add_mem h hy‚ÇÄF
      simp only [neg_add_cancel_right, sub_eq_add_neg] at this
      exact hx this
    refine' ‚ü®x - y‚ÇÄ, x_ne_y‚ÇÄ, fun y hy => le_of_lt _‚ü©
    have hy‚ÇÄy : y‚ÇÄ + y ‚àà F := F.add_mem hy‚ÇÄF hy
    calc
      r * ‚Äñx - y‚ÇÄ‚Äñ ‚â§ r' * ‚Äñx - y‚ÇÄ‚Äñ := mul_le_mul_of_nonneg_right (le_max_left _ _) (norm_nonneg _)
      _ < d := by rw [‚Üê dist_eq_norm]; exact (lt_div_iff' hlt).1 hxy‚ÇÄ
      _ ‚â§ dist x (y‚ÇÄ + y) := (Metric.infDist_le_dist_of_mem hy‚ÇÄy)
      _ = ‚Äñx - y‚ÇÄ - y‚Äñ := by rw [sub_sub, dist_eq_norm]
      
#align riesz_lemma riesz_lemma

/- warning: riesz_lemma_of_norm_lt -> riesz_lemma_of_norm_lt is a dubious translation:
lean 3 declaration is
  forall {ùïú : Type.{u1}} [_inst_1 : NormedField.{u1} ùïú] {E : Type.{u2}} [_inst_2 : NormedAddCommGroup.{u2} E] [_inst_3 : NormedSpace.{u1, u2} ùïú E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)] {c : ùïú}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (Norm.norm.{u1} ùïú (NormedField.toHasNorm.{u1} ùïú _inst_1) c)) -> (forall {R : Real}, (LT.lt.{0} Real Real.hasLt (Norm.norm.{u1} ùïú (NormedField.toHasNorm.{u1} ùïú _inst_1) c) R) -> (forall {F : Subspace.{u1, u2} ùïú E (NormedDivisionRing.toDivisionRing.{u1} ùïú (NormedField.toNormedDivisionRing.{u1} ùïú _inst_1)) (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2) (NormedSpace.toModule.{u1, u2} ùïú E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_3)}, (IsClosed.{u2} E (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Subspace.{u1, u2} ùïú E (NormedDivisionRing.toDivisionRing.{u1} ùïú (NormedField.toNormedDivisionRing.{u1} ùïú _inst_1)) (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2) (NormedSpace.toModule.{u1, u2} ùïú E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_3)) (Set.{u2} E) (HasLiftT.mk.{succ u2, succ u2} (Subspace.{u1, u2} ùïú E (NormedDivisionRing.toDivisionRing.{u1} ùïú (NormedField.toNormedDivisionRing.{u1} ùïú _inst_1)) (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2) (NormedSpace.toModule.{u1, u2} ùïú E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_3)) (Set.{u2} E) (CoeTC‚Çì.coe.{succ u2, succ u2} (Subspace.{u1, u2} ùïú E (NormedDivisionRing.toDivisionRing.{u1} ùïú (NormedField.toNormedDivisionRing.{u1} ùïú _inst_1)) (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2) (NormedSpace.toModule.{u1, u2} ùïú E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_3)) (Set.{u2} E) (SetLike.Set.hasCoeT.{u2, u2} (Subspace.{u1, u2} ùïú E (NormedDivisionRing.toDivisionRing.{u1} ùïú (NormedField.toNormedDivisionRing.{u1} ùïú _inst_1)) (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2) (NormedSpace.toModule.{u1, u2} ùïú E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_3)) E (Submodule.setLike.{u1, u2} ùïú E (Ring.toSemiring.{u1} ùïú (DivisionRing.toRing.{u1} ùïú (NormedDivisionRing.toDivisionRing.{u1} ùïú (NormedField.toNormedDivisionRing.{u1} ùïú _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) (NormedSpace.toModule.{u1, u2} ùïú E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_3))))) F)) -> (Exists.{succ u2} E (fun (x : E) => Not (Membership.Mem.{u2, u2} E (Subspace.{u1, u2} ùïú E (NormedDivisionRing.toDivisionRing.{u1} ùïú (NormedField.toNormedDivisionRing.{u1} ùïú _inst_1)) (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2) (NormedSpace.toModule.{u1, u2} ùïú E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_3)) (SetLike.hasMem.{u2, u2} (Subspace.{u1, u2} ùïú E (NormedDivisionRing.toDivisionRing.{u1} ùïú (NormedField.toNormedDivisionRing.{u1} ùïú _inst_1)) (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2) (NormedSpace.toModule.{u1, u2} ùïú E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_3)) E (Submodule.setLike.{u1, u2} ùïú E (Ring.toSemiring.{u1} ùïú (DivisionRing.toRing.{u1} ùïú (NormedDivisionRing.toDivisionRing.{u1} ùïú (NormedField.toNormedDivisionRing.{u1} ùïú _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) (NormedSpace.toModule.{u1, u2} ùïú E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_3))) x F))) -> (Exists.{succ u2} E (fun (x‚ÇÄ : E) => And (LE.le.{0} Real Real.hasLe (Norm.norm.{u2} E (NormedAddCommGroup.toHasNorm.{u2} E _inst_2) x‚ÇÄ) R) (forall (y : E), (Membership.Mem.{u2, u2} E (Subspace.{u1, u2} ùïú E (NormedDivisionRing.toDivisionRing.{u1} ùïú (NormedField.toNormedDivisionRing.{u1} ùïú _inst_1)) (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2) (NormedSpace.toModule.{u1, u2} ùïú E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_3)) (SetLike.hasMem.{u2, u2} (Subspace.{u1, u2} ùïú E (NormedDivisionRing.toDivisionRing.{u1} ùïú (NormedField.toNormedDivisionRing.{u1} ùïú _inst_1)) (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2) (NormedSpace.toModule.{u1, u2} ùïú E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_3)) E (Submodule.setLike.{u1, u2} ùïú E (Ring.toSemiring.{u1} ùïú (DivisionRing.toRing.{u1} ùïú (NormedDivisionRing.toDivisionRing.{u1} ùïú (NormedField.toNormedDivisionRing.{u1} ùïú _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) (NormedSpace.toModule.{u1, u2} ùïú E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_3))) y F) -> (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (Norm.norm.{u2} E (NormedAddCommGroup.toHasNorm.{u2} E _inst_2) (HSub.hSub.{u2, u2, u2} E E E (instHSub.{u2} E (SubNegMonoid.toHasSub.{u2} E (AddGroup.toSubNegMonoid.{u2} E (NormedAddGroup.toAddGroup.{u2} E (NormedAddCommGroup.toNormedAddGroup.{u2} E _inst_2))))) x‚ÇÄ y))))))))
but is expected to have type
  forall {ùïú : Type.{u2}} [_inst_1 : NormedField.{u2} ùïú] {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_3 : NormedSpace.{u2, u1} ùïú E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] {c : ùïú}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (Norm.norm.{u2} ùïú (NormedField.toNorm.{u2} ùïú _inst_1) c)) -> (forall {R : Real}, (LT.lt.{0} Real Real.instLTReal (Norm.norm.{u2} ùïú (NormedField.toNorm.{u2} ùïú _inst_1) c) R) -> (forall {F : Subspace.{u2, u1} ùïú E (NormedDivisionRing.toDivisionRing.{u2} ùïú (NormedField.toNormedDivisionRing.{u2} ùïú _inst_1)) (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2) (NormedSpace.toModule.{u2, u1} ùïú E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_3)}, (IsClosed.{u1} E (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))) (SetLike.coe.{u1, u1} (Subspace.{u2, u1} ùïú E (NormedDivisionRing.toDivisionRing.{u2} ùïú (NormedField.toNormedDivisionRing.{u2} ùïú _inst_1)) (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2) (NormedSpace.toModule.{u2, u1} ùïú E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_3)) E (Submodule.setLike.{u2, u1} ùïú E (DivisionSemiring.toSemiring.{u2} ùïú (DivisionRing.toDivisionSemiring.{u2} ùïú (NormedDivisionRing.toDivisionRing.{u2} ùïú (NormedField.toNormedDivisionRing.{u2} ùïú _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{u2, u1} ùïú E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_3)) F)) -> (Exists.{succ u1} E (fun (x : E) => Not (Membership.mem.{u1, u1} E (Subspace.{u2, u1} ùïú E (NormedDivisionRing.toDivisionRing.{u2} ùïú (NormedField.toNormedDivisionRing.{u2} ùïú _inst_1)) (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2) (NormedSpace.toModule.{u2, u1} ùïú E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_3)) (SetLike.instMembership.{u1, u1} (Subspace.{u2, u1} ùïú E (NormedDivisionRing.toDivisionRing.{u2} ùïú (NormedField.toNormedDivisionRing.{u2} ùïú _inst_1)) (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2) (NormedSpace.toModule.{u2, u1} ùïú E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_3)) E (Submodule.setLike.{u2, u1} ùïú E (DivisionSemiring.toSemiring.{u2} ùïú (DivisionRing.toDivisionSemiring.{u2} ùïú (NormedDivisionRing.toDivisionRing.{u2} ùïú (NormedField.toNormedDivisionRing.{u2} ùïú _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{u2, u1} ùïú E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_3))) x F))) -> (Exists.{succ u1} E (fun (x‚ÇÄ : E) => And (LE.le.{0} Real Real.instLEReal (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) x‚ÇÄ) R) (forall (y : E), (Membership.mem.{u1, u1} E (Subspace.{u2, u1} ùïú E (NormedDivisionRing.toDivisionRing.{u2} ùïú (NormedField.toNormedDivisionRing.{u2} ùïú _inst_1)) (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2) (NormedSpace.toModule.{u2, u1} ùïú E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_3)) (SetLike.instMembership.{u1, u1} (Subspace.{u2, u1} ùïú E (NormedDivisionRing.toDivisionRing.{u2} ùïú (NormedField.toNormedDivisionRing.{u2} ùïú _inst_1)) (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2) (NormedSpace.toModule.{u2, u1} ùïú E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_3)) E (Submodule.setLike.{u2, u1} ùïú E (DivisionSemiring.toSemiring.{u2} ùïú (DivisionRing.toDivisionSemiring.{u2} ùïú (NormedDivisionRing.toDivisionRing.{u2} ùïú (NormedField.toNormedDivisionRing.{u2} ùïú _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{u2, u1} ùïú E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_3))) y F) -> (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) (HSub.hSub.{u1, u1, u1} E E E (instHSub.{u1} E (SubNegMonoid.toSub.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))) x‚ÇÄ y))))))))
Case conversion may be inaccurate. Consider using '#align riesz_lemma_of_norm_lt riesz_lemma_of_norm_lt‚Çì'. -/
/--
A version of Riesz lemma: given a strict closed subspace `F`, one may find an element of norm `‚â§ R`
which is at distance  at least `1` of every element of `F`. Here, `R` is any given constant
strictly larger than the norm of an element of norm `> 1`. For a version without an `R`, see
`riesz_lemma`.

Since we are considering a general nontrivially normed field, there may be a gap in possible norms
(for instance no element of norm in `(1,2)`). Hence, we can not allow `R` arbitrarily close to `1`,
and require `R > ‚Äñc‚Äñ` for some `c : ùïú` with norm `> 1`.
-/
theorem riesz_lemma_of_norm_lt {c : ùïú} (hc : 1 < ‚Äñc‚Äñ) {R : ‚Ñù} (hR : ‚Äñc‚Äñ < R) {F : Subspace ùïú E}
    (hFc : IsClosed (F : Set E)) (hF : ‚àÉ x : E, x ‚àâ F) :
    ‚àÉ x‚ÇÄ : E, ‚Äñx‚ÇÄ‚Äñ ‚â§ R ‚àß ‚àÄ y ‚àà F, 1 ‚â§ ‚Äñx‚ÇÄ - y‚Äñ :=
  by
  have Rpos : 0 < R := (norm_nonneg _).trans_lt hR
  have : ‚Äñc‚Äñ / R < 1 := by rw [div_lt_iff Rpos]; simpa using hR
  rcases riesz_lemma hFc hF this with ‚ü®x, xF, hx‚ü©
  have x0 : x ‚â† 0 := fun H => by simpa [H] using xF
  obtain ‚ü®d, d0, dxlt, ledx, -‚ü© :
    ‚àÉ d : ùïú, d ‚â† 0 ‚àß ‚Äñd ‚Ä¢ x‚Äñ < R ‚àß R / ‚Äñc‚Äñ ‚â§ ‚Äñd ‚Ä¢ x‚Äñ ‚àß ‚Äñd‚Äñ‚Åª¬π ‚â§ R‚Åª¬π * ‚Äñc‚Äñ * ‚Äñx‚Äñ :=
    rescale_to_shell hc Rpos x0
  refine' ‚ü®d ‚Ä¢ x, dxlt.le, fun y hy => _‚ü©
  set y' := d‚Åª¬π ‚Ä¢ y with hy'
  have y'F : y' ‚àà F := by simp [hy', Submodule.smul_mem _ _ hy]
  have yy' : y = d ‚Ä¢ y' := by simp [hy', smul_smul, mul_inv_cancel d0]
  calc
    1 = ‚Äñc‚Äñ / R * (R / ‚Äñc‚Äñ) := by field_simp [Rpos.ne', (zero_lt_one.trans hc).ne']
    _ ‚â§ ‚Äñc‚Äñ / R * ‚Äñd ‚Ä¢ x‚Äñ := (mul_le_mul_of_nonneg_left ledx (div_nonneg (norm_nonneg _) Rpos.le))
    _ = ‚Äñd‚Äñ * (‚Äñc‚Äñ / R * ‚Äñx‚Äñ) := by simp [norm_smul]; ring
    _ ‚â§ ‚Äñd‚Äñ * ‚Äñx - y'‚Äñ :=
      (mul_le_mul_of_nonneg_left (hx y' (by simp [hy', Submodule.smul_mem _ _ hy])) (norm_nonneg _))
    _ = ‚Äñd ‚Ä¢ x - y‚Äñ := by simp [yy', ‚Üê smul_sub, norm_smul]
    
#align riesz_lemma_of_norm_lt riesz_lemma_of_norm_lt

#print Metric.closedBall_infDist_compl_subset_closure /-
theorem Metric.closedBall_infDist_compl_subset_closure {x : F} {s : Set F} (hx : x ‚àà s) :
    closedBall x (infDist x (s·∂ú)) ‚äÜ closure s :=
  by
  cases' eq_or_ne (inf_dist x (s·∂ú)) 0 with h‚ÇÄ h‚ÇÄ
  ¬∑ rw [h‚ÇÄ, closed_ball_zero']
    exact closure_mono (singleton_subset_iff.2 hx)
  ¬∑ rw [‚Üê closure_ball x h‚ÇÄ]
    exact closure_mono ball_inf_dist_compl_subset
#align metric.closed_ball_inf_dist_compl_subset_closure Metric.closedBall_infDist_compl_subset_closure
-/

