/-
Copyright (c) 2018 Patrick Massot. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Patrick Massot, Johannes Hölzl

! This file was ported from Lean 3 source module analysis.normed_space.basic
! leanprover-community/mathlib commit 8000bbbe2e9d39b84edb993d88781f536a8a3fa8
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Algebra.Pi
import Mathbin.Algebra.Algebra.RestrictScalars
import Mathbin.Analysis.Normed.Field.Basic
import Mathbin.Data.Real.Sqrt
import Mathbin.Topology.Algebra.Module.Basic

/-!
# Normed spaces

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file we define (semi)normed spaces and algebras. We also prove some theorems
about these definitions.
-/


variable {α : Type _} {β : Type _} {γ : Type _} {ι : Type _}

open Filter Metric Function Set

open Topology BigOperators NNReal ENNReal uniformity Pointwise

section SeminormedAddCommGroup

section Prio

/- ./././Mathport/Syntax/Translate/Basic.lean:334:40: warning: unsupported option extends_priority -/
set_option extends_priority 920

#print NormedSpace /-
-- Here, we set a rather high priority for the instance `[normed_space α β] : module α β`
-- to take precedence over `semiring.to_module` as this leads to instance paths with better
-- unification properties.
/-- A normed space over a normed field is a vector space endowed with a norm which satisfies the
equality `‖c • x‖ = ‖c‖ ‖x‖`. We require only `‖c • x‖ ≤ ‖c‖ ‖x‖` in the definition, then prove
`‖c • x‖ = ‖c‖ ‖x‖` in `norm_smul`.

Note that since this requires `seminormed_add_comm_group` and not `normed_add_comm_group`, this
typeclass can be used for "semi normed spaces" too, just as `module` can be used for
"semi modules". -/
class NormedSpace (α : Type _) (β : Type _) [NormedField α] [SeminormedAddCommGroup β] extends
  Module α β where
  norm_smul_le : ∀ (a : α) (b : β), ‖a • b‖ ≤ ‖a‖ * ‖b‖
#align normed_space NormedSpace
-/

end Prio

variable [NormedField α] [SeminormedAddCommGroup β]

-- note: while these are currently strictly weaker than the versions without `le`, they will cease
-- to be if we eventually generalize `normed_space` from `normed_field α` to `normed_ring α`.
section Le

/- warning: norm_smul_le -> norm_smul_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NormedField.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] [_inst_3 : NormedSpace.{u1, u2} α β _inst_1 _inst_2] (r : α) (x : β), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} β (SeminormedAddCommGroup.toHasNorm.{u2} β _inst_2) (SMul.smul.{u1, u2} α β (SMulZeroClass.toHasSmul.{u1, u2} α β (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} α β (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))))))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} α β (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1))))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (Module.toMulActionWithZero.{u1, u2} α β (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)) (NormedSpace.toModule.{u1, u2} α β _inst_1 _inst_2 _inst_3))))) r x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Norm.norm.{u1} α (NormedField.toHasNorm.{u1} α _inst_1) r) (Norm.norm.{u2} β (SeminormedAddCommGroup.toHasNorm.{u2} β _inst_2) x))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : NormedField.{u2} α] [_inst_2 : SeminormedAddCommGroup.{u1} β] [_inst_3 : NormedSpace.{u2, u1} α β _inst_1 _inst_2] (r : α) (x : β), LE.le.{0} Real Real.instLEReal (Norm.norm.{u1} β (SeminormedAddCommGroup.toNorm.{u1} β _inst_2) (HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (CommMonoidWithZero.toZero.{u2} α (CommGroupWithZero.toCommMonoidWithZero.{u2} α (Semifield.toCommGroupWithZero.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)) (NormedSpace.toModule.{u2, u1} α β _inst_1 _inst_2 _inst_3)))))) r x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Norm.norm.{u2} α (NormedField.toNorm.{u2} α _inst_1) r) (Norm.norm.{u1} β (SeminormedAddCommGroup.toNorm.{u1} β _inst_2) x))
Case conversion may be inaccurate. Consider using '#align norm_smul_le norm_smul_leₓ'. -/
theorem norm_smul_le [NormedSpace α β] (r : α) (x : β) : ‖r • x‖ ≤ ‖r‖ * ‖x‖ :=
  NormedSpace.norm_smul_le _ _
#align norm_smul_le norm_smul_le

/- warning: nnnorm_smul_le -> nnnorm_smul_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NormedField.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] [_inst_3 : NormedSpace.{u1, u2} α β _inst_1 _inst_2] (s : α) (x : β), LE.le.{0} NNReal (Preorder.toLE.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (NNNorm.nnnorm.{u2} β (SeminormedAddGroup.toNNNorm.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_2)) (SMul.smul.{u1, u2} α β (SMulZeroClass.toHasSmul.{u1, u2} α β (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} α β (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))))))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} α β (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1))))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (Module.toMulActionWithZero.{u1, u2} α β (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)) (NormedSpace.toModule.{u1, u2} α β _inst_1 _inst_2 _inst_3))))) s x)) (HMul.hMul.{0, 0, 0} NNReal NNReal NNReal (instHMul.{0} NNReal (Distrib.toHasMul.{0} NNReal (NonUnitalNonAssocSemiring.toDistrib.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))) (NNNorm.nnnorm.{u1} α (SeminormedAddGroup.toNNNorm.{u1} α (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} α (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} α (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u1} α (NormedRing.toNonUnitalNormedRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1))))))) s) (NNNorm.nnnorm.{u2} β (SeminormedAddGroup.toNNNorm.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_2)) x))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : NormedField.{u2} α] [_inst_2 : SeminormedAddCommGroup.{u1} β] [_inst_3 : NormedSpace.{u2, u1} α β _inst_1 _inst_2] (s : α) (x : β), LE.le.{0} NNReal (Preorder.toLE.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) (NNNorm.nnnorm.{u1} β (SeminormedAddGroup.toNNNorm.{u1} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} β _inst_2)) (HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (CommMonoidWithZero.toZero.{u2} α (CommGroupWithZero.toCommMonoidWithZero.{u2} α (Semifield.toCommGroupWithZero.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)) (NormedSpace.toModule.{u2, u1} α β _inst_1 _inst_2 _inst_3)))))) s x)) (HMul.hMul.{0, 0, 0} NNReal NNReal NNReal (instHMul.{0} NNReal (CanonicallyOrderedCommSemiring.toMul.{0} NNReal instNNRealCanonicallyOrderedCommSemiring)) (NNNorm.nnnorm.{u2} α (SeminormedAddGroup.toNNNorm.{u2} α (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} α (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u2} α (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u2} α (NormedRing.toNonUnitalNormedRing.{u2} α (NormedCommRing.toNormedRing.{u2} α (NormedField.toNormedCommRing.{u2} α _inst_1))))))) s) (NNNorm.nnnorm.{u1} β (SeminormedAddGroup.toNNNorm.{u1} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} β _inst_2)) x))
Case conversion may be inaccurate. Consider using '#align nnnorm_smul_le nnnorm_smul_leₓ'. -/
theorem nnnorm_smul_le [NormedSpace α β] (s : α) (x : β) : ‖s • x‖₊ ≤ ‖s‖₊ * ‖x‖₊ :=
  norm_smul_le s x
#align nnnorm_smul_le nnnorm_smul_le

/- warning: dist_smul_le -> dist_smul_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NormedField.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] [_inst_3 : NormedSpace.{u1, u2} α β _inst_1 _inst_2] (s : α) (x : β) (y : β), LE.le.{0} Real Real.hasLe (Dist.dist.{u2} β (PseudoMetricSpace.toHasDist.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (SMul.smul.{u1, u2} α β (SMulZeroClass.toHasSmul.{u1, u2} α β (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} α β (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))))))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} α β (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1))))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (Module.toMulActionWithZero.{u1, u2} α β (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)) (NormedSpace.toModule.{u1, u2} α β _inst_1 _inst_2 _inst_3))))) s x) (SMul.smul.{u1, u2} α β (SMulZeroClass.toHasSmul.{u1, u2} α β (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} α β (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))))))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} α β (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1))))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (Module.toMulActionWithZero.{u1, u2} α β (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)) (NormedSpace.toModule.{u1, u2} α β _inst_1 _inst_2 _inst_3))))) s y)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Norm.norm.{u1} α (NormedField.toHasNorm.{u1} α _inst_1) s) (Dist.dist.{u2} β (PseudoMetricSpace.toHasDist.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) x y))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : NormedField.{u2} α] [_inst_2 : SeminormedAddCommGroup.{u1} β] [_inst_3 : NormedSpace.{u2, u1} α β _inst_1 _inst_2] (s : α) (x : β) (y : β), LE.le.{0} Real Real.instLEReal (Dist.dist.{u1} β (PseudoMetricSpace.toDist.{u1} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} β _inst_2)) (HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (CommMonoidWithZero.toZero.{u2} α (CommGroupWithZero.toCommMonoidWithZero.{u2} α (Semifield.toCommGroupWithZero.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)) (NormedSpace.toModule.{u2, u1} α β _inst_1 _inst_2 _inst_3)))))) s x) (HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (CommMonoidWithZero.toZero.{u2} α (CommGroupWithZero.toCommMonoidWithZero.{u2} α (Semifield.toCommGroupWithZero.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)) (NormedSpace.toModule.{u2, u1} α β _inst_1 _inst_2 _inst_3)))))) s y)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Norm.norm.{u2} α (NormedField.toNorm.{u2} α _inst_1) s) (Dist.dist.{u1} β (PseudoMetricSpace.toDist.{u1} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} β _inst_2)) x y))
Case conversion may be inaccurate. Consider using '#align dist_smul_le dist_smul_leₓ'. -/
theorem dist_smul_le [NormedSpace α β] (s : α) (x y : β) : dist (s • x) (s • y) ≤ ‖s‖ * dist x y :=
  by simpa only [dist_eq_norm, ← smul_sub] using norm_smul_le _ _
#align dist_smul_le dist_smul_le

/- warning: nndist_smul_le -> nndist_smul_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NormedField.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] [_inst_3 : NormedSpace.{u1, u2} α β _inst_1 _inst_2] (s : α) (x : β) (y : β), LE.le.{0} NNReal (Preorder.toLE.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (NNDist.nndist.{u2} β (PseudoMetricSpace.toNNDist.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (SMul.smul.{u1, u2} α β (SMulZeroClass.toHasSmul.{u1, u2} α β (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} α β (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))))))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} α β (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1))))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (Module.toMulActionWithZero.{u1, u2} α β (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)) (NormedSpace.toModule.{u1, u2} α β _inst_1 _inst_2 _inst_3))))) s x) (SMul.smul.{u1, u2} α β (SMulZeroClass.toHasSmul.{u1, u2} α β (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} α β (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))))))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} α β (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1))))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (Module.toMulActionWithZero.{u1, u2} α β (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)) (NormedSpace.toModule.{u1, u2} α β _inst_1 _inst_2 _inst_3))))) s y)) (HMul.hMul.{0, 0, 0} NNReal NNReal NNReal (instHMul.{0} NNReal (Distrib.toHasMul.{0} NNReal (NonUnitalNonAssocSemiring.toDistrib.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))) (NNNorm.nnnorm.{u1} α (SeminormedAddGroup.toNNNorm.{u1} α (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} α (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} α (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u1} α (NormedRing.toNonUnitalNormedRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1))))))) s) (NNDist.nndist.{u2} β (PseudoMetricSpace.toNNDist.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) x y))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : NormedField.{u2} α] [_inst_2 : SeminormedAddCommGroup.{u1} β] [_inst_3 : NormedSpace.{u2, u1} α β _inst_1 _inst_2] (s : α) (x : β) (y : β), LE.le.{0} NNReal (Preorder.toLE.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) (NNDist.nndist.{u1} β (PseudoMetricSpace.toNNDist.{u1} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} β _inst_2)) (HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (CommMonoidWithZero.toZero.{u2} α (CommGroupWithZero.toCommMonoidWithZero.{u2} α (Semifield.toCommGroupWithZero.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)) (NormedSpace.toModule.{u2, u1} α β _inst_1 _inst_2 _inst_3)))))) s x) (HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (CommMonoidWithZero.toZero.{u2} α (CommGroupWithZero.toCommMonoidWithZero.{u2} α (Semifield.toCommGroupWithZero.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)) (NormedSpace.toModule.{u2, u1} α β _inst_1 _inst_2 _inst_3)))))) s y)) (HMul.hMul.{0, 0, 0} NNReal NNReal NNReal (instHMul.{0} NNReal (CanonicallyOrderedCommSemiring.toMul.{0} NNReal instNNRealCanonicallyOrderedCommSemiring)) (NNNorm.nnnorm.{u2} α (SeminormedAddGroup.toNNNorm.{u2} α (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} α (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u2} α (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u2} α (NormedRing.toNonUnitalNormedRing.{u2} α (NormedCommRing.toNormedRing.{u2} α (NormedField.toNormedCommRing.{u2} α _inst_1))))))) s) (NNDist.nndist.{u1} β (PseudoMetricSpace.toNNDist.{u1} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} β _inst_2)) x y))
Case conversion may be inaccurate. Consider using '#align nndist_smul_le nndist_smul_leₓ'. -/
theorem nndist_smul_le [NormedSpace α β] (s : α) (x y : β) :
    nndist (s • x) (s • y) ≤ ‖s‖₊ * nndist x y :=
  dist_smul_le s x y
#align nndist_smul_le nndist_smul_le

end Le

/- warning: normed_space.has_bounded_smul -> NormedSpace.boundedSMul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NormedField.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] [_inst_3 : NormedSpace.{u1, u2} α β _inst_1 _inst_2], BoundedSMul.{u1, u2} α β (SeminormedRing.toPseudoMetricSpace.{u1} α (SeminormedCommRing.toSemiNormedRing.{u1} α (NormedCommRing.toSeminormedCommRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))) (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))))))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (SeminormedAddGroup.toAddGroup.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_2)))))) (SMulZeroClass.toHasSmul.{u1, u2} α β (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} α β (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))))))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} α β (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1))))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (Module.toMulActionWithZero.{u1, u2} α β (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)) (NormedSpace.toModule.{u1, u2} α β _inst_1 _inst_2 _inst_3)))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NormedField.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] [_inst_3 : NormedSpace.{u1, u2} α β _inst_1 _inst_2], BoundedSMul.{u1, u2} α β (SeminormedRing.toPseudoMetricSpace.{u1} α (SeminormedCommRing.toSeminormedRing.{u1} α (NormedCommRing.toSeminormedCommRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))) (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (CommMonoidWithZero.toZero.{u1} α (CommGroupWithZero.toCommMonoidWithZero.{u1} α (Semifield.toCommGroupWithZero.{u1} α (Field.toSemifield.{u1} α (NormedField.toField.{u1} α _inst_1))))) (NegZeroClass.toZero.{u2} β (SubNegZeroMonoid.toNegZeroClass.{u2} β (SubtractionMonoid.toSubNegZeroMonoid.{u2} β (SubtractionCommMonoid.toSubtractionMonoid.{u2} β (AddCommGroup.toDivisionAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)))))) (SMulZeroClass.toSMul.{u1, u2} α β (NegZeroClass.toZero.{u2} β (SubNegZeroMonoid.toNegZeroClass.{u2} β (SubtractionMonoid.toSubNegZeroMonoid.{u2} β (SubtractionCommMonoid.toSubtractionMonoid.{u2} β (AddCommGroup.toDivisionAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u1, u2} α β (CommMonoidWithZero.toZero.{u1} α (CommGroupWithZero.toCommMonoidWithZero.{u1} α (Semifield.toCommGroupWithZero.{u1} α (Field.toSemifield.{u1} α (NormedField.toField.{u1} α _inst_1))))) (NegZeroClass.toZero.{u2} β (SubNegZeroMonoid.toNegZeroClass.{u2} β (SubtractionMonoid.toSubNegZeroMonoid.{u2} β (SubtractionCommMonoid.toSubtractionMonoid.{u2} β (AddCommGroup.toDivisionAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} α β (Semiring.toMonoidWithZero.{u1} α (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α (Field.toSemifield.{u1} α (NormedField.toField.{u1} α _inst_1))))) (NegZeroClass.toZero.{u2} β (SubNegZeroMonoid.toNegZeroClass.{u2} β (SubtractionMonoid.toSubNegZeroMonoid.{u2} β (SubtractionCommMonoid.toSubtractionMonoid.{u2} β (AddCommGroup.toDivisionAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} α β (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α (Field.toSemifield.{u1} α (NormedField.toField.{u1} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)) (NormedSpace.toModule.{u1, u2} α β _inst_1 _inst_2 _inst_3)))))
Case conversion may be inaccurate. Consider using '#align normed_space.has_bounded_smul NormedSpace.boundedSMulₓ'. -/
-- see Note [lower instance priority]
instance (priority := 100) NormedSpace.boundedSMul [NormedSpace α β] : BoundedSMul α β
    where
  dist_smul_pair' x y₁ y₂ := by simpa [dist_eq_norm, smul_sub] using norm_smul_le x (y₁ - y₂)
  dist_pair_smul' x₁ x₂ y := by simpa [dist_eq_norm, sub_smul] using norm_smul_le (x₁ - x₂) y
#align normed_space.has_bounded_smul NormedSpace.boundedSMul

-- Shortcut instance, as otherwise this will be found by `normed_space.to_module` and be
-- noncomputable.
instance : Module ℝ ℝ := by infer_instance

#print NormedField.toNormedSpace /-
instance NormedField.toNormedSpace : NormedSpace α α where norm_smul_le a b := norm_mul_le a b
#align normed_field.to_normed_space NormedField.toNormedSpace
-/

/- warning: norm_smul -> norm_smul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NormedField.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] [_inst_3 : NormedSpace.{u1, u2} α β _inst_1 _inst_2] (s : α) (x : β), Eq.{1} Real (Norm.norm.{u2} β (SeminormedAddCommGroup.toHasNorm.{u2} β _inst_2) (SMul.smul.{u1, u2} α β (SMulZeroClass.toHasSmul.{u1, u2} α β (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} α β (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))))))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} α β (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1))))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (Module.toMulActionWithZero.{u1, u2} α β (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)) (NormedSpace.toModule.{u1, u2} α β _inst_1 _inst_2 _inst_3))))) s x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Norm.norm.{u1} α (NormedField.toHasNorm.{u1} α _inst_1) s) (Norm.norm.{u2} β (SeminormedAddCommGroup.toHasNorm.{u2} β _inst_2) x))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : NormedField.{u2} α] [_inst_2 : SeminormedAddCommGroup.{u1} β] [_inst_3 : NormedSpace.{u2, u1} α β _inst_1 _inst_2] (s : α) (x : β), Eq.{1} Real (Norm.norm.{u1} β (SeminormedAddCommGroup.toNorm.{u1} β _inst_2) (HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (CommMonoidWithZero.toZero.{u2} α (CommGroupWithZero.toCommMonoidWithZero.{u2} α (Semifield.toCommGroupWithZero.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)) (NormedSpace.toModule.{u2, u1} α β _inst_1 _inst_2 _inst_3)))))) s x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Norm.norm.{u2} α (NormedField.toNorm.{u2} α _inst_1) s) (Norm.norm.{u1} β (SeminormedAddCommGroup.toNorm.{u1} β _inst_2) x))
Case conversion may be inaccurate. Consider using '#align norm_smul norm_smulₓ'. -/
theorem norm_smul [NormedSpace α β] (s : α) (x : β) : ‖s • x‖ = ‖s‖ * ‖x‖ :=
  by
  by_cases h : s = 0
  · simp [h]
  · refine' le_antisymm (norm_smul_le s x) _
    calc
      ‖s‖ * ‖x‖ = ‖s‖ * ‖s⁻¹ • s • x‖ := by rw [inv_smul_smul₀ h]
      _ ≤ ‖s‖ * (‖s⁻¹‖ * ‖s • x‖) := (mul_le_mul_of_nonneg_left (norm_smul_le _ _) (norm_nonneg _))
      _ = ‖s • x‖ := by rw [norm_inv, ← mul_assoc, mul_inv_cancel (mt norm_eq_zero.1 h), one_mul]
      
#align norm_smul norm_smul

/- warning: norm_zsmul -> norm_zsmul is a dubious translation:
lean 3 declaration is
  forall {β : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} β] (α : Type.{u2}) [_inst_3 : NormedField.{u2} α] [_inst_4 : NormedSpace.{u2, u1} α β _inst_3 _inst_2] (n : Int) (x : β), Eq.{1} Real (Norm.norm.{u1} β (SeminormedAddCommGroup.toHasNorm.{u1} β _inst_2) (SMul.smul.{0, u1} Int β (SubNegMonoid.SMulInt.{u1} β (AddGroup.toSubNegMonoid.{u1} β (SeminormedAddGroup.toAddGroup.{u1} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} β _inst_2)))) n x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Norm.norm.{u2} α (NormedField.toHasNorm.{u2} α _inst_3) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Int α (HasLiftT.mk.{1, succ u2} Int α (CoeTCₓ.coe.{1, succ u2} Int α (Int.castCoe.{u2} α (AddGroupWithOne.toHasIntCast.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (NormedRing.toRing.{u2} α (NormedCommRing.toNormedRing.{u2} α (NormedField.toNormedCommRing.{u2} α _inst_3))))))))) n)) (Norm.norm.{u1} β (SeminormedAddCommGroup.toHasNorm.{u1} β _inst_2) x))
but is expected to have type
  forall {β : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} β] (α : Type.{u2}) [_inst_3 : NormedField.{u2} α] [_inst_4 : NormedSpace.{u2, u1} α β _inst_3 _inst_2] (n : Int) (x : β), Eq.{1} Real (Norm.norm.{u1} β (SeminormedAddCommGroup.toNorm.{u1} β _inst_2) (HSMul.hSMul.{0, u1, u1} Int β β (instHSMul.{0, u1} Int β (SubNegMonoid.SMulInt.{u1} β (AddGroup.toSubNegMonoid.{u1} β (SeminormedAddGroup.toAddGroup.{u1} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} β _inst_2))))) n x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Norm.norm.{u2} α (NormedField.toNorm.{u2} α _inst_3) (Int.cast.{u2} α (Ring.toIntCast.{u2} α (NormedRing.toRing.{u2} α (NormedCommRing.toNormedRing.{u2} α (NormedField.toNormedCommRing.{u2} α _inst_3)))) n)) (Norm.norm.{u1} β (SeminormedAddCommGroup.toNorm.{u1} β _inst_2) x))
Case conversion may be inaccurate. Consider using '#align norm_zsmul norm_zsmulₓ'. -/
theorem norm_zsmul (α) [NormedField α] [NormedSpace α β] (n : ℤ) (x : β) :
    ‖n • x‖ = ‖(n : α)‖ * ‖x‖ := by rw [← norm_smul, ← Int.smul_one_eq_coe, smul_assoc, one_smul]
#align norm_zsmul norm_zsmul

/- warning: abs_norm_eq_norm -> abs_norm_eq_norm is a dubious translation:
lean 3 declaration is
  forall {β : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} β] (z : β), Eq.{1} Real (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.hasNeg Real.hasSup) (Norm.norm.{u1} β (SeminormedAddCommGroup.toHasNorm.{u1} β _inst_2) z)) (Norm.norm.{u1} β (SeminormedAddCommGroup.toHasNorm.{u1} β _inst_2) z)
but is expected to have type
  forall {β : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} β] (z : β), Eq.{1} Real (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.instNegReal Real.instSupReal) (Norm.norm.{u1} β (SeminormedAddCommGroup.toNorm.{u1} β _inst_2) z)) (Norm.norm.{u1} β (SeminormedAddCommGroup.toNorm.{u1} β _inst_2) z)
Case conversion may be inaccurate. Consider using '#align abs_norm_eq_norm abs_norm_eq_normₓ'. -/
@[simp]
theorem abs_norm_eq_norm (z : β) : |‖z‖| = ‖z‖ :=
  (abs_eq (norm_nonneg z)).mpr (Or.inl rfl)
#align abs_norm_eq_norm abs_norm_eq_norm

/- warning: inv_norm_smul_mem_closed_unit_ball -> inv_norm_smul_mem_closed_unit_ball is a dubious translation:
lean 3 declaration is
  forall {β : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} β] [_inst_3 : NormedSpace.{0, u1} Real β Real.normedField _inst_2] (x : β), Membership.Mem.{u1, u1} β (Set.{u1} β) (Set.hasMem.{u1} β) (SMul.smul.{0, u1} Real β (SMulZeroClass.toHasSmul.{0, u1} Real β (AddZeroClass.toHasZero.{u1} β (AddMonoid.toAddZeroClass.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (AddCommGroup.toAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2))))) (SMulWithZero.toSmulZeroClass.{0, u1} Real β (MulZeroClass.toHasZero.{0} Real (MulZeroOneClass.toMulZeroClass.{0} Real (MonoidWithZero.toMulZeroOneClass.{0} Real (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))))))) (AddZeroClass.toHasZero.{u1} β (AddMonoid.toAddZeroClass.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (AddCommGroup.toAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real β (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField))))) (AddZeroClass.toHasZero.{u1} β (AddMonoid.toAddZeroClass.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (AddCommGroup.toAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2))))) (Module.toMulActionWithZero.{0, u1} Real β (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))) (AddCommGroup.toAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)) (NormedSpace.toModule.{0, u1} Real β Real.normedField _inst_2 _inst_3))))) (Inv.inv.{0} Real Real.hasInv (Norm.norm.{u1} β (SeminormedAddCommGroup.toHasNorm.{u1} β _inst_2) x)) x) (Metric.closedBall.{u1} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} β _inst_2) (OfNat.ofNat.{u1} β 0 (OfNat.mk.{u1} β 0 (Zero.zero.{u1} β (AddZeroClass.toHasZero.{u1} β (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (SeminormedAddGroup.toAddGroup.{u1} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} β _inst_2))))))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))
but is expected to have type
  forall {β : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} β] [_inst_3 : NormedSpace.{0, u1} Real β Real.normedField _inst_2] (x : β), Membership.mem.{u1, u1} β (Set.{u1} β) (Set.instMembershipSet.{u1} β) (HSMul.hSMul.{0, u1, u1} Real β β (instHSMul.{0, u1} Real β (SMulZeroClass.toSMul.{0, u1} Real β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (SMulWithZero.toSMulZeroClass.{0, u1} Real β Real.instZeroReal (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real β Real.instMonoidWithZeroReal (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{0, u1} Real β Real.semiring (AddCommGroup.toAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)) (NormedSpace.toModule.{0, u1} Real β Real.normedField _inst_2 _inst_3)))))) (Inv.inv.{0} Real Real.instInvReal (Norm.norm.{u1} β (SeminormedAddCommGroup.toNorm.{u1} β _inst_2) x)) x) (Metric.closedBall.{u1} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} β _inst_2) (OfNat.ofNat.{u1} β 0 (Zero.toOfNat0.{u1} β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))
Case conversion may be inaccurate. Consider using '#align inv_norm_smul_mem_closed_unit_ball inv_norm_smul_mem_closed_unit_ballₓ'. -/
theorem inv_norm_smul_mem_closed_unit_ball [NormedSpace ℝ β] (x : β) :
    ‖x‖⁻¹ • x ∈ closedBall (0 : β) 1 := by
  simp only [mem_closedBall_zero_iff, norm_smul, norm_inv, norm_norm, ← div_eq_inv_mul,
    div_self_le_one]
#align inv_norm_smul_mem_closed_unit_ball inv_norm_smul_mem_closed_unit_ball

/- warning: dist_smul₀ -> dist_smul₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NormedField.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] [_inst_3 : NormedSpace.{u1, u2} α β _inst_1 _inst_2] (s : α) (x : β) (y : β), Eq.{1} Real (Dist.dist.{u2} β (PseudoMetricSpace.toHasDist.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (SMul.smul.{u1, u2} α β (SMulZeroClass.toHasSmul.{u1, u2} α β (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} α β (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))))))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} α β (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1))))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (Module.toMulActionWithZero.{u1, u2} α β (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)) (NormedSpace.toModule.{u1, u2} α β _inst_1 _inst_2 _inst_3))))) s x) (SMul.smul.{u1, u2} α β (SMulZeroClass.toHasSmul.{u1, u2} α β (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} α β (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))))))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} α β (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1))))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (Module.toMulActionWithZero.{u1, u2} α β (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)) (NormedSpace.toModule.{u1, u2} α β _inst_1 _inst_2 _inst_3))))) s y)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Norm.norm.{u1} α (NormedField.toHasNorm.{u1} α _inst_1) s) (Dist.dist.{u2} β (PseudoMetricSpace.toHasDist.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) x y))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : NormedField.{u2} α] [_inst_2 : SeminormedAddCommGroup.{u1} β] [_inst_3 : NormedSpace.{u2, u1} α β _inst_1 _inst_2] (s : α) (x : β) (y : β), Eq.{1} Real (Dist.dist.{u1} β (PseudoMetricSpace.toDist.{u1} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} β _inst_2)) (HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (CommMonoidWithZero.toZero.{u2} α (CommGroupWithZero.toCommMonoidWithZero.{u2} α (Semifield.toCommGroupWithZero.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)) (NormedSpace.toModule.{u2, u1} α β _inst_1 _inst_2 _inst_3)))))) s x) (HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (CommMonoidWithZero.toZero.{u2} α (CommGroupWithZero.toCommMonoidWithZero.{u2} α (Semifield.toCommGroupWithZero.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)) (NormedSpace.toModule.{u2, u1} α β _inst_1 _inst_2 _inst_3)))))) s y)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Norm.norm.{u2} α (NormedField.toNorm.{u2} α _inst_1) s) (Dist.dist.{u1} β (PseudoMetricSpace.toDist.{u1} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} β _inst_2)) x y))
Case conversion may be inaccurate. Consider using '#align dist_smul₀ dist_smul₀ₓ'. -/
theorem dist_smul₀ [NormedSpace α β] (s : α) (x y : β) : dist (s • x) (s • y) = ‖s‖ * dist x y := by
  simp only [dist_eq_norm, (norm_smul _ _).symm, smul_sub]
#align dist_smul₀ dist_smul₀

/- warning: nnnorm_smul -> nnnorm_smul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NormedField.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] [_inst_3 : NormedSpace.{u1, u2} α β _inst_1 _inst_2] (s : α) (x : β), Eq.{1} NNReal (NNNorm.nnnorm.{u2} β (SeminormedAddGroup.toNNNorm.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_2)) (SMul.smul.{u1, u2} α β (SMulZeroClass.toHasSmul.{u1, u2} α β (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} α β (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))))))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} α β (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1))))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (Module.toMulActionWithZero.{u1, u2} α β (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)) (NormedSpace.toModule.{u1, u2} α β _inst_1 _inst_2 _inst_3))))) s x)) (HMul.hMul.{0, 0, 0} NNReal NNReal NNReal (instHMul.{0} NNReal (Distrib.toHasMul.{0} NNReal (NonUnitalNonAssocSemiring.toDistrib.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))) (NNNorm.nnnorm.{u1} α (SeminormedAddGroup.toNNNorm.{u1} α (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} α (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} α (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u1} α (NormedRing.toNonUnitalNormedRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1))))))) s) (NNNorm.nnnorm.{u2} β (SeminormedAddGroup.toNNNorm.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_2)) x))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : NormedField.{u2} α] [_inst_2 : SeminormedAddCommGroup.{u1} β] [_inst_3 : NormedSpace.{u2, u1} α β _inst_1 _inst_2] (s : α) (x : β), Eq.{1} NNReal (NNNorm.nnnorm.{u1} β (SeminormedAddGroup.toNNNorm.{u1} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} β _inst_2)) (HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (CommMonoidWithZero.toZero.{u2} α (CommGroupWithZero.toCommMonoidWithZero.{u2} α (Semifield.toCommGroupWithZero.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)) (NormedSpace.toModule.{u2, u1} α β _inst_1 _inst_2 _inst_3)))))) s x)) (HMul.hMul.{0, 0, 0} NNReal NNReal NNReal (instHMul.{0} NNReal (CanonicallyOrderedCommSemiring.toMul.{0} NNReal instNNRealCanonicallyOrderedCommSemiring)) (NNNorm.nnnorm.{u2} α (SeminormedAddGroup.toNNNorm.{u2} α (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} α (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u2} α (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u2} α (NormedRing.toNonUnitalNormedRing.{u2} α (NormedCommRing.toNormedRing.{u2} α (NormedField.toNormedCommRing.{u2} α _inst_1))))))) s) (NNNorm.nnnorm.{u1} β (SeminormedAddGroup.toNNNorm.{u1} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} β _inst_2)) x))
Case conversion may be inaccurate. Consider using '#align nnnorm_smul nnnorm_smulₓ'. -/
theorem nnnorm_smul [NormedSpace α β] (s : α) (x : β) : ‖s • x‖₊ = ‖s‖₊ * ‖x‖₊ :=
  NNReal.eq <| norm_smul s x
#align nnnorm_smul nnnorm_smul

/- warning: nndist_smul₀ -> nndist_smul₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NormedField.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] [_inst_3 : NormedSpace.{u1, u2} α β _inst_1 _inst_2] (s : α) (x : β) (y : β), Eq.{1} NNReal (NNDist.nndist.{u2} β (PseudoMetricSpace.toNNDist.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (SMul.smul.{u1, u2} α β (SMulZeroClass.toHasSmul.{u1, u2} α β (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} α β (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))))))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} α β (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1))))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (Module.toMulActionWithZero.{u1, u2} α β (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)) (NormedSpace.toModule.{u1, u2} α β _inst_1 _inst_2 _inst_3))))) s x) (SMul.smul.{u1, u2} α β (SMulZeroClass.toHasSmul.{u1, u2} α β (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} α β (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))))))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} α β (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1))))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (Module.toMulActionWithZero.{u1, u2} α β (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)) (NormedSpace.toModule.{u1, u2} α β _inst_1 _inst_2 _inst_3))))) s y)) (HMul.hMul.{0, 0, 0} NNReal NNReal NNReal (instHMul.{0} NNReal (Distrib.toHasMul.{0} NNReal (NonUnitalNonAssocSemiring.toDistrib.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))) (NNNorm.nnnorm.{u1} α (SeminormedAddGroup.toNNNorm.{u1} α (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} α (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} α (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u1} α (NormedRing.toNonUnitalNormedRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1))))))) s) (NNDist.nndist.{u2} β (PseudoMetricSpace.toNNDist.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) x y))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : NormedField.{u2} α] [_inst_2 : SeminormedAddCommGroup.{u1} β] [_inst_3 : NormedSpace.{u2, u1} α β _inst_1 _inst_2] (s : α) (x : β) (y : β), Eq.{1} NNReal (NNDist.nndist.{u1} β (PseudoMetricSpace.toNNDist.{u1} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} β _inst_2)) (HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (CommMonoidWithZero.toZero.{u2} α (CommGroupWithZero.toCommMonoidWithZero.{u2} α (Semifield.toCommGroupWithZero.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)) (NormedSpace.toModule.{u2, u1} α β _inst_1 _inst_2 _inst_3)))))) s x) (HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (CommMonoidWithZero.toZero.{u2} α (CommGroupWithZero.toCommMonoidWithZero.{u2} α (Semifield.toCommGroupWithZero.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)) (NormedSpace.toModule.{u2, u1} α β _inst_1 _inst_2 _inst_3)))))) s y)) (HMul.hMul.{0, 0, 0} NNReal NNReal NNReal (instHMul.{0} NNReal (CanonicallyOrderedCommSemiring.toMul.{0} NNReal instNNRealCanonicallyOrderedCommSemiring)) (NNNorm.nnnorm.{u2} α (SeminormedAddGroup.toNNNorm.{u2} α (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} α (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u2} α (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u2} α (NormedRing.toNonUnitalNormedRing.{u2} α (NormedCommRing.toNormedRing.{u2} α (NormedField.toNormedCommRing.{u2} α _inst_1))))))) s) (NNDist.nndist.{u1} β (PseudoMetricSpace.toNNDist.{u1} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} β _inst_2)) x y))
Case conversion may be inaccurate. Consider using '#align nndist_smul₀ nndist_smul₀ₓ'. -/
theorem nndist_smul₀ [NormedSpace α β] (s : α) (x y : β) :
    nndist (s • x) (s • y) = ‖s‖₊ * nndist x y :=
  NNReal.eq <| dist_smul₀ s x y
#align nndist_smul₀ nndist_smul₀

/- warning: lipschitz_with_smul -> lipschitzWith_smul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NormedField.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] [_inst_3 : NormedSpace.{u1, u2} α β _inst_1 _inst_2] (s : α), LipschitzWith.{u2, u2} β β (PseudoMetricSpace.toPseudoEMetricSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (PseudoMetricSpace.toPseudoEMetricSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (NNNorm.nnnorm.{u1} α (SeminormedAddGroup.toNNNorm.{u1} α (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} α (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} α (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u1} α (NormedRing.toNonUnitalNormedRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1))))))) s) (SMul.smul.{u1, u2} α β (SMulZeroClass.toHasSmul.{u1, u2} α β (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} α β (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))))))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} α β (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1))))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))) (Module.toMulActionWithZero.{u1, u2} α β (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)) (NormedSpace.toModule.{u1, u2} α β _inst_1 _inst_2 _inst_3))))) s)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : NormedField.{u2} α] [_inst_2 : SeminormedAddCommGroup.{u1} β] [_inst_3 : NormedSpace.{u2, u1} α β _inst_1 _inst_2] (s : α), LipschitzWith.{u1, u1} β β (PseudoMetricSpace.toPseudoEMetricSpace.{u1} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} β _inst_2)) (PseudoMetricSpace.toPseudoEMetricSpace.{u1} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} β _inst_2)) (NNNorm.nnnorm.{u2} α (SeminormedAddGroup.toNNNorm.{u2} α (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} α (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u2} α (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u2} α (NormedRing.toNonUnitalNormedRing.{u2} α (NormedCommRing.toNormedRing.{u2} α (NormedField.toNormedCommRing.{u2} α _inst_1))))))) s) ((fun (x._@.Mathlib.Analysis.NormedSpace.Basic._hyg.963 : α) (x._@.Mathlib.Analysis.NormedSpace.Basic._hyg.965 : β) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (CommMonoidWithZero.toZero.{u2} α (CommGroupWithZero.toCommMonoidWithZero.{u2} α (Semifield.toCommGroupWithZero.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)) (NormedSpace.toModule.{u2, u1} α β _inst_1 _inst_2 _inst_3)))))) x._@.Mathlib.Analysis.NormedSpace.Basic._hyg.963 x._@.Mathlib.Analysis.NormedSpace.Basic._hyg.965) s)
Case conversion may be inaccurate. Consider using '#align lipschitz_with_smul lipschitzWith_smulₓ'. -/
theorem lipschitzWith_smul [NormedSpace α β] (s : α) : LipschitzWith ‖s‖₊ ((· • ·) s : β → β) :=
  lipschitzWith_iff_dist_le_mul.2 fun x y => by rw [dist_smul₀, coe_nnnorm]
#align lipschitz_with_smul lipschitzWith_smul

/- warning: norm_smul_of_nonneg -> norm_smul_of_nonneg is a dubious translation:
lean 3 declaration is
  forall {β : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} β] [_inst_3 : NormedSpace.{0, u1} Real β Real.normedField _inst_2] {t : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) t) -> (forall (x : β), Eq.{1} Real (Norm.norm.{u1} β (SeminormedAddCommGroup.toHasNorm.{u1} β _inst_2) (SMul.smul.{0, u1} Real β (SMulZeroClass.toHasSmul.{0, u1} Real β (AddZeroClass.toHasZero.{u1} β (AddMonoid.toAddZeroClass.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (AddCommGroup.toAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2))))) (SMulWithZero.toSmulZeroClass.{0, u1} Real β (MulZeroClass.toHasZero.{0} Real (MulZeroOneClass.toMulZeroClass.{0} Real (MonoidWithZero.toMulZeroOneClass.{0} Real (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))))))) (AddZeroClass.toHasZero.{u1} β (AddMonoid.toAddZeroClass.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (AddCommGroup.toAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real β (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField))))) (AddZeroClass.toHasZero.{u1} β (AddMonoid.toAddZeroClass.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (AddCommGroup.toAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2))))) (Module.toMulActionWithZero.{0, u1} Real β (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))) (AddCommGroup.toAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)) (NormedSpace.toModule.{0, u1} Real β Real.normedField _inst_2 _inst_3))))) t x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) t (Norm.norm.{u1} β (SeminormedAddCommGroup.toHasNorm.{u1} β _inst_2) x)))
but is expected to have type
  forall {β : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} β] [_inst_3 : NormedSpace.{0, u1} Real β Real.normedField _inst_2] {t : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) t) -> (forall (x : β), Eq.{1} Real (Norm.norm.{u1} β (SeminormedAddCommGroup.toNorm.{u1} β _inst_2) (HSMul.hSMul.{0, u1, u1} Real β β (instHSMul.{0, u1} Real β (SMulZeroClass.toSMul.{0, u1} Real β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (SMulWithZero.toSMulZeroClass.{0, u1} Real β Real.instZeroReal (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real β Real.instMonoidWithZeroReal (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{0, u1} Real β Real.semiring (AddCommGroup.toAddCommMonoid.{u1} β (SeminormedAddCommGroup.toAddCommGroup.{u1} β _inst_2)) (NormedSpace.toModule.{0, u1} Real β Real.normedField _inst_2 _inst_3)))))) t x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) t (Norm.norm.{u1} β (SeminormedAddCommGroup.toNorm.{u1} β _inst_2) x)))
Case conversion may be inaccurate. Consider using '#align norm_smul_of_nonneg norm_smul_of_nonnegₓ'. -/
theorem norm_smul_of_nonneg [NormedSpace ℝ β] {t : ℝ} (ht : 0 ≤ t) (x : β) : ‖t • x‖ = t * ‖x‖ := by
  rw [norm_smul, Real.norm_eq_abs, abs_of_nonneg ht]
#align norm_smul_of_nonneg norm_smul_of_nonneg

variable {E : Type _} [SeminormedAddCommGroup E] [NormedSpace α E]

variable {F : Type _} [SeminormedAddCommGroup F] [NormedSpace α F]

/- warning: eventually_nhds_norm_smul_sub_lt -> eventually_nhds_norm_smul_sub_lt is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NormedField.{u1} α] {E : Type.{u2}} [_inst_3 : SeminormedAddCommGroup.{u2} E] [_inst_4 : NormedSpace.{u1, u2} α E _inst_1 _inst_3] (c : α) (x : E) {ε : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) ε) -> (Filter.Eventually.{u2} E (fun (y : E) => LT.lt.{0} Real Real.hasLt (Norm.norm.{u2} E (SeminormedAddCommGroup.toHasNorm.{u2} E _inst_3) (SMul.smul.{u1, u2} α E (SMulZeroClass.toHasSmul.{u1, u2} α E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3))))) (SMulWithZero.toSmulZeroClass.{u1, u2} α E (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3))))) (MulActionWithZero.toSMulWithZero.{u1, u2} α E (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3))))) (Module.toMulActionWithZero.{u1, u2} α E (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3)) (NormedSpace.toModule.{u1, u2} α E _inst_1 _inst_3 _inst_4))))) c (HSub.hSub.{u2, u2, u2} E E E (instHSub.{u2} E (SubNegMonoid.toHasSub.{u2} E (AddGroup.toSubNegMonoid.{u2} E (SeminormedAddGroup.toAddGroup.{u2} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E _inst_3))))) y x))) ε) (nhds.{u2} E (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_3))) x))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NormedField.{u1} α] {E : Type.{u2}} [_inst_3 : SeminormedAddCommGroup.{u2} E] [_inst_4 : NormedSpace.{u1, u2} α E _inst_1 _inst_3] (c : α) (x : E) {ε : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) ε) -> (Filter.Eventually.{u2} E (fun (y : E) => LT.lt.{0} Real Real.instLTReal (Norm.norm.{u2} E (SeminormedAddCommGroup.toNorm.{u2} E _inst_3) (HSMul.hSMul.{u1, u2, u2} α E E (instHSMul.{u1, u2} α E (SMulZeroClass.toSMul.{u1, u2} α E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3)))))) (SMulWithZero.toSMulZeroClass.{u1, u2} α E (CommMonoidWithZero.toZero.{u1} α (CommGroupWithZero.toCommMonoidWithZero.{u1} α (Semifield.toCommGroupWithZero.{u1} α (Field.toSemifield.{u1} α (NormedField.toField.{u1} α _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} α E (Semiring.toMonoidWithZero.{u1} α (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α (Field.toSemifield.{u1} α (NormedField.toField.{u1} α _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3)))))) (Module.toMulActionWithZero.{u1, u2} α E (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α (Field.toSemifield.{u1} α (NormedField.toField.{u1} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3)) (NormedSpace.toModule.{u1, u2} α E _inst_1 _inst_3 _inst_4)))))) c (HSub.hSub.{u2, u2, u2} E E E (instHSub.{u2} E (SubNegMonoid.toSub.{u2} E (AddGroup.toSubNegMonoid.{u2} E (SeminormedAddGroup.toAddGroup.{u2} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E _inst_3))))) y x))) ε) (nhds.{u2} E (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_3))) x))
Case conversion may be inaccurate. Consider using '#align eventually_nhds_norm_smul_sub_lt eventually_nhds_norm_smul_sub_ltₓ'. -/
theorem eventually_nhds_norm_smul_sub_lt (c : α) (x : E) {ε : ℝ} (h : 0 < ε) :
    ∀ᶠ y in 𝓝 x, ‖c • (y - x)‖ < ε :=
  have : Tendsto (fun y => ‖c • (y - x)‖) (𝓝 x) (𝓝 0) :=
    ((continuous_id.sub continuous_const).const_smul _).norm.tendsto' _ _ (by simp)
  this.Eventually (gt_mem_nhds h)
#align eventually_nhds_norm_smul_sub_lt eventually_nhds_norm_smul_sub_lt

/- warning: filter.tendsto.zero_smul_is_bounded_under_le -> Filter.Tendsto.zero_smul_isBoundedUnder_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {ι : Type.{u2}} [_inst_1 : NormedField.{u1} α] {E : Type.{u3}} [_inst_3 : SeminormedAddCommGroup.{u3} E] [_inst_4 : NormedSpace.{u1, u3} α E _inst_1 _inst_3] {f : ι -> α} {g : ι -> E} {l : Filter.{u2} ι}, (Filter.Tendsto.{u2, u1} ι α f l (nhds.{u1} α (UniformSpace.toTopologicalSpace.{u1} α (PseudoMetricSpace.toUniformSpace.{u1} α (SeminormedRing.toPseudoMetricSpace.{u1} α (SeminormedCommRing.toSemiNormedRing.{u1} α (NormedCommRing.toSeminormedCommRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1))))))))))))) -> (Filter.IsBoundedUnder.{0, u2} Real ι (LE.le.{0} Real Real.hasLe) l (Function.comp.{succ u2, succ u3, 1} ι E Real (Norm.norm.{u3} E (SeminormedAddCommGroup.toHasNorm.{u3} E _inst_3)) g)) -> (Filter.Tendsto.{u2, u3} ι E (fun (x : ι) => SMul.smul.{u1, u3} α E (SMulZeroClass.toHasSmul.{u1, u3} α E (AddZeroClass.toHasZero.{u3} E (AddMonoid.toAddZeroClass.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (AddCommGroup.toAddCommMonoid.{u3} E (SeminormedAddCommGroup.toAddCommGroup.{u3} E _inst_3))))) (SMulWithZero.toSmulZeroClass.{u1, u3} α E (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))))))) (AddZeroClass.toHasZero.{u3} E (AddMonoid.toAddZeroClass.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (AddCommGroup.toAddCommMonoid.{u3} E (SeminormedAddCommGroup.toAddCommGroup.{u3} E _inst_3))))) (MulActionWithZero.toSMulWithZero.{u1, u3} α E (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1))))) (AddZeroClass.toHasZero.{u3} E (AddMonoid.toAddZeroClass.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (AddCommGroup.toAddCommMonoid.{u3} E (SeminormedAddCommGroup.toAddCommGroup.{u3} E _inst_3))))) (Module.toMulActionWithZero.{u1, u3} α E (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u3} E (SeminormedAddCommGroup.toAddCommGroup.{u3} E _inst_3)) (NormedSpace.toModule.{u1, u3} α E _inst_1 _inst_3 _inst_4))))) (f x) (g x)) l (nhds.{u3} E (UniformSpace.toTopologicalSpace.{u3} E (PseudoMetricSpace.toUniformSpace.{u3} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} E _inst_3))) (OfNat.ofNat.{u3} E 0 (OfNat.mk.{u3} E 0 (Zero.zero.{u3} E (AddZeroClass.toHasZero.{u3} E (AddMonoid.toAddZeroClass.{u3} E (SubNegMonoid.toAddMonoid.{u3} E (AddGroup.toSubNegMonoid.{u3} E (SeminormedAddGroup.toAddGroup.{u3} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u3} E _inst_3)))))))))))
but is expected to have type
  forall {α : Type.{u2}} {ι : Type.{u3}} [_inst_1 : NormedField.{u2} α] {E : Type.{u1}} [_inst_3 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{u2, u1} α E _inst_1 _inst_3] {f : ι -> α} {g : ι -> E} {l : Filter.{u3} ι}, (Filter.Tendsto.{u3, u2} ι α f l (nhds.{u2} α (UniformSpace.toTopologicalSpace.{u2} α (PseudoMetricSpace.toUniformSpace.{u2} α (SeminormedRing.toPseudoMetricSpace.{u2} α (SeminormedCommRing.toSeminormedRing.{u2} α (NormedCommRing.toSeminormedCommRing.{u2} α (NormedField.toNormedCommRing.{u2} α _inst_1)))))) (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (CommMonoidWithZero.toZero.{u2} α (CommGroupWithZero.toCommMonoidWithZero.{u2} α (Semifield.toCommGroupWithZero.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))))))) -> (Filter.IsBoundedUnder.{0, u3} Real ι (fun (x._@.Mathlib.Analysis.NormedSpace.Basic._hyg.1327 : Real) (x._@.Mathlib.Analysis.NormedSpace.Basic._hyg.1329 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Analysis.NormedSpace.Basic._hyg.1327 x._@.Mathlib.Analysis.NormedSpace.Basic._hyg.1329) l (Function.comp.{succ u3, succ u1, 1} ι E Real (Norm.norm.{u1} E (SeminormedAddCommGroup.toNorm.{u1} E _inst_3)) g)) -> (Filter.Tendsto.{u3, u1} ι E (fun (x : ι) => HSMul.hSMul.{u2, u1, u1} α E E (instHSMul.{u2, u1} α E (SMulZeroClass.toSMul.{u2, u1} α E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α E (CommMonoidWithZero.toZero.{u2} α (CommGroupWithZero.toCommMonoidWithZero.{u2} α (Semifield.toCommGroupWithZero.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α E (Semiring.toMonoidWithZero.{u2} α (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)))))) (Module.toMulActionWithZero.{u2, u1} α E (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)) (NormedSpace.toModule.{u2, u1} α E _inst_1 _inst_3 _inst_4)))))) (f x) (g x)) l (nhds.{u1} E (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3))) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3))))))))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.zero_smul_is_bounded_under_le Filter.Tendsto.zero_smul_isBoundedUnder_leₓ'. -/
theorem Filter.Tendsto.zero_smul_isBoundedUnder_le {f : ι → α} {g : ι → E} {l : Filter ι}
    (hf : Tendsto f l (𝓝 0)) (hg : IsBoundedUnder (· ≤ ·) l (norm ∘ g)) :
    Tendsto (fun x => f x • g x) l (𝓝 0) :=
  hf.op_zero_isBoundedUnder_le hg (· • ·) norm_smul_le
#align filter.tendsto.zero_smul_is_bounded_under_le Filter.Tendsto.zero_smul_isBoundedUnder_le

/- warning: filter.is_bounded_under.smul_tendsto_zero -> Filter.IsBoundedUnder.smul_tendsto_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {ι : Type.{u2}} [_inst_1 : NormedField.{u1} α] {E : Type.{u3}} [_inst_3 : SeminormedAddCommGroup.{u3} E] [_inst_4 : NormedSpace.{u1, u3} α E _inst_1 _inst_3] {f : ι -> α} {g : ι -> E} {l : Filter.{u2} ι}, (Filter.IsBoundedUnder.{0, u2} Real ι (LE.le.{0} Real Real.hasLe) l (Function.comp.{succ u2, succ u1, 1} ι α Real (Norm.norm.{u1} α (NormedField.toHasNorm.{u1} α _inst_1)) f)) -> (Filter.Tendsto.{u2, u3} ι E g l (nhds.{u3} E (UniformSpace.toTopologicalSpace.{u3} E (PseudoMetricSpace.toUniformSpace.{u3} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} E _inst_3))) (OfNat.ofNat.{u3} E 0 (OfNat.mk.{u3} E 0 (Zero.zero.{u3} E (AddZeroClass.toHasZero.{u3} E (AddMonoid.toAddZeroClass.{u3} E (SubNegMonoid.toAddMonoid.{u3} E (AddGroup.toSubNegMonoid.{u3} E (SeminormedAddGroup.toAddGroup.{u3} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u3} E _inst_3))))))))))) -> (Filter.Tendsto.{u2, u3} ι E (fun (x : ι) => SMul.smul.{u1, u3} α E (SMulZeroClass.toHasSmul.{u1, u3} α E (AddZeroClass.toHasZero.{u3} E (AddMonoid.toAddZeroClass.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (AddCommGroup.toAddCommMonoid.{u3} E (SeminormedAddCommGroup.toAddCommGroup.{u3} E _inst_3))))) (SMulWithZero.toSmulZeroClass.{u1, u3} α E (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))))))) (AddZeroClass.toHasZero.{u3} E (AddMonoid.toAddZeroClass.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (AddCommGroup.toAddCommMonoid.{u3} E (SeminormedAddCommGroup.toAddCommGroup.{u3} E _inst_3))))) (MulActionWithZero.toSMulWithZero.{u1, u3} α E (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1))))) (AddZeroClass.toHasZero.{u3} E (AddMonoid.toAddZeroClass.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (AddCommGroup.toAddCommMonoid.{u3} E (SeminormedAddCommGroup.toAddCommGroup.{u3} E _inst_3))))) (Module.toMulActionWithZero.{u1, u3} α E (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u3} E (SeminormedAddCommGroup.toAddCommGroup.{u3} E _inst_3)) (NormedSpace.toModule.{u1, u3} α E _inst_1 _inst_3 _inst_4))))) (f x) (g x)) l (nhds.{u3} E (UniformSpace.toTopologicalSpace.{u3} E (PseudoMetricSpace.toUniformSpace.{u3} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} E _inst_3))) (OfNat.ofNat.{u3} E 0 (OfNat.mk.{u3} E 0 (Zero.zero.{u3} E (AddZeroClass.toHasZero.{u3} E (AddMonoid.toAddZeroClass.{u3} E (SubNegMonoid.toAddMonoid.{u3} E (AddGroup.toSubNegMonoid.{u3} E (SeminormedAddGroup.toAddGroup.{u3} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u3} E _inst_3)))))))))))
but is expected to have type
  forall {α : Type.{u2}} {ι : Type.{u3}} [_inst_1 : NormedField.{u2} α] {E : Type.{u1}} [_inst_3 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{u2, u1} α E _inst_1 _inst_3] {f : ι -> α} {g : ι -> E} {l : Filter.{u3} ι}, (Filter.IsBoundedUnder.{0, u3} Real ι (fun (x._@.Mathlib.Analysis.NormedSpace.Basic._hyg.1430 : Real) (x._@.Mathlib.Analysis.NormedSpace.Basic._hyg.1432 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Analysis.NormedSpace.Basic._hyg.1430 x._@.Mathlib.Analysis.NormedSpace.Basic._hyg.1432) l (Function.comp.{succ u3, succ u2, 1} ι α Real (Norm.norm.{u2} α (NormedField.toNorm.{u2} α _inst_1)) f)) -> (Filter.Tendsto.{u3, u1} ι E g l (nhds.{u1} E (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3))) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)))))))))) -> (Filter.Tendsto.{u3, u1} ι E (fun (x : ι) => HSMul.hSMul.{u2, u1, u1} α E E (instHSMul.{u2, u1} α E (SMulZeroClass.toSMul.{u2, u1} α E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α E (CommMonoidWithZero.toZero.{u2} α (CommGroupWithZero.toCommMonoidWithZero.{u2} α (Semifield.toCommGroupWithZero.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α E (Semiring.toMonoidWithZero.{u2} α (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)))))) (Module.toMulActionWithZero.{u2, u1} α E (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)) (NormedSpace.toModule.{u2, u1} α E _inst_1 _inst_3 _inst_4)))))) (f x) (g x)) l (nhds.{u1} E (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3))) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3))))))))))
Case conversion may be inaccurate. Consider using '#align filter.is_bounded_under.smul_tendsto_zero Filter.IsBoundedUnder.smul_tendsto_zeroₓ'. -/
theorem Filter.IsBoundedUnder.smul_tendsto_zero {f : ι → α} {g : ι → E} {l : Filter ι}
    (hf : IsBoundedUnder (· ≤ ·) l (norm ∘ f)) (hg : Tendsto g l (𝓝 0)) :
    Tendsto (fun x => f x • g x) l (𝓝 0) :=
  hg.op_zero_isBoundedUnder_le hf (flip (· • ·)) fun x y =>
    (norm_smul_le y x).trans_eq (mul_comm _ _)
#align filter.is_bounded_under.smul_tendsto_zero Filter.IsBoundedUnder.smul_tendsto_zero

/- warning: closure_ball -> closure_ball is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_3 : SeminormedAddCommGroup.{u1} E] [_inst_7 : NormedSpace.{0, u1} Real E Real.normedField _inst_3] (x : E) {r : Real}, (Ne.{1} Real r (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) -> (Eq.{succ u1} (Set.{u1} E) (closure.{u1} E (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3))) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) x r)) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) x r))
but is expected to have type
  forall {E : Type.{u1}} [_inst_3 : SeminormedAddCommGroup.{u1} E] [_inst_7 : NormedSpace.{0, u1} Real E Real.normedField _inst_3] (x : E) {r : Real}, (Ne.{1} Real r (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) -> (Eq.{succ u1} (Set.{u1} E) (closure.{u1} E (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3))) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) x r)) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) x r))
Case conversion may be inaccurate. Consider using '#align closure_ball closure_ballₓ'. -/
theorem closure_ball [NormedSpace ℝ E] (x : E) {r : ℝ} (hr : r ≠ 0) :
    closure (ball x r) = closedBall x r :=
  by
  refine' subset.antisymm closure_ball_subset_closed_ball fun y hy => _
  have : ContinuousWithinAt (fun c : ℝ => c • (y - x) + x) (Ico 0 1) 1 :=
    ((continuous_id.smul continuous_const).add continuous_const).ContinuousWithinAt
  convert this.mem_closure _ _
  · rw [one_smul, sub_add_cancel]
  · simp [closure_Ico zero_ne_one, zero_le_one]
  · rintro c ⟨hc0, hc1⟩
    rw [mem_ball, dist_eq_norm, add_sub_cancel, norm_smul, Real.norm_eq_abs, abs_of_nonneg hc0,
      mul_comm, ← mul_one r]
    rw [mem_closed_ball, dist_eq_norm] at hy
    replace hr : 0 < r
    exact ((norm_nonneg _).trans hy).lt_of_ne hr.symm
    apply mul_lt_mul' <;> assumption
#align closure_ball closure_ball

/- warning: frontier_ball -> frontier_ball is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_3 : SeminormedAddCommGroup.{u1} E] [_inst_7 : NormedSpace.{0, u1} Real E Real.normedField _inst_3] (x : E) {r : Real}, (Ne.{1} Real r (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) -> (Eq.{succ u1} (Set.{u1} E) (frontier.{u1} E (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3))) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) x r)) (Metric.sphere.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) x r))
but is expected to have type
  forall {E : Type.{u1}} [_inst_3 : SeminormedAddCommGroup.{u1} E] [_inst_7 : NormedSpace.{0, u1} Real E Real.normedField _inst_3] (x : E) {r : Real}, (Ne.{1} Real r (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) -> (Eq.{succ u1} (Set.{u1} E) (frontier.{u1} E (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3))) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) x r)) (Metric.sphere.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) x r))
Case conversion may be inaccurate. Consider using '#align frontier_ball frontier_ballₓ'. -/
theorem frontier_ball [NormedSpace ℝ E] (x : E) {r : ℝ} (hr : r ≠ 0) :
    frontier (ball x r) = sphere x r :=
  by
  rw [frontier, closure_ball x hr, is_open_ball.interior_eq]
  ext x; exact (@eq_iff_le_not_lt ℝ _ _ _).symm
#align frontier_ball frontier_ball

/- warning: interior_closed_ball -> interior_closedBall is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_3 : SeminormedAddCommGroup.{u1} E] [_inst_7 : NormedSpace.{0, u1} Real E Real.normedField _inst_3] (x : E) {r : Real}, (Ne.{1} Real r (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) -> (Eq.{succ u1} (Set.{u1} E) (interior.{u1} E (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3))) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) x r)) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) x r))
but is expected to have type
  forall {E : Type.{u1}} [_inst_3 : SeminormedAddCommGroup.{u1} E] [_inst_7 : NormedSpace.{0, u1} Real E Real.normedField _inst_3] (x : E) {r : Real}, (Ne.{1} Real r (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) -> (Eq.{succ u1} (Set.{u1} E) (interior.{u1} E (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3))) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) x r)) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) x r))
Case conversion may be inaccurate. Consider using '#align interior_closed_ball interior_closedBallₓ'. -/
theorem interior_closedBall [NormedSpace ℝ E] (x : E) {r : ℝ} (hr : r ≠ 0) :
    interior (closedBall x r) = ball x r :=
  by
  cases' hr.lt_or_lt with hr hr
  · rw [closed_ball_eq_empty.2 hr, ball_eq_empty.2 hr.le, interior_empty]
  refine' subset.antisymm _ ball_subset_interior_closed_ball
  intro y hy
  rcases(mem_closed_ball.1 <| interior_subset hy).lt_or_eq with (hr | rfl)
  · exact hr
  set f : ℝ → E := fun c : ℝ => c • (y - x) + x
  suffices f ⁻¹' closed_ball x (dist y x) ⊆ Icc (-1) 1
    by
    have hfc : Continuous f := (continuous_id.smul continuous_const).add continuous_const
    have hf1 : (1 : ℝ) ∈ f ⁻¹' interior (closed_ball x <| dist y x) := by simpa [f]
    have h1 : (1 : ℝ) ∈ interior (Icc (-1 : ℝ) 1) :=
      interior_mono this (preimage_interior_subset_interior_preimage hfc hf1)
    contrapose h1
    simp
  intro c hc
  rw [mem_Icc, ← abs_le, ← Real.norm_eq_abs, ← mul_le_mul_right hr]
  simpa [f, dist_eq_norm, norm_smul] using hc
#align interior_closed_ball interior_closedBall

/- warning: frontier_closed_ball -> frontier_closedBall is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_3 : SeminormedAddCommGroup.{u1} E] [_inst_7 : NormedSpace.{0, u1} Real E Real.normedField _inst_3] (x : E) {r : Real}, (Ne.{1} Real r (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) -> (Eq.{succ u1} (Set.{u1} E) (frontier.{u1} E (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3))) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) x r)) (Metric.sphere.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) x r))
but is expected to have type
  forall {E : Type.{u1}} [_inst_3 : SeminormedAddCommGroup.{u1} E] [_inst_7 : NormedSpace.{0, u1} Real E Real.normedField _inst_3] (x : E) {r : Real}, (Ne.{1} Real r (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) -> (Eq.{succ u1} (Set.{u1} E) (frontier.{u1} E (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3))) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) x r)) (Metric.sphere.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) x r))
Case conversion may be inaccurate. Consider using '#align frontier_closed_ball frontier_closedBallₓ'. -/
theorem frontier_closedBall [NormedSpace ℝ E] (x : E) {r : ℝ} (hr : r ≠ 0) :
    frontier (closedBall x r) = sphere x r := by
  rw [frontier, closure_closed_ball, interior_closedBall x hr, closed_ball_diff_ball]
#align frontier_closed_ball frontier_closedBall

theorem interior_sphere [NormedSpace ℝ E] (x : E) {r : ℝ} (hr : r ≠ 0) :
    interior (sphere x r) = ∅ := by
  rw [← frontier_closedBall x hr, interior_frontier is_closed_ball]
#align interior_sphere interior_sphere

theorem frontier_sphere [NormedSpace ℝ E] (x : E) {r : ℝ} (hr : r ≠ 0) :
    frontier (sphere x r) = sphere x r := by
  rw [is_closed_sphere.frontier_eq, interior_sphere x hr, diff_empty]
#align frontier_sphere frontier_sphere

instance {E : Type _} [NormedAddCommGroup E] [NormedSpace ℚ E] (e : E) :
    DiscreteTopology <| AddSubgroup.zmultiples e :=
  by
  rcases eq_or_ne e 0 with (rfl | he)
  · rw [AddSubgroup.zmultiples_zero_eq_bot]
    infer_instance
  · rw [discreteTopology_iff_open_singleton_zero, isOpen_induced_iff]
    refine' ⟨Metric.ball 0 ‖e‖, Metric.isOpen_ball, _⟩
    ext ⟨x, hx⟩
    obtain ⟨k, rfl⟩ := add_subgroup.mem_zmultiples_iff.mp hx
    rw [mem_preimage, mem_ball_zero_iff, AddSubgroup.coe_mk, mem_singleton_iff, Subtype.ext_iff,
      AddSubgroup.coe_mk, AddSubgroup.coe_zero, norm_zsmul ℚ k e, Int.norm_cast_rat,
      Int.norm_eq_abs, ← Int.cast_abs, mul_lt_iff_lt_one_left (norm_pos_iff.mpr he), ←
      @Int.cast_one ℝ _, Int.cast_lt, Int.abs_lt_one_iff, smul_eq_zero, or_iff_left he]

/- warning: homeomorph_unit_ball -> homeomorphUnitBall is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_3 : SeminormedAddCommGroup.{u1} E] [_inst_7 : NormedSpace.{0, u1} Real E Real.normedField _inst_3], Homeomorph.{u1, u1} E (coeSort.{succ u1, succ (succ u1)} (Set.{u1} E) Type.{u1} (Set.hasCoeToSort.{u1} E) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) (OfNat.ofNat.{u1} E 0 (OfNat.mk.{u1} E 0 (Zero.zero.{u1} E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_3))))))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3))) (Subtype.topologicalSpace.{u1} E (fun (x : E) => Membership.Mem.{u1, u1} E (Set.{u1} E) (Set.hasMem.{u1} E) x (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) (OfNat.ofNat.{u1} E 0 (OfNat.mk.{u1} E 0 (Zero.zero.{u1} E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_3))))))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3))))
but is expected to have type
  forall {E : Type.{u1}} [_inst_3 : SeminormedAddCommGroup.{u1} E] [_inst_7 : NormedSpace.{0, u1} Real E Real.normedField _inst_3], Homeomorph.{u1, u1} E (Set.Elem.{u1} E (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)))))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3))) (instTopologicalSpaceSubtype.{u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)))))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3))))
Case conversion may be inaccurate. Consider using '#align homeomorph_unit_ball homeomorphUnitBallₓ'. -/
/-- A (semi) normed real vector space is homeomorphic to the unit ball in the same space.
This homeomorphism sends `x : E` to `(1 + ‖x‖²)^(- ½) • x`.

In many cases the actual implementation is not important, so we don't mark the projection lemmas
`homeomorph_unit_ball_apply_coe` and `homeomorph_unit_ball_symm_apply` as `@[simp]`.

See also `cont_diff_homeomorph_unit_ball` and `cont_diff_on_homeomorph_unit_ball_symm` for
smoothness properties that hold when `E` is an inner-product space. -/
@[simps (config := { attrs := [] })]
noncomputable def homeomorphUnitBall [NormedSpace ℝ E] : E ≃ₜ ball (0 : E) 1
    where
  toFun x :=
    ⟨(1 + ‖x‖ ^ 2).sqrt⁻¹ • x, by
      have : 0 < 1 + ‖x‖ ^ 2 := by positivity
      rw [mem_ball_zero_iff, norm_smul, Real.norm_eq_abs, abs_inv, ← div_eq_inv_mul,
        div_lt_one (abs_pos.mpr <| real.sqrt_ne_zero'.mpr this), ← abs_norm_eq_norm x, ← sq_lt_sq,
        abs_norm_eq_norm, Real.sq_sqrt this.le]
      exact lt_one_add _⟩
  invFun y := (1 - ‖(y : E)‖ ^ 2).sqrt⁻¹ • (y : E)
  left_inv x := by
    field_simp [norm_smul, smul_smul, (zero_lt_one_add_norm_sq x).ne',
      Real.sq_sqrt (zero_lt_one_add_norm_sq x).le, ← Real.sqrt_div (zero_lt_one_add_norm_sq x).le]
  right_inv y :=
    by
    have : 0 < 1 - ‖(y : E)‖ ^ 2 := by
      nlinarith [norm_nonneg (y : E), (mem_ball_zero_iff.1 y.2 : ‖(y : E)‖ < 1)]
    field_simp [norm_smul, smul_smul, this.ne', Real.sq_sqrt this.le, ← Real.sqrt_div this.le]
  continuous_toFun := by
    suffices : Continuous fun x => (1 + ‖x‖ ^ 2).sqrt⁻¹;
    exact (this.smul continuous_id).subtype_mk _
    refine' Continuous.inv₀ _ fun x => real.sqrt_ne_zero'.mpr (by positivity)
    continuity
  continuous_invFun :=
    by
    suffices ∀ y : ball (0 : E) 1, (1 - ‖(y : E)‖ ^ 2).sqrt ≠ 0 by continuity
    intro y
    rw [Real.sqrt_ne_zero']
    nlinarith [norm_nonneg (y : E), (mem_ball_zero_iff.1 y.2 : ‖(y : E)‖ < 1)]
#align homeomorph_unit_ball homeomorphUnitBall

/- warning: coe_homeomorph_unit_ball_apply_zero -> coe_homeomorphUnitBall_apply_zero is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_3 : SeminormedAddCommGroup.{u1} E] [_inst_7 : NormedSpace.{0, u1} Real E Real.normedField _inst_3], Eq.{succ u1} E ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} E) Type.{u1} (Set.hasCoeToSort.{u1} E) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) (OfNat.ofNat.{u1} E 0 (OfNat.mk.{u1} E 0 (Zero.zero.{u1} E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_3))))))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) E (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} E) Type.{u1} (Set.hasCoeToSort.{u1} E) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) (OfNat.ofNat.{u1} E 0 (OfNat.mk.{u1} E 0 (Zero.zero.{u1} E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_3))))))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) E (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} E) Type.{u1} (Set.hasCoeToSort.{u1} E) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) (OfNat.ofNat.{u1} E 0 (OfNat.mk.{u1} E 0 (Zero.zero.{u1} E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_3))))))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) E (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} E) Type.{u1} (Set.hasCoeToSort.{u1} E) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) (OfNat.ofNat.{u1} E 0 (OfNat.mk.{u1} E 0 (Zero.zero.{u1} E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_3))))))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) E (coeSubtype.{succ u1} E (fun (x : E) => Membership.Mem.{u1, u1} E (Set.{u1} E) (Set.hasMem.{u1} E) x (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) (OfNat.ofNat.{u1} E 0 (OfNat.mk.{u1} E 0 (Zero.zero.{u1} E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_3))))))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))))))) (coeFn.{succ u1, succ u1} (Homeomorph.{u1, u1} E (coeSort.{succ u1, succ (succ u1)} (Set.{u1} E) Type.{u1} (Set.hasCoeToSort.{u1} E) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) (OfNat.ofNat.{u1} E 0 (OfNat.mk.{u1} E 0 (Zero.zero.{u1} E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_3))))))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3))) (Subtype.topologicalSpace.{u1} E (fun (x : E) => Membership.Mem.{u1, u1} E (Set.{u1} E) (Set.hasMem.{u1} E) x (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) (OfNat.ofNat.{u1} E 0 (OfNat.mk.{u1} E 0 (Zero.zero.{u1} E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_3))))))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3))))) (fun (_x : Homeomorph.{u1, u1} E (coeSort.{succ u1, succ (succ u1)} (Set.{u1} E) Type.{u1} (Set.hasCoeToSort.{u1} E) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) (OfNat.ofNat.{u1} E 0 (OfNat.mk.{u1} E 0 (Zero.zero.{u1} E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_3))))))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3))) (Subtype.topologicalSpace.{u1} E (fun (x : E) => Membership.Mem.{u1, u1} E (Set.{u1} E) (Set.hasMem.{u1} E) x (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) (OfNat.ofNat.{u1} E 0 (OfNat.mk.{u1} E 0 (Zero.zero.{u1} E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_3))))))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3))))) => E -> (coeSort.{succ u1, succ (succ u1)} (Set.{u1} E) Type.{u1} (Set.hasCoeToSort.{u1} E) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) (OfNat.ofNat.{u1} E 0 (OfNat.mk.{u1} E 0 (Zero.zero.{u1} E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_3))))))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))))) (Homeomorph.hasCoeToFun.{u1, u1} E (coeSort.{succ u1, succ (succ u1)} (Set.{u1} E) Type.{u1} (Set.hasCoeToSort.{u1} E) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) (OfNat.ofNat.{u1} E 0 (OfNat.mk.{u1} E 0 (Zero.zero.{u1} E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_3))))))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3))) (Subtype.topologicalSpace.{u1} E (fun (x : E) => Membership.Mem.{u1, u1} E (Set.{u1} E) (Set.hasMem.{u1} E) x (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) (OfNat.ofNat.{u1} E 0 (OfNat.mk.{u1} E 0 (Zero.zero.{u1} E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_3))))))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3))))) (homeomorphUnitBall.{u1} E _inst_3 _inst_7) (OfNat.ofNat.{u1} E 0 (OfNat.mk.{u1} E 0 (Zero.zero.{u1} E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_3))))))))))) (OfNat.ofNat.{u1} E 0 (OfNat.mk.{u1} E 0 (Zero.zero.{u1} E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_3)))))))))
but is expected to have type
  forall {E : Type.{u1}} [_inst_3 : SeminormedAddCommGroup.{u1} E] [_inst_7 : NormedSpace.{0, u1} Real E Real.normedField _inst_3], Eq.{succ u1} E (Subtype.val.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)))))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (FunLike.coe.{succ u1, succ u1, succ u1} (Homeomorph.{u1, u1} E (Set.Elem.{u1} E (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)))))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3))) (instTopologicalSpaceSubtype.{u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)))))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3))))) E (fun (_x : E) => Set.Elem.{u1} E (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)))))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Homeomorph.{u1, u1} E (Set.Elem.{u1} E (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)))))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3))) (instTopologicalSpaceSubtype.{u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)))))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3))))) E (Set.Elem.{u1} E (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)))))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Homeomorph.{u1, u1} E (Set.Elem.{u1} E (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)))))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3))) (instTopologicalSpaceSubtype.{u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)))))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3))))) E (Set.Elem.{u1} E (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)))))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (Homeomorph.instEquivLikeHomeomorph.{u1, u1} E (Set.Elem.{u1} E (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)))))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3))) (instTopologicalSpaceSubtype.{u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)))))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_3))))))) (homeomorphUnitBall.{u1} E _inst_3 _inst_7) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)))))))))) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3))))))))
Case conversion may be inaccurate. Consider using '#align coe_homeomorph_unit_ball_apply_zero coe_homeomorphUnitBall_apply_zeroₓ'. -/
@[simp]
theorem coe_homeomorphUnitBall_apply_zero [NormedSpace ℝ E] :
    (homeomorphUnitBall (0 : E) : E) = 0 := by simp [homeomorphUnitBall]
#align coe_homeomorph_unit_ball_apply_zero coe_homeomorphUnitBall_apply_zero

open NormedField

instance : NormedSpace α (ULift E) :=
  { ULift.normedAddCommGroup, ULift.module' with
    norm_smul_le := fun s x => (norm_smul_le s x.down : _) }

#print Prod.normedSpace /-
/-- The product of two normed spaces is a normed space, with the sup norm. -/
instance Prod.normedSpace : NormedSpace α (E × F) :=
  { Prod.normedAddCommGroup, Prod.module with
    norm_smul_le := fun s x => by simp [Prod.norm_def, norm_smul_le, mul_max_of_nonneg] }
#align prod.normed_space Prod.normedSpace
-/

#print Pi.normedSpace /-
/-- The product of finitely many normed spaces is a normed space, with the sup norm. -/
instance Pi.normedSpace {E : ι → Type _} [Fintype ι] [∀ i, SeminormedAddCommGroup (E i)]
    [∀ i, NormedSpace α (E i)] : NormedSpace α (∀ i, E i)
    where norm_smul_le a f :=
    by
    simp_rw [← coe_nnnorm, ← NNReal.coe_mul, NNReal.coe_le_coe, Pi.nnnorm_def,
      NNReal.mul_finset_sup]
    exact Finset.sup_mono_fun fun _ _ => norm_smul_le _ _
#align pi.normed_space Pi.normedSpace
-/

#print MulOpposite.normedSpace /-
instance MulOpposite.normedSpace : NormedSpace α Eᵐᵒᵖ :=
  { MulOpposite.normedAddCommGroup, MulOpposite.module _ with
    norm_smul_le := fun s x => norm_smul_le s x.unop }
#align mul_opposite.normed_space MulOpposite.normedSpace
-/

#print Submodule.normedSpace /-
/-- A subspace of a normed space is also a normed space, with the restriction of the norm. -/
instance Submodule.normedSpace {𝕜 R : Type _} [SMul 𝕜 R] [NormedField 𝕜] [Ring R] {E : Type _}
    [SeminormedAddCommGroup E] [NormedSpace 𝕜 E] [Module R E] [IsScalarTower 𝕜 R E]
    (s : Submodule R E) : NormedSpace 𝕜 s where norm_smul_le c x := norm_smul_le c (x : E)
#align submodule.normed_space Submodule.normedSpace
-/

/- warning: rescale_to_shell_semi_normed_zpow -> rescale_to_shell_semi_normed_zpow is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NormedField.{u1} α] {E : Type.{u2}} [_inst_3 : SeminormedAddCommGroup.{u2} E] [_inst_4 : NormedSpace.{u1, u2} α E _inst_1 _inst_3] {c : α}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (Norm.norm.{u1} α (NormedField.toHasNorm.{u1} α _inst_1) c)) -> (forall {ε : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) ε) -> (forall {x : E}, (Ne.{1} Real (Norm.norm.{u2} E (SeminormedAddCommGroup.toHasNorm.{u2} E _inst_3) x) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) -> (Exists.{1} Int (fun (n : Int) => And (Ne.{succ u1} α (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (DivisionRing.toDivInvMonoid.{u1} α (NormedDivisionRing.toDivisionRing.{u1} α (NormedField.toNormedDivisionRing.{u1} α _inst_1))))) c n) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))))))))))) (And (LT.lt.{0} Real Real.hasLt (Norm.norm.{u2} E (SeminormedAddCommGroup.toHasNorm.{u2} E _inst_3) (SMul.smul.{u1, u2} α E (SMulZeroClass.toHasSmul.{u1, u2} α E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3))))) (SMulWithZero.toSmulZeroClass.{u1, u2} α E (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3))))) (MulActionWithZero.toSMulWithZero.{u1, u2} α E (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3))))) (Module.toMulActionWithZero.{u1, u2} α E (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3)) (NormedSpace.toModule.{u1, u2} α E _inst_1 _inst_3 _inst_4))))) (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (DivisionRing.toDivInvMonoid.{u1} α (NormedDivisionRing.toDivisionRing.{u1} α (NormedField.toNormedDivisionRing.{u1} α _inst_1))))) c n) x)) ε) (And (LE.le.{0} Real Real.hasLe (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) ε (Norm.norm.{u1} α (NormedField.toHasNorm.{u1} α _inst_1) c)) (Norm.norm.{u2} E (SeminormedAddCommGroup.toHasNorm.{u2} E _inst_3) (SMul.smul.{u1, u2} α E (SMulZeroClass.toHasSmul.{u1, u2} α E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3))))) (SMulWithZero.toSmulZeroClass.{u1, u2} α E (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3))))) (MulActionWithZero.toSMulWithZero.{u1, u2} α E (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3))))) (Module.toMulActionWithZero.{u1, u2} α E (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3)) (NormedSpace.toModule.{u1, u2} α E _inst_1 _inst_3 _inst_4))))) (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (DivisionRing.toDivInvMonoid.{u1} α (NormedDivisionRing.toDivisionRing.{u1} α (NormedField.toNormedDivisionRing.{u1} α _inst_1))))) c n) x))) (LE.le.{0} Real Real.hasLe (Inv.inv.{0} Real Real.hasInv (Norm.norm.{u1} α (NormedField.toHasNorm.{u1} α _inst_1) (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (DivisionRing.toDivInvMonoid.{u1} α (NormedDivisionRing.toDivisionRing.{u1} α (NormedField.toNormedDivisionRing.{u1} α _inst_1))))) c n))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Inv.inv.{0} Real Real.hasInv ε) (Norm.norm.{u1} α (NormedField.toHasNorm.{u1} α _inst_1) c)) (Norm.norm.{u2} E (SeminormedAddCommGroup.toHasNorm.{u2} E _inst_3) x)))))))))
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : NormedField.{u2} α] {E : Type.{u1}} [_inst_3 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{u2, u1} α E _inst_1 _inst_3] {c : α}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (Norm.norm.{u2} α (NormedField.toNorm.{u2} α _inst_1) c)) -> (forall {ε : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) ε) -> (forall {x : E}, (Ne.{1} Real (Norm.norm.{u1} E (SeminormedAddCommGroup.toNorm.{u1} E _inst_3) x) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) -> (Exists.{1} Int (fun (n : Int) => And (Ne.{succ u2} α (HPow.hPow.{u2, 0, u2} α Int α (instHPow.{u2, 0} α Int (DivInvMonoid.Pow.{u2} α (DivisionRing.toDivInvMonoid.{u2} α (NormedDivisionRing.toDivisionRing.{u2} α (NormedField.toNormedDivisionRing.{u2} α _inst_1))))) c n) (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (CommMonoidWithZero.toZero.{u2} α (CommGroupWithZero.toCommMonoidWithZero.{u2} α (Semifield.toCommGroupWithZero.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1)))))))) (And (LT.lt.{0} Real Real.instLTReal (Norm.norm.{u1} E (SeminormedAddCommGroup.toNorm.{u1} E _inst_3) (HSMul.hSMul.{u2, u1, u1} α E E (instHSMul.{u2, u1} α E (SMulZeroClass.toSMul.{u2, u1} α E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α E (CommMonoidWithZero.toZero.{u2} α (CommGroupWithZero.toCommMonoidWithZero.{u2} α (Semifield.toCommGroupWithZero.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α E (Semiring.toMonoidWithZero.{u2} α (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)))))) (Module.toMulActionWithZero.{u2, u1} α E (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)) (NormedSpace.toModule.{u2, u1} α E _inst_1 _inst_3 _inst_4)))))) (HPow.hPow.{u2, 0, u2} α Int α (instHPow.{u2, 0} α Int (DivInvMonoid.Pow.{u2} α (DivisionRing.toDivInvMonoid.{u2} α (NormedDivisionRing.toDivisionRing.{u2} α (NormedField.toNormedDivisionRing.{u2} α _inst_1))))) c n) x)) ε) (And (LE.le.{0} Real Real.instLEReal (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) ε (Norm.norm.{u2} α (NormedField.toNorm.{u2} α _inst_1) c)) (Norm.norm.{u1} E (SeminormedAddCommGroup.toNorm.{u1} E _inst_3) (HSMul.hSMul.{u2, u1, u1} α E E (instHSMul.{u2, u1} α E (SMulZeroClass.toSMul.{u2, u1} α E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α E (CommMonoidWithZero.toZero.{u2} α (CommGroupWithZero.toCommMonoidWithZero.{u2} α (Semifield.toCommGroupWithZero.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α E (Semiring.toMonoidWithZero.{u2} α (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)))))) (Module.toMulActionWithZero.{u2, u1} α E (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)) (NormedSpace.toModule.{u2, u1} α E _inst_1 _inst_3 _inst_4)))))) (HPow.hPow.{u2, 0, u2} α Int α (instHPow.{u2, 0} α Int (DivInvMonoid.Pow.{u2} α (DivisionRing.toDivInvMonoid.{u2} α (NormedDivisionRing.toDivisionRing.{u2} α (NormedField.toNormedDivisionRing.{u2} α _inst_1))))) c n) x))) (LE.le.{0} Real Real.instLEReal (Inv.inv.{0} Real Real.instInvReal (Norm.norm.{u2} α (NormedField.toNorm.{u2} α _inst_1) (HPow.hPow.{u2, 0, u2} α Int α (instHPow.{u2, 0} α Int (DivInvMonoid.Pow.{u2} α (DivisionRing.toDivInvMonoid.{u2} α (NormedDivisionRing.toDivisionRing.{u2} α (NormedField.toNormedDivisionRing.{u2} α _inst_1))))) c n))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Inv.inv.{0} Real Real.instInvReal ε) (Norm.norm.{u2} α (NormedField.toNorm.{u2} α _inst_1) c)) (Norm.norm.{u1} E (SeminormedAddCommGroup.toNorm.{u1} E _inst_3) x)))))))))
Case conversion may be inaccurate. Consider using '#align rescale_to_shell_semi_normed_zpow rescale_to_shell_semi_normed_zpowₓ'. -/
/-- If there is a scalar `c` with `‖c‖>1`, then any element with nonzero norm can be
moved by scalar multiplication to any shell of width `‖c‖`. Also recap information on the norm of
the rescaling element that shows up in applications. -/
theorem rescale_to_shell_semi_normed_zpow {c : α} (hc : 1 < ‖c‖) {ε : ℝ} (εpos : 0 < ε) {x : E}
    (hx : ‖x‖ ≠ 0) :
    ∃ n : ℤ, c ^ n ≠ 0 ∧ ‖c ^ n • x‖ < ε ∧ ε / ‖c‖ ≤ ‖c ^ n • x‖ ∧ ‖c ^ n‖⁻¹ ≤ ε⁻¹ * ‖c‖ * ‖x‖ :=
  by
  have xεpos : 0 < ‖x‖ / ε := div_pos ((Ne.symm hx).le_iff_lt.1 (norm_nonneg x)) εpos
  rcases exists_mem_Ico_zpow xεpos hc with ⟨n, hn⟩
  have cpos : 0 < ‖c‖ := lt_trans (zero_lt_one : (0 : ℝ) < 1) hc
  have cnpos : 0 < ‖c ^ (n + 1)‖ := by
    rw [norm_zpow]
    exact lt_trans xεpos hn.2
  refine' ⟨-(n + 1), _, _, _, _⟩
  show c ^ (-(n + 1)) ≠ 0; exact zpow_ne_zero _ (norm_pos_iff.1 cpos)
  show ‖c ^ (-(n + 1)) • x‖ < ε
  · rw [norm_smul, zpow_neg, norm_inv, ← div_eq_inv_mul, div_lt_iff cnpos, mul_comm, norm_zpow]
    exact (div_lt_iff εpos).1 hn.2
  show ε / ‖c‖ ≤ ‖c ^ (-(n + 1)) • x‖
  · rw [zpow_neg, div_le_iff cpos, norm_smul, norm_inv, norm_zpow, zpow_add₀ (ne_of_gt cpos),
      zpow_one, mul_inv_rev, mul_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel (ne_of_gt cpos),
      one_mul, ← div_eq_inv_mul, le_div_iff (zpow_pos_of_pos cpos _), mul_comm]
    exact (le_div_iff εpos).1 hn.1
  show ‖c ^ (-(n + 1))‖⁻¹ ≤ ε⁻¹ * ‖c‖ * ‖x‖
  · rw [zpow_neg, norm_inv, inv_inv, norm_zpow, zpow_add₀ cpos.ne', zpow_one, mul_right_comm, ←
      div_eq_inv_mul]
    exact mul_le_mul_of_nonneg_right hn.1 (norm_nonneg _)
#align rescale_to_shell_semi_normed_zpow rescale_to_shell_semi_normed_zpow

/- warning: rescale_to_shell_semi_normed -> rescale_to_shell_semi_normed is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NormedField.{u1} α] {E : Type.{u2}} [_inst_3 : SeminormedAddCommGroup.{u2} E] [_inst_4 : NormedSpace.{u1, u2} α E _inst_1 _inst_3] {c : α}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (Norm.norm.{u1} α (NormedField.toHasNorm.{u1} α _inst_1) c)) -> (forall {ε : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) ε) -> (forall {x : E}, (Ne.{1} Real (Norm.norm.{u2} E (SeminormedAddCommGroup.toHasNorm.{u2} E _inst_3) x) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) -> (Exists.{succ u1} α (fun (d : α) => And (Ne.{succ u1} α d (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))))))))))) (And (LT.lt.{0} Real Real.hasLt (Norm.norm.{u2} E (SeminormedAddCommGroup.toHasNorm.{u2} E _inst_3) (SMul.smul.{u1, u2} α E (SMulZeroClass.toHasSmul.{u1, u2} α E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3))))) (SMulWithZero.toSmulZeroClass.{u1, u2} α E (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3))))) (MulActionWithZero.toSMulWithZero.{u1, u2} α E (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3))))) (Module.toMulActionWithZero.{u1, u2} α E (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3)) (NormedSpace.toModule.{u1, u2} α E _inst_1 _inst_3 _inst_4))))) d x)) ε) (And (LE.le.{0} Real Real.hasLe (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) ε (Norm.norm.{u1} α (NormedField.toHasNorm.{u1} α _inst_1) c)) (Norm.norm.{u2} E (SeminormedAddCommGroup.toHasNorm.{u2} E _inst_3) (SMul.smul.{u1, u2} α E (SMulZeroClass.toHasSmul.{u1, u2} α E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3))))) (SMulWithZero.toSmulZeroClass.{u1, u2} α E (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3))))) (MulActionWithZero.toSMulWithZero.{u1, u2} α E (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3))))) (Module.toMulActionWithZero.{u1, u2} α E (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_3)) (NormedSpace.toModule.{u1, u2} α E _inst_1 _inst_3 _inst_4))))) d x))) (LE.le.{0} Real Real.hasLe (Inv.inv.{0} Real Real.hasInv (Norm.norm.{u1} α (NormedField.toHasNorm.{u1} α _inst_1) d)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Inv.inv.{0} Real Real.hasInv ε) (Norm.norm.{u1} α (NormedField.toHasNorm.{u1} α _inst_1) c)) (Norm.norm.{u2} E (SeminormedAddCommGroup.toHasNorm.{u2} E _inst_3) x)))))))))
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : NormedField.{u2} α] {E : Type.{u1}} [_inst_3 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{u2, u1} α E _inst_1 _inst_3] {c : α}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (Norm.norm.{u2} α (NormedField.toNorm.{u2} α _inst_1) c)) -> (forall {ε : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) ε) -> (forall {x : E}, (Ne.{1} Real (Norm.norm.{u1} E (SeminormedAddCommGroup.toNorm.{u1} E _inst_3) x) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) -> (Exists.{succ u2} α (fun (d : α) => And (Ne.{succ u2} α d (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (CommMonoidWithZero.toZero.{u2} α (CommGroupWithZero.toCommMonoidWithZero.{u2} α (Semifield.toCommGroupWithZero.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1)))))))) (And (LT.lt.{0} Real Real.instLTReal (Norm.norm.{u1} E (SeminormedAddCommGroup.toNorm.{u1} E _inst_3) (HSMul.hSMul.{u2, u1, u1} α E E (instHSMul.{u2, u1} α E (SMulZeroClass.toSMul.{u2, u1} α E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α E (CommMonoidWithZero.toZero.{u2} α (CommGroupWithZero.toCommMonoidWithZero.{u2} α (Semifield.toCommGroupWithZero.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α E (Semiring.toMonoidWithZero.{u2} α (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)))))) (Module.toMulActionWithZero.{u2, u1} α E (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)) (NormedSpace.toModule.{u2, u1} α E _inst_1 _inst_3 _inst_4)))))) d x)) ε) (And (LE.le.{0} Real Real.instLEReal (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) ε (Norm.norm.{u2} α (NormedField.toNorm.{u2} α _inst_1) c)) (Norm.norm.{u1} E (SeminormedAddCommGroup.toNorm.{u1} E _inst_3) (HSMul.hSMul.{u2, u1, u1} α E E (instHSMul.{u2, u1} α E (SMulZeroClass.toSMul.{u2, u1} α E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α E (CommMonoidWithZero.toZero.{u2} α (CommGroupWithZero.toCommMonoidWithZero.{u2} α (Semifield.toCommGroupWithZero.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α E (Semiring.toMonoidWithZero.{u2} α (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)))))) (Module.toMulActionWithZero.{u2, u1} α E (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_3)) (NormedSpace.toModule.{u2, u1} α E _inst_1 _inst_3 _inst_4)))))) d x))) (LE.le.{0} Real Real.instLEReal (Inv.inv.{0} Real Real.instInvReal (Norm.norm.{u2} α (NormedField.toNorm.{u2} α _inst_1) d)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Inv.inv.{0} Real Real.instInvReal ε) (Norm.norm.{u2} α (NormedField.toNorm.{u2} α _inst_1) c)) (Norm.norm.{u1} E (SeminormedAddCommGroup.toNorm.{u1} E _inst_3) x)))))))))
Case conversion may be inaccurate. Consider using '#align rescale_to_shell_semi_normed rescale_to_shell_semi_normedₓ'. -/
/-- If there is a scalar `c` with `‖c‖>1`, then any element with nonzero norm can be
moved by scalar multiplication to any shell of width `‖c‖`. Also recap information on the norm of
the rescaling element that shows up in applications. -/
theorem rescale_to_shell_semi_normed {c : α} (hc : 1 < ‖c‖) {ε : ℝ} (εpos : 0 < ε) {x : E}
    (hx : ‖x‖ ≠ 0) : ∃ d : α, d ≠ 0 ∧ ‖d • x‖ < ε ∧ ε / ‖c‖ ≤ ‖d • x‖ ∧ ‖d‖⁻¹ ≤ ε⁻¹ * ‖c‖ * ‖x‖ :=
  let ⟨n, hn⟩ := rescale_to_shell_semi_normed_zpow hc εpos hx
  ⟨_, hn⟩
#align rescale_to_shell_semi_normed rescale_to_shell_semi_normed

end SeminormedAddCommGroup

#print NormedSpace.induced /-
/-- A linear map from a `module` to a `normed_space` induces a `normed_space` structure on the
domain, using the `seminormed_add_comm_group.induced` norm.

See note [reducible non-instances] -/
@[reducible]
def NormedSpace.induced {F : Type _} (α β γ : Type _) [NormedField α] [AddCommGroup β] [Module α β]
    [SeminormedAddCommGroup γ] [NormedSpace α γ] [LinearMapClass F α β γ] (f : F) :
    @NormedSpace α β _ (SeminormedAddCommGroup.induced β γ f)
    where norm_smul_le a b := by
    unfold norm
    exact (map_smul f a b).symm ▸ norm_smul_le a (f b)
#align normed_space.induced NormedSpace.induced
-/

section NormedAddCommGroup

variable [NormedField α]

variable {E : Type _} [NormedAddCommGroup E] [NormedSpace α E]

variable {F : Type _} [NormedAddCommGroup F] [NormedSpace α F]

open NormedField

#print NormedSpace.toModule' /-
/-- While this may appear identical to `normed_space.to_module`, it contains an implicit argument
involving `normed_add_comm_group.to_seminormed_add_comm_group` that typeclass inference has trouble
inferring.

Specifically, the following instance cannot be found without this `normed_space.to_module'`:
```lean
example
  (𝕜 ι : Type*) (E : ι → Type*)
  [normed_field 𝕜] [Π i, normed_add_comm_group (E i)] [Π i, normed_space 𝕜 (E i)] :
  Π i, module 𝕜 (E i) := by apply_instance
```

[This Zulip thread](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclass.20resolution.20under.20binders/near/245151099)
gives some more context. -/
instance (priority := 100) NormedSpace.toModule' : Module α F :=
  NormedSpace.toModule
#align normed_space.to_module' NormedSpace.toModule'
-/

section Surj

variable (E) [NormedSpace ℝ E] [Nontrivial E]

/- warning: exists_norm_eq -> exists_norm_eq is a dubious translation:
lean 3 declaration is
  forall (E : Type.{u1}) [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_6 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_7 : Nontrivial.{u1} E] {c : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) c) -> (Exists.{succ u1} E (fun (x : E) => Eq.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) x) c))
but is expected to have type
  forall (E : Type.{u1}) [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_6 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_7 : Nontrivial.{u1} E] {c : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) c) -> (Exists.{succ u1} E (fun (x : E) => Eq.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) x) c))
Case conversion may be inaccurate. Consider using '#align exists_norm_eq exists_norm_eqₓ'. -/
theorem exists_norm_eq {c : ℝ} (hc : 0 ≤ c) : ∃ x : E, ‖x‖ = c :=
  by
  rcases exists_ne (0 : E) with ⟨x, hx⟩
  rw [← norm_ne_zero_iff] at hx
  use c • ‖x‖⁻¹ • x
  simp [norm_smul, Real.norm_of_nonneg hc, hx]
#align exists_norm_eq exists_norm_eq

/- warning: range_norm -> range_norm is a dubious translation:
lean 3 declaration is
  forall (E : Type.{u1}) [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_6 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_7 : Nontrivial.{u1} E], Eq.{1} (Set.{0} Real) (Set.range.{0, succ u1} Real E (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2))) (Set.Ici.{0} Real Real.preorder (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))
but is expected to have type
  forall (E : Type.{u1}) [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_6 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_7 : Nontrivial.{u1} E], Eq.{1} (Set.{0} Real) (Set.range.{0, succ u1} Real E (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2))) (Set.Ici.{0} Real Real.instPreorderReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))
Case conversion may be inaccurate. Consider using '#align range_norm range_normₓ'. -/
@[simp]
theorem range_norm : range (norm : E → ℝ) = Ici 0 :=
  Subset.antisymm (range_subset_iff.2 norm_nonneg) fun _ => exists_norm_eq E
#align range_norm range_norm

#print nnnorm_surjective /-
theorem nnnorm_surjective : Surjective (nnnorm : E → ℝ≥0) := fun c =>
  (exists_norm_eq E c.coe_nonneg).imp fun x h => NNReal.eq h
#align nnnorm_surjective nnnorm_surjective
-/

#print range_nnnorm /-
@[simp]
theorem range_nnnorm : range (nnnorm : E → ℝ≥0) = univ :=
  (nnnorm_surjective E).range_eq
#align range_nnnorm range_nnnorm
-/

end Surj

/- warning: real.punctured_nhds_module_ne_bot -> Real.punctured_nhds_module_neBot is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_6 : AddCommGroup.{u1} E] [_inst_7 : TopologicalSpace.{u1} E] [_inst_8 : ContinuousAdd.{u1} E _inst_7 (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_6)))))] [_inst_9 : Nontrivial.{u1} E] [_inst_10 : Module.{0, u1} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u1} E _inst_6)] [_inst_11 : ContinuousSMul.{0, u1} Real E (SMulZeroClass.toHasSmul.{0, u1} Real E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_6)))) (SMulWithZero.toSmulZeroClass.{0, u1} Real E (MulZeroClass.toHasZero.{0} Real (MulZeroOneClass.toMulZeroClass.{0} Real (MonoidWithZero.toMulZeroOneClass.{0} Real (Semiring.toMonoidWithZero.{0} Real Real.semiring)))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_6)))) (MulActionWithZero.toSMulWithZero.{0, u1} Real E (Semiring.toMonoidWithZero.{0} Real Real.semiring) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_6)))) (Module.toMulActionWithZero.{0, u1} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u1} E _inst_6) _inst_10)))) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) _inst_7] (x : E), Filter.NeBot.{u1} E (nhdsWithin.{u1} E _inst_7 x (HasCompl.compl.{u1} (Set.{u1} E) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} E) (Set.booleanAlgebra.{u1} E)) (Singleton.singleton.{u1, u1} E (Set.{u1} E) (Set.hasSingleton.{u1} E) x)))
but is expected to have type
  forall {E : Type.{u1}} [_inst_6 : AddCommGroup.{u1} E] [_inst_7 : TopologicalSpace.{u1} E] [_inst_8 : ContinuousAdd.{u1} E _inst_7 (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_6)))))] [_inst_9 : Nontrivial.{u1} E] [_inst_10 : Module.{0, u1} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u1} E _inst_6)] [_inst_11 : ContinuousSMul.{0, u1} Real E (SMulZeroClass.toSMul.{0, u1} Real E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_6))))) (SMulWithZero.toSMulZeroClass.{0, u1} Real E Real.instZeroReal (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_6))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real E Real.instMonoidWithZeroReal (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_6))))) (Module.toMulActionWithZero.{0, u1} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u1} E _inst_6) _inst_10)))) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) _inst_7] (x : E), Filter.NeBot.{u1} E (nhdsWithin.{u1} E _inst_7 x (HasCompl.compl.{u1} (Set.{u1} E) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} E) (Set.instBooleanAlgebraSet.{u1} E)) (Singleton.singleton.{u1, u1} E (Set.{u1} E) (Set.instSingletonSet.{u1} E) x)))
Case conversion may be inaccurate. Consider using '#align real.punctured_nhds_module_ne_bot Real.punctured_nhds_module_neBotₓ'. -/
/-- If `E` is a nontrivial topological module over `ℝ`, then `E` has no isolated points.
This is a particular case of `module.punctured_nhds_ne_bot`. -/
instance Real.punctured_nhds_module_neBot {E : Type _} [AddCommGroup E] [TopologicalSpace E]
    [ContinuousAdd E] [Nontrivial E] [Module ℝ E] [ContinuousSMul ℝ E] (x : E) : NeBot (𝓝[≠] x) :=
  Module.punctured_nhds_neBot ℝ E x
#align real.punctured_nhds_module_ne_bot Real.punctured_nhds_module_neBot

#print interior_closedBall' /-
theorem interior_closedBall' [NormedSpace ℝ E] [Nontrivial E] (x : E) (r : ℝ) :
    interior (closedBall x r) = ball x r :=
  by
  rcases eq_or_ne r 0 with (rfl | hr)
  · rw [closed_ball_zero, ball_zero, interior_singleton]
  · exact interior_closedBall x hr
#align interior_closed_ball' interior_closedBall'
-/

#print frontier_closedBall' /-
theorem frontier_closedBall' [NormedSpace ℝ E] [Nontrivial E] (x : E) (r : ℝ) :
    frontier (closedBall x r) = sphere x r := by
  rw [frontier, closure_closed_ball, interior_closedBall' x r, closed_ball_diff_ball]
#align frontier_closed_ball' frontier_closedBall'
-/

@[simp]
theorem interior_sphere' [NormedSpace ℝ E] [Nontrivial E] (x : E) (r : ℝ) :
    interior (sphere x r) = ∅ := by rw [← frontier_closedBall' x, interior_frontier is_closed_ball]
#align interior_sphere' interior_sphere'

@[simp]
theorem frontier_sphere' [NormedSpace ℝ E] [Nontrivial E] (x : E) (r : ℝ) :
    frontier (sphere x r) = sphere x r := by
  rw [is_closed_sphere.frontier_eq, interior_sphere' x, diff_empty]
#align frontier_sphere' frontier_sphere'

variable {α}

/- warning: rescale_to_shell_zpow -> rescale_to_shell_zpow is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NormedField.{u1} α] {E : Type.{u2}} [_inst_2 : NormedAddCommGroup.{u2} E] [_inst_3 : NormedSpace.{u1, u2} α E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)] {c : α}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (Norm.norm.{u1} α (NormedField.toHasNorm.{u1} α _inst_1) c)) -> (forall {ε : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) ε) -> (forall {x : E}, (Ne.{succ u2} E x (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (NormedAddGroup.toAddGroup.{u2} E (NormedAddCommGroup.toNormedAddGroup.{u2} E _inst_2)))))))))) -> (Exists.{1} Int (fun (n : Int) => And (Ne.{succ u1} α (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (DivisionRing.toDivInvMonoid.{u1} α (NormedDivisionRing.toDivisionRing.{u1} α (NormedField.toNormedDivisionRing.{u1} α _inst_1))))) c n) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))))))))))) (And (LT.lt.{0} Real Real.hasLt (Norm.norm.{u2} E (NormedAddCommGroup.toHasNorm.{u2} E _inst_2) (SMul.smul.{u1, u2} α E (SMulZeroClass.toHasSmul.{u1, u2} α E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} α E (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} α E (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} α E (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2))) (NormedSpace.toModule.{u1, u2} α E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_3))))) (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (DivisionRing.toDivInvMonoid.{u1} α (NormedDivisionRing.toDivisionRing.{u1} α (NormedField.toNormedDivisionRing.{u1} α _inst_1))))) c n) x)) ε) (And (LE.le.{0} Real Real.hasLe (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) ε (Norm.norm.{u1} α (NormedField.toHasNorm.{u1} α _inst_1) c)) (Norm.norm.{u2} E (NormedAddCommGroup.toHasNorm.{u2} E _inst_2) (SMul.smul.{u1, u2} α E (SMulZeroClass.toHasSmul.{u1, u2} α E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} α E (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} α E (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} α E (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2))) (NormedSpace.toModule.{u1, u2} α E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_3))))) (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (DivisionRing.toDivInvMonoid.{u1} α (NormedDivisionRing.toDivisionRing.{u1} α (NormedField.toNormedDivisionRing.{u1} α _inst_1))))) c n) x))) (LE.le.{0} Real Real.hasLe (Inv.inv.{0} Real Real.hasInv (Norm.norm.{u1} α (NormedField.toHasNorm.{u1} α _inst_1) (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (DivisionRing.toDivInvMonoid.{u1} α (NormedDivisionRing.toDivisionRing.{u1} α (NormedField.toNormedDivisionRing.{u1} α _inst_1))))) c n))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Inv.inv.{0} Real Real.hasInv ε) (Norm.norm.{u1} α (NormedField.toHasNorm.{u1} α _inst_1) c)) (Norm.norm.{u2} E (NormedAddCommGroup.toHasNorm.{u2} E _inst_2) x)))))))))
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : NormedField.{u2} α] {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_3 : NormedSpace.{u2, u1} α E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] {c : α}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (Norm.norm.{u2} α (NormedField.toNorm.{u2} α _inst_1) c)) -> (forall {ε : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) ε) -> (forall {x : E}, (Ne.{succ u1} E x (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2))))))))) -> (Exists.{1} Int (fun (n : Int) => And (Ne.{succ u2} α (HPow.hPow.{u2, 0, u2} α Int α (instHPow.{u2, 0} α Int (DivInvMonoid.Pow.{u2} α (DivisionRing.toDivInvMonoid.{u2} α (NormedDivisionRing.toDivisionRing.{u2} α (NormedField.toNormedDivisionRing.{u2} α _inst_1))))) c n) (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (CommMonoidWithZero.toZero.{u2} α (CommGroupWithZero.toCommMonoidWithZero.{u2} α (Semifield.toCommGroupWithZero.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1)))))))) (And (LT.lt.{0} Real Real.instLTReal (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) (HSMul.hSMul.{u2, u1, u1} α E E (instHSMul.{u2, u1} α E (SMulZeroClass.toSMul.{u2, u1} α E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α E (CommMonoidWithZero.toZero.{u2} α (CommGroupWithZero.toCommMonoidWithZero.{u2} α (Semifield.toCommGroupWithZero.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α E (Semiring.toMonoidWithZero.{u2} α (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α E (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{u2, u1} α E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_3)))))) (HPow.hPow.{u2, 0, u2} α Int α (instHPow.{u2, 0} α Int (DivInvMonoid.Pow.{u2} α (DivisionRing.toDivInvMonoid.{u2} α (NormedDivisionRing.toDivisionRing.{u2} α (NormedField.toNormedDivisionRing.{u2} α _inst_1))))) c n) x)) ε) (And (LE.le.{0} Real Real.instLEReal (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) ε (Norm.norm.{u2} α (NormedField.toNorm.{u2} α _inst_1) c)) (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) (HSMul.hSMul.{u2, u1, u1} α E E (instHSMul.{u2, u1} α E (SMulZeroClass.toSMul.{u2, u1} α E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α E (CommMonoidWithZero.toZero.{u2} α (CommGroupWithZero.toCommMonoidWithZero.{u2} α (Semifield.toCommGroupWithZero.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α E (Semiring.toMonoidWithZero.{u2} α (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α E (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{u2, u1} α E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_3)))))) (HPow.hPow.{u2, 0, u2} α Int α (instHPow.{u2, 0} α Int (DivInvMonoid.Pow.{u2} α (DivisionRing.toDivInvMonoid.{u2} α (NormedDivisionRing.toDivisionRing.{u2} α (NormedField.toNormedDivisionRing.{u2} α _inst_1))))) c n) x))) (LE.le.{0} Real Real.instLEReal (Inv.inv.{0} Real Real.instInvReal (Norm.norm.{u2} α (NormedField.toNorm.{u2} α _inst_1) (HPow.hPow.{u2, 0, u2} α Int α (instHPow.{u2, 0} α Int (DivInvMonoid.Pow.{u2} α (DivisionRing.toDivInvMonoid.{u2} α (NormedDivisionRing.toDivisionRing.{u2} α (NormedField.toNormedDivisionRing.{u2} α _inst_1))))) c n))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Inv.inv.{0} Real Real.instInvReal ε) (Norm.norm.{u2} α (NormedField.toNorm.{u2} α _inst_1) c)) (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) x)))))))))
Case conversion may be inaccurate. Consider using '#align rescale_to_shell_zpow rescale_to_shell_zpowₓ'. -/
theorem rescale_to_shell_zpow {c : α} (hc : 1 < ‖c‖) {ε : ℝ} (εpos : 0 < ε) {x : E} (hx : x ≠ 0) :
    ∃ n : ℤ, c ^ n ≠ 0 ∧ ‖c ^ n • x‖ < ε ∧ ε / ‖c‖ ≤ ‖c ^ n • x‖ ∧ ‖c ^ n‖⁻¹ ≤ ε⁻¹ * ‖c‖ * ‖x‖ :=
  rescale_to_shell_semi_normed_zpow hc εpos (mt norm_eq_zero.1 hx)
#align rescale_to_shell_zpow rescale_to_shell_zpow

/- warning: rescale_to_shell -> rescale_to_shell is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NormedField.{u1} α] {E : Type.{u2}} [_inst_2 : NormedAddCommGroup.{u2} E] [_inst_3 : NormedSpace.{u1, u2} α E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)] {c : α}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (Norm.norm.{u1} α (NormedField.toHasNorm.{u1} α _inst_1) c)) -> (forall {ε : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) ε) -> (forall {x : E}, (Ne.{succ u2} E x (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (NormedAddGroup.toAddGroup.{u2} E (NormedAddCommGroup.toNormedAddGroup.{u2} E _inst_2)))))))))) -> (Exists.{succ u1} α (fun (d : α) => And (Ne.{succ u1} α d (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))))))))))) (And (LT.lt.{0} Real Real.hasLt (Norm.norm.{u2} E (NormedAddCommGroup.toHasNorm.{u2} E _inst_2) (SMul.smul.{u1, u2} α E (SMulZeroClass.toHasSmul.{u1, u2} α E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} α E (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} α E (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} α E (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2))) (NormedSpace.toModule.{u1, u2} α E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_3))))) d x)) ε) (And (LE.le.{0} Real Real.hasLe (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) ε (Norm.norm.{u1} α (NormedField.toHasNorm.{u1} α _inst_1) c)) (Norm.norm.{u2} E (NormedAddCommGroup.toHasNorm.{u2} E _inst_2) (SMul.smul.{u1, u2} α E (SMulZeroClass.toHasSmul.{u1, u2} α E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} α E (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} α E (Semiring.toMonoidWithZero.{u1} α (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} α E (Ring.toSemiring.{u1} α (NormedRing.toRing.{u1} α (NormedCommRing.toNormedRing.{u1} α (NormedField.toNormedCommRing.{u1} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2))) (NormedSpace.toModule.{u1, u2} α E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_3))))) d x))) (LE.le.{0} Real Real.hasLe (Inv.inv.{0} Real Real.hasInv (Norm.norm.{u1} α (NormedField.toHasNorm.{u1} α _inst_1) d)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Inv.inv.{0} Real Real.hasInv ε) (Norm.norm.{u1} α (NormedField.toHasNorm.{u1} α _inst_1) c)) (Norm.norm.{u2} E (NormedAddCommGroup.toHasNorm.{u2} E _inst_2) x)))))))))
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : NormedField.{u2} α] {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_3 : NormedSpace.{u2, u1} α E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] {c : α}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (Norm.norm.{u2} α (NormedField.toNorm.{u2} α _inst_1) c)) -> (forall {ε : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) ε) -> (forall {x : E}, (Ne.{succ u1} E x (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2))))))))) -> (Exists.{succ u2} α (fun (d : α) => And (Ne.{succ u2} α d (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (CommMonoidWithZero.toZero.{u2} α (CommGroupWithZero.toCommMonoidWithZero.{u2} α (Semifield.toCommGroupWithZero.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1)))))))) (And (LT.lt.{0} Real Real.instLTReal (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) (HSMul.hSMul.{u2, u1, u1} α E E (instHSMul.{u2, u1} α E (SMulZeroClass.toSMul.{u2, u1} α E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α E (CommMonoidWithZero.toZero.{u2} α (CommGroupWithZero.toCommMonoidWithZero.{u2} α (Semifield.toCommGroupWithZero.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α E (Semiring.toMonoidWithZero.{u2} α (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α E (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{u2, u1} α E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_3)))))) d x)) ε) (And (LE.le.{0} Real Real.instLEReal (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) ε (Norm.norm.{u2} α (NormedField.toNorm.{u2} α _inst_1) c)) (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) (HSMul.hSMul.{u2, u1, u1} α E E (instHSMul.{u2, u1} α E (SMulZeroClass.toSMul.{u2, u1} α E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α E (CommMonoidWithZero.toZero.{u2} α (CommGroupWithZero.toCommMonoidWithZero.{u2} α (Semifield.toCommGroupWithZero.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α E (Semiring.toMonoidWithZero.{u2} α (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α E (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{u2, u1} α E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_3)))))) d x))) (LE.le.{0} Real Real.instLEReal (Inv.inv.{0} Real Real.instInvReal (Norm.norm.{u2} α (NormedField.toNorm.{u2} α _inst_1) d)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Inv.inv.{0} Real Real.instInvReal ε) (Norm.norm.{u2} α (NormedField.toNorm.{u2} α _inst_1) c)) (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) x)))))))))
Case conversion may be inaccurate. Consider using '#align rescale_to_shell rescale_to_shellₓ'. -/
/-- If there is a scalar `c` with `‖c‖>1`, then any element can be moved by scalar multiplication to
any shell of width `‖c‖`. Also recap information on the norm of the rescaling element that shows
up in applications. -/
theorem rescale_to_shell {c : α} (hc : 1 < ‖c‖) {ε : ℝ} (εpos : 0 < ε) {x : E} (hx : x ≠ 0) :
    ∃ d : α, d ≠ 0 ∧ ‖d • x‖ < ε ∧ ε / ‖c‖ ≤ ‖d • x‖ ∧ ‖d‖⁻¹ ≤ ε⁻¹ * ‖c‖ * ‖x‖ :=
  rescale_to_shell_semi_normed hc εpos (mt norm_eq_zero.1 hx)
#align rescale_to_shell rescale_to_shell

end NormedAddCommGroup

section NontriviallyNormedSpace

variable (𝕜 E : Type _) [NontriviallyNormedField 𝕜] [NormedAddCommGroup E] [NormedSpace 𝕜 E]
  [Nontrivial E]

include 𝕜

/- warning: normed_space.exists_lt_norm -> NormedSpace.exists_lt_norm is a dubious translation:
lean 3 declaration is
  forall (𝕜 : Type.{u1}) (E : Type.{u2}) [_inst_1 : NontriviallyNormedField.{u1} 𝕜] [_inst_2 : NormedAddCommGroup.{u2} E] [_inst_3 : NormedSpace.{u1, u2} 𝕜 E (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1) (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)] [_inst_4 : Nontrivial.{u2} E] (c : Real), Exists.{succ u2} E (fun (x : E) => LT.lt.{0} Real Real.hasLt c (Norm.norm.{u2} E (NormedAddCommGroup.toHasNorm.{u2} E _inst_2) x))
but is expected to have type
  forall (𝕜 : Type.{u2}) (E : Type.{u1}) [_inst_1 : NontriviallyNormedField.{u2} 𝕜] [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_3 : NormedSpace.{u2, u1} 𝕜 E (NontriviallyNormedField.toNormedField.{u2} 𝕜 _inst_1) (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_4 : Nontrivial.{u1} E] (c : Real), Exists.{succ u1} E (fun (x : E) => LT.lt.{0} Real Real.instLTReal c (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) x))
Case conversion may be inaccurate. Consider using '#align normed_space.exists_lt_norm NormedSpace.exists_lt_normₓ'. -/
/-- If `E` is a nontrivial normed space over a nontrivially normed field `𝕜`, then `E` is unbounded:
for any `c : ℝ`, there exists a vector `x : E` with norm strictly greater than `c`. -/
theorem NormedSpace.exists_lt_norm (c : ℝ) : ∃ x : E, c < ‖x‖ :=
  by
  rcases exists_ne (0 : E) with ⟨x, hx⟩
  rcases NormedField.exists_lt_norm 𝕜 (c / ‖x‖) with ⟨r, hr⟩
  use r • x
  rwa [norm_smul, ← div_lt_iff]
  rwa [norm_pos_iff]
#align normed_space.exists_lt_norm NormedSpace.exists_lt_norm

/- warning: normed_space.unbounded_univ -> NormedSpace.unbounded_univ is a dubious translation:
lean 3 declaration is
  forall (𝕜 : Type.{u1}) (E : Type.{u2}) [_inst_1 : NontriviallyNormedField.{u1} 𝕜] [_inst_2 : NormedAddCommGroup.{u2} E] [_inst_3 : NormedSpace.{u1, u2} 𝕜 E (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1) (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)] [_inst_4 : Nontrivial.{u2} E], Not (Metric.Bounded.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)) (Set.univ.{u2} E))
but is expected to have type
  forall (𝕜 : Type.{u2}) (E : Type.{u1}) [_inst_1 : NontriviallyNormedField.{u2} 𝕜] [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_3 : NormedSpace.{u2, u1} 𝕜 E (NontriviallyNormedField.toNormedField.{u2} 𝕜 _inst_1) (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_4 : Nontrivial.{u1} E], Not (Metric.Bounded.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)) (Set.univ.{u1} E))
Case conversion may be inaccurate. Consider using '#align normed_space.unbounded_univ NormedSpace.unbounded_univₓ'. -/
protected theorem NormedSpace.unbounded_univ : ¬Bounded (univ : Set E) := fun h =>
  let ⟨R, hR⟩ := bounded_iff_forall_norm_le.1 h
  let ⟨x, hx⟩ := NormedSpace.exists_lt_norm 𝕜 E R
  hx.not_le (hR x trivial)
#align normed_space.unbounded_univ NormedSpace.unbounded_univ

/- warning: normed_space.noncompact_space -> NormedSpace.noncompactSpace is a dubious translation:
lean 3 declaration is
  forall (𝕜 : Type.{u1}) (E : Type.{u2}) [_inst_1 : NontriviallyNormedField.{u1} 𝕜] [_inst_2 : NormedAddCommGroup.{u2} E] [_inst_3 : NormedSpace.{u1, u2} 𝕜 E (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1) (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)] [_inst_4 : Nontrivial.{u2} E], NoncompactSpace.{u2} E (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2))))
but is expected to have type
  forall (𝕜 : Type.{u2}) (E : Type.{u1}) [_inst_1 : NontriviallyNormedField.{u2} 𝕜] [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_3 : NormedSpace.{u2, u1} 𝕜 E (NontriviallyNormedField.toNormedField.{u2} 𝕜 _inst_1) (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_4 : Nontrivial.{u1} E], NoncompactSpace.{u1} E (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2))))
Case conversion may be inaccurate. Consider using '#align normed_space.noncompact_space NormedSpace.noncompactSpaceₓ'. -/
/-- A normed vector space over a nontrivially normed field is a noncompact space. This cannot be
an instance because in order to apply it, Lean would have to search for `normed_space 𝕜 E` with
unknown `𝕜`. We register this as an instance in two cases: `𝕜 = E` and `𝕜 = ℝ`. -/
protected theorem NormedSpace.noncompactSpace : NoncompactSpace E :=
  ⟨fun h => NormedSpace.unbounded_univ 𝕜 _ h.Bounded⟩
#align normed_space.noncompact_space NormedSpace.noncompactSpace

#print NontriviallyNormedField.noncompactSpace /-
instance (priority := 100) NontriviallyNormedField.noncompactSpace : NoncompactSpace 𝕜 :=
  NormedSpace.noncompactSpace 𝕜 𝕜
#align nontrivially_normed_field.noncompact_space NontriviallyNormedField.noncompactSpace
-/

omit 𝕜

#print RealNormedSpace.noncompactSpace /-
instance (priority := 100) RealNormedSpace.noncompactSpace [NormedSpace ℝ E] : NoncompactSpace E :=
  NormedSpace.noncompactSpace ℝ E
#align real_normed_space.noncompact_space RealNormedSpace.noncompactSpace
-/

end NontriviallyNormedSpace

section NormedAlgebra

#print NormedAlgebra /-
/-- A normed algebra `𝕜'` over `𝕜` is normed module that is also an algebra.

See the implementation notes for `algebra` for a discussion about non-unital algebras. Following
the strategy there, a non-unital *normed* algebra can be written as:
```lean
variables [normed_field 𝕜] [non_unital_semi_normed_ring 𝕜']
variables [normed_module 𝕜 𝕜'] [smul_comm_class 𝕜 𝕜' 𝕜'] [is_scalar_tower 𝕜 𝕜' 𝕜']
```
-/
class NormedAlgebra (𝕜 : Type _) (𝕜' : Type _) [NormedField 𝕜] [SeminormedRing 𝕜'] extends
  Algebra 𝕜 𝕜' where
  norm_smul_le : ∀ (r : 𝕜) (x : 𝕜'), ‖r • x‖ ≤ ‖r‖ * ‖x‖
#align normed_algebra NormedAlgebra
-/

variable {𝕜 : Type _} (𝕜' : Type _) [NormedField 𝕜] [SeminormedRing 𝕜'] [NormedAlgebra 𝕜 𝕜']

#print NormedAlgebra.toNormedSpace /-
instance (priority := 100) NormedAlgebra.toNormedSpace : NormedSpace 𝕜 𝕜'
    where norm_smul_le := NormedAlgebra.norm_smul_le
#align normed_algebra.to_normed_space NormedAlgebra.toNormedSpace
-/

#print NormedAlgebra.toNormedSpace' /-
/-- While this may appear identical to `normed_algebra.to_normed_space`, it contains an implicit
argument involving `normed_ring.to_semi_normed_ring` that typeclass inference has trouble inferring.

Specifically, the following instance cannot be found without this `normed_space.to_module'`:
```lean
example
  (𝕜 ι : Type*) (E : ι → Type*)
  [normed_field 𝕜] [Π i, normed_ring (E i)] [Π i, normed_algebra 𝕜 (E i)] :
  Π i, module 𝕜 (E i) := by apply_instance
```

See `normed_space.to_module'` for a similar situation. -/
instance (priority := 100) NormedAlgebra.toNormedSpace' {𝕜'} [NormedRing 𝕜'] [NormedAlgebra 𝕜 𝕜'] :
    NormedSpace 𝕜 𝕜' := by infer_instance
#align normed_algebra.to_normed_space' NormedAlgebra.toNormedSpace'
-/

/- warning: norm_algebra_map -> norm_algebraMap is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u1}} (𝕜' : Type.{u2}) [_inst_1 : NormedField.{u1} 𝕜] [_inst_2 : SeminormedRing.{u2} 𝕜'] [_inst_3 : NormedAlgebra.{u1, u2} 𝕜 𝕜' _inst_1 _inst_2] (x : 𝕜), Eq.{1} Real (Norm.norm.{u2} 𝕜' (SeminormedRing.toHasNorm.{u2} 𝕜' _inst_2) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) (fun (_x : RingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) => 𝕜 -> 𝕜') (RingHom.hasCoeToFun.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) (algebraMap.{u1, u2} 𝕜 𝕜' (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))) (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)) (NormedAlgebra.toAlgebra.{u1, u2} 𝕜 𝕜' _inst_1 _inst_2 _inst_3)) x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Norm.norm.{u1} 𝕜 (NormedField.toHasNorm.{u1} 𝕜 _inst_1) x) (Norm.norm.{u2} 𝕜' (SeminormedRing.toHasNorm.{u2} 𝕜' _inst_2) (OfNat.ofNat.{u2} 𝕜' 1 (OfNat.mk.{u2} 𝕜' 1 (One.one.{u2} 𝕜' (AddMonoidWithOne.toOne.{u2} 𝕜' (AddGroupWithOne.toAddMonoidWithOne.{u2} 𝕜' (AddCommGroupWithOne.toAddGroupWithOne.{u2} 𝕜' (Ring.toAddCommGroupWithOne.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2))))))))))
but is expected to have type
  forall {𝕜 : Type.{u1}} (𝕜' : Type.{u2}) [_inst_1 : NormedField.{u1} 𝕜] [_inst_2 : SeminormedRing.{u2} 𝕜'] [_inst_3 : NormedAlgebra.{u1, u2} 𝕜 𝕜' _inst_1 _inst_2] (x : 𝕜), Eq.{1} Real (Norm.norm.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : 𝕜) => 𝕜') x) (SeminormedRing.toNorm.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : 𝕜) => 𝕜') x) _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) 𝕜 (fun (_x : 𝕜) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : 𝕜) => 𝕜') _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) 𝕜 𝕜' (NonUnitalNonAssocSemiring.toMul.{u1} 𝕜 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))))) (NonUnitalNonAssocSemiring.toMul.{u2} 𝕜' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} 𝕜' (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) 𝕜 𝕜' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1)))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} 𝕜' (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2))) (RingHom.instRingHomClassRingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2))))))) (algebraMap.{u1, u2} 𝕜 𝕜' (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))) (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)) (NormedAlgebra.toAlgebra.{u1, u2} 𝕜 𝕜' _inst_1 _inst_2 _inst_3)) x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Norm.norm.{u1} 𝕜 (NormedField.toNorm.{u1} 𝕜 _inst_1) x) (Norm.norm.{u2} 𝕜' (SeminormedRing.toNorm.{u2} 𝕜' _inst_2) (OfNat.ofNat.{u2} 𝕜' 1 (One.toOfNat1.{u2} 𝕜' (NonAssocRing.toOne.{u2} 𝕜' (Ring.toNonAssocRing.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))))))
Case conversion may be inaccurate. Consider using '#align norm_algebra_map norm_algebraMapₓ'. -/
theorem norm_algebraMap (x : 𝕜) : ‖algebraMap 𝕜 𝕜' x‖ = ‖x‖ * ‖(1 : 𝕜')‖ :=
  by
  rw [Algebra.algebraMap_eq_smul_one]
  exact norm_smul _ _
#align norm_algebra_map norm_algebraMap

/- warning: nnnorm_algebra_map -> nnnorm_algebraMap is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u1}} (𝕜' : Type.{u2}) [_inst_1 : NormedField.{u1} 𝕜] [_inst_2 : SeminormedRing.{u2} 𝕜'] [_inst_3 : NormedAlgebra.{u1, u2} 𝕜 𝕜' _inst_1 _inst_2] (x : 𝕜), Eq.{1} NNReal (NNNorm.nnnorm.{u2} 𝕜' (SeminormedAddGroup.toNNNorm.{u2} 𝕜' (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} 𝕜' (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u2} 𝕜' (SeminormedRing.toNonUnitalSeminormedRing.{u2} 𝕜' _inst_2)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) (fun (_x : RingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) => 𝕜 -> 𝕜') (RingHom.hasCoeToFun.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) (algebraMap.{u1, u2} 𝕜 𝕜' (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))) (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)) (NormedAlgebra.toAlgebra.{u1, u2} 𝕜 𝕜' _inst_1 _inst_2 _inst_3)) x)) (HMul.hMul.{0, 0, 0} NNReal NNReal NNReal (instHMul.{0} NNReal (Distrib.toHasMul.{0} NNReal (NonUnitalNonAssocSemiring.toDistrib.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))) (NNNorm.nnnorm.{u1} 𝕜 (SeminormedAddGroup.toNNNorm.{u1} 𝕜 (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} 𝕜 (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} 𝕜 (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u1} 𝕜 (NormedRing.toNonUnitalNormedRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1))))))) x) (NNNorm.nnnorm.{u2} 𝕜' (SeminormedAddGroup.toNNNorm.{u2} 𝕜' (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} 𝕜' (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u2} 𝕜' (SeminormedRing.toNonUnitalSeminormedRing.{u2} 𝕜' _inst_2)))) (OfNat.ofNat.{u2} 𝕜' 1 (OfNat.mk.{u2} 𝕜' 1 (One.one.{u2} 𝕜' (AddMonoidWithOne.toOne.{u2} 𝕜' (AddGroupWithOne.toAddMonoidWithOne.{u2} 𝕜' (AddCommGroupWithOne.toAddGroupWithOne.{u2} 𝕜' (Ring.toAddCommGroupWithOne.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2))))))))))
but is expected to have type
  forall {𝕜 : Type.{u1}} (𝕜' : Type.{u2}) [_inst_1 : NormedField.{u1} 𝕜] [_inst_2 : SeminormedRing.{u2} 𝕜'] [_inst_3 : NormedAlgebra.{u1, u2} 𝕜 𝕜' _inst_1 _inst_2] (x : 𝕜), Eq.{1} NNReal (NNNorm.nnnorm.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : 𝕜) => 𝕜') x) (SeminormedAddGroup.toNNNorm.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : 𝕜) => 𝕜') x) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : 𝕜) => 𝕜') x) (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : 𝕜) => 𝕜') x) (SeminormedRing.toNonUnitalSeminormedRing.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : 𝕜) => 𝕜') x) _inst_2)))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) 𝕜 (fun (_x : 𝕜) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : 𝕜) => 𝕜') _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) 𝕜 𝕜' (NonUnitalNonAssocSemiring.toMul.{u1} 𝕜 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))))) (NonUnitalNonAssocSemiring.toMul.{u2} 𝕜' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} 𝕜' (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) 𝕜 𝕜' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1)))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} 𝕜' (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2))) (RingHom.instRingHomClassRingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2))))))) (algebraMap.{u1, u2} 𝕜 𝕜' (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))) (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)) (NormedAlgebra.toAlgebra.{u1, u2} 𝕜 𝕜' _inst_1 _inst_2 _inst_3)) x)) (HMul.hMul.{0, 0, 0} NNReal NNReal NNReal (instHMul.{0} NNReal (CanonicallyOrderedCommSemiring.toMul.{0} NNReal instNNRealCanonicallyOrderedCommSemiring)) (NNNorm.nnnorm.{u1} 𝕜 (SeminormedAddGroup.toNNNorm.{u1} 𝕜 (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} 𝕜 (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} 𝕜 (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u1} 𝕜 (NormedRing.toNonUnitalNormedRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1))))))) x) (NNNorm.nnnorm.{u2} 𝕜' (SeminormedAddGroup.toNNNorm.{u2} 𝕜' (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} 𝕜' (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u2} 𝕜' (SeminormedRing.toNonUnitalSeminormedRing.{u2} 𝕜' _inst_2)))) (OfNat.ofNat.{u2} 𝕜' 1 (One.toOfNat1.{u2} 𝕜' (NonAssocRing.toOne.{u2} 𝕜' (Ring.toNonAssocRing.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))))))
Case conversion may be inaccurate. Consider using '#align nnnorm_algebra_map nnnorm_algebraMapₓ'. -/
theorem nnnorm_algebraMap (x : 𝕜) : ‖algebraMap 𝕜 𝕜' x‖₊ = ‖x‖₊ * ‖(1 : 𝕜')‖₊ :=
  Subtype.ext <| norm_algebraMap 𝕜' x
#align nnnorm_algebra_map nnnorm_algebraMap

/- warning: norm_algebra_map' -> norm_algebraMap' is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u1}} (𝕜' : Type.{u2}) [_inst_1 : NormedField.{u1} 𝕜] [_inst_2 : SeminormedRing.{u2} 𝕜'] [_inst_3 : NormedAlgebra.{u1, u2} 𝕜 𝕜' _inst_1 _inst_2] [_inst_4 : NormOneClass.{u2} 𝕜' (SeminormedRing.toHasNorm.{u2} 𝕜' _inst_2) (AddMonoidWithOne.toOne.{u2} 𝕜' (AddGroupWithOne.toAddMonoidWithOne.{u2} 𝕜' (AddCommGroupWithOne.toAddGroupWithOne.{u2} 𝕜' (Ring.toAddCommGroupWithOne.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))))] (x : 𝕜), Eq.{1} Real (Norm.norm.{u2} 𝕜' (SeminormedRing.toHasNorm.{u2} 𝕜' _inst_2) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) (fun (_x : RingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) => 𝕜 -> 𝕜') (RingHom.hasCoeToFun.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) (algebraMap.{u1, u2} 𝕜 𝕜' (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))) (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)) (NormedAlgebra.toAlgebra.{u1, u2} 𝕜 𝕜' _inst_1 _inst_2 _inst_3)) x)) (Norm.norm.{u1} 𝕜 (NormedField.toHasNorm.{u1} 𝕜 _inst_1) x)
but is expected to have type
  forall {𝕜 : Type.{u1}} (𝕜' : Type.{u2}) [_inst_1 : NormedField.{u1} 𝕜] [_inst_2 : SeminormedRing.{u2} 𝕜'] [_inst_3 : NormedAlgebra.{u1, u2} 𝕜 𝕜' _inst_1 _inst_2] [_inst_4 : NormOneClass.{u2} 𝕜' (SeminormedRing.toNorm.{u2} 𝕜' _inst_2) (NonAssocRing.toOne.{u2} 𝕜' (Ring.toNonAssocRing.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))] (x : 𝕜), Eq.{1} Real (Norm.norm.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : 𝕜) => 𝕜') x) (SeminormedRing.toNorm.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : 𝕜) => 𝕜') x) _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) 𝕜 (fun (_x : 𝕜) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : 𝕜) => 𝕜') _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) 𝕜 𝕜' (NonUnitalNonAssocSemiring.toMul.{u1} 𝕜 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))))) (NonUnitalNonAssocSemiring.toMul.{u2} 𝕜' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} 𝕜' (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) 𝕜 𝕜' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1)))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} 𝕜' (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2))) (RingHom.instRingHomClassRingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2))))))) (algebraMap.{u1, u2} 𝕜 𝕜' (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))) (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)) (NormedAlgebra.toAlgebra.{u1, u2} 𝕜 𝕜' _inst_1 _inst_2 _inst_3)) x)) (Norm.norm.{u1} 𝕜 (NormedField.toNorm.{u1} 𝕜 _inst_1) x)
Case conversion may be inaccurate. Consider using '#align norm_algebra_map' norm_algebraMap'ₓ'. -/
@[simp]
theorem norm_algebraMap' [NormOneClass 𝕜'] (x : 𝕜) : ‖algebraMap 𝕜 𝕜' x‖ = ‖x‖ := by
  rw [norm_algebraMap, norm_one, mul_one]
#align norm_algebra_map' norm_algebraMap'

/- warning: nnnorm_algebra_map' -> nnnorm_algebraMap' is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u1}} (𝕜' : Type.{u2}) [_inst_1 : NormedField.{u1} 𝕜] [_inst_2 : SeminormedRing.{u2} 𝕜'] [_inst_3 : NormedAlgebra.{u1, u2} 𝕜 𝕜' _inst_1 _inst_2] [_inst_4 : NormOneClass.{u2} 𝕜' (SeminormedRing.toHasNorm.{u2} 𝕜' _inst_2) (AddMonoidWithOne.toOne.{u2} 𝕜' (AddGroupWithOne.toAddMonoidWithOne.{u2} 𝕜' (AddCommGroupWithOne.toAddGroupWithOne.{u2} 𝕜' (Ring.toAddCommGroupWithOne.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))))] (x : 𝕜), Eq.{1} NNReal (NNNorm.nnnorm.{u2} 𝕜' (SeminormedAddGroup.toNNNorm.{u2} 𝕜' (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} 𝕜' (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u2} 𝕜' (SeminormedRing.toNonUnitalSeminormedRing.{u2} 𝕜' _inst_2)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) (fun (_x : RingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) => 𝕜 -> 𝕜') (RingHom.hasCoeToFun.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) (algebraMap.{u1, u2} 𝕜 𝕜' (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))) (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)) (NormedAlgebra.toAlgebra.{u1, u2} 𝕜 𝕜' _inst_1 _inst_2 _inst_3)) x)) (NNNorm.nnnorm.{u1} 𝕜 (SeminormedAddGroup.toNNNorm.{u1} 𝕜 (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} 𝕜 (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} 𝕜 (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u1} 𝕜 (NormedRing.toNonUnitalNormedRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1))))))) x)
but is expected to have type
  forall {𝕜 : Type.{u1}} (𝕜' : Type.{u2}) [_inst_1 : NormedField.{u1} 𝕜] [_inst_2 : SeminormedRing.{u2} 𝕜'] [_inst_3 : NormedAlgebra.{u1, u2} 𝕜 𝕜' _inst_1 _inst_2] [_inst_4 : NormOneClass.{u2} 𝕜' (SeminormedRing.toNorm.{u2} 𝕜' _inst_2) (NonAssocRing.toOne.{u2} 𝕜' (Ring.toNonAssocRing.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))] (x : 𝕜), Eq.{1} NNReal (NNNorm.nnnorm.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : 𝕜) => 𝕜') x) (SeminormedAddGroup.toNNNorm.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : 𝕜) => 𝕜') x) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : 𝕜) => 𝕜') x) (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : 𝕜) => 𝕜') x) (SeminormedRing.toNonUnitalSeminormedRing.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : 𝕜) => 𝕜') x) _inst_2)))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) 𝕜 (fun (_x : 𝕜) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : 𝕜) => 𝕜') _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) 𝕜 𝕜' (NonUnitalNonAssocSemiring.toMul.{u1} 𝕜 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))))) (NonUnitalNonAssocSemiring.toMul.{u2} 𝕜' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} 𝕜' (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) 𝕜 𝕜' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1)))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} 𝕜' (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2))) (RingHom.instRingHomClassRingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2))))))) (algebraMap.{u1, u2} 𝕜 𝕜' (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))) (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)) (NormedAlgebra.toAlgebra.{u1, u2} 𝕜 𝕜' _inst_1 _inst_2 _inst_3)) x)) (NNNorm.nnnorm.{u1} 𝕜 (SeminormedAddGroup.toNNNorm.{u1} 𝕜 (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} 𝕜 (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} 𝕜 (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u1} 𝕜 (NormedRing.toNonUnitalNormedRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1))))))) x)
Case conversion may be inaccurate. Consider using '#align nnnorm_algebra_map' nnnorm_algebraMap'ₓ'. -/
@[simp]
theorem nnnorm_algebraMap' [NormOneClass 𝕜'] (x : 𝕜) : ‖algebraMap 𝕜 𝕜' x‖₊ = ‖x‖₊ :=
  Subtype.ext <| norm_algebraMap' _ _
#align nnnorm_algebra_map' nnnorm_algebraMap'

section NNReal

variable [NormOneClass 𝕜'] [NormedAlgebra ℝ 𝕜']

/- warning: norm_algebra_map_nnreal -> norm_algebraMap_nNReal is a dubious translation:
lean 3 declaration is
  forall (𝕜' : Type.{u1}) [_inst_2 : SeminormedRing.{u1} 𝕜'] [_inst_4 : NormOneClass.{u1} 𝕜' (SeminormedRing.toHasNorm.{u1} 𝕜' _inst_2) (AddMonoidWithOne.toOne.{u1} 𝕜' (AddGroupWithOne.toAddMonoidWithOne.{u1} 𝕜' (AddCommGroupWithOne.toAddGroupWithOne.{u1} 𝕜' (Ring.toAddCommGroupWithOne.{u1} 𝕜' (SeminormedRing.toRing.{u1} 𝕜' _inst_2)))))] [_inst_5 : NormedAlgebra.{0, u1} Real 𝕜' Real.normedField _inst_2] (x : NNReal), Eq.{1} Real (Norm.norm.{u1} 𝕜' (SeminormedRing.toHasNorm.{u1} 𝕜' _inst_2) (coeFn.{succ u1, succ u1} (RingHom.{0, u1} NNReal 𝕜' (Semiring.toNonAssocSemiring.{0} NNReal (CommSemiring.toSemiring.{0} NNReal NNReal.commSemiring)) (Semiring.toNonAssocSemiring.{u1} 𝕜' (Ring.toSemiring.{u1} 𝕜' (SeminormedRing.toRing.{u1} 𝕜' _inst_2)))) (fun (_x : RingHom.{0, u1} NNReal 𝕜' (Semiring.toNonAssocSemiring.{0} NNReal (CommSemiring.toSemiring.{0} NNReal NNReal.commSemiring)) (Semiring.toNonAssocSemiring.{u1} 𝕜' (Ring.toSemiring.{u1} 𝕜' (SeminormedRing.toRing.{u1} 𝕜' _inst_2)))) => NNReal -> 𝕜') (RingHom.hasCoeToFun.{0, u1} NNReal 𝕜' (Semiring.toNonAssocSemiring.{0} NNReal (CommSemiring.toSemiring.{0} NNReal NNReal.commSemiring)) (Semiring.toNonAssocSemiring.{u1} 𝕜' (Ring.toSemiring.{u1} 𝕜' (SeminormedRing.toRing.{u1} 𝕜' _inst_2)))) (algebraMap.{0, u1} NNReal 𝕜' NNReal.commSemiring (Ring.toSemiring.{u1} 𝕜' (SeminormedRing.toRing.{u1} 𝕜' _inst_2)) (NNReal.algebra.{u1} 𝕜' (Ring.toSemiring.{u1} 𝕜' (SeminormedRing.toRing.{u1} 𝕜' _inst_2)) (NormedAlgebra.toAlgebra.{0, u1} Real 𝕜' Real.normedField _inst_2 _inst_5))) x)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) NNReal Real (HasLiftT.mk.{1, 1} NNReal Real (CoeTCₓ.coe.{1, 1} NNReal Real (coeBase.{1, 1} NNReal Real NNReal.Real.hasCoe))) x)
but is expected to have type
  forall (𝕜' : Type.{u1}) [_inst_2 : SeminormedRing.{u1} 𝕜'] [_inst_4 : NormOneClass.{u1} 𝕜' (SeminormedRing.toNorm.{u1} 𝕜' _inst_2) (NonAssocRing.toOne.{u1} 𝕜' (Ring.toNonAssocRing.{u1} 𝕜' (SeminormedRing.toRing.{u1} 𝕜' _inst_2)))] [_inst_5 : NormedAlgebra.{0, u1} Real 𝕜' Real.normedField _inst_2] (x : NNReal), Eq.{1} Real (Norm.norm.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : NNReal) => 𝕜') x) (SeminormedRing.toNorm.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : NNReal) => 𝕜') x) _inst_2) (FunLike.coe.{succ u1, 1, succ u1} (RingHom.{0, u1} NNReal 𝕜' (Semiring.toNonAssocSemiring.{0} NNReal (CommSemiring.toSemiring.{0} NNReal instNNRealCommSemiring)) (Semiring.toNonAssocSemiring.{u1} 𝕜' (Ring.toSemiring.{u1} 𝕜' (SeminormedRing.toRing.{u1} 𝕜' _inst_2)))) NNReal (fun (_x : NNReal) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : NNReal) => 𝕜') _x) (MulHomClass.toFunLike.{u1, 0, u1} (RingHom.{0, u1} NNReal 𝕜' (Semiring.toNonAssocSemiring.{0} NNReal (CommSemiring.toSemiring.{0} NNReal instNNRealCommSemiring)) (Semiring.toNonAssocSemiring.{u1} 𝕜' (Ring.toSemiring.{u1} 𝕜' (SeminormedRing.toRing.{u1} 𝕜' _inst_2)))) NNReal 𝕜' (NonUnitalNonAssocSemiring.toMul.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal (CommSemiring.toSemiring.{0} NNReal instNNRealCommSemiring)))) (NonUnitalNonAssocSemiring.toMul.{u1} 𝕜' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜' (Ring.toSemiring.{u1} 𝕜' (SeminormedRing.toRing.{u1} 𝕜' _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{u1, 0, u1} (RingHom.{0, u1} NNReal 𝕜' (Semiring.toNonAssocSemiring.{0} NNReal (CommSemiring.toSemiring.{0} NNReal instNNRealCommSemiring)) (Semiring.toNonAssocSemiring.{u1} 𝕜' (Ring.toSemiring.{u1} 𝕜' (SeminormedRing.toRing.{u1} 𝕜' _inst_2)))) NNReal 𝕜' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal (CommSemiring.toSemiring.{0} NNReal instNNRealCommSemiring))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜' (Ring.toSemiring.{u1} 𝕜' (SeminormedRing.toRing.{u1} 𝕜' _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{u1, 0, u1} (RingHom.{0, u1} NNReal 𝕜' (Semiring.toNonAssocSemiring.{0} NNReal (CommSemiring.toSemiring.{0} NNReal instNNRealCommSemiring)) (Semiring.toNonAssocSemiring.{u1} 𝕜' (Ring.toSemiring.{u1} 𝕜' (SeminormedRing.toRing.{u1} 𝕜' _inst_2)))) NNReal 𝕜' (Semiring.toNonAssocSemiring.{0} NNReal (CommSemiring.toSemiring.{0} NNReal instNNRealCommSemiring)) (Semiring.toNonAssocSemiring.{u1} 𝕜' (Ring.toSemiring.{u1} 𝕜' (SeminormedRing.toRing.{u1} 𝕜' _inst_2))) (RingHom.instRingHomClassRingHom.{0, u1} NNReal 𝕜' (Semiring.toNonAssocSemiring.{0} NNReal (CommSemiring.toSemiring.{0} NNReal instNNRealCommSemiring)) (Semiring.toNonAssocSemiring.{u1} 𝕜' (Ring.toSemiring.{u1} 𝕜' (SeminormedRing.toRing.{u1} 𝕜' _inst_2))))))) (algebraMap.{0, u1} NNReal 𝕜' instNNRealCommSemiring (Ring.toSemiring.{u1} 𝕜' (SeminormedRing.toRing.{u1} 𝕜' _inst_2)) (NNReal.instAlgebraNNRealInstNNRealCommSemiring.{u1} 𝕜' (Ring.toSemiring.{u1} 𝕜' (SeminormedRing.toRing.{u1} 𝕜' _inst_2)) (NormedAlgebra.toAlgebra.{0, u1} Real 𝕜' Real.normedField _inst_2 _inst_5))) x)) (NNReal.toReal x)
Case conversion may be inaccurate. Consider using '#align norm_algebra_map_nnreal norm_algebraMap_nNRealₓ'. -/
@[simp]
theorem norm_algebraMap_nNReal (x : ℝ≥0) : ‖algebraMap ℝ≥0 𝕜' x‖ = x :=
  (norm_algebraMap' 𝕜' (x : ℝ)).symm ▸ Real.norm_of_nonneg x.Prop
#align norm_algebra_map_nnreal norm_algebraMap_nNReal

/- warning: nnnorm_algebra_map_nnreal -> nnnorm_algebraMap_nNReal is a dubious translation:
lean 3 declaration is
  forall (𝕜' : Type.{u1}) [_inst_2 : SeminormedRing.{u1} 𝕜'] [_inst_4 : NormOneClass.{u1} 𝕜' (SeminormedRing.toHasNorm.{u1} 𝕜' _inst_2) (AddMonoidWithOne.toOne.{u1} 𝕜' (AddGroupWithOne.toAddMonoidWithOne.{u1} 𝕜' (AddCommGroupWithOne.toAddGroupWithOne.{u1} 𝕜' (Ring.toAddCommGroupWithOne.{u1} 𝕜' (SeminormedRing.toRing.{u1} 𝕜' _inst_2)))))] [_inst_5 : NormedAlgebra.{0, u1} Real 𝕜' Real.normedField _inst_2] (x : NNReal), Eq.{1} NNReal (NNNorm.nnnorm.{u1} 𝕜' (SeminormedAddGroup.toNNNorm.{u1} 𝕜' (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} 𝕜' (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} 𝕜' (SeminormedRing.toNonUnitalSeminormedRing.{u1} 𝕜' _inst_2)))) (coeFn.{succ u1, succ u1} (RingHom.{0, u1} NNReal 𝕜' (Semiring.toNonAssocSemiring.{0} NNReal (CommSemiring.toSemiring.{0} NNReal NNReal.commSemiring)) (Semiring.toNonAssocSemiring.{u1} 𝕜' (Ring.toSemiring.{u1} 𝕜' (SeminormedRing.toRing.{u1} 𝕜' _inst_2)))) (fun (_x : RingHom.{0, u1} NNReal 𝕜' (Semiring.toNonAssocSemiring.{0} NNReal (CommSemiring.toSemiring.{0} NNReal NNReal.commSemiring)) (Semiring.toNonAssocSemiring.{u1} 𝕜' (Ring.toSemiring.{u1} 𝕜' (SeminormedRing.toRing.{u1} 𝕜' _inst_2)))) => NNReal -> 𝕜') (RingHom.hasCoeToFun.{0, u1} NNReal 𝕜' (Semiring.toNonAssocSemiring.{0} NNReal (CommSemiring.toSemiring.{0} NNReal NNReal.commSemiring)) (Semiring.toNonAssocSemiring.{u1} 𝕜' (Ring.toSemiring.{u1} 𝕜' (SeminormedRing.toRing.{u1} 𝕜' _inst_2)))) (algebraMap.{0, u1} NNReal 𝕜' NNReal.commSemiring (Ring.toSemiring.{u1} 𝕜' (SeminormedRing.toRing.{u1} 𝕜' _inst_2)) (NNReal.algebra.{u1} 𝕜' (Ring.toSemiring.{u1} 𝕜' (SeminormedRing.toRing.{u1} 𝕜' _inst_2)) (NormedAlgebra.toAlgebra.{0, u1} Real 𝕜' Real.normedField _inst_2 _inst_5))) x)) x
but is expected to have type
  forall (𝕜' : Type.{u1}) [_inst_2 : SeminormedRing.{u1} 𝕜'] [_inst_4 : NormOneClass.{u1} 𝕜' (SeminormedRing.toNorm.{u1} 𝕜' _inst_2) (NonAssocRing.toOne.{u1} 𝕜' (Ring.toNonAssocRing.{u1} 𝕜' (SeminormedRing.toRing.{u1} 𝕜' _inst_2)))] [_inst_5 : NormedAlgebra.{0, u1} Real 𝕜' Real.normedField _inst_2] (x : NNReal), Eq.{1} NNReal (NNNorm.nnnorm.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : NNReal) => 𝕜') x) (SeminormedAddGroup.toNNNorm.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : NNReal) => 𝕜') x) (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : NNReal) => 𝕜') x) (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : NNReal) => 𝕜') x) (SeminormedRing.toNonUnitalSeminormedRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : NNReal) => 𝕜') x) _inst_2)))) (FunLike.coe.{succ u1, 1, succ u1} (RingHom.{0, u1} NNReal 𝕜' (Semiring.toNonAssocSemiring.{0} NNReal (CommSemiring.toSemiring.{0} NNReal instNNRealCommSemiring)) (Semiring.toNonAssocSemiring.{u1} 𝕜' (Ring.toSemiring.{u1} 𝕜' (SeminormedRing.toRing.{u1} 𝕜' _inst_2)))) NNReal (fun (_x : NNReal) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : NNReal) => 𝕜') _x) (MulHomClass.toFunLike.{u1, 0, u1} (RingHom.{0, u1} NNReal 𝕜' (Semiring.toNonAssocSemiring.{0} NNReal (CommSemiring.toSemiring.{0} NNReal instNNRealCommSemiring)) (Semiring.toNonAssocSemiring.{u1} 𝕜' (Ring.toSemiring.{u1} 𝕜' (SeminormedRing.toRing.{u1} 𝕜' _inst_2)))) NNReal 𝕜' (NonUnitalNonAssocSemiring.toMul.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal (CommSemiring.toSemiring.{0} NNReal instNNRealCommSemiring)))) (NonUnitalNonAssocSemiring.toMul.{u1} 𝕜' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜' (Ring.toSemiring.{u1} 𝕜' (SeminormedRing.toRing.{u1} 𝕜' _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{u1, 0, u1} (RingHom.{0, u1} NNReal 𝕜' (Semiring.toNonAssocSemiring.{0} NNReal (CommSemiring.toSemiring.{0} NNReal instNNRealCommSemiring)) (Semiring.toNonAssocSemiring.{u1} 𝕜' (Ring.toSemiring.{u1} 𝕜' (SeminormedRing.toRing.{u1} 𝕜' _inst_2)))) NNReal 𝕜' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal (CommSemiring.toSemiring.{0} NNReal instNNRealCommSemiring))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜' (Ring.toSemiring.{u1} 𝕜' (SeminormedRing.toRing.{u1} 𝕜' _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{u1, 0, u1} (RingHom.{0, u1} NNReal 𝕜' (Semiring.toNonAssocSemiring.{0} NNReal (CommSemiring.toSemiring.{0} NNReal instNNRealCommSemiring)) (Semiring.toNonAssocSemiring.{u1} 𝕜' (Ring.toSemiring.{u1} 𝕜' (SeminormedRing.toRing.{u1} 𝕜' _inst_2)))) NNReal 𝕜' (Semiring.toNonAssocSemiring.{0} NNReal (CommSemiring.toSemiring.{0} NNReal instNNRealCommSemiring)) (Semiring.toNonAssocSemiring.{u1} 𝕜' (Ring.toSemiring.{u1} 𝕜' (SeminormedRing.toRing.{u1} 𝕜' _inst_2))) (RingHom.instRingHomClassRingHom.{0, u1} NNReal 𝕜' (Semiring.toNonAssocSemiring.{0} NNReal (CommSemiring.toSemiring.{0} NNReal instNNRealCommSemiring)) (Semiring.toNonAssocSemiring.{u1} 𝕜' (Ring.toSemiring.{u1} 𝕜' (SeminormedRing.toRing.{u1} 𝕜' _inst_2))))))) (algebraMap.{0, u1} NNReal 𝕜' instNNRealCommSemiring (Ring.toSemiring.{u1} 𝕜' (SeminormedRing.toRing.{u1} 𝕜' _inst_2)) (NNReal.instAlgebraNNRealInstNNRealCommSemiring.{u1} 𝕜' (Ring.toSemiring.{u1} 𝕜' (SeminormedRing.toRing.{u1} 𝕜' _inst_2)) (NormedAlgebra.toAlgebra.{0, u1} Real 𝕜' Real.normedField _inst_2 _inst_5))) x)) x
Case conversion may be inaccurate. Consider using '#align nnnorm_algebra_map_nnreal nnnorm_algebraMap_nNRealₓ'. -/
@[simp]
theorem nnnorm_algebraMap_nNReal (x : ℝ≥0) : ‖algebraMap ℝ≥0 𝕜' x‖₊ = x :=
  Subtype.ext <| norm_algebraMap_nNReal 𝕜' x
#align nnnorm_algebra_map_nnreal nnnorm_algebraMap_nNReal

end NNReal

variable (𝕜 𝕜')

/- warning: algebra_map_isometry -> algebraMap_isometry is a dubious translation:
lean 3 declaration is
  forall (𝕜 : Type.{u1}) (𝕜' : Type.{u2}) [_inst_1 : NormedField.{u1} 𝕜] [_inst_2 : SeminormedRing.{u2} 𝕜'] [_inst_3 : NormedAlgebra.{u1, u2} 𝕜 𝕜' _inst_1 _inst_2] [_inst_4 : NormOneClass.{u2} 𝕜' (SeminormedRing.toHasNorm.{u2} 𝕜' _inst_2) (AddMonoidWithOne.toOne.{u2} 𝕜' (AddGroupWithOne.toAddMonoidWithOne.{u2} 𝕜' (AddCommGroupWithOne.toAddGroupWithOne.{u2} 𝕜' (Ring.toAddCommGroupWithOne.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))))], Isometry.{u1, u2} 𝕜 𝕜' (PseudoMetricSpace.toPseudoEMetricSpace.{u1} 𝕜 (SeminormedRing.toPseudoMetricSpace.{u1} 𝕜 (SeminormedCommRing.toSemiNormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1))))) (PseudoMetricSpace.toPseudoEMetricSpace.{u2} 𝕜' (SeminormedRing.toPseudoMetricSpace.{u2} 𝕜' _inst_2)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) (fun (_x : RingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) => 𝕜 -> 𝕜') (RingHom.hasCoeToFun.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) (algebraMap.{u1, u2} 𝕜 𝕜' (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))) (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)) (NormedAlgebra.toAlgebra.{u1, u2} 𝕜 𝕜' _inst_1 _inst_2 _inst_3)))
but is expected to have type
  forall (𝕜 : Type.{u1}) (𝕜' : Type.{u2}) [_inst_1 : NormedField.{u1} 𝕜] [_inst_2 : SeminormedRing.{u2} 𝕜'] [_inst_3 : NormedAlgebra.{u1, u2} 𝕜 𝕜' _inst_1 _inst_2] [_inst_4 : NormOneClass.{u2} 𝕜' (SeminormedRing.toNorm.{u2} 𝕜' _inst_2) (NonAssocRing.toOne.{u2} 𝕜' (Ring.toNonAssocRing.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))], Isometry.{u1, u2} 𝕜 𝕜' (EMetricSpace.toPseudoEMetricSpace.{u1} 𝕜 (MetricSpace.toEMetricSpace.{u1} 𝕜 (NormedField.toMetricSpace.{u1} 𝕜 _inst_1))) (PseudoMetricSpace.toPseudoEMetricSpace.{u2} 𝕜' (SeminormedRing.toPseudoMetricSpace.{u2} 𝕜' _inst_2)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) 𝕜 (fun (_x : 𝕜) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : 𝕜) => 𝕜') _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) 𝕜 𝕜' (NonUnitalNonAssocSemiring.toMul.{u1} 𝕜 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))))) (NonUnitalNonAssocSemiring.toMul.{u2} 𝕜' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} 𝕜' (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) 𝕜 𝕜' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1)))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} 𝕜' (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)))) 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2))) (RingHom.instRingHomClassRingHom.{u1, u2} 𝕜 𝕜' (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{u2} 𝕜' (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2))))))) (algebraMap.{u1, u2} 𝕜 𝕜' (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))) (Ring.toSemiring.{u2} 𝕜' (SeminormedRing.toRing.{u2} 𝕜' _inst_2)) (NormedAlgebra.toAlgebra.{u1, u2} 𝕜 𝕜' _inst_1 _inst_2 _inst_3)))
Case conversion may be inaccurate. Consider using '#align algebra_map_isometry algebraMap_isometryₓ'. -/
/-- In a normed algebra, the inclusion of the base field in the extended field is an isometry. -/
theorem algebraMap_isometry [NormOneClass 𝕜'] : Isometry (algebraMap 𝕜 𝕜') :=
  by
  refine' Isometry.of_dist_eq fun x y => _
  rw [dist_eq_norm, dist_eq_norm, ← RingHom.map_sub, norm_algebraMap']
#align algebra_map_isometry algebraMap_isometry

#print NormedAlgebra.id /-
instance NormedAlgebra.id : NormedAlgebra 𝕜 𝕜 :=
  { NormedField.toNormedSpace, Algebra.id 𝕜 with }
#align normed_algebra.id NormedAlgebra.id
-/

/- warning: normed_algebra_rat -> normedAlgebraRat is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u1}} [_inst_4 : NormedDivisionRing.{u1} 𝕜] [_inst_5 : CharZero.{u1} 𝕜 (AddGroupWithOne.toAddMonoidWithOne.{u1} 𝕜 (AddCommGroupWithOne.toAddGroupWithOne.{u1} 𝕜 (Ring.toAddCommGroupWithOne.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedDivisionRing.toNormedRing.{u1} 𝕜 _inst_4)))))] [_inst_6 : NormedAlgebra.{0, u1} Real 𝕜 Real.normedField (NormedRing.toSeminormedRing.{u1} 𝕜 (NormedDivisionRing.toNormedRing.{u1} 𝕜 _inst_4))], NormedAlgebra.{0, u1} Rat 𝕜 Rat.normedField (NormedRing.toSeminormedRing.{u1} 𝕜 (NormedDivisionRing.toNormedRing.{u1} 𝕜 _inst_4))
but is expected to have type
  forall {𝕜 : Type.{u1}} [_inst_4 : NormedDivisionRing.{u1} 𝕜] [_inst_5 : CharZero.{u1} 𝕜 (AddGroupWithOne.toAddMonoidWithOne.{u1} 𝕜 (Ring.toAddGroupWithOne.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedDivisionRing.toNormedRing.{u1} 𝕜 _inst_4))))] [_inst_6 : NormedAlgebra.{0, u1} Real 𝕜 Real.normedField (NormedRing.toSeminormedRing.{u1} 𝕜 (NormedDivisionRing.toNormedRing.{u1} 𝕜 _inst_4))], NormedAlgebra.{0, u1} Rat 𝕜 Rat.normedField (NormedRing.toSeminormedRing.{u1} 𝕜 (NormedDivisionRing.toNormedRing.{u1} 𝕜 _inst_4))
Case conversion may be inaccurate. Consider using '#align normed_algebra_rat normedAlgebraRatₓ'. -/
/-- Any normed characteristic-zero division ring that is a normed_algebra over the reals is also a
normed algebra over the rationals.

Phrased another way, if `𝕜` is a normed algebra over the reals, then `algebra_rat` respects that
norm. -/
instance normedAlgebraRat {𝕜} [NormedDivisionRing 𝕜] [CharZero 𝕜] [NormedAlgebra ℝ 𝕜] :
    NormedAlgebra ℚ 𝕜
    where norm_smul_le q x := by
    rw [← smul_one_smul ℝ q x, Rat.smul_one_eq_coe, norm_smul, Rat.norm_cast_real]
#align normed_algebra_rat normedAlgebraRat

#print PUnit.normedAlgebra /-
instance PUnit.normedAlgebra : NormedAlgebra 𝕜 PUnit
    where norm_smul_le q x := by simp only [PUnit.norm_eq_zero, MulZeroClass.mul_zero]
#align punit.normed_algebra PUnit.normedAlgebra
-/

instance : NormedAlgebra 𝕜 (ULift 𝕜') :=
  { ULift.normedSpace with }

#print Prod.normedAlgebra /-
/-- The product of two normed algebras is a normed algebra, with the sup norm. -/
instance Prod.normedAlgebra {E F : Type _} [SeminormedRing E] [SeminormedRing F] [NormedAlgebra 𝕜 E]
    [NormedAlgebra 𝕜 F] : NormedAlgebra 𝕜 (E × F) :=
  { Prod.normedSpace with }
#align prod.normed_algebra Prod.normedAlgebra
-/

#print Pi.normedAlgebra /-
/-- The product of finitely many normed algebras is a normed algebra, with the sup norm. -/
instance Pi.normedAlgebra {E : ι → Type _} [Fintype ι] [∀ i, SeminormedRing (E i)]
    [∀ i, NormedAlgebra 𝕜 (E i)] : NormedAlgebra 𝕜 (∀ i, E i) :=
  { Pi.normedSpace, Pi.algebra _ E with }
#align pi.normed_algebra Pi.normedAlgebra
-/

#print MulOpposite.normedAlgebra /-
instance MulOpposite.normedAlgebra {E : Type _} [SeminormedRing E] [NormedAlgebra 𝕜 E] :
    NormedAlgebra 𝕜 Eᵐᵒᵖ :=
  { MulOpposite.normedSpace with }
#align mul_opposite.normed_algebra MulOpposite.normedAlgebra
-/

end NormedAlgebra

/- warning: normed_algebra.induced -> NormedAlgebra.induced is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} (α : Type.{u2}) (β : Type.{u3}) (γ : Type.{u4}) [_inst_1 : NormedField.{u2} α] [_inst_2 : Ring.{u3} β] [_inst_3 : Algebra.{u2, u3} α β (Semifield.toCommSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))) (Ring.toSemiring.{u3} β _inst_2)] [_inst_4 : SeminormedRing.{u4} γ] [_inst_5 : NormedAlgebra.{u2, u4} α γ _inst_1 _inst_4] [_inst_6 : NonUnitalAlgHomClass.{u1, u2, u3, u4} F α β γ (Ring.toMonoid.{u2} α (NormedRing.toRing.{u2} α (NormedCommRing.toNormedRing.{u2} α (NormedField.toNormedCommRing.{u2} α _inst_1)))) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} β (NonAssocRing.toNonUnitalNonAssocRing.{u3} β (Ring.toNonAssocRing.{u3} β _inst_2))) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} γ (NonAssocRing.toNonUnitalNonAssocRing.{u4} γ (Ring.toNonAssocRing.{u4} γ (SeminormedRing.toRing.{u4} γ _inst_4)))) (Module.toDistribMulAction.{u2, u3} α β (Ring.toSemiring.{u2} α (NormedRing.toRing.{u2} α (NormedCommRing.toNormedRing.{u2} α (NormedField.toNormedCommRing.{u2} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u3} β (NonUnitalNonAssocRing.toAddCommGroup.{u3} β (NonAssocRing.toNonUnitalNonAssocRing.{u3} β (Ring.toNonAssocRing.{u3} β _inst_2)))) (Algebra.toModule.{u2, u3} α β (Semifield.toCommSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))) (Ring.toSemiring.{u3} β _inst_2) _inst_3)) (Module.toDistribMulAction.{u2, u4} α γ (Ring.toSemiring.{u2} α (NormedRing.toRing.{u2} α (NormedCommRing.toNormedRing.{u2} α (NormedField.toNormedCommRing.{u2} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u4} γ (SeminormedAddCommGroup.toAddCommGroup.{u4} γ (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u4} γ (SeminormedRing.toNonUnitalSeminormedRing.{u4} γ _inst_4)))) (NormedSpace.toModule.{u2, u4} α γ _inst_1 (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u4} γ (SeminormedRing.toNonUnitalSeminormedRing.{u4} γ _inst_4)) (NormedAlgebra.toNormedSpace.{u2, u4} α γ _inst_1 _inst_4 _inst_5)))] (f : F), NormedAlgebra.{u2, u3} α β _inst_1 (SeminormedRing.induced.{u1, u3, u4} F β γ _inst_2 _inst_4 (NonUnitalAlgHomClass.toNonUnitalRingHomClass.{u1, u2, u3, u4} F α β γ (Ring.toMonoid.{u2} α (NormedRing.toRing.{u2} α (NormedCommRing.toNormedRing.{u2} α (NormedField.toNormedCommRing.{u2} α _inst_1)))) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} β (NonAssocRing.toNonUnitalNonAssocRing.{u3} β (Ring.toNonAssocRing.{u3} β _inst_2))) (Module.toDistribMulAction.{u2, u3} α β (Ring.toSemiring.{u2} α (NormedRing.toRing.{u2} α (NormedCommRing.toNormedRing.{u2} α (NormedField.toNormedCommRing.{u2} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u3} β (NonUnitalNonAssocRing.toAddCommGroup.{u3} β (NonAssocRing.toNonUnitalNonAssocRing.{u3} β (Ring.toNonAssocRing.{u3} β _inst_2)))) (Algebra.toModule.{u2, u3} α β (Semifield.toCommSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))) (Ring.toSemiring.{u3} β _inst_2) _inst_3)) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} γ (NonAssocRing.toNonUnitalNonAssocRing.{u4} γ (Ring.toNonAssocRing.{u4} γ (SeminormedRing.toRing.{u4} γ _inst_4)))) (Module.toDistribMulAction.{u2, u4} α γ (Ring.toSemiring.{u2} α (NormedRing.toRing.{u2} α (NormedCommRing.toNormedRing.{u2} α (NormedField.toNormedCommRing.{u2} α _inst_1)))) (AddCommGroup.toAddCommMonoid.{u4} γ (SeminormedAddCommGroup.toAddCommGroup.{u4} γ (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u4} γ (SeminormedRing.toNonUnitalSeminormedRing.{u4} γ _inst_4)))) (NormedSpace.toModule.{u2, u4} α γ _inst_1 (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u4} γ (SeminormedRing.toNonUnitalSeminormedRing.{u4} γ _inst_4)) (NormedAlgebra.toNormedSpace.{u2, u4} α γ _inst_1 _inst_4 _inst_5))) _inst_6) f)
but is expected to have type
  forall {F : Type.{u1}} (α : Type.{u2}) (β : Type.{u3}) (γ : Type.{u4}) [_inst_1 : NormedField.{u2} α] [_inst_2 : Ring.{u3} β] [_inst_3 : Algebra.{u2, u3} α β (Semifield.toCommSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))) (Ring.toSemiring.{u3} β _inst_2)] [_inst_4 : SeminormedRing.{u4} γ] [_inst_5 : NormedAlgebra.{u2, u4} α γ _inst_1 _inst_4] [_inst_6 : NonUnitalAlgHomClass.{u1, u2, u3, u4} F α β γ (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1)))))) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} β (NonAssocRing.toNonUnitalNonAssocRing.{u3} β (Ring.toNonAssocRing.{u3} β _inst_2))) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} γ (NonAssocRing.toNonUnitalNonAssocRing.{u4} γ (Ring.toNonAssocRing.{u4} γ (SeminormedRing.toRing.{u4} γ _inst_4)))) (Module.toDistribMulAction.{u2, u3} α β (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} β (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} β (NonAssocRing.toNonUnitalNonAssocRing.{u3} β (Ring.toNonAssocRing.{u3} β _inst_2)))) (Algebra.toModule.{u2, u3} α β (Semifield.toCommSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))) (Ring.toSemiring.{u3} β _inst_2) _inst_3)) (Module.toDistribMulAction.{u2, u4} α γ (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} γ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} γ (NonAssocRing.toNonUnitalNonAssocRing.{u4} γ (Ring.toNonAssocRing.{u4} γ (SeminormedRing.toRing.{u4} γ _inst_4))))) (NormedSpace.toModule.{u2, u4} α γ _inst_1 (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u4} γ (SeminormedRing.toNonUnitalSeminormedRing.{u4} γ _inst_4)) (NormedAlgebra.toNormedSpace.{u2, u4} α γ _inst_1 _inst_4 _inst_5)))] (f : F), NormedAlgebra.{u2, u3} α β _inst_1 (SeminormedRing.induced.{u1, u3, u4} F β γ _inst_2 _inst_4 (NonUnitalAlgHomClass.toNonUnitalRingHomClass.{u1, u2, u3, u4} F α β γ (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1)))))) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} β (NonAssocRing.toNonUnitalNonAssocRing.{u3} β (Ring.toNonAssocRing.{u3} β _inst_2))) (Module.toDistribMulAction.{u2, u3} α β (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} β (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} β (NonAssocRing.toNonUnitalNonAssocRing.{u3} β (Ring.toNonAssocRing.{u3} β _inst_2)))) (Algebra.toModule.{u2, u3} α β (Semifield.toCommSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1))) (Ring.toSemiring.{u3} β _inst_2) _inst_3)) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} γ (NonAssocRing.toNonUnitalNonAssocRing.{u4} γ (Ring.toNonAssocRing.{u4} γ (SeminormedRing.toRing.{u4} γ _inst_4)))) (Module.toDistribMulAction.{u2, u4} α γ (DivisionSemiring.toSemiring.{u2} α (Semifield.toDivisionSemiring.{u2} α (Field.toSemifield.{u2} α (NormedField.toField.{u2} α _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} γ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} γ (NonAssocRing.toNonUnitalNonAssocRing.{u4} γ (Ring.toNonAssocRing.{u4} γ (SeminormedRing.toRing.{u4} γ _inst_4))))) (NormedSpace.toModule.{u2, u4} α γ _inst_1 (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u4} γ (SeminormedRing.toNonUnitalSeminormedRing.{u4} γ _inst_4)) (NormedAlgebra.toNormedSpace.{u2, u4} α γ _inst_1 _inst_4 _inst_5))) _inst_6) f)
Case conversion may be inaccurate. Consider using '#align normed_algebra.induced NormedAlgebra.inducedₓ'. -/
/-- A non-unital algebra homomorphism from an `algebra` to a `normed_algebra` induces a
`normed_algebra` structure on the domain, using the `semi_normed_ring.induced` norm.

See note [reducible non-instances] -/
@[reducible]
def NormedAlgebra.induced {F : Type _} (α β γ : Type _) [NormedField α] [Ring β] [Algebra α β]
    [SeminormedRing γ] [NormedAlgebra α γ] [NonUnitalAlgHomClass F α β γ] (f : F) :
    @NormedAlgebra α β _ (SeminormedRing.induced β γ f)
    where norm_smul_le a b := by
    unfold norm
    exact (map_smul f a b).symm ▸ norm_smul_le a (f b)
#align normed_algebra.induced NormedAlgebra.induced

/- warning: subalgebra.to_normed_algebra -> Subalgebra.toNormedAlgebra is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u1}} {A : Type.{u2}} [_inst_1 : SeminormedRing.{u2} A] [_inst_2 : NormedField.{u1} 𝕜] [_inst_3 : NormedAlgebra.{u1, u2} 𝕜 A _inst_2 _inst_1] (S : Subalgebra.{u1, u2} 𝕜 A (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_2))) (Ring.toSemiring.{u2} A (SeminormedRing.toRing.{u2} A _inst_1)) (NormedAlgebra.toAlgebra.{u1, u2} 𝕜 A _inst_2 _inst_1 _inst_3)), NormedAlgebra.{u1, u2} 𝕜 (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} 𝕜 A (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_2))) (Ring.toSemiring.{u2} A (SeminormedRing.toRing.{u2} A _inst_1)) (NormedAlgebra.toAlgebra.{u1, u2} 𝕜 A _inst_2 _inst_1 _inst_3)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} 𝕜 A (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_2))) (Ring.toSemiring.{u2} A (SeminormedRing.toRing.{u2} A _inst_1)) (NormedAlgebra.toAlgebra.{u1, u2} 𝕜 A _inst_2 _inst_1 _inst_3)) A (Subalgebra.setLike.{u1, u2} 𝕜 A (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_2))) (Ring.toSemiring.{u2} A (SeminormedRing.toRing.{u2} A _inst_1)) (NormedAlgebra.toAlgebra.{u1, u2} 𝕜 A _inst_2 _inst_1 _inst_3))) S) _inst_2 (SubringClass.toSeminormedRing.{u2, u2} (Subalgebra.{u1, u2} 𝕜 A (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_2))) (Ring.toSemiring.{u2} A (SeminormedRing.toRing.{u2} A _inst_1)) (NormedAlgebra.toAlgebra.{u1, u2} 𝕜 A _inst_2 _inst_1 _inst_3)) A (Subalgebra.setLike.{u1, u2} 𝕜 A (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_2))) (Ring.toSemiring.{u2} A (SeminormedRing.toRing.{u2} A _inst_1)) (NormedAlgebra.toAlgebra.{u1, u2} 𝕜 A _inst_2 _inst_1 _inst_3)) _inst_1 (Subalgebra.toNormedAlgebra._proof_1.{u1, u2} 𝕜 A _inst_1 _inst_2 _inst_3) S)
but is expected to have type
  forall {𝕜 : Type.{u1}} {A : Type.{u2}} [_inst_1 : SeminormedRing.{u2} A] [_inst_2 : NormedField.{u1} 𝕜] [_inst_3 : NormedAlgebra.{u1, u2} 𝕜 A _inst_2 _inst_1] (S : Subalgebra.{u1, u2} 𝕜 A (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_2))) (Ring.toSemiring.{u2} A (SeminormedRing.toRing.{u2} A _inst_1)) (NormedAlgebra.toAlgebra.{u1, u2} 𝕜 A _inst_2 _inst_1 _inst_3)), NormedAlgebra.{u1, u2} 𝕜 (Subtype.{succ u2} A (fun (x : A) => Membership.mem.{u2, u2} A (Subalgebra.{u1, u2} 𝕜 A (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_2))) (Ring.toSemiring.{u2} A (SeminormedRing.toRing.{u2} A _inst_1)) (NormedAlgebra.toAlgebra.{u1, u2} 𝕜 A _inst_2 _inst_1 _inst_3)) (SetLike.instMembership.{u2, u2} (Subalgebra.{u1, u2} 𝕜 A (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_2))) (Ring.toSemiring.{u2} A (SeminormedRing.toRing.{u2} A _inst_1)) (NormedAlgebra.toAlgebra.{u1, u2} 𝕜 A _inst_2 _inst_1 _inst_3)) A (Subalgebra.instSetLikeSubalgebra.{u1, u2} 𝕜 A (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_2))) (Ring.toSemiring.{u2} A (SeminormedRing.toRing.{u2} A _inst_1)) (NormedAlgebra.toAlgebra.{u1, u2} 𝕜 A _inst_2 _inst_1 _inst_3))) x S)) _inst_2 (SubringClass.toSeminormedRing.{u2, u2} (Subalgebra.{u1, u2} 𝕜 A (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_2))) (Ring.toSemiring.{u2} A (SeminormedRing.toRing.{u2} A _inst_1)) (NormedAlgebra.toAlgebra.{u1, u2} 𝕜 A _inst_2 _inst_1 _inst_3)) A (Subalgebra.instSetLikeSubalgebra.{u1, u2} 𝕜 A (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_2))) (Ring.toSemiring.{u2} A (SeminormedRing.toRing.{u2} A _inst_1)) (NormedAlgebra.toAlgebra.{u1, u2} 𝕜 A _inst_2 _inst_1 _inst_3)) _inst_1 (Subalgebra.instSubringClassSubalgebraToCommSemiringToSemiringInstSetLikeSubalgebra.{u1, u2} 𝕜 A (EuclideanDomain.toCommRing.{u1} 𝕜 (Field.toEuclideanDomain.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_2))) (SeminormedRing.toRing.{u2} A _inst_1) (NormedAlgebra.toAlgebra.{u1, u2} 𝕜 A _inst_2 _inst_1 _inst_3)) S)
Case conversion may be inaccurate. Consider using '#align subalgebra.to_normed_algebra Subalgebra.toNormedAlgebraₓ'. -/
instance Subalgebra.toNormedAlgebra {𝕜 A : Type _} [SeminormedRing A] [NormedField 𝕜]
    [NormedAlgebra 𝕜 A] (S : Subalgebra 𝕜 A) : NormedAlgebra 𝕜 S :=
  @NormedAlgebra.induced _ 𝕜 S A _ (SubringClass.toRing S) S.Algebra _ _ _ S.val
#align subalgebra.to_normed_algebra Subalgebra.toNormedAlgebra

section RestrictScalars

variable (𝕜 : Type _) (𝕜' : Type _) [NormedField 𝕜] [NormedField 𝕜'] [NormedAlgebra 𝕜 𝕜']
  (E : Type _) [SeminormedAddCommGroup E] [NormedSpace 𝕜' E]

instance {𝕜 : Type _} {𝕜' : Type _} {E : Type _} [I : SeminormedAddCommGroup E] :
    SeminormedAddCommGroup (RestrictScalars 𝕜 𝕜' E) :=
  I

instance {𝕜 : Type _} {𝕜' : Type _} {E : Type _} [I : NormedAddCommGroup E] :
    NormedAddCommGroup (RestrictScalars 𝕜 𝕜' E) :=
  I

/-- If `E` is a normed space over `𝕜'` and `𝕜` is a normed algebra over `𝕜'`, then
`restrict_scalars.module` is additionally a `normed_space`. -/
instance : NormedSpace 𝕜 (RestrictScalars 𝕜 𝕜' E) :=
  { RestrictScalars.module 𝕜 𝕜' E with
    norm_smul_le := fun c x =>
      (norm_smul_le (algebraMap 𝕜 𝕜' c) (_ : E)).trans_eq <| by rw [norm_algebraMap'] }

#print Module.RestrictScalars.normedSpaceOrig /-
-- If you think you need this, consider instead reproducing `restrict_scalars.lsmul`
-- appropriately modified here.
/-- The action of the original normed_field on `restrict_scalars 𝕜 𝕜' E`.
This is not an instance as it would be contrary to the purpose of `restrict_scalars`.
-/
def Module.RestrictScalars.normedSpaceOrig {𝕜 : Type _} {𝕜' : Type _} {E : Type _} [NormedField 𝕜']
    [SeminormedAddCommGroup E] [I : NormedSpace 𝕜' E] : NormedSpace 𝕜' (RestrictScalars 𝕜 𝕜' E) :=
  I
#align module.restrict_scalars.normed_space_orig Module.RestrictScalars.normedSpaceOrig
-/

#print NormedSpace.restrictScalars /-
/-- Warning: This declaration should be used judiciously.
Please consider using `is_scalar_tower` and/or `restrict_scalars 𝕜 𝕜' E` instead.

This definition allows the `restrict_scalars.normed_space` instance to be put directly on `E`
rather on `restrict_scalars 𝕜 𝕜' E`. This would be a very bad instance; both because `𝕜'` cannot be
inferred, and because it is likely to create instance diamonds.
-/
def NormedSpace.restrictScalars : NormedSpace 𝕜 E :=
  RestrictScalars.normedSpace _ 𝕜' _
#align normed_space.restrict_scalars NormedSpace.restrictScalars
-/

end RestrictScalars

