/-
Copyright (c) 2022 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov, Yaël Dillies

! This file was ported from Lean 3 source module analysis.normed_space.ray
! leanprover-community/mathlib commit 92ca63f0fb391a9ca5f22d2409a6080e786d99f7
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.LinearAlgebra.Ray
import Mathbin.Analysis.NormedSpace.Basic

/-!
# Rays in a real normed vector space

In this file we prove some lemmas about the `same_ray` predicate in case of a real normed space. In
this case, for two vectors `x y` in the same ray, the norm of their sum is equal to the sum of their
norms and `‖y‖ • x = ‖x‖ • y`.
-/


open Real

variable {E : Type _} [SeminormedAddCommGroup E] [NormedSpace ℝ E] {F : Type _}
  [NormedAddCommGroup F] [NormedSpace ℝ F]

namespace SameRay

variable {x y : E}

/- warning: same_ray.norm_add -> SameRay.norm_add is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_1 : SeminormedAddCommGroup.{u1} E] [_inst_2 : NormedSpace.{0, u1} Real E Real.normedField _inst_1] {x : E} {y : E}, (SameRay.{0, u1} Real Real.strictOrderedCommSemiring E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_1)) (NormedSpace.toModule.{0, u1} Real E Real.normedField _inst_1 _inst_2) x y) -> (Eq.{1} Real (Norm.norm.{u1} E (SeminormedAddCommGroup.toHasNorm.{u1} E _inst_1) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_1))))))) x y)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (Norm.norm.{u1} E (SeminormedAddCommGroup.toHasNorm.{u1} E _inst_1) x) (Norm.norm.{u1} E (SeminormedAddCommGroup.toHasNorm.{u1} E _inst_1) y)))
but is expected to have type
  forall {E : Type.{u1}} [_inst_1 : SeminormedAddCommGroup.{u1} E] [_inst_2 : NormedSpace.{0, u1} Real E Real.normedField _inst_1] {x : E} {y : E}, (SameRay.{0, u1} Real Real.strictOrderedCommSemiring E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_1)) (NormedSpace.toModule.{0, u1} Real E Real.normedField _inst_1 _inst_2) x y) -> (Eq.{1} Real (Norm.norm.{u1} E (SeminormedAddCommGroup.toNorm.{u1} E _inst_1) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_1))))))) x y)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (Norm.norm.{u1} E (SeminormedAddCommGroup.toNorm.{u1} E _inst_1) x) (Norm.norm.{u1} E (SeminormedAddCommGroup.toNorm.{u1} E _inst_1) y)))
Case conversion may be inaccurate. Consider using '#align same_ray.norm_add SameRay.norm_addₓ'. -/
/-- If `x` and `y` are on the same ray, then the triangle inequality becomes the equality: the norm
of `x + y` is the sum of the norms of `x` and `y`. The converse is true for a strictly convex
space. -/
theorem norm_add (h : SameRay ℝ x y) : ‖x + y‖ = ‖x‖ + ‖y‖ :=
  by
  rcases h.exists_eq_smul with ⟨u, a, b, ha, hb, -, rfl, rfl⟩
  rw [← add_smul, norm_smul_of_nonneg (add_nonneg ha hb), norm_smul_of_nonneg ha,
    norm_smul_of_nonneg hb, add_mul]
#align same_ray.norm_add SameRay.norm_add

/- warning: same_ray.norm_sub -> SameRay.norm_sub is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u_1}} [_inst_1 : SeminormedAddCommGroup.{u_1} E] [_inst_2 : NormedSpace.{0, u_1} Real E Real.normedField _inst_1] {x : E} {y : E}, (SameRay.{0, u_1} Real Real.strictOrderedCommSemiring E (AddCommGroup.toAddCommMonoid.{u_1} E (SeminormedAddCommGroup.toAddCommGroup.{u_1} E _inst_1)) (NormedSpace.toModule.{0, u_1} Real E Real.normedField _inst_1 _inst_2) x y) -> (Eq.{1} Real (Norm.norm.{u_1} E (SeminormedAddCommGroup.toHasNorm.{u_1} E _inst_1) (HSub.hSub.{u_1, u_1, u_1} E E E (instHSub.{u_1} E (SubNegMonoid.toHasSub.{u_1} E (AddGroup.toSubNegMonoid.{u_1} E (SeminormedAddGroup.toAddGroup.{u_1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u_1} E _inst_1))))) x y)) (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.hasNeg Real.hasSup) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (Norm.norm.{u_1} E (SeminormedAddCommGroup.toHasNorm.{u_1} E _inst_1) x) (Norm.norm.{u_1} E (SeminormedAddCommGroup.toHasNorm.{u_1} E _inst_1) y))))
but is expected to have type
  forall {E : Type.{u_1}} [_inst_1 : SeminormedAddCommGroup.{u_1} E] [_inst_2 : NormedSpace.{0, u_1} Real E Real.normedField _inst_1] {x : Type.{u_2}} [y : NormedAddCommGroup.{u_2} x] [h : NormedSpace.{0, u_2} Real x Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u_2} x y)] {x : E} {y : E}, (SameRay.{0, u_1} Real Real.strictOrderedCommSemiring E (AddCommGroup.toAddCommMonoid.{u_1} E (SeminormedAddCommGroup.toAddCommGroup.{u_1} E _inst_1)) (NormedSpace.toModule.{0, u_1} Real E Real.normedField _inst_1 _inst_2) x y) -> (Eq.{1} Real (Norm.norm.{u_1} E (SeminormedAddCommGroup.toNorm.{u_1} E _inst_1) (HSub.hSub.{u_1, u_1, u_1} E E E (instHSub.{u_1} E (SubNegMonoid.toSub.{u_1} E (AddGroup.toSubNegMonoid.{u_1} E (SeminormedAddGroup.toAddGroup.{u_1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u_1} E _inst_1))))) x y)) (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.instNegReal Real.instSupReal) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.instSubReal) (Norm.norm.{u_1} E (SeminormedAddCommGroup.toNorm.{u_1} E _inst_1) x) (Norm.norm.{u_1} E (SeminormedAddCommGroup.toNorm.{u_1} E _inst_1) y))))
Case conversion may be inaccurate. Consider using '#align same_ray.norm_sub SameRay.norm_subₓ'. -/
theorem norm_sub (h : SameRay ℝ x y) : ‖x - y‖ = |‖x‖ - ‖y‖| :=
  by
  rcases h.exists_eq_smul with ⟨u, a, b, ha, hb, -, rfl, rfl⟩
  wlog hab : b ≤ a
  · rw [SameRay.sameRay_comm] at h
    rw [norm_sub_rev, abs_sub_comm]
    exact this u b a hb ha h (le_of_not_le hab)
  rw [← sub_nonneg] at hab
  rw [← sub_smul, norm_smul_of_nonneg hab, norm_smul_of_nonneg ha, norm_smul_of_nonneg hb, ←
    sub_mul, abs_of_nonneg (mul_nonneg hab (norm_nonneg _))]
#align same_ray.norm_sub SameRay.norm_sub

#print SameRay.norm_smul_eq /-
theorem norm_smul_eq (h : SameRay ℝ x y) : ‖x‖ • y = ‖y‖ • x :=
  by
  rcases h.exists_eq_smul with ⟨u, a, b, ha, hb, -, rfl, rfl⟩
  simp only [norm_smul_of_nonneg, *, mul_smul, smul_comm ‖u‖]
  apply smul_comm
#align same_ray.norm_smul_eq SameRay.norm_smul_eq
-/

end SameRay

variable {x y : F}

/- warning: norm_inj_on_ray_left -> norm_injOn_ray_left is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} [_inst_3 : NormedAddCommGroup.{u1} F] [_inst_4 : NormedSpace.{0, u1} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3)] {x : F}, (Ne.{succ u1} F x (OfNat.ofNat.{u1} F 0 (OfNat.mk.{u1} F 0 (Zero.zero.{u1} F (AddZeroClass.toHasZero.{u1} F (AddMonoid.toAddZeroClass.{u1} F (SubNegMonoid.toAddMonoid.{u1} F (AddGroup.toSubNegMonoid.{u1} F (NormedAddGroup.toAddGroup.{u1} F (NormedAddCommGroup.toNormedAddGroup.{u1} F _inst_3)))))))))) -> (Set.InjOn.{u1, 0} F Real (Norm.norm.{u1} F (NormedAddCommGroup.toHasNorm.{u1} F _inst_3)) (setOf.{u1} F (fun (y : F) => SameRay.{0, u1} Real Real.strictOrderedCommSemiring F (AddCommGroup.toAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3)) (NormedSpace.toModule.{0, u1} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3) _inst_4) x y)))
but is expected to have type
  forall {F : Type.{u1}} [_inst_3 : NormedAddCommGroup.{u1} F] [_inst_4 : NormedSpace.{0, u1} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3)] {x : F}, (Ne.{succ u1} F x (OfNat.ofNat.{u1} F 0 (Zero.toOfNat0.{u1} F (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3))))))))) -> (Set.InjOn.{u1, 0} F Real (Norm.norm.{u1} F (NormedAddCommGroup.toNorm.{u1} F _inst_3)) (setOf.{u1} F (fun (y : F) => SameRay.{0, u1} Real Real.strictOrderedCommSemiring F (AddCommGroup.toAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3)) (NormedSpace.toModule.{0, u1} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3) _inst_4) x y)))
Case conversion may be inaccurate. Consider using '#align norm_inj_on_ray_left norm_injOn_ray_leftₓ'. -/
theorem norm_injOn_ray_left (hx : x ≠ 0) : { y | SameRay ℝ x y }.InjOn norm :=
  by
  rintro y hy z hz h
  rcases hy.exists_nonneg_left hx with ⟨r, hr, rfl⟩
  rcases hz.exists_nonneg_left hx with ⟨s, hs, rfl⟩
  rw [norm_smul, norm_smul, mul_left_inj' (norm_ne_zero_iff.2 hx), norm_of_nonneg hr,
    norm_of_nonneg hs] at h
  rw [h]
#align norm_inj_on_ray_left norm_injOn_ray_left

/- warning: norm_inj_on_ray_right -> norm_injOn_ray_right is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} [_inst_3 : NormedAddCommGroup.{u1} F] [_inst_4 : NormedSpace.{0, u1} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3)] {y : F}, (Ne.{succ u1} F y (OfNat.ofNat.{u1} F 0 (OfNat.mk.{u1} F 0 (Zero.zero.{u1} F (AddZeroClass.toHasZero.{u1} F (AddMonoid.toAddZeroClass.{u1} F (SubNegMonoid.toAddMonoid.{u1} F (AddGroup.toSubNegMonoid.{u1} F (NormedAddGroup.toAddGroup.{u1} F (NormedAddCommGroup.toNormedAddGroup.{u1} F _inst_3)))))))))) -> (Set.InjOn.{u1, 0} F Real (Norm.norm.{u1} F (NormedAddCommGroup.toHasNorm.{u1} F _inst_3)) (setOf.{u1} F (fun (x : F) => SameRay.{0, u1} Real Real.strictOrderedCommSemiring F (AddCommGroup.toAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3)) (NormedSpace.toModule.{0, u1} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3) _inst_4) x y)))
but is expected to have type
  forall {F : Type.{u1}} [_inst_3 : NormedAddCommGroup.{u1} F] [_inst_4 : NormedSpace.{0, u1} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3)] {y : F}, (Ne.{succ u1} F y (OfNat.ofNat.{u1} F 0 (Zero.toOfNat0.{u1} F (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3))))))))) -> (Set.InjOn.{u1, 0} F Real (Norm.norm.{u1} F (NormedAddCommGroup.toNorm.{u1} F _inst_3)) (setOf.{u1} F (fun (x : F) => SameRay.{0, u1} Real Real.strictOrderedCommSemiring F (AddCommGroup.toAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3)) (NormedSpace.toModule.{0, u1} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3) _inst_4) x y)))
Case conversion may be inaccurate. Consider using '#align norm_inj_on_ray_right norm_injOn_ray_rightₓ'. -/
theorem norm_injOn_ray_right (hy : y ≠ 0) : { x | SameRay ℝ x y }.InjOn norm := by
  simpa only [SameRay.sameRay_comm] using norm_injOn_ray_left hy
#align norm_inj_on_ray_right norm_injOn_ray_right

#print sameRay_iff_norm_smul_eq /-
theorem sameRay_iff_norm_smul_eq : SameRay ℝ x y ↔ ‖x‖ • y = ‖y‖ • x :=
  ⟨SameRay.norm_smul_eq, fun h =>
    or_iff_not_imp_left.2 fun hx =>
      or_iff_not_imp_left.2 fun hy => ⟨‖y‖, ‖x‖, norm_pos_iff.2 hy, norm_pos_iff.2 hx, h.symm⟩⟩
#align same_ray_iff_norm_smul_eq sameRay_iff_norm_smul_eq
-/

/- warning: same_ray_iff_inv_norm_smul_eq_of_ne -> sameRay_iff_inv_norm_smul_eq_of_ne is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} [_inst_3 : NormedAddCommGroup.{u1} F] [_inst_4 : NormedSpace.{0, u1} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3)] {x : F} {y : F}, (Ne.{succ u1} F x (OfNat.ofNat.{u1} F 0 (OfNat.mk.{u1} F 0 (Zero.zero.{u1} F (AddZeroClass.toHasZero.{u1} F (AddMonoid.toAddZeroClass.{u1} F (SubNegMonoid.toAddMonoid.{u1} F (AddGroup.toSubNegMonoid.{u1} F (NormedAddGroup.toAddGroup.{u1} F (NormedAddCommGroup.toNormedAddGroup.{u1} F _inst_3)))))))))) -> (Ne.{succ u1} F y (OfNat.ofNat.{u1} F 0 (OfNat.mk.{u1} F 0 (Zero.zero.{u1} F (AddZeroClass.toHasZero.{u1} F (AddMonoid.toAddZeroClass.{u1} F (SubNegMonoid.toAddMonoid.{u1} F (AddGroup.toSubNegMonoid.{u1} F (NormedAddGroup.toAddGroup.{u1} F (NormedAddCommGroup.toNormedAddGroup.{u1} F _inst_3)))))))))) -> (Iff (SameRay.{0, u1} Real Real.strictOrderedCommSemiring F (AddCommGroup.toAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3)) (NormedSpace.toModule.{0, u1} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3) _inst_4) x y) (Eq.{succ u1} F (SMul.smul.{0, u1} Real F (SMulZeroClass.toHasSmul.{0, u1} Real F (AddZeroClass.toHasZero.{u1} F (AddMonoid.toAddZeroClass.{u1} F (AddCommMonoid.toAddMonoid.{u1} F (AddCommGroup.toAddCommMonoid.{u1} F (SeminormedAddCommGroup.toAddCommGroup.{u1} F (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3)))))) (SMulWithZero.toSmulZeroClass.{0, u1} Real F (MulZeroClass.toHasZero.{0} Real (MulZeroOneClass.toMulZeroClass.{0} Real (MonoidWithZero.toMulZeroOneClass.{0} Real (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))))))) (AddZeroClass.toHasZero.{u1} F (AddMonoid.toAddZeroClass.{u1} F (AddCommMonoid.toAddMonoid.{u1} F (AddCommGroup.toAddCommMonoid.{u1} F (SeminormedAddCommGroup.toAddCommGroup.{u1} F (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real F (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField))))) (AddZeroClass.toHasZero.{u1} F (AddMonoid.toAddZeroClass.{u1} F (AddCommMonoid.toAddMonoid.{u1} F (AddCommGroup.toAddCommMonoid.{u1} F (SeminormedAddCommGroup.toAddCommGroup.{u1} F (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3)))))) (Module.toMulActionWithZero.{0, u1} Real F (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))) (AddCommGroup.toAddCommMonoid.{u1} F (SeminormedAddCommGroup.toAddCommGroup.{u1} F (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3))) (NormedSpace.toModule.{0, u1} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3) _inst_4))))) (Inv.inv.{0} Real Real.hasInv (Norm.norm.{u1} F (NormedAddCommGroup.toHasNorm.{u1} F _inst_3) x)) x) (SMul.smul.{0, u1} Real F (SMulZeroClass.toHasSmul.{0, u1} Real F (AddZeroClass.toHasZero.{u1} F (AddMonoid.toAddZeroClass.{u1} F (AddCommMonoid.toAddMonoid.{u1} F (AddCommGroup.toAddCommMonoid.{u1} F (SeminormedAddCommGroup.toAddCommGroup.{u1} F (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3)))))) (SMulWithZero.toSmulZeroClass.{0, u1} Real F (MulZeroClass.toHasZero.{0} Real (MulZeroOneClass.toMulZeroClass.{0} Real (MonoidWithZero.toMulZeroOneClass.{0} Real (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))))))) (AddZeroClass.toHasZero.{u1} F (AddMonoid.toAddZeroClass.{u1} F (AddCommMonoid.toAddMonoid.{u1} F (AddCommGroup.toAddCommMonoid.{u1} F (SeminormedAddCommGroup.toAddCommGroup.{u1} F (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real F (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField))))) (AddZeroClass.toHasZero.{u1} F (AddMonoid.toAddZeroClass.{u1} F (AddCommMonoid.toAddMonoid.{u1} F (AddCommGroup.toAddCommMonoid.{u1} F (SeminormedAddCommGroup.toAddCommGroup.{u1} F (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3)))))) (Module.toMulActionWithZero.{0, u1} Real F (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))) (AddCommGroup.toAddCommMonoid.{u1} F (SeminormedAddCommGroup.toAddCommGroup.{u1} F (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3))) (NormedSpace.toModule.{0, u1} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3) _inst_4))))) (Inv.inv.{0} Real Real.hasInv (Norm.norm.{u1} F (NormedAddCommGroup.toHasNorm.{u1} F _inst_3) y)) y)))
but is expected to have type
  forall {F : Type.{u1}} [_inst_3 : NormedAddCommGroup.{u1} F] [_inst_4 : NormedSpace.{0, u1} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3)] {x : F} {y : F}, (Ne.{succ u1} F x (OfNat.ofNat.{u1} F 0 (Zero.toOfNat0.{u1} F (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3))))))))) -> (Ne.{succ u1} F y (OfNat.ofNat.{u1} F 0 (Zero.toOfNat0.{u1} F (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3))))))))) -> (Iff (SameRay.{0, u1} Real Real.strictOrderedCommSemiring F (AddCommGroup.toAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3)) (NormedSpace.toModule.{0, u1} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3) _inst_4) x y) (Eq.{succ u1} F (HSMul.hSMul.{0, u1, u1} Real F F (instHSMul.{0, u1} Real F (SMulZeroClass.toSMul.{0, u1} Real F (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3)))))) (SMulWithZero.toSMulZeroClass.{0, u1} Real F Real.instZeroReal (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real F Real.instMonoidWithZeroReal (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3)))))) (Module.toMulActionWithZero.{0, u1} Real F Real.semiring (AddCommGroup.toAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3)) (NormedSpace.toModule.{0, u1} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3) _inst_4)))))) (Inv.inv.{0} Real Real.instInvReal (Norm.norm.{u1} F (NormedAddCommGroup.toNorm.{u1} F _inst_3) x)) x) (HSMul.hSMul.{0, u1, u1} Real F F (instHSMul.{0, u1} Real F (SMulZeroClass.toSMul.{0, u1} Real F (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3)))))) (SMulWithZero.toSMulZeroClass.{0, u1} Real F Real.instZeroReal (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real F Real.instMonoidWithZeroReal (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3)))))) (Module.toMulActionWithZero.{0, u1} Real F Real.semiring (AddCommGroup.toAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3)) (NormedSpace.toModule.{0, u1} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3) _inst_4)))))) (Inv.inv.{0} Real Real.instInvReal (Norm.norm.{u1} F (NormedAddCommGroup.toNorm.{u1} F _inst_3) y)) y)))
Case conversion may be inaccurate. Consider using '#align same_ray_iff_inv_norm_smul_eq_of_ne sameRay_iff_inv_norm_smul_eq_of_neₓ'. -/
/-- Two nonzero vectors `x y` in a real normed space are on the same ray if and only if the unit
vectors `‖x‖⁻¹ • x` and `‖y‖⁻¹ • y` are equal. -/
theorem sameRay_iff_inv_norm_smul_eq_of_ne (hx : x ≠ 0) (hy : y ≠ 0) :
    SameRay ℝ x y ↔ ‖x‖⁻¹ • x = ‖y‖⁻¹ • y := by
  rw [inv_smul_eq_iff₀, smul_comm, eq_comm, inv_smul_eq_iff₀, sameRay_iff_norm_smul_eq] <;>
    rwa [norm_ne_zero_iff]
#align same_ray_iff_inv_norm_smul_eq_of_ne sameRay_iff_inv_norm_smul_eq_of_ne

/- warning: same_ray.inv_norm_smul_eq -> SameRay.inv_norm_smul_eq is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} [_inst_3 : NormedAddCommGroup.{u1} F] [_inst_4 : NormedSpace.{0, u1} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3)] {x : F} {y : F}, (Ne.{succ u1} F x (OfNat.ofNat.{u1} F 0 (OfNat.mk.{u1} F 0 (Zero.zero.{u1} F (AddZeroClass.toHasZero.{u1} F (AddMonoid.toAddZeroClass.{u1} F (SubNegMonoid.toAddMonoid.{u1} F (AddGroup.toSubNegMonoid.{u1} F (NormedAddGroup.toAddGroup.{u1} F (NormedAddCommGroup.toNormedAddGroup.{u1} F _inst_3)))))))))) -> (Ne.{succ u1} F y (OfNat.ofNat.{u1} F 0 (OfNat.mk.{u1} F 0 (Zero.zero.{u1} F (AddZeroClass.toHasZero.{u1} F (AddMonoid.toAddZeroClass.{u1} F (SubNegMonoid.toAddMonoid.{u1} F (AddGroup.toSubNegMonoid.{u1} F (NormedAddGroup.toAddGroup.{u1} F (NormedAddCommGroup.toNormedAddGroup.{u1} F _inst_3)))))))))) -> (SameRay.{0, u1} Real Real.strictOrderedCommSemiring F (AddCommGroup.toAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3)) (NormedSpace.toModule.{0, u1} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3) _inst_4) x y) -> (Eq.{succ u1} F (SMul.smul.{0, u1} Real F (SMulZeroClass.toHasSmul.{0, u1} Real F (AddZeroClass.toHasZero.{u1} F (AddMonoid.toAddZeroClass.{u1} F (AddCommMonoid.toAddMonoid.{u1} F (AddCommGroup.toAddCommMonoid.{u1} F (SeminormedAddCommGroup.toAddCommGroup.{u1} F (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3)))))) (SMulWithZero.toSmulZeroClass.{0, u1} Real F (MulZeroClass.toHasZero.{0} Real (MulZeroOneClass.toMulZeroClass.{0} Real (MonoidWithZero.toMulZeroOneClass.{0} Real (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))))))) (AddZeroClass.toHasZero.{u1} F (AddMonoid.toAddZeroClass.{u1} F (AddCommMonoid.toAddMonoid.{u1} F (AddCommGroup.toAddCommMonoid.{u1} F (SeminormedAddCommGroup.toAddCommGroup.{u1} F (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real F (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField))))) (AddZeroClass.toHasZero.{u1} F (AddMonoid.toAddZeroClass.{u1} F (AddCommMonoid.toAddMonoid.{u1} F (AddCommGroup.toAddCommMonoid.{u1} F (SeminormedAddCommGroup.toAddCommGroup.{u1} F (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3)))))) (Module.toMulActionWithZero.{0, u1} Real F (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))) (AddCommGroup.toAddCommMonoid.{u1} F (SeminormedAddCommGroup.toAddCommGroup.{u1} F (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3))) (NormedSpace.toModule.{0, u1} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3) _inst_4))))) (Inv.inv.{0} Real Real.hasInv (Norm.norm.{u1} F (NormedAddCommGroup.toHasNorm.{u1} F _inst_3) x)) x) (SMul.smul.{0, u1} Real F (SMulZeroClass.toHasSmul.{0, u1} Real F (AddZeroClass.toHasZero.{u1} F (AddMonoid.toAddZeroClass.{u1} F (AddCommMonoid.toAddMonoid.{u1} F (AddCommGroup.toAddCommMonoid.{u1} F (SeminormedAddCommGroup.toAddCommGroup.{u1} F (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3)))))) (SMulWithZero.toSmulZeroClass.{0, u1} Real F (MulZeroClass.toHasZero.{0} Real (MulZeroOneClass.toMulZeroClass.{0} Real (MonoidWithZero.toMulZeroOneClass.{0} Real (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))))))) (AddZeroClass.toHasZero.{u1} F (AddMonoid.toAddZeroClass.{u1} F (AddCommMonoid.toAddMonoid.{u1} F (AddCommGroup.toAddCommMonoid.{u1} F (SeminormedAddCommGroup.toAddCommGroup.{u1} F (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real F (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField))))) (AddZeroClass.toHasZero.{u1} F (AddMonoid.toAddZeroClass.{u1} F (AddCommMonoid.toAddMonoid.{u1} F (AddCommGroup.toAddCommMonoid.{u1} F (SeminormedAddCommGroup.toAddCommGroup.{u1} F (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3)))))) (Module.toMulActionWithZero.{0, u1} Real F (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))) (AddCommGroup.toAddCommMonoid.{u1} F (SeminormedAddCommGroup.toAddCommGroup.{u1} F (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3))) (NormedSpace.toModule.{0, u1} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3) _inst_4))))) (Inv.inv.{0} Real Real.hasInv (Norm.norm.{u1} F (NormedAddCommGroup.toHasNorm.{u1} F _inst_3) y)) y))
but is expected to have type
  forall {F : Type.{u1}} [_inst_3 : NormedAddCommGroup.{u1} F] [_inst_4 : NormedSpace.{0, u1} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3)] {x : F} {y : F}, (Ne.{succ u1} F x (OfNat.ofNat.{u1} F 0 (Zero.toOfNat0.{u1} F (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3))))))))) -> (Ne.{succ u1} F y (OfNat.ofNat.{u1} F 0 (Zero.toOfNat0.{u1} F (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3))))))))) -> (SameRay.{0, u1} Real Real.strictOrderedCommSemiring F (AddCommGroup.toAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3)) (NormedSpace.toModule.{0, u1} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3) _inst_4) x y) -> (Eq.{succ u1} F (HSMul.hSMul.{0, u1, u1} Real F F (instHSMul.{0, u1} Real F (SMulZeroClass.toSMul.{0, u1} Real F (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3)))))) (SMulWithZero.toSMulZeroClass.{0, u1} Real F Real.instZeroReal (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real F Real.instMonoidWithZeroReal (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3)))))) (Module.toMulActionWithZero.{0, u1} Real F Real.semiring (AddCommGroup.toAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3)) (NormedSpace.toModule.{0, u1} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3) _inst_4)))))) (Inv.inv.{0} Real Real.instInvReal (Norm.norm.{u1} F (NormedAddCommGroup.toNorm.{u1} F _inst_3) x)) x) (HSMul.hSMul.{0, u1, u1} Real F F (instHSMul.{0, u1} Real F (SMulZeroClass.toSMul.{0, u1} Real F (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3)))))) (SMulWithZero.toSMulZeroClass.{0, u1} Real F Real.instZeroReal (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real F Real.instMonoidWithZeroReal (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3)))))) (Module.toMulActionWithZero.{0, u1} Real F Real.semiring (AddCommGroup.toAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3)) (NormedSpace.toModule.{0, u1} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3) _inst_4)))))) (Inv.inv.{0} Real Real.instInvReal (Norm.norm.{u1} F (NormedAddCommGroup.toNorm.{u1} F _inst_3) y)) y))
Case conversion may be inaccurate. Consider using '#align same_ray.inv_norm_smul_eq SameRay.inv_norm_smul_eqₓ'. -/
alias sameRay_iff_inv_norm_smul_eq_of_ne ↔ SameRay.inv_norm_smul_eq _
#align same_ray.inv_norm_smul_eq SameRay.inv_norm_smul_eq

/- warning: same_ray_iff_inv_norm_smul_eq -> sameRay_iff_inv_norm_smul_eq is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} [_inst_3 : NormedAddCommGroup.{u1} F] [_inst_4 : NormedSpace.{0, u1} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3)] {x : F} {y : F}, Iff (SameRay.{0, u1} Real Real.strictOrderedCommSemiring F (AddCommGroup.toAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3)) (NormedSpace.toModule.{0, u1} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3) _inst_4) x y) (Or (Eq.{succ u1} F x (OfNat.ofNat.{u1} F 0 (OfNat.mk.{u1} F 0 (Zero.zero.{u1} F (AddZeroClass.toHasZero.{u1} F (AddMonoid.toAddZeroClass.{u1} F (SubNegMonoid.toAddMonoid.{u1} F (AddGroup.toSubNegMonoid.{u1} F (NormedAddGroup.toAddGroup.{u1} F (NormedAddCommGroup.toNormedAddGroup.{u1} F _inst_3)))))))))) (Or (Eq.{succ u1} F y (OfNat.ofNat.{u1} F 0 (OfNat.mk.{u1} F 0 (Zero.zero.{u1} F (AddZeroClass.toHasZero.{u1} F (AddMonoid.toAddZeroClass.{u1} F (SubNegMonoid.toAddMonoid.{u1} F (AddGroup.toSubNegMonoid.{u1} F (NormedAddGroup.toAddGroup.{u1} F (NormedAddCommGroup.toNormedAddGroup.{u1} F _inst_3)))))))))) (Eq.{succ u1} F (SMul.smul.{0, u1} Real F (SMulZeroClass.toHasSmul.{0, u1} Real F (AddZeroClass.toHasZero.{u1} F (AddMonoid.toAddZeroClass.{u1} F (AddCommMonoid.toAddMonoid.{u1} F (AddCommGroup.toAddCommMonoid.{u1} F (SeminormedAddCommGroup.toAddCommGroup.{u1} F (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3)))))) (SMulWithZero.toSmulZeroClass.{0, u1} Real F (MulZeroClass.toHasZero.{0} Real (MulZeroOneClass.toMulZeroClass.{0} Real (MonoidWithZero.toMulZeroOneClass.{0} Real (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))))))) (AddZeroClass.toHasZero.{u1} F (AddMonoid.toAddZeroClass.{u1} F (AddCommMonoid.toAddMonoid.{u1} F (AddCommGroup.toAddCommMonoid.{u1} F (SeminormedAddCommGroup.toAddCommGroup.{u1} F (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real F (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField))))) (AddZeroClass.toHasZero.{u1} F (AddMonoid.toAddZeroClass.{u1} F (AddCommMonoid.toAddMonoid.{u1} F (AddCommGroup.toAddCommMonoid.{u1} F (SeminormedAddCommGroup.toAddCommGroup.{u1} F (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3)))))) (Module.toMulActionWithZero.{0, u1} Real F (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))) (AddCommGroup.toAddCommMonoid.{u1} F (SeminormedAddCommGroup.toAddCommGroup.{u1} F (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3))) (NormedSpace.toModule.{0, u1} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3) _inst_4))))) (Inv.inv.{0} Real Real.hasInv (Norm.norm.{u1} F (NormedAddCommGroup.toHasNorm.{u1} F _inst_3) x)) x) (SMul.smul.{0, u1} Real F (SMulZeroClass.toHasSmul.{0, u1} Real F (AddZeroClass.toHasZero.{u1} F (AddMonoid.toAddZeroClass.{u1} F (AddCommMonoid.toAddMonoid.{u1} F (AddCommGroup.toAddCommMonoid.{u1} F (SeminormedAddCommGroup.toAddCommGroup.{u1} F (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3)))))) (SMulWithZero.toSmulZeroClass.{0, u1} Real F (MulZeroClass.toHasZero.{0} Real (MulZeroOneClass.toMulZeroClass.{0} Real (MonoidWithZero.toMulZeroOneClass.{0} Real (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))))))) (AddZeroClass.toHasZero.{u1} F (AddMonoid.toAddZeroClass.{u1} F (AddCommMonoid.toAddMonoid.{u1} F (AddCommGroup.toAddCommMonoid.{u1} F (SeminormedAddCommGroup.toAddCommGroup.{u1} F (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real F (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField))))) (AddZeroClass.toHasZero.{u1} F (AddMonoid.toAddZeroClass.{u1} F (AddCommMonoid.toAddMonoid.{u1} F (AddCommGroup.toAddCommMonoid.{u1} F (SeminormedAddCommGroup.toAddCommGroup.{u1} F (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3)))))) (Module.toMulActionWithZero.{0, u1} Real F (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))) (AddCommGroup.toAddCommMonoid.{u1} F (SeminormedAddCommGroup.toAddCommGroup.{u1} F (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3))) (NormedSpace.toModule.{0, u1} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3) _inst_4))))) (Inv.inv.{0} Real Real.hasInv (Norm.norm.{u1} F (NormedAddCommGroup.toHasNorm.{u1} F _inst_3) y)) y))))
but is expected to have type
  forall {F : Type.{u1}} [_inst_3 : NormedAddCommGroup.{u1} F] [_inst_4 : NormedSpace.{0, u1} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3)] {x : F} {y : F}, Iff (SameRay.{0, u1} Real Real.strictOrderedCommSemiring F (AddCommGroup.toAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3)) (NormedSpace.toModule.{0, u1} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3) _inst_4) x y) (Or (Eq.{succ u1} F x (OfNat.ofNat.{u1} F 0 (Zero.toOfNat0.{u1} F (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3))))))))) (Or (Eq.{succ u1} F y (OfNat.ofNat.{u1} F 0 (Zero.toOfNat0.{u1} F (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3))))))))) (Eq.{succ u1} F (HSMul.hSMul.{0, u1, u1} Real F F (instHSMul.{0, u1} Real F (SMulZeroClass.toSMul.{0, u1} Real F (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3)))))) (SMulWithZero.toSMulZeroClass.{0, u1} Real F Real.instZeroReal (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real F Real.instMonoidWithZeroReal (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3)))))) (Module.toMulActionWithZero.{0, u1} Real F Real.semiring (AddCommGroup.toAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3)) (NormedSpace.toModule.{0, u1} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3) _inst_4)))))) (Inv.inv.{0} Real Real.instInvReal (Norm.norm.{u1} F (NormedAddCommGroup.toNorm.{u1} F _inst_3) x)) x) (HSMul.hSMul.{0, u1, u1} Real F F (instHSMul.{0, u1} Real F (SMulZeroClass.toSMul.{0, u1} Real F (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3)))))) (SMulWithZero.toSMulZeroClass.{0, u1} Real F Real.instZeroReal (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real F Real.instMonoidWithZeroReal (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3)))))) (Module.toMulActionWithZero.{0, u1} Real F Real.semiring (AddCommGroup.toAddCommMonoid.{u1} F (NormedAddCommGroup.toAddCommGroup.{u1} F _inst_3)) (NormedSpace.toModule.{0, u1} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_3) _inst_4)))))) (Inv.inv.{0} Real Real.instInvReal (Norm.norm.{u1} F (NormedAddCommGroup.toNorm.{u1} F _inst_3) y)) y))))
Case conversion may be inaccurate. Consider using '#align same_ray_iff_inv_norm_smul_eq sameRay_iff_inv_norm_smul_eqₓ'. -/
/-- Two vectors `x y` in a real normed space are on the ray if and only if one of them is zero or
the unit vectors `‖x‖⁻¹ • x` and `‖y‖⁻¹ • y` are equal. -/
theorem sameRay_iff_inv_norm_smul_eq : SameRay ℝ x y ↔ x = 0 ∨ y = 0 ∨ ‖x‖⁻¹ • x = ‖y‖⁻¹ • y :=
  by
  rcases eq_or_ne x 0 with (rfl | hx); · simp [SameRay.zero_left]
  rcases eq_or_ne y 0 with (rfl | hy); · simp [SameRay.zero_right]
  simp only [sameRay_iff_inv_norm_smul_eq_of_ne hx hy, *, false_or_iff]
#align same_ray_iff_inv_norm_smul_eq sameRay_iff_inv_norm_smul_eq

#print sameRay_iff_of_norm_eq /-
/-- Two vectors of the same norm are on the same ray if and only if they are equal. -/
theorem sameRay_iff_of_norm_eq (h : ‖x‖ = ‖y‖) : SameRay ℝ x y ↔ x = y :=
  by
  obtain rfl | hy := eq_or_ne y 0
  · rw [norm_zero, norm_eq_zero] at h
    exact iff_of_true (SameRay.zero_right _) h
  · exact ⟨fun hxy => norm_injOn_ray_right hy hxy SameRay.rfl h, fun hxy => hxy ▸ SameRay.rfl⟩
#align same_ray_iff_of_norm_eq sameRay_iff_of_norm_eq
-/

#print not_sameRay_iff_of_norm_eq /-
theorem not_sameRay_iff_of_norm_eq (h : ‖x‖ = ‖y‖) : ¬SameRay ℝ x y ↔ x ≠ y :=
  (sameRay_iff_of_norm_eq h).Not
#align not_same_ray_iff_of_norm_eq not_sameRay_iff_of_norm_eq
-/

#print SameRay.eq_of_norm_eq /-
/-- If two points on the same ray have the same norm, then they are equal. -/
theorem SameRay.eq_of_norm_eq (h : SameRay ℝ x y) (hn : ‖x‖ = ‖y‖) : x = y :=
  (sameRay_iff_of_norm_eq hn).mp h
#align same_ray.eq_of_norm_eq SameRay.eq_of_norm_eq
-/

#print SameRay.norm_eq_iff /-
/-- The norms of two vectors on the same ray are equal if and only if they are equal. -/
theorem SameRay.norm_eq_iff (h : SameRay ℝ x y) : ‖x‖ = ‖y‖ ↔ x = y :=
  ⟨h.eq_of_norm_eq, fun h => h ▸ rfl⟩
#align same_ray.norm_eq_iff SameRay.norm_eq_iff
-/

