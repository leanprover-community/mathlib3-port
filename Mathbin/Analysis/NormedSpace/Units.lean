import Mathbin.Analysis.SpecificLimits

/-!
# The group of units of a complete normed ring

This file contains the basic theory for the group of units (invertible elements) of a complete
normed ring (Banach algebras being a notable special case).

## Main results

The constructions `one_sub`, `add` and `unit_of_nearby` state, in varying forms, that perturbations
of a unit are units.  The latter two are not stated in their optimal form; more precise versions
would use the spectral radius.

The first main result is `is_open`:  the group of units of a complete normed ring is an open subset
of the ring.

The function `inverse` (defined in `algebra.ring`), for a ring `R`, sends `a : R` to `a‚Åª¬π` if `a` is
a unit and 0 if not.  The other major results of this file (notably `inverse_add`,
`inverse_add_norm` and `inverse_add_norm_diff_nth_order`) cover the asymptotic properties of
`inverse (x + t)` as `t ‚Üí 0`.

-/


noncomputable theory

open_locale TopologicalSpace

variable{R : Type _}[NormedRing R][CompleteSpace R]

namespace Units

/-- In a complete normed ring, a perturbation of `1` by an element `t` of distance less than `1`
from `1` is a unit.  Here we construct its `units` structure.  -/
@[simps coe]
def one_sub (t : R) (h : ‚à•t‚à• < 1) : Units R :=
  { val := 1 - t, inv := ‚àë'n : ‚Ñï, t ^ n, val_inv := mul_neg_geom_series t h, inv_val := geom_series_mul_neg t h }

-- error in Analysis.NormedSpace.Units: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- In a complete normed ring, a perturbation of a unit `x` by an element `t` of distance less than
`‚à•x‚Åª¬π‚à•‚Åª¬π` from `x` is a unit.  Here we construct its `units` structure. -/
@[simps #[ident coe]]
def add
(x : units R)
(t : R)
(h : ¬´expr < ¬ª(¬´expr‚à• ‚à•¬ª(t), ¬´expr ‚Åª¬π¬ª(¬´expr‚à• ‚à•¬ª((¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x)) : R))))) : units R :=
units.copy ¬´expr * ¬ª(x, units.one_sub ¬´expr- ¬ª(¬´expr * ¬ª(¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x)), t)) (begin
    nontriviality [expr R] ["using", "[", expr zero_lt_one, "]"],
    have [ident hpos] [":", expr ¬´expr < ¬ª(0, ¬´expr‚à• ‚à•¬ª((¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x)) : R)))] [":=", expr units.norm_pos ¬´expr ‚Åª¬π¬ª(x)],
    calc
      ¬´expr = ¬ª(¬´expr‚à• ‚à•¬ª(¬´expr- ¬ª(¬´expr * ¬ª(¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x)), t))), ¬´expr‚à• ‚à•¬ª(¬´expr * ¬ª(¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x)), t))) : by { rw [expr norm_neg] [] }
      ¬´expr ‚â§ ¬ª(..., ¬´expr * ¬ª(¬´expr‚à• ‚à•¬ª((¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x)) : R)), ¬´expr‚à• ‚à•¬ª(t))) : norm_mul_le ¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x)) _
      ¬´expr < ¬ª(..., ¬´expr * ¬ª(¬´expr‚à• ‚à•¬ª((¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x)) : R)), ¬´expr ‚Åª¬π¬ª(¬´expr‚à• ‚à•¬ª((¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x)) : R))))) : by nlinarith [] ["only"] ["[", expr h, ",", expr hpos, "]"]
      ¬´expr = ¬ª(..., 1) : mul_inv_cancel (ne_of_gt hpos)
  end)) ¬´expr + ¬ª(x, t) (by simp [] [] [] ["[", expr mul_add, "]"] [] []) _ rfl

/-- In a complete normed ring, an element `y` of distance less than `‚à•x‚Åª¬π‚à•‚Åª¬π` from `x` is a unit.
Here we construct its `units` structure. -/
@[simps coe]
def unit_of_nearby (x : Units R) (y : R) (h : ‚à•y - x‚à• < ‚à•(¬´expr‚Üë ¬ª (x‚Åª¬π) : R)‚à•‚Åª¬π) : Units R :=
  Units.copy (x.add (y - x : R) h) y
    (by 
      simp )
    _ rfl

/-- The group of units of a complete normed ring is an open subset of the ring. -/
protected theorem IsOpen : IsOpen { x:R | IsUnit x } :=
  by 
    nontriviality R 
    apply metric.is_open_iff.mpr 
    rintro x' ‚ü®x, rfl‚ü©
    refine' ‚ü®‚à•(¬´expr‚Üë ¬ª (x‚Åª¬π) : R)‚à•‚Åª¬π, inv_pos.mpr (Units.norm_pos (x‚Åª¬π)), _‚ü©
    intro y hy 
    rw [Metric.mem_ball, dist_eq_norm] at hy 
    exact (x.unit_of_nearby y hy).IsUnit

protected theorem nhds (x : Units R) : { x:R | IsUnit x } ‚àà ùìù (x : R) :=
  IsOpen.mem_nhds Units.is_open x.is_unit

end Units

namespace NormedRing

open_locale Classical BigOperators

open Asymptotics Filter Metric Finset Ring‚Çì

theorem inverse_one_sub (t : R) (h : ‚à•t‚à• < 1) : inverse (1 - t) = ¬´expr‚Üë ¬ª (Units.oneSub t h‚Åª¬π) :=
  by 
    rw [‚Üêinverse_unit (Units.oneSub t h), Units.coe_one_sub]

-- error in Analysis.NormedSpace.Units: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The formula `inverse (x + t) = inverse (1 + x‚Åª¬π * t) * x‚Åª¬π` holds for `t` sufficiently small. -/
theorem inverse_add
(x : units R) : ¬´expr‚àÄ·∂† in , ¬ª((t), exprùìù() 0, ¬´expr = ¬ª(inverse ¬´expr + ¬ª((x : R), t), ¬´expr * ¬ª(inverse ¬´expr + ¬ª(1, ¬´expr * ¬ª(¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x)), t)), ¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x))))) :=
begin
  nontriviality [expr R] [],
  rw ["[", expr eventually_iff, ",", expr metric.mem_nhds_iff, "]"] [],
  have [ident hinv] [":", expr ¬´expr < ¬ª(0, ¬´expr ‚Åª¬π¬ª(¬´expr‚à• ‚à•¬ª((¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x)) : R))))] [],
  by cancel_denoms [],
  use ["[", expr ¬´expr ‚Åª¬π¬ª(¬´expr‚à• ‚à•¬ª((¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x)) : R))), ",", expr hinv, "]"],
  intros [ident t, ident ht],
  simp [] [] ["only"] ["[", expr mem_ball, ",", expr dist_zero_right, "]"] [] ["at", ident ht],
  have [ident ht'] [":", expr ¬´expr < ¬ª(¬´expr‚à• ‚à•¬ª(¬´expr * ¬ª(¬´expr- ¬ª(¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x))), t)), 1)] [],
  { refine [expr lt_of_le_of_lt (norm_mul_le _ _) _],
    rw [expr norm_neg] [],
    refine [expr lt_of_lt_of_le (mul_lt_mul_of_pos_left ht ¬´expr ‚Åª¬π¬ª(x).norm_pos) _],
    cancel_denoms [] },
  have [ident hright] [] [":=", expr inverse_one_sub ¬´expr * ¬ª(¬´expr- ¬ª(¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x))), t) ht'],
  have [ident hleft] [] [":=", expr inverse_unit (x.add t ht)],
  simp [] [] ["only"] ["[", "<-", expr neg_mul_eq_neg_mul, ",", expr sub_neg_eq_add, "]"] [] ["at", ident hright],
  simp [] [] ["only"] ["[", expr units.coe_add, "]"] [] ["at", ident hleft],
  simp [] [] [] ["[", expr hleft, ",", expr hright, ",", expr units.add, "]"] [] []
end

-- error in Analysis.NormedSpace.Units: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem inverse_one_sub_nth_order
(n : expr‚Ñï()) : ¬´expr‚àÄ·∂† in , ¬ª((t), exprùìù() 0, ¬´expr = ¬ª(inverse ¬´expr - ¬ª((1 : R), t), ¬´expr + ¬ª(¬´expr‚àë in , ¬ª((i), range n, ¬´expr ^ ¬ª(t, i)), ¬´expr * ¬ª(¬´expr ^ ¬ª(t, n), inverse ¬´expr - ¬ª(1, t))))) :=
begin
  simp [] [] ["only"] ["[", expr eventually_iff, ",", expr metric.mem_nhds_iff, "]"] [] [],
  use ["[", expr 1, ",", expr by norm_num [] [], "]"],
  intros [ident t, ident ht],
  simp [] [] ["only"] ["[", expr mem_ball, ",", expr dist_zero_right, "]"] [] ["at", ident ht],
  simp [] [] ["only"] ["[", expr inverse_one_sub t ht, ",", expr set.mem_set_of_eq, "]"] [] [],
  have [ident h] [":", expr ¬´expr = ¬ª(1, ¬´expr + ¬ª(¬´expr * ¬ª((range n).sum (Œª
       i, ¬´expr ^ ¬ª(t, i)), units.one_sub t ht), ¬´expr ^ ¬ª(t, n)))] [],
  { simp [] [] ["only"] ["[", expr units.coe_one_sub, "]"] [] [],
    rw ["[", "<-", expr geom_sum, ",", expr geom_sum_mul_neg, "]"] [],
    simp [] [] [] [] [] [] },
  rw ["[", "<-", expr one_mul ¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(units.one_sub t ht)), ",", expr h, ",", expr add_mul, "]"] [],
  congr,
  { rw ["[", expr mul_assoc, ",", expr (units.one_sub t ht).mul_inv, "]"] [],
    simp [] [] [] [] [] [] },
  { simp [] [] ["only"] ["[", expr units.coe_one_sub, "]"] [] [],
    rw ["[", "<-", expr add_mul, ",", "<-", expr geom_sum, ",", expr geom_sum_mul_neg, "]"] [],
    simp [] [] [] [] [] [] }
end

-- error in Analysis.NormedSpace.Units: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
/-- The formula
`inverse (x + t) = (‚àë i in range n, (- x‚Åª¬π * t) ^ i) * x‚Åª¬π + (- x‚Åª¬π * t) ^ n * inverse (x + t)`
holds for `t` sufficiently small. -/
theorem inverse_add_nth_order
(x : units R)
(n : expr‚Ñï()) : ¬´expr‚àÄ·∂† in , ¬ª((t), exprùìù() 0, ¬´expr = ¬ª(inverse ¬´expr + ¬ª((x : R), t), ¬´expr + ¬ª(¬´expr * ¬ª(¬´expr‚àë in , ¬ª((i), range n, ¬´expr ^ ¬ª(¬´expr * ¬ª(¬´expr- ¬ª(¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x))), t), i)), ¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x))), ¬´expr * ¬ª(¬´expr ^ ¬ª(¬´expr * ¬ª(¬´expr- ¬ª(¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x))), t), n), inverse ¬´expr + ¬ª(x, t))))) :=
begin
  refine [expr (inverse_add x).mp _],
  have [ident hzero] [":", expr tendsto (Œª
    t : R, ¬´expr * ¬ª(¬´expr- ¬ª(¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x))), t)) (exprùìù() 0) (exprùìù() 0)] [],
  { convert [] [expr ((mul_left_continuous ¬´expr- ¬ª((¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x)) : R))).tendsto 0).comp tendsto_id] [],
    simp [] [] [] [] [] [] },
  refine [expr (hzero.eventually (inverse_one_sub_nth_order n)).mp (eventually_of_forall _)],
  simp [] [] ["only"] ["[", expr neg_mul_eq_neg_mul_symm, ",", expr sub_neg_eq_add, "]"] [] [],
  intros [ident t, ident h1, ident h2],
  have [ident h] [] [":=", expr congr_arg (Œª a : R, ¬´expr * ¬ª(a, ¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x)))) h1],
  dsimp [] [] [] ["at", ident h],
  convert [] [expr h] [],
  rw ["[", expr add_mul, ",", expr mul_assoc, "]"] [],
  simp [] [] [] ["[", expr h2.symm, "]"] [] []
end

-- error in Analysis.NormedSpace.Units: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem inverse_one_sub_norm : is_O (Œª t, inverse ¬´expr - ¬ª((1 : R), t)) (Œª t, (1 : expr‚Ñù())) (exprùìù() (0 : R)) :=
begin
  simp [] [] ["only"] ["[", expr is_O, ",", expr is_O_with, ",", expr eventually_iff, ",", expr metric.mem_nhds_iff, "]"] [] [],
  refine [expr ‚ü®¬´expr + ¬ª(¬´expr‚à• ‚à•¬ª((1 : R)), 1), ¬´expr ‚Åª¬π¬ª((2 : expr‚Ñù())), by norm_num [] [], _‚ü©],
  intros [ident t, ident ht],
  simp [] [] ["only"] ["[", expr ball, ",", expr dist_zero_right, ",", expr set.mem_set_of_eq, "]"] [] ["at", ident ht],
  have [ident ht'] [":", expr ¬´expr < ¬ª(¬´expr‚à• ‚à•¬ª(t), 1)] [],
  { have [] [":", expr ¬´expr < ¬ª(¬´expr ‚Åª¬π¬ª((2 : expr‚Ñù())), 1)] [":=", expr by cancel_denoms []],
    linarith [] [] [] },
  simp [] [] ["only"] ["[", expr inverse_one_sub t ht', ",", expr norm_one, ",", expr mul_one, ",", expr set.mem_set_of_eq, "]"] [] [],
  change [expr ¬´expr ‚â§ ¬ª(¬´expr‚à• ‚à•¬ª(¬´expr‚àë' , ¬ª((n : expr‚Ñï()), ¬´expr ^ ¬ª(t, n))), _)] [] [],
  have [] [] [":=", expr normed_ring.tsum_geometric_of_norm_lt_1 t ht'],
  have [] [":", expr ¬´expr ‚â§ ¬ª(¬´expr ‚Åª¬π¬ª(¬´expr - ¬ª(1, ¬´expr‚à• ‚à•¬ª(t))), 2)] [],
  { rw ["<-", expr inv_inv‚ÇÄ (2 : expr‚Ñù())] [],
    refine [expr inv_le_inv_of_le (by norm_num [] []) _],
    have [] [":", expr ¬´expr = ¬ª(¬´expr + ¬ª(¬´expr ‚Åª¬π¬ª((2 : expr‚Ñù())), ¬´expr ‚Åª¬π¬ª((2 : expr‚Ñù()))), 1)] [":=", expr by ring []],
    linarith [] [] [] },
  linarith [] [] []
end

-- error in Analysis.NormedSpace.Units: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The function `Œª t, inverse (x + t)` is O(1) as `t ‚Üí 0`. -/
theorem inverse_add_norm
(x : units R) : is_O (Œª t, inverse ¬´expr + ¬ª(¬´expr‚Üë ¬ª(x), t)) (Œª t, (1 : expr‚Ñù())) (exprùìù() (0 : R)) :=
begin
  nontriviality [expr R] [],
  simp [] [] ["only"] ["[", expr is_O_iff, ",", expr norm_one, ",", expr mul_one, "]"] [] [],
  cases [expr is_O_iff.mp (@inverse_one_sub_norm R _ _)] ["with", ident C, ident hC],
  use [expr ¬´expr * ¬ª(C, ¬´expr‚à• ‚à•¬ª(((¬´expr ‚Åª¬π¬ª(x) : units R) : R)))],
  have [ident hzero] [":", expr tendsto (Œª
    t, ¬´expr * ¬ª(¬´expr- ¬ª((¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x)) : R)), t)) (exprùìù() 0) (exprùìù() 0)] [],
  { convert [] [expr ((mul_left_continuous (¬´expr- ¬ª(¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x))) : R)).tendsto 0).comp tendsto_id] [],
    simp [] [] [] [] [] [] },
  refine [expr (inverse_add x).mp ((hzero.eventually hC).mp (eventually_of_forall _))],
  intros [ident t, ident bound, ident iden],
  rw [expr iden] [],
  simp [] [] [] [] [] ["at", ident bound],
  have [ident hmul] [] [":=", expr norm_mul_le (inverse ¬´expr + ¬ª(1, ¬´expr * ¬ª(¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x)), t))) ¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x))],
  nlinarith [] [] ["[", expr norm_nonneg (¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x)) : R), "]"]
end

-- error in Analysis.NormedSpace.Units: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The function
`Œª t, inverse (x + t) - (‚àë i in range n, (- x‚Åª¬π * t) ^ i) * x‚Åª¬π`
is `O(t ^ n)` as `t ‚Üí 0`. -/
theorem inverse_add_norm_diff_nth_order
(x : units R)
(n : expr‚Ñï()) : is_O (Œª
 t : R, ¬´expr - ¬ª(inverse ¬´expr + ¬ª(¬´expr‚Üë ¬ª(x), t), ¬´expr * ¬ª(¬´expr‚àë in , ¬ª((i), range n, ¬´expr ^ ¬ª(¬´expr * ¬ª(¬´expr- ¬ª(¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x))), t), i)), ¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x))))) (Œª
 t, ¬´expr ^ ¬ª(¬´expr‚à• ‚à•¬ª(t), n)) (exprùìù() (0 : R)) :=
begin
  by_cases [expr h, ":", expr ¬´expr = ¬ª(n, 0)],
  { simpa [] [] [] ["[", expr h, "]"] [] ["using", expr inverse_add_norm x] },
  have [ident hn] [":", expr ¬´expr < ¬ª(0, n)] [":=", expr nat.pos_of_ne_zero h],
  simp [] [] [] ["[", expr is_O_iff, "]"] [] [],
  cases [expr is_O_iff.mp (inverse_add_norm x)] ["with", ident C, ident hC],
  use [expr ¬´expr * ¬ª(¬´expr * ¬ª(C, ¬´expr‚à• ‚à•¬ª((1 : expr‚Ñù()))), ¬´expr ^ ¬ª(¬´expr‚à• ‚à•¬ª((¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x)) : R)), n))],
  have [ident h] [":", expr eventually_eq (exprùìù() (0 : R)) (Œª
    t, ¬´expr - ¬ª(inverse ¬´expr + ¬ª(¬´expr‚Üë ¬ª(x), t), ¬´expr * ¬ª(¬´expr‚àë in , ¬ª((i), range n, ¬´expr ^ ¬ª(¬´expr * ¬ª(¬´expr- ¬ª(¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x))), t), i)), ¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x))))) (Œª
    t, ¬´expr * ¬ª(¬´expr ^ ¬ª(¬´expr * ¬ª(¬´expr- ¬ª(¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x))), t), n), inverse ¬´expr + ¬ª(x, t)))] [],
  { refine [expr (inverse_add_nth_order x n).mp (eventually_of_forall _)],
    intros [ident t, ident ht],
    convert [] [expr congr_arg (Œª
      a, ¬´expr - ¬ª(a, ¬´expr * ¬ª((range n).sum (pow ¬´expr * ¬ª(¬´expr- ¬ª(¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x))), t)), ¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x))))) ht] [],
    simp [] [] [] [] [] [] },
  refine [expr h.mp (hC.mp (eventually_of_forall _))],
  intros [ident t, "_", ident hLHS],
  simp [] [] ["only"] ["[", expr neg_mul_eq_neg_mul_symm, "]"] [] ["at", ident hLHS],
  rw [expr hLHS] [],
  refine [expr le_trans (norm_mul_le _ _) _],
  have [ident h'] [":", expr ¬´expr ‚â§ ¬ª(¬´expr‚à• ‚à•¬ª(¬´expr ^ ¬ª(¬´expr- ¬ª(¬´expr * ¬ª(¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x)), t)), n)), ¬´expr * ¬ª(¬´expr ^ ¬ª(¬´expr‚à• ‚à•¬ª((¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x)) : R)), n), ¬´expr ^ ¬ª(¬´expr‚à• ‚à•¬ª(t), n)))] [],
  { calc
      ¬´expr ‚â§ ¬ª(¬´expr‚à• ‚à•¬ª(¬´expr ^ ¬ª(¬´expr- ¬ª(¬´expr * ¬ª(¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x)), t)), n)), ¬´expr ^ ¬ª(¬´expr‚à• ‚à•¬ª(¬´expr- ¬ª(¬´expr * ¬ª(¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x)), t))), n)) : norm_pow_le' _ hn
      ¬´expr = ¬ª(..., ¬´expr ^ ¬ª(¬´expr‚à• ‚à•¬ª(¬´expr * ¬ª(¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x)), t)), n)) : by rw [expr norm_neg] []
      ¬´expr ‚â§ ¬ª(..., ¬´expr ^ ¬ª(¬´expr * ¬ª(¬´expr‚à• ‚à•¬ª((¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x)) : R)), ¬´expr‚à• ‚à•¬ª(t)), n)) : _
      ¬´expr = ¬ª(..., ¬´expr * ¬ª(¬´expr ^ ¬ª(¬´expr‚à• ‚à•¬ª((¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x)) : R)), n), ¬´expr ^ ¬ª(¬´expr‚à• ‚à•¬ª(t), n))) : mul_pow _ _ n,
    exact [expr pow_le_pow_of_le_left (norm_nonneg _) (norm_mul_le ¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x)) t) n] },
  have [ident h''] [":", expr ¬´expr ‚â§ ¬ª(0, ¬´expr * ¬ª(¬´expr ^ ¬ª(¬´expr‚à• ‚à•¬ª((¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x)) : R)), n), ¬´expr ^ ¬ª(¬´expr‚à• ‚à•¬ª(t), n)))] [],
  { refine [expr mul_nonneg _ _]; exact [expr pow_nonneg (norm_nonneg _) n] },
  nlinarith [] [] ["[", expr norm_nonneg (inverse ¬´expr + ¬ª(¬´expr‚Üë ¬ª(x), t)), "]"]
end

/-- The function `Œª t, inverse (x + t) - x‚Åª¬π` is `O(t)` as `t ‚Üí 0`. -/
theorem inverse_add_norm_diff_first_order (x : Units R) :
  is_O (fun t => inverse (¬´expr‚Üë ¬ª x+t) - ¬´expr‚Üë ¬ª (x‚Åª¬π)) (fun t => ‚à•t‚à•) (ùìù (0 : R)) :=
  by 
    convert inverse_add_norm_diff_nth_order x 1 <;> simp 

/-- The function
`Œª t, inverse (x + t) - x‚Åª¬π + x‚Åª¬π * t * x‚Åª¬π`
is `O(t ^ 2)` as `t ‚Üí 0`. -/
theorem inverse_add_norm_diff_second_order (x : Units R) :
  is_O (fun t => (inverse (¬´expr‚Üë ¬ª x+t) - ¬´expr‚Üë ¬ª (x‚Åª¬π))+(¬´expr‚Üë ¬ª (x‚Åª¬π)*t)*¬´expr‚Üë ¬ª (x‚Åª¬π)) (fun t => ‚à•t‚à• ^ 2)
    (ùìù (0 : R)) :=
  by 
    convert inverse_add_norm_diff_nth_order x 2 
    ext t 
    simp only [range_succ, range_one, sum_insert, mem_singleton, sum_singleton, not_false_iff, one_ne_zero, pow_zero‚Çì,
      add_mul‚Çì, pow_one‚Çì, one_mul‚Çì, neg_mul_eq_neg_mul_symm, sub_add_eq_sub_sub_swap, sub_neg_eq_add]

-- error in Analysis.NormedSpace.Units: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The function `inverse` is continuous at each unit of `R`. -/
theorem inverse_continuous_at (x : units R) : continuous_at inverse (x : R) :=
begin
  have [ident h_is_o] [":", expr is_o (Œª
    t : R, ¬´expr‚à• ‚à•¬ª(¬´expr - ¬ª(inverse ¬´expr + ¬ª(¬´expr‚Üë ¬ª(x), t), ¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x))))) (Œª
    t : R, (1 : expr‚Ñù())) (exprùìù() 0)] [],
  { refine [expr is_o_norm_left.mpr ((inverse_add_norm_diff_first_order x).trans_is_o _)],
    exact [expr is_o_norm_left.mpr (is_o_id_const one_ne_zero)] },
  have [ident h_lim] [":", expr tendsto (Œª y : R, ¬´expr - ¬ª(y, x)) (exprùìù() x) (exprùìù() 0)] [],
  { refine [expr tendsto_zero_iff_norm_tendsto_zero.mpr _],
    exact [expr tendsto_iff_norm_tendsto_zero.mp tendsto_id] },
  simp [] [] ["only"] ["[", expr continuous_at, "]"] [] [],
  rw ["[", expr tendsto_iff_norm_tendsto_zero, ",", expr inverse_unit, "]"] [],
  convert [] [expr h_is_o.tendsto_0.comp h_lim] [],
  ext [] [] [],
  simp [] [] [] [] [] []
end

end NormedRing

namespace Units

open MulOpposite Filter NormedRing

-- error in Analysis.NormedSpace.Units: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- In a normed ring, the coercion from `units R` (equipped with the induced topology from the
embedding in `R √ó R`) to `R` is an open map. -/ theorem is_open_map_coe : is_open_map (coe : units R ‚Üí R) :=
begin
  rw [expr is_open_map_iff_nhds_le] [],
  intros [ident x, ident s],
  rw ["[", expr mem_map, ",", expr mem_nhds_induced, "]"] [],
  rintros ["‚ü®", ident t, ",", ident ht, ",", ident hts, "‚ü©"],
  obtain ["‚ü®", ident u, ",", ident hu, ",", ident v, ",", ident hv, ",", ident huvt, "‚ü©", ":", expr ¬´expr‚àÉ , ¬ª((u : set R), ¬´expr ‚àß ¬ª(¬´expr ‚àà ¬ª(u, exprùìù() ¬´expr‚Üë ¬ª(x)), ¬´expr‚àÉ , ¬ª((v : set ¬´expr ·µê·µí·µñ¬ª(R)), ¬´expr ‚àß ¬ª(¬´expr ‚àà ¬ª(v, exprùìù() (op ¬´expr‚Üë ¬ª(¬´expr ‚Åª¬π¬ª(x)))), ¬´expr ‚äÜ ¬ª(u.prod v, t)))))],
  { simpa [] [] [] ["[", expr embed_product, ",", expr mem_nhds_prod_iff, "]"] [] ["using", expr ht] },
  have [] [":", expr ¬´expr ‚àà ¬ª(¬´expr ‚à© ¬ª(¬´expr ‚à© ¬ª(u, ¬´expr ‚Åª¬π' ¬ª(¬´expr ‚àò ¬ª(op, ring.inverse), v)), set.range (coe : units R ‚Üí R)), exprùìù() ¬´expr‚Üë ¬ª(x))] [],
  { refine [expr inter_mem (inter_mem hu _) (units.nhds x)],
    refine [expr (continuous_op.continuous_at.comp (inverse_continuous_at x)).preimage_mem_nhds _],
    simpa [] [] [] [] [] ["using", expr hv] },
  refine [expr mem_of_superset this _],
  rintros ["_", "‚ü®", "‚ü®", ident huy, ",", ident hvy, "‚ü©", ",", "‚ü®", ident y, ",", ident rfl, "‚ü©", "‚ü©"],
  have [] [":", expr ¬´expr ‚àà ¬ª(embed_product R y, u.prod v)] [":=", expr ‚ü®huy, by simpa [] [] [] [] [] ["using", expr hvy]‚ü©],
  simpa [] [] [] [] [] ["using", expr hts (huvt this)]
end

/-- In a normed ring, the coercion from `units R` (equipped with the induced topology from the
embedding in `R √ó R`) to `R` is an open embedding. -/
theorem open_embedding_coe : OpenEmbedding (coe‚Çì : Units R ‚Üí R) :=
  open_embedding_of_continuous_injective_open continuous_coe ext is_open_map_coe

end Units

