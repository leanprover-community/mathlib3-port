/-
Copyright (c) 2020 S√©bastien Gou√´zel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: S√©bastien Gou√´zel, Jireh Loreaux

! This file was ported from Lean 3 source module analysis.normed_space.pi_Lp
! leanprover-community/mathlib commit 0b7c740e25651db0ba63648fbae9f9d6f941e31b
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Analysis.MeanInequalities
import Mathbin.Data.Fintype.Order
import Mathbin.LinearAlgebra.Matrix.Basis

/-!
# `L^p` distance on finite products of metric spaces

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.
Given finitely many metric spaces, one can put the max distance on their product, but there is also
a whole family of natural distances, indexed by a parameter `p : ‚Ñù‚â•0‚àû`, that also induce
the product topology. We define them in this file. For `0 < p < ‚àû`, the distance on `Œ† i, Œ± i`
is given by
$$
d(x, y) = \left(\sum d(x_i, y_i)^p\right)^{1/p}.
$$,
whereas for `p = 0` it is the cardinality of the set ${ i | x_i ‚â† y_i}$. For `p = ‚àû` the distance
is the supremum of the distances.

We give instances of this construction for emetric spaces, metric spaces, normed groups and normed
spaces.

To avoid conflicting instances, all these are defined on a copy of the original Œ†-type, named
`pi_Lp p Œ±`. The assumpion `[fact (1 ‚â§ p)]` is required for the metric and normed space instances.

We ensure that the topology, bornology and uniform structure on `pi_Lp p Œ±` are (defeq to) the
product topology, product bornology and product uniformity, to be able to use freely continuity
statements for the coordinate functions, for instance.

## Implementation notes

We only deal with the `L^p` distance on a product of finitely many metric spaces, which may be
distinct. A closely related construction is `lp`, the `L^p` norm on a product of (possibly
infinitely many) normed spaces, where the norm is
$$
\left(\sum ‚Äñf (x)‚Äñ^p \right)^{1/p}.
$$
However, the topology induced by this construction is not the product topology, and some functions
have infinite `L^p` norm. These subtleties are not present in the case of finitely many metric
spaces, hence it is worth devoting a file to this specific case which is particularly well behaved.

Another related construction is `measure_theory.Lp`, the `L^p` norm on the space of functions from
a measure space to a normed space, where the norm is
$$
\left(\int ‚Äñf (x)‚Äñ^p dŒº\right)^{1/p}.
$$
This has all the same subtleties as `lp`, and the further subtlety that this only
defines a seminorm (as almost everywhere zero functions have zero `L^p` norm).
The construction `pi_Lp` corresponds to the special case of `measure_theory.Lp` in which the basis
is a finite space equipped with the counting measure.

To prove that the topology (and the uniform structure) on a finite product with the `L^p` distance
are the same as those coming from the `L^‚àû` distance, we could argue that the `L^p` and `L^‚àû` norms
are equivalent on `‚Ñù^n` for abstract (norm equivalence) reasons. Instead, we give a more explicit
(easy) proof which provides a comparison between these two norms with explicit constants.

We also set up the theory for `pseudo_emetric_space` and `pseudo_metric_space`.
-/


open Real Set Filter IsROrC Bornology

open BigOperators uniformity Topology NNReal ENNReal

noncomputable section

#print PiLp /-
/-- A copy of a Pi type, on which we will put the `L^p` distance. Since the Pi type itself is
already endowed with the `L^‚àû` distance, we need the type synonym to avoid confusing typeclass
resolution. Also, we let it depend on `p`, to get a whole family of type on which we can put
different distances. -/
@[nolint unused_arguments]
def PiLp (p : ‚Ñù‚â•0‚àû) {Œπ : Type _} (Œ± : Œπ ‚Üí Type _) : Type _ :=
  ‚àÄ i : Œπ, Œ± i
#align pi_Lp PiLp
-/

instance (p : ‚Ñù‚â•0‚àû) {Œπ : Type _} (Œ± : Œπ ‚Üí Type _) [‚àÄ i, Inhabited (Œ± i)] : Inhabited (PiLp p Œ±) :=
  ‚ü®fun i => default‚ü©

namespace PiLp

variable (p : ‚Ñù‚â•0‚àû) (ùïú ùïú' : Type _) {Œπ : Type _} (Œ± : Œπ ‚Üí Type _) (Œ≤ : Œπ ‚Üí Type _)

#print PiLp.equiv /-
/-- Canonical bijection between `pi_Lp p Œ±` and the original Pi type. We introduce it to be able
to compare the `L^p` and `L^‚àû` distances through it. -/
protected def equiv : PiLp p Œ± ‚âÉ ‚àÄ i : Œπ, Œ± i :=
  Equiv.refl _
#align pi_Lp.equiv PiLp.equiv
-/

/-! Note that the unapplied versions of these lemmas are deliberately omitted, as they break
the use of the type synonym. -/


/- warning: pi_Lp.equiv_apply -> PiLp.equiv_apply is a dubious translation:
lean 3 declaration is
  forall (p : ENNReal) {Œπ : Type.{u1}} (Œ± : Œπ -> Type.{u2}) (x : PiLp.{u1, u2} p Œπ Œ±) (i : Œπ), Eq.{succ u2} (Œ± i) (coeFn.{max 1 (max (succ (max u1 u2)) (succ u1) (succ u2)) (max (succ u1) (succ u2)) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u1) (succ u2)} (Equiv.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ±) (forall (i : Œπ), Œ± i)) (fun (_x : Equiv.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ±) (forall (i : Œπ), Œ± i)) => (PiLp.{u1, u2} p Œπ Œ±) -> (forall (i : Œπ), Œ± i)) (Equiv.hasCoeToFun.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ±) (forall (i : Œπ), Œ± i)) (PiLp.equiv.{u1, u2} p Œπ Œ±) x i) (x i)
but is expected to have type
  forall (p : ENNReal) {Œπ : Type.{u2}} (Œ± : Œπ -> Type.{u1}) (x : PiLp.{u2, u1} p Œπ Œ±) (i : Œπ), Eq.{succ u1} (Œ± i) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ±) (forall (i : Œπ), Œ± i)) (PiLp.{u2, u1} p Œπ Œ±) (fun (_x : PiLp.{u2, u1} p Œπ Œ±) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : PiLp.{u2, u1} p Œπ Œ±) => forall (i : Œπ), Œ± i) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ±) (forall (i : Œπ), Œ± i)) (PiLp.equiv.{u2, u1} p Œπ Œ±) x i) (x i)
Case conversion may be inaccurate. Consider using '#align pi_Lp.equiv_apply PiLp.equiv_apply‚Çì'. -/
@[simp]
theorem equiv_apply (x : PiLp p Œ±) (i : Œπ) : PiLp.equiv p Œ± x i = x i :=
  rfl
#align pi_Lp.equiv_apply PiLp.equiv_apply

#print PiLp.equiv_symm_apply /-
@[simp]
theorem equiv_symm_apply (x : ‚àÄ i, Œ± i) (i : Œπ) : (PiLp.equiv p Œ±).symm x i = x i :=
  rfl
#align pi_Lp.equiv_symm_apply PiLp.equiv_symm_apply
-/

section DistNorm

variable [Fintype Œπ]

/-!
### Definition of `edist`, `dist` and `norm` on `pi_Lp`

In this section we define the `edist`, `dist` and `norm` functions on `pi_Lp p Œ±` without assuming
`[fact (1 ‚â§ p)]` or metric properties of the spaces `Œ± i`. This allows us to provide the rewrite
lemmas for each of three cases `p = 0`, `p = ‚àû` and `0 < p.to_real`.
-/


section Edist

variable [‚àÄ i, EDist (Œ≤ i)]

/-- Endowing the space `pi_Lp p Œ≤` with the `L^p` edistance. We register this instance
separate from `pi_Lp.pseudo_emetric` since the latter requires the type class hypothesis
`[fact (1 ‚â§ p)]` in order to prove the triangle inequality.

Registering this separately allows for a future emetric-like structure on `pi_Lp p Œ≤` for `p < 1`
satisfying a relaxed triangle inequality. The terminology for this varies throughout the
literature, but it is sometimes called a *quasi-metric* or *semi-metric*. -/
instance : EDist (PiLp p Œ≤)
    where edist f g :=
    if hp : p = 0 then { i | f i ‚â† g i }.toFinite.toFinset.card
    else
      if p = ‚àû then ‚®Ü i, edist (f i) (g i) else (‚àë i, edist (f i) (g i) ^ p.toReal) ^ (1 / p.toReal)

variable {Œ≤}

/- warning: pi_Lp.edist_eq_card -> PiLp.edist_eq_card is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {Œ≤ : Œπ -> Type.{u2}} [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : forall (i : Œπ), EDist.{u2} (Œ≤ i)] (f : PiLp.{u1, u2} (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))) Œπ Œ≤) (g : PiLp.{u1, u2} (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))) Œπ Œ≤), Eq.{1} ENNReal (EDist.edist.{max u1 u2} (PiLp.{u1, u2} (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))) Œπ Œ≤) (PiLp.hasEdist.{u1, u2} (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))) Œπ Œ≤ _inst_1 (fun (i : Œπ) => _inst_2 i)) f g) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat ENNReal (HasLiftT.mk.{1, 1} Nat ENNReal (CoeTC‚Çì.coe.{1, 1} Nat ENNReal (Nat.castCoe.{0} ENNReal (AddMonoidWithOne.toNatCast.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) (Finset.card.{u1} Œπ (Set.Finite.toFinset.{u1} Œπ (setOf.{u1} Œπ (fun (i : Œπ) => Ne.{succ u2} (Œ≤ i) (f i) (g i))) (Set.toFinite.{u1} Œπ (setOf.{u1} Œπ (fun (i : Œπ) => Ne.{succ u2} (Œ≤ i) (f i) (g i))) (Subtype.finite.{succ u1} Œπ (Finite.of_fintype.{u1} Œπ _inst_1) (fun (x : Œπ) => Membership.Mem.{u1, u1} Œπ (Set.{u1} Œπ) (Set.hasMem.{u1} Œπ) x (setOf.{u1} Œπ (fun (i : Œπ) => Ne.{succ u2} (Œ≤ i) (f i) (g i)))))))))
but is expected to have type
  forall {Œπ : Type.{u2}} {Œ≤ : Œπ -> Type.{u1}} [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : forall (i : Œπ), EDist.{u1} (Œ≤ i)] (f : PiLp.{u2, u1} (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)) Œπ Œ≤) (g : PiLp.{u2, u1} (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)) Œπ Œ≤), Eq.{1} ENNReal (EDist.edist.{max u2 u1} (PiLp.{u2, u1} (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)) Œπ Œ≤) (PiLp.instEDistPiLp.{u2, u1} (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)) Œπ Œ≤ _inst_1 (fun (i : Œπ) => _inst_2 i)) f g) (Nat.cast.{0} ENNReal (CanonicallyOrderedCommSemiring.toNatCast.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (Finset.card.{u2} Œπ (Set.Finite.toFinset.{u2} Œπ (setOf.{u2} Œπ (fun (i : Œπ) => Ne.{succ u1} (Œ≤ i) (f i) (g i))) (Set.toFinite.{u2} Œπ (setOf.{u2} Œπ (fun (i : Œπ) => Ne.{succ u1} (Œ≤ i) (f i) (g i))) (Subtype.finite.{succ u2} Œπ (Finite.of_fintype.{u2} Œπ _inst_1) (fun (x : Œπ) => Membership.mem.{u2, u2} Œπ (Set.{u2} Œπ) (Set.instMembershipSet.{u2} Œπ) x (setOf.{u2} Œπ (fun (i : Œπ) => Ne.{succ u1} (Œ≤ i) (f i) (g i)))))))))
Case conversion may be inaccurate. Consider using '#align pi_Lp.edist_eq_card PiLp.edist_eq_card‚Çì'. -/
theorem edist_eq_card (f g : PiLp 0 Œ≤) : edist f g = { i | f i ‚â† g i }.toFinite.toFinset.card :=
  if_pos rfl
#align pi_Lp.edist_eq_card PiLp.edist_eq_card

/- warning: pi_Lp.edist_eq_sum -> PiLp.edist_eq_sum is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {Œ≤ : Œπ -> Type.{u2}} [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : forall (i : Œπ), EDist.{u2} (Œ≤ i)] {p : ENNReal}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) (ENNReal.toReal p)) -> (forall (f : PiLp.{u1, u2} p Œπ Œ≤) (g : PiLp.{u1, u2} p Œπ Œ≤), Eq.{1} ENNReal (EDist.edist.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.hasEdist.{u1, u2} p Œπ Œ≤ _inst_1 (fun (i : Œπ) => _inst_2 i)) f g) (HPow.hPow.{0, 0, 0} ENNReal Real ENNReal (instHPow.{0, 0} ENNReal Real ENNReal.Real.hasPow) (Finset.sum.{0, u1} ENNReal Œπ (OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) (Finset.univ.{u1} Œπ _inst_1) (fun (i : Œπ) => HPow.hPow.{0, 0, 0} ENNReal Real ENNReal (instHPow.{0, 0} ENNReal Real ENNReal.Real.hasPow) (EDist.edist.{u2} (Œ≤ i) (_inst_2 i) (f i) (g i)) (ENNReal.toReal p))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (ENNReal.toReal p))))
but is expected to have type
  forall {Œπ : Type.{u2}} {Œ≤ : Œπ -> Type.{u1}} [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : forall (i : Œπ), EDist.{u1} (Œ≤ i)] {p : ENNReal}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) (ENNReal.toReal p)) -> (forall (f : PiLp.{u2, u1} p Œπ Œ≤) (g : PiLp.{u2, u1} p Œπ Œ≤), Eq.{1} ENNReal (EDist.edist.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (PiLp.instEDistPiLp.{u2, u1} p Œπ Œ≤ _inst_1 (fun (i : Œπ) => _inst_2 i)) f g) (HPow.hPow.{0, 0, 0} ENNReal Real ENNReal (instHPow.{0, 0} ENNReal Real ENNReal.instPowENNRealReal) (Finset.sum.{0, u2} ENNReal Œπ (LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal)) (Finset.univ.{u2} Œπ _inst_1) (fun (i : Œπ) => HPow.hPow.{0, 0, 0} ENNReal Real ENNReal (instHPow.{0, 0} ENNReal Real ENNReal.instPowENNRealReal) (EDist.edist.{u1} (Œ≤ i) (_inst_2 i) (f i) (g i)) (ENNReal.toReal p))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (ENNReal.toReal p))))
Case conversion may be inaccurate. Consider using '#align pi_Lp.edist_eq_sum PiLp.edist_eq_sum‚Çì'. -/
theorem edist_eq_sum {p : ‚Ñù‚â•0‚àû} (hp : 0 < p.toReal) (f g : PiLp p Œ≤) :
    edist f g = (‚àë i, edist (f i) (g i) ^ p.toReal) ^ (1 / p.toReal) :=
  let hp' := ENNReal.toReal_pos_iff.mp hp
  (if_neg hp'.1.ne').trans (if_neg hp'.2.Ne)
#align pi_Lp.edist_eq_sum PiLp.edist_eq_sum

/- warning: pi_Lp.edist_eq_supr -> PiLp.edist_eq_iSup is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {Œ≤ : Œπ -> Type.{u2}} [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : forall (i : Œπ), EDist.{u2} (Œ≤ i)] (f : PiLp.{u1, u2} (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Œπ Œ≤) (g : PiLp.{u1, u2} (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Œπ Œ≤), Eq.{1} ENNReal (EDist.edist.{max u1 u2} (PiLp.{u1, u2} (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Œπ Œ≤) (PiLp.hasEdist.{u1, u2} (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Œπ Œ≤ _inst_1 (fun (i : Œπ) => _inst_2 i)) f g) (iSup.{0, succ u1} ENNReal (ConditionallyCompleteLattice.toHasSup.{0} ENNReal (CompleteLattice.toConditionallyCompleteLattice.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Œπ (fun (i : Œπ) => EDist.edist.{u2} (Œ≤ i) (_inst_2 i) (f i) (g i)))
but is expected to have type
  forall {Œπ : Type.{u2}} {Œ≤ : Œπ -> Type.{u1}} [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : forall (i : Œπ), EDist.{u1} (Œ≤ i)] (f : PiLp.{u2, u1} (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))) Œπ Œ≤) (g : PiLp.{u2, u1} (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))) Œπ Œ≤), Eq.{1} ENNReal (EDist.edist.{max u2 u1} (PiLp.{u2, u1} (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))) Œπ Œ≤) (PiLp.instEDistPiLp.{u2, u1} (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))) Œπ Œ≤ _inst_1 (fun (i : Œπ) => _inst_2 i)) f g) (iSup.{0, succ u2} ENNReal (ConditionallyCompleteLattice.toSupSet.{0} ENNReal (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{0} ENNReal (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{0} ENNReal (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) Œπ (fun (i : Œπ) => EDist.edist.{u1} (Œ≤ i) (_inst_2 i) (f i) (g i)))
Case conversion may be inaccurate. Consider using '#align pi_Lp.edist_eq_supr PiLp.edist_eq_iSup‚Çì'. -/
theorem edist_eq_iSup (f g : PiLp ‚àû Œ≤) : edist f g = ‚®Ü i, edist (f i) (g i) := by dsimp [edist];
  exact if_neg ENNReal.top_ne_zero
#align pi_Lp.edist_eq_supr PiLp.edist_eq_iSup

end Edist

section EdistProp

variable {Œ≤} [‚àÄ i, PseudoEMetricSpace (Œ≤ i)]

/- warning: pi_Lp.edist_self -> PiLp.edist_self is a dubious translation:
lean 3 declaration is
  forall (p : ENNReal) {Œπ : Type.{u1}} {Œ≤ : Œπ -> Type.{u2}} [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : forall (i : Œπ), PseudoEMetricSpace.{u2} (Œ≤ i)] (f : PiLp.{u1, u2} p Œπ Œ≤), Eq.{1} ENNReal (EDist.edist.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.hasEdist.{u1, u2} p Œπ Œ≤ _inst_1 (fun (i : Œπ) => PseudoEMetricSpace.toHasEdist.{u2} (Œ≤ i) (_inst_2 i))) f f) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))
but is expected to have type
  forall (p : ENNReal) {Œπ : Type.{u2}} {Œ≤ : Œπ -> Type.{u1}} [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : forall (i : Œπ), PseudoEMetricSpace.{u1} (Œ≤ i)] (f : PiLp.{u2, u1} p Œπ Œ≤), Eq.{1} ENNReal (EDist.edist.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (PiLp.instEDistPiLp.{u2, u1} p Œπ Œ≤ _inst_1 (fun (i : Œπ) => PseudoEMetricSpace.toEDist.{u1} (Œ≤ i) (_inst_2 i))) f f) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))
Case conversion may be inaccurate. Consider using '#align pi_Lp.edist_self PiLp.edist_self‚Çì'. -/
/-- This holds independent of `p` and does not require `[fact (1 ‚â§ p)]`. We keep it separate
from `pi_Lp.pseudo_emetric_space` so it can be used also for `p < 1`. -/
protected theorem edist_self (f : PiLp p Œ≤) : edist f f = 0 :=
  by
  rcases p.trichotomy with (rfl | rfl | h)
  ¬∑ simp [edist_eq_card]
  ¬∑ simp [edist_eq_supr]
  ¬∑ simp [edist_eq_sum h, ENNReal.zero_rpow_of_pos h, ENNReal.zero_rpow_of_pos (inv_pos.2 <| h)]
#align pi_Lp.edist_self PiLp.edist_self

/- warning: pi_Lp.edist_comm -> PiLp.edist_comm is a dubious translation:
lean 3 declaration is
  forall (p : ENNReal) {Œπ : Type.{u1}} {Œ≤ : Œπ -> Type.{u2}} [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : forall (i : Œπ), PseudoEMetricSpace.{u2} (Œ≤ i)] (f : PiLp.{u1, u2} p Œπ Œ≤) (g : PiLp.{u1, u2} p Œπ Œ≤), Eq.{1} ENNReal (EDist.edist.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.hasEdist.{u1, u2} p Œπ Œ≤ _inst_1 (fun (i : Œπ) => PseudoEMetricSpace.toHasEdist.{u2} (Œ≤ i) (_inst_2 i))) f g) (EDist.edist.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.hasEdist.{u1, u2} p Œπ Œ≤ _inst_1 (fun (i : Œπ) => PseudoEMetricSpace.toHasEdist.{u2} (Œ≤ i) (_inst_2 i))) g f)
but is expected to have type
  forall (p : ENNReal) {Œπ : Type.{u2}} {Œ≤ : Œπ -> Type.{u1}} [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : forall (i : Œπ), PseudoEMetricSpace.{u1} (Œ≤ i)] (f : PiLp.{u2, u1} p Œπ Œ≤) (g : PiLp.{u2, u1} p Œπ Œ≤), Eq.{1} ENNReal (EDist.edist.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (PiLp.instEDistPiLp.{u2, u1} p Œπ Œ≤ _inst_1 (fun (i : Œπ) => PseudoEMetricSpace.toEDist.{u1} (Œ≤ i) (_inst_2 i))) f g) (EDist.edist.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (PiLp.instEDistPiLp.{u2, u1} p Œπ Œ≤ _inst_1 (fun (i : Œπ) => PseudoEMetricSpace.toEDist.{u1} (Œ≤ i) (_inst_2 i))) g f)
Case conversion may be inaccurate. Consider using '#align pi_Lp.edist_comm PiLp.edist_comm‚Çì'. -/
/-- This holds independent of `p` and does not require `[fact (1 ‚â§ p)]`. We keep it separate
from `pi_Lp.pseudo_emetric_space` so it can be used also for `p < 1`. -/
protected theorem edist_comm (f g : PiLp p Œ≤) : edist f g = edist g f :=
  by
  rcases p.trichotomy with (rfl | rfl | h)
  ¬∑ simp only [edist_eq_card, eq_comm, Ne.def]
  ¬∑ simp only [edist_eq_supr, edist_comm]
  ¬∑ simp only [edist_eq_sum h, edist_comm]
#align pi_Lp.edist_comm PiLp.edist_comm

end EdistProp

section Dist

variable [‚àÄ i, Dist (Œ± i)]

/-- Endowing the space `pi_Lp p Œ≤` with the `L^p` distance. We register this instance
separate from `pi_Lp.pseudo_metric` since the latter requires the type class hypothesis
`[fact (1 ‚â§ p)]` in order to prove the triangle inequality.

Registering this separately allows for a future metric-like structure on `pi_Lp p Œ≤` for `p < 1`
satisfying a relaxed triangle inequality. The terminology for this varies throughout the
literature, but it is sometimes called a *quasi-metric* or *semi-metric*. -/
instance : Dist (PiLp p Œ±)
    where dist f g :=
    if hp : p = 0 then { i | f i ‚â† g i }.toFinite.toFinset.card
    else
      if p = ‚àû then ‚®Ü i, dist (f i) (g i) else (‚àë i, dist (f i) (g i) ^ p.toReal) ^ (1 / p.toReal)

variable {Œ±}

/- warning: pi_Lp.dist_eq_card -> PiLp.dist_eq_card is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {Œ± : Œπ -> Type.{u2}} [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : forall (i : Œπ), Dist.{u2} (Œ± i)] (f : PiLp.{u1, u2} (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))) Œπ Œ±) (g : PiLp.{u1, u2} (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))) Œπ Œ±), Eq.{1} Real (Dist.dist.{max u1 u2} (PiLp.{u1, u2} (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))) Œπ Œ±) (PiLp.hasDist.{u1, u2} (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))) Œπ Œ± _inst_1 (fun (i : Œπ) => _inst_2 i)) f g) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTC‚Çì.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) (Finset.card.{u1} Œπ (Set.Finite.toFinset.{u1} Œπ (setOf.{u1} Œπ (fun (i : Œπ) => Ne.{succ u2} (Œ± i) (f i) (g i))) (Set.toFinite.{u1} Œπ (setOf.{u1} Œπ (fun (i : Œπ) => Ne.{succ u2} (Œ± i) (f i) (g i))) (Subtype.finite.{succ u1} Œπ (Finite.of_fintype.{u1} Œπ _inst_1) (fun (x : Œπ) => Membership.Mem.{u1, u1} Œπ (Set.{u1} Œπ) (Set.hasMem.{u1} Œπ) x (setOf.{u1} Œπ (fun (i : Œπ) => Ne.{succ u2} (Œ± i) (f i) (g i)))))))))
but is expected to have type
  forall {Œπ : Type.{u2}} {Œ± : Œπ -> Type.{u1}} [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : forall (i : Œπ), Dist.{u1} (Œ± i)] (f : PiLp.{u2, u1} (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)) Œπ Œ±) (g : PiLp.{u2, u1} (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)) Œπ Œ±), Eq.{1} Real (Dist.dist.{max u2 u1} (PiLp.{u2, u1} (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)) Œπ Œ±) (PiLp.instDistPiLp.{u2, u1} (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)) Œπ Œ± _inst_1 (fun (i : Œπ) => _inst_2 i)) f g) (Nat.cast.{0} Real Real.natCast (Finset.card.{u2} Œπ (Set.Finite.toFinset.{u2} Œπ (setOf.{u2} Œπ (fun (i : Œπ) => Ne.{succ u1} (Œ± i) (f i) (g i))) (Set.toFinite.{u2} Œπ (setOf.{u2} Œπ (fun (i : Œπ) => Ne.{succ u1} (Œ± i) (f i) (g i))) (Subtype.finite.{succ u2} Œπ (Finite.of_fintype.{u2} Œπ _inst_1) (fun (x : Œπ) => Membership.mem.{u2, u2} Œπ (Set.{u2} Œπ) (Set.instMembershipSet.{u2} Œπ) x (setOf.{u2} Œπ (fun (i : Œπ) => Ne.{succ u1} (Œ± i) (f i) (g i)))))))))
Case conversion may be inaccurate. Consider using '#align pi_Lp.dist_eq_card PiLp.dist_eq_card‚Çì'. -/
theorem dist_eq_card (f g : PiLp 0 Œ±) : dist f g = { i | f i ‚â† g i }.toFinite.toFinset.card :=
  if_pos rfl
#align pi_Lp.dist_eq_card PiLp.dist_eq_card

/- warning: pi_Lp.dist_eq_sum -> PiLp.dist_eq_sum is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {Œ± : Œπ -> Type.{u2}} [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : forall (i : Œπ), Dist.{u2} (Œ± i)] {p : ENNReal}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) (ENNReal.toReal p)) -> (forall (f : PiLp.{u1, u2} p Œπ Œ±) (g : PiLp.{u1, u2} p Œπ Œ±), Eq.{1} Real (Dist.dist.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ±) (PiLp.hasDist.{u1, u2} p Œπ Œ± _inst_1 (fun (i : Œπ) => _inst_2 i)) f g) (HPow.hPow.{0, 0, 0} Real Real Real (instHPow.{0, 0} Real Real Real.hasPow) (Finset.sum.{0, u1} Real Œπ Real.addCommMonoid (Finset.univ.{u1} Œπ _inst_1) (fun (i : Œπ) => HPow.hPow.{0, 0, 0} Real Real Real (instHPow.{0, 0} Real Real Real.hasPow) (Dist.dist.{u2} (Œ± i) (_inst_2 i) (f i) (g i)) (ENNReal.toReal p))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (ENNReal.toReal p))))
but is expected to have type
  forall {Œπ : Type.{u2}} {Œ± : Œπ -> Type.{u1}} [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : forall (i : Œπ), Dist.{u1} (Œ± i)] {p : ENNReal}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) (ENNReal.toReal p)) -> (forall (f : PiLp.{u2, u1} p Œπ Œ±) (g : PiLp.{u2, u1} p Œπ Œ±), Eq.{1} Real (Dist.dist.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ±) (PiLp.instDistPiLp.{u2, u1} p Œπ Œ± _inst_1 (fun (i : Œπ) => _inst_2 i)) f g) (HPow.hPow.{0, 0, 0} Real Real Real (instHPow.{0, 0} Real Real Real.instPowReal) (Finset.sum.{0, u2} Real Œπ Real.instAddCommMonoidReal (Finset.univ.{u2} Œπ _inst_1) (fun (i : Œπ) => HPow.hPow.{0, 0, 0} Real Real Real (instHPow.{0, 0} Real Real Real.instPowReal) (Dist.dist.{u1} (Œ± i) (_inst_2 i) (f i) (g i)) (ENNReal.toReal p))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (ENNReal.toReal p))))
Case conversion may be inaccurate. Consider using '#align pi_Lp.dist_eq_sum PiLp.dist_eq_sum‚Çì'. -/
theorem dist_eq_sum {p : ‚Ñù‚â•0‚àû} (hp : 0 < p.toReal) (f g : PiLp p Œ±) :
    dist f g = (‚àë i, dist (f i) (g i) ^ p.toReal) ^ (1 / p.toReal) :=
  let hp' := ENNReal.toReal_pos_iff.mp hp
  (if_neg hp'.1.ne').trans (if_neg hp'.2.Ne)
#align pi_Lp.dist_eq_sum PiLp.dist_eq_sum

/- warning: pi_Lp.dist_eq_csupr -> PiLp.dist_eq_iSup is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {Œ± : Œπ -> Type.{u2}} [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : forall (i : Œπ), Dist.{u2} (Œ± i)] (f : PiLp.{u1, u2} (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Œπ Œ±) (g : PiLp.{u1, u2} (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Œπ Œ±), Eq.{1} Real (Dist.dist.{max u1 u2} (PiLp.{u1, u2} (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Œπ Œ±) (PiLp.hasDist.{u1, u2} (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Œπ Œ± _inst_1 (fun (i : Œπ) => _inst_2 i)) f g) (iSup.{0, succ u1} Real Real.hasSup Œπ (fun (i : Œπ) => Dist.dist.{u2} (Œ± i) (_inst_2 i) (f i) (g i)))
but is expected to have type
  forall {Œπ : Type.{u2}} {Œ± : Œπ -> Type.{u1}} [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : forall (i : Œπ), Dist.{u1} (Œ± i)] (f : PiLp.{u2, u1} (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))) Œπ Œ±) (g : PiLp.{u2, u1} (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))) Œπ Œ±), Eq.{1} Real (Dist.dist.{max u2 u1} (PiLp.{u2, u1} (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))) Œπ Œ±) (PiLp.instDistPiLp.{u2, u1} (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))) Œπ Œ± _inst_1 (fun (i : Œπ) => _inst_2 i)) f g) (iSup.{0, succ u2} Real Real.instSupSetReal Œπ (fun (i : Œπ) => Dist.dist.{u1} (Œ± i) (_inst_2 i) (f i) (g i)))
Case conversion may be inaccurate. Consider using '#align pi_Lp.dist_eq_csupr PiLp.dist_eq_iSup‚Çì'. -/
theorem dist_eq_iSup (f g : PiLp ‚àû Œ±) : dist f g = ‚®Ü i, dist (f i) (g i) := by dsimp [dist];
  exact if_neg ENNReal.top_ne_zero
#align pi_Lp.dist_eq_csupr PiLp.dist_eq_iSup

end Dist

section Norm

variable [‚àÄ i, Norm (Œ≤ i)] [‚àÄ i, Zero (Œ≤ i)]

#print PiLp.hasNorm /-
/-- Endowing the space `pi_Lp p Œ≤` with the `L^p` norm. We register this instance
separate from `pi_Lp.seminormed_add_comm_group` since the latter requires the type class hypothesis
`[fact (1 ‚â§ p)]` in order to prove the triangle inequality.

Registering this separately allows for a future norm-like structure on `pi_Lp p Œ≤` for `p < 1`
satisfying a relaxed triangle inequality. These are called *quasi-norms*. -/
instance hasNorm : Norm (PiLp p Œ≤)
    where norm f :=
    if hp : p = 0 then { i | f i ‚â† 0 }.toFinite.toFinset.card
    else if p = ‚àû then ‚®Ü i, ‚Äñf i‚Äñ else (‚àë i, ‚Äñf i‚Äñ ^ p.toReal) ^ (1 / p.toReal)
#align pi_Lp.has_norm PiLp.hasNorm
-/

variable {p Œ≤}

/- warning: pi_Lp.norm_eq_card -> PiLp.norm_eq_card is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {Œ≤ : Œπ -> Type.{u2}} [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : forall (i : Œπ), Norm.{u2} (Œ≤ i)] [_inst_3 : forall (i : Œπ), Zero.{u2} (Œ≤ i)] (f : PiLp.{u1, u2} (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))) Œπ Œ≤), Eq.{1} Real (Norm.norm.{max u1 u2} (PiLp.{u1, u2} (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))) Œπ Œ≤) (PiLp.hasNorm.{u1, u2} (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))) Œπ Œ≤ _inst_1 (fun (i : Œπ) => _inst_2 i) (fun (i : Œπ) => _inst_3 i)) f) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTC‚Çì.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) (Finset.card.{u1} Œπ (Set.Finite.toFinset.{u1} Œπ (setOf.{u1} Œπ (fun (i : Œπ) => Ne.{succ u2} (Œ≤ i) (f i) (OfNat.ofNat.{u2} (Œ≤ i) 0 (OfNat.mk.{u2} (Œ≤ i) 0 (Zero.zero.{u2} (Œ≤ i) (_inst_3 i)))))) (Set.toFinite.{u1} Œπ (setOf.{u1} Œπ (fun (i : Œπ) => Ne.{succ u2} (Œ≤ i) (f i) (OfNat.ofNat.{u2} (Œ≤ i) 0 (OfNat.mk.{u2} (Œ≤ i) 0 (Zero.zero.{u2} (Œ≤ i) (_inst_3 i)))))) (Subtype.finite.{succ u1} Œπ (Finite.of_fintype.{u1} Œπ _inst_1) (fun (x : Œπ) => Membership.Mem.{u1, u1} Œπ (Set.{u1} Œπ) (Set.hasMem.{u1} Œπ) x (setOf.{u1} Œπ (fun (i : Œπ) => Ne.{succ u2} (Œ≤ i) (f i) (OfNat.ofNat.{u2} (Œ≤ i) 0 (OfNat.mk.{u2} (Œ≤ i) 0 (Zero.zero.{u2} (Œ≤ i) (_inst_3 i))))))))))))
but is expected to have type
  forall {Œπ : Type.{u2}} {Œ≤ : Œπ -> Type.{u1}} [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : forall (i : Œπ), Norm.{u1} (Œ≤ i)] [_inst_3 : forall (i : Œπ), Zero.{u1} (Œ≤ i)] (f : PiLp.{u2, u1} (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)) Œπ Œ≤), Eq.{1} Real (Norm.norm.{max u2 u1} (PiLp.{u2, u1} (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)) Œπ Œ≤) (PiLp.hasNorm.{u2, u1} (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)) Œπ Œ≤ _inst_1 (fun (i : Œπ) => _inst_2 i) (fun (i : Œπ) => _inst_3 i)) f) (Nat.cast.{0} Real Real.natCast (Finset.card.{u2} Œπ (Set.Finite.toFinset.{u2} Œπ (setOf.{u2} Œπ (fun (i : Œπ) => Ne.{succ u1} (Œ≤ i) (f i) (OfNat.ofNat.{u1} (Œ≤ i) 0 (Zero.toOfNat0.{u1} (Œ≤ i) (_inst_3 i))))) (Set.toFinite.{u2} Œπ (setOf.{u2} Œπ (fun (i : Œπ) => Ne.{succ u1} (Œ≤ i) (f i) (OfNat.ofNat.{u1} (Œ≤ i) 0 (Zero.toOfNat0.{u1} (Œ≤ i) (_inst_3 i))))) (Subtype.finite.{succ u2} Œπ (Finite.of_fintype.{u2} Œπ _inst_1) (fun (x : Œπ) => Membership.mem.{u2, u2} Œπ (Set.{u2} Œπ) (Set.instMembershipSet.{u2} Œπ) x (setOf.{u2} Œπ (fun (i : Œπ) => Ne.{succ u1} (Œ≤ i) (f i) (OfNat.ofNat.{u1} (Œ≤ i) 0 (Zero.toOfNat0.{u1} (Œ≤ i) (_inst_3 i)))))))))))
Case conversion may be inaccurate. Consider using '#align pi_Lp.norm_eq_card PiLp.norm_eq_card‚Çì'. -/
theorem norm_eq_card (f : PiLp 0 Œ≤) : ‚Äñf‚Äñ = { i | f i ‚â† 0 }.toFinite.toFinset.card :=
  if_pos rfl
#align pi_Lp.norm_eq_card PiLp.norm_eq_card

/- warning: pi_Lp.norm_eq_csupr -> PiLp.norm_eq_ciSup is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {Œ≤ : Œπ -> Type.{u2}} [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : forall (i : Œπ), Norm.{u2} (Œ≤ i)] [_inst_3 : forall (i : Œπ), Zero.{u2} (Œ≤ i)] (f : PiLp.{u1, u2} (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Œπ Œ≤), Eq.{1} Real (Norm.norm.{max u1 u2} (PiLp.{u1, u2} (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Œπ Œ≤) (PiLp.hasNorm.{u1, u2} (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Œπ Œ≤ _inst_1 (fun (i : Œπ) => _inst_2 i) (fun (i : Œπ) => _inst_3 i)) f) (iSup.{0, succ u1} Real Real.hasSup Œπ (fun (i : Œπ) => Norm.norm.{u2} (Œ≤ i) (_inst_2 i) (f i)))
but is expected to have type
  forall {Œπ : Type.{u2}} {Œ≤ : Œπ -> Type.{u1}} [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : forall (i : Œπ), Norm.{u1} (Œ≤ i)] [_inst_3 : forall (i : Œπ), Zero.{u1} (Œ≤ i)] (f : PiLp.{u2, u1} (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))) Œπ Œ≤), Eq.{1} Real (Norm.norm.{max u2 u1} (PiLp.{u2, u1} (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))) Œπ Œ≤) (PiLp.hasNorm.{u2, u1} (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))) Œπ Œ≤ _inst_1 (fun (i : Œπ) => _inst_2 i) (fun (i : Œπ) => _inst_3 i)) f) (iSup.{0, succ u2} Real Real.instSupSetReal Œπ (fun (i : Œπ) => Norm.norm.{u1} (Œ≤ i) (_inst_2 i) (f i)))
Case conversion may be inaccurate. Consider using '#align pi_Lp.norm_eq_csupr PiLp.norm_eq_ciSup‚Çì'. -/
theorem norm_eq_ciSup (f : PiLp ‚àû Œ≤) : ‚Äñf‚Äñ = ‚®Ü i, ‚Äñf i‚Äñ := by dsimp [norm];
  exact if_neg ENNReal.top_ne_zero
#align pi_Lp.norm_eq_csupr PiLp.norm_eq_ciSup

/- warning: pi_Lp.norm_eq_sum -> PiLp.norm_eq_sum is a dubious translation:
lean 3 declaration is
  forall {p : ENNReal} {Œπ : Type.{u1}} {Œ≤ : Œπ -> Type.{u2}} [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : forall (i : Œπ), Norm.{u2} (Œ≤ i)] [_inst_3 : forall (i : Œπ), Zero.{u2} (Œ≤ i)], (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) (ENNReal.toReal p)) -> (forall (f : PiLp.{u1, u2} p Œπ Œ≤), Eq.{1} Real (Norm.norm.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.hasNorm.{u1, u2} p Œπ Œ≤ _inst_1 (fun (i : Œπ) => _inst_2 i) (fun (i : Œπ) => _inst_3 i)) f) (HPow.hPow.{0, 0, 0} Real Real Real (instHPow.{0, 0} Real Real Real.hasPow) (Finset.sum.{0, u1} Real Œπ Real.addCommMonoid (Finset.univ.{u1} Œπ _inst_1) (fun (i : Œπ) => HPow.hPow.{0, 0, 0} Real Real Real (instHPow.{0, 0} Real Real Real.hasPow) (Norm.norm.{u2} (Œ≤ i) (_inst_2 i) (f i)) (ENNReal.toReal p))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (ENNReal.toReal p))))
but is expected to have type
  forall {p : ENNReal} {Œπ : Type.{u2}} {Œ≤ : Œπ -> Type.{u1}} [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : forall (i : Œπ), Norm.{u1} (Œ≤ i)] [_inst_3 : forall (i : Œπ), Zero.{u1} (Œ≤ i)], (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) (ENNReal.toReal p)) -> (forall (f : PiLp.{u2, u1} p Œπ Œ≤), Eq.{1} Real (Norm.norm.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (PiLp.hasNorm.{u2, u1} p Œπ Œ≤ _inst_1 (fun (i : Œπ) => _inst_2 i) (fun (i : Œπ) => _inst_3 i)) f) (HPow.hPow.{0, 0, 0} Real Real Real (instHPow.{0, 0} Real Real Real.instPowReal) (Finset.sum.{0, u2} Real Œπ Real.instAddCommMonoidReal (Finset.univ.{u2} Œπ _inst_1) (fun (i : Œπ) => HPow.hPow.{0, 0, 0} Real Real Real (instHPow.{0, 0} Real Real Real.instPowReal) (Norm.norm.{u1} (Œ≤ i) (_inst_2 i) (f i)) (ENNReal.toReal p))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (ENNReal.toReal p))))
Case conversion may be inaccurate. Consider using '#align pi_Lp.norm_eq_sum PiLp.norm_eq_sum‚Çì'. -/
theorem norm_eq_sum (hp : 0 < p.toReal) (f : PiLp p Œ≤) :
    ‚Äñf‚Äñ = (‚àë i, ‚Äñf i‚Äñ ^ p.toReal) ^ (1 / p.toReal) :=
  let hp' := ENNReal.toReal_pos_iff.mp hp
  (if_neg hp'.1.ne').trans (if_neg hp'.2.Ne)
#align pi_Lp.norm_eq_sum PiLp.norm_eq_sum

end Norm

end DistNorm

section Aux

/-!
### The uniformity on finite `L^p` products is the product uniformity

In this section, we put the `L^p` edistance on `pi_Lp p Œ±`, and we check that the uniformity
coming from this edistance coincides with the product uniformity, by showing that the canonical
map to the Pi type (with the `L^‚àû` distance) is a uniform embedding, as it is both Lipschitz and
antiLipschitz.

We only register this emetric space structure as a temporary instance, as the true instance (to be
registered later) will have as uniformity exactly the product uniformity, instead of the one coming
from the edistance (which is equal to it, but not defeq). See Note [forgetful inheritance]
explaining why having definitionally the right uniformity is often important.
-/


variable [Fact (1 ‚â§ p)] [‚àÄ i, PseudoMetricSpace (Œ± i)] [‚àÄ i, PseudoEMetricSpace (Œ≤ i)]

variable [Fintype Œπ]

/- warning: pi_Lp.pseudo_emetric_aux -> PiLp.pseudoEmetricAux is a dubious translation:
lean 3 declaration is
  forall (p : ENNReal) {Œπ : Type.{u1}} (Œ≤ : Œπ -> Type.{u2}) [_inst_1 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] [_inst_3 : forall (i : Œπ), PseudoEMetricSpace.{u2} (Œ≤ i)] [_inst_4 : Fintype.{u1} Œπ], PseudoEMetricSpace.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤)
but is expected to have type
  forall (p : ENNReal) {Œπ : Type.{u1}} (Œ≤ : Œπ -> Type.{u2}) [_inst_1 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] [_inst_3 : forall (i : Œπ), PseudoEMetricSpace.{u2} (Œ≤ i)] [_inst_4 : Fintype.{u1} Œπ], PseudoEMetricSpace.{max u2 u1} (PiLp.{u1, u2} p Œπ Œ≤)
Case conversion may be inaccurate. Consider using '#align pi_Lp.pseudo_emetric_aux PiLp.pseudoEmetricAux‚Çì'. -/
/-- Endowing the space `pi_Lp p Œ≤` with the `L^p` pseudoemetric structure. This definition is not
satisfactory, as it does not register the fact that the topology and the uniform structure coincide
with the product one. Therefore, we do not register it as an instance. Using this as a temporary
pseudoemetric space instance, we will show that the uniform structure is equal (but not defeq) to
the product one, and then register an instance in which we replace the uniform structure by the
product one using this pseudoemetric space and `pseudo_emetric_space.replace_uniformity`. -/
def pseudoEmetricAux : PseudoEMetricSpace (PiLp p Œ≤)
    where
  edist_self := PiLp.edist_self p
  edist_comm := PiLp.edist_comm p
  edist_triangle f g h := by
    rcases p.dichotomy with (rfl | hp)
    ¬∑ simp only [edist_eq_supr]
      cases isEmpty_or_nonempty Œπ
      ¬∑ simp only [ciSup_of_empty, ENNReal.bot_eq_zero, add_zero, nonpos_iff_eq_zero]
      exact
        iSup_le fun i => (edist_triangle _ (g i) _).trans <| add_le_add (le_iSup _ i) (le_iSup _ i)
    ¬∑ simp only [edist_eq_sum (zero_lt_one.trans_le hp)]
      calc
        (‚àë i, edist (f i) (h i) ^ p.to_real) ^ (1 / p.to_real) ‚â§
            (‚àë i, (edist (f i) (g i) + edist (g i) (h i)) ^ p.to_real) ^ (1 / p.to_real) :=
          by
          apply ENNReal.rpow_le_rpow _ (one_div_nonneg.2 <| zero_le_one.trans hp)
          refine' Finset.sum_le_sum fun i hi => _
          exact ENNReal.rpow_le_rpow (edist_triangle _ _ _) (zero_le_one.trans hp)
        _ ‚â§
            (‚àë i, edist (f i) (g i) ^ p.to_real) ^ (1 / p.to_real) +
              (‚àë i, edist (g i) (h i) ^ p.to_real) ^ (1 / p.to_real) :=
          ENNReal.Lp_add_le _ _ _ hp
        
#align pi_Lp.pseudo_emetric_aux PiLp.pseudoEmetricAux

attribute [local instance] PiLp.pseudoEmetricAux

/- warning: pi_Lp.supr_edist_ne_top_aux -> PiLp.iSup_edist_ne_top_aux is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} [_inst_5 : Finite.{succ u1} Œπ] {Œ± : Œπ -> Type.{u2}} [_inst_6 : forall (i : Œπ), PseudoMetricSpace.{u2} (Œ± i)] (f : PiLp.{u1, u2} (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Œπ Œ±) (g : PiLp.{u1, u2} (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Œπ Œ±), Ne.{1} ENNReal (iSup.{0, succ u1} ENNReal (ConditionallyCompleteLattice.toHasSup.{0} ENNReal (CompleteLattice.toConditionallyCompleteLattice.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Œπ (fun (i : Œπ) => EDist.edist.{u2} (Œ± i) (PseudoMetricSpace.toEDist.{u2} (Œ± i) (_inst_6 i)) (f i) (g i))) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))
but is expected to have type
  forall {Œπ : Type.{u2}} [_inst_5 : Finite.{succ u2} Œπ] {Œ± : Œπ -> Type.{u1}} [_inst_6 : forall (i : Œπ), PseudoMetricSpace.{u1} (Œ± i)] (f : PiLp.{u2, u1} (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))) Œπ Œ±) (g : PiLp.{u2, u1} (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))) Œπ Œ±), Ne.{1} ENNReal (iSup.{0, succ u2} ENNReal (ConditionallyCompleteLattice.toSupSet.{0} ENNReal (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{0} ENNReal (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{0} ENNReal (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) Œπ (fun (i : Œπ) => EDist.edist.{u1} (Œ± i) (PseudoEMetricSpace.toEDist.{u1} (Œ± i) (PseudoMetricSpace.toPseudoEMetricSpace.{u1} (Œ± i) (_inst_6 i))) (f i) (g i))) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))
Case conversion may be inaccurate. Consider using '#align pi_Lp.supr_edist_ne_top_aux PiLp.iSup_edist_ne_top_aux‚Çì'. -/
/-- An auxiliary lemma used twice in the proof of `pi_Lp.pseudo_metric_aux` below. Not intended for
use outside this file. -/
theorem iSup_edist_ne_top_aux {Œπ : Type _} [Finite Œπ] {Œ± : Œπ ‚Üí Type _}
    [‚àÄ i, PseudoMetricSpace (Œ± i)] (f g : PiLp ‚àû Œ±) : (‚®Ü i, edist (f i) (g i)) ‚â† ‚ä§ :=
  by
  cases nonempty_fintype Œπ
  obtain ‚ü®M, hM‚ü© := Fintype.exists_le fun i => (‚ü®dist (f i) (g i), dist_nonneg‚ü© : ‚Ñù‚â•0)
  refine' ne_of_lt ((iSup_le fun i => _).trans_lt (@ENNReal.coe_lt_top M))
  simp only [edist, PseudoMetricSpace.edist_dist, ENNReal.ofReal_eq_coe_nnreal dist_nonneg]
  exact_mod_cast hM i
#align pi_Lp.supr_edist_ne_top_aux PiLp.iSup_edist_ne_top_aux

/- warning: pi_Lp.pseudo_metric_aux -> PiLp.pseudoMetricAux is a dubious translation:
lean 3 declaration is
  forall (p : ENNReal) {Œπ : Type.{u1}} (Œ± : Œπ -> Type.{u2}) [_inst_1 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] [_inst_2 : forall (i : Œπ), PseudoMetricSpace.{u2} (Œ± i)] [_inst_4 : Fintype.{u1} Œπ], PseudoMetricSpace.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ±)
but is expected to have type
  forall (p : ENNReal) {Œπ : Type.{u1}} (Œ± : Œπ -> Type.{u2}) [_inst_1 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] [_inst_2 : forall (i : Œπ), PseudoMetricSpace.{u2} (Œ± i)] [_inst_4 : Fintype.{u1} Œπ], PseudoMetricSpace.{max u2 u1} (PiLp.{u1, u2} p Œπ Œ±)
Case conversion may be inaccurate. Consider using '#align pi_Lp.pseudo_metric_aux PiLp.pseudoMetricAux‚Çì'. -/
/-- Endowing the space `pi_Lp p Œ±` with the `L^p` pseudometric structure. This definition is not
satisfactory, as it does not register the fact that the topology, the uniform structure, and the
bornology coincide with the product ones. Therefore, we do not register it as an instance. Using
this as a temporary pseudoemetric space instance, we will show that the uniform structure is equal
(but not defeq) to the product one, and then register an instance in which we replace the uniform
structure and the bornology by the product ones using this pseudometric space,
`pseudo_metric_space.replace_uniformity`, and `pseudo_metric_space.replace_bornology`.

See note [reducible non-instances] -/
@[reducible]
def pseudoMetricAux : PseudoMetricSpace (PiLp p Œ±) :=
  PseudoEMetricSpace.toPseudoMetricSpaceOfDist dist
    (fun f g => by
      rcases p.dichotomy with (rfl | h)
      ¬∑ exact supr_edist_ne_top_aux f g
      ¬∑ rw [edist_eq_sum (zero_lt_one.trans_le h)]
        exact
          ENNReal.rpow_ne_top_of_nonneg (one_div_nonneg.2 (zero_le_one.trans h))
            (ne_of_lt <|
              ENNReal.sum_lt_top fun i hi =>
                ENNReal.rpow_ne_top_of_nonneg (zero_le_one.trans h) (edist_ne_top _ _)))
    fun f g => by
    rcases p.dichotomy with (rfl | h)
    ¬∑ rw [edist_eq_supr, dist_eq_csupr]
      ¬∑ cases isEmpty_or_nonempty Œπ
        ¬∑ simp only [Real.ciSup_empty, ciSup_of_empty, ENNReal.bot_eq_zero, ENNReal.zero_toReal]
        ¬∑ refine' le_antisymm (ciSup_le fun i => _) _
          ¬∑ rw [‚Üê ENNReal.ofReal_le_iff_le_toReal (supr_edist_ne_top_aux f g), ‚Üê
              PseudoMetricSpace.edist_dist]
            exact le_iSup _ i
          ¬∑ refine' ENNReal.toReal_le_of_le_ofReal (Real.sSup_nonneg _ _) (iSup_le fun i => _)
            ¬∑ rintro - ‚ü®i, rfl‚ü©
              exact dist_nonneg
            ¬∑ unfold edist; rw [PseudoMetricSpace.edist_dist]
              exact ENNReal.ofReal_le_ofReal (le_ciSup (Fintype.bddAbove_range _) i)
    ¬∑ have A : ‚àÄ i, edist (f i) (g i) ^ p.to_real ‚â† ‚ä§ := fun i =>
        ENNReal.rpow_ne_top_of_nonneg (zero_le_one.trans h) (edist_ne_top _ _)
      simp only [edist_eq_sum (zero_lt_one.trans_le h), dist_edist, ENNReal.toReal_rpow,
        dist_eq_sum (zero_lt_one.trans_le h), ‚Üê ENNReal.toReal_sum fun i _ => A i]
#align pi_Lp.pseudo_metric_aux PiLp.pseudoMetricAux

attribute [local instance] PiLp.pseudoMetricAux

/- warning: pi_Lp.lipschitz_with_equiv_aux -> PiLp.lipschitzWith_equiv_aux is a dubious translation:
lean 3 declaration is
  forall (p : ENNReal) {Œπ : Type.{u1}} (Œ≤ : Œπ -> Type.{u2}) [_inst_1 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] [_inst_3 : forall (i : Œπ), PseudoEMetricSpace.{u2} (Œ≤ i)] [_inst_4 : Fintype.{u1} Œπ], LipschitzWith.{max u1 u2, max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.pseudoEmetricAux.{u1, u2} p Œπ Œ≤ _inst_1 (fun (b : Œπ) => _inst_3 b) _inst_4) (pseudoEMetricSpacePi.{u1, u2} Œπ (fun (i : Œπ) => Œ≤ i) _inst_4 (fun (b : Œπ) => _inst_3 b)) (OfNat.ofNat.{0} NNReal 1 (OfNat.mk.{0} NNReal 1 (One.one.{0} NNReal (AddMonoidWithOne.toOne.{0} NNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} NNReal (NonAssocSemiring.toAddCommMonoidWithOne.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))))) (coeFn.{max 1 (max (succ (max u1 u2)) (succ u1) (succ u2)) (max (succ u1) (succ u2)) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u1) (succ u2)} (Equiv.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (fun (_x : Equiv.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) => (PiLp.{u1, u2} p Œπ Œ≤) -> (forall (i : Œπ), Œ≤ i)) (Equiv.hasCoeToFun.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.equiv.{u1, u2} p Œπ Œ≤))
but is expected to have type
  forall (p : ENNReal) {Œπ : Type.{u2}} (Œ≤ : Œπ -> Type.{u1}) [_inst_1 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] [_inst_3 : forall (i : Œπ), PseudoEMetricSpace.{u1} (Œ≤ i)] [_inst_4 : Fintype.{u2} Œπ], LipschitzWith.{max u2 u1, max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.pseudoEmetricAux.{u2, u1} p Œπ Œ≤ _inst_1 (fun (b : Œπ) => _inst_3 b) _inst_4) (pseudoEMetricSpacePi.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) _inst_4 (fun (b : Œπ) => _inst_3 b)) (OfNat.ofNat.{0} NNReal 1 (One.toOfNat1.{0} NNReal instNNRealOne)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.{u2, u1} p Œπ Œ≤) (fun (_x : PiLp.{u2, u1} p Œπ Œ≤) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : PiLp.{u2, u1} p Œπ Œ≤) => forall (i : Œπ), Œ≤ i) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.equiv.{u2, u1} p Œπ Œ≤))
Case conversion may be inaccurate. Consider using '#align pi_Lp.lipschitz_with_equiv_aux PiLp.lipschitzWith_equiv_aux‚Çì'. -/
theorem lipschitzWith_equiv_aux : LipschitzWith 1 (PiLp.equiv p Œ≤) :=
  by
  intro x y
  rcases p.dichotomy with (rfl | h)
  ¬∑
    simpa only [ENNReal.coe_one, one_mul, edist_eq_supr, edist, Finset.sup_le_iff, Finset.mem_univ,
      forall_true_left] using le_iSup fun i => edist (x i) (y i)
  ¬∑ have cancel : p.to_real * (1 / p.to_real) = 1 := mul_div_cancel' 1 (zero_lt_one.trans_le h).ne'
    rw [edist_eq_sum (zero_lt_one.trans_le h)]
    simp only [edist, forall_prop_of_true, one_mul, Finset.mem_univ, Finset.sup_le_iff,
      ENNReal.coe_one]
    intro i
    calc
      edist (x i) (y i) = (edist (x i) (y i) ^ p.to_real) ^ (1 / p.to_real) := by
        simp [‚Üê ENNReal.rpow_mul, cancel, -one_div]
      _ ‚â§ (‚àë i, edist (x i) (y i) ^ p.to_real) ^ (1 / p.to_real) :=
        by
        apply ENNReal.rpow_le_rpow _ (one_div_nonneg.2 <| zero_le_one.trans h)
        exact Finset.single_le_sum (fun i hi => (bot_le : (0 : ‚Ñù‚â•0‚àû) ‚â§ _)) (Finset.mem_univ i)
      
#align pi_Lp.lipschitz_with_equiv_aux PiLp.lipschitzWith_equiv_aux

/- warning: pi_Lp.antilipschitz_with_equiv_aux -> PiLp.antilipschitzWith_equiv_aux is a dubious translation:
lean 3 declaration is
  forall (p : ENNReal) {Œπ : Type.{u1}} (Œ≤ : Œπ -> Type.{u2}) [_inst_1 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] [_inst_3 : forall (i : Œπ), PseudoEMetricSpace.{u2} (Œ≤ i)] [_inst_4 : Fintype.{u1} Œπ], AntilipschitzWith.{max u1 u2, max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.pseudoEmetricAux.{u1, u2} p Œπ Œ≤ _inst_1 (fun (b : Œπ) => _inst_3 b) _inst_4) (pseudoEMetricSpacePi.{u1, u2} Œπ (fun (i : Œπ) => Œ≤ i) _inst_4 (fun (b : Œπ) => _inst_3 b)) (HPow.hPow.{0, 0, 0} NNReal Real NNReal (instHPow.{0, 0} NNReal Real NNReal.Real.hasPow) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat NNReal (HasLiftT.mk.{1, 1} Nat NNReal (CoeTC‚Çì.coe.{1, 1} Nat NNReal (Nat.castCoe.{0} NNReal (AddMonoidWithOne.toNatCast.{0} NNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} NNReal (NonAssocSemiring.toAddCommMonoidWithOne.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))))) (Fintype.card.{u1} Œπ _inst_4)) (ENNReal.toReal (HDiv.hDiv.{0, 0, 0} ENNReal ENNReal ENNReal (instHDiv.{0} ENNReal (DivInvMonoid.toHasDiv.{0} ENNReal ENNReal.divInvMonoid)) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p))) (coeFn.{max 1 (max (succ (max u1 u2)) (succ u1) (succ u2)) (max (succ u1) (succ u2)) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u1) (succ u2)} (Equiv.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (fun (_x : Equiv.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) => (PiLp.{u1, u2} p Œπ Œ≤) -> (forall (i : Œπ), Œ≤ i)) (Equiv.hasCoeToFun.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.equiv.{u1, u2} p Œπ Œ≤))
but is expected to have type
  forall (p : ENNReal) {Œπ : Type.{u2}} (Œ≤ : Œπ -> Type.{u1}) [_inst_1 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] [_inst_3 : forall (i : Œπ), PseudoEMetricSpace.{u1} (Œ≤ i)] [_inst_4 : Fintype.{u2} Œπ], AntilipschitzWith.{max u2 u1, max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.pseudoEmetricAux.{u2, u1} p Œπ Œ≤ _inst_1 (fun (b : Œπ) => _inst_3 b) _inst_4) (pseudoEMetricSpacePi.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) _inst_4 (fun (b : Œπ) => _inst_3 b)) (HPow.hPow.{0, 0, 0} NNReal Real NNReal (instHPow.{0, 0} NNReal Real NNReal.instPowNNRealReal) (Nat.cast.{0} NNReal (CanonicallyOrderedCommSemiring.toNatCast.{0} NNReal instNNRealCanonicallyOrderedCommSemiring) (Fintype.card.{u2} Œπ _inst_4)) (ENNReal.toReal (HDiv.hDiv.{0, 0, 0} ENNReal ENNReal ENNReal (instHDiv.{0} ENNReal (DivInvMonoid.toDiv.{0} ENNReal ENNReal.instDivInvMonoidENNReal)) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p))) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.{u2, u1} p Œπ Œ≤) (fun (_x : PiLp.{u2, u1} p Œπ Œ≤) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : PiLp.{u2, u1} p Œπ Œ≤) => forall (i : Œπ), Œ≤ i) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.equiv.{u2, u1} p Œπ Œ≤))
Case conversion may be inaccurate. Consider using '#align pi_Lp.antilipschitz_with_equiv_aux PiLp.antilipschitzWith_equiv_aux‚Çì'. -/
theorem antilipschitzWith_equiv_aux :
    AntilipschitzWith ((Fintype.card Œπ : ‚Ñù‚â•0) ^ (1 / p).toReal) (PiLp.equiv p Œ≤) :=
  by
  intro x y
  rcases p.dichotomy with (rfl | h)
  ¬∑ simp only [edist_eq_supr, ENNReal.div_top, ENNReal.zero_toReal, NNReal.rpow_zero,
      ENNReal.coe_one, one_mul, iSup_le_iff]
    exact fun i => Finset.le_sup (Finset.mem_univ i)
  ¬∑ have pos : 0 < p.to_real := zero_lt_one.trans_le h
    have nonneg : 0 ‚â§ 1 / p.to_real := one_div_nonneg.2 (le_of_lt Pos)
    have cancel : p.to_real * (1 / p.to_real) = 1 := mul_div_cancel' 1 (ne_of_gt Pos)
    rw [edist_eq_sum Pos, ENNReal.toReal_div 1 p]
    simp only [edist, ‚Üê one_div, ENNReal.one_toReal]
    calc
      (‚àë i, edist (x i) (y i) ^ p.to_real) ^ (1 / p.to_real) ‚â§
          (‚àë i, edist (PiLp.equiv p Œ≤ x) (PiLp.equiv p Œ≤ y) ^ p.to_real) ^ (1 / p.to_real) :=
        by
        apply ENNReal.rpow_le_rpow _ nonneg
        apply Finset.sum_le_sum fun i hi => _
        apply ENNReal.rpow_le_rpow _ (le_of_lt Pos)
        exact Finset.le_sup (Finset.mem_univ i)
      _ =
          ((Fintype.card Œπ : ‚Ñù‚â•0) ^ (1 / p.to_real) : ‚Ñù‚â•0) *
            edist (PiLp.equiv p Œ≤ x) (PiLp.equiv p Œ≤ y) :=
        by
        simp only [nsmul_eq_mul, Finset.card_univ, ENNReal.rpow_one, Finset.sum_const,
          ENNReal.mul_rpow_of_nonneg _ _ nonneg, ‚Üê ENNReal.rpow_mul, cancel]
        have : (Fintype.card Œπ : ‚Ñù‚â•0‚àû) = (Fintype.card Œπ : ‚Ñù‚â•0) :=
          (ENNReal.coe_nat (Fintype.card Œπ)).symm
        rw [this, ENNReal.coe_rpow_of_nonneg _ nonneg]
      
#align pi_Lp.antilipschitz_with_equiv_aux PiLp.antilipschitzWith_equiv_aux

/- warning: pi_Lp.aux_uniformity_eq -> PiLp.aux_uniformity_eq is a dubious translation:
lean 3 declaration is
  forall (p : ENNReal) {Œπ : Type.{u1}} (Œ≤ : Œπ -> Type.{u2}) [_inst_1 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] [_inst_3 : forall (i : Œπ), PseudoEMetricSpace.{u2} (Œ≤ i)] [_inst_4 : Fintype.{u1} Œπ], Eq.{succ (max u1 u2)} (Filter.{max u1 u2} (Prod.{max u1 u2, max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.{u1, u2} p Œπ Œ≤))) (uniformity.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PseudoEMetricSpace.toUniformSpace.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.pseudoEmetricAux.{u1, u2} p Œπ Œ≤ _inst_1 (fun (i : Œπ) => _inst_3 i) _inst_4))) (uniformity.{max u1 u2} (forall (i : Œπ), Œ≤ i) (Pi.uniformSpace.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (i : Œπ) => PseudoEMetricSpace.toUniformSpace.{u2} (Œ≤ i) (_inst_3 i))))
but is expected to have type
  forall (p : ENNReal) {Œπ : Type.{u2}} (Œ≤ : Œπ -> Type.{u1}) [_inst_1 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] [_inst_3 : forall (i : Œπ), PseudoEMetricSpace.{u1} (Œ≤ i)] [_inst_4 : Fintype.{u2} Œπ], Eq.{max (succ u2) (succ u1)} (Filter.{max u1 u2} (Prod.{max u1 u2, max u1 u2} (PiLp.{u2, u1} p Œπ Œ≤) (PiLp.{u2, u1} p Œπ Œ≤))) (uniformity.{max u1 u2} (PiLp.{u2, u1} p Œπ Œ≤) (PseudoEMetricSpace.toUniformSpace.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (PiLp.pseudoEmetricAux.{u2, u1} p Œπ Œ≤ _inst_1 (fun (i : Œπ) => _inst_3 i) _inst_4))) (uniformity.{max u2 u1} (forall (i : Œπ), Œ≤ i) (Pi.uniformSpace.{u1, u2} Œπ (fun (i : Œπ) => Œ≤ i) (fun (i : Œπ) => PseudoEMetricSpace.toUniformSpace.{u1} (Œ≤ i) (_inst_3 i))))
Case conversion may be inaccurate. Consider using '#align pi_Lp.aux_uniformity_eq PiLp.aux_uniformity_eq‚Çì'. -/
theorem aux_uniformity_eq : ùì§ (PiLp p Œ≤) = ùì§[Pi.uniformSpace _] :=
  by
  have A : UniformInducing (PiLp.equiv p Œ≤) :=
    (antilipschitz_with_equiv_aux p Œ≤).UniformInducing
      (lipschitz_with_equiv_aux p Œ≤).UniformContinuous
  have : (fun x : PiLp p Œ≤ √ó PiLp p Œ≤ => ((PiLp.equiv p Œ≤) x.fst, (PiLp.equiv p Œ≤) x.snd)) = id :=
    by ext i <;> rfl
  rw [‚Üê A.comap_uniformity, this, comap_id]
#align pi_Lp.aux_uniformity_eq PiLp.aux_uniformity_eq

/- warning: pi_Lp.aux_cobounded_eq -> PiLp.aux_cobounded_eq is a dubious translation:
lean 3 declaration is
  forall (p : ENNReal) {Œπ : Type.{u1}} (Œ± : Œπ -> Type.{u2}) [_inst_1 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] [_inst_2 : forall (i : Œπ), PseudoMetricSpace.{u2} (Œ± i)] [_inst_4 : Fintype.{u1} Œπ], Eq.{succ (max u1 u2)} (Filter.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ±)) (Bornology.cobounded.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ±) (PseudoMetricSpace.toBornology.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ±) (PiLp.pseudoMetricAux.{u1, u2} p Œπ Œ± _inst_1 (fun (i : Œπ) => _inst_2 i) _inst_4))) (Bornology.cobounded.{max u1 u2} (forall (i : Œπ), Œ± i) (Pi.instBornology.{u1, u2} Œπ (fun (i : Œπ) => Œ± i) _inst_4 (fun (i : Œπ) => PseudoMetricSpace.toBornology.{u2} (Œ± i) (_inst_2 i))))
but is expected to have type
  forall (p : ENNReal) {Œπ : Type.{u2}} (Œ± : Œπ -> Type.{u1}) [_inst_1 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] [_inst_2 : forall (i : Œπ), PseudoMetricSpace.{u1} (Œ± i)] [_inst_4 : Fintype.{u2} Œπ], Eq.{max (succ u2) (succ u1)} (Filter.{max u1 u2} (PiLp.{u2, u1} p Œπ Œ±)) (Bornology.cobounded.{max u1 u2} (PiLp.{u2, u1} p Œπ Œ±) (PseudoMetricSpace.toBornology.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ±) (PiLp.pseudoMetricAux.{u2, u1} p Œπ Œ± _inst_1 (fun (i : Œπ) => _inst_2 i) _inst_4))) (Bornology.cobounded.{max u1 u2} (forall (i : Œπ), Œ± i) (Pi.instBornology.{u2, u1} Œπ (fun (i : Œπ) => Œ± i) _inst_4 (fun (i : Œπ) => PseudoMetricSpace.toBornology.{u1} (Œ± i) (_inst_2 i))))
Case conversion may be inaccurate. Consider using '#align pi_Lp.aux_cobounded_eq PiLp.aux_cobounded_eq‚Çì'. -/
theorem aux_cobounded_eq : cobounded (PiLp p Œ±) = @cobounded _ Pi.instBornology :=
  calc
    cobounded (PiLp p Œ±) = comap (PiLp.equiv p Œ±) (cobounded _) :=
      le_antisymm (antilipschitzWith_equiv_aux p Œ±).tendsto_cobounded.le_comap
        (lipschitzWith_equiv_aux p Œ±).comap_cobounded_le
    _ = _ := comap_id
    
#align pi_Lp.aux_cobounded_eq PiLp.aux_cobounded_eq

end Aux

/-! ### Instances on finite `L^p` products -/


#print PiLp.uniformSpace /-
instance uniformSpace [‚àÄ i, UniformSpace (Œ≤ i)] : UniformSpace (PiLp p Œ≤) :=
  Pi.uniformSpace _
#align pi_Lp.uniform_space PiLp.uniformSpace
-/

#print PiLp.uniformContinuous_equiv /-
theorem uniformContinuous_equiv [‚àÄ i, UniformSpace (Œ≤ i)] : UniformContinuous (PiLp.equiv p Œ≤) :=
  uniformContinuous_id
#align pi_Lp.uniform_continuous_equiv PiLp.uniformContinuous_equiv
-/

#print PiLp.uniformContinuous_equiv_symm /-
theorem uniformContinuous_equiv_symm [‚àÄ i, UniformSpace (Œ≤ i)] :
    UniformContinuous (PiLp.equiv p Œ≤).symm :=
  uniformContinuous_id
#align pi_Lp.uniform_continuous_equiv_symm PiLp.uniformContinuous_equiv_symm
-/

#print PiLp.continuous_equiv /-
@[continuity]
theorem continuous_equiv [‚àÄ i, UniformSpace (Œ≤ i)] : Continuous (PiLp.equiv p Œ≤) :=
  continuous_id
#align pi_Lp.continuous_equiv PiLp.continuous_equiv
-/

#print PiLp.continuous_equiv_symm /-
@[continuity]
theorem continuous_equiv_symm [‚àÄ i, UniformSpace (Œ≤ i)] : Continuous (PiLp.equiv p Œ≤).symm :=
  continuous_id
#align pi_Lp.continuous_equiv_symm PiLp.continuous_equiv_symm
-/

variable [Fintype Œπ]

#print PiLp.bornology /-
instance bornology [‚àÄ i, Bornology (Œ≤ i)] : Bornology (PiLp p Œ≤) :=
  Pi.instBornology
#align pi_Lp.bornology PiLp.bornology
-/

-- throughout the rest of the file, we assume `1 ‚â§ p`
variable [Fact (1 ‚â§ p)]

/-- pseudoemetric space instance on the product of finitely many pseudoemetric spaces, using the
`L^p` pseudoedistance, and having as uniformity the product uniformity. -/
instance [‚àÄ i, PseudoEMetricSpace (Œ≤ i)] : PseudoEMetricSpace (PiLp p Œ≤) :=
  (pseudoEmetricAux p Œ≤).replaceUniformity (aux_uniformity_eq p Œ≤).symm

/-- emetric space instance on the product of finitely many emetric spaces, using the `L^p`
edistance, and having as uniformity the product uniformity. -/
instance [‚àÄ i, EMetricSpace (Œ± i)] : EMetricSpace (PiLp p Œ±) :=
  @EMetricSpace.ofT0PseudoEMetricSpace (PiLp p Œ±) _ Pi.instT0Space

/-- pseudometric space instance on the product of finitely many psuedometric spaces, using the
`L^p` distance, and having as uniformity the product uniformity. -/
instance [‚àÄ i, PseudoMetricSpace (Œ≤ i)] : PseudoMetricSpace (PiLp p Œ≤) :=
  ((pseudoMetricAux p Œ≤).replaceUniformity (aux_uniformity_eq p Œ≤).symm).replaceBornology fun s =>
    Filter.ext_iff.1 (aux_cobounded_eq p Œ≤).symm (s·∂ú)

/-- metric space instance on the product of finitely many metric spaces, using the `L^p` distance,
and having as uniformity the product uniformity. -/
instance [‚àÄ i, MetricSpace (Œ± i)] : MetricSpace (PiLp p Œ±) :=
  MetricSpace.ofT0PseudoMetricSpace _

/- warning: pi_Lp.nndist_eq_sum -> PiLp.nndist_eq_sum is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} [_inst_1 : Fintype.{u1} Œπ] {p : ENNReal} [_inst_3 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] {Œ≤ : Œπ -> Type.{u2}} [_inst_4 : forall (i : Œπ), PseudoMetricSpace.{u2} (Œ≤ i)], (Ne.{1} ENNReal p (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (forall (x : PiLp.{u1, u2} p Œπ Œ≤) (y : PiLp.{u1, u2} p Œπ Œ≤), Eq.{1} NNReal (NNDist.nndist.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PseudoMetricSpace.toNNDist.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.pseudoMetricSpace.{u1, u2} p Œπ Œ≤ _inst_1 _inst_3 (fun (i : Œπ) => _inst_4 i))) x y) (HPow.hPow.{0, 0, 0} NNReal Real NNReal (instHPow.{0, 0} NNReal Real NNReal.Real.hasPow) (Finset.sum.{0, u1} NNReal Œπ (OrderedCancelAddCommMonoid.toAddCommMonoid.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)) (Finset.univ.{u1} Œπ _inst_1) (fun (i : Œπ) => HPow.hPow.{0, 0, 0} NNReal Real NNReal (instHPow.{0, 0} NNReal Real NNReal.Real.hasPow) (NNDist.nndist.{u2} (Œ≤ i) (PseudoMetricSpace.toNNDist.{u2} (Œ≤ i) (_inst_4 i)) (x i) (y i)) (ENNReal.toReal p))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (ENNReal.toReal p))))
but is expected to have type
  forall {Œπ : Type.{u1}} [_inst_1 : Fintype.{u1} Œπ] {p : ENNReal} [_inst_3 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] {Œ≤ : Œπ -> Type.{u2}} [_inst_4 : forall (i : Œπ), PseudoMetricSpace.{u2} (Œ≤ i)], (Ne.{1} ENNReal p (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (forall (x : PiLp.{u1, u2} p Œπ Œ≤) (y : PiLp.{u1, u2} p Œπ Œ≤), Eq.{1} NNReal (NNDist.nndist.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PseudoMetricSpace.toNNDist.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.instPseudoMetricSpacePiLp.{u1, u2} p Œπ Œ≤ _inst_1 _inst_3 (fun (i : Œπ) => _inst_4 i))) x y) (HPow.hPow.{0, 0, 0} NNReal Real NNReal (instHPow.{0, 0} NNReal Real NNReal.instPowNNRealReal) (Finset.sum.{0, u1} NNReal Œπ (OrderedCancelAddCommMonoid.toAddCommMonoid.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal instNNRealStrictOrderedSemiring)) (Finset.univ.{u1} Œπ _inst_1) (fun (i : Œπ) => HPow.hPow.{0, 0, 0} NNReal Real NNReal (instHPow.{0, 0} NNReal Real NNReal.instPowNNRealReal) (NNDist.nndist.{u2} (Œ≤ i) (PseudoMetricSpace.toNNDist.{u2} (Œ≤ i) (_inst_4 i)) (x i) (y i)) (ENNReal.toReal p))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (ENNReal.toReal p))))
Case conversion may be inaccurate. Consider using '#align pi_Lp.nndist_eq_sum PiLp.nndist_eq_sum‚Çì'. -/
theorem nndist_eq_sum {p : ‚Ñù‚â•0‚àû} [Fact (1 ‚â§ p)] {Œ≤ : Œπ ‚Üí Type _} [‚àÄ i, PseudoMetricSpace (Œ≤ i)]
    (hp : p ‚â† ‚àû) (x y : PiLp p Œ≤) :
    nndist x y = (‚àë i : Œπ, nndist (x i) (y i) ^ p.toReal) ^ (1 / p.toReal) :=
  Subtype.ext <| by push_cast ; exact dist_eq_sum (p.to_real_pos_iff_ne_top.mpr hp) _ _
#align pi_Lp.nndist_eq_sum PiLp.nndist_eq_sum

/- warning: pi_Lp.nndist_eq_supr -> PiLp.nndist_eq_iSup is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} [_inst_1 : Fintype.{u1} Œπ] {Œ≤ : Œπ -> Type.{u2}} [_inst_3 : forall (i : Œπ), PseudoMetricSpace.{u2} (Œ≤ i)] (x : PiLp.{u1, u2} (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Œπ Œ≤) (y : PiLp.{u1, u2} (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Œπ Œ≤), Eq.{1} NNReal (NNDist.nndist.{max u1 u2} (PiLp.{u1, u2} (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Œπ Œ≤) (PseudoMetricSpace.toNNDist.{max u1 u2} (PiLp.{u1, u2} (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Œπ Œ≤) (PiLp.pseudoMetricSpace.{u1, u2} (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Œπ Œ≤ _inst_1 fact_one_le_top_ennreal (fun (i : Œπ) => _inst_3 i))) x y) (iSup.{0, succ u1} NNReal (ConditionallyCompleteLattice.toHasSup.{0} NNReal (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{0} NNReal (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{0} NNReal NNReal.conditionallyCompleteLinearOrderBot))) Œπ (fun (i : Œπ) => NNDist.nndist.{u2} (Œ≤ i) (PseudoMetricSpace.toNNDist.{u2} (Œ≤ i) (_inst_3 i)) (x i) (y i)))
but is expected to have type
  forall {Œπ : Type.{u1}} [_inst_1 : Fintype.{u1} Œπ] {Œ≤ : Œπ -> Type.{u2}} [_inst_3 : forall (i : Œπ), PseudoMetricSpace.{u2} (Œ≤ i)] (x : PiLp.{u1, u2} (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))) Œπ Œ≤) (y : PiLp.{u1, u2} (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))) Œπ Œ≤), Eq.{1} NNReal (NNDist.nndist.{max u1 u2} (PiLp.{u1, u2} (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))) Œπ Œ≤) (PseudoMetricSpace.toNNDist.{max u1 u2} (PiLp.{u1, u2} (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))) Œπ Œ≤) (PiLp.instPseudoMetricSpacePiLp.{u1, u2} (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))) Œπ Œ≤ _inst_1 fact_one_le_top_ennreal (fun (i : Œπ) => _inst_3 i))) x y) (iSup.{0, succ u1} NNReal (ConditionallyCompleteLattice.toSupSet.{0} NNReal (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{0} NNReal (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{0} NNReal NNReal.instConditionallyCompleteLinearOrderBotNNReal))) Œπ (fun (i : Œπ) => NNDist.nndist.{u2} (Œ≤ i) (PseudoMetricSpace.toNNDist.{u2} (Œ≤ i) (_inst_3 i)) (x i) (y i)))
Case conversion may be inaccurate. Consider using '#align pi_Lp.nndist_eq_supr PiLp.nndist_eq_iSup‚Çì'. -/
theorem nndist_eq_iSup {Œ≤ : Œπ ‚Üí Type _} [‚àÄ i, PseudoMetricSpace (Œ≤ i)] (x y : PiLp ‚àû Œ≤) :
    nndist x y = ‚®Ü i, nndist (x i) (y i) :=
  Subtype.ext <| by push_cast ; exact dist_eq_csupr _ _
#align pi_Lp.nndist_eq_supr PiLp.nndist_eq_iSup

/- warning: pi_Lp.lipschitz_with_equiv -> PiLp.lipschitzWith_equiv is a dubious translation:
lean 3 declaration is
  forall (p : ENNReal) {Œπ : Type.{u1}} (Œ≤ : Œπ -> Type.{u2}) [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] [_inst_3 : forall (i : Œπ), PseudoEMetricSpace.{u2} (Œ≤ i)], LipschitzWith.{max u1 u2, max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.pseudoEmetricSpace.{u1, u2} p Œπ Œ≤ _inst_1 _inst_2 (fun (b : Œπ) => _inst_3 b)) (pseudoEMetricSpacePi.{u1, u2} Œπ (fun (i : Œπ) => Œ≤ i) _inst_1 (fun (b : Œπ) => _inst_3 b)) (OfNat.ofNat.{0} NNReal 1 (OfNat.mk.{0} NNReal 1 (One.one.{0} NNReal (AddMonoidWithOne.toOne.{0} NNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} NNReal (NonAssocSemiring.toAddCommMonoidWithOne.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))))) (coeFn.{max 1 (max (succ (max u1 u2)) (succ u1) (succ u2)) (max (succ u1) (succ u2)) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u1) (succ u2)} (Equiv.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (fun (_x : Equiv.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) => (PiLp.{u1, u2} p Œπ Œ≤) -> (forall (i : Œπ), Œ≤ i)) (Equiv.hasCoeToFun.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.equiv.{u1, u2} p Œπ Œ≤))
but is expected to have type
  forall (p : ENNReal) {Œπ : Type.{u1}} (Œ≤ : Œπ -> Type.{u2}) [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] [_inst_3 : forall (i : Œπ), PseudoEMetricSpace.{u2} (Œ≤ i)], LipschitzWith.{max u1 u2, max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.instPseudoEMetricSpacePiLp.{u1, u2} p Œπ Œ≤ _inst_1 _inst_2 (fun (b : Œπ) => _inst_3 b)) (pseudoEMetricSpacePi.{u1, u2} Œπ (fun (i : Œπ) => Œ≤ i) _inst_1 (fun (b : Œπ) => _inst_3 b)) (OfNat.ofNat.{0} NNReal 1 (One.toOfNat1.{0} NNReal instNNRealOne)) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.{u1, u2} p Œπ Œ≤) (fun (_x : PiLp.{u1, u2} p Œπ Œ≤) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : PiLp.{u1, u2} p Œπ Œ≤) => forall (i : Œπ), Œ≤ i) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.equiv.{u1, u2} p Œπ Œ≤))
Case conversion may be inaccurate. Consider using '#align pi_Lp.lipschitz_with_equiv PiLp.lipschitzWith_equiv‚Çì'. -/
theorem lipschitzWith_equiv [‚àÄ i, PseudoEMetricSpace (Œ≤ i)] : LipschitzWith 1 (PiLp.equiv p Œ≤) :=
  lipschitzWith_equiv_aux p Œ≤
#align pi_Lp.lipschitz_with_equiv PiLp.lipschitzWith_equiv

/- warning: pi_Lp.antilipschitz_with_equiv -> PiLp.antilipschitzWith_equiv is a dubious translation:
lean 3 declaration is
  forall (p : ENNReal) {Œπ : Type.{u1}} (Œ≤ : Œπ -> Type.{u2}) [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] [_inst_3 : forall (i : Œπ), PseudoEMetricSpace.{u2} (Œ≤ i)], AntilipschitzWith.{max u1 u2, max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.pseudoEmetricSpace.{u1, u2} p Œπ Œ≤ _inst_1 _inst_2 (fun (b : Œπ) => _inst_3 b)) (pseudoEMetricSpacePi.{u1, u2} Œπ (fun (i : Œπ) => Œ≤ i) _inst_1 (fun (b : Œπ) => _inst_3 b)) (HPow.hPow.{0, 0, 0} NNReal Real NNReal (instHPow.{0, 0} NNReal Real NNReal.Real.hasPow) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat NNReal (HasLiftT.mk.{1, 1} Nat NNReal (CoeTC‚Çì.coe.{1, 1} Nat NNReal (Nat.castCoe.{0} NNReal (AddMonoidWithOne.toNatCast.{0} NNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} NNReal (NonAssocSemiring.toAddCommMonoidWithOne.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))))) (Fintype.card.{u1} Œπ _inst_1)) (ENNReal.toReal (HDiv.hDiv.{0, 0, 0} ENNReal ENNReal ENNReal (instHDiv.{0} ENNReal (DivInvMonoid.toHasDiv.{0} ENNReal ENNReal.divInvMonoid)) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p))) (coeFn.{max 1 (max (succ (max u1 u2)) (succ u1) (succ u2)) (max (succ u1) (succ u2)) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u1) (succ u2)} (Equiv.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (fun (_x : Equiv.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) => (PiLp.{u1, u2} p Œπ Œ≤) -> (forall (i : Œπ), Œ≤ i)) (Equiv.hasCoeToFun.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.equiv.{u1, u2} p Œπ Œ≤))
but is expected to have type
  forall (p : ENNReal) {Œπ : Type.{u1}} (Œ≤ : Œπ -> Type.{u2}) [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] [_inst_3 : forall (i : Œπ), PseudoEMetricSpace.{u2} (Œ≤ i)], AntilipschitzWith.{max u1 u2, max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.instPseudoEMetricSpacePiLp.{u1, u2} p Œπ Œ≤ _inst_1 _inst_2 (fun (b : Œπ) => _inst_3 b)) (pseudoEMetricSpacePi.{u1, u2} Œπ (fun (i : Œπ) => Œ≤ i) _inst_1 (fun (b : Œπ) => _inst_3 b)) (HPow.hPow.{0, 0, 0} NNReal Real NNReal (instHPow.{0, 0} NNReal Real NNReal.instPowNNRealReal) (Nat.cast.{0} NNReal (CanonicallyOrderedCommSemiring.toNatCast.{0} NNReal instNNRealCanonicallyOrderedCommSemiring) (Fintype.card.{u1} Œπ _inst_1)) (ENNReal.toReal (HDiv.hDiv.{0, 0, 0} ENNReal ENNReal ENNReal (instHDiv.{0} ENNReal (DivInvMonoid.toDiv.{0} ENNReal ENNReal.instDivInvMonoidENNReal)) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p))) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.{u1, u2} p Œπ Œ≤) (fun (_x : PiLp.{u1, u2} p Œπ Œ≤) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : PiLp.{u1, u2} p Œπ Œ≤) => forall (i : Œπ), Œ≤ i) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.equiv.{u1, u2} p Œπ Œ≤))
Case conversion may be inaccurate. Consider using '#align pi_Lp.antilipschitz_with_equiv PiLp.antilipschitzWith_equiv‚Çì'. -/
theorem antilipschitzWith_equiv [‚àÄ i, PseudoEMetricSpace (Œ≤ i)] :
    AntilipschitzWith ((Fintype.card Œπ : ‚Ñù‚â•0) ^ (1 / p).toReal) (PiLp.equiv p Œ≤) :=
  antilipschitzWith_equiv_aux p Œ≤
#align pi_Lp.antilipschitz_with_equiv PiLp.antilipschitzWith_equiv

#print PiLp.infty_equiv_isometry /-
theorem infty_equiv_isometry [‚àÄ i, PseudoEMetricSpace (Œ≤ i)] : Isometry (PiLp.equiv ‚àû Œ≤) :=
  fun x y =>
  le_antisymm (by simpa only [ENNReal.coe_one, one_mul] using lipschitz_with_equiv ‚àû Œ≤ x y)
    (by
      simpa only [ENNReal.div_top, ENNReal.zero_toReal, NNReal.rpow_zero, ENNReal.coe_one,
        one_mul] using antilipschitz_with_equiv ‚àû Œ≤ x y)
#align pi_Lp.infty_equiv_isometry PiLp.infty_equiv_isometry
-/

variable (p Œ≤)

/- warning: pi_Lp.seminormed_add_comm_group -> PiLp.seminormedAddCommGroup is a dubious translation:
lean 3 declaration is
  forall (p : ENNReal) {Œπ : Type.{u1}} (Œ≤ : Œπ -> Type.{u2}) [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] [_inst_3 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)], SeminormedAddCommGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤)
but is expected to have type
  forall (p : ENNReal) {Œπ : Type.{u1}} (Œ≤ : Œπ -> Type.{u2}) [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] [_inst_3 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)], SeminormedAddCommGroup.{max u2 u1} (PiLp.{u1, u2} p Œπ Œ≤)
Case conversion may be inaccurate. Consider using '#align pi_Lp.seminormed_add_comm_group PiLp.seminormedAddCommGroup‚Çì'. -/
/-- seminormed group instance on the product of finitely many normed groups, using the `L^p`
norm. -/
instance seminormedAddCommGroup [‚àÄ i, SeminormedAddCommGroup (Œ≤ i)] :
    SeminormedAddCommGroup (PiLp p Œ≤) :=
  { Pi.addCommGroup with
    dist_eq := fun x y => by
      rcases p.dichotomy with (rfl | h)
      ¬∑ simpa only [dist_eq_csupr, norm_eq_csupr, dist_eq_norm]
      ¬∑ have : p ‚â† ‚àû := by intro hp; rw [hp, ENNReal.top_toReal] at h; linarith
        simpa only [dist_eq_sum (zero_lt_one.trans_le h), norm_eq_sum (zero_lt_one.trans_le h),
          dist_eq_norm] }
#align pi_Lp.seminormed_add_comm_group PiLp.seminormedAddCommGroup

/- warning: pi_Lp.normed_add_comm_group -> PiLp.normedAddCommGroup is a dubious translation:
lean 3 declaration is
  forall (p : ENNReal) {Œπ : Type.{u1}} (Œ± : Œπ -> Type.{u2}) [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] [_inst_3 : forall (i : Œπ), NormedAddCommGroup.{u2} (Œ± i)], NormedAddCommGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ±)
but is expected to have type
  forall (p : ENNReal) {Œπ : Type.{u1}} (Œ± : Œπ -> Type.{u2}) [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] [_inst_3 : forall (i : Œπ), NormedAddCommGroup.{u2} (Œ± i)], NormedAddCommGroup.{max u2 u1} (PiLp.{u1, u2} p Œπ Œ±)
Case conversion may be inaccurate. Consider using '#align pi_Lp.normed_add_comm_group PiLp.normedAddCommGroup‚Çì'. -/
/-- normed group instance on the product of finitely many normed groups, using the `L^p` norm. -/
instance normedAddCommGroup [‚àÄ i, NormedAddCommGroup (Œ± i)] : NormedAddCommGroup (PiLp p Œ±) :=
  { PiLp.seminormedAddCommGroup p Œ± with }
#align pi_Lp.normed_add_comm_group PiLp.normedAddCommGroup

/- warning: pi_Lp.nnnorm_eq_sum -> PiLp.nnnorm_eq_sum is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} [_inst_1 : Fintype.{u1} Œπ] {p : ENNReal} [_inst_3 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] {Œ≤ : Œπ -> Type.{u2}}, (Ne.{1} ENNReal p (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (forall [_inst_4 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)] (f : PiLp.{u1, u2} p Œπ Œ≤), Eq.{1} NNReal (NNNorm.nnnorm.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddGroup.toNNNorm.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u1, u2} p Œπ Œ≤ _inst_1 _inst_3 (fun (i : Œπ) => _inst_4 i)))) f) (HPow.hPow.{0, 0, 0} NNReal Real NNReal (instHPow.{0, 0} NNReal Real NNReal.Real.hasPow) (Finset.sum.{0, u1} NNReal Œπ (OrderedCancelAddCommMonoid.toAddCommMonoid.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)) (Finset.univ.{u1} Œπ _inst_1) (fun (i : Œπ) => HPow.hPow.{0, 0, 0} NNReal Real NNReal (instHPow.{0, 0} NNReal Real NNReal.Real.hasPow) (NNNorm.nnnorm.{u2} (Œ≤ i) (SeminormedAddGroup.toNNNorm.{u2} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} (Œ≤ i) (_inst_4 i))) (f i)) (ENNReal.toReal p))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (ENNReal.toReal p))))
but is expected to have type
  forall {Œπ : Type.{u1}} [_inst_1 : Fintype.{u1} Œπ] {p : ENNReal} [_inst_3 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] {Œ≤ : Œπ -> Type.{u2}}, (Ne.{1} ENNReal p (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (forall [_inst_4 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)] (f : PiLp.{u1, u2} p Œπ Œ≤), Eq.{1} NNReal (NNNorm.nnnorm.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddGroup.toNNNorm.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u1, u2} p Œπ Œ≤ _inst_1 _inst_3 (fun (i : Œπ) => _inst_4 i)))) f) (HPow.hPow.{0, 0, 0} NNReal Real NNReal (instHPow.{0, 0} NNReal Real NNReal.instPowNNRealReal) (Finset.sum.{0, u1} NNReal Œπ (OrderedCancelAddCommMonoid.toAddCommMonoid.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal instNNRealStrictOrderedSemiring)) (Finset.univ.{u1} Œπ _inst_1) (fun (i : Œπ) => HPow.hPow.{0, 0, 0} NNReal Real NNReal (instHPow.{0, 0} NNReal Real NNReal.instPowNNRealReal) (NNNorm.nnnorm.{u2} (Œ≤ i) (SeminormedAddGroup.toNNNorm.{u2} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} (Œ≤ i) (_inst_4 i))) (f i)) (ENNReal.toReal p))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (ENNReal.toReal p))))
Case conversion may be inaccurate. Consider using '#align pi_Lp.nnnorm_eq_sum PiLp.nnnorm_eq_sum‚Çì'. -/
theorem nnnorm_eq_sum {p : ‚Ñù‚â•0‚àû} [Fact (1 ‚â§ p)] {Œ≤ : Œπ ‚Üí Type _} (hp : p ‚â† ‚àû)
    [‚àÄ i, SeminormedAddCommGroup (Œ≤ i)] (f : PiLp p Œ≤) :
    ‚Äñf‚Äñ‚Çä = (‚àë i, ‚Äñf i‚Äñ‚Çä ^ p.toReal) ^ (1 / p.toReal) := by ext;
  simp [NNReal.coe_sum, norm_eq_sum (p.to_real_pos_iff_ne_top.mpr hp)]
#align pi_Lp.nnnorm_eq_sum PiLp.nnnorm_eq_sum

/- warning: pi_Lp.nnnorm_eq_csupr -> PiLp.nnnorm_eq_ciSup is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} [_inst_1 : Fintype.{u1} Œπ] {Œ≤ : Œπ -> Type.{u2}} [_inst_3 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)] (f : PiLp.{u1, u2} (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Œπ Œ≤), Eq.{1} NNReal (NNNorm.nnnorm.{max u1 u2} (PiLp.{u1, u2} (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Œπ Œ≤) (SeminormedAddGroup.toNNNorm.{max u1 u2} (PiLp.{u1, u2} (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Œπ Œ≤) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (PiLp.{u1, u2} (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u1, u2} (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Œπ Œ≤ _inst_1 fact_one_le_top_ennreal (fun (i : Œπ) => _inst_3 i)))) f) (iSup.{0, succ u1} NNReal (ConditionallyCompleteLattice.toHasSup.{0} NNReal (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{0} NNReal (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{0} NNReal NNReal.conditionallyCompleteLinearOrderBot))) Œπ (fun (i : Œπ) => NNNorm.nnnorm.{u2} (Œ≤ i) (SeminormedAddGroup.toNNNorm.{u2} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} (Œ≤ i) (_inst_3 i))) (f i)))
but is expected to have type
  forall {Œπ : Type.{u1}} [_inst_1 : Fintype.{u1} Œπ] {Œ≤ : Œπ -> Type.{u2}} [_inst_3 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)] (f : PiLp.{u1, u2} (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))) Œπ Œ≤), Eq.{1} NNReal (NNNorm.nnnorm.{max u1 u2} (PiLp.{u1, u2} (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))) Œπ Œ≤) (SeminormedAddGroup.toNNNorm.{max u1 u2} (PiLp.{u1, u2} (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))) Œπ Œ≤) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (PiLp.{u1, u2} (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))) Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u1, u2} (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))) Œπ Œ≤ _inst_1 fact_one_le_top_ennreal (fun (i : Œπ) => _inst_3 i)))) f) (iSup.{0, succ u1} NNReal (ConditionallyCompleteLattice.toSupSet.{0} NNReal (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{0} NNReal (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{0} NNReal NNReal.instConditionallyCompleteLinearOrderBotNNReal))) Œπ (fun (i : Œπ) => NNNorm.nnnorm.{u2} (Œ≤ i) (SeminormedAddGroup.toNNNorm.{u2} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} (Œ≤ i) (_inst_3 i))) (f i)))
Case conversion may be inaccurate. Consider using '#align pi_Lp.nnnorm_eq_csupr PiLp.nnnorm_eq_ciSup‚Çì'. -/
theorem nnnorm_eq_ciSup {Œ≤ : Œπ ‚Üí Type _} [‚àÄ i, SeminormedAddCommGroup (Œ≤ i)] (f : PiLp ‚àû Œ≤) :
    ‚Äñf‚Äñ‚Çä = ‚®Ü i, ‚Äñf i‚Äñ‚Çä := by ext; simp [NNReal.coe_iSup, norm_eq_csupr]
#align pi_Lp.nnnorm_eq_csupr PiLp.nnnorm_eq_ciSup

/- warning: pi_Lp.norm_eq_of_nat -> PiLp.norm_eq_of_nat is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} [_inst_1 : Fintype.{u1} Œπ] {p : ENNReal} [_inst_3 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] {Œ≤ : Œπ -> Type.{u2}} [_inst_4 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)] (n : Nat), (Eq.{1} ENNReal p ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat ENNReal (HasLiftT.mk.{1, 1} Nat ENNReal (CoeTC‚Çì.coe.{1, 1} Nat ENNReal (Nat.castCoe.{0} ENNReal (AddMonoidWithOne.toNatCast.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) n)) -> (forall (f : PiLp.{u1, u2} p Œπ Œ≤), Eq.{1} Real (Norm.norm.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.hasNorm.{u1, u2} p Œπ Œ≤ _inst_1 (fun (i : Œπ) => SeminormedAddCommGroup.toHasNorm.{u2} (Œ≤ i) (_inst_4 i)) (fun (i : Œπ) => AddZeroClass.toHasZero.{u2} (Œ≤ i) (AddMonoid.toAddZeroClass.{u2} (Œ≤ i) (SubNegMonoid.toAddMonoid.{u2} (Œ≤ i) (AddGroup.toSubNegMonoid.{u2} (Œ≤ i) (SeminormedAddGroup.toAddGroup.{u2} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} (Œ≤ i) (_inst_4 i)))))))) f) (HPow.hPow.{0, 0, 0} Real Real Real (instHPow.{0, 0} Real Real Real.hasPow) (Finset.sum.{0, u1} Real Œπ Real.addCommMonoid (Finset.univ.{u1} Œπ _inst_1) (fun (i : Œπ) => HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) (Norm.norm.{u2} (Œ≤ i) (SeminormedAddCommGroup.toHasNorm.{u2} (Œ≤ i) (_inst_4 i)) (f i)) n)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTC‚Çì.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n))))
but is expected to have type
  forall {Œπ : Type.{u1}} [_inst_1 : Fintype.{u1} Œπ] {p : ENNReal} [_inst_3 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] {Œ≤ : Œπ -> Type.{u2}} [_inst_4 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)] (n : Nat), (Eq.{1} ENNReal p (Nat.cast.{0} ENNReal (CanonicallyOrderedCommSemiring.toNatCast.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) n)) -> (forall (f : PiLp.{u1, u2} p Œπ Œ≤), Eq.{1} Real (Norm.norm.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.hasNorm.{u1, u2} p Œπ Œ≤ _inst_1 (fun (i : Œπ) => SeminormedAddCommGroup.toNorm.{u2} (Œ≤ i) (_inst_4 i)) (fun (i : Œπ) => NegZeroClass.toZero.{u2} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u2} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u2} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u2} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u2} (Œ≤ i) (_inst_4 i)))))))) f) (HPow.hPow.{0, 0, 0} Real Real Real (instHPow.{0, 0} Real Real Real.instPowReal) (Finset.sum.{0, u1} Real Œπ Real.instAddCommMonoidReal (Finset.univ.{u1} Œπ _inst_1) (fun (i : Œπ) => HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) (Norm.norm.{u2} (Œ≤ i) (SeminormedAddCommGroup.toNorm.{u2} (Œ≤ i) (_inst_4 i)) (f i)) n)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (Nat.cast.{0} Real Real.natCast n))))
Case conversion may be inaccurate. Consider using '#align pi_Lp.norm_eq_of_nat PiLp.norm_eq_of_nat‚Çì'. -/
theorem norm_eq_of_nat {p : ‚Ñù‚â•0‚àû} [Fact (1 ‚â§ p)] {Œ≤ : Œπ ‚Üí Type _}
    [‚àÄ i, SeminormedAddCommGroup (Œ≤ i)] (n : ‚Ñï) (h : p = n) (f : PiLp p Œ≤) :
    ‚Äñf‚Äñ = (‚àë i, ‚Äñf i‚Äñ ^ n) ^ (1 / (n : ‚Ñù)) :=
  by
  have := p.to_real_pos_iff_ne_top.mpr (ne_of_eq_of_ne h <| ENNReal.nat_ne_top n)
  simp only [one_div, h, Real.rpow_nat_cast, ENNReal.toReal_nat, eq_self_iff_true, Finset.sum_congr,
    norm_eq_sum this]
#align pi_Lp.norm_eq_of_nat PiLp.norm_eq_of_nat

/- warning: pi_Lp.norm_eq_of_L2 -> PiLp.norm_eq_of_L2 is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} [_inst_1 : Fintype.{u1} Œπ] {Œ≤ : Œπ -> Type.{u2}} [_inst_3 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)] (x : PiLp.{u1, u2} (OfNat.ofNat.{0} ENNReal 2 (OfNat.mk.{0} ENNReal 2 (bit0.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))))) Œπ Œ≤), Eq.{1} Real (Norm.norm.{max u1 u2} (PiLp.{u1, u2} (OfNat.ofNat.{0} ENNReal 2 (OfNat.mk.{0} ENNReal 2 (bit0.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))))) Œπ Œ≤) (PiLp.hasNorm.{u1, u2} (OfNat.ofNat.{0} ENNReal 2 (OfNat.mk.{0} ENNReal 2 (bit0.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))))) Œπ Œ≤ _inst_1 (fun (i : Œπ) => SeminormedAddCommGroup.toHasNorm.{u2} (Œ≤ i) (_inst_3 i)) (fun (i : Œπ) => AddZeroClass.toHasZero.{u2} (Œ≤ i) (AddMonoid.toAddZeroClass.{u2} (Œ≤ i) (SubNegMonoid.toAddMonoid.{u2} (Œ≤ i) (AddGroup.toSubNegMonoid.{u2} (Œ≤ i) (SeminormedAddGroup.toAddGroup.{u2} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} (Œ≤ i) (_inst_3 i)))))))) x) (Real.sqrt (Finset.sum.{0, u1} Real Œπ Real.addCommMonoid (Finset.univ.{u1} Œπ _inst_1) (fun (i : Œπ) => HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) (Norm.norm.{u2} (Œ≤ i) (SeminormedAddCommGroup.toHasNorm.{u2} (Œ≤ i) (_inst_3 i)) (x i)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))
but is expected to have type
  forall {Œπ : Type.{u1}} [_inst_1 : Fintype.{u1} Œπ] {Œ≤ : Œπ -> Type.{u2}} [_inst_3 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)] (x : PiLp.{u1, u2} (OfNat.ofNat.{0} ENNReal 2 (instOfNat.{0} ENNReal 2 (CanonicallyOrderedCommSemiring.toNatCast.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) Œπ Œ≤), Eq.{1} Real (Norm.norm.{max u1 u2} (PiLp.{u1, u2} (OfNat.ofNat.{0} ENNReal 2 (instOfNat.{0} ENNReal 2 (CanonicallyOrderedCommSemiring.toNatCast.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) Œπ Œ≤) (PiLp.hasNorm.{u1, u2} (OfNat.ofNat.{0} ENNReal 2 (instOfNat.{0} ENNReal 2 (CanonicallyOrderedCommSemiring.toNatCast.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) Œπ Œ≤ _inst_1 (fun (i : Œπ) => SeminormedAddCommGroup.toNorm.{u2} (Œ≤ i) (_inst_3 i)) (fun (i : Œπ) => NegZeroClass.toZero.{u2} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u2} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u2} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u2} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u2} (Œ≤ i) (_inst_3 i)))))))) x) (Real.sqrt (Finset.sum.{0, u1} Real Œπ Real.instAddCommMonoidReal (Finset.univ.{u1} Œπ _inst_1) (fun (i : Œπ) => HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) (Norm.norm.{u2} (Œ≤ i) (SeminormedAddCommGroup.toNorm.{u2} (Œ≤ i) (_inst_3 i)) (x i)) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))))
Case conversion may be inaccurate. Consider using '#align pi_Lp.norm_eq_of_L2 PiLp.norm_eq_of_L2‚Çì'. -/
theorem norm_eq_of_L2 {Œ≤ : Œπ ‚Üí Type _} [‚àÄ i, SeminormedAddCommGroup (Œ≤ i)] (x : PiLp 2 Œ≤) :
    ‚Äñx‚Äñ = sqrt (‚àë i : Œπ, ‚Äñx i‚Äñ ^ 2) := by convert norm_eq_of_nat 2 (by norm_cast) _;
  rw [sqrt_eq_rpow]; norm_cast
#align pi_Lp.norm_eq_of_L2 PiLp.norm_eq_of_L2

/- warning: pi_Lp.nnnorm_eq_of_L2 -> PiLp.nnnorm_eq_of_L2 is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align pi_Lp.nnnorm_eq_of_L2 PiLp.nnnorm_eq_of_L2‚Çì'. -/
theorem nnnorm_eq_of_L2 {Œ≤ : Œπ ‚Üí Type _} [‚àÄ i, SeminormedAddCommGroup (Œ≤ i)] (x : PiLp 2 Œ≤) :
    ‚Äñx‚Äñ‚Çä = NNReal.sqrt (‚àë i : Œπ, ‚Äñx i‚Äñ‚Çä ^ 2) :=
  Subtype.ext <| by push_cast ; exact norm_eq_of_L2 x
#align pi_Lp.nnnorm_eq_of_L2 PiLp.nnnorm_eq_of_L2

/- warning: pi_Lp.norm_sq_eq_of_L2 -> PiLp.norm_sq_eq_of_L2 is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} [_inst_1 : Fintype.{u1} Œπ] (Œ≤ : Œπ -> Type.{u2}) [_inst_3 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)] (x : PiLp.{u1, u2} (OfNat.ofNat.{0} ENNReal 2 (OfNat.mk.{0} ENNReal 2 (bit0.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))))) Œπ Œ≤), Eq.{1} Real (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) (Norm.norm.{max u1 u2} (PiLp.{u1, u2} (OfNat.ofNat.{0} ENNReal 2 (OfNat.mk.{0} ENNReal 2 (bit0.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))))) Œπ Œ≤) (PiLp.hasNorm.{u1, u2} (OfNat.ofNat.{0} ENNReal 2 (OfNat.mk.{0} ENNReal 2 (bit0.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))))) Œπ Œ≤ _inst_1 (fun (i : Œπ) => SeminormedAddCommGroup.toHasNorm.{u2} (Œ≤ i) (_inst_3 i)) (fun (i : Œπ) => AddZeroClass.toHasZero.{u2} (Œ≤ i) (AddMonoid.toAddZeroClass.{u2} (Œ≤ i) (SubNegMonoid.toAddMonoid.{u2} (Œ≤ i) (AddGroup.toSubNegMonoid.{u2} (Œ≤ i) (SeminormedAddGroup.toAddGroup.{u2} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} (Œ≤ i) (_inst_3 i)))))))) x) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (Finset.sum.{0, u1} Real Œπ Real.addCommMonoid (Finset.univ.{u1} Œπ _inst_1) (fun (i : Œπ) => HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) (Norm.norm.{u2} (Œ≤ i) (SeminormedAddCommGroup.toHasNorm.{u2} (Œ≤ i) (_inst_3 i)) (x i)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))
but is expected to have type
  forall {Œπ : Type.{u1}} [_inst_1 : Fintype.{u1} Œπ] (Œ≤ : Œπ -> Type.{u2}) [_inst_3 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)] (x : PiLp.{u1, u2} (OfNat.ofNat.{0} ENNReal 2 (instOfNat.{0} ENNReal 2 (CanonicallyOrderedCommSemiring.toNatCast.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) Œπ Œ≤), Eq.{1} Real (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) (Norm.norm.{max u1 u2} (PiLp.{u1, u2} (OfNat.ofNat.{0} ENNReal 2 (instOfNat.{0} ENNReal 2 (CanonicallyOrderedCommSemiring.toNatCast.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) Œπ Œ≤) (PiLp.hasNorm.{u1, u2} (OfNat.ofNat.{0} ENNReal 2 (instOfNat.{0} ENNReal 2 (CanonicallyOrderedCommSemiring.toNatCast.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) Œπ Œ≤ _inst_1 (fun (i : Œπ) => SeminormedAddCommGroup.toNorm.{u2} (Œ≤ i) (_inst_3 i)) (fun (i : Œπ) => NegZeroClass.toZero.{u2} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u2} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u2} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u2} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u2} (Œ≤ i) (_inst_3 i)))))))) x) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (Finset.sum.{0, u1} Real Œπ Real.instAddCommMonoidReal (Finset.univ.{u1} Œπ _inst_1) (fun (i : Œπ) => HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) (Norm.norm.{u2} (Œ≤ i) (SeminormedAddCommGroup.toNorm.{u2} (Œ≤ i) (_inst_3 i)) (x i)) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))
Case conversion may be inaccurate. Consider using '#align pi_Lp.norm_sq_eq_of_L2 PiLp.norm_sq_eq_of_L2‚Çì'. -/
theorem norm_sq_eq_of_L2 (Œ≤ : Œπ ‚Üí Type _) [‚àÄ i, SeminormedAddCommGroup (Œ≤ i)] (x : PiLp 2 Œ≤) :
    ‚Äñx‚Äñ ^ 2 = ‚àë i : Œπ, ‚Äñx i‚Äñ ^ 2 :=
  by
  suffices ‚Äñx‚Äñ‚Çä ^ 2 = ‚àë i : Œπ, ‚Äñx i‚Äñ‚Çä ^ 2 by
    simpa only [NNReal.coe_sum] using congr_arg (coe : ‚Ñù‚â•0 ‚Üí ‚Ñù) this
  rw [nnnorm_eq_of_L2, NNReal.sq_sqrt]
#align pi_Lp.norm_sq_eq_of_L2 PiLp.norm_sq_eq_of_L2

/- warning: pi_Lp.dist_eq_of_L2 -> PiLp.dist_eq_of_L2 is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} [_inst_1 : Fintype.{u1} Œπ] {Œ≤ : Œπ -> Type.{u2}} [_inst_3 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)] (x : PiLp.{u1, u2} (OfNat.ofNat.{0} ENNReal 2 (OfNat.mk.{0} ENNReal 2 (bit0.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))))) Œπ Œ≤) (y : PiLp.{u1, u2} (OfNat.ofNat.{0} ENNReal 2 (OfNat.mk.{0} ENNReal 2 (bit0.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))))) Œπ Œ≤), Eq.{1} Real (Dist.dist.{max u1 u2} (PiLp.{u1, u2} (OfNat.ofNat.{0} ENNReal 2 (OfNat.mk.{0} ENNReal 2 (bit0.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))))) Œπ Œ≤) (PiLp.hasDist.{u1, u2} (OfNat.ofNat.{0} ENNReal 2 (OfNat.mk.{0} ENNReal 2 (bit0.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))))) Œπ Œ≤ _inst_1 (fun (i : Œπ) => PseudoMetricSpace.toHasDist.{u2} (Œ≤ i) (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} (Œ≤ i) (_inst_3 i)))) x y) (Real.sqrt (Finset.sum.{0, u1} Real Œπ Real.addCommMonoid (Finset.univ.{u1} Œπ _inst_1) (fun (i : Œπ) => HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) (Dist.dist.{u2} (Œ≤ i) (PseudoMetricSpace.toHasDist.{u2} (Œ≤ i) (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} (Œ≤ i) (_inst_3 i))) (x i) (y i)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))
but is expected to have type
  forall {Œπ : Type.{u1}} [_inst_1 : Fintype.{u1} Œπ] {Œ≤ : Œπ -> Type.{u2}} [_inst_3 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)] (x : PiLp.{u1, u2} (OfNat.ofNat.{0} ENNReal 2 (instOfNat.{0} ENNReal 2 (CanonicallyOrderedCommSemiring.toNatCast.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) Œπ Œ≤) (y : PiLp.{u1, u2} (OfNat.ofNat.{0} ENNReal 2 (instOfNat.{0} ENNReal 2 (CanonicallyOrderedCommSemiring.toNatCast.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) Œπ Œ≤), Eq.{1} Real (Dist.dist.{max u1 u2} (PiLp.{u1, u2} (OfNat.ofNat.{0} ENNReal 2 (instOfNat.{0} ENNReal 2 (CanonicallyOrderedCommSemiring.toNatCast.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) Œπ Œ≤) (PiLp.instDistPiLp.{u1, u2} (OfNat.ofNat.{0} ENNReal 2 (instOfNat.{0} ENNReal 2 (CanonicallyOrderedCommSemiring.toNatCast.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) Œπ Œ≤ _inst_1 (fun (i : Œπ) => PseudoMetricSpace.toDist.{u2} (Œ≤ i) (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} (Œ≤ i) (_inst_3 i)))) x y) (Real.sqrt (Finset.sum.{0, u1} Real Œπ Real.instAddCommMonoidReal (Finset.univ.{u1} Œπ _inst_1) (fun (i : Œπ) => HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) (Dist.dist.{u2} (Œ≤ i) (PseudoMetricSpace.toDist.{u2} (Œ≤ i) (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} (Œ≤ i) (_inst_3 i))) (x i) (y i)) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))))
Case conversion may be inaccurate. Consider using '#align pi_Lp.dist_eq_of_L2 PiLp.dist_eq_of_L2‚Çì'. -/
theorem dist_eq_of_L2 {Œ≤ : Œπ ‚Üí Type _} [‚àÄ i, SeminormedAddCommGroup (Œ≤ i)] (x y : PiLp 2 Œ≤) :
    dist x y = (‚àë i, dist (x i) (y i) ^ 2).sqrt := by
  simp_rw [dist_eq_norm, norm_eq_of_L2, Pi.sub_apply]
#align pi_Lp.dist_eq_of_L2 PiLp.dist_eq_of_L2

/- warning: pi_Lp.nndist_eq_of_L2 -> PiLp.nndist_eq_of_L2 is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align pi_Lp.nndist_eq_of_L2 PiLp.nndist_eq_of_L2‚Çì'. -/
theorem nndist_eq_of_L2 {Œ≤ : Œπ ‚Üí Type _} [‚àÄ i, SeminormedAddCommGroup (Œ≤ i)] (x y : PiLp 2 Œ≤) :
    nndist x y = (‚àë i, nndist (x i) (y i) ^ 2).sqrt :=
  Subtype.ext <| by push_cast ; exact dist_eq_of_L2 _ _
#align pi_Lp.nndist_eq_of_L2 PiLp.nndist_eq_of_L2

/- warning: pi_Lp.edist_eq_of_L2 -> PiLp.edist_eq_of_L2 is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} [_inst_1 : Fintype.{u1} Œπ] {Œ≤ : Œπ -> Type.{u2}} [_inst_3 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)] (x : PiLp.{u1, u2} (OfNat.ofNat.{0} ENNReal 2 (OfNat.mk.{0} ENNReal 2 (bit0.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))))) Œπ Œ≤) (y : PiLp.{u1, u2} (OfNat.ofNat.{0} ENNReal 2 (OfNat.mk.{0} ENNReal 2 (bit0.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))))) Œπ Œ≤), Eq.{1} ENNReal (EDist.edist.{max u1 u2} (PiLp.{u1, u2} (OfNat.ofNat.{0} ENNReal 2 (OfNat.mk.{0} ENNReal 2 (bit0.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))))) Œπ Œ≤) (PiLp.hasEdist.{u1, u2} (OfNat.ofNat.{0} ENNReal 2 (OfNat.mk.{0} ENNReal 2 (bit0.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))))) Œπ Œ≤ _inst_1 (fun (i : Œπ) => PseudoMetricSpace.toEDist.{u2} (Œ≤ i) (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} (Œ≤ i) (_inst_3 i)))) x y) (HPow.hPow.{0, 0, 0} ENNReal Real ENNReal (instHPow.{0, 0} ENNReal Real ENNReal.Real.hasPow) (Finset.sum.{0, u1} ENNReal Œπ (OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) (Finset.univ.{u1} Œπ _inst_1) (fun (i : Œπ) => HPow.hPow.{0, 0, 0} ENNReal Nat ENNReal (instHPow.{0, 0} ENNReal Nat (Monoid.Pow.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) (EDist.edist.{u2} (Œ≤ i) (PseudoMetricSpace.toEDist.{u2} (Œ≤ i) (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} (Œ≤ i) (_inst_3 i))) (x i) (y i)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))))
but is expected to have type
  forall {Œπ : Type.{u1}} [_inst_1 : Fintype.{u1} Œπ] {Œ≤ : Œπ -> Type.{u2}} [_inst_3 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)] (x : PiLp.{u1, u2} (OfNat.ofNat.{0} ENNReal 2 (instOfNat.{0} ENNReal 2 (CanonicallyOrderedCommSemiring.toNatCast.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) Œπ Œ≤) (y : PiLp.{u1, u2} (OfNat.ofNat.{0} ENNReal 2 (instOfNat.{0} ENNReal 2 (CanonicallyOrderedCommSemiring.toNatCast.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) Œπ Œ≤), Eq.{1} ENNReal (EDist.edist.{max u1 u2} (PiLp.{u1, u2} (OfNat.ofNat.{0} ENNReal 2 (instOfNat.{0} ENNReal 2 (CanonicallyOrderedCommSemiring.toNatCast.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) Œπ Œ≤) (PiLp.instEDistPiLp.{u1, u2} (OfNat.ofNat.{0} ENNReal 2 (instOfNat.{0} ENNReal 2 (CanonicallyOrderedCommSemiring.toNatCast.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) Œπ Œ≤ _inst_1 (fun (i : Œπ) => PseudoEMetricSpace.toEDist.{u2} (Œ≤ i) (PseudoMetricSpace.toPseudoEMetricSpace.{u2} (Œ≤ i) (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} (Œ≤ i) (_inst_3 i))))) x y) (HPow.hPow.{0, 0, 0} ENNReal Real ENNReal (instHPow.{0, 0} ENNReal Real ENNReal.instPowENNRealReal) (Finset.sum.{0, u1} ENNReal Œπ (LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal)) (Finset.univ.{u1} Œπ _inst_1) (fun (i : Œπ) => HPow.hPow.{0, 0, 0} ENNReal Nat ENNReal (instHPow.{0, 0} ENNReal Nat (Monoid.Pow.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))))) (EDist.edist.{u2} (Œ≤ i) (PseudoEMetricSpace.toEDist.{u2} (Œ≤ i) (PseudoMetricSpace.toPseudoEMetricSpace.{u2} (Œ≤ i) (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} (Œ≤ i) (_inst_3 i)))) (x i) (y i)) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))))
Case conversion may be inaccurate. Consider using '#align pi_Lp.edist_eq_of_L2 PiLp.edist_eq_of_L2‚Çì'. -/
theorem edist_eq_of_L2 {Œ≤ : Œπ ‚Üí Type _} [‚àÄ i, SeminormedAddCommGroup (Œ≤ i)] (x y : PiLp 2 Œ≤) :
    edist x y = (‚àë i, edist (x i) (y i) ^ 2) ^ (1 / 2 : ‚Ñù) := by simp [PiLp.edist_eq_sum]
#align pi_Lp.edist_eq_of_L2 PiLp.edist_eq_of_L2

variable [NormedField ùïú] [NormedField ùïú']

/- warning: pi_Lp.normed_space -> PiLp.normedSpace is a dubious translation:
lean 3 declaration is
  forall (p : ENNReal) (ùïú : Type.{u1}) {Œπ : Type.{u2}} (Œ≤ : Œπ -> Type.{u3}) [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] [_inst_3 : NormedField.{u1} ùïú] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u3} (Œ≤ i)] [_inst_6 : forall (i : Œπ), NormedSpace.{u1, u3} ùïú (Œ≤ i) _inst_3 (_inst_5 i)], NormedSpace.{u1, max u2 u3} ùïú (PiLp.{u2, u3} p Œπ Œ≤) _inst_3 (PiLp.seminormedAddCommGroup.{u2, u3} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i))
but is expected to have type
  forall (p : ENNReal) (ùïú : Type.{u1}) {Œπ : Type.{u2}} (Œ≤ : Œπ -> Type.{u3}) [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] [_inst_3 : NormedField.{u1} ùïú] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u3} (Œ≤ i)] [_inst_6 : forall (i : Œπ), NormedSpace.{u1, u3} ùïú (Œ≤ i) _inst_3 (_inst_5 i)], NormedSpace.{u1, max u3 u2} ùïú (PiLp.{u2, u3} p Œπ Œ≤) _inst_3 (PiLp.seminormedAddCommGroup.{u2, u3} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i))
Case conversion may be inaccurate. Consider using '#align pi_Lp.normed_space PiLp.normedSpace‚Çì'. -/
/-- The product of finitely many normed spaces is a normed space, with the `L^p` norm. -/
instance normedSpace [‚àÄ i, SeminormedAddCommGroup (Œ≤ i)] [‚àÄ i, NormedSpace ùïú (Œ≤ i)] :
    NormedSpace ùïú (PiLp p Œ≤) :=
  { Pi.module Œπ Œ≤ ùïú with
    norm_smul_le := fun c f => by
      rcases p.dichotomy with (rfl | hp)
      ¬∑ letI : Module ùïú (PiLp ‚àû Œ≤) := Pi.module Œπ Œ≤ ùïú
        suffices ‚Äñc ‚Ä¢ f‚Äñ‚Çä = ‚Äñc‚Äñ‚Çä * ‚Äñf‚Äñ‚Çä by exact_mod_cast NNReal.coe_mono this.le
        simpa only [nnnorm_eq_csupr, NNReal.mul_iSup, ‚Üê nnnorm_smul]
      ¬∑ have : p.to_real * (1 / p.to_real) = 1 := mul_div_cancel' 1 (zero_lt_one.trans_le hp).ne'
        simp only [norm_eq_sum (zero_lt_one.trans_le hp), norm_smul, mul_rpow, norm_nonneg, ‚Üê
          Finset.mul_sum, Pi.smul_apply]
        rw [mul_rpow (rpow_nonneg_of_nonneg (norm_nonneg _) _), ‚Üê rpow_mul (norm_nonneg _), this,
          rpow_one]
        exact Finset.sum_nonneg fun i hi => rpow_nonneg_of_nonneg (norm_nonneg _) _ }
#align pi_Lp.normed_space PiLp.normedSpace

/- warning: pi_Lp.is_scalar_tower -> PiLp.isScalarTower is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align pi_Lp.is_scalar_tower PiLp.isScalarTower‚Çì'. -/
instance isScalarTower [‚àÄ i, SeminormedAddCommGroup (Œ≤ i)] [SMul ùïú ùïú'] [‚àÄ i, NormedSpace ùïú (Œ≤ i)]
    [‚àÄ i, NormedSpace ùïú' (Œ≤ i)] [‚àÄ i, IsScalarTower ùïú ùïú' (Œ≤ i)] : IsScalarTower ùïú ùïú' (PiLp p Œ≤) :=
  Pi.isScalarTower
#align pi_Lp.is_scalar_tower PiLp.isScalarTower

/- warning: pi_Lp.smul_comm_class -> PiLp.smulCommClass is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align pi_Lp.smul_comm_class PiLp.smulCommClass‚Çì'. -/
instance smulCommClass [‚àÄ i, SeminormedAddCommGroup (Œ≤ i)] [‚àÄ i, NormedSpace ùïú (Œ≤ i)]
    [‚àÄ i, NormedSpace ùïú' (Œ≤ i)] [‚àÄ i, SMulCommClass ùïú ùïú' (Œ≤ i)] : SMulCommClass ùïú ùïú' (PiLp p Œ≤) :=
  Pi.smulCommClass
#align pi_Lp.smul_comm_class PiLp.smulCommClass

/- warning: pi_Lp.finite_dimensional -> PiLp.finiteDimensional is a dubious translation:
lean 3 declaration is
  forall (p : ENNReal) (ùïú : Type.{u1}) {Œπ : Type.{u2}} (Œ≤ : Œπ -> Type.{u3}) [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] [_inst_3 : NormedField.{u1} ùïú] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u3} (Œ≤ i)] [_inst_6 : forall (i : Œπ), NormedSpace.{u1, u3} ùïú (Œ≤ i) _inst_3 (_inst_5 i)] [I : forall (i : Œπ), FiniteDimensional.{u1, u3} ùïú (Œ≤ i) (NormedDivisionRing.toDivisionRing.{u1} ùïú (NormedField.toNormedDivisionRing.{u1} ùïú _inst_3)) (SeminormedAddCommGroup.toAddCommGroup.{u3} (Œ≤ i) (_inst_5 i)) (NormedSpace.toModule.{u1, u3} ùïú (Œ≤ i) _inst_3 (_inst_5 i) (_inst_6 i))], FiniteDimensional.{u1, max u2 u3} ùïú (PiLp.{u2, u3} p Œπ Œ≤) (NormedDivisionRing.toDivisionRing.{u1} ùïú (NormedField.toNormedDivisionRing.{u1} ùïú _inst_3)) (SeminormedAddCommGroup.toAddCommGroup.{max u2 u3} (PiLp.{u2, u3} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u2, u3} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i))) (NormedSpace.toModule.{u1, max u2 u3} ùïú (PiLp.{u2, u3} p Œπ Œ≤) _inst_3 (PiLp.seminormedAddCommGroup.{u2, u3} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i)) (PiLp.normedSpace.{u1, u2, u3} p ùïú Œπ Œ≤ _inst_1 _inst_2 _inst_3 (fun (i : Œπ) => _inst_5 i) (fun (i : Œπ) => _inst_6 i)))
but is expected to have type
  forall (p : ENNReal) (ùïú : Type.{u1}) {Œπ : Type.{u2}} (Œ≤ : Œπ -> Type.{u3}) [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] [_inst_3 : NormedField.{u1} ùïú] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u3} (Œ≤ i)] [_inst_6 : forall (i : Œπ), NormedSpace.{u1, u3} ùïú (Œ≤ i) _inst_3 (_inst_5 i)] [I : forall (i : Œπ), FiniteDimensional.{u1, u3} ùïú (Œ≤ i) (NormedDivisionRing.toDivisionRing.{u1} ùïú (NormedField.toNormedDivisionRing.{u1} ùïú _inst_3)) (SeminormedAddCommGroup.toAddCommGroup.{u3} (Œ≤ i) (_inst_5 i)) (NormedSpace.toModule.{u1, u3} ùïú (Œ≤ i) _inst_3 (_inst_5 i) (_inst_6 i))], FiniteDimensional.{u1, max u3 u2} ùïú (PiLp.{u2, u3} p Œπ Œ≤) (NormedDivisionRing.toDivisionRing.{u1} ùïú (NormedField.toNormedDivisionRing.{u1} ùïú _inst_3)) (SeminormedAddCommGroup.toAddCommGroup.{max u2 u3} (PiLp.{u2, u3} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u2, u3} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i))) (PiLp.module.{u1, u2, u3} p ùïú Œπ Œ≤ _inst_1 _inst_2 _inst_3 (fun (i : Œπ) => _inst_5 i) (fun (i : Œπ) => _inst_6 i))
Case conversion may be inaccurate. Consider using '#align pi_Lp.finite_dimensional PiLp.finiteDimensional‚Çì'. -/
instance finiteDimensional [‚àÄ i, SeminormedAddCommGroup (Œ≤ i)] [‚àÄ i, NormedSpace ùïú (Œ≤ i)]
    [I : ‚àÄ i, FiniteDimensional ùïú (Œ≤ i)] : FiniteDimensional ùïú (PiLp p Œ≤) :=
  FiniteDimensional.finiteDimensional_pi' _ _
#align pi_Lp.finite_dimensional PiLp.finiteDimensional

/- Register simplification lemmas for the applications of `pi_Lp` elements, as the usual lemmas
for Pi types will not trigger. -/
variable {ùïú ùïú' p Œ±} [‚àÄ i, SeminormedAddCommGroup (Œ≤ i)] [‚àÄ i, NormedSpace ùïú (Œ≤ i)] (c : ùïú)

variable (x y : PiLp p Œ≤) (x' y' : ‚àÄ i, Œ≤ i) (i : Œπ)

/- warning: pi_Lp.zero_apply -> PiLp.zero_apply is a dubious translation:
lean 3 declaration is
  forall {p : ENNReal} {Œπ : Type.{u1}} (Œ≤ : Œπ -> Type.{u2}) [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)] (i : Œπ), Eq.{succ u2} (Œ≤ i) (Zero.zero.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (AddZeroClass.toHasZero.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (AddMonoid.toAddZeroClass.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SubNegMonoid.toAddMonoid.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (AddGroup.toSubNegMonoid.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddGroup.toAddGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u1, u2} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i)))))))) i) (OfNat.ofNat.{u2} (Œ≤ i) 0 (OfNat.mk.{u2} (Œ≤ i) 0 (Zero.zero.{u2} (Œ≤ i) (AddZeroClass.toHasZero.{u2} (Œ≤ i) (AddMonoid.toAddZeroClass.{u2} (Œ≤ i) (SubNegMonoid.toAddMonoid.{u2} (Œ≤ i) (AddGroup.toSubNegMonoid.{u2} (Œ≤ i) (SeminormedAddGroup.toAddGroup.{u2} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} (Œ≤ i) (_inst_5 i))))))))))
but is expected to have type
  forall {p : ENNReal} {Œπ : Type.{u1}} (Œ≤ : Œπ -> Type.{u2}) [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)] (i : Œπ), Eq.{succ u2} (Œ≤ i) (OfNat.ofNat.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) 0 (Zero.toOfNat0.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (NegZeroClass.toZero.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SubNegZeroMonoid.toNegZeroClass.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SubtractionMonoid.toSubNegZeroMonoid.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SubtractionCommMonoid.toSubtractionMonoid.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (AddCommGroup.toDivisionAddCommMonoid.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddCommGroup.toAddCommGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u1, u2} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i))))))))) i) (OfNat.ofNat.{u2} (Œ≤ i) 0 (Zero.toOfNat0.{u2} (Œ≤ i) (NegZeroClass.toZero.{u2} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u2} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u2} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u2} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u2} (Œ≤ i) (_inst_5 i)))))))))
Case conversion may be inaccurate. Consider using '#align pi_Lp.zero_apply PiLp.zero_apply‚Çì'. -/
@[simp]
theorem zero_apply : (0 : PiLp p Œ≤) i = 0 :=
  rfl
#align pi_Lp.zero_apply PiLp.zero_apply

/- warning: pi_Lp.add_apply -> PiLp.add_apply is a dubious translation:
lean 3 declaration is
  forall {p : ENNReal} {Œπ : Type.{u1}} (Œ≤ : Œπ -> Type.{u2}) [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)] (x : PiLp.{u1, u2} p Œπ Œ≤) (y : PiLp.{u1, u2} p Œπ Œ≤) (i : Œπ), Eq.{succ u2} (Œ≤ i) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.{u1, u2} p Œπ Œ≤) (instHAdd.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (AddZeroClass.toHasAdd.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (AddMonoid.toAddZeroClass.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SubNegMonoid.toAddMonoid.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (AddGroup.toSubNegMonoid.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddGroup.toAddGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u1, u2} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i))))))))) x y i) (HAdd.hAdd.{u2, u2, u2} (Œ≤ i) (Œ≤ i) (Œ≤ i) (instHAdd.{u2} (Œ≤ i) (AddZeroClass.toHasAdd.{u2} (Œ≤ i) (AddMonoid.toAddZeroClass.{u2} (Œ≤ i) (SubNegMonoid.toAddMonoid.{u2} (Œ≤ i) (AddGroup.toSubNegMonoid.{u2} (Œ≤ i) (SeminormedAddGroup.toAddGroup.{u2} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} (Œ≤ i) (_inst_5 i)))))))) (x i) (y i))
but is expected to have type
  forall {p : ENNReal} {Œπ : Type.{u1}} (Œ≤ : Œπ -> Type.{u2}) [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)] (x : PiLp.{u1, u2} p Œπ Œ≤) (y : PiLp.{u1, u2} p Œπ Œ≤) (i : Œπ), Eq.{succ u2} (Œ≤ i) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.{u1, u2} p Œπ Œ≤) (instHAdd.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (AddZeroClass.toAdd.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (AddMonoid.toAddZeroClass.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SubNegMonoid.toAddMonoid.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (AddGroup.toSubNegMonoid.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddGroup.toAddGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u1, u2} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i))))))))) x y i) (HAdd.hAdd.{u2, u2, u2} (Œ≤ i) (Œ≤ i) (Œ≤ i) (instHAdd.{u2} (Œ≤ i) (AddZeroClass.toAdd.{u2} (Œ≤ i) (AddMonoid.toAddZeroClass.{u2} (Œ≤ i) (SubNegMonoid.toAddMonoid.{u2} (Œ≤ i) (AddGroup.toSubNegMonoid.{u2} (Œ≤ i) (SeminormedAddGroup.toAddGroup.{u2} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} (Œ≤ i) (_inst_5 i)))))))) (x i) (y i))
Case conversion may be inaccurate. Consider using '#align pi_Lp.add_apply PiLp.add_apply‚Çì'. -/
@[simp]
theorem add_apply : (x + y) i = x i + y i :=
  rfl
#align pi_Lp.add_apply PiLp.add_apply

/- warning: pi_Lp.sub_apply -> PiLp.sub_apply is a dubious translation:
lean 3 declaration is
  forall {p : ENNReal} {Œπ : Type.{u1}} (Œ≤ : Œπ -> Type.{u2}) [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)] (x : PiLp.{u1, u2} p Œπ Œ≤) (y : PiLp.{u1, u2} p Œπ Œ≤) (i : Œπ), Eq.{succ u2} (Œ≤ i) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.{u1, u2} p Œπ Œ≤) (instHSub.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SubNegMonoid.toHasSub.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (AddGroup.toSubNegMonoid.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddGroup.toAddGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u1, u2} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i))))))) x y i) (HSub.hSub.{u2, u2, u2} (Œ≤ i) (Œ≤ i) (Œ≤ i) (instHSub.{u2} (Œ≤ i) (SubNegMonoid.toHasSub.{u2} (Œ≤ i) (AddGroup.toSubNegMonoid.{u2} (Œ≤ i) (SeminormedAddGroup.toAddGroup.{u2} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} (Œ≤ i) (_inst_5 i)))))) (x i) (y i))
but is expected to have type
  forall {p : ENNReal} {Œπ : Type.{u1}} (Œ≤ : Œπ -> Type.{u2}) [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)] (x : PiLp.{u1, u2} p Œπ Œ≤) (y : PiLp.{u1, u2} p Œπ Œ≤) (i : Œπ), Eq.{succ u2} (Œ≤ i) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.{u1, u2} p Œπ Œ≤) (instHSub.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SubNegMonoid.toSub.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (AddGroup.toSubNegMonoid.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddGroup.toAddGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u1, u2} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i))))))) x y i) (HSub.hSub.{u2, u2, u2} (Œ≤ i) (Œ≤ i) (Œ≤ i) (instHSub.{u2} (Œ≤ i) (SubNegMonoid.toSub.{u2} (Œ≤ i) (AddGroup.toSubNegMonoid.{u2} (Œ≤ i) (SeminormedAddGroup.toAddGroup.{u2} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} (Œ≤ i) (_inst_5 i)))))) (x i) (y i))
Case conversion may be inaccurate. Consider using '#align pi_Lp.sub_apply PiLp.sub_apply‚Çì'. -/
@[simp]
theorem sub_apply : (x - y) i = x i - y i :=
  rfl
#align pi_Lp.sub_apply PiLp.sub_apply

/- warning: pi_Lp.smul_apply -> PiLp.smul_apply is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align pi_Lp.smul_apply PiLp.smul_apply‚Çì'. -/
@[simp]
theorem smul_apply : (c ‚Ä¢ x) i = c ‚Ä¢ x i :=
  rfl
#align pi_Lp.smul_apply PiLp.smul_apply

/- warning: pi_Lp.neg_apply -> PiLp.neg_apply is a dubious translation:
lean 3 declaration is
  forall {p : ENNReal} {Œπ : Type.{u1}} (Œ≤ : Œπ -> Type.{u2}) [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)] (x : PiLp.{u1, u2} p Œπ Œ≤) (i : Œπ), Eq.{succ u2} (Œ≤ i) (Neg.neg.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SubNegMonoid.toHasNeg.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (AddGroup.toSubNegMonoid.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddGroup.toAddGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u1, u2} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i)))))) x i) (Neg.neg.{u2} (Œ≤ i) (SubNegMonoid.toHasNeg.{u2} (Œ≤ i) (AddGroup.toSubNegMonoid.{u2} (Œ≤ i) (SeminormedAddGroup.toAddGroup.{u2} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} (Œ≤ i) (_inst_5 i))))) (x i))
but is expected to have type
  forall {p : ENNReal} {Œπ : Type.{u1}} (Œ≤ : Œπ -> Type.{u2}) [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)] (x : PiLp.{u1, u2} p Œπ Œ≤) (i : Œπ), Eq.{succ u2} (Œ≤ i) (Neg.neg.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (NegZeroClass.toNeg.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SubNegZeroMonoid.toNegZeroClass.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SubtractionMonoid.toSubNegZeroMonoid.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SubtractionCommMonoid.toSubtractionMonoid.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (AddCommGroup.toDivisionAddCommMonoid.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddCommGroup.toAddCommGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u1, u2} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i)))))))) x i) (Neg.neg.{u2} (Œ≤ i) (NegZeroClass.toNeg.{u2} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u2} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u2} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u2} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u2} (Œ≤ i) (_inst_5 i))))))) (x i))
Case conversion may be inaccurate. Consider using '#align pi_Lp.neg_apply PiLp.neg_apply‚Çì'. -/
@[simp]
theorem neg_apply : (-x) i = -x i :=
  rfl
#align pi_Lp.neg_apply PiLp.neg_apply

/- warning: pi_Lp.equiv‚Çó·µ¢ -> PiLp.equiv‚Çó·µ¢ is a dubious translation:
lean 3 declaration is
  forall {ùïú : Type.{u1}} {Œπ : Type.{u2}} (Œ≤ : Œπ -> Type.{u3}) [_inst_1 : Fintype.{u2} Œπ] [_inst_3 : NormedField.{u1} ùïú] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u3} (Œ≤ i)] [_inst_6 : forall (i : Œπ), NormedSpace.{u1, u3} ùïú (Œ≤ i) _inst_3 (_inst_5 i)], LinearIsometryEquiv.{u1, u1, max u2 u3, max u2 u3} ùïú ùïú (Ring.toSemiring.{u1} ùïú (NormedRing.toRing.{u1} ùïú (NormedCommRing.toNormedRing.{u1} ùïú (NormedField.toNormedCommRing.{u1} ùïú _inst_3)))) (Ring.toSemiring.{u1} ùïú (NormedRing.toRing.{u1} ùïú (NormedCommRing.toNormedRing.{u1} ùïú (NormedField.toNormedCommRing.{u1} ùïú _inst_3)))) (RingHom.id.{u1} ùïú (Semiring.toNonAssocSemiring.{u1} ùïú (Ring.toSemiring.{u1} ùïú (NormedRing.toRing.{u1} ùïú (NormedCommRing.toNormedRing.{u1} ùïú (NormedField.toNormedCommRing.{u1} ùïú _inst_3)))))) (RingHom.id.{u1} ùïú (Semiring.toNonAssocSemiring.{u1} ùïú (Ring.toSemiring.{u1} ùïú (NormedRing.toRing.{u1} ùïú (NormedCommRing.toNormedRing.{u1} ùïú (NormedField.toNormedCommRing.{u1} ùïú _inst_3)))))) (PiLp.equiv‚Çó·µ¢._proof_1.{u1} ùïú _inst_3) (PiLp.equiv‚Çó·µ¢._proof_2.{u1} ùïú _inst_3) (PiLp.{u2, u3} (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.seminormedAddCommGroup.{u2, u3} (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Œπ Œ≤ _inst_1 fact_one_le_top_ennreal (fun (i : Œπ) => _inst_5 i)) (Pi.seminormedAddCommGroup.{u2, u3} Œπ (fun (i : Œπ) => Œ≤ i) _inst_1 (fun (i : Œπ) => _inst_5 i)) (NormedSpace.toModule.{u1, max u2 u3} ùïú (PiLp.{u2, u3} (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Œπ Œ≤) _inst_3 (PiLp.seminormedAddCommGroup.{u2, u3} (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Œπ Œ≤ _inst_1 fact_one_le_top_ennreal (fun (i : Œπ) => _inst_5 i)) (PiLp.normedSpace.{u1, u2, u3} (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) ùïú Œπ Œ≤ _inst_1 fact_one_le_top_ennreal _inst_3 (fun (i : Œπ) => _inst_5 i) (fun (i : Œπ) => _inst_6 i))) (Pi.module.{u2, u3, u1} Œπ (fun (i : Œπ) => Œ≤ i) ùïú (Ring.toSemiring.{u1} ùïú (NormedRing.toRing.{u1} ùïú (NormedCommRing.toNormedRing.{u1} ùïú (NormedField.toNormedCommRing.{u1} ùïú _inst_3)))) (fun (i : Œπ) => AddCommGroup.toAddCommMonoid.{u3} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u3} (Œ≤ i) (_inst_5 i))) (fun (i : Œπ) => NormedSpace.toModule.{u1, u3} ùïú (Œ≤ i) _inst_3 (_inst_5 i) (_inst_6 i)))
but is expected to have type
  forall {ùïú : Type.{u1}} {Œπ : Type.{u2}} (Œ≤ : Œπ -> Type.{u3}) [_inst_1 : Fintype.{u2} Œπ] [_inst_3 : NormedField.{u1} ùïú] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u3} (Œ≤ i)] [_inst_6 : forall (i : Œπ), NormedSpace.{u1, u3} ùïú (Œ≤ i) _inst_3 (_inst_5 i)], LinearIsometryEquiv.{u1, u1, max u3 u2, max u2 u3} ùïú ùïú (DivisionSemiring.toSemiring.{u1} ùïú (Semifield.toDivisionSemiring.{u1} ùïú (Field.toSemifield.{u1} ùïú (NormedField.toField.{u1} ùïú _inst_3)))) (DivisionSemiring.toSemiring.{u1} ùïú (Semifield.toDivisionSemiring.{u1} ùïú (Field.toSemifield.{u1} ùïú (NormedField.toField.{u1} ùïú _inst_3)))) (RingHom.id.{u1} ùïú (Semiring.toNonAssocSemiring.{u1} ùïú (DivisionSemiring.toSemiring.{u1} ùïú (Semifield.toDivisionSemiring.{u1} ùïú (Field.toSemifield.{u1} ùïú (NormedField.toField.{u1} ùïú _inst_3)))))) (RingHom.id.{u1} ùïú (Semiring.toNonAssocSemiring.{u1} ùïú (DivisionSemiring.toSemiring.{u1} ùïú (Semifield.toDivisionSemiring.{u1} ùïú (Field.toSemifield.{u1} ùïú (NormedField.toField.{u1} ùïú _inst_3)))))) (RingHomInvPair.ids.{u1} ùïú (DivisionSemiring.toSemiring.{u1} ùïú (Semifield.toDivisionSemiring.{u1} ùïú (Field.toSemifield.{u1} ùïú (NormedField.toField.{u1} ùïú _inst_3))))) (RingHomInvPair.ids.{u1} ùïú (DivisionSemiring.toSemiring.{u1} ùïú (Semifield.toDivisionSemiring.{u1} ùïú (Field.toSemifield.{u1} ùïú (NormedField.toField.{u1} ùïú _inst_3))))) (PiLp.{u2, u3} (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))) Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.seminormedAddCommGroup.{u2, u3} (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))) Œπ Œ≤ _inst_1 fact_one_le_top_ennreal (fun (i : Œπ) => _inst_5 i)) (Pi.seminormedAddCommGroup.{u2, u3} Œπ (fun (i : Œπ) => Œ≤ i) _inst_1 (fun (i : Œπ) => _inst_5 i)) (PiLp.module.{u1, u2, u3} (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))) ùïú Œπ Œ≤ _inst_1 fact_one_le_top_ennreal _inst_3 (fun (i : Œπ) => _inst_5 i) (fun (i : Œπ) => _inst_6 i)) (Pi.module.{u2, u3, u1} Œπ (fun (i : Œπ) => Œ≤ i) ùïú (DivisionSemiring.toSemiring.{u1} ùïú (Semifield.toDivisionSemiring.{u1} ùïú (Field.toSemifield.{u1} ùïú (NormedField.toField.{u1} ùïú _inst_3)))) (fun (i : Œπ) => AddCommGroup.toAddCommMonoid.{u3} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u3} (Œ≤ i) (_inst_5 i))) (fun (i : Œπ) => NormedSpace.toModule.{u1, u3} ùïú (Œ≤ i) _inst_3 (_inst_5 i) (_inst_6 i)))
Case conversion may be inaccurate. Consider using '#align pi_Lp.equiv‚Çó·µ¢ PiLp.equiv‚Çó·µ¢‚Çì'. -/
/-- The canonical map `pi_Lp.equiv` between `pi_Lp ‚àû Œ≤` and `Œ† i, Œ≤ i` as a linear isometric
equivalence. -/
def equiv‚Çó·µ¢ : PiLp ‚àû Œ≤ ‚âÉ‚Çó·µ¢[ùïú] ‚àÄ i, Œ≤ i :=
  { PiLp.equiv ‚àû Œ≤ with
    map_add' := fun f g => rfl
    map_smul' := fun c f => rfl
    norm_map' := fun f =>
      by
      suffices (finset.univ.sup fun i => ‚Äñf i‚Äñ‚Çä) = ‚®Ü i, ‚Äñf i‚Äñ‚Çä by
        simpa only [NNReal.coe_iSup] using congr_arg (coe : ‚Ñù‚â•0 ‚Üí ‚Ñù) this
      refine'
        antisymm (Finset.sup_le fun i _ => le_ciSup (Fintype.bddAbove_range fun i => ‚Äñf i‚Äñ‚Çä) _) _
      cases isEmpty_or_nonempty Œπ
      ¬∑ simp only [ciSup_of_empty, Finset.univ_eq_empty, Finset.sup_empty]
      ¬∑ exact ciSup_le fun i => Finset.le_sup (Finset.mem_univ i) }
#align pi_Lp.equiv‚Çó·µ¢ PiLp.equiv‚Çó·µ¢

variable {Œπ' : Type _}

variable [Fintype Œπ']

variable (p ùïú) (E : Type _) [NormedAddCommGroup E] [NormedSpace ùïú E]

/- warning: linear_isometry_equiv.pi_Lp_congr_left -> LinearIsometryEquiv.piLpCongrLeft is a dubious translation:
lean 3 declaration is
  forall (p : ENNReal) (ùïú : Type.{u1}) {Œπ : Type.{u2}} [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] [_inst_3 : NormedField.{u1} ùïú] {Œπ' : Type.{u3}} [_inst_7 : Fintype.{u3} Œπ'] (E : Type.{u4}) [_inst_8 : NormedAddCommGroup.{u4} E] [_inst_9 : NormedSpace.{u1, u4} ùïú E _inst_3 (NormedAddCommGroup.toSeminormedAddCommGroup.{u4} E _inst_8)], (Equiv.{succ u2, succ u3} Œπ Œπ') -> (LinearIsometryEquiv.{u1, u1, max u2 u4, max u3 u4} ùïú ùïú (Ring.toSemiring.{u1} ùïú (NormedRing.toRing.{u1} ùïú (NormedCommRing.toNormedRing.{u1} ùïú (NormedField.toNormedCommRing.{u1} ùïú _inst_3)))) (Ring.toSemiring.{u1} ùïú (NormedRing.toRing.{u1} ùïú (NormedCommRing.toNormedRing.{u1} ùïú (NormedField.toNormedCommRing.{u1} ùïú _inst_3)))) (RingHom.id.{u1} ùïú (Semiring.toNonAssocSemiring.{u1} ùïú (Ring.toSemiring.{u1} ùïú (NormedRing.toRing.{u1} ùïú (NormedCommRing.toNormedRing.{u1} ùïú (NormedField.toNormedCommRing.{u1} ùïú _inst_3)))))) (RingHom.id.{u1} ùïú (Semiring.toNonAssocSemiring.{u1} ùïú (Ring.toSemiring.{u1} ùïú (NormedRing.toRing.{u1} ùïú (NormedCommRing.toNormedRing.{u1} ùïú (NormedField.toNormedCommRing.{u1} ùïú _inst_3)))))) (LinearIsometryEquiv.piLpCongrLeft._proof_1.{u1} ùïú _inst_3) (LinearIsometryEquiv.piLpCongrLeft._proof_2.{u1} ùïú _inst_3) (PiLp.{u2, u4} p Œπ (fun (i : Œπ) => E)) (PiLp.{u3, u4} p Œπ' (fun (i : Œπ') => E)) (PiLp.seminormedAddCommGroup.{u2, u4} p Œπ (fun (i : Œπ) => E) _inst_1 _inst_2 (fun (i : Œπ) => NormedAddCommGroup.toSeminormedAddCommGroup.{u4} E _inst_8)) (PiLp.seminormedAddCommGroup.{u3, u4} p Œπ' (fun (i : Œπ') => E) _inst_7 _inst_2 (fun (i : Œπ') => NormedAddCommGroup.toSeminormedAddCommGroup.{u4} E _inst_8)) (NormedSpace.toModule.{u1, max u2 u4} ùïú (PiLp.{u2, u4} p Œπ (fun (i : Œπ) => E)) _inst_3 (PiLp.seminormedAddCommGroup.{u2, u4} p Œπ (fun (i : Œπ) => E) _inst_1 _inst_2 (fun (i : Œπ) => NormedAddCommGroup.toSeminormedAddCommGroup.{u4} E _inst_8)) (PiLp.normedSpace.{u1, u2, u4} p ùïú Œπ (fun (i : Œπ) => E) _inst_1 _inst_2 _inst_3 (fun (i : Œπ) => NormedAddCommGroup.toSeminormedAddCommGroup.{u4} E _inst_8) (fun (i : Œπ) => _inst_9))) (NormedSpace.toModule.{u1, max u3 u4} ùïú (PiLp.{u3, u4} p Œπ' (fun (i : Œπ') => E)) _inst_3 (PiLp.seminormedAddCommGroup.{u3, u4} p Œπ' (fun (i : Œπ') => E) _inst_7 _inst_2 (fun (i : Œπ') => NormedAddCommGroup.toSeminormedAddCommGroup.{u4} E _inst_8)) (PiLp.normedSpace.{u1, u3, u4} p ùïú Œπ' (fun (i : Œπ') => E) _inst_7 _inst_2 _inst_3 (fun (i : Œπ') => NormedAddCommGroup.toSeminormedAddCommGroup.{u4} E _inst_8) (fun (i : Œπ') => _inst_9))))
but is expected to have type
  forall (p : ENNReal) (ùïú : Type.{u1}) {Œπ : Type.{u2}} [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] [_inst_3 : NormedField.{u1} ùïú] {Œπ' : Type.{u3}} [_inst_7 : Fintype.{u3} Œπ'] (E : Type.{u4}) [_inst_8 : NormedAddCommGroup.{u4} E] [_inst_9 : NormedSpace.{u1, u4} ùïú E _inst_3 (NormedAddCommGroup.toSeminormedAddCommGroup.{u4} E _inst_8)], (Equiv.{succ u2, succ u3} Œπ Œπ') -> (LinearIsometryEquiv.{u1, u1, max u4 u2, max u4 u3} ùïú ùïú (DivisionSemiring.toSemiring.{u1} ùïú (Semifield.toDivisionSemiring.{u1} ùïú (Field.toSemifield.{u1} ùïú (NormedField.toField.{u1} ùïú _inst_3)))) (DivisionSemiring.toSemiring.{u1} ùïú (Semifield.toDivisionSemiring.{u1} ùïú (Field.toSemifield.{u1} ùïú (NormedField.toField.{u1} ùïú _inst_3)))) (RingHom.id.{u1} ùïú (Semiring.toNonAssocSemiring.{u1} ùïú (DivisionSemiring.toSemiring.{u1} ùïú (Semifield.toDivisionSemiring.{u1} ùïú (Field.toSemifield.{u1} ùïú (NormedField.toField.{u1} ùïú _inst_3)))))) (RingHom.id.{u1} ùïú (Semiring.toNonAssocSemiring.{u1} ùïú (DivisionSemiring.toSemiring.{u1} ùïú (Semifield.toDivisionSemiring.{u1} ùïú (Field.toSemifield.{u1} ùïú (NormedField.toField.{u1} ùïú _inst_3)))))) (RingHomInvPair.ids.{u1} ùïú (DivisionSemiring.toSemiring.{u1} ùïú (Semifield.toDivisionSemiring.{u1} ùïú (Field.toSemifield.{u1} ùïú (NormedField.toField.{u1} ùïú _inst_3))))) (RingHomInvPair.ids.{u1} ùïú (DivisionSemiring.toSemiring.{u1} ùïú (Semifield.toDivisionSemiring.{u1} ùïú (Field.toSemifield.{u1} ùïú (NormedField.toField.{u1} ùïú _inst_3))))) (PiLp.{u2, u4} p Œπ (fun (i : Œπ) => E)) (PiLp.{u3, u4} p Œπ' (fun (i : Œπ') => E)) (PiLp.seminormedAddCommGroup.{u2, u4} p Œπ (fun (i : Œπ) => E) _inst_1 _inst_2 (fun (i : Œπ) => NormedAddCommGroup.toSeminormedAddCommGroup.{u4} E _inst_8)) (PiLp.seminormedAddCommGroup.{u3, u4} p Œπ' (fun (i : Œπ') => E) _inst_7 _inst_2 (fun (i : Œπ') => NormedAddCommGroup.toSeminormedAddCommGroup.{u4} E _inst_8)) (PiLp.module.{u1, u2, u4} p ùïú Œπ (fun (x._@.Mathlib.Analysis.NormedSpace.PiLp._hyg.8359 : Œπ) => E) _inst_1 _inst_2 _inst_3 (fun (i : Œπ) => NormedAddCommGroup.toSeminormedAddCommGroup.{u4} E _inst_8) (fun (i : Œπ) => _inst_9)) (PiLp.module.{u1, u3, u4} p ùïú Œπ' (fun (x._@.Mathlib.Analysis.NormedSpace.PiLp._hyg.8368 : Œπ') => E) _inst_7 _inst_2 _inst_3 (fun (i : Œπ') => NormedAddCommGroup.toSeminormedAddCommGroup.{u4} E _inst_8) (fun (i : Œπ') => _inst_9)))
Case conversion may be inaccurate. Consider using '#align linear_isometry_equiv.pi_Lp_congr_left LinearIsometryEquiv.piLpCongrLeft‚Çì'. -/
/-- An equivalence of finite domains induces a linearly isometric equivalence of finitely supported
functions-/
def LinearIsometryEquiv.piLpCongrLeft (e : Œπ ‚âÉ Œπ') :
    (PiLp p fun i : Œπ => E) ‚âÉ‚Çó·µ¢[ùïú] PiLp p fun i : Œπ' => E
    where
  toLinearEquiv := LinearEquiv.piCongrLeft' ùïú (fun i : Œπ => E) e
  norm_map' x := by
    rcases p.dichotomy with (rfl | h)
    ¬∑ simp_rw [norm_eq_csupr, LinearEquiv.piCongrLeft'_apply ùïú (fun i : Œπ => E) e x _]
      exact e.symm.supr_congr fun i => rfl
    ¬∑ simp only [norm_eq_sum (zero_lt_one.trans_le h)]
      simp_rw [LinearEquiv.piCongrLeft'_apply ùïú (fun i : Œπ => E) e x _]
      congr
      exact Fintype.sum_equiv e.symm _ _ fun i => rfl
#align linear_isometry_equiv.pi_Lp_congr_left LinearIsometryEquiv.piLpCongrLeft

variable {p ùïú E}

/- warning: linear_isometry_equiv.pi_Lp_congr_left_apply -> LinearIsometryEquiv.piLpCongrLeft_apply is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align linear_isometry_equiv.pi_Lp_congr_left_apply LinearIsometryEquiv.piLpCongrLeft_apply‚Çì'. -/
@[simp]
theorem LinearIsometryEquiv.piLpCongrLeft_apply (e : Œπ ‚âÉ Œπ') (v : PiLp p fun i : Œπ => E) :
    LinearIsometryEquiv.piLpCongrLeft p ùïú E e v = Equiv.piCongrLeft' (fun i : Œπ => E) e v :=
  rfl
#align linear_isometry_equiv.pi_Lp_congr_left_apply LinearIsometryEquiv.piLpCongrLeft_apply

/- warning: linear_isometry_equiv.pi_Lp_congr_left_symm -> LinearIsometryEquiv.piLpCongrLeft_symm is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align linear_isometry_equiv.pi_Lp_congr_left_symm LinearIsometryEquiv.piLpCongrLeft_symm‚Çì'. -/
@[simp]
theorem LinearIsometryEquiv.piLpCongrLeft_symm (e : Œπ ‚âÉ Œπ') :
    (LinearIsometryEquiv.piLpCongrLeft p ùïú E e).symm =
      LinearIsometryEquiv.piLpCongrLeft p ùïú E e.symm :=
  LinearIsometryEquiv.ext fun x => rfl
#align linear_isometry_equiv.pi_Lp_congr_left_symm LinearIsometryEquiv.piLpCongrLeft_symm

/- warning: linear_isometry_equiv.pi_Lp_congr_left_single -> LinearIsometryEquiv.piLpCongrLeft_single is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align linear_isometry_equiv.pi_Lp_congr_left_single LinearIsometryEquiv.piLpCongrLeft_single‚Çì'. -/
@[simp]
theorem LinearIsometryEquiv.piLpCongrLeft_single [DecidableEq Œπ] [DecidableEq Œπ'] (e : Œπ ‚âÉ Œπ')
    (i : Œπ) (v : E) :
    LinearIsometryEquiv.piLpCongrLeft p ùïú E e ((PiLp.equiv p fun _ => E).symm <| Pi.single i v) =
      (PiLp.equiv p fun _ => E).symm (Pi.single (e i) v) :=
  by
  funext x
  simp [LinearIsometryEquiv.piLpCongrLeft, LinearEquiv.piCongrLeft', Equiv.piCongrLeft', Pi.single,
    Function.update, Equiv.symm_apply_eq]
#align linear_isometry_equiv.pi_Lp_congr_left_single LinearIsometryEquiv.piLpCongrLeft_single

/- warning: pi_Lp.equiv_zero -> PiLp.equiv_zero is a dubious translation:
lean 3 declaration is
  forall {p : ENNReal} {Œπ : Type.{u1}} (Œ≤ : Œπ -> Type.{u2}) [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)], Eq.{max (succ u1) (succ u2)} (forall (i : Œπ), Œ≤ i) (coeFn.{max 1 (max (succ (max u1 u2)) (succ u1) (succ u2)) (max (succ u1) (succ u2)) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u1) (succ u2)} (Equiv.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (fun (_x : Equiv.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) => (PiLp.{u1, u2} p Œπ Œ≤) -> (forall (i : Œπ), Œ≤ i)) (Equiv.hasCoeToFun.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.equiv.{u1, u2} p Œπ Œ≤) (OfNat.ofNat.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) 0 (OfNat.mk.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) 0 (Zero.zero.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (AddZeroClass.toHasZero.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (AddMonoid.toAddZeroClass.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SubNegMonoid.toAddMonoid.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (AddGroup.toSubNegMonoid.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddGroup.toAddGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u1, u2} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i)))))))))))) (OfNat.ofNat.{max u1 u2} (forall (i : Œπ), Œ≤ i) 0 (OfNat.mk.{max u1 u2} (forall (i : Œπ), Œ≤ i) 0 (Zero.zero.{max u1 u2} (forall (i : Œπ), Œ≤ i) (Pi.instZero.{u1, u2} Œπ (fun (i : Œπ) => Œ≤ i) (fun (i : Œπ) => AddZeroClass.toHasZero.{u2} (Œ≤ i) (AddMonoid.toAddZeroClass.{u2} (Œ≤ i) (SubNegMonoid.toAddMonoid.{u2} (Œ≤ i) (AddGroup.toSubNegMonoid.{u2} (Œ≤ i) (SeminormedAddGroup.toAddGroup.{u2} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} (Œ≤ i) (_inst_5 i)))))))))))
but is expected to have type
  forall {p : ENNReal} {Œπ : Type.{u2}} (Œ≤ : Œπ -> Type.{u1}) [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u1} (Œ≤ i)], Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : PiLp.{u2, u1} p Œπ Œ≤) => forall (i : Œπ), Œ≤ i) (OfNat.ofNat.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) 0 (Zero.toOfNat0.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (NegZeroClass.toZero.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SubNegZeroMonoid.toNegZeroClass.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SubtractionMonoid.toSubNegZeroMonoid.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SubtractionCommMonoid.toSubtractionMonoid.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (AddCommGroup.toDivisionAddCommMonoid.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SeminormedAddCommGroup.toAddCommGroup.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u2, u1} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i))))))))))) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.{u2, u1} p Œπ Œ≤) (fun (_x : PiLp.{u2, u1} p Œπ Œ≤) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : PiLp.{u2, u1} p Œπ Œ≤) => forall (i : Œπ), Œ≤ i) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.equiv.{u2, u1} p Œπ Œ≤) (OfNat.ofNat.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) 0 (Zero.toOfNat0.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (NegZeroClass.toZero.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SubNegZeroMonoid.toNegZeroClass.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SubtractionMonoid.toSubNegZeroMonoid.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SubtractionCommMonoid.toSubtractionMonoid.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (AddCommGroup.toDivisionAddCommMonoid.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SeminormedAddCommGroup.toAddCommGroup.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u2, u1} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i))))))))))) (OfNat.ofNat.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : PiLp.{u2, u1} p Œπ Œ≤) => forall (i : Œπ), Œ≤ i) (OfNat.ofNat.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) 0 (Zero.toOfNat0.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (NegZeroClass.toZero.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SubNegZeroMonoid.toNegZeroClass.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SubtractionMonoid.toSubNegZeroMonoid.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SubtractionCommMonoid.toSubtractionMonoid.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (AddCommGroup.toDivisionAddCommMonoid.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SeminormedAddCommGroup.toAddCommGroup.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u2, u1} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i))))))))))) 0 (Zero.toOfNat0.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : PiLp.{u2, u1} p Œπ Œ≤) => forall (i : Œπ), Œ≤ i) (OfNat.ofNat.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) 0 (Zero.toOfNat0.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (NegZeroClass.toZero.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SubNegZeroMonoid.toNegZeroClass.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SubtractionMonoid.toSubNegZeroMonoid.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SubtractionCommMonoid.toSubtractionMonoid.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (AddCommGroup.toDivisionAddCommMonoid.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SeminormedAddCommGroup.toAddCommGroup.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u2, u1} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i))))))))))) (Pi.instZero.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (i : Œπ) => NegZeroClass.toZero.{u1} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u1} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u1} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u1} (Œ≤ i) (_inst_5 i))))))))))
Case conversion may be inaccurate. Consider using '#align pi_Lp.equiv_zero PiLp.equiv_zero‚Çì'. -/
@[simp]
theorem equiv_zero : PiLp.equiv p Œ≤ 0 = 0 :=
  rfl
#align pi_Lp.equiv_zero PiLp.equiv_zero

/- warning: pi_Lp.equiv_symm_zero -> PiLp.equiv_symm_zero is a dubious translation:
lean 3 declaration is
  forall {p : ENNReal} {Œπ : Type.{u1}} (Œ≤ : Œπ -> Type.{u2}) [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)], Eq.{succ (max u1 u2)} (PiLp.{u1, u2} p Œπ Œ≤) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ (max u1 u2))) (succ (max u1 u2)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ (max u1 u2))} (Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) (fun (_x : Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) => (forall (i : Œπ), Œ≤ i) -> (PiLp.{u1, u2} p Œπ Œ≤)) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) (Equiv.symm.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.equiv.{u1, u2} p Œπ Œ≤)) (OfNat.ofNat.{max u1 u2} (forall (i : Œπ), Œ≤ i) 0 (OfNat.mk.{max u1 u2} (forall (i : Œπ), Œ≤ i) 0 (Zero.zero.{max u1 u2} (forall (i : Œπ), Œ≤ i) (Pi.instZero.{u1, u2} Œπ (fun (i : Œπ) => Œ≤ i) (fun (i : Œπ) => AddZeroClass.toHasZero.{u2} (Œ≤ i) (AddMonoid.toAddZeroClass.{u2} (Œ≤ i) (SubNegMonoid.toAddMonoid.{u2} (Œ≤ i) (AddGroup.toSubNegMonoid.{u2} (Œ≤ i) (SeminormedAddGroup.toAddGroup.{u2} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} (Œ≤ i) (_inst_5 i)))))))))))) (OfNat.ofNat.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) 0 (OfNat.mk.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) 0 (Zero.zero.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (AddZeroClass.toHasZero.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (AddMonoid.toAddZeroClass.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SubNegMonoid.toAddMonoid.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (AddGroup.toSubNegMonoid.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddGroup.toAddGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u1, u2} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i)))))))))))
but is expected to have type
  forall {p : ENNReal} {Œπ : Type.{u2}} (Œ≤ : Œπ -> Type.{u1}) [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u1} (Œ≤ i)], Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) (OfNat.ofNat.{max u2 u1} (forall (i : Œπ), Œ≤ i) 0 (Zero.toOfNat0.{max u2 u1} (forall (i : Œπ), Œ≤ i) (Pi.instZero.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (i : Œπ) => NegZeroClass.toZero.{u1} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u1} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u1} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u1} (Œ≤ i) (_inst_5 i))))))))))) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (forall (i : Œπ), Œ≤ i) (PiLp.{u2, u1} p Œπ Œ≤)) (forall (i : Œπ), Œ≤ i) (fun (_x : forall (i : Œπ), Œ≤ i) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (forall (i : Œπ), Œ≤ i) (PiLp.{u2, u1} p Œπ Œ≤)) (Equiv.symm.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.equiv.{u2, u1} p Œπ Œ≤)) (OfNat.ofNat.{max u2 u1} (forall (i : Œπ), Œ≤ i) 0 (Zero.toOfNat0.{max u2 u1} (forall (i : Œπ), Œ≤ i) (Pi.instZero.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (i : Œπ) => NegZeroClass.toZero.{u1} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u1} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u1} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u1} (Œ≤ i) (_inst_5 i))))))))))) (OfNat.ofNat.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) (OfNat.ofNat.{max u2 u1} (forall (i : Œπ), Œ≤ i) 0 (Zero.toOfNat0.{max u2 u1} (forall (i : Œπ), Œ≤ i) (Pi.instZero.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (i : Œπ) => NegZeroClass.toZero.{u1} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u1} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u1} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u1} (Œ≤ i) (_inst_5 i))))))))))) 0 (Zero.toOfNat0.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) (OfNat.ofNat.{max u2 u1} (forall (i : Œπ), Œ≤ i) 0 (Zero.toOfNat0.{max u2 u1} (forall (i : Œπ), Œ≤ i) (Pi.instZero.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (i : Œπ) => NegZeroClass.toZero.{u1} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u1} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u1} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u1} (Œ≤ i) (_inst_5 i))))))))))) (NegZeroClass.toZero.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) (OfNat.ofNat.{max u2 u1} (forall (i : Œπ), Œ≤ i) 0 (Zero.toOfNat0.{max u2 u1} (forall (i : Œπ), Œ≤ i) (Pi.instZero.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (i : Œπ) => NegZeroClass.toZero.{u1} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u1} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u1} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u1} (Œ≤ i) (_inst_5 i))))))))))) (SubNegZeroMonoid.toNegZeroClass.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) (OfNat.ofNat.{max u2 u1} (forall (i : Œπ), Œ≤ i) 0 (Zero.toOfNat0.{max u2 u1} (forall (i : Œπ), Œ≤ i) (Pi.instZero.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (i : Œπ) => NegZeroClass.toZero.{u1} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u1} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u1} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u1} (Œ≤ i) (_inst_5 i))))))))))) (SubtractionMonoid.toSubNegZeroMonoid.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) (OfNat.ofNat.{max u2 u1} (forall (i : Œπ), Œ≤ i) 0 (Zero.toOfNat0.{max u2 u1} (forall (i : Œπ), Œ≤ i) (Pi.instZero.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (i : Œπ) => NegZeroClass.toZero.{u1} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u1} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u1} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u1} (Œ≤ i) (_inst_5 i))))))))))) (SubtractionCommMonoid.toSubtractionMonoid.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) (OfNat.ofNat.{max u2 u1} (forall (i : Œπ), Œ≤ i) 0 (Zero.toOfNat0.{max u2 u1} (forall (i : Œπ), Œ≤ i) (Pi.instZero.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (i : Œπ) => NegZeroClass.toZero.{u1} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u1} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u1} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u1} (Œ≤ i) (_inst_5 i))))))))))) (AddCommGroup.toDivisionAddCommMonoid.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) (OfNat.ofNat.{max u2 u1} (forall (i : Œπ), Œ≤ i) 0 (Zero.toOfNat0.{max u2 u1} (forall (i : Œπ), Œ≤ i) (Pi.instZero.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (i : Œπ) => NegZeroClass.toZero.{u1} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u1} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u1} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u1} (Œ≤ i) (_inst_5 i))))))))))) (SeminormedAddCommGroup.toAddCommGroup.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) (OfNat.ofNat.{max u2 u1} (forall (i : Œπ), Œ≤ i) 0 (Zero.toOfNat0.{max u2 u1} (forall (i : Œπ), Œ≤ i) (Pi.instZero.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (i : Œπ) => NegZeroClass.toZero.{u1} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u1} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u1} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u1} (Œ≤ i) (_inst_5 i))))))))))) (PiLp.seminormedAddCommGroup.{u2, u1} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i))))))))))
Case conversion may be inaccurate. Consider using '#align pi_Lp.equiv_symm_zero PiLp.equiv_symm_zero‚Çì'. -/
@[simp]
theorem equiv_symm_zero : (PiLp.equiv p Œ≤).symm 0 = 0 :=
  rfl
#align pi_Lp.equiv_symm_zero PiLp.equiv_symm_zero

/- warning: pi_Lp.equiv_add -> PiLp.equiv_add is a dubious translation:
lean 3 declaration is
  forall {p : ENNReal} {Œπ : Type.{u1}} (Œ≤ : Œπ -> Type.{u2}) [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)] (x : PiLp.{u1, u2} p Œπ Œ≤) (y : PiLp.{u1, u2} p Œπ Œ≤), Eq.{max (succ u1) (succ u2)} (forall (i : Œπ), Œ≤ i) (coeFn.{max 1 (max (succ (max u1 u2)) (succ u1) (succ u2)) (max (succ u1) (succ u2)) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u1) (succ u2)} (Equiv.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (fun (_x : Equiv.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) => (PiLp.{u1, u2} p Œπ Œ≤) -> (forall (i : Œπ), Œ≤ i)) (Equiv.hasCoeToFun.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.equiv.{u1, u2} p Œπ Œ≤) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.{u1, u2} p Œπ Œ≤) (instHAdd.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (AddZeroClass.toHasAdd.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (AddMonoid.toAddZeroClass.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SubNegMonoid.toAddMonoid.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (AddGroup.toSubNegMonoid.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddGroup.toAddGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u1, u2} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i))))))))) x y)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (forall (i : Œπ), Œ≤ i) (forall (i : Œπ), Œ≤ i) (forall (i : Œπ), Œ≤ i) (instHAdd.{max u1 u2} (forall (i : Œπ), Œ≤ i) (Pi.instAdd.{u1, u2} Œπ (fun (i : Œπ) => Œ≤ i) (fun (i : Œπ) => AddZeroClass.toHasAdd.{u2} (Œ≤ i) (AddMonoid.toAddZeroClass.{u2} (Œ≤ i) (SubNegMonoid.toAddMonoid.{u2} (Œ≤ i) (AddGroup.toSubNegMonoid.{u2} (Œ≤ i) (SeminormedAddGroup.toAddGroup.{u2} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} (Œ≤ i) (_inst_5 i))))))))) (coeFn.{max 1 (max (succ (max u1 u2)) (succ u1) (succ u2)) (max (succ u1) (succ u2)) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u1) (succ u2)} (Equiv.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (fun (_x : Equiv.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) => (PiLp.{u1, u2} p Œπ Œ≤) -> (forall (i : Œπ), Œ≤ i)) (Equiv.hasCoeToFun.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.equiv.{u1, u2} p Œπ Œ≤) x) (coeFn.{max 1 (max (succ (max u1 u2)) (succ u1) (succ u2)) (max (succ u1) (succ u2)) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u1) (succ u2)} (Equiv.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (fun (_x : Equiv.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) => (PiLp.{u1, u2} p Œπ Œ≤) -> (forall (i : Œπ), Œ≤ i)) (Equiv.hasCoeToFun.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.equiv.{u1, u2} p Œπ Œ≤) y))
but is expected to have type
  forall {p : ENNReal} {Œπ : Type.{u2}} (Œ≤ : Œπ -> Type.{u1}) [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u1} (Œ≤ i)] (x : PiLp.{u2, u1} p Œπ Œ≤) (y : PiLp.{u2, u1} p Œπ Œ≤), Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : PiLp.{u2, u1} p Œπ Œ≤) => forall (i : Œπ), Œ≤ i) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (PiLp.{u2, u1} p Œπ Œ≤) (PiLp.{u2, u1} p Œπ Œ≤) (instHAdd.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (AddZeroClass.toAdd.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (AddMonoid.toAddZeroClass.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SubNegMonoid.toAddMonoid.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (AddGroup.toSubNegMonoid.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SeminormedAddGroup.toAddGroup.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u2, u1} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i))))))))) x y)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.{u2, u1} p Œπ Œ≤) (fun (_x : PiLp.{u2, u1} p Œπ Œ≤) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : PiLp.{u2, u1} p Œπ Œ≤) => forall (i : Œπ), Œ≤ i) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.equiv.{u2, u1} p Œπ Œ≤) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (PiLp.{u2, u1} p Œπ Œ≤) (PiLp.{u2, u1} p Œπ Œ≤) (instHAdd.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (AddZeroClass.toAdd.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (AddMonoid.toAddZeroClass.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SubNegMonoid.toAddMonoid.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (AddGroup.toSubNegMonoid.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SeminormedAddGroup.toAddGroup.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u2, u1} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i))))))))) x y)) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : PiLp.{u2, u1} p Œπ Œ≤) => forall (i : Œπ), Œ≤ i) x) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : PiLp.{u2, u1} p Œπ Œ≤) => forall (i : Œπ), Œ≤ i) y) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : PiLp.{u2, u1} p Œπ Œ≤) => forall (i : Œπ), Œ≤ i) x) (instHAdd.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : PiLp.{u2, u1} p Œπ Œ≤) => forall (i : Œπ), Œ≤ i) x) (Pi.instAdd.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (i : Œπ) => AddZeroClass.toAdd.{u1} (Œ≤ i) (AddMonoid.toAddZeroClass.{u1} (Œ≤ i) (SubNegMonoid.toAddMonoid.{u1} (Œ≤ i) (AddGroup.toSubNegMonoid.{u1} (Œ≤ i) (SeminormedAddGroup.toAddGroup.{u1} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} (Œ≤ i) (_inst_5 i))))))))) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.{u2, u1} p Œπ Œ≤) (fun (_x : PiLp.{u2, u1} p Œπ Œ≤) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : PiLp.{u2, u1} p Œπ Œ≤) => forall (i : Œπ), Œ≤ i) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.equiv.{u2, u1} p Œπ Œ≤) x) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.{u2, u1} p Œπ Œ≤) (fun (_x : PiLp.{u2, u1} p Œπ Œ≤) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : PiLp.{u2, u1} p Œπ Œ≤) => forall (i : Œπ), Œ≤ i) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.equiv.{u2, u1} p Œπ Œ≤) y))
Case conversion may be inaccurate. Consider using '#align pi_Lp.equiv_add PiLp.equiv_add‚Çì'. -/
@[simp]
theorem equiv_add : PiLp.equiv p Œ≤ (x + y) = PiLp.equiv p Œ≤ x + PiLp.equiv p Œ≤ y :=
  rfl
#align pi_Lp.equiv_add PiLp.equiv_add

/- warning: pi_Lp.equiv_symm_add -> PiLp.equiv_symm_add is a dubious translation:
lean 3 declaration is
  forall {p : ENNReal} {Œπ : Type.{u1}} (Œ≤ : Œπ -> Type.{u2}) [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)] (x' : forall (i : Œπ), Œ≤ i) (y' : forall (i : Œπ), Œ≤ i), Eq.{succ (max u1 u2)} (PiLp.{u1, u2} p Œπ Œ≤) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ (max u1 u2))) (succ (max u1 u2)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ (max u1 u2))} (Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) (fun (_x : Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) => (forall (i : Œπ), Œ≤ i) -> (PiLp.{u1, u2} p Œπ Œ≤)) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) (Equiv.symm.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.equiv.{u1, u2} p Œπ Œ≤)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (forall (i : Œπ), Œ≤ i) (forall (i : Œπ), Œ≤ i) (forall (i : Œπ), Œ≤ i) (instHAdd.{max u1 u2} (forall (i : Œπ), Œ≤ i) (Pi.instAdd.{u1, u2} Œπ (fun (i : Œπ) => Œ≤ i) (fun (i : Œπ) => AddZeroClass.toHasAdd.{u2} (Œ≤ i) (AddMonoid.toAddZeroClass.{u2} (Œ≤ i) (SubNegMonoid.toAddMonoid.{u2} (Œ≤ i) (AddGroup.toSubNegMonoid.{u2} (Œ≤ i) (SeminormedAddGroup.toAddGroup.{u2} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} (Œ≤ i) (_inst_5 i))))))))) x' y')) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.{u1, u2} p Œπ Œ≤) (instHAdd.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (AddZeroClass.toHasAdd.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (AddMonoid.toAddZeroClass.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SubNegMonoid.toAddMonoid.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (AddGroup.toSubNegMonoid.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddGroup.toAddGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u1, u2} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i))))))))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ (max u1 u2))) (succ (max u1 u2)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ (max u1 u2))} (Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) (fun (_x : Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) => (forall (i : Œπ), Œ≤ i) -> (PiLp.{u1, u2} p Œπ Œ≤)) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) (Equiv.symm.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.equiv.{u1, u2} p Œπ Œ≤)) x') (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ (max u1 u2))) (succ (max u1 u2)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ (max u1 u2))} (Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) (fun (_x : Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) => (forall (i : Œπ), Œ≤ i) -> (PiLp.{u1, u2} p Œπ Œ≤)) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) (Equiv.symm.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.equiv.{u1, u2} p Œπ Œ≤)) y'))
but is expected to have type
  forall {p : ENNReal} {Œπ : Type.{u2}} (Œ≤ : Œπ -> Type.{u1}) [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u1} (Œ≤ i)] (x' : forall (i : Œπ), Œ≤ i) (y' : forall (i : Œπ), Œ≤ i), Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (forall (i : Œπ), Œ≤ i) (forall (i : Œπ), Œ≤ i) (forall (i : Œπ), Œ≤ i) (instHAdd.{max u2 u1} (forall (i : Œπ), Œ≤ i) (Pi.instAdd.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (i : Œπ) => AddZeroClass.toAdd.{u1} (Œ≤ i) (AddMonoid.toAddZeroClass.{u1} (Œ≤ i) (SubNegMonoid.toAddMonoid.{u1} (Œ≤ i) (AddGroup.toSubNegMonoid.{u1} (Œ≤ i) (SeminormedAddGroup.toAddGroup.{u1} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} (Œ≤ i) (_inst_5 i))))))))) x' y')) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (forall (i : Œπ), Œ≤ i) (PiLp.{u2, u1} p Œπ Œ≤)) (forall (i : Œπ), Œ≤ i) (fun (_x : forall (i : Œπ), Œ≤ i) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (forall (i : Œπ), Œ≤ i) (PiLp.{u2, u1} p Œπ Œ≤)) (Equiv.symm.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.equiv.{u2, u1} p Œπ Œ≤)) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (forall (i : Œπ), Œ≤ i) (forall (i : Œπ), Œ≤ i) (forall (i : Œπ), Œ≤ i) (instHAdd.{max u2 u1} (forall (i : Œπ), Œ≤ i) (Pi.instAdd.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (i : Œπ) => AddZeroClass.toAdd.{u1} (Œ≤ i) (AddMonoid.toAddZeroClass.{u1} (Œ≤ i) (SubNegMonoid.toAddMonoid.{u1} (Œ≤ i) (AddGroup.toSubNegMonoid.{u1} (Œ≤ i) (SeminormedAddGroup.toAddGroup.{u1} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} (Œ≤ i) (_inst_5 i))))))))) x' y')) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) x') ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) y') ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) x') (instHAdd.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) x') (AddZeroClass.toAdd.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) x') (AddMonoid.toAddZeroClass.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) x') (SubNegMonoid.toAddMonoid.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) x') (AddGroup.toSubNegMonoid.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) x') (SeminormedAddGroup.toAddGroup.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) x') (SeminormedAddCommGroup.toSeminormedAddGroup.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) x') (PiLp.seminormedAddCommGroup.{u2, u1} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i))))))))) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (forall (i : Œπ), Œ≤ i) (PiLp.{u2, u1} p Œπ Œ≤)) (forall (i : Œπ), Œ≤ i) (fun (_x : forall (i : Œπ), Œ≤ i) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (forall (i : Œπ), Œ≤ i) (PiLp.{u2, u1} p Œπ Œ≤)) (Equiv.symm.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.equiv.{u2, u1} p Œπ Œ≤)) x') (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (forall (i : Œπ), Œ≤ i) (PiLp.{u2, u1} p Œπ Œ≤)) (forall (i : Œπ), Œ≤ i) (fun (_x : forall (i : Œπ), Œ≤ i) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (forall (i : Œπ), Œ≤ i) (PiLp.{u2, u1} p Œπ Œ≤)) (Equiv.symm.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.equiv.{u2, u1} p Œπ Œ≤)) y'))
Case conversion may be inaccurate. Consider using '#align pi_Lp.equiv_symm_add PiLp.equiv_symm_add‚Çì'. -/
@[simp]
theorem equiv_symm_add :
    (PiLp.equiv p Œ≤).symm (x' + y') = (PiLp.equiv p Œ≤).symm x' + (PiLp.equiv p Œ≤).symm y' :=
  rfl
#align pi_Lp.equiv_symm_add PiLp.equiv_symm_add

/- warning: pi_Lp.equiv_sub -> PiLp.equiv_sub is a dubious translation:
lean 3 declaration is
  forall {p : ENNReal} {Œπ : Type.{u1}} (Œ≤ : Œπ -> Type.{u2}) [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)] (x : PiLp.{u1, u2} p Œπ Œ≤) (y : PiLp.{u1, u2} p Œπ Œ≤), Eq.{max (succ u1) (succ u2)} (forall (i : Œπ), Œ≤ i) (coeFn.{max 1 (max (succ (max u1 u2)) (succ u1) (succ u2)) (max (succ u1) (succ u2)) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u1) (succ u2)} (Equiv.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (fun (_x : Equiv.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) => (PiLp.{u1, u2} p Œπ Œ≤) -> (forall (i : Œπ), Œ≤ i)) (Equiv.hasCoeToFun.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.equiv.{u1, u2} p Œπ Œ≤) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.{u1, u2} p Œπ Œ≤) (instHSub.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SubNegMonoid.toHasSub.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (AddGroup.toSubNegMonoid.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddGroup.toAddGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u1, u2} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i))))))) x y)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (forall (i : Œπ), Œ≤ i) (forall (i : Œπ), Œ≤ i) (forall (i : Œπ), Œ≤ i) (instHSub.{max u1 u2} (forall (i : Œπ), Œ≤ i) (Pi.instSub.{u1, u2} Œπ (fun (i : Œπ) => Œ≤ i) (fun (i : Œπ) => SubNegMonoid.toHasSub.{u2} (Œ≤ i) (AddGroup.toSubNegMonoid.{u2} (Œ≤ i) (SeminormedAddGroup.toAddGroup.{u2} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} (Œ≤ i) (_inst_5 i))))))) (coeFn.{max 1 (max (succ (max u1 u2)) (succ u1) (succ u2)) (max (succ u1) (succ u2)) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u1) (succ u2)} (Equiv.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (fun (_x : Equiv.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) => (PiLp.{u1, u2} p Œπ Œ≤) -> (forall (i : Œπ), Œ≤ i)) (Equiv.hasCoeToFun.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.equiv.{u1, u2} p Œπ Œ≤) x) (coeFn.{max 1 (max (succ (max u1 u2)) (succ u1) (succ u2)) (max (succ u1) (succ u2)) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u1) (succ u2)} (Equiv.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (fun (_x : Equiv.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) => (PiLp.{u1, u2} p Œπ Œ≤) -> (forall (i : Œπ), Œ≤ i)) (Equiv.hasCoeToFun.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.equiv.{u1, u2} p Œπ Œ≤) y))
but is expected to have type
  forall {p : ENNReal} {Œπ : Type.{u2}} (Œ≤ : Œπ -> Type.{u1}) [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u1} (Œ≤ i)] (x : PiLp.{u2, u1} p Œπ Œ≤) (y : PiLp.{u2, u1} p Œπ Œ≤), Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : PiLp.{u2, u1} p Œπ Œ≤) => forall (i : Œπ), Œ≤ i) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (PiLp.{u2, u1} p Œπ Œ≤) (PiLp.{u2, u1} p Œπ Œ≤) (instHSub.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SubNegMonoid.toSub.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (AddGroup.toSubNegMonoid.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SeminormedAddGroup.toAddGroup.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u2, u1} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i))))))) x y)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.{u2, u1} p Œπ Œ≤) (fun (_x : PiLp.{u2, u1} p Œπ Œ≤) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : PiLp.{u2, u1} p Œπ Œ≤) => forall (i : Œπ), Œ≤ i) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.equiv.{u2, u1} p Œπ Œ≤) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (PiLp.{u2, u1} p Œπ Œ≤) (PiLp.{u2, u1} p Œπ Œ≤) (instHSub.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SubNegMonoid.toSub.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (AddGroup.toSubNegMonoid.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SeminormedAddGroup.toAddGroup.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u2, u1} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i))))))) x y)) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : PiLp.{u2, u1} p Œπ Œ≤) => forall (i : Œπ), Œ≤ i) x) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : PiLp.{u2, u1} p Œπ Œ≤) => forall (i : Œπ), Œ≤ i) y) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : PiLp.{u2, u1} p Œπ Œ≤) => forall (i : Œπ), Œ≤ i) x) (instHSub.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : PiLp.{u2, u1} p Œπ Œ≤) => forall (i : Œπ), Œ≤ i) x) (Pi.instSub.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (i : Œπ) => SubNegMonoid.toSub.{u1} (Œ≤ i) (AddGroup.toSubNegMonoid.{u1} (Œ≤ i) (SeminormedAddGroup.toAddGroup.{u1} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} (Œ≤ i) (_inst_5 i))))))) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.{u2, u1} p Œπ Œ≤) (fun (_x : PiLp.{u2, u1} p Œπ Œ≤) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : PiLp.{u2, u1} p Œπ Œ≤) => forall (i : Œπ), Œ≤ i) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.equiv.{u2, u1} p Œπ Œ≤) x) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.{u2, u1} p Œπ Œ≤) (fun (_x : PiLp.{u2, u1} p Œπ Œ≤) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : PiLp.{u2, u1} p Œπ Œ≤) => forall (i : Œπ), Œ≤ i) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.equiv.{u2, u1} p Œπ Œ≤) y))
Case conversion may be inaccurate. Consider using '#align pi_Lp.equiv_sub PiLp.equiv_sub‚Çì'. -/
@[simp]
theorem equiv_sub : PiLp.equiv p Œ≤ (x - y) = PiLp.equiv p Œ≤ x - PiLp.equiv p Œ≤ y :=
  rfl
#align pi_Lp.equiv_sub PiLp.equiv_sub

/- warning: pi_Lp.equiv_symm_sub -> PiLp.equiv_symm_sub is a dubious translation:
lean 3 declaration is
  forall {p : ENNReal} {Œπ : Type.{u1}} (Œ≤ : Œπ -> Type.{u2}) [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)] (x' : forall (i : Œπ), Œ≤ i) (y' : forall (i : Œπ), Œ≤ i), Eq.{succ (max u1 u2)} (PiLp.{u1, u2} p Œπ Œ≤) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ (max u1 u2))) (succ (max u1 u2)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ (max u1 u2))} (Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) (fun (_x : Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) => (forall (i : Œπ), Œ≤ i) -> (PiLp.{u1, u2} p Œπ Œ≤)) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) (Equiv.symm.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.equiv.{u1, u2} p Œπ Œ≤)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (forall (i : Œπ), Œ≤ i) (forall (i : Œπ), Œ≤ i) (forall (i : Œπ), Œ≤ i) (instHSub.{max u1 u2} (forall (i : Œπ), Œ≤ i) (Pi.instSub.{u1, u2} Œπ (fun (i : Œπ) => Œ≤ i) (fun (i : Œπ) => SubNegMonoid.toHasSub.{u2} (Œ≤ i) (AddGroup.toSubNegMonoid.{u2} (Œ≤ i) (SeminormedAddGroup.toAddGroup.{u2} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} (Œ≤ i) (_inst_5 i))))))) x' y')) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.{u1, u2} p Œπ Œ≤) (instHSub.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SubNegMonoid.toHasSub.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (AddGroup.toSubNegMonoid.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddGroup.toAddGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u1, u2} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i))))))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ (max u1 u2))) (succ (max u1 u2)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ (max u1 u2))} (Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) (fun (_x : Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) => (forall (i : Œπ), Œ≤ i) -> (PiLp.{u1, u2} p Œπ Œ≤)) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) (Equiv.symm.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.equiv.{u1, u2} p Œπ Œ≤)) x') (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ (max u1 u2))) (succ (max u1 u2)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ (max u1 u2))} (Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) (fun (_x : Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) => (forall (i : Œπ), Œ≤ i) -> (PiLp.{u1, u2} p Œπ Œ≤)) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) (Equiv.symm.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.equiv.{u1, u2} p Œπ Œ≤)) y'))
but is expected to have type
  forall {p : ENNReal} {Œπ : Type.{u2}} (Œ≤ : Œπ -> Type.{u1}) [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u1} (Œ≤ i)] (x' : forall (i : Œπ), Œ≤ i) (y' : forall (i : Œπ), Œ≤ i), Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (forall (i : Œπ), Œ≤ i) (forall (i : Œπ), Œ≤ i) (forall (i : Œπ), Œ≤ i) (instHSub.{max u2 u1} (forall (i : Œπ), Œ≤ i) (Pi.instSub.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (i : Œπ) => SubNegMonoid.toSub.{u1} (Œ≤ i) (AddGroup.toSubNegMonoid.{u1} (Œ≤ i) (SeminormedAddGroup.toAddGroup.{u1} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} (Œ≤ i) (_inst_5 i))))))) x' y')) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (forall (i : Œπ), Œ≤ i) (PiLp.{u2, u1} p Œπ Œ≤)) (forall (i : Œπ), Œ≤ i) (fun (_x : forall (i : Œπ), Œ≤ i) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (forall (i : Œπ), Œ≤ i) (PiLp.{u2, u1} p Œπ Œ≤)) (Equiv.symm.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.equiv.{u2, u1} p Œπ Œ≤)) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (forall (i : Œπ), Œ≤ i) (forall (i : Œπ), Œ≤ i) (forall (i : Œπ), Œ≤ i) (instHSub.{max u2 u1} (forall (i : Œπ), Œ≤ i) (Pi.instSub.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (i : Œπ) => SubNegMonoid.toSub.{u1} (Œ≤ i) (AddGroup.toSubNegMonoid.{u1} (Œ≤ i) (SeminormedAddGroup.toAddGroup.{u1} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} (Œ≤ i) (_inst_5 i))))))) x' y')) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) x') ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) y') ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) x') (instHSub.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) x') (SubNegMonoid.toSub.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) x') (AddGroup.toSubNegMonoid.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) x') (SeminormedAddGroup.toAddGroup.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) x') (SeminormedAddCommGroup.toSeminormedAddGroup.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) x') (PiLp.seminormedAddCommGroup.{u2, u1} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i))))))) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (forall (i : Œπ), Œ≤ i) (PiLp.{u2, u1} p Œπ Œ≤)) (forall (i : Œπ), Œ≤ i) (fun (_x : forall (i : Œπ), Œ≤ i) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (forall (i : Œπ), Œ≤ i) (PiLp.{u2, u1} p Œπ Œ≤)) (Equiv.symm.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.equiv.{u2, u1} p Œπ Œ≤)) x') (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (forall (i : Œπ), Œ≤ i) (PiLp.{u2, u1} p Œπ Œ≤)) (forall (i : Œπ), Œ≤ i) (fun (_x : forall (i : Œπ), Œ≤ i) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (forall (i : Œπ), Œ≤ i) (PiLp.{u2, u1} p Œπ Œ≤)) (Equiv.symm.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.equiv.{u2, u1} p Œπ Œ≤)) y'))
Case conversion may be inaccurate. Consider using '#align pi_Lp.equiv_symm_sub PiLp.equiv_symm_sub‚Çì'. -/
@[simp]
theorem equiv_symm_sub :
    (PiLp.equiv p Œ≤).symm (x' - y') = (PiLp.equiv p Œ≤).symm x' - (PiLp.equiv p Œ≤).symm y' :=
  rfl
#align pi_Lp.equiv_symm_sub PiLp.equiv_symm_sub

/- warning: pi_Lp.equiv_neg -> PiLp.equiv_neg is a dubious translation:
lean 3 declaration is
  forall {p : ENNReal} {Œπ : Type.{u1}} (Œ≤ : Œπ -> Type.{u2}) [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)] (x : PiLp.{u1, u2} p Œπ Œ≤), Eq.{max (succ u1) (succ u2)} (forall (i : Œπ), Œ≤ i) (coeFn.{max 1 (max (succ (max u1 u2)) (succ u1) (succ u2)) (max (succ u1) (succ u2)) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u1) (succ u2)} (Equiv.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (fun (_x : Equiv.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) => (PiLp.{u1, u2} p Œπ Œ≤) -> (forall (i : Œπ), Œ≤ i)) (Equiv.hasCoeToFun.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.equiv.{u1, u2} p Œπ Œ≤) (Neg.neg.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SubNegMonoid.toHasNeg.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (AddGroup.toSubNegMonoid.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddGroup.toAddGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u1, u2} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i)))))) x)) (Neg.neg.{max u1 u2} (forall (i : Œπ), Œ≤ i) (Pi.instNeg.{u1, u2} Œπ (fun (i : Œπ) => Œ≤ i) (fun (i : Œπ) => SubNegMonoid.toHasNeg.{u2} (Œ≤ i) (AddGroup.toSubNegMonoid.{u2} (Œ≤ i) (SeminormedAddGroup.toAddGroup.{u2} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} (Œ≤ i) (_inst_5 i)))))) (coeFn.{max 1 (max (succ (max u1 u2)) (succ u1) (succ u2)) (max (succ u1) (succ u2)) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u1) (succ u2)} (Equiv.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (fun (_x : Equiv.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) => (PiLp.{u1, u2} p Œπ Œ≤) -> (forall (i : Œπ), Œ≤ i)) (Equiv.hasCoeToFun.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.equiv.{u1, u2} p Œπ Œ≤) x))
but is expected to have type
  forall {p : ENNReal} {Œπ : Type.{u2}} (Œ≤ : Œπ -> Type.{u1}) [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u1} (Œ≤ i)] (x : PiLp.{u2, u1} p Œπ Œ≤), Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : PiLp.{u2, u1} p Œπ Œ≤) => forall (i : Œπ), Œ≤ i) (Neg.neg.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (NegZeroClass.toNeg.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SubNegZeroMonoid.toNegZeroClass.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SubtractionMonoid.toSubNegZeroMonoid.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SubtractionCommMonoid.toSubtractionMonoid.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (AddCommGroup.toDivisionAddCommMonoid.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SeminormedAddCommGroup.toAddCommGroup.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u2, u1} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i)))))))) x)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.{u2, u1} p Œπ Œ≤) (fun (_x : PiLp.{u2, u1} p Œπ Œ≤) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : PiLp.{u2, u1} p Œπ Œ≤) => forall (i : Œπ), Œ≤ i) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.equiv.{u2, u1} p Œπ Œ≤) (Neg.neg.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (NegZeroClass.toNeg.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SubNegZeroMonoid.toNegZeroClass.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SubtractionMonoid.toSubNegZeroMonoid.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SubtractionCommMonoid.toSubtractionMonoid.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (AddCommGroup.toDivisionAddCommMonoid.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (SeminormedAddCommGroup.toAddCommGroup.{max u2 u1} (PiLp.{u2, u1} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u2, u1} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i)))))))) x)) (Neg.neg.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : PiLp.{u2, u1} p Œπ Œ≤) => forall (i : Œπ), Œ≤ i) x) (Pi.instNeg.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (i : Œπ) => NegZeroClass.toNeg.{u1} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u1} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u1} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u1} (Œ≤ i) (_inst_5 i)))))))) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.{u2, u1} p Œπ Œ≤) (fun (_x : PiLp.{u2, u1} p Œπ Œ≤) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : PiLp.{u2, u1} p Œπ Œ≤) => forall (i : Œπ), Œ≤ i) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i)) (PiLp.equiv.{u2, u1} p Œπ Œ≤) x))
Case conversion may be inaccurate. Consider using '#align pi_Lp.equiv_neg PiLp.equiv_neg‚Çì'. -/
@[simp]
theorem equiv_neg : PiLp.equiv p Œ≤ (-x) = -PiLp.equiv p Œ≤ x :=
  rfl
#align pi_Lp.equiv_neg PiLp.equiv_neg

/- warning: pi_Lp.equiv_symm_neg -> PiLp.equiv_symm_neg is a dubious translation:
lean 3 declaration is
  forall {p : ENNReal} {Œπ : Type.{u1}} (Œ≤ : Œπ -> Type.{u2}) [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)] (x' : forall (i : Œπ), Œ≤ i), Eq.{succ (max u1 u2)} (PiLp.{u1, u2} p Œπ Œ≤) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ (max u1 u2))) (succ (max u1 u2)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ (max u1 u2))} (Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) (fun (_x : Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) => (forall (i : Œπ), Œ≤ i) -> (PiLp.{u1, u2} p Œπ Œ≤)) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) (Equiv.symm.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.equiv.{u1, u2} p Œπ Œ≤)) (Neg.neg.{max u1 u2} (forall (i : Œπ), Œ≤ i) (Pi.instNeg.{u1, u2} Œπ (fun (i : Œπ) => Œ≤ i) (fun (i : Œπ) => SubNegMonoid.toHasNeg.{u2} (Œ≤ i) (AddGroup.toSubNegMonoid.{u2} (Œ≤ i) (SeminormedAddGroup.toAddGroup.{u2} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} (Œ≤ i) (_inst_5 i)))))) x')) (Neg.neg.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SubNegMonoid.toHasNeg.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (AddGroup.toSubNegMonoid.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddGroup.toAddGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u1, u2} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i)))))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ (max u1 u2))) (succ (max u1 u2)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ (max u1 u2))} (Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) (fun (_x : Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) => (forall (i : Œπ), Œ≤ i) -> (PiLp.{u1, u2} p Œπ Œ≤)) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) (Equiv.symm.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.equiv.{u1, u2} p Œπ Œ≤)) x'))
but is expected to have type
  forall {p : ENNReal} {Œπ : Type.{u2}} (Œ≤ : Œπ -> Type.{u1}) [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u1} (Œ≤ i)] (x' : forall (i : Œπ), Œ≤ i), Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) (Neg.neg.{max u2 u1} (forall (i : Œπ), Œ≤ i) (Pi.instNeg.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (i : Œπ) => NegZeroClass.toNeg.{u1} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u1} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u1} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u1} (Œ≤ i) (_inst_5 i)))))))) x')) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (forall (i : Œπ), Œ≤ i) (PiLp.{u2, u1} p Œπ Œ≤)) (forall (i : Œπ), Œ≤ i) (fun (_x : forall (i : Œπ), Œ≤ i) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (forall (i : Œπ), Œ≤ i) (PiLp.{u2, u1} p Œπ Œ≤)) (Equiv.symm.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.equiv.{u2, u1} p Œπ Œ≤)) (Neg.neg.{max u2 u1} (forall (i : Œπ), Œ≤ i) (Pi.instNeg.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (i : Œπ) => NegZeroClass.toNeg.{u1} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u1} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u1} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u1} (Œ≤ i) (_inst_5 i)))))))) x')) (Neg.neg.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) x') (NegZeroClass.toNeg.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) x') (SubNegZeroMonoid.toNegZeroClass.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) x') (SubtractionMonoid.toSubNegZeroMonoid.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) x') (SubtractionCommMonoid.toSubtractionMonoid.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) x') (AddCommGroup.toDivisionAddCommMonoid.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) x') (SeminormedAddCommGroup.toAddCommGroup.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) x') (PiLp.seminormedAddCommGroup.{u2, u1} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i)))))))) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (forall (i : Œπ), Œ≤ i) (PiLp.{u2, u1} p Œπ Œ≤)) (forall (i : Œπ), Œ≤ i) (fun (_x : forall (i : Œπ), Œ≤ i) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (forall (i : Œπ), Œ≤ i) (PiLp.{u2, u1} p Œπ Œ≤)) (Equiv.symm.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.equiv.{u2, u1} p Œπ Œ≤)) x'))
Case conversion may be inaccurate. Consider using '#align pi_Lp.equiv_symm_neg PiLp.equiv_symm_neg‚Çì'. -/
@[simp]
theorem equiv_symm_neg : (PiLp.equiv p Œ≤).symm (-x') = -(PiLp.equiv p Œ≤).symm x' :=
  rfl
#align pi_Lp.equiv_symm_neg PiLp.equiv_symm_neg

/- warning: pi_Lp.equiv_smul -> PiLp.equiv_smul is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align pi_Lp.equiv_smul PiLp.equiv_smul‚Çì'. -/
@[simp]
theorem equiv_smul : PiLp.equiv p Œ≤ (c ‚Ä¢ x) = c ‚Ä¢ PiLp.equiv p Œ≤ x :=
  rfl
#align pi_Lp.equiv_smul PiLp.equiv_smul

/- warning: pi_Lp.equiv_symm_smul -> PiLp.equiv_symm_smul is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align pi_Lp.equiv_symm_smul PiLp.equiv_symm_smul‚Çì'. -/
@[simp]
theorem equiv_symm_smul : (PiLp.equiv p Œ≤).symm (c ‚Ä¢ x') = c ‚Ä¢ (PiLp.equiv p Œ≤).symm x' :=
  rfl
#align pi_Lp.equiv_symm_smul PiLp.equiv_symm_smul

section Single

variable (p)

variable [DecidableEq Œπ]

/- warning: pi_Lp.nnnorm_equiv_symm_single -> PiLp.nnnorm_equiv_symm_single is a dubious translation:
lean 3 declaration is
  forall (p : ENNReal) {Œπ : Type.{u1}} (Œ≤ : Œπ -> Type.{u2}) [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)] [_inst_10 : DecidableEq.{succ u1} Œπ] (i : Œπ) (b : Œ≤ i), Eq.{1} NNReal (NNNorm.nnnorm.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddGroup.toNNNorm.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u1, u2} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i)))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ (max u1 u2))) (succ (max u1 u2)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ (max u1 u2))} (Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) (fun (_x : Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) => (forall (i : Œπ), Œ≤ i) -> (PiLp.{u1, u2} p Œπ Œ≤)) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) (Equiv.symm.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.equiv.{u1, u2} p Œπ Œ≤)) (Pi.single.{u1, u2} Œπ (fun (i : Œπ) => Œ≤ i) (fun (a : Œπ) (b : Œπ) => _inst_10 a b) (fun (i : Œπ) => AddZeroClass.toHasZero.{u2} (Œ≤ i) (AddMonoid.toAddZeroClass.{u2} (Œ≤ i) (SubNegMonoid.toAddMonoid.{u2} (Œ≤ i) (AddGroup.toSubNegMonoid.{u2} (Œ≤ i) (SeminormedAddGroup.toAddGroup.{u2} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} (Œ≤ i) (_inst_5 i))))))) i b))) (NNNorm.nnnorm.{u2} (Œ≤ i) (SeminormedAddGroup.toNNNorm.{u2} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} (Œ≤ i) (_inst_5 i))) b)
but is expected to have type
  forall (p : ENNReal) {Œπ : Type.{u2}} (Œ≤ : Œπ -> Type.{u1}) [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : forall (i : Œπ), SeminormedAddCommGroup.{u1} (Œ≤ i)] [_inst_5 : DecidableEq.{succ u2} Œπ] [_inst_10 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] (i : Œπ) (b : Œ≤ i), Eq.{1} NNReal (NNNorm.nnnorm.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) (Pi.single.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (a : Œπ) (b : Œπ) => _inst_5 a b) (fun (i : Œπ) => NegZeroClass.toZero.{u1} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u1} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u1} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u1} (Œ≤ i) (_inst_2 i))))))) i b)) (SeminormedAddGroup.toNNNorm.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) (Pi.single.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (a : Œπ) (b : Œπ) => _inst_5 a b) (fun (i : Œπ) => NegZeroClass.toZero.{u1} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u1} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u1} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u1} (Œ≤ i) (_inst_2 i))))))) i b)) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) (Pi.single.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (a : Œπ) (b : Œπ) => _inst_5 a b) (fun (i : Œπ) => NegZeroClass.toZero.{u1} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u1} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u1} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u1} (Œ≤ i) (_inst_2 i))))))) i b)) (PiLp.seminormedAddCommGroup.{u2, u1} p Œπ Œ≤ _inst_1 _inst_10 (fun (i : Œπ) => _inst_2 i)))) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (forall (i : Œπ), Œ≤ i) (PiLp.{u2, u1} p Œπ Œ≤)) (forall (i : Œπ), Œ≤ i) (fun (_x : forall (i : Œπ), Œ≤ i) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (forall (i : Œπ), Œ≤ i) (PiLp.{u2, u1} p Œπ Œ≤)) (Equiv.symm.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.equiv.{u2, u1} p Œπ Œ≤)) (Pi.single.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (a : Œπ) (b : Œπ) => _inst_5 a b) (fun (i : Œπ) => NegZeroClass.toZero.{u1} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u1} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u1} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u1} (Œ≤ i) (_inst_2 i))))))) i b))) (NNNorm.nnnorm.{u1} (Œ≤ i) (SeminormedAddGroup.toNNNorm.{u1} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} (Œ≤ i) (_inst_2 i))) b)
Case conversion may be inaccurate. Consider using '#align pi_Lp.nnnorm_equiv_symm_single PiLp.nnnorm_equiv_symm_single‚Çì'. -/
@[simp]
theorem nnnorm_equiv_symm_single (i : Œπ) (b : Œ≤ i) :
    ‚Äñ(PiLp.equiv p Œ≤).symm (Pi.single i b)‚Äñ‚Çä = ‚Äñb‚Äñ‚Çä :=
  by
  haveI : Nonempty Œπ := ‚ü®i‚ü©
  induction p using WithTop.recTopCoe
  ¬∑ simp_rw [nnnorm_eq_csupr, equiv_symm_apply]
    refine' ciSup_eq_of_forall_le_of_forall_lt_exists_gt (fun j => _) fun n hn => ‚ü®i, hn.trans_eq _‚ü©
    ¬∑ obtain rfl | hij := Decidable.eq_or_ne i j
      ¬∑ rw [Pi.single_eq_same]
      ¬∑ rw [Pi.single_eq_of_ne' hij, nnnorm_zero]
        exact zero_le _
    ¬∑ rw [Pi.single_eq_same]
  ¬∑ have hp0 : (p : ‚Ñù) ‚â† 0 := by
      exact_mod_cast (zero_lt_one.trans_le <| Fact.out (1 ‚â§ (p : ‚Ñù‚â•0‚àû))).ne'
    rw [nnnorm_eq_sum ENNReal.coe_ne_top, ENNReal.coe_toReal, Fintype.sum_eq_single i,
      equiv_symm_apply, Pi.single_eq_same, ‚Üê NNReal.rpow_mul, one_div, mul_inv_cancel hp0,
      NNReal.rpow_one]
    intro j hij
    rw [equiv_symm_apply, Pi.single_eq_of_ne hij, nnnorm_zero, NNReal.zero_rpow hp0]
#align pi_Lp.nnnorm_equiv_symm_single PiLp.nnnorm_equiv_symm_single

/- warning: pi_Lp.norm_equiv_symm_single -> PiLp.norm_equiv_symm_single is a dubious translation:
lean 3 declaration is
  forall (p : ENNReal) {Œπ : Type.{u1}} (Œ≤ : Œπ -> Type.{u2}) [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)] [_inst_10 : DecidableEq.{succ u1} Œπ] (i : Œπ) (b : Œ≤ i), Eq.{1} Real (Norm.norm.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.hasNorm.{u1, u2} p Œπ Œ≤ _inst_1 (fun (i : Œπ) => SeminormedAddCommGroup.toHasNorm.{u2} (Œ≤ i) (_inst_5 i)) (fun (i : Œπ) => AddZeroClass.toHasZero.{u2} (Œ≤ i) (AddMonoid.toAddZeroClass.{u2} (Œ≤ i) (SubNegMonoid.toAddMonoid.{u2} (Œ≤ i) (AddGroup.toSubNegMonoid.{u2} (Œ≤ i) (SeminormedAddGroup.toAddGroup.{u2} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} (Œ≤ i) (_inst_5 i)))))))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ (max u1 u2))) (succ (max u1 u2)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ (max u1 u2))} (Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) (fun (_x : Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) => (forall (i : Œπ), Œ≤ i) -> (PiLp.{u1, u2} p Œπ Œ≤)) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) (Equiv.symm.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.equiv.{u1, u2} p Œπ Œ≤)) (Pi.single.{u1, u2} Œπ (fun (i : Œπ) => Œ≤ i) (fun (a : Œπ) (b : Œπ) => _inst_10 a b) (fun (i : Œπ) => AddZeroClass.toHasZero.{u2} (Œ≤ i) (AddMonoid.toAddZeroClass.{u2} (Œ≤ i) (SubNegMonoid.toAddMonoid.{u2} (Œ≤ i) (AddGroup.toSubNegMonoid.{u2} (Œ≤ i) (SeminormedAddGroup.toAddGroup.{u2} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} (Œ≤ i) (_inst_5 i))))))) i b))) (Norm.norm.{u2} (Œ≤ i) (SeminormedAddCommGroup.toHasNorm.{u2} (Œ≤ i) (_inst_5 i)) b)
but is expected to have type
  forall (p : ENNReal) {Œπ : Type.{u2}} (Œ≤ : Œπ -> Type.{u1}) [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u1} (Œ≤ i)] [_inst_10 : DecidableEq.{succ u2} Œπ] (i : Œπ) (b : Œ≤ i), Eq.{1} Real (Norm.norm.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) (Pi.single.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (a : Œπ) (b : Œπ) => _inst_10 a b) (fun (i : Œπ) => NegZeroClass.toZero.{u1} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u1} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u1} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u1} (Œ≤ i) (_inst_5 i))))))) i b)) (PiLp.hasNorm.{u2, u1} p Œπ Œ≤ _inst_1 (fun (i : Œπ) => SeminormedAddCommGroup.toNorm.{u1} (Œ≤ i) (_inst_5 i)) (fun (i : Œπ) => NegZeroClass.toZero.{u1} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u1} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u1} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u1} (Œ≤ i) (_inst_5 i)))))))) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (forall (i : Œπ), Œ≤ i) (PiLp.{u2, u1} p Œπ Œ≤)) (forall (i : Œπ), Œ≤ i) (fun (_x : forall (i : Œπ), Œ≤ i) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (forall (i : Œπ), Œ≤ i) (PiLp.{u2, u1} p Œπ Œ≤)) (Equiv.symm.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.equiv.{u2, u1} p Œπ Œ≤)) (Pi.single.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (a : Œπ) (b : Œπ) => _inst_10 a b) (fun (i : Œπ) => NegZeroClass.toZero.{u1} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u1} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u1} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u1} (Œ≤ i) (_inst_5 i))))))) i b))) (Norm.norm.{u1} (Œ≤ i) (SeminormedAddCommGroup.toNorm.{u1} (Œ≤ i) (_inst_5 i)) b)
Case conversion may be inaccurate. Consider using '#align pi_Lp.norm_equiv_symm_single PiLp.norm_equiv_symm_single‚Çì'. -/
@[simp]
theorem norm_equiv_symm_single (i : Œπ) (b : Œ≤ i) : ‚Äñ(PiLp.equiv p Œ≤).symm (Pi.single i b)‚Äñ = ‚Äñb‚Äñ :=
  congr_arg coe <| nnnorm_equiv_symm_single p Œ≤ i b
#align pi_Lp.norm_equiv_symm_single PiLp.norm_equiv_symm_single

/- warning: pi_Lp.nndist_equiv_symm_single_same -> PiLp.nndist_equiv_symm_single_same is a dubious translation:
lean 3 declaration is
  forall (p : ENNReal) {Œπ : Type.{u1}} (Œ≤ : Œπ -> Type.{u2}) [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)] [_inst_10 : DecidableEq.{succ u1} Œπ] (i : Œπ) (b‚ÇÅ : Œ≤ i) (b‚ÇÇ : Œ≤ i), Eq.{1} NNReal (NNDist.nndist.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PseudoMetricSpace.toNNDist.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.pseudoMetricSpace.{u1, u2} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => SeminormedAddCommGroup.toPseudoMetricSpace.{u2} (Œ≤ i) (_inst_5 i)))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ (max u1 u2))) (succ (max u1 u2)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ (max u1 u2))} (Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) (fun (_x : Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) => (forall (i : Œπ), Œ≤ i) -> (PiLp.{u1, u2} p Œπ Œ≤)) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) (Equiv.symm.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.equiv.{u1, u2} p Œπ Œ≤)) (Pi.single.{u1, u2} Œπ (fun (i : Œπ) => Œ≤ i) (fun (a : Œπ) (b : Œπ) => _inst_10 a b) (fun (i : Œπ) => AddZeroClass.toHasZero.{u2} (Œ≤ i) (AddMonoid.toAddZeroClass.{u2} (Œ≤ i) (SubNegMonoid.toAddMonoid.{u2} (Œ≤ i) (AddGroup.toSubNegMonoid.{u2} (Œ≤ i) (SeminormedAddGroup.toAddGroup.{u2} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} (Œ≤ i) (_inst_5 i))))))) i b‚ÇÅ)) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ (max u1 u2))) (succ (max u1 u2)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ (max u1 u2))} (Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) (fun (_x : Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) => (forall (i : Œπ), Œ≤ i) -> (PiLp.{u1, u2} p Œπ Œ≤)) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) (Equiv.symm.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.equiv.{u1, u2} p Œπ Œ≤)) (Pi.single.{u1, u2} Œπ (fun (i : Œπ) => Œ≤ i) (fun (a : Œπ) (b : Œπ) => _inst_10 a b) (fun (i : Œπ) => AddZeroClass.toHasZero.{u2} (Œ≤ i) (AddMonoid.toAddZeroClass.{u2} (Œ≤ i) (SubNegMonoid.toAddMonoid.{u2} (Œ≤ i) (AddGroup.toSubNegMonoid.{u2} (Œ≤ i) (SeminormedAddGroup.toAddGroup.{u2} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} (Œ≤ i) (_inst_5 i))))))) i b‚ÇÇ))) (NNDist.nndist.{u2} (Œ≤ i) (PseudoMetricSpace.toNNDist.{u2} (Œ≤ i) (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} (Œ≤ i) (_inst_5 i))) b‚ÇÅ b‚ÇÇ)
but is expected to have type
  forall (p : ENNReal) {Œπ : Type.{u2}} (Œ≤ : Œπ -> Type.{u1}) [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u1} (Œ≤ i)] [_inst_10 : DecidableEq.{succ u2} Œπ] (i : Œπ) (b‚ÇÅ : Œ≤ i) (b‚ÇÇ : Œ≤ i), Eq.{1} NNReal (NNDist.nndist.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) (Pi.single.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (a : Œπ) (b : Œπ) => _inst_10 a b) (fun (i : Œπ) => NegZeroClass.toZero.{u1} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u1} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u1} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u1} (Œ≤ i) (_inst_5 i))))))) i b‚ÇÅ)) (PseudoMetricSpace.toNNDist.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) (Pi.single.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (a : Œπ) (b : Œπ) => _inst_10 a b) (fun (i : Œπ) => NegZeroClass.toZero.{u1} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u1} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u1} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u1} (Œ≤ i) (_inst_5 i))))))) i b‚ÇÅ)) (PiLp.instPseudoMetricSpacePiLp.{u2, u1} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => SeminormedAddCommGroup.toPseudoMetricSpace.{u1} (Œ≤ i) (_inst_5 i)))) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (forall (i : Œπ), Œ≤ i) (PiLp.{u2, u1} p Œπ Œ≤)) (forall (i : Œπ), Œ≤ i) (fun (_x : forall (i : Œπ), Œ≤ i) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (forall (i : Œπ), Œ≤ i) (PiLp.{u2, u1} p Œπ Œ≤)) (Equiv.symm.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.equiv.{u2, u1} p Œπ Œ≤)) (Pi.single.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (a : Œπ) (b : Œπ) => _inst_10 a b) (fun (i : Œπ) => NegZeroClass.toZero.{u1} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u1} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u1} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u1} (Œ≤ i) (_inst_5 i))))))) i b‚ÇÅ)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (forall (i : Œπ), Œ≤ i) (PiLp.{u2, u1} p Œπ Œ≤)) (forall (i : Œπ), Œ≤ i) (fun (_x : forall (i : Œπ), Œ≤ i) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (forall (i : Œπ), Œ≤ i) (PiLp.{u2, u1} p Œπ Œ≤)) (Equiv.symm.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.equiv.{u2, u1} p Œπ Œ≤)) (Pi.single.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (a : Œπ) (b : Œπ) => _inst_10 a b) (fun (i : Œπ) => NegZeroClass.toZero.{u1} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u1} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u1} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u1} (Œ≤ i) (_inst_5 i))))))) i b‚ÇÇ))) (NNDist.nndist.{u1} (Œ≤ i) (PseudoMetricSpace.toNNDist.{u1} (Œ≤ i) (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} (Œ≤ i) (_inst_5 i))) b‚ÇÅ b‚ÇÇ)
Case conversion may be inaccurate. Consider using '#align pi_Lp.nndist_equiv_symm_single_same PiLp.nndist_equiv_symm_single_same‚Çì'. -/
@[simp]
theorem nndist_equiv_symm_single_same (i : Œπ) (b‚ÇÅ b‚ÇÇ : Œ≤ i) :
    nndist ((PiLp.equiv p Œ≤).symm (Pi.single i b‚ÇÅ)) ((PiLp.equiv p Œ≤).symm (Pi.single i b‚ÇÇ)) =
      nndist b‚ÇÅ b‚ÇÇ :=
  by
  rw [nndist_eq_nnnorm, nndist_eq_nnnorm, ‚Üê equiv_symm_sub, ‚Üê Pi.single_sub,
    nnnorm_equiv_symm_single]
#align pi_Lp.nndist_equiv_symm_single_same PiLp.nndist_equiv_symm_single_same

/- warning: pi_Lp.dist_equiv_symm_single_same -> PiLp.dist_equiv_symm_single_same is a dubious translation:
lean 3 declaration is
  forall (p : ENNReal) {Œπ : Type.{u1}} (Œ≤ : Œπ -> Type.{u2}) [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)] [_inst_10 : DecidableEq.{succ u1} Œπ] (i : Œπ) (b‚ÇÅ : Œ≤ i) (b‚ÇÇ : Œ≤ i), Eq.{1} Real (Dist.dist.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.hasDist.{u1, u2} p Œπ Œ≤ _inst_1 (fun (i : Œπ) => PseudoMetricSpace.toHasDist.{u2} (Œ≤ i) (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} (Œ≤ i) (_inst_5 i)))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ (max u1 u2))) (succ (max u1 u2)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ (max u1 u2))} (Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) (fun (_x : Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) => (forall (i : Œπ), Œ≤ i) -> (PiLp.{u1, u2} p Œπ Œ≤)) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) (Equiv.symm.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.equiv.{u1, u2} p Œπ Œ≤)) (Pi.single.{u1, u2} Œπ (fun (i : Œπ) => Œ≤ i) (fun (a : Œπ) (b : Œπ) => _inst_10 a b) (fun (i : Œπ) => AddZeroClass.toHasZero.{u2} (Œ≤ i) (AddMonoid.toAddZeroClass.{u2} (Œ≤ i) (SubNegMonoid.toAddMonoid.{u2} (Œ≤ i) (AddGroup.toSubNegMonoid.{u2} (Œ≤ i) (SeminormedAddGroup.toAddGroup.{u2} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} (Œ≤ i) (_inst_5 i))))))) i b‚ÇÅ)) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ (max u1 u2))) (succ (max u1 u2)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ (max u1 u2))} (Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) (fun (_x : Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) => (forall (i : Œπ), Œ≤ i) -> (PiLp.{u1, u2} p Œπ Œ≤)) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) (Equiv.symm.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.equiv.{u1, u2} p Œπ Œ≤)) (Pi.single.{u1, u2} Œπ (fun (i : Œπ) => Œ≤ i) (fun (a : Œπ) (b : Œπ) => _inst_10 a b) (fun (i : Œπ) => AddZeroClass.toHasZero.{u2} (Œ≤ i) (AddMonoid.toAddZeroClass.{u2} (Œ≤ i) (SubNegMonoid.toAddMonoid.{u2} (Œ≤ i) (AddGroup.toSubNegMonoid.{u2} (Œ≤ i) (SeminormedAddGroup.toAddGroup.{u2} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} (Œ≤ i) (_inst_5 i))))))) i b‚ÇÇ))) (Dist.dist.{u2} (Œ≤ i) (PseudoMetricSpace.toHasDist.{u2} (Œ≤ i) (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} (Œ≤ i) (_inst_5 i))) b‚ÇÅ b‚ÇÇ)
but is expected to have type
  forall (p : ENNReal) {Œπ : Type.{u2}} (Œ≤ : Œπ -> Type.{u1}) [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u1} (Œ≤ i)] [_inst_10 : DecidableEq.{succ u2} Œπ] (i : Œπ) (b‚ÇÅ : Œ≤ i) (b‚ÇÇ : Œ≤ i), Eq.{1} Real (Dist.dist.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) (Pi.single.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (a : Œπ) (b : Œπ) => _inst_10 a b) (fun (i : Œπ) => NegZeroClass.toZero.{u1} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u1} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u1} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u1} (Œ≤ i) (_inst_5 i))))))) i b‚ÇÅ)) (PiLp.instDistPiLp.{u2, u1} p Œπ Œ≤ _inst_1 (fun (i : Œπ) => PseudoMetricSpace.toDist.{u1} (Œ≤ i) (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} (Œ≤ i) (_inst_5 i)))) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (forall (i : Œπ), Œ≤ i) (PiLp.{u2, u1} p Œπ Œ≤)) (forall (i : Œπ), Œ≤ i) (fun (_x : forall (i : Œπ), Œ≤ i) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (forall (i : Œπ), Œ≤ i) (PiLp.{u2, u1} p Œπ Œ≤)) (Equiv.symm.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.equiv.{u2, u1} p Œπ Œ≤)) (Pi.single.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (a : Œπ) (b : Œπ) => _inst_10 a b) (fun (i : Œπ) => NegZeroClass.toZero.{u1} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u1} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u1} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u1} (Œ≤ i) (_inst_5 i))))))) i b‚ÇÅ)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (forall (i : Œπ), Œ≤ i) (PiLp.{u2, u1} p Œπ Œ≤)) (forall (i : Œπ), Œ≤ i) (fun (_x : forall (i : Œπ), Œ≤ i) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (forall (i : Œπ), Œ≤ i) (PiLp.{u2, u1} p Œπ Œ≤)) (Equiv.symm.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.equiv.{u2, u1} p Œπ Œ≤)) (Pi.single.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (a : Œπ) (b : Œπ) => _inst_10 a b) (fun (i : Œπ) => NegZeroClass.toZero.{u1} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u1} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u1} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u1} (Œ≤ i) (_inst_5 i))))))) i b‚ÇÇ))) (Dist.dist.{u1} (Œ≤ i) (PseudoMetricSpace.toDist.{u1} (Œ≤ i) (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} (Œ≤ i) (_inst_5 i))) b‚ÇÅ b‚ÇÇ)
Case conversion may be inaccurate. Consider using '#align pi_Lp.dist_equiv_symm_single_same PiLp.dist_equiv_symm_single_same‚Çì'. -/
@[simp]
theorem dist_equiv_symm_single_same (i : Œπ) (b‚ÇÅ b‚ÇÇ : Œ≤ i) :
    dist ((PiLp.equiv p Œ≤).symm (Pi.single i b‚ÇÅ)) ((PiLp.equiv p Œ≤).symm (Pi.single i b‚ÇÇ)) =
      dist b‚ÇÅ b‚ÇÇ :=
  congr_arg coe <| nndist_equiv_symm_single_same p Œ≤ i b‚ÇÅ b‚ÇÇ
#align pi_Lp.dist_equiv_symm_single_same PiLp.dist_equiv_symm_single_same

/- warning: pi_Lp.edist_equiv_symm_single_same -> PiLp.edist_equiv_symm_single_same is a dubious translation:
lean 3 declaration is
  forall (p : ENNReal) {Œπ : Type.{u1}} (Œ≤ : Œπ -> Type.{u2}) [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u2} (Œ≤ i)] [_inst_10 : DecidableEq.{succ u1} Œπ] (i : Œπ) (b‚ÇÅ : Œ≤ i) (b‚ÇÇ : Œ≤ i), Eq.{1} ENNReal (EDist.edist.{max u1 u2} (PiLp.{u1, u2} p Œπ Œ≤) (PiLp.hasEdist.{u1, u2} p Œπ Œ≤ _inst_1 (fun (i : Œπ) => PseudoMetricSpace.toEDist.{u2} (Œ≤ i) (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} (Œ≤ i) (_inst_5 i)))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ (max u1 u2))) (succ (max u1 u2)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ (max u1 u2))} (Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) (fun (_x : Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) => (forall (i : Œπ), Œ≤ i) -> (PiLp.{u1, u2} p Œπ Œ≤)) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) (Equiv.symm.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.equiv.{u1, u2} p Œπ Œ≤)) (Pi.single.{u1, u2} Œπ (fun (i : Œπ) => Œ≤ i) (fun (a : Œπ) (b : Œπ) => _inst_10 a b) (fun (i : Œπ) => AddZeroClass.toHasZero.{u2} (Œ≤ i) (AddMonoid.toAddZeroClass.{u2} (Œ≤ i) (SubNegMonoid.toAddMonoid.{u2} (Œ≤ i) (AddGroup.toSubNegMonoid.{u2} (Œ≤ i) (SeminormedAddGroup.toAddGroup.{u2} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} (Œ≤ i) (_inst_5 i))))))) i b‚ÇÅ)) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ (max u1 u2))) (succ (max u1 u2)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ (max u1 u2))} (Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) (fun (_x : Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) => (forall (i : Œπ), Œ≤ i) -> (PiLp.{u1, u2} p Œπ Œ≤)) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), Œ≤ i) (PiLp.{u1, u2} p Œπ Œ≤)) (Equiv.symm.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.equiv.{u1, u2} p Œπ Œ≤)) (Pi.single.{u1, u2} Œπ (fun (i : Œπ) => Œ≤ i) (fun (a : Œπ) (b : Œπ) => _inst_10 a b) (fun (i : Œπ) => AddZeroClass.toHasZero.{u2} (Œ≤ i) (AddMonoid.toAddZeroClass.{u2} (Œ≤ i) (SubNegMonoid.toAddMonoid.{u2} (Œ≤ i) (AddGroup.toSubNegMonoid.{u2} (Œ≤ i) (SeminormedAddGroup.toAddGroup.{u2} (Œ≤ i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} (Œ≤ i) (_inst_5 i))))))) i b‚ÇÇ))) (EDist.edist.{u2} (Œ≤ i) (PseudoMetricSpace.toEDist.{u2} (Œ≤ i) (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} (Œ≤ i) (_inst_5 i))) b‚ÇÅ b‚ÇÇ)
but is expected to have type
  forall (p : ENNReal) {Œπ : Type.{u2}} (Œ≤ : Œπ -> Type.{u1}) [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u1} (Œ≤ i)] [_inst_10 : DecidableEq.{succ u2} Œπ] (i : Œπ) (b‚ÇÅ : Œ≤ i) (b‚ÇÇ : Œ≤ i), Eq.{1} ENNReal (EDist.edist.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) (Pi.single.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (a : Œπ) (b : Œπ) => _inst_10 a b) (fun (i : Œπ) => NegZeroClass.toZero.{u1} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u1} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u1} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u1} (Œ≤ i) (_inst_5 i))))))) i b‚ÇÅ)) (PiLp.instEDistPiLp.{u2, u1} p Œπ Œ≤ _inst_1 (fun (i : Œπ) => PseudoEMetricSpace.toEDist.{u1} (Œ≤ i) (PseudoMetricSpace.toPseudoEMetricSpace.{u1} (Œ≤ i) (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} (Œ≤ i) (_inst_5 i))))) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (forall (i : Œπ), Œ≤ i) (PiLp.{u2, u1} p Œπ Œ≤)) (forall (i : Œπ), Œ≤ i) (fun (_x : forall (i : Œπ), Œ≤ i) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (forall (i : Œπ), Œ≤ i) (PiLp.{u2, u1} p Œπ Œ≤)) (Equiv.symm.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.equiv.{u2, u1} p Œπ Œ≤)) (Pi.single.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (a : Œπ) (b : Œπ) => _inst_10 a b) (fun (i : Œπ) => NegZeroClass.toZero.{u1} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u1} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u1} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u1} (Œ≤ i) (_inst_5 i))))))) i b‚ÇÅ)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (forall (i : Œπ), Œ≤ i) (PiLp.{u2, u1} p Œπ Œ≤)) (forall (i : Œπ), Œ≤ i) (fun (_x : forall (i : Œπ), Œ≤ i) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : forall (i : Œπ), Œ≤ i) => PiLp.{u2, u1} p Œπ Œ≤) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (forall (i : Œπ), Œ≤ i) (PiLp.{u2, u1} p Œπ Œ≤)) (Equiv.symm.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (PiLp.{u2, u1} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (PiLp.equiv.{u2, u1} p Œπ Œ≤)) (Pi.single.{u2, u1} Œπ (fun (i : Œπ) => Œ≤ i) (fun (a : Œπ) (b : Œπ) => _inst_10 a b) (fun (i : Œπ) => NegZeroClass.toZero.{u1} (Œ≤ i) (SubNegZeroMonoid.toNegZeroClass.{u1} (Œ≤ i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (Œ≤ i) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (Œ≤ i) (AddCommGroup.toDivisionAddCommMonoid.{u1} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u1} (Œ≤ i) (_inst_5 i))))))) i b‚ÇÇ))) (EDist.edist.{u1} (Œ≤ i) (PseudoEMetricSpace.toEDist.{u1} (Œ≤ i) (PseudoMetricSpace.toPseudoEMetricSpace.{u1} (Œ≤ i) (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} (Œ≤ i) (_inst_5 i)))) b‚ÇÅ b‚ÇÇ)
Case conversion may be inaccurate. Consider using '#align pi_Lp.edist_equiv_symm_single_same PiLp.edist_equiv_symm_single_same‚Çì'. -/
@[simp]
theorem edist_equiv_symm_single_same (i : Œπ) (b‚ÇÅ b‚ÇÇ : Œ≤ i) :
    edist ((PiLp.equiv p Œ≤).symm (Pi.single i b‚ÇÅ)) ((PiLp.equiv p Œ≤).symm (Pi.single i b‚ÇÇ)) =
      edist b‚ÇÅ b‚ÇÇ :=
  by simpa only [edist_nndist] using congr_arg coe (nndist_equiv_symm_single_same p Œ≤ i b‚ÇÅ b‚ÇÇ)
#align pi_Lp.edist_equiv_symm_single_same PiLp.edist_equiv_symm_single_same

end Single

/- warning: pi_Lp.nnnorm_equiv_symm_const -> PiLp.nnnorm_equiv_symm_const is a dubious translation:
lean 3 declaration is
  forall {p : ENNReal} {Œπ : Type.{u1}} [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] {Œ≤ : Type.{u2}} [_inst_10 : SeminormedAddCommGroup.{u2} Œ≤], (Ne.{1} ENNReal p (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (forall (b : Œ≤), Eq.{1} NNReal (NNNorm.nnnorm.{max u1 u2} (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤)) (SeminormedAddGroup.toNNNorm.{max u1 u2} (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤)) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤)) (PiLp.seminormedAddCommGroup.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤) _inst_1 _inst_2 (fun (i : Œπ) => _inst_10)))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ (max u1 u2))) (succ (max u1 u2)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ (max u1 u2))} (Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (fun (_x : Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) => (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) -> (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (Equiv.symm.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤)) (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) (PiLp.equiv.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (Function.const.{succ u2, succ u1} Œ≤ Œπ b))) (HMul.hMul.{0, 0, 0} NNReal NNReal NNReal (instHMul.{0} NNReal (Distrib.toHasMul.{0} NNReal (NonUnitalNonAssocSemiring.toDistrib.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))) (HPow.hPow.{0, 0, 0} NNReal Real NNReal (instHPow.{0, 0} NNReal Real NNReal.Real.hasPow) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat NNReal (HasLiftT.mk.{1, 1} Nat NNReal (CoeTC‚Çì.coe.{1, 1} Nat NNReal (Nat.castCoe.{0} NNReal (AddMonoidWithOne.toNatCast.{0} NNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} NNReal (NonAssocSemiring.toAddCommMonoidWithOne.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))))) (Fintype.card.{u1} Œπ _inst_1)) (ENNReal.toReal (HDiv.hDiv.{0, 0, 0} ENNReal ENNReal ENNReal (instHDiv.{0} ENNReal (DivInvMonoid.toHasDiv.{0} ENNReal ENNReal.divInvMonoid)) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p))) (NNNorm.nnnorm.{u2} Œ≤ (SeminormedAddGroup.toNNNorm.{u2} Œ≤ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} Œ≤ _inst_10)) b)))
but is expected to have type
  forall {p : ENNReal} {Œπ : Type.{u1}} [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] {Œ≤ : Type.{u2}} [_inst_10 : SeminormedAddCommGroup.{u2} Œ≤], (Ne.{1} ENNReal p (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (forall (b : Œ≤), Eq.{1} NNReal (NNNorm.nnnorm.{max u1 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : Œπ -> Œ≤) => PiLp.{u1, u2} p Œπ (fun (x._@.Mathlib.Analysis.NormedSpace.PiLp._hyg.11210 : Œπ) => Œ≤)) (Function.const.{succ u2, succ u1} Œ≤ Œπ b)) (SeminormedAddGroup.toNNNorm.{max u1 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : Œπ -> Œ≤) => PiLp.{u1, u2} p Œπ (fun (x._@.Mathlib.Analysis.NormedSpace.PiLp._hyg.11210 : Œπ) => Œ≤)) (Function.const.{succ u2, succ u1} Œ≤ Œπ b)) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : Œπ -> Œ≤) => PiLp.{u1, u2} p Œπ (fun (x._@.Mathlib.Analysis.NormedSpace.PiLp._hyg.11210 : Œπ) => Œ≤)) (Function.const.{succ u2, succ u1} Œ≤ Œπ b)) (PiLp.seminormedAddCommGroup.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤) _inst_1 _inst_2 (fun (i : Œπ) => _inst_10)))) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Œπ -> Œ≤) (PiLp.{u1, u2} p Œπ (fun (x._@.Mathlib.Analysis.NormedSpace.PiLp._hyg.11210 : Œπ) => Œ≤))) (Œπ -> Œ≤) (fun (_x : Œπ -> Œ≤) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : Œπ -> Œ≤) => PiLp.{u1, u2} p Œπ (fun (x._@.Mathlib.Analysis.NormedSpace.PiLp._hyg.11210 : Œπ) => Œ≤)) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Œπ -> Œ≤) (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (Equiv.symm.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤)) (Œπ -> Œ≤) (PiLp.equiv.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (Function.const.{succ u2, succ u1} Œ≤ Œπ b))) (HMul.hMul.{0, 0, 0} NNReal NNReal NNReal (instHMul.{0} NNReal (CanonicallyOrderedCommSemiring.toMul.{0} NNReal instNNRealCanonicallyOrderedCommSemiring)) (HPow.hPow.{0, 0, 0} NNReal Real NNReal (instHPow.{0, 0} NNReal Real NNReal.instPowNNRealReal) (Nat.cast.{0} NNReal (CanonicallyOrderedCommSemiring.toNatCast.{0} NNReal instNNRealCanonicallyOrderedCommSemiring) (Fintype.card.{u1} Œπ _inst_1)) (ENNReal.toReal (HDiv.hDiv.{0, 0, 0} ENNReal ENNReal ENNReal (instHDiv.{0} ENNReal (DivInvMonoid.toDiv.{0} ENNReal ENNReal.instDivInvMonoidENNReal)) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p))) (NNNorm.nnnorm.{u2} Œ≤ (SeminormedAddGroup.toNNNorm.{u2} Œ≤ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} Œ≤ _inst_10)) b)))
Case conversion may be inaccurate. Consider using '#align pi_Lp.nnnorm_equiv_symm_const PiLp.nnnorm_equiv_symm_const‚Çì'. -/
/-- When `p = ‚àû`, this lemma does not hold without the additional assumption `nonempty Œπ` because
the left-hand side simplifies to `0`, while the right-hand side simplifies to `‚Äñb‚Äñ‚Çä`. See
`pi_Lp.nnnorm_equiv_symm_const'` for a version which exchanges the hypothesis `p ‚â† ‚àû` for
`nonempty Œπ`. -/
theorem nnnorm_equiv_symm_const {Œ≤} [SeminormedAddCommGroup Œ≤] (hp : p ‚â† ‚àû) (b : Œ≤) :
    ‚Äñ(PiLp.equiv p fun _ : Œπ => Œ≤).symm (Function.const _ b)‚Äñ‚Çä =
      Fintype.card Œπ ^ (1 / p).toReal * ‚Äñb‚Äñ‚Çä :=
  by
  rcases p.dichotomy with (h | h)
  ¬∑ exact False.elim (hp h)
  ¬∑ have ne_zero : p.to_real ‚â† 0 := (zero_lt_one.trans_le h).ne'
    simp_rw [nnnorm_eq_sum hp, equiv_symm_apply, Function.const_apply, Finset.sum_const,
      Finset.card_univ, nsmul_eq_mul, NNReal.mul_rpow, ‚Üê NNReal.rpow_mul, mul_one_div_cancel NeZero,
      NNReal.rpow_one, ENNReal.toReal_div, ENNReal.one_toReal]
#align pi_Lp.nnnorm_equiv_symm_const PiLp.nnnorm_equiv_symm_const

/- warning: pi_Lp.nnnorm_equiv_symm_const' -> PiLp.nnnorm_equiv_symm_const' is a dubious translation:
lean 3 declaration is
  forall {p : ENNReal} {Œπ : Type.{u1}} [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] {Œ≤ : Type.{u2}} [_inst_10 : SeminormedAddCommGroup.{u2} Œ≤] [_inst_11 : Nonempty.{succ u1} Œπ] (b : Œ≤), Eq.{1} NNReal (NNNorm.nnnorm.{max u1 u2} (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤)) (SeminormedAddGroup.toNNNorm.{max u1 u2} (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤)) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤)) (PiLp.seminormedAddCommGroup.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤) _inst_1 _inst_2 (fun (i : Œπ) => _inst_10)))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ (max u1 u2))) (succ (max u1 u2)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ (max u1 u2))} (Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (fun (_x : Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) => (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) -> (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (Equiv.symm.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤)) (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) (PiLp.equiv.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (Function.const.{succ u2, succ u1} Œ≤ Œπ b))) (HMul.hMul.{0, 0, 0} NNReal NNReal NNReal (instHMul.{0} NNReal (Distrib.toHasMul.{0} NNReal (NonUnitalNonAssocSemiring.toDistrib.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))) (HPow.hPow.{0, 0, 0} NNReal Real NNReal (instHPow.{0, 0} NNReal Real NNReal.Real.hasPow) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat NNReal (HasLiftT.mk.{1, 1} Nat NNReal (CoeTC‚Çì.coe.{1, 1} Nat NNReal (Nat.castCoe.{0} NNReal (AddMonoidWithOne.toNatCast.{0} NNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} NNReal (NonAssocSemiring.toAddCommMonoidWithOne.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))))) (Fintype.card.{u1} Œπ _inst_1)) (ENNReal.toReal (HDiv.hDiv.{0, 0, 0} ENNReal ENNReal ENNReal (instHDiv.{0} ENNReal (DivInvMonoid.toHasDiv.{0} ENNReal ENNReal.divInvMonoid)) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p))) (NNNorm.nnnorm.{u2} Œ≤ (SeminormedAddGroup.toNNNorm.{u2} Œ≤ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} Œ≤ _inst_10)) b))
but is expected to have type
  forall {p : ENNReal} {Œπ : Type.{u1}} [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] {Œ≤ : Type.{u2}} [_inst_10 : SeminormedAddCommGroup.{u2} Œ≤] [_inst_11 : Nonempty.{succ u1} Œπ] (b : Œ≤), Eq.{1} NNReal (NNNorm.nnnorm.{max u1 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : Œπ -> Œ≤) => PiLp.{u1, u2} p Œπ (fun (x._@.Mathlib.Analysis.NormedSpace.PiLp._hyg.11402 : Œπ) => Œ≤)) (Function.const.{succ u2, succ u1} Œ≤ Œπ b)) (SeminormedAddGroup.toNNNorm.{max u1 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : Œπ -> Œ≤) => PiLp.{u1, u2} p Œπ (fun (x._@.Mathlib.Analysis.NormedSpace.PiLp._hyg.11402 : Œπ) => Œ≤)) (Function.const.{succ u2, succ u1} Œ≤ Œπ b)) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : Œπ -> Œ≤) => PiLp.{u1, u2} p Œπ (fun (x._@.Mathlib.Analysis.NormedSpace.PiLp._hyg.11402 : Œπ) => Œ≤)) (Function.const.{succ u2, succ u1} Œ≤ Œπ b)) (PiLp.seminormedAddCommGroup.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤) _inst_1 _inst_2 (fun (i : Œπ) => _inst_10)))) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Œπ -> Œ≤) (PiLp.{u1, u2} p Œπ (fun (x._@.Mathlib.Analysis.NormedSpace.PiLp._hyg.11402 : Œπ) => Œ≤))) (Œπ -> Œ≤) (fun (_x : Œπ -> Œ≤) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : Œπ -> Œ≤) => PiLp.{u1, u2} p Œπ (fun (x._@.Mathlib.Analysis.NormedSpace.PiLp._hyg.11402 : Œπ) => Œ≤)) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Œπ -> Œ≤) (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (Equiv.symm.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤)) (Œπ -> Œ≤) (PiLp.equiv.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (Function.const.{succ u2, succ u1} Œ≤ Œπ b))) (HMul.hMul.{0, 0, 0} NNReal NNReal NNReal (instHMul.{0} NNReal (CanonicallyOrderedCommSemiring.toMul.{0} NNReal instNNRealCanonicallyOrderedCommSemiring)) (HPow.hPow.{0, 0, 0} NNReal Real NNReal (instHPow.{0, 0} NNReal Real NNReal.instPowNNRealReal) (Nat.cast.{0} NNReal (CanonicallyOrderedCommSemiring.toNatCast.{0} NNReal instNNRealCanonicallyOrderedCommSemiring) (Fintype.card.{u1} Œπ _inst_1)) (ENNReal.toReal (HDiv.hDiv.{0, 0, 0} ENNReal ENNReal ENNReal (instHDiv.{0} ENNReal (DivInvMonoid.toDiv.{0} ENNReal ENNReal.instDivInvMonoidENNReal)) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p))) (NNNorm.nnnorm.{u2} Œ≤ (SeminormedAddGroup.toNNNorm.{u2} Œ≤ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} Œ≤ _inst_10)) b))
Case conversion may be inaccurate. Consider using '#align pi_Lp.nnnorm_equiv_symm_const' PiLp.nnnorm_equiv_symm_const'‚Çì'. -/
/-- When `is_empty Œπ`, this lemma does not hold without the additional assumption `p ‚â† ‚àû` because
the left-hand side simplifies to `0`, while the right-hand side simplifies to `‚Äñb‚Äñ‚Çä`. See
`pi_Lp.nnnorm_equiv_symm_const` for a version which exchanges the hypothesis `nonempty Œπ`.
for `p ‚â† ‚àû`. -/
theorem nnnorm_equiv_symm_const' {Œ≤} [SeminormedAddCommGroup Œ≤] [Nonempty Œπ] (b : Œ≤) :
    ‚Äñ(PiLp.equiv p fun _ : Œπ => Œ≤).symm (Function.const _ b)‚Äñ‚Çä =
      Fintype.card Œπ ^ (1 / p).toReal * ‚Äñb‚Äñ‚Çä :=
  by
  rcases em <| p = ‚àû with (rfl | hp)
  ¬∑
    simp only [equiv_symm_apply, ENNReal.div_top, ENNReal.zero_toReal, NNReal.rpow_zero, one_mul,
      nnnorm_eq_csupr, Function.const_apply, ciSup_const]
  ¬∑ exact nnnorm_equiv_symm_const hp b
#align pi_Lp.nnnorm_equiv_symm_const' PiLp.nnnorm_equiv_symm_const'

/- warning: pi_Lp.norm_equiv_symm_const -> PiLp.norm_equiv_symm_const is a dubious translation:
lean 3 declaration is
  forall {p : ENNReal} {Œπ : Type.{u1}} [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] {Œ≤ : Type.{u2}} [_inst_10 : SeminormedAddCommGroup.{u2} Œ≤], (Ne.{1} ENNReal p (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (forall (b : Œ≤), Eq.{1} Real (Norm.norm.{max u1 u2} (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤)) (PiLp.hasNorm.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤) _inst_1 (fun (i : Œπ) => SeminormedAddCommGroup.toHasNorm.{u2} Œ≤ _inst_10) (fun (i : Œπ) => AddZeroClass.toHasZero.{u2} Œ≤ (AddMonoid.toAddZeroClass.{u2} Œ≤ (SubNegMonoid.toAddMonoid.{u2} Œ≤ (AddGroup.toSubNegMonoid.{u2} Œ≤ (SeminormedAddGroup.toAddGroup.{u2} Œ≤ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} Œ≤ _inst_10))))))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ (max u1 u2))) (succ (max u1 u2)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ (max u1 u2))} (Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (fun (_x : Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) => (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) -> (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (Equiv.symm.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤)) (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) (PiLp.equiv.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (Function.const.{succ u2, succ u1} Œ≤ Œπ b))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (HPow.hPow.{0, 0, 0} Real Real Real (instHPow.{0, 0} Real Real Real.hasPow) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTC‚Çì.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) (Fintype.card.{u1} Œπ _inst_1)) (ENNReal.toReal (HDiv.hDiv.{0, 0, 0} ENNReal ENNReal ENNReal (instHDiv.{0} ENNReal (DivInvMonoid.toHasDiv.{0} ENNReal ENNReal.divInvMonoid)) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p))) (Norm.norm.{u2} Œ≤ (SeminormedAddCommGroup.toHasNorm.{u2} Œ≤ _inst_10) b)))
but is expected to have type
  forall {p : ENNReal} {Œπ : Type.{u1}} [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] {Œ≤ : Type.{u2}} [_inst_10 : SeminormedAddCommGroup.{u2} Œ≤], (Ne.{1} ENNReal p (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (forall (b : Œ≤), Eq.{1} Real (Norm.norm.{max u1 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : Œπ -> Œ≤) => PiLp.{u1, u2} p Œπ (fun (x._@.Mathlib.Analysis.NormedSpace.PiLp._hyg.11575 : Œπ) => Œ≤)) (Function.const.{succ u2, succ u1} Œ≤ Œπ b)) (PiLp.hasNorm.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤) _inst_1 (fun (i : Œπ) => SeminormedAddCommGroup.toNorm.{u2} Œ≤ _inst_10) (fun (i : Œπ) => NegZeroClass.toZero.{u2} Œ≤ (SubNegZeroMonoid.toNegZeroClass.{u2} Œ≤ (SubtractionMonoid.toSubNegZeroMonoid.{u2} Œ≤ (SubtractionCommMonoid.toSubtractionMonoid.{u2} Œ≤ (AddCommGroup.toDivisionAddCommMonoid.{u2} Œ≤ (SeminormedAddCommGroup.toAddCommGroup.{u2} Œ≤ _inst_10))))))) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Œπ -> Œ≤) (PiLp.{u1, u2} p Œπ (fun (x._@.Mathlib.Analysis.NormedSpace.PiLp._hyg.11575 : Œπ) => Œ≤))) (Œπ -> Œ≤) (fun (_x : Œπ -> Œ≤) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : Œπ -> Œ≤) => PiLp.{u1, u2} p Œπ (fun (x._@.Mathlib.Analysis.NormedSpace.PiLp._hyg.11575 : Œπ) => Œ≤)) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Œπ -> Œ≤) (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (Equiv.symm.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤)) (Œπ -> Œ≤) (PiLp.equiv.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (Function.const.{succ u2, succ u1} Œ≤ Œπ b))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (NNReal.toReal (HPow.hPow.{0, 0, 0} NNReal Real NNReal (instHPow.{0, 0} NNReal Real NNReal.instPowNNRealReal) (Nat.cast.{0} NNReal (CanonicallyOrderedCommSemiring.toNatCast.{0} NNReal instNNRealCanonicallyOrderedCommSemiring) (Fintype.card.{u1} Œπ _inst_1)) (ENNReal.toReal (HDiv.hDiv.{0, 0, 0} ENNReal ENNReal ENNReal (instHDiv.{0} ENNReal (DivInvMonoid.toDiv.{0} ENNReal ENNReal.instDivInvMonoidENNReal)) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)))) (Norm.norm.{u2} Œ≤ (SeminormedAddCommGroup.toNorm.{u2} Œ≤ _inst_10) b)))
Case conversion may be inaccurate. Consider using '#align pi_Lp.norm_equiv_symm_const PiLp.norm_equiv_symm_const‚Çì'. -/
/-- When `p = ‚àû`, this lemma does not hold without the additional assumption `nonempty Œπ` because
the left-hand side simplifies to `0`, while the right-hand side simplifies to `‚Äñb‚Äñ‚Çä`. See
`pi_Lp.norm_equiv_symm_const'` for a version which exchanges the hypothesis `p ‚â† ‚àû` for
`nonempty Œπ`. -/
theorem norm_equiv_symm_const {Œ≤} [SeminormedAddCommGroup Œ≤] (hp : p ‚â† ‚àû) (b : Œ≤) :
    ‚Äñ(PiLp.equiv p fun _ : Œπ => Œ≤).symm (Function.const _ b)‚Äñ =
      Fintype.card Œπ ^ (1 / p).toReal * ‚Äñb‚Äñ :=
  (congr_arg coe <| nnnorm_equiv_symm_const hp b).trans <| by simp
#align pi_Lp.norm_equiv_symm_const PiLp.norm_equiv_symm_const

/- warning: pi_Lp.norm_equiv_symm_const' -> PiLp.norm_equiv_symm_const' is a dubious translation:
lean 3 declaration is
  forall {p : ENNReal} {Œπ : Type.{u1}} [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] {Œ≤ : Type.{u2}} [_inst_10 : SeminormedAddCommGroup.{u2} Œ≤] [_inst_11 : Nonempty.{succ u1} Œπ] (b : Œ≤), Eq.{1} Real (Norm.norm.{max u1 u2} (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤)) (PiLp.hasNorm.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤) _inst_1 (fun (i : Œπ) => SeminormedAddCommGroup.toHasNorm.{u2} Œ≤ _inst_10) (fun (i : Œπ) => AddZeroClass.toHasZero.{u2} Œ≤ (AddMonoid.toAddZeroClass.{u2} Œ≤ (SubNegMonoid.toAddMonoid.{u2} Œ≤ (AddGroup.toSubNegMonoid.{u2} Œ≤ (SeminormedAddGroup.toAddGroup.{u2} Œ≤ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} Œ≤ _inst_10))))))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ (max u1 u2))) (succ (max u1 u2)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ (max u1 u2))} (Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (fun (_x : Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) => (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) -> (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (Equiv.symm.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤)) (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) (PiLp.equiv.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (Function.const.{succ u2, succ u1} Œ≤ Œπ b))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (HPow.hPow.{0, 0, 0} Real Real Real (instHPow.{0, 0} Real Real Real.hasPow) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTC‚Çì.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) (Fintype.card.{u1} Œπ _inst_1)) (ENNReal.toReal (HDiv.hDiv.{0, 0, 0} ENNReal ENNReal ENNReal (instHDiv.{0} ENNReal (DivInvMonoid.toHasDiv.{0} ENNReal ENNReal.divInvMonoid)) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p))) (Norm.norm.{u2} Œ≤ (SeminormedAddCommGroup.toHasNorm.{u2} Œ≤ _inst_10) b))
but is expected to have type
  forall {p : ENNReal} {Œπ : Type.{u1}} [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] {Œ≤ : Type.{u2}} [_inst_10 : SeminormedAddCommGroup.{u2} Œ≤] [_inst_11 : Nonempty.{succ u1} Œπ] (b : Œ≤), Eq.{1} Real (Norm.norm.{max u1 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : Œπ -> Œ≤) => PiLp.{u1, u2} p Œπ (fun (x._@.Mathlib.Analysis.NormedSpace.PiLp._hyg.11733 : Œπ) => Œ≤)) (Function.const.{succ u2, succ u1} Œ≤ Œπ b)) (PiLp.hasNorm.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤) _inst_1 (fun (i : Œπ) => SeminormedAddCommGroup.toNorm.{u2} Œ≤ _inst_10) (fun (i : Œπ) => NegZeroClass.toZero.{u2} Œ≤ (SubNegZeroMonoid.toNegZeroClass.{u2} Œ≤ (SubtractionMonoid.toSubNegZeroMonoid.{u2} Œ≤ (SubtractionCommMonoid.toSubtractionMonoid.{u2} Œ≤ (AddCommGroup.toDivisionAddCommMonoid.{u2} Œ≤ (SeminormedAddCommGroup.toAddCommGroup.{u2} Œ≤ _inst_10))))))) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Œπ -> Œ≤) (PiLp.{u1, u2} p Œπ (fun (x._@.Mathlib.Analysis.NormedSpace.PiLp._hyg.11733 : Œπ) => Œ≤))) (Œπ -> Œ≤) (fun (_x : Œπ -> Œ≤) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : Œπ -> Œ≤) => PiLp.{u1, u2} p Œπ (fun (x._@.Mathlib.Analysis.NormedSpace.PiLp._hyg.11733 : Œπ) => Œ≤)) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Œπ -> Œ≤) (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (Equiv.symm.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤)) (Œπ -> Œ≤) (PiLp.equiv.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (Function.const.{succ u2, succ u1} Œ≤ Œπ b))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (NNReal.toReal (HPow.hPow.{0, 0, 0} NNReal Real NNReal (instHPow.{0, 0} NNReal Real NNReal.instPowNNRealReal) (Nat.cast.{0} NNReal (CanonicallyOrderedCommSemiring.toNatCast.{0} NNReal instNNRealCanonicallyOrderedCommSemiring) (Fintype.card.{u1} Œπ _inst_1)) (ENNReal.toReal (HDiv.hDiv.{0, 0, 0} ENNReal ENNReal ENNReal (instHDiv.{0} ENNReal (DivInvMonoid.toDiv.{0} ENNReal ENNReal.instDivInvMonoidENNReal)) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)))) (Norm.norm.{u2} Œ≤ (SeminormedAddCommGroup.toNorm.{u2} Œ≤ _inst_10) b))
Case conversion may be inaccurate. Consider using '#align pi_Lp.norm_equiv_symm_const' PiLp.norm_equiv_symm_const'‚Çì'. -/
/-- When `is_empty Œπ`, this lemma does not hold without the additional assumption `p ‚â† ‚àû` because
the left-hand side simplifies to `0`, while the right-hand side simplifies to `‚Äñb‚Äñ‚Çä`. See
`pi_Lp.norm_equiv_symm_const` for a version which exchanges the hypothesis `nonempty Œπ`.
for `p ‚â† ‚àû`. -/
theorem norm_equiv_symm_const' {Œ≤} [SeminormedAddCommGroup Œ≤] [Nonempty Œπ] (b : Œ≤) :
    ‚Äñ(PiLp.equiv p fun _ : Œπ => Œ≤).symm (Function.const _ b)‚Äñ =
      Fintype.card Œπ ^ (1 / p).toReal * ‚Äñb‚Äñ :=
  (congr_arg coe <| nnnorm_equiv_symm_const' b).trans <| by simp
#align pi_Lp.norm_equiv_symm_const' PiLp.norm_equiv_symm_const'

/- warning: pi_Lp.nnnorm_equiv_symm_one -> PiLp.nnnorm_equiv_symm_one is a dubious translation:
lean 3 declaration is
  forall {p : ENNReal} {Œπ : Type.{u1}} [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] {Œ≤ : Type.{u2}} [_inst_10 : SeminormedAddCommGroup.{u2} Œ≤], (Ne.{1} ENNReal p (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (forall [_inst_11 : One.{u2} Œ≤], Eq.{1} NNReal (NNNorm.nnnorm.{max u1 u2} (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤)) (SeminormedAddGroup.toNNNorm.{max u1 u2} (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤)) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤)) (PiLp.seminormedAddCommGroup.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤) _inst_1 _inst_2 (fun (i : Œπ) => _inst_10)))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ (max u1 u2))) (succ (max u1 u2)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ (max u1 u2))} (Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (fun (_x : Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) => (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) -> (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (Equiv.symm.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤)) (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) (PiLp.equiv.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (OfNat.ofNat.{max u1 u2} (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) 1 (OfNat.mk.{max u1 u2} (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) 1 (One.one.{max u1 u2} (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) (Pi.instOne.{u1, u2} Œπ (fun (i : Œπ) => (fun (_x : Œπ) => Œ≤) i) (fun (i : Œπ) => _inst_11))))))) (HMul.hMul.{0, 0, 0} NNReal NNReal NNReal (instHMul.{0} NNReal (Distrib.toHasMul.{0} NNReal (NonUnitalNonAssocSemiring.toDistrib.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))) (HPow.hPow.{0, 0, 0} NNReal Real NNReal (instHPow.{0, 0} NNReal Real NNReal.Real.hasPow) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat NNReal (HasLiftT.mk.{1, 1} Nat NNReal (CoeTC‚Çì.coe.{1, 1} Nat NNReal (Nat.castCoe.{0} NNReal (AddMonoidWithOne.toNatCast.{0} NNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} NNReal (NonAssocSemiring.toAddCommMonoidWithOne.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))))) (Fintype.card.{u1} Œπ _inst_1)) (ENNReal.toReal (HDiv.hDiv.{0, 0, 0} ENNReal ENNReal ENNReal (instHDiv.{0} ENNReal (DivInvMonoid.toHasDiv.{0} ENNReal ENNReal.divInvMonoid)) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p))) (NNNorm.nnnorm.{u2} Œ≤ (SeminormedAddGroup.toNNNorm.{u2} Œ≤ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} Œ≤ _inst_10)) (OfNat.ofNat.{u2} Œ≤ 1 (OfNat.mk.{u2} Œ≤ 1 (One.one.{u2} Œ≤ _inst_11))))))
but is expected to have type
  forall {p : ENNReal} {Œπ : Type.{u1}} [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] {Œ≤ : Type.{u2}} [_inst_10 : SeminormedAddCommGroup.{u2} Œ≤], (Ne.{1} ENNReal p (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (forall [_inst_11 : One.{u2} Œ≤], Eq.{1} NNReal (NNNorm.nnnorm.{max u1 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : Œπ -> Œ≤) => PiLp.{u1, u2} p Œπ (fun (x._@.Mathlib.Analysis.NormedSpace.PiLp._hyg.11901 : Œπ) => Œ≤)) (OfNat.ofNat.{max u1 u2} (Œπ -> Œ≤) 1 (One.toOfNat1.{max u1 u2} (Œπ -> Œ≤) (Pi.instOne.{u1, u2} Œπ (fun (i : Œπ) => Œ≤) (fun (i : Œπ) => _inst_11))))) (SeminormedAddGroup.toNNNorm.{max u1 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : Œπ -> Œ≤) => PiLp.{u1, u2} p Œπ (fun (x._@.Mathlib.Analysis.NormedSpace.PiLp._hyg.11901 : Œπ) => Œ≤)) (OfNat.ofNat.{max u1 u2} (Œπ -> Œ≤) 1 (One.toOfNat1.{max u1 u2} (Œπ -> Œ≤) (Pi.instOne.{u1, u2} Œπ (fun (i : Œπ) => Œ≤) (fun (i : Œπ) => _inst_11))))) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : Œπ -> Œ≤) => PiLp.{u1, u2} p Œπ (fun (x._@.Mathlib.Analysis.NormedSpace.PiLp._hyg.11901 : Œπ) => Œ≤)) (OfNat.ofNat.{max u1 u2} (Œπ -> Œ≤) 1 (One.toOfNat1.{max u1 u2} (Œπ -> Œ≤) (Pi.instOne.{u1, u2} Œπ (fun (i : Œπ) => Œ≤) (fun (i : Œπ) => _inst_11))))) (PiLp.seminormedAddCommGroup.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤) _inst_1 _inst_2 (fun (i : Œπ) => _inst_10)))) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Œπ -> Œ≤) (PiLp.{u1, u2} p Œπ (fun (x._@.Mathlib.Analysis.NormedSpace.PiLp._hyg.11901 : Œπ) => Œ≤))) (Œπ -> Œ≤) (fun (_x : Œπ -> Œ≤) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : Œπ -> Œ≤) => PiLp.{u1, u2} p Œπ (fun (x._@.Mathlib.Analysis.NormedSpace.PiLp._hyg.11901 : Œπ) => Œ≤)) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Œπ -> Œ≤) (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (Equiv.symm.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤)) (Œπ -> Œ≤) (PiLp.equiv.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (OfNat.ofNat.{max u1 u2} (Œπ -> Œ≤) 1 (One.toOfNat1.{max u1 u2} (Œπ -> Œ≤) (Pi.instOne.{u1, u2} Œπ (fun (i : Œπ) => Œ≤) (fun (i : Œπ) => _inst_11)))))) (HMul.hMul.{0, 0, 0} NNReal NNReal NNReal (instHMul.{0} NNReal (CanonicallyOrderedCommSemiring.toMul.{0} NNReal instNNRealCanonicallyOrderedCommSemiring)) (HPow.hPow.{0, 0, 0} NNReal Real NNReal (instHPow.{0, 0} NNReal Real NNReal.instPowNNRealReal) (Nat.cast.{0} NNReal (CanonicallyOrderedCommSemiring.toNatCast.{0} NNReal instNNRealCanonicallyOrderedCommSemiring) (Fintype.card.{u1} Œπ _inst_1)) (ENNReal.toReal (HDiv.hDiv.{0, 0, 0} ENNReal ENNReal ENNReal (instHDiv.{0} ENNReal (DivInvMonoid.toDiv.{0} ENNReal ENNReal.instDivInvMonoidENNReal)) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p))) (NNNorm.nnnorm.{u2} Œ≤ (SeminormedAddGroup.toNNNorm.{u2} Œ≤ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} Œ≤ _inst_10)) (OfNat.ofNat.{u2} Œ≤ 1 (One.toOfNat1.{u2} Œ≤ _inst_11)))))
Case conversion may be inaccurate. Consider using '#align pi_Lp.nnnorm_equiv_symm_one PiLp.nnnorm_equiv_symm_one‚Çì'. -/
theorem nnnorm_equiv_symm_one {Œ≤} [SeminormedAddCommGroup Œ≤] (hp : p ‚â† ‚àû) [One Œ≤] :
    ‚Äñ(PiLp.equiv p fun _ : Œπ => Œ≤).symm 1‚Äñ‚Çä = Fintype.card Œπ ^ (1 / p).toReal * ‚Äñ(1 : Œ≤)‚Äñ‚Çä :=
  (nnnorm_equiv_symm_const hp (1 : Œ≤)).trans rfl
#align pi_Lp.nnnorm_equiv_symm_one PiLp.nnnorm_equiv_symm_one

/- warning: pi_Lp.norm_equiv_symm_one -> PiLp.norm_equiv_symm_one is a dubious translation:
lean 3 declaration is
  forall {p : ENNReal} {Œπ : Type.{u1}} [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] {Œ≤ : Type.{u2}} [_inst_10 : SeminormedAddCommGroup.{u2} Œ≤], (Ne.{1} ENNReal p (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (forall [_inst_11 : One.{u2} Œ≤], Eq.{1} Real (Norm.norm.{max u1 u2} (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤)) (PiLp.hasNorm.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤) _inst_1 (fun (i : Œπ) => SeminormedAddCommGroup.toHasNorm.{u2} Œ≤ _inst_10) (fun (i : Œπ) => AddZeroClass.toHasZero.{u2} Œ≤ (AddMonoid.toAddZeroClass.{u2} Œ≤ (SubNegMonoid.toAddMonoid.{u2} Œ≤ (AddGroup.toSubNegMonoid.{u2} Œ≤ (SeminormedAddGroup.toAddGroup.{u2} Œ≤ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} Œ≤ _inst_10))))))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ (max u1 u2))) (succ (max u1 u2)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ (max u1 u2))} (Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (fun (_x : Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) => (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) -> (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), succ (max u1 u2)} (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (Equiv.symm.{succ (max u1 u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤)) (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) (PiLp.equiv.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (OfNat.ofNat.{max u1 u2} (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) 1 (OfNat.mk.{max u1 u2} (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) 1 (One.one.{max u1 u2} (forall (i : Œπ), (fun (_x : Œπ) => Œ≤) i) (Pi.instOne.{u1, u2} Œπ (fun (i : Œπ) => (fun (_x : Œπ) => Œ≤) i) (fun (i : Œπ) => _inst_11))))))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (HPow.hPow.{0, 0, 0} Real Real Real (instHPow.{0, 0} Real Real Real.hasPow) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTC‚Çì.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) (Fintype.card.{u1} Œπ _inst_1)) (ENNReal.toReal (HDiv.hDiv.{0, 0, 0} ENNReal ENNReal ENNReal (instHDiv.{0} ENNReal (DivInvMonoid.toHasDiv.{0} ENNReal ENNReal.divInvMonoid)) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p))) (Norm.norm.{u2} Œ≤ (SeminormedAddCommGroup.toHasNorm.{u2} Œ≤ _inst_10) (OfNat.ofNat.{u2} Œ≤ 1 (OfNat.mk.{u2} Œ≤ 1 (One.one.{u2} Œ≤ _inst_11))))))
but is expected to have type
  forall {p : ENNReal} {Œπ : Type.{u1}} [_inst_1 : Fintype.{u1} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] {Œ≤ : Type.{u2}} [_inst_10 : SeminormedAddCommGroup.{u2} Œ≤], (Ne.{1} ENNReal p (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (forall [_inst_11 : One.{u2} Œ≤], Eq.{1} Real (Norm.norm.{max u1 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : Œπ -> Œ≤) => PiLp.{u1, u2} p Œπ (fun (x._@.Mathlib.Analysis.NormedSpace.PiLp._hyg.12054 : Œπ) => Œ≤)) (OfNat.ofNat.{max u1 u2} (Œπ -> Œ≤) 1 (One.toOfNat1.{max u1 u2} (Œπ -> Œ≤) (Pi.instOne.{u1, u2} Œπ (fun (i : Œπ) => Œ≤) (fun (i : Œπ) => _inst_11))))) (PiLp.hasNorm.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤) _inst_1 (fun (i : Œπ) => SeminormedAddCommGroup.toNorm.{u2} Œ≤ _inst_10) (fun (i : Œπ) => NegZeroClass.toZero.{u2} Œ≤ (SubNegZeroMonoid.toNegZeroClass.{u2} Œ≤ (SubtractionMonoid.toSubNegZeroMonoid.{u2} Œ≤ (SubtractionCommMonoid.toSubtractionMonoid.{u2} Œ≤ (AddCommGroup.toDivisionAddCommMonoid.{u2} Œ≤ (SeminormedAddCommGroup.toAddCommGroup.{u2} Œ≤ _inst_10))))))) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Œπ -> Œ≤) (PiLp.{u1, u2} p Œπ (fun (x._@.Mathlib.Analysis.NormedSpace.PiLp._hyg.12054 : Œπ) => Œ≤))) (Œπ -> Œ≤) (fun (_x : Œπ -> Œ≤) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : Œπ -> Œ≤) => PiLp.{u1, u2} p Œπ (fun (x._@.Mathlib.Analysis.NormedSpace.PiLp._hyg.12054 : Œπ) => Œ≤)) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Œπ -> Œ≤) (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (Equiv.symm.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (PiLp.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤)) (Œπ -> Œ≤) (PiLp.equiv.{u1, u2} p Œπ (fun (_x : Œπ) => Œ≤))) (OfNat.ofNat.{max u1 u2} (Œπ -> Œ≤) 1 (One.toOfNat1.{max u1 u2} (Œπ -> Œ≤) (Pi.instOne.{u1, u2} Œπ (fun (i : Œπ) => Œ≤) (fun (i : Œπ) => _inst_11)))))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (NNReal.toReal (HPow.hPow.{0, 0, 0} NNReal Real NNReal (instHPow.{0, 0} NNReal Real NNReal.instPowNNRealReal) (Nat.cast.{0} NNReal (CanonicallyOrderedCommSemiring.toNatCast.{0} NNReal instNNRealCanonicallyOrderedCommSemiring) (Fintype.card.{u1} Œπ _inst_1)) (ENNReal.toReal (HDiv.hDiv.{0, 0, 0} ENNReal ENNReal ENNReal (instHDiv.{0} ENNReal (DivInvMonoid.toDiv.{0} ENNReal ENNReal.instDivInvMonoidENNReal)) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)))) (Norm.norm.{u2} Œ≤ (SeminormedAddCommGroup.toNorm.{u2} Œ≤ _inst_10) (OfNat.ofNat.{u2} Œ≤ 1 (One.toOfNat1.{u2} Œ≤ _inst_11)))))
Case conversion may be inaccurate. Consider using '#align pi_Lp.norm_equiv_symm_one PiLp.norm_equiv_symm_one‚Çì'. -/
theorem norm_equiv_symm_one {Œ≤} [SeminormedAddCommGroup Œ≤] (hp : p ‚â† ‚àû) [One Œ≤] :
    ‚Äñ(PiLp.equiv p fun _ : Œπ => Œ≤).symm 1‚Äñ = Fintype.card Œπ ^ (1 / p).toReal * ‚Äñ(1 : Œ≤)‚Äñ :=
  (norm_equiv_symm_const hp (1 : Œ≤)).trans rfl
#align pi_Lp.norm_equiv_symm_one PiLp.norm_equiv_symm_one

variable (ùïú p)

/- warning: pi_Lp.linear_equiv -> PiLp.linearEquiv is a dubious translation:
lean 3 declaration is
  forall (p : ENNReal) (ùïú : Type.{u1}) {Œπ : Type.{u2}} (Œ≤ : Œπ -> Type.{u3}) [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] [_inst_3 : NormedField.{u1} ùïú] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u3} (Œ≤ i)] [_inst_6 : forall (i : Œπ), NormedSpace.{u1, u3} ùïú (Œ≤ i) _inst_3 (_inst_5 i)], LinearEquiv.{u1, u1, max u2 u3, max u2 u3} ùïú ùïú (Ring.toSemiring.{u1} ùïú (NormedRing.toRing.{u1} ùïú (NormedCommRing.toNormedRing.{u1} ùïú (NormedField.toNormedCommRing.{u1} ùïú _inst_3)))) (Ring.toSemiring.{u1} ùïú (NormedRing.toRing.{u1} ùïú (NormedCommRing.toNormedRing.{u1} ùïú (NormedField.toNormedCommRing.{u1} ùïú _inst_3)))) (RingHom.id.{u1} ùïú (Semiring.toNonAssocSemiring.{u1} ùïú (Ring.toSemiring.{u1} ùïú (NormedRing.toRing.{u1} ùïú (NormedCommRing.toNormedRing.{u1} ùïú (NormedField.toNormedCommRing.{u1} ùïú _inst_3)))))) (RingHom.id.{u1} ùïú (Semiring.toNonAssocSemiring.{u1} ùïú (Ring.toSemiring.{u1} ùïú (NormedRing.toRing.{u1} ùïú (NormedCommRing.toNormedRing.{u1} ùïú (NormedField.toNormedCommRing.{u1} ùïú _inst_3)))))) (PiLp.linearEquiv._proof_1.{u1} ùïú _inst_3) (PiLp.linearEquiv._proof_2.{u1} ùïú _inst_3) (PiLp.{u2, u3} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (AddCommGroup.toAddCommMonoid.{max u2 u3} (PiLp.{u2, u3} p Œπ Œ≤) (SeminormedAddCommGroup.toAddCommGroup.{max u2 u3} (PiLp.{u2, u3} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u2, u3} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i)))) (Pi.addCommMonoid.{u2, u3} Œπ (fun (i : Œπ) => Œ≤ i) (fun (i : Œπ) => AddCommGroup.toAddCommMonoid.{u3} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u3} (Œ≤ i) (_inst_5 i)))) (NormedSpace.toModule.{u1, max u2 u3} ùïú (PiLp.{u2, u3} p Œπ Œ≤) _inst_3 (PiLp.seminormedAddCommGroup.{u2, u3} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i)) (PiLp.normedSpace.{u1, u2, u3} p ùïú Œπ Œ≤ _inst_1 _inst_2 _inst_3 (fun (i : Œπ) => _inst_5 i) (fun (i : Œπ) => _inst_6 i))) (Pi.module.{u2, u3, u1} Œπ (fun (i : Œπ) => Œ≤ i) ùïú (Ring.toSemiring.{u1} ùïú (NormedRing.toRing.{u1} ùïú (NormedCommRing.toNormedRing.{u1} ùïú (NormedField.toNormedCommRing.{u1} ùïú _inst_3)))) (fun (i : Œπ) => AddCommGroup.toAddCommMonoid.{u3} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u3} (Œ≤ i) (_inst_5 i))) (fun (i : Œπ) => NormedSpace.toModule.{u1, u3} ùïú (Œ≤ i) _inst_3 (_inst_5 i) (_inst_6 i)))
but is expected to have type
  forall (p : ENNReal) (ùïú : Type.{u1}) {Œπ : Type.{u2}} (Œ≤ : Œπ -> Type.{u3}) [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] [_inst_3 : NormedField.{u1} ùïú] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u3} (Œ≤ i)] [_inst_6 : forall (i : Œπ), NormedSpace.{u1, u3} ùïú (Œ≤ i) _inst_3 (_inst_5 i)], LinearEquiv.{u1, u1, max u3 u2, max u2 u3} ùïú ùïú (DivisionSemiring.toSemiring.{u1} ùïú (Semifield.toDivisionSemiring.{u1} ùïú (Field.toSemifield.{u1} ùïú (NormedField.toField.{u1} ùïú _inst_3)))) (DivisionSemiring.toSemiring.{u1} ùïú (Semifield.toDivisionSemiring.{u1} ùïú (Field.toSemifield.{u1} ùïú (NormedField.toField.{u1} ùïú _inst_3)))) (RingHom.id.{u1} ùïú (Semiring.toNonAssocSemiring.{u1} ùïú (DivisionSemiring.toSemiring.{u1} ùïú (Semifield.toDivisionSemiring.{u1} ùïú (Field.toSemifield.{u1} ùïú (NormedField.toField.{u1} ùïú _inst_3)))))) (RingHom.id.{u1} ùïú (Semiring.toNonAssocSemiring.{u1} ùïú (DivisionSemiring.toSemiring.{u1} ùïú (Semifield.toDivisionSemiring.{u1} ùïú (Field.toSemifield.{u1} ùïú (NormedField.toField.{u1} ùïú _inst_3)))))) (RingHomInvPair.ids.{u1} ùïú (DivisionSemiring.toSemiring.{u1} ùïú (Semifield.toDivisionSemiring.{u1} ùïú (Field.toSemifield.{u1} ùïú (NormedField.toField.{u1} ùïú _inst_3))))) (RingHomInvPair.ids.{u1} ùïú (DivisionSemiring.toSemiring.{u1} ùïú (Semifield.toDivisionSemiring.{u1} ùïú (Field.toSemifield.{u1} ùïú (NormedField.toField.{u1} ùïú _inst_3))))) (PiLp.{u2, u3} p Œπ Œ≤) (forall (i : Œπ), Œ≤ i) (AddCommGroup.toAddCommMonoid.{max u2 u3} (PiLp.{u2, u3} p Œπ Œ≤) (SeminormedAddCommGroup.toAddCommGroup.{max u2 u3} (PiLp.{u2, u3} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u2, u3} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i)))) (Pi.addCommMonoid.{u2, u3} Œπ (fun (i : Œπ) => Œ≤ i) (fun (i : Œπ) => AddCommGroup.toAddCommMonoid.{u3} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u3} (Œ≤ i) (_inst_5 i)))) (PiLp.module.{u1, u2, u3} p ùïú Œπ Œ≤ _inst_1 _inst_2 _inst_3 (fun (i : Œπ) => _inst_5 i) (fun (i : Œπ) => _inst_6 i)) (Pi.module.{u2, u3, u1} Œπ (fun (i : Œπ) => Œ≤ i) ùïú (DivisionSemiring.toSemiring.{u1} ùïú (Semifield.toDivisionSemiring.{u1} ùïú (Field.toSemifield.{u1} ùïú (NormedField.toField.{u1} ùïú _inst_3)))) (fun (i : Œπ) => AddCommGroup.toAddCommMonoid.{u3} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u3} (Œ≤ i) (_inst_5 i))) (fun (i : Œπ) => NormedSpace.toModule.{u1, u3} ùïú (Œ≤ i) _inst_3 (_inst_5 i) (_inst_6 i)))
Case conversion may be inaccurate. Consider using '#align pi_Lp.linear_equiv PiLp.linearEquiv‚Çì'. -/
/-- `pi_Lp.equiv` as a linear equivalence. -/
@[simps (config := { fullyApplied := false })]
protected def linearEquiv : PiLp p Œ≤ ‚âÉ‚Çó[ùïú] ‚àÄ i, Œ≤ i :=
  { LinearEquiv.refl _ _ with
    toFun := PiLp.equiv _ _
    invFun := (PiLp.equiv _ _).symm }
#align pi_Lp.linear_equiv PiLp.linearEquiv

/- warning: pi_Lp.continuous_linear_equiv -> PiLp.continuousLinearEquiv is a dubious translation:
lean 3 declaration is
  forall (p : ENNReal) (ùïú : Type.{u1}) {Œπ : Type.{u2}} (Œ≤ : Œπ -> Type.{u3}) [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] [_inst_3 : NormedField.{u1} ùïú] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u3} (Œ≤ i)] [_inst_6 : forall (i : Œπ), NormedSpace.{u1, u3} ùïú (Œ≤ i) _inst_3 (_inst_5 i)], ContinuousLinearEquiv.{u1, u1, max u2 u3, max u2 u3} ùïú ùïú (Ring.toSemiring.{u1} ùïú (NormedRing.toRing.{u1} ùïú (NormedCommRing.toNormedRing.{u1} ùïú (NormedField.toNormedCommRing.{u1} ùïú _inst_3)))) (Ring.toSemiring.{u1} ùïú (NormedRing.toRing.{u1} ùïú (NormedCommRing.toNormedRing.{u1} ùïú (NormedField.toNormedCommRing.{u1} ùïú _inst_3)))) (RingHom.id.{u1} ùïú (Semiring.toNonAssocSemiring.{u1} ùïú (Ring.toSemiring.{u1} ùïú (NormedRing.toRing.{u1} ùïú (NormedCommRing.toNormedRing.{u1} ùïú (NormedField.toNormedCommRing.{u1} ùïú _inst_3)))))) (RingHom.id.{u1} ùïú (Semiring.toNonAssocSemiring.{u1} ùïú (Ring.toSemiring.{u1} ùïú (NormedRing.toRing.{u1} ùïú (NormedCommRing.toNormedRing.{u1} ùïú (NormedField.toNormedCommRing.{u1} ùïú _inst_3)))))) (PiLp.continuousLinearEquiv._proof_1.{u1} ùïú _inst_3) (PiLp.continuousLinearEquiv._proof_2.{u1} ùïú _inst_3) (PiLp.{u2, u3} p Œπ Œ≤) (UniformSpace.toTopologicalSpace.{max u2 u3} (PiLp.{u2, u3} p Œπ Œ≤) (PiLp.uniformSpace.{u2, u3} p Œπ Œ≤ (fun (i : Œπ) => PseudoMetricSpace.toUniformSpace.{u3} (Œ≤ i) (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} (Œ≤ i) (_inst_5 i))))) (AddCommGroup.toAddCommMonoid.{max u2 u3} (PiLp.{u2, u3} p Œπ Œ≤) (SeminormedAddCommGroup.toAddCommGroup.{max u2 u3} (PiLp.{u2, u3} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u2, u3} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i)))) (forall (i : Œπ), Œ≤ i) (Pi.topologicalSpace.{u2, u3} Œπ (fun (i : Œπ) => Œ≤ i) (fun (a : Œπ) => UniformSpace.toTopologicalSpace.{u3} (Œ≤ a) (PseudoMetricSpace.toUniformSpace.{u3} (Œ≤ a) (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} (Œ≤ a) (_inst_5 a))))) (Pi.addCommMonoid.{u2, u3} Œπ (fun (i : Œπ) => Œ≤ i) (fun (i : Œπ) => AddCommGroup.toAddCommMonoid.{u3} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u3} (Œ≤ i) (_inst_5 i)))) (NormedSpace.toModule.{u1, max u2 u3} ùïú (PiLp.{u2, u3} p Œπ Œ≤) _inst_3 (PiLp.seminormedAddCommGroup.{u2, u3} p Œπ Œ≤ _inst_1 _inst_2 (fun (a : Œπ) => _inst_5 a)) (PiLp.normedSpace.{u1, u2, u3} p ùïú Œπ Œ≤ _inst_1 _inst_2 _inst_3 (fun (a : Œπ) => _inst_5 a) (fun (i : Œπ) => _inst_6 i))) (Pi.module.{u2, u3, u1} Œπ (fun (i : Œπ) => Œ≤ i) ùïú (Ring.toSemiring.{u1} ùïú (NormedRing.toRing.{u1} ùïú (NormedCommRing.toNormedRing.{u1} ùïú (NormedField.toNormedCommRing.{u1} ùïú _inst_3)))) (fun (i : Œπ) => AddCommGroup.toAddCommMonoid.{u3} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u3} (Œ≤ i) (_inst_5 i))) (fun (i : Œπ) => NormedSpace.toModule.{u1, u3} ùïú (Œ≤ i) _inst_3 (_inst_5 i) (_inst_6 i)))
but is expected to have type
  forall (p : ENNReal) (ùïú : Type.{u1}) {Œπ : Type.{u2}} (Œ≤ : Œπ -> Type.{u3}) [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] [_inst_3 : NormedField.{u1} ùïú] [_inst_5 : forall (i : Œπ), SeminormedAddCommGroup.{u3} (Œ≤ i)] [_inst_6 : forall (i : Œπ), NormedSpace.{u1, u3} ùïú (Œ≤ i) _inst_3 (_inst_5 i)], ContinuousLinearEquiv.{u1, u1, max u3 u2, max u2 u3} ùïú ùïú (DivisionSemiring.toSemiring.{u1} ùïú (Semifield.toDivisionSemiring.{u1} ùïú (Field.toSemifield.{u1} ùïú (NormedField.toField.{u1} ùïú _inst_3)))) (DivisionSemiring.toSemiring.{u1} ùïú (Semifield.toDivisionSemiring.{u1} ùïú (Field.toSemifield.{u1} ùïú (NormedField.toField.{u1} ùïú _inst_3)))) (RingHom.id.{u1} ùïú (Semiring.toNonAssocSemiring.{u1} ùïú (DivisionSemiring.toSemiring.{u1} ùïú (Semifield.toDivisionSemiring.{u1} ùïú (Field.toSemifield.{u1} ùïú (NormedField.toField.{u1} ùïú _inst_3)))))) (RingHom.id.{u1} ùïú (Semiring.toNonAssocSemiring.{u1} ùïú (DivisionSemiring.toSemiring.{u1} ùïú (Semifield.toDivisionSemiring.{u1} ùïú (Field.toSemifield.{u1} ùïú (NormedField.toField.{u1} ùïú _inst_3)))))) (RingHomInvPair.ids.{u1} ùïú (DivisionSemiring.toSemiring.{u1} ùïú (Semifield.toDivisionSemiring.{u1} ùïú (Field.toSemifield.{u1} ùïú (NormedField.toField.{u1} ùïú _inst_3))))) (RingHomInvPair.ids.{u1} ùïú (DivisionSemiring.toSemiring.{u1} ùïú (Semifield.toDivisionSemiring.{u1} ùïú (Field.toSemifield.{u1} ùïú (NormedField.toField.{u1} ùïú _inst_3))))) (PiLp.{u2, u3} p Œπ Œ≤) (UniformSpace.toTopologicalSpace.{max u2 u3} (PiLp.{u2, u3} p Œπ Œ≤) (PiLp.uniformSpace.{u2, u3} p Œπ Œ≤ (fun (i : Œπ) => PseudoMetricSpace.toUniformSpace.{u3} (Œ≤ i) (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} (Œ≤ i) (_inst_5 i))))) (AddCommGroup.toAddCommMonoid.{max u2 u3} (PiLp.{u2, u3} p Œπ Œ≤) (SeminormedAddCommGroup.toAddCommGroup.{max u2 u3} (PiLp.{u2, u3} p Œπ Œ≤) (PiLp.seminormedAddCommGroup.{u2, u3} p Œπ Œ≤ _inst_1 _inst_2 (fun (i : Œπ) => _inst_5 i)))) (forall (i : Œπ), Œ≤ i) (Pi.topologicalSpace.{u2, u3} Œπ (fun (i : Œπ) => Œ≤ i) (fun (a : Œπ) => UniformSpace.toTopologicalSpace.{u3} (Œ≤ a) (PseudoMetricSpace.toUniformSpace.{u3} (Œ≤ a) (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} (Œ≤ a) (_inst_5 a))))) (Pi.addCommMonoid.{u2, u3} Œπ (fun (i : Œπ) => Œ≤ i) (fun (i : Œπ) => AddCommGroup.toAddCommMonoid.{u3} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u3} (Œ≤ i) (_inst_5 i)))) (PiLp.module.{u1, u2, u3} p ùïú Œπ Œ≤ _inst_1 _inst_2 _inst_3 (fun (i : Œπ) => _inst_5 i) (fun (i : Œπ) => _inst_6 i)) (Pi.module.{u2, u3, u1} Œπ (fun (i : Œπ) => Œ≤ i) ùïú (DivisionSemiring.toSemiring.{u1} ùïú (Semifield.toDivisionSemiring.{u1} ùïú (Field.toSemifield.{u1} ùïú (NormedField.toField.{u1} ùïú _inst_3)))) (fun (i : Œπ) => AddCommGroup.toAddCommMonoid.{u3} (Œ≤ i) (SeminormedAddCommGroup.toAddCommGroup.{u3} (Œ≤ i) (_inst_5 i))) (fun (i : Œπ) => NormedSpace.toModule.{u1, u3} ùïú (Œ≤ i) _inst_3 (_inst_5 i) (_inst_6 i)))
Case conversion may be inaccurate. Consider using '#align pi_Lp.continuous_linear_equiv PiLp.continuousLinearEquiv‚Çì'. -/
/-- `pi_Lp.equiv` as a continuous linear equivalence. -/
@[simps (config := { fullyApplied := false })]
protected def continuousLinearEquiv : PiLp p Œ≤ ‚âÉL[ùïú] ‚àÄ i, Œ≤ i
    where
  toLinearEquiv := PiLp.linearEquiv _ _ _
  continuous_toFun := continuous_equiv _ _
  continuous_invFun := continuous_equiv_symm _ _
#align pi_Lp.continuous_linear_equiv PiLp.continuousLinearEquiv

section Basis

variable (Œπ)

/- warning: pi_Lp.basis_fun -> PiLp.basisFun is a dubious translation:
lean 3 declaration is
  forall (p : ENNReal) (ùïú : Type.{u1}) (Œπ : Type.{u2}) [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) p)] [_inst_3 : NormedField.{u1} ùïú], Basis.{u2, u1, max u2 u1} Œπ ùïú (PiLp.{u2, u1} p Œπ (fun (_x : Œπ) => ùïú)) (Ring.toSemiring.{u1} ùïú (NormedRing.toRing.{u1} ùïú (NormedCommRing.toNormedRing.{u1} ùïú (NormedField.toNormedCommRing.{u1} ùïú _inst_3)))) (AddCommGroup.toAddCommMonoid.{max u2 u1} (PiLp.{u2, u1} p Œπ (fun (_x : Œπ) => ùïú)) (SeminormedAddCommGroup.toAddCommGroup.{max u2 u1} (PiLp.{u2, u1} p Œπ (fun (_x : Œπ) => ùïú)) (PiLp.seminormedAddCommGroup.{u2, u1} p Œπ (fun (_x : Œπ) => ùïú) _inst_1 _inst_2 (fun (i : Œπ) => (fun (i : Œπ) => NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} ((fun (_x : Œπ) => ùïú) i) (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u1} ((fun (_x : Œπ) => ùïú) i) (NormedRing.toNonUnitalNormedRing.{u1} ((fun (_x : Œπ) => ùïú) i) (NormedCommRing.toNormedRing.{u1} ((fun (_x : Œπ) => ùïú) i) (NormedField.toNormedCommRing.{u1} ((fun (_x : Œπ) => ùïú) i) _inst_3))))) i)))) (NormedSpace.toModule.{u1, max u2 u1} ùïú (PiLp.{u2, u1} p Œπ (fun (_x : Œπ) => ùïú)) _inst_3 (PiLp.seminormedAddCommGroup.{u2, u1} p Œπ (fun (_x : Œπ) => ùïú) _inst_1 _inst_2 (fun (i : Œπ) => (fun (i : Œπ) => NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} ((fun (_x : Œπ) => ùïú) i) (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u1} ((fun (_x : Œπ) => ùïú) i) (NormedRing.toNonUnitalNormedRing.{u1} ((fun (_x : Œπ) => ùïú) i) (NormedCommRing.toNormedRing.{u1} ((fun (_x : Œπ) => ùïú) i) (NormedField.toNormedCommRing.{u1} ((fun (_x : Œπ) => ùïú) i) _inst_3))))) i)) (PiLp.normedSpace.{u1, u2, u1} p ùïú Œπ (fun (_x : Œπ) => ùïú) _inst_1 _inst_2 _inst_3 (fun (i : Œπ) => (fun (i : Œπ) => NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} ((fun (_x : Œπ) => ùïú) i) (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u1} ((fun (_x : Œπ) => ùïú) i) (NormedRing.toNonUnitalNormedRing.{u1} ((fun (_x : Œπ) => ùïú) i) (NormedCommRing.toNormedRing.{u1} ((fun (_x : Œπ) => ùïú) i) (NormedField.toNormedCommRing.{u1} ((fun (_x : Œπ) => ùïú) i) _inst_3))))) i) (fun (i : Œπ) => (fun (i : Œπ) => NormedField.toNormedSpace.{u1} ùïú _inst_3) i)))
but is expected to have type
  forall (p : ENNReal) (ùïú : Type.{u1}) (Œπ : Type.{u2}) [_inst_1 : Fintype.{u2} Œπ] [_inst_2 : Fact (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) p)] [_inst_3 : NormedField.{u1} ùïú], Basis.{u2, u1, max u1 u2} Œπ ùïú (PiLp.{u2, u1} p Œπ (fun (_x : Œπ) => ùïú)) (DivisionSemiring.toSemiring.{u1} ùïú (Semifield.toDivisionSemiring.{u1} ùïú (Field.toSemifield.{u1} ùïú (NormedField.toField.{u1} ùïú _inst_3)))) (AddCommGroup.toAddCommMonoid.{max u1 u2} (PiLp.{u2, u1} p Œπ (fun (_x : Œπ) => ùïú)) (NormedAddCommGroup.toAddCommGroup.{max u1 u2} (PiLp.{u2, u1} p Œπ (fun (_x : Œπ) => ùïú)) (PiLp.normedAddCommGroup.{u2, u1} p Œπ (fun (_x : Œπ) => ùïú) _inst_1 _inst_2 (fun (i : Œπ) => NonUnitalNormedRing.toNormedAddCommGroup.{u1} ùïú (NormedRing.toNonUnitalNormedRing.{u1} ùïú (NormedCommRing.toNormedRing.{u1} ùïú (NormedField.toNormedCommRing.{u1} ùïú _inst_3))))))) (PiLp.module.{u1, u2, u1} p ùïú Œπ (fun (x._@.Mathlib.Analysis.NormedSpace.PiLp._hyg.12725 : Œπ) => ùïú) _inst_1 _inst_2 _inst_3 (fun (i : Œπ) => NormedAddCommGroup.toSeminormedAddCommGroup.{u1} ((fun (x._@.Mathlib.Analysis.NormedSpace.PiLp._hyg.12725 : Œπ) => ùïú) i) ((fun (i : Œπ) => NonUnitalNormedRing.toNormedAddCommGroup.{u1} ùïú (NormedRing.toNonUnitalNormedRing.{u1} ùïú (NormedCommRing.toNormedRing.{u1} ùïú (NormedField.toNormedCommRing.{u1} ùïú _inst_3)))) i)) (fun (i : Œπ) => NormedField.toNormedSpace.{u1} ùïú _inst_3))
Case conversion may be inaccurate. Consider using '#align pi_Lp.basis_fun PiLp.basisFun‚Çì'. -/
/-- A version of `pi.basis_fun` for `pi_Lp`. -/
def basisFun : Basis Œπ ùïú (PiLp p fun _ => ùïú) :=
  Basis.ofEquivFun (PiLp.linearEquiv p ùïú fun _ : Œπ => ùïú)
#align pi_Lp.basis_fun PiLp.basisFun

/- warning: pi_Lp.basis_fun_apply -> PiLp.basisFun_apply is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align pi_Lp.basis_fun_apply PiLp.basisFun_apply‚Çì'. -/
@[simp]
theorem basisFun_apply [DecidableEq Œπ] (i) :
    basisFun p ùïú Œπ i = (PiLp.equiv p _).symm (Pi.single i 1) := by
  simp_rw [basis_fun, Basis.coe_ofEquivFun, PiLp.linearEquiv_symm_apply, Pi.single]
#align pi_Lp.basis_fun_apply PiLp.basisFun_apply

/- warning: pi_Lp.basis_fun_repr -> PiLp.basisFun_repr is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align pi_Lp.basis_fun_repr PiLp.basisFun_repr‚Çì'. -/
@[simp]
theorem basisFun_repr (x : PiLp p fun i : Œπ => ùïú) (i : Œπ) : (basisFun p ùïú Œπ).repr x i = x i :=
  rfl
#align pi_Lp.basis_fun_repr PiLp.basisFun_repr

/- warning: pi_Lp.basis_fun_equiv_fun -> PiLp.basisFun_equivFun is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align pi_Lp.basis_fun_equiv_fun PiLp.basisFun_equivFun‚Çì'. -/
@[simp]
theorem basisFun_equivFun : (basisFun p ùïú Œπ).equivFun = PiLp.linearEquiv p ùïú fun _ : Œπ => ùïú :=
  Basis.equivFun_ofEquivFun _
#align pi_Lp.basis_fun_equiv_fun PiLp.basisFun_equivFun

/- warning: pi_Lp.basis_fun_eq_pi_basis_fun -> PiLp.basisFun_eq_pi_basisFun is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align pi_Lp.basis_fun_eq_pi_basis_fun PiLp.basisFun_eq_pi_basisFun‚Çì'. -/
theorem basisFun_eq_pi_basisFun :
    basisFun p ùïú Œπ = (Pi.basisFun ùïú Œπ).map (PiLp.linearEquiv p ùïú fun _ : Œπ => ùïú).symm :=
  rfl
#align pi_Lp.basis_fun_eq_pi_basis_fun PiLp.basisFun_eq_pi_basisFun

/- warning: pi_Lp.basis_fun_map -> PiLp.basisFun_map is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align pi_Lp.basis_fun_map PiLp.basisFun_map‚Çì'. -/
@[simp]
theorem basisFun_map :
    (basisFun p ùïú Œπ).map (PiLp.linearEquiv p ùïú fun _ : Œπ => ùïú) = Pi.basisFun ùïú Œπ :=
  rfl
#align pi_Lp.basis_fun_map PiLp.basisFun_map

open Matrix

/- warning: pi_Lp.basis_to_matrix_basis_fun_mul -> PiLp.basis_toMatrix_basisFun_mul is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align pi_Lp.basis_to_matrix_basis_fun_mul PiLp.basis_toMatrix_basisFun_mul‚Çì'. -/
theorem basis_toMatrix_basisFun_mul (b : Basis Œπ ùïú (PiLp p fun i : Œπ => ùïú)) (A : Matrix Œπ Œπ ùïú) :
    b.toMatrix (PiLp.basisFun _ _ _) ‚¨ù A =
      Matrix.of fun i j => b.repr ((PiLp.equiv _ _).symm (A·µÄ j)) i :=
  by
  have := basis_toMatrix_basisFun_mul (b.map (PiLp.linearEquiv _ ùïú _)) A
  simp_rw [‚Üê PiLp.basisFun_map p, Basis.map_repr, LinearEquiv.trans_apply,
    PiLp.linearEquiv_symm_apply, Basis.toMatrix_map, Function.comp, Basis.map_apply,
    LinearEquiv.symm_apply_apply] at this
  exact this
#align pi_Lp.basis_to_matrix_basis_fun_mul PiLp.basis_toMatrix_basisFun_mul

end Basis

end PiLp

