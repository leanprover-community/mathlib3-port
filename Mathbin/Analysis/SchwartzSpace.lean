/-
Copyright (c) 2022 Moritz Doll. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Moritz Doll

! This file was ported from Lean 3 source module analysis.schwartz_space
! leanprover-community/mathlib commit bcfa726826abd57587355b4b5b7e78ad6527b7e4
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Analysis.Calculus.ContDiff
import Mathbin.Analysis.LocallyConvex.WithSeminorms
import Mathbin.Topology.Algebra.UniformFilterBasis
import Mathbin.Topology.ContinuousFunction.Bounded
import Mathbin.Tactic.Positivity

/-!
# Schwartz space

This file defines the Schwartz space. Usually, the Schwartz space is defined as the set of smooth
functions $f : ‚Ñù^n ‚Üí ‚ÑÇ$ such that there exists $C_{Œ±Œ≤} > 0$ with $$|x^Œ± ‚àÇ^Œ≤ f(x)| < C_{Œ±Œ≤}$$ for
all $x ‚àà ‚Ñù^n$ and for all multiindices $Œ±, Œ≤$.
In mathlib, we use a slightly different approach and define define the Schwartz space as all
smooth functions `f : E ‚Üí F`, where `E` and `F` are real normed vector spaces such that for all
natural numbers `k` and `n` we have uniform bounds `‚Äñx‚Äñ^k * ‚Äñiterated_fderiv ‚Ñù n f x‚Äñ < C`.
This approach completely avoids using partial derivatives as well as polynomials.
We construct the topology on the Schwartz space by a family of seminorms, which are the best
constants in the above estimates, which is by abstract theory from
`seminorm_family.module_filter_basis` and `with_seminorms.to_locally_convex_space` turns the
Schwartz space into a locally convex topological vector space.

## Main definitions

* `schwartz_map`: The Schwartz space is the space of smooth functions such that all derivatives
decay faster than any power of `‚Äñx‚Äñ`.
* `schwartz_map.seminorm`: The family of seminorms as described above
* `schwartz_map.fderiv_clm`: The differential as a continuous linear map
`ùì¢(E, F) ‚ÜíL[ùïú] ùì¢(E, E ‚ÜíL[‚Ñù] F)`

## Main statements

* `schwartz_map.uniform_add_group` and `schwartz_map.locally_convex`: The Schwartz space is a
locally convex topological vector space.

## Implementation details

The implementation of the seminorms is taken almost literally from `continuous_linear_map.op_norm`.

## Notation

* `ùì¢(E, F)`: The Schwartz space `schwartz_map E F` localized in `schwartz_space`

## Tags

Schwartz space, tempered distributions
-/


noncomputable section

variable {ùïú ùïú' E F : Type _}

variable [NormedAddCommGroup E] [NormedSpace ‚Ñù E]

variable [NormedAddCommGroup F] [NormedSpace ‚Ñù F]

variable (E F)

/-- A function is a Schwartz function if it is smooth and all derivatives decay faster than
  any power of `‚Äñx‚Äñ`. -/
structure SchwartzMap where
  toFun : E ‚Üí F
  smooth' : ContDiff ‚Ñù ‚ä§ to_fun
  decay' : ‚àÄ k n : ‚Ñï, ‚àÉ C : ‚Ñù, ‚àÄ x, ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFderiv ‚Ñù n to_fun x‚Äñ ‚â§ C
#align schwartz_map SchwartzMap

-- mathport name: ¬´exprùì¢( , )¬ª
scoped[SchwartzSpace] notation "ùì¢(" E ", " F ")" => SchwartzMap E F

variable {E F}

namespace SchwartzMap

instance : Coe ùì¢(E, F) (E ‚Üí F) :=
  ‚ü®toFun‚ü©

instance funLike : FunLike ùì¢(E, F) E fun _ => F
    where
  coe f := f.toFun
  coe_injective' f g h := by cases f <;> cases g <;> congr
#align schwartz_map.fun_like SchwartzMap.funLike

/-- Helper instance for when there's too many metavariables to apply `fun_like.has_coe_to_fun`. -/
instance : CoeFun ùì¢(E, F) fun _ => E ‚Üí F :=
  ‚ü®fun p => p.toFun‚ü©

/-- All derivatives of a Schwartz function are rapidly decaying. -/
theorem decay (f : ùì¢(E, F)) (k n : ‚Ñï) :
    ‚àÉ (C : ‚Ñù)(hC : 0 < C), ‚àÄ x, ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFderiv ‚Ñù n f x‚Äñ ‚â§ C :=
  by
  rcases f.decay' k n with ‚ü®C, hC‚ü©
  exact ‚ü®max C 1, by positivity, fun x => (hC x).trans (le_max_left _ _)‚ü©
#align schwartz_map.decay SchwartzMap.decay

/-- Every Schwartz function is smooth. -/
theorem smooth (f : ùì¢(E, F)) (n : ‚Ñï‚àû) : ContDiff ‚Ñù n f :=
  f.smooth'.of_le le_top
#align schwartz_map.smooth SchwartzMap.smooth

/-- Every Schwartz function is continuous. -/
@[continuity, protected]
theorem continuous (f : ùì¢(E, F)) : Continuous f :=
  (f.smooth 0).Continuous
#align schwartz_map.continuous SchwartzMap.continuous

/-- Every Schwartz function is differentiable. -/
@[protected]
theorem differentiable (f : ùì¢(E, F)) : Differentiable ‚Ñù f :=
  (f.smooth 1).Differentiable rfl.le
#align schwartz_map.differentiable SchwartzMap.differentiable

@[ext]
theorem ext {f g : ùì¢(E, F)} (h : ‚àÄ x, (f : E ‚Üí F) x = g x) : f = g :=
  FunLike.ext f g h
#align schwartz_map.ext SchwartzMap.ext

section Aux

theorem bounds_nonempty (k n : ‚Ñï) (f : ùì¢(E, F)) :
    ‚àÉ c : ‚Ñù, c ‚àà { c : ‚Ñù | 0 ‚â§ c ‚àß ‚àÄ x : E, ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFderiv ‚Ñù n f x‚Äñ ‚â§ c } :=
  let ‚ü®M, hMp, hMb‚ü© := f.decay k n
  ‚ü®M, le_of_lt hMp, hMb‚ü©
#align schwartz_map.bounds_nonempty SchwartzMap.bounds_nonempty

theorem bounds_bddBelow (k n : ‚Ñï) (f : ùì¢(E, F)) :
    BddBelow { c | 0 ‚â§ c ‚àß ‚àÄ x, ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFderiv ‚Ñù n f x‚Äñ ‚â§ c } :=
  ‚ü®0, fun _ ‚ü®hn, _‚ü© => hn‚ü©
#align schwartz_map.bounds_bdd_below SchwartzMap.bounds_bddBelow

theorem decay_add_le_aux (k n : ‚Ñï) (f g : ùì¢(E, F)) (x : E) :
    ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFderiv ‚Ñù n (f + g) x‚Äñ ‚â§
      ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFderiv ‚Ñù n f x‚Äñ + ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFderiv ‚Ñù n g x‚Äñ :=
  by
  rw [‚Üê mul_add]
  refine' mul_le_mul_of_nonneg_left _ (by positivity)
  convert norm_add_le _ _
  exact iteratedFderiv_add_apply (f.smooth _) (g.smooth _)
#align schwartz_map.decay_add_le_aux SchwartzMap.decay_add_le_aux

theorem decay_neg_aux (k n : ‚Ñï) (f : ùì¢(E, F)) (x : E) :
    ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFderiv ‚Ñù n (-f) x‚Äñ = ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFderiv ‚Ñù n f x‚Äñ :=
  by
  nth_rw 4 [‚Üê norm_neg]
  congr
  exact iteratedFderiv_neg_apply
#align schwartz_map.decay_neg_aux SchwartzMap.decay_neg_aux

variable [NormedField ùïú] [NormedSpace ùïú F] [SMulCommClass ‚Ñù ùïú F]

theorem decay_smul_aux (k n : ‚Ñï) (f : ùì¢(E, F)) (c : ùïú) (x : E) :
    ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFderiv ‚Ñù n (c ‚Ä¢ f) x‚Äñ = ‚Äñc‚Äñ * ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFderiv ‚Ñù n f x‚Äñ := by
  rw [mul_comm ‚Äñc‚Äñ, mul_assoc, iteratedFderiv_const_smul_apply (f.smooth _), norm_smul]
#align schwartz_map.decay_smul_aux SchwartzMap.decay_smul_aux

end Aux

section SeminormAux

/-- Helper definition for the seminorms of the Schwartz space. -/
@[protected]
def seminormAux (k n : ‚Ñï) (f : ùì¢(E, F)) : ‚Ñù :=
  inf‚Çõ { c | 0 ‚â§ c ‚àß ‚àÄ x, ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFderiv ‚Ñù n f x‚Äñ ‚â§ c }
#align schwartz_map.seminorm_aux SchwartzMap.seminormAux

theorem seminormAux_nonneg (k n : ‚Ñï) (f : ùì¢(E, F)) : 0 ‚â§ f.seminormAux k n :=
  le_cinf‚Çõ (bounds_nonempty k n f) fun _ ‚ü®hx, _‚ü© => hx
#align schwartz_map.seminorm_aux_nonneg SchwartzMap.seminormAux_nonneg

theorem le_seminormAux (k n : ‚Ñï) (f : ùì¢(E, F)) (x : E) :
    ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFderiv ‚Ñù n (‚áëf) x‚Äñ ‚â§ f.seminormAux k n :=
  le_cinf‚Çõ (bounds_nonempty k n f) fun y ‚ü®_, h‚ü© => h x
#align schwartz_map.le_seminorm_aux SchwartzMap.le_seminormAux

/-- If one controls the norm of every `A x`, then one controls the norm of `A`. -/
theorem seminormAux_le_bound (k n : ‚Ñï) (f : ùì¢(E, F)) {M : ‚Ñù} (hMp : 0 ‚â§ M)
    (hM : ‚àÄ x, ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFderiv ‚Ñù n f x‚Äñ ‚â§ M) : f.seminormAux k n ‚â§ M :=
  cinf‚Çõ_le (bounds_bddBelow k n f) ‚ü®hMp, hM‚ü©
#align schwartz_map.seminorm_aux_le_bound SchwartzMap.seminormAux_le_bound

end SeminormAux

/-! ### Algebraic properties -/


section Smul

variable [NormedField ùïú] [NormedSpace ùïú F] [SMulCommClass ‚Ñù ùïú F] [NormedField ùïú'] [NormedSpace ùïú' F]
  [SMulCommClass ‚Ñù ùïú' F]

instance : SMul ùïú ùì¢(E, F) :=
  ‚ü®fun c f =>
    { toFun := c ‚Ä¢ f
      smooth' := (f.smooth _).const_smul c
      decay' := fun k n =>
        by
        refine' ‚ü®f.seminorm_aux k n * (‚Äñc‚Äñ + 1), fun x => _‚ü©
        have hc : 0 ‚â§ ‚Äñc‚Äñ := by positivity
        refine' le_trans _ ((mul_le_mul_of_nonneg_right (f.le_seminorm_aux k n x) hc).trans _)
        ¬∑ apply Eq.le
          rw [mul_comm _ ‚Äñc‚Äñ, ‚Üê mul_assoc]
          exact decay_smul_aux k n f c x
        ¬∑ apply mul_le_mul_of_nonneg_left _ (f.seminorm_aux_nonneg k n)
          linarith }‚ü©

@[simp]
theorem smul_apply {f : ùì¢(E, F)} {c : ùïú} {x : E} : (c ‚Ä¢ f) x = c ‚Ä¢ f x :=
  rfl
#align schwartz_map.smul_apply SchwartzMap.smul_apply

instance [SMul ùïú ùïú'] [IsScalarTower ùïú ùïú' F] : IsScalarTower ùïú ùïú' ùì¢(E, F) :=
  ‚ü®fun a b f => ext fun x => smul_assoc a b (f x)‚ü©

instance [SMulCommClass ùïú ùïú' F] : SMulCommClass ùïú ùïú' ùì¢(E, F) :=
  ‚ü®fun a b f => ext fun x => smul_comm a b (f x)‚ü©

theorem seminormAux_smul_le (k n : ‚Ñï) (c : ùïú) (f : ùì¢(E, F)) :
    (c ‚Ä¢ f).seminormAux k n ‚â§ ‚Äñc‚Äñ * f.seminormAux k n :=
  by
  refine'
    (c ‚Ä¢ f).seminormAux_le_bound k n (mul_nonneg (norm_nonneg _) (seminorm_aux_nonneg _ _ _))
      fun x => (decay_smul_aux k n f c x).le.trans _
  rw [mul_assoc]
  exact mul_le_mul_of_nonneg_left (f.le_seminorm_aux k n x) (norm_nonneg _)
#align schwartz_map.seminorm_aux_smul_le SchwartzMap.seminormAux_smul_le

instance hasNsmul : SMul ‚Ñï ùì¢(E, F) :=
  ‚ü®fun c f =>
    { toFun := c ‚Ä¢ f
      smooth' := (f.smooth _).const_smul c
      decay' :=
        by
        have : c ‚Ä¢ (f : E ‚Üí F) = (c : ‚Ñù) ‚Ä¢ f := by
          ext x
          simp only [Pi.smul_apply, ‚Üê nsmul_eq_smul_cast]
        simp only [this]
        exact ((c : ‚Ñù) ‚Ä¢ f).decay' }‚ü©
#align schwartz_map.has_nsmul SchwartzMap.hasNsmul

instance hasZsmul : SMul ‚Ñ§ ùì¢(E, F) :=
  ‚ü®fun c f =>
    { toFun := c ‚Ä¢ f
      smooth' := (f.smooth _).const_smul c
      decay' :=
        by
        have : c ‚Ä¢ (f : E ‚Üí F) = (c : ‚Ñù) ‚Ä¢ f := by
          ext x
          simp only [Pi.smul_apply, ‚Üê zsmul_eq_smul_cast]
        simp only [this]
        exact ((c : ‚Ñù) ‚Ä¢ f).decay' }‚ü©
#align schwartz_map.has_zsmul SchwartzMap.hasZsmul

end Smul

section Zero

instance : Zero ùì¢(E, F) :=
  ‚ü®{  toFun := fun _ => 0
      smooth' := contDiff_const
      decay' := fun _ _ => ‚ü®1, fun _ => by simp‚ü© }‚ü©

instance : Inhabited ùì¢(E, F) :=
  ‚ü®0‚ü©

theorem coe_zero : ‚Üë(0 : ùì¢(E, F)) = (0 : E ‚Üí F) :=
  rfl
#align schwartz_map.coe_zero SchwartzMap.coe_zero

@[simp]
theorem coeFn_zero : coeFn (0 : ùì¢(E, F)) = (0 : E ‚Üí F) :=
  rfl
#align schwartz_map.coe_fn_zero SchwartzMap.coeFn_zero

@[simp]
theorem zero_apply {x : E} : (0 : ùì¢(E, F)) x = 0 :=
  rfl
#align schwartz_map.zero_apply SchwartzMap.zero_apply

theorem seminormAux_zero (k n : ‚Ñï) : (0 : ùì¢(E, F)).seminormAux k n = 0 :=
  le_antisymm (seminormAux_le_bound k n _ rfl.le fun _ => by simp [Pi.zero_def])
    (seminormAux_nonneg _ _ _)
#align schwartz_map.seminorm_aux_zero SchwartzMap.seminormAux_zero

end Zero

section Neg

instance : Neg ùì¢(E, F) :=
  ‚ü®fun f =>
    ‚ü®-f, (f.smooth _).neg, fun k n =>
      ‚ü®f.seminormAux k n, fun x => (decay_neg_aux k n f x).le.trans (f.le_seminormAux k n x)‚ü©‚ü©‚ü©

end Neg

section Add

instance : Add ùì¢(E, F) :=
  ‚ü®fun f g =>
    ‚ü®f + g, (f.smooth _).add (g.smooth _), fun k n =>
      ‚ü®f.seminormAux k n + g.seminormAux k n, fun x =>
        (decay_add_le_aux k n f g x).trans
          (add_le_add (f.le_seminormAux k n x) (g.le_seminormAux k n x))‚ü©‚ü©‚ü©

@[simp]
theorem add_apply {f g : ùì¢(E, F)} {x : E} : (f + g) x = f x + g x :=
  rfl
#align schwartz_map.add_apply SchwartzMap.add_apply

theorem seminormAux_add_le (k n : ‚Ñï) (f g : ùì¢(E, F)) :
    (f + g).seminormAux k n ‚â§ f.seminormAux k n + g.seminormAux k n :=
  (f + g).seminormAux_le_bound k n
    (add_nonneg (seminormAux_nonneg _ _ _) (seminormAux_nonneg _ _ _)) fun x =>
    (decay_add_le_aux k n f g x).trans <|
      add_le_add (f.le_seminormAux k n x) (g.le_seminormAux k n x)
#align schwartz_map.seminorm_aux_add_le SchwartzMap.seminormAux_add_le

end Add

section Sub

instance : Sub ùì¢(E, F) :=
  ‚ü®fun f g =>
    ‚ü®f - g, (f.smooth _).sub (g.smooth _), by
      intro k n
      refine' ‚ü®f.seminorm_aux k n + g.seminorm_aux k n, fun x => _‚ü©
      refine' le_trans _ (add_le_add (f.le_seminorm_aux k n x) (g.le_seminorm_aux k n x))
      rw [sub_eq_add_neg]
      rw [‚Üê decay_neg_aux k n g x]
      convert decay_add_le_aux k n f (-g) x‚ü©‚ü©

-- exact fails with deterministic timeout
@[simp]
theorem sub_apply {f g : ùì¢(E, F)} {x : E} : (f - g) x = f x - g x :=
  rfl
#align schwartz_map.sub_apply SchwartzMap.sub_apply

end Sub

section AddCommGroup

instance : AddCommGroup ùì¢(E, F) :=
  FunLike.coe_injective.AddCommGroup _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)
    (fun _ _ => rfl) fun _ _ => rfl

variable (E F)

/-- Coercion as an additive homomorphism. -/
def coeHom : ùì¢(E, F) ‚Üí+ E ‚Üí F where
  toFun f := f
  map_zero' := coe_zero
  map_add' _ _ := rfl
#align schwartz_map.coe_hom SchwartzMap.coeHom

variable {E F}

theorem coe_coeHom : (coeHom E F : ùì¢(E, F) ‚Üí E ‚Üí F) = coeFn :=
  rfl
#align schwartz_map.coe_coe_hom SchwartzMap.coe_coeHom

theorem coeHom_injective : Function.Injective (coeHom E F) :=
  by
  rw [coe_coe_hom]
  exact FunLike.coe_injective
#align schwartz_map.coe_hom_injective SchwartzMap.coeHom_injective

end AddCommGroup

section Module

variable [NormedField ùïú] [NormedSpace ùïú F] [SMulCommClass ‚Ñù ùïú F]

instance : Module ùïú ùì¢(E, F) :=
  coeHom_injective.Module ùïú (coeHom E F) fun _ _ => rfl

end Module

section Seminorms

/-! ### Seminorms on Schwartz space-/


variable [NormedField ùïú] [NormedSpace ùïú F] [SMulCommClass ‚Ñù ùïú F]

variable (ùïú)

/-- The seminorms of the Schwartz space given by the best constants in the definition of
`ùì¢(E, F)`. -/
@[protected]
def seminorm (k n : ‚Ñï) : Seminorm ùïú ùì¢(E, F) :=
  Seminorm.ofSmulLe (seminormAux k n) (seminormAux_zero k n) (seminormAux_add_le k n)
    (seminormAux_smul_le k n)
#align schwartz_map.seminorm SchwartzMap.seminorm

/-- If one controls the seminorm for every `x`, then one controls the seminorm. -/
theorem seminorm_le_bound (k n : ‚Ñï) (f : ùì¢(E, F)) {M : ‚Ñù} (hMp : 0 ‚â§ M)
    (hM : ‚àÄ x, ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFderiv ‚Ñù n f x‚Äñ ‚â§ M) : Seminorm ùïú k n f ‚â§ M :=
  f.seminormAux_le_bound k n hMp hM
#align schwartz_map.seminorm_le_bound SchwartzMap.seminorm_le_bound

/-- The seminorm controls the Schwartz estimate for any fixed `x`. -/
theorem le_seminorm (k n : ‚Ñï) (f : ùì¢(E, F)) (x : E) :
    ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFderiv ‚Ñù n f x‚Äñ ‚â§ Seminorm ùïú k n f :=
  f.le_seminormAux k n x
#align schwartz_map.le_seminorm SchwartzMap.le_seminorm

theorem norm_iteratedFderiv_le_seminorm (f : ùì¢(E, F)) (n : ‚Ñï) (x‚ÇÄ : E) :
    ‚ÄñiteratedFderiv ‚Ñù n f x‚ÇÄ‚Äñ ‚â§ (SchwartzMap.seminorm ùïú 0 n) f :=
  by
  have := SchwartzMap.le_seminorm ùïú 0 n f x‚ÇÄ
  rwa [pow_zero, one_mul] at this
#align schwartz_map.norm_iterated_fderiv_le_seminorm SchwartzMap.norm_iteratedFderiv_le_seminorm

theorem norm_pow_mul_le_seminorm (f : ùì¢(E, F)) (k : ‚Ñï) (x‚ÇÄ : E) :
    ‚Äñx‚ÇÄ‚Äñ ^ k * ‚Äñf x‚ÇÄ‚Äñ ‚â§ (SchwartzMap.seminorm ùïú k 0) f :=
  by
  have := SchwartzMap.le_seminorm ùïú k 0 f x‚ÇÄ
  rwa [norm_iteratedFderiv_zero] at this
#align schwartz_map.norm_pow_mul_le_seminorm SchwartzMap.norm_pow_mul_le_seminorm

theorem norm_le_seminorm (f : ùì¢(E, F)) (x‚ÇÄ : E) : ‚Äñf x‚ÇÄ‚Äñ ‚â§ (SchwartzMap.seminorm ùïú 0 0) f :=
  by
  have := norm_pow_mul_le_seminorm ùïú f 0 x‚ÇÄ
  rwa [pow_zero, one_mul] at this
#align schwartz_map.norm_le_seminorm SchwartzMap.norm_le_seminorm

end Seminorms

section Topology

/-! ### The topology on the Schwartz space-/


variable [NormedField ùïú] [NormedSpace ùïú F] [SMulCommClass ‚Ñù ùïú F]

variable (ùïú E F)

/-- The family of Schwartz seminorms. -/
def schwartzSeminormFamily : SeminormFamily ùïú ùì¢(E, F) (‚Ñï √ó ‚Ñï) := fun n => Seminorm ùïú n.1 n.2
#align schwartz_seminorm_family schwartzSeminormFamily

@[simp]
theorem schwartzSeminormFamily_apply (n k : ‚Ñï) :
    schwartzSeminormFamily ùïú E F (n, k) = SchwartzMap.seminorm ùïú n k :=
  rfl
#align schwartz_map.schwartz_seminorm_family_apply SchwartzMap.schwartzSeminormFamily_apply

@[simp]
theorem schwartzSeminormFamily_apply_zero :
    schwartzSeminormFamily ùïú E F 0 = SchwartzMap.seminorm ùïú 0 0 :=
  rfl
#align schwartz_map.schwartz_seminorm_family_apply_zero SchwartzMap.schwartzSeminormFamily_apply_zero

instance : TopologicalSpace ùì¢(E, F) :=
  (schwartzSeminormFamily ‚Ñù E F).ModuleFilterBasis.topology'

theorem schwartzWithSeminorms : WithSeminorms (schwartzSeminormFamily ùïú E F) :=
  by
  have A : WithSeminorms (schwartzSeminormFamily ‚Ñù E F) := ‚ü®rfl‚ü©
  rw [SeminormFamily.withSeminorms_iff_nhds_eq_inf·µ¢] at A‚ä¢
  rw [A]
  rfl
#align schwartz_with_seminorms schwartzWithSeminorms

variable {ùïú E F}

instance : HasContinuousSmul ùïú ùì¢(E, F) :=
  by
  rw [(schwartzWithSeminorms ùïú E F).withSeminorms_eq]
  exact (schwartzSeminormFamily ùïú E F).ModuleFilterBasis.HasContinuousSmul

instance : TopologicalAddGroup ùì¢(E, F) :=
  (schwartzSeminormFamily ‚Ñù E F).AddGroupFilterBasis.is_topological_add_group

instance : UniformSpace ùì¢(E, F) :=
  (schwartzSeminormFamily ‚Ñù E F).AddGroupFilterBasis.UniformSpace

instance : UniformAddGroup ùì¢(E, F) :=
  (schwartzSeminormFamily ‚Ñù E F).AddGroupFilterBasis.UniformAddGroup

instance : LocallyConvexSpace ‚Ñù ùì¢(E, F) :=
  (schwartzWithSeminorms ‚Ñù E F).toLocallyConvexSpace

instance : TopologicalSpace.FirstCountableTopology ùì¢(E, F) :=
  (schwartzWithSeminorms ‚Ñù E F).first_countable

end Topology

section fderiv

/-! ### Derivatives of Schwartz functions -/


variable {E F}

/-- The derivative of a Schwartz function as a Schwartz function with values in the
continuous linear maps `E‚ÜíL[‚Ñù] F`. -/
@[protected]
def fderiv (f : ùì¢(E, F)) : ùì¢(E, E ‚ÜíL[‚Ñù] F)
    where
  toFun := fderiv ‚Ñù f
  smooth' := (contDiff_top_iff_fderiv.mp f.smooth').2
  decay' := by
    intro k n
    cases' f.decay' k (n + 1) with C hC
    use C
    intro x
    rw [norm_iteratedFderiv_fderiv]
    exact hC x
#align schwartz_map.fderiv SchwartzMap.fderiv

@[simp, norm_cast]
theorem coe_fderiv (f : ùì¢(E, F)) : ‚áëf.fderiv = fderiv ‚Ñù f :=
  rfl
#align schwartz_map.coe_fderiv SchwartzMap.coe_fderiv

@[simp]
theorem fderiv_apply (f : ùì¢(E, F)) (x : E) : f.fderiv x = fderiv ‚Ñù f x :=
  rfl
#align schwartz_map.fderiv_apply SchwartzMap.fderiv_apply

variable (ùïú)

variable [IsROrC ùïú] [NormedSpace ùïú F] [SMulCommClass ‚Ñù ùïú F]

/-- The derivative on Schwartz space as a linear map. -/
def fderivLm : ùì¢(E, F) ‚Üí‚Çó[ùïú] ùì¢(E, E ‚ÜíL[‚Ñù] F)
    where
  toFun := SchwartzMap.fderiv
  map_add' f g :=
    ext fun _ => fderiv_add f.Differentiable.DifferentiableAt g.Differentiable.DifferentiableAt
  map_smul' a f := ext fun _ => fderiv_const_smul f.Differentiable.DifferentiableAt a
#align schwartz_map.fderiv_lm SchwartzMap.fderivLm

@[simp, norm_cast]
theorem fderivLm_apply (f : ùì¢(E, F)) : fderivLm ùïú f = SchwartzMap.fderiv f :=
  rfl
#align schwartz_map.fderiv_lm_apply SchwartzMap.fderivLm_apply

/-- The derivative on Schwartz space as a continuous linear map. -/
def fderivClm : ùì¢(E, F) ‚ÜíL[ùïú] ùì¢(E, E ‚ÜíL[‚Ñù] F)
    where
  cont := by
    change Continuous (fderiv_lm ùïú : ùì¢(E, F) ‚Üí‚Çó[ùïú] ùì¢(E, E ‚ÜíL[‚Ñù] F))
    refine'
      Seminorm.continuous_from_bounded (schwartzWithSeminorms ùïú E F)
        (schwartzWithSeminorms ùïú E (E ‚ÜíL[‚Ñù] F)) _ _
    rintro ‚ü®k, n‚ü©
    use {‚ü®k, n + 1‚ü©}, 1, one_ne_zero
    intro f
    simp only [schwartz_seminorm_family_apply, Seminorm.comp_apply, Finset.sup_singleton, one_smul]
    refine' (fderiv_lm ùïú f).seminorm_le_bound ùïú k n (by positivity) _
    intro x
    rw [fderiv_lm_apply, coe_fderiv, norm_iteratedFderiv_fderiv]
    exact f.le_seminorm ùïú k (n + 1) x
  toLinearMap := fderivLm ùïú
#align schwartz_map.fderiv_clm SchwartzMap.fderivClm

@[simp, norm_cast]
theorem fderivClm_apply (f : ùì¢(E, F)) : fderivClm ùïú f = SchwartzMap.fderiv f :=
  rfl
#align schwartz_map.fderiv_clm_apply SchwartzMap.fderivClm_apply

end fderiv

section BoundedContinuousFunction

/-! ### Inclusion into the space of bounded continuous functions -/


open BoundedContinuousFunction

/-- Schwartz functions as bounded continuous functions-/
def toBoundedContinuousFunction (f : ùì¢(E, F)) : E ‚Üí·µá F :=
  BoundedContinuousFunction.ofNormedAddCommGroup f (SchwartzMap.continuous f)
    (SchwartzMap.seminorm ‚Ñù 0 0 f) (norm_le_seminorm ‚Ñù f)
#align schwartz_map.to_bounded_continuous_function SchwartzMap.toBoundedContinuousFunction

@[simp]
theorem toBoundedContinuousFunction_apply (f : ùì¢(E, F)) (x : E) :
    f.toBoundedContinuousFunction x = f x :=
  rfl
#align schwartz_map.to_bounded_continuous_function_apply SchwartzMap.toBoundedContinuousFunction_apply

variable (ùïú E F)

variable [IsROrC ùïú] [NormedSpace ùïú F] [SMulCommClass ‚Ñù ùïú F]

/-- The inclusion map from Schwartz functions to bounded continuous functions as a linear map. -/
def toBoundedContinuousFunctionLm : ùì¢(E, F) ‚Üí‚Çó[ùïú] E ‚Üí·µá F
    where
  toFun f := f.toBoundedContinuousFunction
  map_add' f g := by
    ext
    exact add_apply
  map_smul' a f := by
    ext
    exact smul_apply
#align schwartz_map.to_bounded_continuous_function_lm SchwartzMap.toBoundedContinuousFunctionLm

@[simp]
theorem toBoundedContinuousFunctionLm_apply (f : ùì¢(E, F)) (x : E) :
    toBoundedContinuousFunctionLm ùïú E F f x = f x :=
  rfl
#align schwartz_map.to_bounded_continuous_function_lm_apply SchwartzMap.toBoundedContinuousFunctionLm_apply

/-- The inclusion map from Schwartz functions to bounded continuous functions as a continuous linear
map. -/
def toBoundedContinuousFunctionClm : ùì¢(E, F) ‚ÜíL[ùïú] E ‚Üí·µá F :=
  { toBoundedContinuousFunctionLm ùïú E F with
    cont := by
      change Continuous (to_bounded_continuous_function_lm ùïú E F)
      refine'
        Seminorm.continuous_from_bounded (schwartzWithSeminorms ùïú E F)
          (normWithSeminorms ùïú (E ‚Üí·µá F)) _ fun i => ‚ü®{0}, 1, one_ne_zero, fun f => _‚ü©
      rw [Finset.sup_singleton, one_smul, Seminorm.comp_apply, coe_normSeminorm,
        schwartz_seminorm_family_apply_zero, BoundedContinuousFunction.norm_le (map_nonneg _ _)]
      intro x
      exact norm_le_seminorm ùïú _ _ }
#align schwartz_map.to_bounded_continuous_function_clm SchwartzMap.toBoundedContinuousFunctionClm

@[simp]
theorem toBoundedContinuousFunctionClm_apply (f : ùì¢(E, F)) (x : E) :
    toBoundedContinuousFunctionClm ùïú E F f x = f x :=
  rfl
#align schwartz_map.to_bounded_continuous_function_clm_apply SchwartzMap.toBoundedContinuousFunctionClm_apply

variable {E}

/-- The Dirac delta distribution -/
def delta (x : E) : ùì¢(E, F) ‚ÜíL[ùïú] F :=
  (BoundedContinuousFunction.evalClm ùïú x).comp (toBoundedContinuousFunctionClm ùïú E F)
#align schwartz_map.delta SchwartzMap.delta

@[simp]
theorem delta_apply (x‚ÇÄ : E) (f : ùì¢(E, F)) : delta ùïú F x‚ÇÄ f = f x‚ÇÄ :=
  rfl
#align schwartz_map.delta_apply SchwartzMap.delta_apply

end BoundedContinuousFunction

end SchwartzMap

