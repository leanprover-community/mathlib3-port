/-
Copyright (c) 2022 Moritz Doll. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Moritz Doll

! This file was ported from Lean 3 source module analysis.locally_convex.bounded
! leanprover-community/mathlib commit 9d2f0748e6c50d7a2657c564b1ff2c695b39148d
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Analysis.LocallyConvex.Basic
import Mathbin.Analysis.LocallyConvex.BalancedCoreHull
import Mathbin.Analysis.Seminorm
import Mathbin.Topology.Bornology.Basic
import Mathbin.Topology.Algebra.UniformGroup
import Mathbin.Topology.UniformSpace.Cauchy

/-!
# Von Neumann Boundedness

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file defines natural or von Neumann bounded sets and proves elementary properties.

## Main declarations

* `bornology.is_vonN_bounded`: A set `s` is von Neumann-bounded if every neighborhood of zero
absorbs `s`.
* `bornology.vonN_bornology`: The bornology made of the von Neumann-bounded sets.

## Main results

* `bornology.is_vonN_bounded.of_topological_space_le`: A coarser topology admits more
von Neumann-bounded sets.
* `bornology.is_vonN_bounded.image`: A continuous linear image of a bounded set is bounded.
* `bornology.is_vonN_bounded_iff_smul_tendsto_zero`: Given any sequence `ε` of scalars which tends
  to `𝓝[≠] 0`, we have that a set `S` is bounded if and only if for any sequence `x : ℕ → S`,
  `ε • x` tends to 0. This shows that bounded sets are completely determined by sequences, which is
  the key fact for proving that sequential continuity implies continuity for linear maps defined on
  a bornological space

## References

* [Bourbaki, *Topological Vector Spaces*][bourbaki1987]

-/


variable {𝕜 𝕜' E E' F ι : Type _}

open Set Filter

open Topology Pointwise

namespace Bornology

section SeminormedRing

section Zero

variable (𝕜)

variable [SeminormedRing 𝕜] [SMul 𝕜 E] [Zero E]

variable [TopologicalSpace E]

#print Bornology.IsVonNBounded /-
/-- A set `s` is von Neumann bounded if every neighborhood of 0 absorbs `s`. -/
def IsVonNBounded (s : Set E) : Prop :=
  ∀ ⦃V⦄, V ∈ 𝓝 (0 : E) → Absorbs 𝕜 V s
#align bornology.is_vonN_bounded Bornology.IsVonNBounded
-/

variable (E)

/- warning: bornology.is_vonN_bounded_empty -> Bornology.isVonNBounded_empty is a dubious translation:
lean 3 declaration is
  forall (𝕜 : Type.{u1}) (E : Type.{u2}) [_inst_1 : SeminormedRing.{u1} 𝕜] [_inst_2 : SMul.{u1, u2} 𝕜 E] [_inst_3 : Zero.{u2} E] [_inst_4 : TopologicalSpace.{u2} E], Bornology.IsVonNBounded.{u1, u2} 𝕜 E _inst_1 _inst_2 _inst_3 _inst_4 (EmptyCollection.emptyCollection.{u2} (Set.{u2} E) (Set.hasEmptyc.{u2} E))
but is expected to have type
  forall (𝕜 : Type.{u2}) (E : Type.{u1}) [_inst_1 : SeminormedRing.{u2} 𝕜] [_inst_2 : SMul.{u2, u1} 𝕜 E] [_inst_3 : Zero.{u1} E] [_inst_4 : TopologicalSpace.{u1} E], Bornology.IsVonNBounded.{u2, u1} 𝕜 E _inst_1 _inst_2 _inst_3 _inst_4 (EmptyCollection.emptyCollection.{u1} (Set.{u1} E) (Set.instEmptyCollectionSet.{u1} E))
Case conversion may be inaccurate. Consider using '#align bornology.is_vonN_bounded_empty Bornology.isVonNBounded_emptyₓ'. -/
@[simp]
theorem isVonNBounded_empty : IsVonNBounded 𝕜 (∅ : Set E) := fun _ _ => absorbs_empty
#align bornology.is_vonN_bounded_empty Bornology.isVonNBounded_empty

variable {𝕜 E}

#print Bornology.isVonNBounded_iff /-
theorem isVonNBounded_iff (s : Set E) : IsVonNBounded 𝕜 s ↔ ∀ V ∈ 𝓝 (0 : E), Absorbs 𝕜 V s :=
  Iff.rfl
#align bornology.is_vonN_bounded_iff Bornology.isVonNBounded_iff
-/

/- warning: filter.has_basis.is_vonN_bounded_basis_iff -> Filter.HasBasis.isVonNBounded_basis_iff is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u1}} {E : Type.{u2}} {ι : Type.{u3}} [_inst_1 : SeminormedRing.{u1} 𝕜] [_inst_2 : SMul.{u1, u2} 𝕜 E] [_inst_3 : Zero.{u2} E] [_inst_4 : TopologicalSpace.{u2} E] {q : ι -> Prop} {s : ι -> (Set.{u2} E)} {A : Set.{u2} E}, (Filter.HasBasis.{u2, succ u3} E ι (nhds.{u2} E _inst_4 (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E _inst_3)))) q s) -> (Iff (Bornology.IsVonNBounded.{u1, u2} 𝕜 E _inst_1 _inst_2 _inst_3 _inst_4 A) (forall (i : ι), (q i) -> (Absorbs.{u1, u2} 𝕜 E _inst_1 _inst_2 (s i) A)))
but is expected to have type
  forall {𝕜 : Type.{u1}} {E : Type.{u3}} {ι : Type.{u2}} [_inst_1 : SeminormedRing.{u1} 𝕜] [_inst_2 : SMul.{u1, u3} 𝕜 E] [_inst_3 : Zero.{u3} E] [_inst_4 : TopologicalSpace.{u3} E] {q : ι -> Prop} {s : ι -> (Set.{u3} E)} {A : Set.{u3} E}, (Filter.HasBasis.{u3, succ u2} E ι (nhds.{u3} E _inst_4 (OfNat.ofNat.{u3} E 0 (Zero.toOfNat0.{u3} E _inst_3))) q s) -> (Iff (Bornology.IsVonNBounded.{u1, u3} 𝕜 E _inst_1 _inst_2 _inst_3 _inst_4 A) (forall (i : ι), (q i) -> (Absorbs.{u1, u3} 𝕜 E _inst_1 _inst_2 (s i) A)))
Case conversion may be inaccurate. Consider using '#align filter.has_basis.is_vonN_bounded_basis_iff Filter.HasBasis.isVonNBounded_basis_iffₓ'. -/
theorem Filter.HasBasis.isVonNBounded_basis_iff {q : ι → Prop} {s : ι → Set E} {A : Set E}
    (h : (𝓝 (0 : E)).HasBasis q s) : IsVonNBounded 𝕜 A ↔ ∀ (i) (hi : q i), Absorbs 𝕜 (s i) A :=
  by
  refine' ⟨fun hA i hi => hA (h.mem_of_mem hi), fun hA V hV => _⟩
  rcases h.mem_iff.mp hV with ⟨i, hi, hV⟩
  exact (hA i hi).mono_left hV
#align filter.has_basis.is_vonN_bounded_basis_iff Filter.HasBasis.isVonNBounded_basis_iff

#print Bornology.IsVonNBounded.subset /-
/-- Subsets of bounded sets are bounded. -/
theorem IsVonNBounded.subset {s₁ s₂ : Set E} (h : s₁ ⊆ s₂) (hs₂ : IsVonNBounded 𝕜 s₂) :
    IsVonNBounded 𝕜 s₁ := fun V hV => (hs₂ hV).mono_right h
#align bornology.is_vonN_bounded.subset Bornology.IsVonNBounded.subset
-/

/- warning: bornology.is_vonN_bounded.union -> Bornology.IsVonNBounded.union is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u1}} {E : Type.{u2}} [_inst_1 : SeminormedRing.{u1} 𝕜] [_inst_2 : SMul.{u1, u2} 𝕜 E] [_inst_3 : Zero.{u2} E] [_inst_4 : TopologicalSpace.{u2} E] {s₁ : Set.{u2} E} {s₂ : Set.{u2} E}, (Bornology.IsVonNBounded.{u1, u2} 𝕜 E _inst_1 _inst_2 _inst_3 _inst_4 s₁) -> (Bornology.IsVonNBounded.{u1, u2} 𝕜 E _inst_1 _inst_2 _inst_3 _inst_4 s₂) -> (Bornology.IsVonNBounded.{u1, u2} 𝕜 E _inst_1 _inst_2 _inst_3 _inst_4 (Union.union.{u2} (Set.{u2} E) (Set.hasUnion.{u2} E) s₁ s₂))
but is expected to have type
  forall {𝕜 : Type.{u1}} {E : Type.{u2}} [_inst_1 : SeminormedRing.{u1} 𝕜] [_inst_2 : SMul.{u1, u2} 𝕜 E] [_inst_3 : Zero.{u2} E] [_inst_4 : TopologicalSpace.{u2} E] {s₁ : Set.{u2} E} {s₂ : Set.{u2} E}, (Bornology.IsVonNBounded.{u1, u2} 𝕜 E _inst_1 _inst_2 _inst_3 _inst_4 s₁) -> (Bornology.IsVonNBounded.{u1, u2} 𝕜 E _inst_1 _inst_2 _inst_3 _inst_4 s₂) -> (Bornology.IsVonNBounded.{u1, u2} 𝕜 E _inst_1 _inst_2 _inst_3 _inst_4 (Union.union.{u2} (Set.{u2} E) (Set.instUnionSet.{u2} E) s₁ s₂))
Case conversion may be inaccurate. Consider using '#align bornology.is_vonN_bounded.union Bornology.IsVonNBounded.unionₓ'. -/
/-- The union of two bounded sets is bounded. -/
theorem IsVonNBounded.union {s₁ s₂ : Set E} (hs₁ : IsVonNBounded 𝕜 s₁) (hs₂ : IsVonNBounded 𝕜 s₂) :
    IsVonNBounded 𝕜 (s₁ ∪ s₂) := fun V hV => (hs₁ hV).union (hs₂ hV)
#align bornology.is_vonN_bounded.union Bornology.IsVonNBounded.union

end Zero

end SeminormedRing

section MultipleTopologies

variable [SeminormedRing 𝕜] [AddCommGroup E] [Module 𝕜 E]

/- warning: bornology.is_vonN_bounded.of_topological_space_le -> Bornology.IsVonNBounded.of_topologicalSpace_le is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u1}} {E : Type.{u2}} [_inst_1 : SeminormedRing.{u1} 𝕜] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 (SeminormedRing.toRing.{u1} 𝕜 _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {t : TopologicalSpace.{u2} E} {t' : TopologicalSpace.{u2} E}, (LE.le.{u2} (TopologicalSpace.{u2} E) (Preorder.toLE.{u2} (TopologicalSpace.{u2} E) (PartialOrder.toPreorder.{u2} (TopologicalSpace.{u2} E) (TopologicalSpace.partialOrder.{u2} E))) t t') -> (forall {s : Set.{u2} E}, (Bornology.IsVonNBounded.{u1, u2} 𝕜 E _inst_1 (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 E (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (SeminormedRing.toRing.{u1} 𝕜 _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (SeminormedRing.toRing.{u1} 𝕜 _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 (SeminormedRing.toRing.{u1} 𝕜 _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))) t s) -> (Bornology.IsVonNBounded.{u1, u2} 𝕜 E _inst_1 (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 E (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (SeminormedRing.toRing.{u1} 𝕜 _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (SeminormedRing.toRing.{u1} 𝕜 _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 (SeminormedRing.toRing.{u1} 𝕜 _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))) t' s))
but is expected to have type
  forall {𝕜 : Type.{u1}} {E : Type.{u2}} [_inst_1 : SeminormedRing.{u1} 𝕜] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 (SeminormedRing.toRing.{u1} 𝕜 _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {t : TopologicalSpace.{u2} E} {t' : TopologicalSpace.{u2} E}, (LE.le.{u2} (TopologicalSpace.{u2} E) (Preorder.toLE.{u2} (TopologicalSpace.{u2} E) (PartialOrder.toPreorder.{u2} (TopologicalSpace.{u2} E) (TopologicalSpace.instPartialOrderTopologicalSpace.{u2} E))) t t') -> (forall {s : Set.{u2} E}, (Bornology.IsVonNBounded.{u1, u2} 𝕜 E _inst_1 (SMulZeroClass.toSMul.{u1, u2} 𝕜 E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} 𝕜 E (MonoidWithZero.toZero.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (SeminormedRing.toRing.{u1} 𝕜 _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (SeminormedRing.toRing.{u1} 𝕜 _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 (SeminormedRing.toRing.{u1} 𝕜 _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) t s) -> (Bornology.IsVonNBounded.{u1, u2} 𝕜 E _inst_1 (SMulZeroClass.toSMul.{u1, u2} 𝕜 E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} 𝕜 E (MonoidWithZero.toZero.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (SeminormedRing.toRing.{u1} 𝕜 _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (SeminormedRing.toRing.{u1} 𝕜 _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 (SeminormedRing.toRing.{u1} 𝕜 _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) t' s))
Case conversion may be inaccurate. Consider using '#align bornology.is_vonN_bounded.of_topological_space_le Bornology.IsVonNBounded.of_topologicalSpace_leₓ'. -/
/-- If a topology `t'` is coarser than `t`, then any set `s` that is bounded with respect to
`t` is bounded with respect to `t'`. -/
theorem IsVonNBounded.of_topologicalSpace_le {t t' : TopologicalSpace E} (h : t ≤ t') {s : Set E}
    (hs : @IsVonNBounded 𝕜 E _ _ _ t s) : @IsVonNBounded 𝕜 E _ _ _ t' s := fun V hV =>
  hs <| (le_iff_nhds t t').mp h 0 hV
#align bornology.is_vonN_bounded.of_topological_space_le Bornology.IsVonNBounded.of_topologicalSpace_le

end MultipleTopologies

section Image

variable {𝕜₁ 𝕜₂ : Type _} [NormedDivisionRing 𝕜₁] [NormedDivisionRing 𝕜₂] [AddCommGroup E]
  [Module 𝕜₁ E] [AddCommGroup F] [Module 𝕜₂ F] [TopologicalSpace E] [TopologicalSpace F]

/- warning: bornology.is_vonN_bounded.image -> Bornology.IsVonNBounded.image is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} {F : Type.{u2}} {𝕜₁ : Type.{u3}} {𝕜₂ : Type.{u4}} [_inst_1 : NormedDivisionRing.{u3} 𝕜₁] [_inst_2 : NormedDivisionRing.{u4} 𝕜₂] [_inst_3 : AddCommGroup.{u1} E] [_inst_4 : Module.{u3, u1} 𝕜₁ E (Ring.toSemiring.{u3} 𝕜₁ (NormedRing.toRing.{u3} 𝕜₁ (NormedDivisionRing.toNormedRing.{u3} 𝕜₁ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_3)] [_inst_5 : AddCommGroup.{u2} F] [_inst_6 : Module.{u4, u2} 𝕜₂ F (Ring.toSemiring.{u4} 𝕜₂ (NormedRing.toRing.{u4} 𝕜₂ (NormedDivisionRing.toNormedRing.{u4} 𝕜₂ _inst_2))) (AddCommGroup.toAddCommMonoid.{u2} F _inst_5)] [_inst_7 : TopologicalSpace.{u1} E] [_inst_8 : TopologicalSpace.{u2} F] {σ : RingHom.{u3, u4} 𝕜₁ 𝕜₂ (NonAssocRing.toNonAssocSemiring.{u3} 𝕜₁ (Ring.toNonAssocRing.{u3} 𝕜₁ (NormedRing.toRing.{u3} 𝕜₁ (NormedDivisionRing.toNormedRing.{u3} 𝕜₁ _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u4} 𝕜₂ (Ring.toNonAssocRing.{u4} 𝕜₂ (NormedRing.toRing.{u4} 𝕜₂ (NormedDivisionRing.toNormedRing.{u4} 𝕜₂ _inst_2))))} [_inst_9 : RingHomSurjective.{u3, u4} 𝕜₁ 𝕜₂ (Ring.toSemiring.{u3} 𝕜₁ (NormedRing.toRing.{u3} 𝕜₁ (NormedDivisionRing.toNormedRing.{u3} 𝕜₁ _inst_1))) (Ring.toSemiring.{u4} 𝕜₂ (NormedRing.toRing.{u4} 𝕜₂ (NormedDivisionRing.toNormedRing.{u4} 𝕜₂ _inst_2))) σ] [_inst_10 : RingHomIsometric.{u3, u4} 𝕜₁ 𝕜₂ (Ring.toSemiring.{u3} 𝕜₁ (NormedRing.toRing.{u3} 𝕜₁ (NormedDivisionRing.toNormedRing.{u3} 𝕜₁ _inst_1))) (Ring.toSemiring.{u4} 𝕜₂ (NormedRing.toRing.{u4} 𝕜₂ (NormedDivisionRing.toNormedRing.{u4} 𝕜₂ _inst_2))) (NormedDivisionRing.toHasNorm.{u3} 𝕜₁ _inst_1) (NormedDivisionRing.toHasNorm.{u4} 𝕜₂ _inst_2) σ] {s : Set.{u1} E}, (Bornology.IsVonNBounded.{u3, u1} 𝕜₁ E (NormedRing.toSeminormedRing.{u3} 𝕜₁ (NormedDivisionRing.toNormedRing.{u3} 𝕜₁ _inst_1)) (SMulZeroClass.toHasSmul.{u3, u1} 𝕜₁ E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_3)))) (SMulWithZero.toSmulZeroClass.{u3, u1} 𝕜₁ E (MulZeroClass.toHasZero.{u3} 𝕜₁ (MulZeroOneClass.toMulZeroClass.{u3} 𝕜₁ (MonoidWithZero.toMulZeroOneClass.{u3} 𝕜₁ (Semiring.toMonoidWithZero.{u3} 𝕜₁ (Ring.toSemiring.{u3} 𝕜₁ (NormedRing.toRing.{u3} 𝕜₁ (NormedDivisionRing.toNormedRing.{u3} 𝕜₁ _inst_1))))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_3)))) (MulActionWithZero.toSMulWithZero.{u3, u1} 𝕜₁ E (Semiring.toMonoidWithZero.{u3} 𝕜₁ (Ring.toSemiring.{u3} 𝕜₁ (NormedRing.toRing.{u3} 𝕜₁ (NormedDivisionRing.toNormedRing.{u3} 𝕜₁ _inst_1)))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_3)))) (Module.toMulActionWithZero.{u3, u1} 𝕜₁ E (Ring.toSemiring.{u3} 𝕜₁ (NormedRing.toRing.{u3} 𝕜₁ (NormedDivisionRing.toNormedRing.{u3} 𝕜₁ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_3) _inst_4)))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_3))))) _inst_7 s) -> (forall (f : ContinuousLinearMap.{u3, u4, u1, u2} 𝕜₁ 𝕜₂ (Ring.toSemiring.{u3} 𝕜₁ (NormedRing.toRing.{u3} 𝕜₁ (NormedDivisionRing.toNormedRing.{u3} 𝕜₁ _inst_1))) (Ring.toSemiring.{u4} 𝕜₂ (NormedRing.toRing.{u4} 𝕜₂ (NormedDivisionRing.toNormedRing.{u4} 𝕜₂ _inst_2))) σ E _inst_7 (AddCommGroup.toAddCommMonoid.{u1} E _inst_3) F _inst_8 (AddCommGroup.toAddCommMonoid.{u2} F _inst_5) _inst_4 _inst_6), Bornology.IsVonNBounded.{u4, u2} 𝕜₂ F (NormedRing.toSeminormedRing.{u4} 𝕜₂ (NormedDivisionRing.toNormedRing.{u4} 𝕜₂ _inst_2)) (SMulZeroClass.toHasSmul.{u4, u2} 𝕜₂ F (AddZeroClass.toHasZero.{u2} F (AddMonoid.toAddZeroClass.{u2} F (AddCommMonoid.toAddMonoid.{u2} F (AddCommGroup.toAddCommMonoid.{u2} F _inst_5)))) (SMulWithZero.toSmulZeroClass.{u4, u2} 𝕜₂ F (MulZeroClass.toHasZero.{u4} 𝕜₂ (MulZeroOneClass.toMulZeroClass.{u4} 𝕜₂ (MonoidWithZero.toMulZeroOneClass.{u4} 𝕜₂ (Semiring.toMonoidWithZero.{u4} 𝕜₂ (Ring.toSemiring.{u4} 𝕜₂ (NormedRing.toRing.{u4} 𝕜₂ (NormedDivisionRing.toNormedRing.{u4} 𝕜₂ _inst_2))))))) (AddZeroClass.toHasZero.{u2} F (AddMonoid.toAddZeroClass.{u2} F (AddCommMonoid.toAddMonoid.{u2} F (AddCommGroup.toAddCommMonoid.{u2} F _inst_5)))) (MulActionWithZero.toSMulWithZero.{u4, u2} 𝕜₂ F (Semiring.toMonoidWithZero.{u4} 𝕜₂ (Ring.toSemiring.{u4} 𝕜₂ (NormedRing.toRing.{u4} 𝕜₂ (NormedDivisionRing.toNormedRing.{u4} 𝕜₂ _inst_2)))) (AddZeroClass.toHasZero.{u2} F (AddMonoid.toAddZeroClass.{u2} F (AddCommMonoid.toAddMonoid.{u2} F (AddCommGroup.toAddCommMonoid.{u2} F _inst_5)))) (Module.toMulActionWithZero.{u4, u2} 𝕜₂ F (Ring.toSemiring.{u4} 𝕜₂ (NormedRing.toRing.{u4} 𝕜₂ (NormedDivisionRing.toNormedRing.{u4} 𝕜₂ _inst_2))) (AddCommGroup.toAddCommMonoid.{u2} F _inst_5) _inst_6)))) (AddZeroClass.toHasZero.{u2} F (AddMonoid.toAddZeroClass.{u2} F (SubNegMonoid.toAddMonoid.{u2} F (AddGroup.toSubNegMonoid.{u2} F (AddCommGroup.toAddGroup.{u2} F _inst_5))))) _inst_8 (Set.image.{u1, u2} E F (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousLinearMap.{u3, u4, u1, u2} 𝕜₁ 𝕜₂ (Ring.toSemiring.{u3} 𝕜₁ (NormedRing.toRing.{u3} 𝕜₁ (NormedDivisionRing.toNormedRing.{u3} 𝕜₁ _inst_1))) (Ring.toSemiring.{u4} 𝕜₂ (NormedRing.toRing.{u4} 𝕜₂ (NormedDivisionRing.toNormedRing.{u4} 𝕜₂ _inst_2))) σ E _inst_7 (AddCommGroup.toAddCommMonoid.{u1} E _inst_3) F _inst_8 (AddCommGroup.toAddCommMonoid.{u2} F _inst_5) _inst_4 _inst_6) (fun (_x : ContinuousLinearMap.{u3, u4, u1, u2} 𝕜₁ 𝕜₂ (Ring.toSemiring.{u3} 𝕜₁ (NormedRing.toRing.{u3} 𝕜₁ (NormedDivisionRing.toNormedRing.{u3} 𝕜₁ _inst_1))) (Ring.toSemiring.{u4} 𝕜₂ (NormedRing.toRing.{u4} 𝕜₂ (NormedDivisionRing.toNormedRing.{u4} 𝕜₂ _inst_2))) σ E _inst_7 (AddCommGroup.toAddCommMonoid.{u1} E _inst_3) F _inst_8 (AddCommGroup.toAddCommMonoid.{u2} F _inst_5) _inst_4 _inst_6) => E -> F) (ContinuousLinearMap.toFun.{u3, u4, u1, u2} 𝕜₁ 𝕜₂ (Ring.toSemiring.{u3} 𝕜₁ (NormedRing.toRing.{u3} 𝕜₁ (NormedDivisionRing.toNormedRing.{u3} 𝕜₁ _inst_1))) (Ring.toSemiring.{u4} 𝕜₂ (NormedRing.toRing.{u4} 𝕜₂ (NormedDivisionRing.toNormedRing.{u4} 𝕜₂ _inst_2))) σ E _inst_7 (AddCommGroup.toAddCommMonoid.{u1} E _inst_3) F _inst_8 (AddCommGroup.toAddCommMonoid.{u2} F _inst_5) _inst_4 _inst_6) f) s))
but is expected to have type
  forall {E : Type.{u2}} {F : Type.{u1}} {𝕜₁ : Type.{u4}} {𝕜₂ : Type.{u3}} [_inst_1 : NormedDivisionRing.{u4} 𝕜₁] [_inst_2 : NormedDivisionRing.{u3} 𝕜₂] [_inst_3 : AddCommGroup.{u2} E] [_inst_4 : Module.{u4, u2} 𝕜₁ E (DivisionSemiring.toSemiring.{u4} 𝕜₁ (DivisionRing.toDivisionSemiring.{u4} 𝕜₁ (NormedDivisionRing.toDivisionRing.{u4} 𝕜₁ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_3)] [_inst_5 : AddCommGroup.{u1} F] [_inst_6 : Module.{u3, u1} 𝕜₂ F (DivisionSemiring.toSemiring.{u3} 𝕜₂ (DivisionRing.toDivisionSemiring.{u3} 𝕜₂ (NormedDivisionRing.toDivisionRing.{u3} 𝕜₂ _inst_2))) (AddCommGroup.toAddCommMonoid.{u1} F _inst_5)] [_inst_7 : TopologicalSpace.{u2} E] [_inst_8 : TopologicalSpace.{u1} F] {σ : RingHom.{u4, u3} 𝕜₁ 𝕜₂ (Semiring.toNonAssocSemiring.{u4} 𝕜₁ (DivisionSemiring.toSemiring.{u4} 𝕜₁ (DivisionRing.toDivisionSemiring.{u4} 𝕜₁ (NormedDivisionRing.toDivisionRing.{u4} 𝕜₁ _inst_1)))) (Semiring.toNonAssocSemiring.{u3} 𝕜₂ (DivisionSemiring.toSemiring.{u3} 𝕜₂ (DivisionRing.toDivisionSemiring.{u3} 𝕜₂ (NormedDivisionRing.toDivisionRing.{u3} 𝕜₂ _inst_2))))} [_inst_9 : RingHomSurjective.{u4, u3} 𝕜₁ 𝕜₂ (DivisionSemiring.toSemiring.{u4} 𝕜₁ (DivisionRing.toDivisionSemiring.{u4} 𝕜₁ (NormedDivisionRing.toDivisionRing.{u4} 𝕜₁ _inst_1))) (DivisionSemiring.toSemiring.{u3} 𝕜₂ (DivisionRing.toDivisionSemiring.{u3} 𝕜₂ (NormedDivisionRing.toDivisionRing.{u3} 𝕜₂ _inst_2))) σ] [_inst_10 : RingHomIsometric.{u4, u3} 𝕜₁ 𝕜₂ (DivisionSemiring.toSemiring.{u4} 𝕜₁ (DivisionRing.toDivisionSemiring.{u4} 𝕜₁ (NormedDivisionRing.toDivisionRing.{u4} 𝕜₁ _inst_1))) (DivisionSemiring.toSemiring.{u3} 𝕜₂ (DivisionRing.toDivisionSemiring.{u3} 𝕜₂ (NormedDivisionRing.toDivisionRing.{u3} 𝕜₂ _inst_2))) (NormedDivisionRing.toNorm.{u4} 𝕜₁ _inst_1) (NormedDivisionRing.toNorm.{u3} 𝕜₂ _inst_2) σ] {s : Set.{u2} E}, (Bornology.IsVonNBounded.{u4, u2} 𝕜₁ E (NormedRing.toSeminormedRing.{u4} 𝕜₁ (NormedDivisionRing.toNormedRing.{u4} 𝕜₁ _inst_1)) (SMulZeroClass.toSMul.{u4, u2} 𝕜₁ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_3))))) (SMulWithZero.toSMulZeroClass.{u4, u2} 𝕜₁ E (MonoidWithZero.toZero.{u4} 𝕜₁ (Semiring.toMonoidWithZero.{u4} 𝕜₁ (DivisionSemiring.toSemiring.{u4} 𝕜₁ (DivisionRing.toDivisionSemiring.{u4} 𝕜₁ (NormedDivisionRing.toDivisionRing.{u4} 𝕜₁ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_3))))) (MulActionWithZero.toSMulWithZero.{u4, u2} 𝕜₁ E (Semiring.toMonoidWithZero.{u4} 𝕜₁ (DivisionSemiring.toSemiring.{u4} 𝕜₁ (DivisionRing.toDivisionSemiring.{u4} 𝕜₁ (NormedDivisionRing.toDivisionRing.{u4} 𝕜₁ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_3))))) (Module.toMulActionWithZero.{u4, u2} 𝕜₁ E (DivisionSemiring.toSemiring.{u4} 𝕜₁ (DivisionRing.toDivisionSemiring.{u4} 𝕜₁ (NormedDivisionRing.toDivisionRing.{u4} 𝕜₁ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_3) _inst_4)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_3))))) _inst_7 s) -> (forall (f : ContinuousLinearMap.{u4, u3, u2, u1} 𝕜₁ 𝕜₂ (DivisionSemiring.toSemiring.{u4} 𝕜₁ (DivisionRing.toDivisionSemiring.{u4} 𝕜₁ (NormedDivisionRing.toDivisionRing.{u4} 𝕜₁ _inst_1))) (DivisionSemiring.toSemiring.{u3} 𝕜₂ (DivisionRing.toDivisionSemiring.{u3} 𝕜₂ (NormedDivisionRing.toDivisionRing.{u3} 𝕜₂ _inst_2))) σ E _inst_7 (AddCommGroup.toAddCommMonoid.{u2} E _inst_3) F _inst_8 (AddCommGroup.toAddCommMonoid.{u1} F _inst_5) _inst_4 _inst_6), Bornology.IsVonNBounded.{u3, u1} 𝕜₂ F (NormedRing.toSeminormedRing.{u3} 𝕜₂ (NormedDivisionRing.toNormedRing.{u3} 𝕜₂ _inst_2)) (SMulZeroClass.toSMul.{u3, u1} 𝕜₂ F (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_5))))) (SMulWithZero.toSMulZeroClass.{u3, u1} 𝕜₂ F (MonoidWithZero.toZero.{u3} 𝕜₂ (Semiring.toMonoidWithZero.{u3} 𝕜₂ (DivisionSemiring.toSemiring.{u3} 𝕜₂ (DivisionRing.toDivisionSemiring.{u3} 𝕜₂ (NormedDivisionRing.toDivisionRing.{u3} 𝕜₂ _inst_2))))) (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_5))))) (MulActionWithZero.toSMulWithZero.{u3, u1} 𝕜₂ F (Semiring.toMonoidWithZero.{u3} 𝕜₂ (DivisionSemiring.toSemiring.{u3} 𝕜₂ (DivisionRing.toDivisionSemiring.{u3} 𝕜₂ (NormedDivisionRing.toDivisionRing.{u3} 𝕜₂ _inst_2)))) (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_5))))) (Module.toMulActionWithZero.{u3, u1} 𝕜₂ F (DivisionSemiring.toSemiring.{u3} 𝕜₂ (DivisionRing.toDivisionSemiring.{u3} 𝕜₂ (NormedDivisionRing.toDivisionRing.{u3} 𝕜₂ _inst_2))) (AddCommGroup.toAddCommMonoid.{u1} F _inst_5) _inst_6)))) (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_5))))) _inst_8 (Set.image.{u2, u1} E F (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousLinearMap.{u4, u3, u2, u1} 𝕜₁ 𝕜₂ (DivisionSemiring.toSemiring.{u4} 𝕜₁ (DivisionRing.toDivisionSemiring.{u4} 𝕜₁ (NormedDivisionRing.toDivisionRing.{u4} 𝕜₁ _inst_1))) (DivisionSemiring.toSemiring.{u3} 𝕜₂ (DivisionRing.toDivisionSemiring.{u3} 𝕜₂ (NormedDivisionRing.toDivisionRing.{u3} 𝕜₂ _inst_2))) σ E _inst_7 (AddCommGroup.toAddCommMonoid.{u2} E _inst_3) F _inst_8 (AddCommGroup.toAddCommMonoid.{u1} F _inst_5) _inst_4 _inst_6) E (fun (_x : E) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : E) => F) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousLinearMap.{u4, u3, u2, u1} 𝕜₁ 𝕜₂ (DivisionSemiring.toSemiring.{u4} 𝕜₁ (DivisionRing.toDivisionSemiring.{u4} 𝕜₁ (NormedDivisionRing.toDivisionRing.{u4} 𝕜₁ _inst_1))) (DivisionSemiring.toSemiring.{u3} 𝕜₂ (DivisionRing.toDivisionSemiring.{u3} 𝕜₂ (NormedDivisionRing.toDivisionRing.{u3} 𝕜₂ _inst_2))) σ E _inst_7 (AddCommGroup.toAddCommMonoid.{u2} E _inst_3) F _inst_8 (AddCommGroup.toAddCommMonoid.{u1} F _inst_5) _inst_4 _inst_6) E F _inst_7 _inst_8 (ContinuousSemilinearMapClass.toContinuousMapClass.{max u2 u1, u4, u3, u2, u1} (ContinuousLinearMap.{u4, u3, u2, u1} 𝕜₁ 𝕜₂ (DivisionSemiring.toSemiring.{u4} 𝕜₁ (DivisionRing.toDivisionSemiring.{u4} 𝕜₁ (NormedDivisionRing.toDivisionRing.{u4} 𝕜₁ _inst_1))) (DivisionSemiring.toSemiring.{u3} 𝕜₂ (DivisionRing.toDivisionSemiring.{u3} 𝕜₂ (NormedDivisionRing.toDivisionRing.{u3} 𝕜₂ _inst_2))) σ E _inst_7 (AddCommGroup.toAddCommMonoid.{u2} E _inst_3) F _inst_8 (AddCommGroup.toAddCommMonoid.{u1} F _inst_5) _inst_4 _inst_6) 𝕜₁ 𝕜₂ (DivisionSemiring.toSemiring.{u4} 𝕜₁ (DivisionRing.toDivisionSemiring.{u4} 𝕜₁ (NormedDivisionRing.toDivisionRing.{u4} 𝕜₁ _inst_1))) (DivisionSemiring.toSemiring.{u3} 𝕜₂ (DivisionRing.toDivisionSemiring.{u3} 𝕜₂ (NormedDivisionRing.toDivisionRing.{u3} 𝕜₂ _inst_2))) σ E _inst_7 (AddCommGroup.toAddCommMonoid.{u2} E _inst_3) F _inst_8 (AddCommGroup.toAddCommMonoid.{u1} F _inst_5) _inst_4 _inst_6 (ContinuousLinearMap.continuousSemilinearMapClass.{u4, u3, u2, u1} 𝕜₁ 𝕜₂ (DivisionSemiring.toSemiring.{u4} 𝕜₁ (DivisionRing.toDivisionSemiring.{u4} 𝕜₁ (NormedDivisionRing.toDivisionRing.{u4} 𝕜₁ _inst_1))) (DivisionSemiring.toSemiring.{u3} 𝕜₂ (DivisionRing.toDivisionSemiring.{u3} 𝕜₂ (NormedDivisionRing.toDivisionRing.{u3} 𝕜₂ _inst_2))) σ E _inst_7 (AddCommGroup.toAddCommMonoid.{u2} E _inst_3) F _inst_8 (AddCommGroup.toAddCommMonoid.{u1} F _inst_5) _inst_4 _inst_6))) f) s))
Case conversion may be inaccurate. Consider using '#align bornology.is_vonN_bounded.image Bornology.IsVonNBounded.imageₓ'. -/
/-- A continuous linear image of a bounded set is bounded. -/
theorem IsVonNBounded.image {σ : 𝕜₁ →+* 𝕜₂} [RingHomSurjective σ] [RingHomIsometric σ] {s : Set E}
    (hs : IsVonNBounded 𝕜₁ s) (f : E →SL[σ] F) : IsVonNBounded 𝕜₂ (f '' s) :=
  by
  let σ' := RingEquiv.ofBijective σ ⟨σ.injective, σ.is_surjective⟩
  have σ_iso : Isometry σ := AddMonoidHomClass.isometry_of_norm σ fun x => RingHomIsometric.is_iso
  have σ'_symm_iso : Isometry σ'.symm := σ_iso.right_inv σ'.right_inv
  have f_tendsto_zero := f.continuous.tendsto 0
  rw [map_zero] at f_tendsto_zero
  intro V hV
  rcases hs (f_tendsto_zero hV) with ⟨r, hrpos, hr⟩
  refine' ⟨r, hrpos, fun a ha => _⟩
  rw [← σ'.apply_symm_apply a]
  have hanz : a ≠ 0 := norm_pos_iff.mp (hrpos.trans_le ha)
  have : σ'.symm a ≠ 0 := (map_ne_zero σ'.symm.to_ring_hom).mpr hanz
  change _ ⊆ σ _ • _
  rw [Set.image_subset_iff, preimage_smul_setₛₗ _ _ _ f this.is_unit]
  refine' hr (σ'.symm a) _
  rwa [σ'_symm_iso.norm_map_of_map_zero (map_zero _)]
#align bornology.is_vonN_bounded.image Bornology.IsVonNBounded.image

end Image

section sequence

variable {𝕝 : Type _} [NormedField 𝕜] [NontriviallyNormedField 𝕝] [AddCommGroup E] [Module 𝕜 E]
  [Module 𝕝 E] [TopologicalSpace E] [ContinuousSMul 𝕝 E]

/- warning: bornology.is_vonN_bounded.smul_tendsto_zero -> Bornology.IsVonNBounded.smul_tendsto_zero is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u1}} {E : Type.{u2}} {ι : Type.{u3}} [_inst_1 : NormedField.{u1} 𝕜] [_inst_3 : AddCommGroup.{u2} E] [_inst_4 : Module.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_3)] [_inst_6 : TopologicalSpace.{u2} E] {S : Set.{u2} E} {ε : ι -> 𝕜} {x : ι -> E} {l : Filter.{u3} ι}, (Bornology.IsVonNBounded.{u1, u2} 𝕜 E (SeminormedCommRing.toSemiNormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1))) (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 E (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_3)))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_3) _inst_4)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_3))))) _inst_6 S) -> (Filter.Eventually.{u3} ι (fun (n : ι) => Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) (x n) S) l) -> (Filter.Tendsto.{u3, u1} ι 𝕜 ε l (nhds.{u1} 𝕜 (UniformSpace.toTopologicalSpace.{u1} 𝕜 (PseudoMetricSpace.toUniformSpace.{u1} 𝕜 (SeminormedRing.toPseudoMetricSpace.{u1} 𝕜 (SeminormedCommRing.toSemiNormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1)))))) (OfNat.ofNat.{u1} 𝕜 0 (OfNat.mk.{u1} 𝕜 0 (Zero.zero.{u1} 𝕜 (MulZeroClass.toHasZero.{u1} 𝕜 (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} 𝕜 (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} 𝕜 (NonAssocRing.toNonUnitalNonAssocRing.{u1} 𝕜 (Ring.toNonAssocRing.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1))))))))))))) -> (Filter.Tendsto.{u3, u2} ι E (SMul.smul.{max u3 u1, max u3 u2} (ι -> 𝕜) (ι -> E) (Pi.smul'.{u3, u1, u2} ι (fun (ᾰ : ι) => 𝕜) (fun (ᾰ : ι) => E) (fun (i : ι) => SMulZeroClass.toHasSmul.{u1, u2} 𝕜 E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 E (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_3)))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_3) _inst_4))))) ε x) l (nhds.{u2} E _inst_6 (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_3))))))))))
but is expected to have type
  forall {𝕜 : Type.{u1}} {E : Type.{u3}} {ι : Type.{u2}} [_inst_1 : NormedField.{u1} 𝕜] [_inst_3 : AddCommGroup.{u3} E] [_inst_4 : Module.{u1, u3} 𝕜 E (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1)))) (AddCommGroup.toAddCommMonoid.{u3} E _inst_3)] [_inst_6 : TopologicalSpace.{u3} E] {S : Set.{u3} E} {ε : ι -> 𝕜} {x : ι -> E} {l : Filter.{u2} ι}, (Bornology.IsVonNBounded.{u1, u3} 𝕜 E (SeminormedCommRing.toSeminormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1))) (SMulZeroClass.toSMul.{u1, u3} 𝕜 E (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_3))))) (SMulWithZero.toSMulZeroClass.{u1, u3} 𝕜 E (CommMonoidWithZero.toZero.{u1} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u1} 𝕜 (Semifield.toCommGroupWithZero.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_3))))) (MulActionWithZero.toSMulWithZero.{u1, u3} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_3))))) (Module.toMulActionWithZero.{u1, u3} 𝕜 E (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1)))) (AddCommGroup.toAddCommMonoid.{u3} E _inst_3) _inst_4)))) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_3))))) _inst_6 S) -> (Filter.Eventually.{u2} ι (fun (n : ι) => Membership.mem.{u3, u3} E (Set.{u3} E) (Set.instMembershipSet.{u3} E) (x n) S) l) -> (Filter.Tendsto.{u2, u1} ι 𝕜 ε l (nhds.{u1} 𝕜 (UniformSpace.toTopologicalSpace.{u1} 𝕜 (PseudoMetricSpace.toUniformSpace.{u1} 𝕜 (SeminormedRing.toPseudoMetricSpace.{u1} 𝕜 (SeminormedCommRing.toSeminormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1)))))) (OfNat.ofNat.{u1} 𝕜 0 (Zero.toOfNat0.{u1} 𝕜 (CommMonoidWithZero.toZero.{u1} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u1} 𝕜 (Semifield.toCommGroupWithZero.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))))))) -> (Filter.Tendsto.{u2, u3} ι E (HSMul.hSMul.{max u1 u2, max u3 u2, max u3 u2} (ι -> 𝕜) (ι -> E) (ι -> E) (instHSMul.{max u1 u2, max u3 u2} (ι -> 𝕜) (ι -> E) (Pi.smul'.{u2, u1, u3} ι (fun (a._@.Mathlib.Analysis.LocallyConvex.Bounded._hyg.1071 : ι) => 𝕜) (fun (a._@.Mathlib.Analysis.LocallyConvex.Bounded._hyg.1074 : ι) => E) (fun (i : ι) => SMulZeroClass.toSMul.{u1, u3} 𝕜 E (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_3))))) (SMulWithZero.toSMulZeroClass.{u1, u3} 𝕜 E (CommMonoidWithZero.toZero.{u1} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u1} 𝕜 (Semifield.toCommGroupWithZero.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_3))))) (MulActionWithZero.toSMulWithZero.{u1, u3} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_3))))) (Module.toMulActionWithZero.{u1, u3} 𝕜 E (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1)))) (AddCommGroup.toAddCommMonoid.{u3} E _inst_3) _inst_4)))))) ε x) l (nhds.{u3} E _inst_6 (OfNat.ofNat.{u3} E 0 (Zero.toOfNat0.{u3} E (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_3)))))))))
Case conversion may be inaccurate. Consider using '#align bornology.is_vonN_bounded.smul_tendsto_zero Bornology.IsVonNBounded.smul_tendsto_zeroₓ'. -/
theorem IsVonNBounded.smul_tendsto_zero {S : Set E} {ε : ι → 𝕜} {x : ι → E} {l : Filter ι}
    (hS : IsVonNBounded 𝕜 S) (hxS : ∀ᶠ n in l, x n ∈ S) (hε : Tendsto ε l (𝓝 0)) :
    Tendsto (ε • x) l (𝓝 0) := by
  rw [tendsto_def] at *
  intro V hV
  rcases hS hV with ⟨r, r_pos, hrS⟩
  filter_upwards [hxS, hε _ (Metric.ball_mem_nhds 0 <| inv_pos.mpr r_pos)]with n hnS hnr
  by_cases this : ε n = 0
  · simp [this, mem_of_mem_nhds hV]
  · rw [mem_preimage, mem_ball_zero_iff, lt_inv (norm_pos_iff.mpr this) r_pos, ← norm_inv] at hnr
    rw [mem_preimage, Pi.smul_apply', ← Set.mem_inv_smul_set_iff₀ this]
    exact hrS _ hnr.le hnS
#align bornology.is_vonN_bounded.smul_tendsto_zero Bornology.IsVonNBounded.smul_tendsto_zero

/- warning: bornology.is_vonN_bounded_of_smul_tendsto_zero -> Bornology.isVonNBounded_of_smul_tendsto_zero is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} {ι : Type.{u2}} {𝕝 : Type.{u3}} [_inst_2 : NontriviallyNormedField.{u3} 𝕝] [_inst_3 : AddCommGroup.{u1} E] [_inst_5 : Module.{u3, u1} 𝕝 E (Ring.toSemiring.{u3} 𝕝 (NormedRing.toRing.{u3} 𝕝 (NormedCommRing.toNormedRing.{u3} 𝕝 (NormedField.toNormedCommRing.{u3} 𝕝 (NontriviallyNormedField.toNormedField.{u3} 𝕝 _inst_2))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_3)] [_inst_6 : TopologicalSpace.{u1} E] [_inst_7 : ContinuousSMul.{u3, u1} 𝕝 E (SMulZeroClass.toHasSmul.{u3, u1} 𝕝 E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_3)))) (SMulWithZero.toSmulZeroClass.{u3, u1} 𝕝 E (MulZeroClass.toHasZero.{u3} 𝕝 (MulZeroOneClass.toMulZeroClass.{u3} 𝕝 (MonoidWithZero.toMulZeroOneClass.{u3} 𝕝 (Semiring.toMonoidWithZero.{u3} 𝕝 (Ring.toSemiring.{u3} 𝕝 (NormedRing.toRing.{u3} 𝕝 (NormedCommRing.toNormedRing.{u3} 𝕝 (NormedField.toNormedCommRing.{u3} 𝕝 (NontriviallyNormedField.toNormedField.{u3} 𝕝 _inst_2))))))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_3)))) (MulActionWithZero.toSMulWithZero.{u3, u1} 𝕝 E (Semiring.toMonoidWithZero.{u3} 𝕝 (Ring.toSemiring.{u3} 𝕝 (NormedRing.toRing.{u3} 𝕝 (NormedCommRing.toNormedRing.{u3} 𝕝 (NormedField.toNormedCommRing.{u3} 𝕝 (NontriviallyNormedField.toNormedField.{u3} 𝕝 _inst_2)))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_3)))) (Module.toMulActionWithZero.{u3, u1} 𝕝 E (Ring.toSemiring.{u3} 𝕝 (NormedRing.toRing.{u3} 𝕝 (NormedCommRing.toNormedRing.{u3} 𝕝 (NormedField.toNormedCommRing.{u3} 𝕝 (NontriviallyNormedField.toNormedField.{u3} 𝕝 _inst_2))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_3) _inst_5)))) (UniformSpace.toTopologicalSpace.{u3} 𝕝 (PseudoMetricSpace.toUniformSpace.{u3} 𝕝 (SeminormedRing.toPseudoMetricSpace.{u3} 𝕝 (SeminormedCommRing.toSemiNormedRing.{u3} 𝕝 (NormedCommRing.toSeminormedCommRing.{u3} 𝕝 (NormedField.toNormedCommRing.{u3} 𝕝 (NontriviallyNormedField.toNormedField.{u3} 𝕝 _inst_2))))))) _inst_6] {ε : ι -> 𝕝} {l : Filter.{u2} ι} [_inst_8 : Filter.NeBot.{u2} ι l], (Filter.Eventually.{u2} ι (fun (n : ι) => Ne.{succ u3} 𝕝 (ε n) (OfNat.ofNat.{u3} 𝕝 0 (OfNat.mk.{u3} 𝕝 0 (Zero.zero.{u3} 𝕝 (MulZeroClass.toHasZero.{u3} 𝕝 (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} 𝕝 (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} 𝕝 (NonAssocRing.toNonUnitalNonAssocRing.{u3} 𝕝 (Ring.toNonAssocRing.{u3} 𝕝 (NormedRing.toRing.{u3} 𝕝 (NormedCommRing.toNormedRing.{u3} 𝕝 (NormedField.toNormedCommRing.{u3} 𝕝 (NontriviallyNormedField.toNormedField.{u3} 𝕝 _inst_2))))))))))))) l) -> (forall {S : Set.{u1} E}, (forall (x : ι -> E), (forall (n : ι), Membership.Mem.{u1, u1} E (Set.{u1} E) (Set.hasMem.{u1} E) (x n) S) -> (Filter.Tendsto.{u2, u1} ι E (SMul.smul.{max u2 u3, max u2 u1} (ι -> 𝕝) (ι -> E) (Pi.smul'.{u2, u3, u1} ι (fun (ᾰ : ι) => 𝕝) (fun (ᾰ : ι) => E) (fun (i : ι) => SMulZeroClass.toHasSmul.{u3, u1} 𝕝 E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_3)))) (SMulWithZero.toSmulZeroClass.{u3, u1} 𝕝 E (MulZeroClass.toHasZero.{u3} 𝕝 (MulZeroOneClass.toMulZeroClass.{u3} 𝕝 (MonoidWithZero.toMulZeroOneClass.{u3} 𝕝 (Semiring.toMonoidWithZero.{u3} 𝕝 (Ring.toSemiring.{u3} 𝕝 (NormedRing.toRing.{u3} 𝕝 (NormedCommRing.toNormedRing.{u3} 𝕝 (NormedField.toNormedCommRing.{u3} 𝕝 (NontriviallyNormedField.toNormedField.{u3} 𝕝 _inst_2))))))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_3)))) (MulActionWithZero.toSMulWithZero.{u3, u1} 𝕝 E (Semiring.toMonoidWithZero.{u3} 𝕝 (Ring.toSemiring.{u3} 𝕝 (NormedRing.toRing.{u3} 𝕝 (NormedCommRing.toNormedRing.{u3} 𝕝 (NormedField.toNormedCommRing.{u3} 𝕝 (NontriviallyNormedField.toNormedField.{u3} 𝕝 _inst_2)))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_3)))) (Module.toMulActionWithZero.{u3, u1} 𝕝 E (Ring.toSemiring.{u3} 𝕝 (NormedRing.toRing.{u3} 𝕝 (NormedCommRing.toNormedRing.{u3} 𝕝 (NormedField.toNormedCommRing.{u3} 𝕝 (NontriviallyNormedField.toNormedField.{u3} 𝕝 _inst_2))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_3) _inst_5))))) ε x) l (nhds.{u1} E _inst_6 (OfNat.ofNat.{u1} E 0 (OfNat.mk.{u1} E 0 (Zero.zero.{u1} E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_3))))))))))) -> (Bornology.IsVonNBounded.{u3, u1} 𝕝 E (SeminormedCommRing.toSemiNormedRing.{u3} 𝕝 (NormedCommRing.toSeminormedCommRing.{u3} 𝕝 (NormedField.toNormedCommRing.{u3} 𝕝 (NontriviallyNormedField.toNormedField.{u3} 𝕝 _inst_2)))) (SMulZeroClass.toHasSmul.{u3, u1} 𝕝 E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_3)))) (SMulWithZero.toSmulZeroClass.{u3, u1} 𝕝 E (MulZeroClass.toHasZero.{u3} 𝕝 (MulZeroOneClass.toMulZeroClass.{u3} 𝕝 (MonoidWithZero.toMulZeroOneClass.{u3} 𝕝 (Semiring.toMonoidWithZero.{u3} 𝕝 (Ring.toSemiring.{u3} 𝕝 (NormedRing.toRing.{u3} 𝕝 (NormedCommRing.toNormedRing.{u3} 𝕝 (NormedField.toNormedCommRing.{u3} 𝕝 (NontriviallyNormedField.toNormedField.{u3} 𝕝 _inst_2))))))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_3)))) (MulActionWithZero.toSMulWithZero.{u3, u1} 𝕝 E (Semiring.toMonoidWithZero.{u3} 𝕝 (Ring.toSemiring.{u3} 𝕝 (NormedRing.toRing.{u3} 𝕝 (NormedCommRing.toNormedRing.{u3} 𝕝 (NormedField.toNormedCommRing.{u3} 𝕝 (NontriviallyNormedField.toNormedField.{u3} 𝕝 _inst_2)))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_3)))) (Module.toMulActionWithZero.{u3, u1} 𝕝 E (Ring.toSemiring.{u3} 𝕝 (NormedRing.toRing.{u3} 𝕝 (NormedCommRing.toNormedRing.{u3} 𝕝 (NormedField.toNormedCommRing.{u3} 𝕝 (NontriviallyNormedField.toNormedField.{u3} 𝕝 _inst_2))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_3) _inst_5)))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_3))))) _inst_6 S))
but is expected to have type
  forall {E : Type.{u1}} {ι : Type.{u3}} {𝕝 : Type.{u2}} [_inst_2 : NontriviallyNormedField.{u2} 𝕝] [_inst_3 : AddCommGroup.{u1} E] [_inst_5 : Module.{u2, u1} 𝕝 E (DivisionSemiring.toSemiring.{u2} 𝕝 (Semifield.toDivisionSemiring.{u2} 𝕝 (Field.toSemifield.{u2} 𝕝 (NormedField.toField.{u2} 𝕝 (NontriviallyNormedField.toNormedField.{u2} 𝕝 _inst_2))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_3)] [_inst_6 : TopologicalSpace.{u1} E] [_inst_7 : ContinuousSMul.{u2, u1} 𝕝 E (SMulZeroClass.toSMul.{u2, u1} 𝕝 E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_3))))) (SMulWithZero.toSMulZeroClass.{u2, u1} 𝕝 E (CommMonoidWithZero.toZero.{u2} 𝕝 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕝 (Semifield.toCommGroupWithZero.{u2} 𝕝 (Field.toSemifield.{u2} 𝕝 (NormedField.toField.{u2} 𝕝 (NontriviallyNormedField.toNormedField.{u2} 𝕝 _inst_2)))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_3))))) (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕝 E (Semiring.toMonoidWithZero.{u2} 𝕝 (DivisionSemiring.toSemiring.{u2} 𝕝 (Semifield.toDivisionSemiring.{u2} 𝕝 (Field.toSemifield.{u2} 𝕝 (NormedField.toField.{u2} 𝕝 (NontriviallyNormedField.toNormedField.{u2} 𝕝 _inst_2)))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_3))))) (Module.toMulActionWithZero.{u2, u1} 𝕝 E (DivisionSemiring.toSemiring.{u2} 𝕝 (Semifield.toDivisionSemiring.{u2} 𝕝 (Field.toSemifield.{u2} 𝕝 (NormedField.toField.{u2} 𝕝 (NontriviallyNormedField.toNormedField.{u2} 𝕝 _inst_2))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_3) _inst_5)))) (UniformSpace.toTopologicalSpace.{u2} 𝕝 (PseudoMetricSpace.toUniformSpace.{u2} 𝕝 (SeminormedRing.toPseudoMetricSpace.{u2} 𝕝 (SeminormedCommRing.toSeminormedRing.{u2} 𝕝 (NormedCommRing.toSeminormedCommRing.{u2} 𝕝 (NormedField.toNormedCommRing.{u2} 𝕝 (NontriviallyNormedField.toNormedField.{u2} 𝕝 _inst_2))))))) _inst_6] {ε : ι -> 𝕝} {l : Filter.{u3} ι} [_inst_8 : Filter.NeBot.{u3} ι l], (Filter.Eventually.{u3} ι (fun (n : ι) => Ne.{succ u2} 𝕝 (ε n) (OfNat.ofNat.{u2} 𝕝 0 (Zero.toOfNat0.{u2} 𝕝 (CommMonoidWithZero.toZero.{u2} 𝕝 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕝 (Semifield.toCommGroupWithZero.{u2} 𝕝 (Field.toSemifield.{u2} 𝕝 (NormedField.toField.{u2} 𝕝 (NontriviallyNormedField.toNormedField.{u2} 𝕝 _inst_2))))))))) l) -> (forall {S : Set.{u1} E}, (forall (x : ι -> E), (forall (n : ι), Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) (x n) S) -> (Filter.Tendsto.{u3, u1} ι E (HSMul.hSMul.{max u3 u2, max u1 u3, max u1 u3} (ι -> 𝕝) (ι -> E) (ι -> E) (instHSMul.{max u3 u2, max u1 u3} (ι -> 𝕝) (ι -> E) (Pi.smul'.{u3, u2, u1} ι (fun (a._@.Mathlib.Analysis.LocallyConvex.Bounded._hyg.1362 : ι) => 𝕝) (fun (a._@.Mathlib.Analysis.LocallyConvex.Bounded._hyg.1398 : ι) => E) (fun (i : ι) => SMulZeroClass.toSMul.{u2, u1} 𝕝 E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_3))))) (SMulWithZero.toSMulZeroClass.{u2, u1} 𝕝 E (CommMonoidWithZero.toZero.{u2} 𝕝 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕝 (Semifield.toCommGroupWithZero.{u2} 𝕝 (Field.toSemifield.{u2} 𝕝 (NormedField.toField.{u2} 𝕝 (NontriviallyNormedField.toNormedField.{u2} 𝕝 _inst_2)))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_3))))) (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕝 E (Semiring.toMonoidWithZero.{u2} 𝕝 (DivisionSemiring.toSemiring.{u2} 𝕝 (Semifield.toDivisionSemiring.{u2} 𝕝 (Field.toSemifield.{u2} 𝕝 (NormedField.toField.{u2} 𝕝 (NontriviallyNormedField.toNormedField.{u2} 𝕝 _inst_2)))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_3))))) (Module.toMulActionWithZero.{u2, u1} 𝕝 E (DivisionSemiring.toSemiring.{u2} 𝕝 (Semifield.toDivisionSemiring.{u2} 𝕝 (Field.toSemifield.{u2} 𝕝 (NormedField.toField.{u2} 𝕝 (NontriviallyNormedField.toNormedField.{u2} 𝕝 _inst_2))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_3) _inst_5)))))) ε x) l (nhds.{u1} E _inst_6 (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_3)))))))))) -> (Bornology.IsVonNBounded.{u2, u1} 𝕝 E (SeminormedCommRing.toSeminormedRing.{u2} 𝕝 (NormedCommRing.toSeminormedCommRing.{u2} 𝕝 (NormedField.toNormedCommRing.{u2} 𝕝 (NontriviallyNormedField.toNormedField.{u2} 𝕝 _inst_2)))) (SMulZeroClass.toSMul.{u2, u1} 𝕝 E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_3))))) (SMulWithZero.toSMulZeroClass.{u2, u1} 𝕝 E (CommMonoidWithZero.toZero.{u2} 𝕝 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕝 (Semifield.toCommGroupWithZero.{u2} 𝕝 (Field.toSemifield.{u2} 𝕝 (NormedField.toField.{u2} 𝕝 (NontriviallyNormedField.toNormedField.{u2} 𝕝 _inst_2)))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_3))))) (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕝 E (Semiring.toMonoidWithZero.{u2} 𝕝 (DivisionSemiring.toSemiring.{u2} 𝕝 (Semifield.toDivisionSemiring.{u2} 𝕝 (Field.toSemifield.{u2} 𝕝 (NormedField.toField.{u2} 𝕝 (NontriviallyNormedField.toNormedField.{u2} 𝕝 _inst_2)))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_3))))) (Module.toMulActionWithZero.{u2, u1} 𝕝 E (DivisionSemiring.toSemiring.{u2} 𝕝 (Semifield.toDivisionSemiring.{u2} 𝕝 (Field.toSemifield.{u2} 𝕝 (NormedField.toField.{u2} 𝕝 (NontriviallyNormedField.toNormedField.{u2} 𝕝 _inst_2))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_3) _inst_5)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_3))))) _inst_6 S))
Case conversion may be inaccurate. Consider using '#align bornology.is_vonN_bounded_of_smul_tendsto_zero Bornology.isVonNBounded_of_smul_tendsto_zeroₓ'. -/
theorem isVonNBounded_of_smul_tendsto_zero {ε : ι → 𝕝} {l : Filter ι} [l.ne_bot]
    (hε : ∀ᶠ n in l, ε n ≠ 0) {S : Set E}
    (H : ∀ x : ι → E, (∀ n, x n ∈ S) → Tendsto (ε • x) l (𝓝 0)) : IsVonNBounded 𝕝 S :=
  by
  rw [(nhds_basis_balanced 𝕝 E).isVonNBounded_basis_iff]
  by_contra' H'
  rcases H' with ⟨V, ⟨hV, hVb⟩, hVS⟩
  have : ∀ᶠ n in l, ∃ x : S, ε n • (x : E) ∉ V :=
    by
    filter_upwards [hε]with n hn
    rw [Absorbs] at hVS
    push_neg  at hVS
    rcases hVS _ (norm_pos_iff.mpr <| inv_ne_zero hn) with ⟨a, haε, haS⟩
    rcases set.not_subset.mp haS with ⟨x, hxS, hx⟩
    refine' ⟨⟨x, hxS⟩, fun hnx => _⟩
    rw [← Set.mem_inv_smul_set_iff₀ hn] at hnx
    exact hx (hVb.smul_mono haε hnx)
  rcases this.choice with ⟨x, hx⟩
  refine' Filter.frequently_false l (Filter.Eventually.frequently _)
  filter_upwards [hx,
    (H (coe ∘ x) fun n => (x n).2).Eventually (eventually_mem_set.mpr hV)]using fun n => id
#align bornology.is_vonN_bounded_of_smul_tendsto_zero Bornology.isVonNBounded_of_smul_tendsto_zero

/- warning: bornology.is_vonN_bounded_iff_smul_tendsto_zero -> Bornology.isVonNBounded_iff_smul_tendsto_zero is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} {ι : Type.{u2}} {𝕝 : Type.{u3}} [_inst_2 : NontriviallyNormedField.{u3} 𝕝] [_inst_3 : AddCommGroup.{u1} E] [_inst_5 : Module.{u3, u1} 𝕝 E (Ring.toSemiring.{u3} 𝕝 (NormedRing.toRing.{u3} 𝕝 (NormedCommRing.toNormedRing.{u3} 𝕝 (NormedField.toNormedCommRing.{u3} 𝕝 (NontriviallyNormedField.toNormedField.{u3} 𝕝 _inst_2))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_3)] [_inst_6 : TopologicalSpace.{u1} E] [_inst_7 : ContinuousSMul.{u3, u1} 𝕝 E (SMulZeroClass.toHasSmul.{u3, u1} 𝕝 E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_3)))) (SMulWithZero.toSmulZeroClass.{u3, u1} 𝕝 E (MulZeroClass.toHasZero.{u3} 𝕝 (MulZeroOneClass.toMulZeroClass.{u3} 𝕝 (MonoidWithZero.toMulZeroOneClass.{u3} 𝕝 (Semiring.toMonoidWithZero.{u3} 𝕝 (Ring.toSemiring.{u3} 𝕝 (NormedRing.toRing.{u3} 𝕝 (NormedCommRing.toNormedRing.{u3} 𝕝 (NormedField.toNormedCommRing.{u3} 𝕝 (NontriviallyNormedField.toNormedField.{u3} 𝕝 _inst_2))))))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_3)))) (MulActionWithZero.toSMulWithZero.{u3, u1} 𝕝 E (Semiring.toMonoidWithZero.{u3} 𝕝 (Ring.toSemiring.{u3} 𝕝 (NormedRing.toRing.{u3} 𝕝 (NormedCommRing.toNormedRing.{u3} 𝕝 (NormedField.toNormedCommRing.{u3} 𝕝 (NontriviallyNormedField.toNormedField.{u3} 𝕝 _inst_2)))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_3)))) (Module.toMulActionWithZero.{u3, u1} 𝕝 E (Ring.toSemiring.{u3} 𝕝 (NormedRing.toRing.{u3} 𝕝 (NormedCommRing.toNormedRing.{u3} 𝕝 (NormedField.toNormedCommRing.{u3} 𝕝 (NontriviallyNormedField.toNormedField.{u3} 𝕝 _inst_2))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_3) _inst_5)))) (UniformSpace.toTopologicalSpace.{u3} 𝕝 (PseudoMetricSpace.toUniformSpace.{u3} 𝕝 (SeminormedRing.toPseudoMetricSpace.{u3} 𝕝 (SeminormedCommRing.toSemiNormedRing.{u3} 𝕝 (NormedCommRing.toSeminormedCommRing.{u3} 𝕝 (NormedField.toNormedCommRing.{u3} 𝕝 (NontriviallyNormedField.toNormedField.{u3} 𝕝 _inst_2))))))) _inst_6] {ε : ι -> 𝕝} {l : Filter.{u2} ι} [_inst_8 : Filter.NeBot.{u2} ι l], (Filter.Tendsto.{u2, u3} ι 𝕝 ε l (nhdsWithin.{u3} 𝕝 (UniformSpace.toTopologicalSpace.{u3} 𝕝 (PseudoMetricSpace.toUniformSpace.{u3} 𝕝 (SeminormedRing.toPseudoMetricSpace.{u3} 𝕝 (SeminormedCommRing.toSemiNormedRing.{u3} 𝕝 (NormedCommRing.toSeminormedCommRing.{u3} 𝕝 (NormedField.toNormedCommRing.{u3} 𝕝 (NontriviallyNormedField.toNormedField.{u3} 𝕝 _inst_2))))))) (OfNat.ofNat.{u3} 𝕝 0 (OfNat.mk.{u3} 𝕝 0 (Zero.zero.{u3} 𝕝 (MulZeroClass.toHasZero.{u3} 𝕝 (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} 𝕝 (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} 𝕝 (NonAssocRing.toNonUnitalNonAssocRing.{u3} 𝕝 (Ring.toNonAssocRing.{u3} 𝕝 (NormedRing.toRing.{u3} 𝕝 (NormedCommRing.toNormedRing.{u3} 𝕝 (NormedField.toNormedCommRing.{u3} 𝕝 (NontriviallyNormedField.toNormedField.{u3} 𝕝 _inst_2)))))))))))) (HasCompl.compl.{u3} (Set.{u3} 𝕝) (BooleanAlgebra.toHasCompl.{u3} (Set.{u3} 𝕝) (Set.booleanAlgebra.{u3} 𝕝)) (Singleton.singleton.{u3, u3} 𝕝 (Set.{u3} 𝕝) (Set.hasSingleton.{u3} 𝕝) (OfNat.ofNat.{u3} 𝕝 0 (OfNat.mk.{u3} 𝕝 0 (Zero.zero.{u3} 𝕝 (MulZeroClass.toHasZero.{u3} 𝕝 (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} 𝕝 (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} 𝕝 (NonAssocRing.toNonUnitalNonAssocRing.{u3} 𝕝 (Ring.toNonAssocRing.{u3} 𝕝 (NormedRing.toRing.{u3} 𝕝 (NormedCommRing.toNormedRing.{u3} 𝕝 (NormedField.toNormedCommRing.{u3} 𝕝 (NontriviallyNormedField.toNormedField.{u3} 𝕝 _inst_2)))))))))))))))) -> (forall {S : Set.{u1} E}, Iff (Bornology.IsVonNBounded.{u3, u1} 𝕝 E (SeminormedCommRing.toSemiNormedRing.{u3} 𝕝 (NormedCommRing.toSeminormedCommRing.{u3} 𝕝 (NormedField.toNormedCommRing.{u3} 𝕝 (NontriviallyNormedField.toNormedField.{u3} 𝕝 _inst_2)))) (SMulZeroClass.toHasSmul.{u3, u1} 𝕝 E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_3)))) (SMulWithZero.toSmulZeroClass.{u3, u1} 𝕝 E (MulZeroClass.toHasZero.{u3} 𝕝 (MulZeroOneClass.toMulZeroClass.{u3} 𝕝 (MonoidWithZero.toMulZeroOneClass.{u3} 𝕝 (Semiring.toMonoidWithZero.{u3} 𝕝 (Ring.toSemiring.{u3} 𝕝 (NormedRing.toRing.{u3} 𝕝 (NormedCommRing.toNormedRing.{u3} 𝕝 (NormedField.toNormedCommRing.{u3} 𝕝 (NontriviallyNormedField.toNormedField.{u3} 𝕝 _inst_2))))))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_3)))) (MulActionWithZero.toSMulWithZero.{u3, u1} 𝕝 E (Semiring.toMonoidWithZero.{u3} 𝕝 (Ring.toSemiring.{u3} 𝕝 (NormedRing.toRing.{u3} 𝕝 (NormedCommRing.toNormedRing.{u3} 𝕝 (NormedField.toNormedCommRing.{u3} 𝕝 (NontriviallyNormedField.toNormedField.{u3} 𝕝 _inst_2)))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_3)))) (Module.toMulActionWithZero.{u3, u1} 𝕝 E (Ring.toSemiring.{u3} 𝕝 (NormedRing.toRing.{u3} 𝕝 (NormedCommRing.toNormedRing.{u3} 𝕝 (NormedField.toNormedCommRing.{u3} 𝕝 (NontriviallyNormedField.toNormedField.{u3} 𝕝 _inst_2))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_3) _inst_5)))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_3))))) _inst_6 S) (forall (x : ι -> E), (forall (n : ι), Membership.Mem.{u1, u1} E (Set.{u1} E) (Set.hasMem.{u1} E) (x n) S) -> (Filter.Tendsto.{u2, u1} ι E (SMul.smul.{max u2 u3, max u2 u1} (ι -> 𝕝) (ι -> E) (Pi.smul'.{u2, u3, u1} ι (fun (ᾰ : ι) => 𝕝) (fun (ᾰ : ι) => E) (fun (i : ι) => SMulZeroClass.toHasSmul.{u3, u1} 𝕝 E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_3)))) (SMulWithZero.toSmulZeroClass.{u3, u1} 𝕝 E (MulZeroClass.toHasZero.{u3} 𝕝 (MulZeroOneClass.toMulZeroClass.{u3} 𝕝 (MonoidWithZero.toMulZeroOneClass.{u3} 𝕝 (Semiring.toMonoidWithZero.{u3} 𝕝 (Ring.toSemiring.{u3} 𝕝 (NormedRing.toRing.{u3} 𝕝 (NormedCommRing.toNormedRing.{u3} 𝕝 (NormedField.toNormedCommRing.{u3} 𝕝 (NontriviallyNormedField.toNormedField.{u3} 𝕝 _inst_2))))))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_3)))) (MulActionWithZero.toSMulWithZero.{u3, u1} 𝕝 E (Semiring.toMonoidWithZero.{u3} 𝕝 (Ring.toSemiring.{u3} 𝕝 (NormedRing.toRing.{u3} 𝕝 (NormedCommRing.toNormedRing.{u3} 𝕝 (NormedField.toNormedCommRing.{u3} 𝕝 (NontriviallyNormedField.toNormedField.{u3} 𝕝 _inst_2)))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_3)))) (Module.toMulActionWithZero.{u3, u1} 𝕝 E (Ring.toSemiring.{u3} 𝕝 (NormedRing.toRing.{u3} 𝕝 (NormedCommRing.toNormedRing.{u3} 𝕝 (NormedField.toNormedCommRing.{u3} 𝕝 (NontriviallyNormedField.toNormedField.{u3} 𝕝 _inst_2))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_3) _inst_5))))) ε x) l (nhds.{u1} E _inst_6 (OfNat.ofNat.{u1} E 0 (OfNat.mk.{u1} E 0 (Zero.zero.{u1} E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_3))))))))))))
but is expected to have type
  forall {E : Type.{u1}} {ι : Type.{u3}} {𝕝 : Type.{u2}} [_inst_2 : NontriviallyNormedField.{u2} 𝕝] [_inst_3 : AddCommGroup.{u1} E] [_inst_5 : Module.{u2, u1} 𝕝 E (DivisionSemiring.toSemiring.{u2} 𝕝 (Semifield.toDivisionSemiring.{u2} 𝕝 (Field.toSemifield.{u2} 𝕝 (NormedField.toField.{u2} 𝕝 (NontriviallyNormedField.toNormedField.{u2} 𝕝 _inst_2))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_3)] [_inst_6 : TopologicalSpace.{u1} E] [_inst_7 : ContinuousSMul.{u2, u1} 𝕝 E (SMulZeroClass.toSMul.{u2, u1} 𝕝 E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_3))))) (SMulWithZero.toSMulZeroClass.{u2, u1} 𝕝 E (CommMonoidWithZero.toZero.{u2} 𝕝 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕝 (Semifield.toCommGroupWithZero.{u2} 𝕝 (Field.toSemifield.{u2} 𝕝 (NormedField.toField.{u2} 𝕝 (NontriviallyNormedField.toNormedField.{u2} 𝕝 _inst_2)))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_3))))) (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕝 E (Semiring.toMonoidWithZero.{u2} 𝕝 (DivisionSemiring.toSemiring.{u2} 𝕝 (Semifield.toDivisionSemiring.{u2} 𝕝 (Field.toSemifield.{u2} 𝕝 (NormedField.toField.{u2} 𝕝 (NontriviallyNormedField.toNormedField.{u2} 𝕝 _inst_2)))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_3))))) (Module.toMulActionWithZero.{u2, u1} 𝕝 E (DivisionSemiring.toSemiring.{u2} 𝕝 (Semifield.toDivisionSemiring.{u2} 𝕝 (Field.toSemifield.{u2} 𝕝 (NormedField.toField.{u2} 𝕝 (NontriviallyNormedField.toNormedField.{u2} 𝕝 _inst_2))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_3) _inst_5)))) (UniformSpace.toTopologicalSpace.{u2} 𝕝 (PseudoMetricSpace.toUniformSpace.{u2} 𝕝 (SeminormedRing.toPseudoMetricSpace.{u2} 𝕝 (SeminormedCommRing.toSeminormedRing.{u2} 𝕝 (NormedCommRing.toSeminormedCommRing.{u2} 𝕝 (NormedField.toNormedCommRing.{u2} 𝕝 (NontriviallyNormedField.toNormedField.{u2} 𝕝 _inst_2))))))) _inst_6] {ε : ι -> 𝕝} {l : Filter.{u3} ι} [_inst_8 : Filter.NeBot.{u3} ι l], (Filter.Tendsto.{u3, u2} ι 𝕝 ε l (nhdsWithin.{u2} 𝕝 (UniformSpace.toTopologicalSpace.{u2} 𝕝 (PseudoMetricSpace.toUniformSpace.{u2} 𝕝 (SeminormedRing.toPseudoMetricSpace.{u2} 𝕝 (SeminormedCommRing.toSeminormedRing.{u2} 𝕝 (NormedCommRing.toSeminormedCommRing.{u2} 𝕝 (NormedField.toNormedCommRing.{u2} 𝕝 (NontriviallyNormedField.toNormedField.{u2} 𝕝 _inst_2))))))) (OfNat.ofNat.{u2} 𝕝 0 (Zero.toOfNat0.{u2} 𝕝 (CommMonoidWithZero.toZero.{u2} 𝕝 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕝 (Semifield.toCommGroupWithZero.{u2} 𝕝 (Field.toSemifield.{u2} 𝕝 (NormedField.toField.{u2} 𝕝 (NontriviallyNormedField.toNormedField.{u2} 𝕝 _inst_2)))))))) (HasCompl.compl.{u2} (Set.{u2} 𝕝) (BooleanAlgebra.toHasCompl.{u2} (Set.{u2} 𝕝) (Set.instBooleanAlgebraSet.{u2} 𝕝)) (Singleton.singleton.{u2, u2} 𝕝 (Set.{u2} 𝕝) (Set.instSingletonSet.{u2} 𝕝) (OfNat.ofNat.{u2} 𝕝 0 (Zero.toOfNat0.{u2} 𝕝 (CommMonoidWithZero.toZero.{u2} 𝕝 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕝 (Semifield.toCommGroupWithZero.{u2} 𝕝 (Field.toSemifield.{u2} 𝕝 (NormedField.toField.{u2} 𝕝 (NontriviallyNormedField.toNormedField.{u2} 𝕝 _inst_2)))))))))))) -> (forall {S : Set.{u1} E}, Iff (Bornology.IsVonNBounded.{u2, u1} 𝕝 E (SeminormedCommRing.toSeminormedRing.{u2} 𝕝 (NormedCommRing.toSeminormedCommRing.{u2} 𝕝 (NormedField.toNormedCommRing.{u2} 𝕝 (NontriviallyNormedField.toNormedField.{u2} 𝕝 _inst_2)))) (SMulZeroClass.toSMul.{u2, u1} 𝕝 E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_3))))) (SMulWithZero.toSMulZeroClass.{u2, u1} 𝕝 E (CommMonoidWithZero.toZero.{u2} 𝕝 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕝 (Semifield.toCommGroupWithZero.{u2} 𝕝 (Field.toSemifield.{u2} 𝕝 (NormedField.toField.{u2} 𝕝 (NontriviallyNormedField.toNormedField.{u2} 𝕝 _inst_2)))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_3))))) (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕝 E (Semiring.toMonoidWithZero.{u2} 𝕝 (DivisionSemiring.toSemiring.{u2} 𝕝 (Semifield.toDivisionSemiring.{u2} 𝕝 (Field.toSemifield.{u2} 𝕝 (NormedField.toField.{u2} 𝕝 (NontriviallyNormedField.toNormedField.{u2} 𝕝 _inst_2)))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_3))))) (Module.toMulActionWithZero.{u2, u1} 𝕝 E (DivisionSemiring.toSemiring.{u2} 𝕝 (Semifield.toDivisionSemiring.{u2} 𝕝 (Field.toSemifield.{u2} 𝕝 (NormedField.toField.{u2} 𝕝 (NontriviallyNormedField.toNormedField.{u2} 𝕝 _inst_2))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_3) _inst_5)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_3))))) _inst_6 S) (forall (x : ι -> E), (forall (n : ι), Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) (x n) S) -> (Filter.Tendsto.{u3, u1} ι E (HSMul.hSMul.{max u3 u2, max u1 u3, max u1 u3} (ι -> 𝕝) (ι -> E) (ι -> E) (instHSMul.{max u3 u2, max u1 u3} (ι -> 𝕝) (ι -> E) (Pi.smul'.{u3, u2, u1} ι (fun (a._@.Mathlib.Analysis.LocallyConvex.Bounded._hyg.1749 : ι) => 𝕝) (fun (a._@.Mathlib.Analysis.LocallyConvex.Bounded._hyg.3297 : ι) => E) (fun (i : ι) => SMulZeroClass.toSMul.{u2, u1} 𝕝 E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_3))))) (SMulWithZero.toSMulZeroClass.{u2, u1} 𝕝 E (CommMonoidWithZero.toZero.{u2} 𝕝 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕝 (Semifield.toCommGroupWithZero.{u2} 𝕝 (Field.toSemifield.{u2} 𝕝 (NormedField.toField.{u2} 𝕝 (NontriviallyNormedField.toNormedField.{u2} 𝕝 _inst_2)))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_3))))) (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕝 E (Semiring.toMonoidWithZero.{u2} 𝕝 (DivisionSemiring.toSemiring.{u2} 𝕝 (Semifield.toDivisionSemiring.{u2} 𝕝 (Field.toSemifield.{u2} 𝕝 (NormedField.toField.{u2} 𝕝 (NontriviallyNormedField.toNormedField.{u2} 𝕝 _inst_2)))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_3))))) (Module.toMulActionWithZero.{u2, u1} 𝕝 E (DivisionSemiring.toSemiring.{u2} 𝕝 (Semifield.toDivisionSemiring.{u2} 𝕝 (Field.toSemifield.{u2} 𝕝 (NormedField.toField.{u2} 𝕝 (NontriviallyNormedField.toNormedField.{u2} 𝕝 _inst_2))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_3) _inst_5)))))) ε x) l (nhds.{u1} E _inst_6 (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_3)))))))))))
Case conversion may be inaccurate. Consider using '#align bornology.is_vonN_bounded_iff_smul_tendsto_zero Bornology.isVonNBounded_iff_smul_tendsto_zeroₓ'. -/
/-- Given any sequence `ε` of scalars which tends to `𝓝[≠] 0`, we have that a set `S` is bounded
  if and only if for any sequence `x : ℕ → S`, `ε • x` tends to 0. This actually works for any
  indexing type `ι`, but in the special case `ι = ℕ` we get the important fact that convergent
  sequences fully characterize bounded sets. -/
theorem isVonNBounded_iff_smul_tendsto_zero {ε : ι → 𝕝} {l : Filter ι} [l.ne_bot]
    (hε : Tendsto ε l (𝓝[≠] 0)) {S : Set E} :
    IsVonNBounded 𝕝 S ↔ ∀ x : ι → E, (∀ n, x n ∈ S) → Tendsto (ε • x) l (𝓝 0) :=
  ⟨fun hS x hxS => hS.smul_tendsto_zero (eventually_of_forall hxS) (le_trans hε nhdsWithin_le_nhds),
    isVonNBounded_of_smul_tendsto_zero (hε self_mem_nhdsWithin)⟩
#align bornology.is_vonN_bounded_iff_smul_tendsto_zero Bornology.isVonNBounded_iff_smul_tendsto_zero

end sequence

section NormedField

variable [NormedField 𝕜] [AddCommGroup E] [Module 𝕜 E]

variable [TopologicalSpace E] [ContinuousSMul 𝕜 E]

/- warning: bornology.is_vonN_bounded_singleton -> Bornology.isVonNBounded_singleton is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u1}} {E : Type.{u2}} [_inst_1 : NormedField.{u1} 𝕜] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : TopologicalSpace.{u2} E] [_inst_5 : ContinuousSMul.{u1, u2} 𝕜 E (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 E (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (UniformSpace.toTopologicalSpace.{u1} 𝕜 (PseudoMetricSpace.toUniformSpace.{u1} 𝕜 (SeminormedRing.toPseudoMetricSpace.{u1} 𝕜 (SeminormedCommRing.toSemiNormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1)))))) _inst_4] (x : E), Bornology.IsVonNBounded.{u1, u2} 𝕜 E (SeminormedCommRing.toSemiNormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1))) (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 E (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))) _inst_4 (Singleton.singleton.{u2, u2} E (Set.{u2} E) (Set.hasSingleton.{u2} E) x)
but is expected to have type
  forall {𝕜 : Type.{u2}} {E : Type.{u1}} [_inst_1 : NormedField.{u2} 𝕜] [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u2, u1} 𝕜 E (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 (NormedField.toField.{u2} 𝕜 _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] [_inst_4 : TopologicalSpace.{u1} E] [_inst_5 : ContinuousSMul.{u2, u1} 𝕜 E (SMulZeroClass.toSMul.{u2, u1} 𝕜 E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} 𝕜 E (CommMonoidWithZero.toZero.{u2} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕜 (Semifield.toCommGroupWithZero.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 (NormedField.toField.{u2} 𝕜 _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕜 E (Semiring.toMonoidWithZero.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 (NormedField.toField.{u2} 𝕜 _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} 𝕜 E (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 (NormedField.toField.{u2} 𝕜 _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3)))) (UniformSpace.toTopologicalSpace.{u2} 𝕜 (PseudoMetricSpace.toUniformSpace.{u2} 𝕜 (SeminormedRing.toPseudoMetricSpace.{u2} 𝕜 (SeminormedCommRing.toSeminormedRing.{u2} 𝕜 (NormedCommRing.toSeminormedCommRing.{u2} 𝕜 (NormedField.toNormedCommRing.{u2} 𝕜 _inst_1)))))) _inst_4] (x : E), Bornology.IsVonNBounded.{u2, u1} 𝕜 E (SeminormedCommRing.toSeminormedRing.{u2} 𝕜 (NormedCommRing.toSeminormedCommRing.{u2} 𝕜 (NormedField.toNormedCommRing.{u2} 𝕜 _inst_1))) (SMulZeroClass.toSMul.{u2, u1} 𝕜 E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} 𝕜 E (CommMonoidWithZero.toZero.{u2} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕜 (Semifield.toCommGroupWithZero.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 (NormedField.toField.{u2} 𝕜 _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕜 E (Semiring.toMonoidWithZero.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 (NormedField.toField.{u2} 𝕜 _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} 𝕜 E (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 (NormedField.toField.{u2} 𝕜 _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) _inst_4 (Singleton.singleton.{u1, u1} E (Set.{u1} E) (Set.instSingletonSet.{u1} E) x)
Case conversion may be inaccurate. Consider using '#align bornology.is_vonN_bounded_singleton Bornology.isVonNBounded_singletonₓ'. -/
/-- Singletons are bounded. -/
theorem isVonNBounded_singleton (x : E) : IsVonNBounded 𝕜 ({x} : Set E) := fun V hV =>
  (absorbent_nhds_zero hV).Absorbs
#align bornology.is_vonN_bounded_singleton Bornology.isVonNBounded_singleton

/- warning: bornology.is_vonN_bounded_covers -> Bornology.isVonNBounded_covers is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u1}} {E : Type.{u2}} [_inst_1 : NormedField.{u1} 𝕜] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : TopologicalSpace.{u2} E] [_inst_5 : ContinuousSMul.{u1, u2} 𝕜 E (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 E (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (UniformSpace.toTopologicalSpace.{u1} 𝕜 (PseudoMetricSpace.toUniformSpace.{u1} 𝕜 (SeminormedRing.toPseudoMetricSpace.{u1} 𝕜 (SeminormedCommRing.toSemiNormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1)))))) _inst_4], Eq.{succ u2} (Set.{u2} E) (Set.sUnion.{u2} E (setOf.{u2} (Set.{u2} E) (Bornology.IsVonNBounded.{u1, u2} 𝕜 E (SeminormedCommRing.toSemiNormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1))) (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 E (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))) _inst_4))) (Set.univ.{u2} E)
but is expected to have type
  forall {𝕜 : Type.{u1}} {E : Type.{u2}} [_inst_1 : NormedField.{u1} 𝕜] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} 𝕜 E (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : TopologicalSpace.{u2} E] [_inst_5 : ContinuousSMul.{u1, u2} 𝕜 E (SMulZeroClass.toSMul.{u1, u2} 𝕜 E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} 𝕜 E (CommMonoidWithZero.toZero.{u1} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u1} 𝕜 (Semifield.toCommGroupWithZero.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (UniformSpace.toTopologicalSpace.{u1} 𝕜 (PseudoMetricSpace.toUniformSpace.{u1} 𝕜 (SeminormedRing.toPseudoMetricSpace.{u1} 𝕜 (SeminormedCommRing.toSeminormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1)))))) _inst_4], Eq.{succ u2} (Set.{u2} E) (Set.sUnion.{u2} E (setOf.{u2} (Set.{u2} E) (Bornology.IsVonNBounded.{u1, u2} 𝕜 E (SeminormedCommRing.toSeminormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1))) (SMulZeroClass.toSMul.{u1, u2} 𝕜 E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} 𝕜 E (CommMonoidWithZero.toZero.{u1} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u1} 𝕜 (Semifield.toCommGroupWithZero.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) _inst_4))) (Set.univ.{u2} E)
Case conversion may be inaccurate. Consider using '#align bornology.is_vonN_bounded_covers Bornology.isVonNBounded_coversₓ'. -/
/-- The union of all bounded set is the whole space. -/
theorem isVonNBounded_covers : ⋃₀ setOf (IsVonNBounded 𝕜) = (Set.univ : Set E) :=
  Set.eq_univ_iff_forall.mpr fun x =>
    Set.mem_sUnion.mpr ⟨{x}, isVonNBounded_singleton _, Set.mem_singleton _⟩
#align bornology.is_vonN_bounded_covers Bornology.isVonNBounded_covers

variable (𝕜 E)

#print Bornology.vonNBornology /-
-- See note [reducible non-instances]
/-- The von Neumann bornology defined by the von Neumann bounded sets.

Note that this is not registered as an instance, in order to avoid diamonds with the
metric bornology.-/
@[reducible]
def vonNBornology : Bornology E :=
  Bornology.ofBounded (setOf (IsVonNBounded 𝕜)) (isVonNBounded_empty 𝕜 E)
    (fun _ hs _ ht => hs.Subset ht) (fun _ hs _ => hs.union) isVonNBounded_singleton
#align bornology.vonN_bornology Bornology.vonNBornology
-/

variable {E}

/- warning: bornology.is_bounded_iff_is_vonN_bounded -> Bornology.isBounded_iff_isVonNBounded is a dubious translation:
lean 3 declaration is
  forall (𝕜 : Type.{u1}) {E : Type.{u2}} [_inst_1 : NormedField.{u1} 𝕜] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : TopologicalSpace.{u2} E] [_inst_5 : ContinuousSMul.{u1, u2} 𝕜 E (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 E (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (UniformSpace.toTopologicalSpace.{u1} 𝕜 (PseudoMetricSpace.toUniformSpace.{u1} 𝕜 (SeminormedRing.toPseudoMetricSpace.{u1} 𝕜 (SeminormedCommRing.toSemiNormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1)))))) _inst_4] {s : Set.{u2} E}, Iff (Bornology.IsBounded.{u2} E (Bornology.vonNBornology.{u1, u2} 𝕜 E _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) s) (Bornology.IsVonNBounded.{u1, u2} 𝕜 E (SeminormedCommRing.toSemiNormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1))) (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 E (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))) _inst_4 s)
but is expected to have type
  forall (𝕜 : Type.{u1}) {E : Type.{u2}} [_inst_1 : NormedField.{u1} 𝕜] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} 𝕜 E (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : TopologicalSpace.{u2} E] [_inst_5 : ContinuousSMul.{u1, u2} 𝕜 E (SMulZeroClass.toSMul.{u1, u2} 𝕜 E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} 𝕜 E (CommMonoidWithZero.toZero.{u1} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u1} 𝕜 (Semifield.toCommGroupWithZero.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (UniformSpace.toTopologicalSpace.{u1} 𝕜 (PseudoMetricSpace.toUniformSpace.{u1} 𝕜 (SeminormedRing.toPseudoMetricSpace.{u1} 𝕜 (SeminormedCommRing.toSeminormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1)))))) _inst_4] {s : Set.{u2} E}, Iff (Bornology.IsBounded.{u2} E (Bornology.vonNBornology.{u1, u2} 𝕜 E _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) s) (Bornology.IsVonNBounded.{u1, u2} 𝕜 E (SeminormedCommRing.toSeminormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1))) (SMulZeroClass.toSMul.{u1, u2} 𝕜 E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} 𝕜 E (CommMonoidWithZero.toZero.{u1} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u1} 𝕜 (Semifield.toCommGroupWithZero.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) _inst_4 s)
Case conversion may be inaccurate. Consider using '#align bornology.is_bounded_iff_is_vonN_bounded Bornology.isBounded_iff_isVonNBoundedₓ'. -/
@[simp]
theorem isBounded_iff_isVonNBounded {s : Set E} :
    @IsBounded _ (vonNBornology 𝕜 E) s ↔ IsVonNBounded 𝕜 s :=
  isBounded_ofBounded_iff _
#align bornology.is_bounded_iff_is_vonN_bounded Bornology.isBounded_iff_isVonNBounded

end NormedField

end Bornology

section UniformAddGroup

variable (𝕜) [NontriviallyNormedField 𝕜] [AddCommGroup E] [Module 𝕜 E]

variable [UniformSpace E] [UniformAddGroup E] [ContinuousSMul 𝕜 E]

/- warning: totally_bounded.is_vonN_bounded -> TotallyBounded.isVonNBounded is a dubious translation:
lean 3 declaration is
  forall (𝕜 : Type.{u1}) {E : Type.{u2}} [_inst_1 : NontriviallyNormedField.{u1} 𝕜] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : UniformSpace.{u2} E] [_inst_5 : UniformAddGroup.{u2} E _inst_4 (AddCommGroup.toAddGroup.{u2} E _inst_2)] [_inst_6 : ContinuousSMul.{u1, u2} 𝕜 E (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 E (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1))))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (UniformSpace.toTopologicalSpace.{u1} 𝕜 (PseudoMetricSpace.toUniformSpace.{u1} 𝕜 (SeminormedRing.toPseudoMetricSpace.{u1} 𝕜 (SeminormedCommRing.toSemiNormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1))))))) (UniformSpace.toTopologicalSpace.{u2} E _inst_4)] {s : Set.{u2} E}, (TotallyBounded.{u2} E _inst_4 s) -> (Bornology.IsVonNBounded.{u1, u2} 𝕜 E (SeminormedCommRing.toSemiNormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1)))) (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 E (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1))))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))) (UniformSpace.toTopologicalSpace.{u2} E _inst_4) s)
but is expected to have type
  forall (𝕜 : Type.{u1}) {E : Type.{u2}} [_inst_1 : NontriviallyNormedField.{u1} 𝕜] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} 𝕜 E (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : UniformSpace.{u2} E] [_inst_5 : UniformAddGroup.{u2} E _inst_4 (AddCommGroup.toAddGroup.{u2} E _inst_2)] [_inst_6 : ContinuousSMul.{u1, u2} 𝕜 E (SMulZeroClass.toSMul.{u1, u2} 𝕜 E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} 𝕜 E (CommMonoidWithZero.toZero.{u1} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u1} 𝕜 (Semifield.toCommGroupWithZero.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1)))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1)))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (UniformSpace.toTopologicalSpace.{u1} 𝕜 (PseudoMetricSpace.toUniformSpace.{u1} 𝕜 (SeminormedRing.toPseudoMetricSpace.{u1} 𝕜 (SeminormedCommRing.toSeminormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1))))))) (UniformSpace.toTopologicalSpace.{u2} E _inst_4)] {s : Set.{u2} E}, (TotallyBounded.{u2} E _inst_4 s) -> (Bornology.IsVonNBounded.{u1, u2} 𝕜 E (SeminormedCommRing.toSeminormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1)))) (SMulZeroClass.toSMul.{u1, u2} 𝕜 E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} 𝕜 E (CommMonoidWithZero.toZero.{u1} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u1} 𝕜 (Semifield.toCommGroupWithZero.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1)))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1)))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (UniformSpace.toTopologicalSpace.{u2} E _inst_4) s)
Case conversion may be inaccurate. Consider using '#align totally_bounded.is_vonN_bounded TotallyBounded.isVonNBoundedₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
theorem TotallyBounded.isVonNBounded {s : Set E} (hs : TotallyBounded s) :
    Bornology.IsVonNBounded 𝕜 s :=
  by
  rw [totallyBounded_iff_subset_finite_iUnion_nhds_zero] at hs
  intro U hU
  have h : Filter.Tendsto (fun x : E × E => x.fst + x.snd) (𝓝 (0, 0)) (𝓝 ((0 : E) + (0 : E))) :=
    tendsto_add
  rw [add_zero] at h
  have h' := (nhds_basis_balanced 𝕜 E).Prod (nhds_basis_balanced 𝕜 E)
  simp_rw [← nhds_prod_eq, id.def] at h'
  rcases h.basis_left h' U hU with ⟨x, hx, h''⟩
  rcases hs x.snd hx.2.1 with ⟨t, ht, hs⟩
  refine' Absorbs.mono_right _ hs
  rw [ht.absorbs_Union]
  have hx_fstsnd : x.fst + x.snd ⊆ U := by
    intro z hz
    rcases set.mem_add.mp hz with ⟨z1, z2, hz1, hz2, hz⟩
    have hz' : (z1, z2) ∈ x.fst ×ˢ x.snd := ⟨hz1, hz2⟩
    simpa only [hz] using h'' hz'
  refine' fun y hy => Absorbs.mono_left _ hx_fstsnd
  rw [← Set.singleton_vadd, vadd_eq_add]
  exact (absorbent_nhds_zero hx.1.1).Absorbs.add hx.2.2.absorbs_self
#align totally_bounded.is_vonN_bounded TotallyBounded.isVonNBounded

end UniformAddGroup

section VonNBornologyEqMetric

variable (𝕜 E) [NontriviallyNormedField 𝕜] [SeminormedAddCommGroup E] [NormedSpace 𝕜 E]

namespace NormedSpace

/- warning: normed_space.is_vonN_bounded_ball -> NormedSpace.isVonNBounded_ball is a dubious translation:
lean 3 declaration is
  forall (𝕜 : Type.{u1}) (E : Type.{u2}) [_inst_1 : NontriviallyNormedField.{u1} 𝕜] [_inst_2 : SeminormedAddCommGroup.{u2} E] [_inst_3 : NormedSpace.{u1, u2} 𝕜 E (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1) _inst_2] (r : Real), Bornology.IsVonNBounded.{u1, u2} 𝕜 E (SeminormedCommRing.toSemiNormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1)))) (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 E (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1))))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) (NormedSpace.toModule.{u1, u2} 𝕜 E (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1) _inst_2 _inst_3))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (SeminormedAddGroup.toAddGroup.{u2} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E _inst_2)))))) (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2))) (Metric.ball.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2) (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (SeminormedAddGroup.toAddGroup.{u2} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E _inst_2))))))))) r)
but is expected to have type
  forall (𝕜 : Type.{u2}) (E : Type.{u1}) [_inst_1 : NontriviallyNormedField.{u2} 𝕜] [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_3 : NormedSpace.{u2, u1} 𝕜 E (NontriviallyNormedField.toNormedField.{u2} 𝕜 _inst_1) _inst_2] (r : Real), Bornology.IsVonNBounded.{u2, u1} 𝕜 E (SeminormedCommRing.toSeminormedRing.{u2} 𝕜 (NormedCommRing.toSeminormedCommRing.{u2} 𝕜 (NormedField.toNormedCommRing.{u2} 𝕜 (NontriviallyNormedField.toNormedField.{u2} 𝕜 _inst_1)))) (SMulZeroClass.toSMul.{u2, u1} 𝕜 E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u2, u1} 𝕜 E (CommMonoidWithZero.toZero.{u2} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕜 (Semifield.toCommGroupWithZero.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 (NormedField.toField.{u2} 𝕜 (NontriviallyNormedField.toNormedField.{u2} 𝕜 _inst_1)))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕜 E (Semiring.toMonoidWithZero.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 (NormedField.toField.{u2} 𝕜 (NontriviallyNormedField.toNormedField.{u2} 𝕜 _inst_1)))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} 𝕜 E (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 (NormedField.toField.{u2} 𝕜 (NontriviallyNormedField.toNormedField.{u2} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{u2, u1} 𝕜 E (NontriviallyNormedField.toNormedField.{u2} 𝕜 _inst_1) _inst_2 _inst_3))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2))) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))))) r)
Case conversion may be inaccurate. Consider using '#align normed_space.is_vonN_bounded_ball NormedSpace.isVonNBounded_ballₓ'. -/
theorem isVonNBounded_ball (r : ℝ) : Bornology.IsVonNBounded 𝕜 (Metric.ball (0 : E) r) :=
  by
  rw [metric.nhds_basis_ball.is_vonN_bounded_basis_iff, ← ball_normSeminorm 𝕜 E]
  exact fun ε hε => (normSeminorm 𝕜 E).ball_zero_absorbs_ball_zero hε
#align normed_space.is_vonN_bounded_ball NormedSpace.isVonNBounded_ball

/- warning: normed_space.is_vonN_bounded_closed_ball -> NormedSpace.isVonNBounded_closedBall is a dubious translation:
lean 3 declaration is
  forall (𝕜 : Type.{u1}) (E : Type.{u2}) [_inst_1 : NontriviallyNormedField.{u1} 𝕜] [_inst_2 : SeminormedAddCommGroup.{u2} E] [_inst_3 : NormedSpace.{u1, u2} 𝕜 E (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1) _inst_2] (r : Real), Bornology.IsVonNBounded.{u1, u2} 𝕜 E (SeminormedCommRing.toSemiNormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1)))) (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 E (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1))))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) (NormedSpace.toModule.{u1, u2} 𝕜 E (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1) _inst_2 _inst_3))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (SeminormedAddGroup.toAddGroup.{u2} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E _inst_2)))))) (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2))) (Metric.closedBall.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2) (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (SeminormedAddGroup.toAddGroup.{u2} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E _inst_2))))))))) r)
but is expected to have type
  forall (𝕜 : Type.{u2}) (E : Type.{u1}) [_inst_1 : NontriviallyNormedField.{u2} 𝕜] [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_3 : NormedSpace.{u2, u1} 𝕜 E (NontriviallyNormedField.toNormedField.{u2} 𝕜 _inst_1) _inst_2] (r : Real), Bornology.IsVonNBounded.{u2, u1} 𝕜 E (SeminormedCommRing.toSeminormedRing.{u2} 𝕜 (NormedCommRing.toSeminormedCommRing.{u2} 𝕜 (NormedField.toNormedCommRing.{u2} 𝕜 (NontriviallyNormedField.toNormedField.{u2} 𝕜 _inst_1)))) (SMulZeroClass.toSMul.{u2, u1} 𝕜 E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u2, u1} 𝕜 E (CommMonoidWithZero.toZero.{u2} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕜 (Semifield.toCommGroupWithZero.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 (NormedField.toField.{u2} 𝕜 (NontriviallyNormedField.toNormedField.{u2} 𝕜 _inst_1)))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕜 E (Semiring.toMonoidWithZero.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 (NormedField.toField.{u2} 𝕜 (NontriviallyNormedField.toNormedField.{u2} 𝕜 _inst_1)))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} 𝕜 E (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 (NormedField.toField.{u2} 𝕜 (NontriviallyNormedField.toNormedField.{u2} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{u2, u1} 𝕜 E (NontriviallyNormedField.toNormedField.{u2} 𝕜 _inst_1) _inst_2 _inst_3))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2))) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))))) r)
Case conversion may be inaccurate. Consider using '#align normed_space.is_vonN_bounded_closed_ball NormedSpace.isVonNBounded_closedBallₓ'. -/
theorem isVonNBounded_closedBall (r : ℝ) :
    Bornology.IsVonNBounded 𝕜 (Metric.closedBall (0 : E) r) :=
  (isVonNBounded_ball 𝕜 E (r + 1)).Subset (Metric.closedBall_subset_ball <| by linarith)
#align normed_space.is_vonN_bounded_closed_ball NormedSpace.isVonNBounded_closedBall

/- warning: normed_space.is_vonN_bounded_iff -> NormedSpace.isVonNBounded_iff is a dubious translation:
lean 3 declaration is
  forall (𝕜 : Type.{u1}) (E : Type.{u2}) [_inst_1 : NontriviallyNormedField.{u1} 𝕜] [_inst_2 : SeminormedAddCommGroup.{u2} E] [_inst_3 : NormedSpace.{u1, u2} 𝕜 E (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1) _inst_2] (s : Set.{u2} E), Iff (Bornology.IsVonNBounded.{u1, u2} 𝕜 E (SeminormedCommRing.toSemiNormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1)))) (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 E (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1))))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) (NormedSpace.toModule.{u1, u2} 𝕜 E (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1) _inst_2 _inst_3))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (SeminormedAddGroup.toAddGroup.{u2} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E _inst_2)))))) (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2))) s) (Bornology.IsBounded.{u2} E (PseudoMetricSpace.toBornology.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2)) s)
but is expected to have type
  forall (𝕜 : Type.{u1}) (E : Type.{u2}) [_inst_1 : NontriviallyNormedField.{u1} 𝕜] [_inst_2 : SeminormedAddCommGroup.{u2} E] [_inst_3 : NormedSpace.{u1, u2} 𝕜 E (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1) _inst_2] (s : Set.{u2} E), Iff (Bornology.IsVonNBounded.{u1, u2} 𝕜 E (SeminormedCommRing.toSeminormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1)))) (SMulZeroClass.toSMul.{u1, u2} 𝕜 E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u1, u2} 𝕜 E (CommMonoidWithZero.toZero.{u1} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u1} 𝕜 (Semifield.toCommGroupWithZero.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1)))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1)))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) (NormedSpace.toModule.{u1, u2} 𝕜 E (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1) _inst_2 _inst_3))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2))) s) (Bornology.IsBounded.{u2} E (PseudoMetricSpace.toBornology.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2)) s)
Case conversion may be inaccurate. Consider using '#align normed_space.is_vonN_bounded_iff NormedSpace.isVonNBounded_iffₓ'. -/
theorem isVonNBounded_iff (s : Set E) : Bornology.IsVonNBounded 𝕜 s ↔ Bornology.IsBounded s :=
  by
  rw [← Metric.bounded_iff_isBounded, Metric.bounded_iff_subset_ball (0 : E)]
  constructor
  · intro h
    rcases h (Metric.ball_mem_nhds 0 zero_lt_one) with ⟨ρ, hρ, hρball⟩
    rcases NormedField.exists_lt_norm 𝕜 ρ with ⟨a, ha⟩
    specialize hρball a ha.le
    rw [← ball_normSeminorm 𝕜 E, Seminorm.smul_ball_zero (norm_pos_iff.1 <| hρ.trans ha),
      ball_normSeminorm, mul_one] at hρball
    exact ⟨‖a‖, hρball.trans Metric.ball_subset_closedBall⟩
  · exact fun ⟨C, hC⟩ => (is_vonN_bounded_closed_ball 𝕜 E C).Subset hC
#align normed_space.is_vonN_bounded_iff NormedSpace.isVonNBounded_iff

/- warning: normed_space.is_vonN_bounded_iff' -> NormedSpace.isVonNBounded_iff' is a dubious translation:
lean 3 declaration is
  forall (𝕜 : Type.{u1}) (E : Type.{u2}) [_inst_1 : NontriviallyNormedField.{u1} 𝕜] [_inst_2 : SeminormedAddCommGroup.{u2} E] [_inst_3 : NormedSpace.{u1, u2} 𝕜 E (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1) _inst_2] (s : Set.{u2} E), Iff (Bornology.IsVonNBounded.{u1, u2} 𝕜 E (SeminormedCommRing.toSemiNormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1)))) (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 E (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1))))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) (NormedSpace.toModule.{u1, u2} 𝕜 E (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1) _inst_2 _inst_3))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (SeminormedAddGroup.toAddGroup.{u2} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E _inst_2)))))) (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2))) s) (Exists.{1} Real (fun (r : Real) => forall (x : E), (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x s) -> (LE.le.{0} Real Real.hasLe (Norm.norm.{u2} E (SeminormedAddCommGroup.toHasNorm.{u2} E _inst_2) x) r)))
but is expected to have type
  forall (𝕜 : Type.{u1}) (E : Type.{u2}) [_inst_1 : NontriviallyNormedField.{u1} 𝕜] [_inst_2 : SeminormedAddCommGroup.{u2} E] [_inst_3 : NormedSpace.{u1, u2} 𝕜 E (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1) _inst_2] (s : Set.{u2} E), Iff (Bornology.IsVonNBounded.{u1, u2} 𝕜 E (SeminormedCommRing.toSeminormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1)))) (SMulZeroClass.toSMul.{u1, u2} 𝕜 E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u1, u2} 𝕜 E (CommMonoidWithZero.toZero.{u1} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u1} 𝕜 (Semifield.toCommGroupWithZero.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1)))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1)))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) (NormedSpace.toModule.{u1, u2} 𝕜 E (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1) _inst_2 _inst_3))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2))) s) (Exists.{1} Real (fun (r : Real) => forall (x : E), (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x s) -> (LE.le.{0} Real Real.instLEReal (Norm.norm.{u2} E (SeminormedAddCommGroup.toNorm.{u2} E _inst_2) x) r)))
Case conversion may be inaccurate. Consider using '#align normed_space.is_vonN_bounded_iff' NormedSpace.isVonNBounded_iff'ₓ'. -/
theorem isVonNBounded_iff' (s : Set E) :
    Bornology.IsVonNBounded 𝕜 s ↔ ∃ r : ℝ, ∀ (x : E) (hx : x ∈ s), ‖x‖ ≤ r := by
  rw [NormedSpace.isVonNBounded_iff, ← Metric.bounded_iff_isBounded, bounded_iff_forall_norm_le]
#align normed_space.is_vonN_bounded_iff' NormedSpace.isVonNBounded_iff'

/- warning: normed_space.image_is_vonN_bounded_iff -> NormedSpace.image_isVonNBounded_iff is a dubious translation:
lean 3 declaration is
  forall (𝕜 : Type.{u1}) (E : Type.{u2}) {E' : Type.{u3}} [_inst_1 : NontriviallyNormedField.{u1} 𝕜] [_inst_2 : SeminormedAddCommGroup.{u2} E] [_inst_3 : NormedSpace.{u1, u2} 𝕜 E (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1) _inst_2] (f : E' -> E) (s : Set.{u3} E'), Iff (Bornology.IsVonNBounded.{u1, u2} 𝕜 E (SeminormedCommRing.toSemiNormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1)))) (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 E (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1))))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) (NormedSpace.toModule.{u1, u2} 𝕜 E (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1) _inst_2 _inst_3))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (SeminormedAddGroup.toAddGroup.{u2} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E _inst_2)))))) (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2))) (Set.image.{u3, u2} E' E f s)) (Exists.{1} Real (fun (r : Real) => forall (x : E'), (Membership.Mem.{u3, u3} E' (Set.{u3} E') (Set.hasMem.{u3} E') x s) -> (LE.le.{0} Real Real.hasLe (Norm.norm.{u2} E (SeminormedAddCommGroup.toHasNorm.{u2} E _inst_2) (f x)) r)))
but is expected to have type
  forall (𝕜 : Type.{u2}) (E : Type.{u1}) {E' : Type.{u3}} [_inst_1 : NontriviallyNormedField.{u2} 𝕜] [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_3 : NormedSpace.{u2, u1} 𝕜 E (NontriviallyNormedField.toNormedField.{u2} 𝕜 _inst_1) _inst_2] (f : E' -> E) (s : Set.{u3} E'), Iff (Bornology.IsVonNBounded.{u2, u1} 𝕜 E (SeminormedCommRing.toSeminormedRing.{u2} 𝕜 (NormedCommRing.toSeminormedCommRing.{u2} 𝕜 (NormedField.toNormedCommRing.{u2} 𝕜 (NontriviallyNormedField.toNormedField.{u2} 𝕜 _inst_1)))) (SMulZeroClass.toSMul.{u2, u1} 𝕜 E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u2, u1} 𝕜 E (CommMonoidWithZero.toZero.{u2} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕜 (Semifield.toCommGroupWithZero.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 (NormedField.toField.{u2} 𝕜 (NontriviallyNormedField.toNormedField.{u2} 𝕜 _inst_1)))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕜 E (Semiring.toMonoidWithZero.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 (NormedField.toField.{u2} 𝕜 (NontriviallyNormedField.toNormedField.{u2} 𝕜 _inst_1)))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} 𝕜 E (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 (NormedField.toField.{u2} 𝕜 (NontriviallyNormedField.toNormedField.{u2} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{u2, u1} 𝕜 E (NontriviallyNormedField.toNormedField.{u2} 𝕜 _inst_1) _inst_2 _inst_3))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2))) (Set.image.{u3, u1} E' E f s)) (Exists.{1} Real (fun (r : Real) => forall (x : E'), (Membership.mem.{u3, u3} E' (Set.{u3} E') (Set.instMembershipSet.{u3} E') x s) -> (LE.le.{0} Real Real.instLEReal (Norm.norm.{u1} E (SeminormedAddCommGroup.toNorm.{u1} E _inst_2) (f x)) r)))
Case conversion may be inaccurate. Consider using '#align normed_space.image_is_vonN_bounded_iff NormedSpace.image_isVonNBounded_iffₓ'. -/
theorem image_isVonNBounded_iff (f : E' → E) (s : Set E') :
    Bornology.IsVonNBounded 𝕜 (f '' s) ↔ ∃ r : ℝ, ∀ (x : E') (hx : x ∈ s), ‖f x‖ ≤ r := by
  simp_rw [is_vonN_bounded_iff', Set.ball_image_iff]
#align normed_space.image_is_vonN_bounded_iff NormedSpace.image_isVonNBounded_iff

#print NormedSpace.vonNBornology_eq /-
/-- In a normed space, the von Neumann bornology (`bornology.vonN_bornology`) is equal to the
metric bornology. -/
theorem vonNBornology_eq : Bornology.vonNBornology 𝕜 E = PseudoMetricSpace.toBornology :=
  by
  rw [Bornology.ext_iff_isBounded]
  intro s
  rw [Bornology.isBounded_iff_isVonNBounded]
  exact is_vonN_bounded_iff 𝕜 E s
#align normed_space.vonN_bornology_eq NormedSpace.vonNBornology_eq
-/

variable (𝕜)

/- warning: normed_space.is_bounded_iff_subset_smul_ball -> NormedSpace.isBounded_iff_subset_smul_ball is a dubious translation:
lean 3 declaration is
  forall (𝕜 : Type.{u1}) (E : Type.{u2}) [_inst_1 : NontriviallyNormedField.{u1} 𝕜] [_inst_2 : SeminormedAddCommGroup.{u2} E] [_inst_3 : NormedSpace.{u1, u2} 𝕜 E (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1) _inst_2] {s : Set.{u2} E}, Iff (Bornology.IsBounded.{u2} E (PseudoMetricSpace.toBornology.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2)) s) (Exists.{succ u1} 𝕜 (fun (a : 𝕜) => HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) s (SMul.smul.{u1, u2} 𝕜 (Set.{u2} E) (Set.smulSet.{u1, u2} 𝕜 E (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 E (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1))))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) (NormedSpace.toModule.{u1, u2} 𝕜 E (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1) _inst_2 _inst_3)))))) a (Metric.ball.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2) (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (SeminormedAddGroup.toAddGroup.{u2} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E _inst_2))))))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))))))
but is expected to have type
  forall (𝕜 : Type.{u1}) (E : Type.{u2}) [_inst_1 : NontriviallyNormedField.{u1} 𝕜] [_inst_2 : SeminormedAddCommGroup.{u2} E] [_inst_3 : NormedSpace.{u1, u2} 𝕜 E (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1) _inst_2] {s : Set.{u2} E}, Iff (Bornology.IsBounded.{u2} E (PseudoMetricSpace.toBornology.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2)) s) (Exists.{succ u1} 𝕜 (fun (a : 𝕜) => HasSubset.Subset.{u2} (Set.{u2} E) (Set.instHasSubsetSet.{u2} E) s (HSMul.hSMul.{u1, u2, u2} 𝕜 (Set.{u2} E) (Set.{u2} E) (instHSMul.{u1, u2} 𝕜 (Set.{u2} E) (Set.smulSet.{u1, u2} 𝕜 E (SMulZeroClass.toSMul.{u1, u2} 𝕜 E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u1, u2} 𝕜 E (CommMonoidWithZero.toZero.{u1} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u1} 𝕜 (Semifield.toCommGroupWithZero.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1)))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1)))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) (NormedSpace.toModule.{u1, u2} 𝕜 E (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1) _inst_2 _inst_3))))))) a (Metric.ball.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2) (OfNat.ofNat.{u2} E 0 (Zero.toOfNat0.{u2} E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))))))
Case conversion may be inaccurate. Consider using '#align normed_space.is_bounded_iff_subset_smul_ball NormedSpace.isBounded_iff_subset_smul_ballₓ'. -/
theorem isBounded_iff_subset_smul_ball {s : Set E} :
    Bornology.IsBounded s ↔ ∃ a : 𝕜, s ⊆ a • Metric.ball 0 1 :=
  by
  rw [← is_vonN_bounded_iff 𝕜]
  constructor
  · intro h
    rcases h (Metric.ball_mem_nhds 0 zero_lt_one) with ⟨ρ, hρ, hρball⟩
    rcases NormedField.exists_lt_norm 𝕜 ρ with ⟨a, ha⟩
    exact ⟨a, hρball a ha.le⟩
  · rintro ⟨a, ha⟩
    exact ((is_vonN_bounded_ball 𝕜 E 1).image (a • 1 : E →L[𝕜] E)).Subset ha
#align normed_space.is_bounded_iff_subset_smul_ball NormedSpace.isBounded_iff_subset_smul_ball

/- warning: normed_space.is_bounded_iff_subset_smul_closed_ball -> NormedSpace.isBounded_iff_subset_smul_closedBall is a dubious translation:
lean 3 declaration is
  forall (𝕜 : Type.{u1}) (E : Type.{u2}) [_inst_1 : NontriviallyNormedField.{u1} 𝕜] [_inst_2 : SeminormedAddCommGroup.{u2} E] [_inst_3 : NormedSpace.{u1, u2} 𝕜 E (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1) _inst_2] {s : Set.{u2} E}, Iff (Bornology.IsBounded.{u2} E (PseudoMetricSpace.toBornology.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2)) s) (Exists.{succ u1} 𝕜 (fun (a : 𝕜) => HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) s (SMul.smul.{u1, u2} 𝕜 (Set.{u2} E) (Set.smulSet.{u1, u2} 𝕜 E (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 E (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1))))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) (NormedSpace.toModule.{u1, u2} 𝕜 E (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1) _inst_2 _inst_3)))))) a (Metric.closedBall.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2) (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (SeminormedAddGroup.toAddGroup.{u2} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E _inst_2))))))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))))))
but is expected to have type
  forall (𝕜 : Type.{u1}) (E : Type.{u2}) [_inst_1 : NontriviallyNormedField.{u1} 𝕜] [_inst_2 : SeminormedAddCommGroup.{u2} E] [_inst_3 : NormedSpace.{u1, u2} 𝕜 E (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1) _inst_2] {s : Set.{u2} E}, Iff (Bornology.IsBounded.{u2} E (PseudoMetricSpace.toBornology.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2)) s) (Exists.{succ u1} 𝕜 (fun (a : 𝕜) => HasSubset.Subset.{u2} (Set.{u2} E) (Set.instHasSubsetSet.{u2} E) s (HSMul.hSMul.{u1, u2, u2} 𝕜 (Set.{u2} E) (Set.{u2} E) (instHSMul.{u1, u2} 𝕜 (Set.{u2} E) (Set.smulSet.{u1, u2} 𝕜 E (SMulZeroClass.toSMul.{u1, u2} 𝕜 E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u1, u2} 𝕜 E (CommMonoidWithZero.toZero.{u1} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u1} 𝕜 (Semifield.toCommGroupWithZero.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1)))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1)))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) (NormedSpace.toModule.{u1, u2} 𝕜 E (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_1) _inst_2 _inst_3))))))) a (Metric.closedBall.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2) (OfNat.ofNat.{u2} E 0 (Zero.toOfNat0.{u2} E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))))))
Case conversion may be inaccurate. Consider using '#align normed_space.is_bounded_iff_subset_smul_closed_ball NormedSpace.isBounded_iff_subset_smul_closedBallₓ'. -/
theorem isBounded_iff_subset_smul_closedBall {s : Set E} :
    Bornology.IsBounded s ↔ ∃ a : 𝕜, s ⊆ a • Metric.closedBall 0 1 :=
  by
  constructor
  · rw [is_bounded_iff_subset_smul_ball 𝕜]
    exact Exists.imp fun a ha => ha.trans <| Set.smul_set_mono <| Metric.ball_subset_closedBall
  · rw [← is_vonN_bounded_iff 𝕜]
    rintro ⟨a, ha⟩
    exact ((is_vonN_bounded_closed_ball 𝕜 E 1).image (a • 1 : E →L[𝕜] E)).Subset ha
#align normed_space.is_bounded_iff_subset_smul_closed_ball NormedSpace.isBounded_iff_subset_smul_closedBall

end NormedSpace

end VonNBornologyEqMetric

