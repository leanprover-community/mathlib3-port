/-
Copyright (c) 2022 Yaël Dillies. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yaël Dillies, Yury Kudryashov

! This file was ported from Lean 3 source module analysis.convex.strict_convex_space
! leanprover-community/mathlib commit a63928c34ec358b5edcda2bf7513c50052a5230f
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Analysis.Convex.Normed
import Mathbin.Analysis.Convex.Strict
import Mathbin.Analysis.Normed.Order.Basic
import Mathbin.Analysis.NormedSpace.AddTorsor
import Mathbin.Analysis.NormedSpace.Pointwise
import Mathbin.Analysis.NormedSpace.AffineIsometry

/-!
# Strictly convex spaces

This file defines strictly convex spaces. A normed space is strictly convex if all closed balls are
strictly convex. This does **not** mean that the norm is strictly convex (in fact, it never is).

## Main definitions

`strict_convex_space`: a typeclass saying that a given normed space over a normed linear ordered
field (e.g., `ℝ` or `ℚ`) is strictly convex. The definition requires strict convexity of a closed
ball of positive radius with center at the origin; strict convexity of any other closed ball follows
from this assumption.

## Main results

In a strictly convex space, we prove

- `strict_convex_closed_ball`: a closed ball is strictly convex.
- `combo_mem_ball_of_ne`, `open_segment_subset_ball_of_ne`, `norm_combo_lt_of_ne`:
  a nontrivial convex combination of two points in a closed ball belong to the corresponding open
  ball;
- `norm_add_lt_of_not_same_ray`, `same_ray_iff_norm_add`, `dist_add_dist_eq_iff`:
  the triangle inequality `dist x y + dist y z ≤ dist x z` is a strict inequality unless `y` belongs
  to the segment `[x -[ℝ] z]`.
- `isometry.affine_isometry_of_strict_convex_space`: an isometry of `normed_add_torsor`s for real
  normed spaces, strictly convex in the case of the codomain, is an affine isometry.

We also provide several lemmas that can be used as alternative constructors for `strict_convex ℝ E`:

- `strict_convex_space.of_strict_convex_closed_unit_ball`: if `closed_ball (0 : E) 1` is strictly
  convex, then `E` is a strictly convex space;

- `strict_convex_space.of_norm_add`: if `‖x + y‖ = ‖x‖ + ‖y‖` implies `same_ray ℝ x y` for all
  nonzero `x y : E`, then `E` is a strictly convex space.

## Implementation notes

While the definition is formulated for any normed linear ordered field, most of the lemmas are
formulated only for the case `𝕜 = ℝ`.

## Tags

convex, strictly convex
-/


open Set Metric

open Convex Pointwise

#print StrictConvexSpace /-
/-- A *strictly convex space* is a normed space where the closed balls are strictly convex. We only
require balls of positive radius with center at the origin to be strictly convex in the definition,
then prove that any closed ball is strictly convex in `strict_convex_closed_ball` below.

See also `strict_convex_space.of_strict_convex_closed_unit_ball`. -/
class StrictConvexSpace (𝕜 E : Type _) [NormedLinearOrderedField 𝕜] [NormedAddCommGroup E]
  [NormedSpace 𝕜 E] : Prop where
  strictConvex_closedBall : ∀ r : ℝ, 0 < r → StrictConvex 𝕜 (closedBall (0 : E) r)
#align strict_convex_space StrictConvexSpace
-/

variable (𝕜 : Type _) {E : Type _} [NormedLinearOrderedField 𝕜] [NormedAddCommGroup E]
  [NormedSpace 𝕜 E]

/- warning: strict_convex_closed_ball -> strictConvex_closedBall is a dubious translation:
lean 3 declaration is
  forall (𝕜 : Type.{u1}) {E : Type.{u2}} [_inst_1 : NormedLinearOrderedField.{u1} 𝕜] [_inst_2 : NormedAddCommGroup.{u2} E] [_inst_3 : NormedSpace.{u1, u2} 𝕜 E (NormedLinearOrderedField.toNormedField.{u1} 𝕜 _inst_1) (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)] [_inst_4 : StrictConvexSpace.{u1, u2} 𝕜 E _inst_1 _inst_2 _inst_3] (x : E) (r : Real), StrictConvex.{u1, u2} 𝕜 E (StrictOrderedSemiring.toOrderedSemiring.{u1} 𝕜 (StrictOrderedRing.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u1} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u1} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u1} 𝕜 (NormedLinearOrderedField.toLinearOrderedField.{u1} 𝕜 _inst_1)))))) (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))) (AddCommGroup.toAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 E (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NormedLinearOrderedField.toNormedField.{u1} 𝕜 _inst_1))))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NormedLinearOrderedField.toNormedField.{u1} 𝕜 _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NormedLinearOrderedField.toNormedField.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2))) (NormedSpace.toModule.{u1, u2} 𝕜 E (NormedLinearOrderedField.toNormedField.{u1} 𝕜 _inst_1) (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_3))))) (Metric.closedBall.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)) x r)
but is expected to have type
  forall (𝕜 : Type.{u2}) {E : Type.{u1}} [_inst_1 : NormedLinearOrderedField.{u2} 𝕜] [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_3 : NormedSpace.{u2, u1} 𝕜 E (NormedLinearOrderedField.toNormedField.{u2} 𝕜 _inst_1) (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_4 : StrictConvexSpace.{u2, u1} 𝕜 E _inst_1 _inst_2 _inst_3] (x : E) (r : Real), StrictConvex.{u2, u1} 𝕜 E (OrderedCommSemiring.toOrderedSemiring.{u2} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u2} 𝕜 (NormedLinearOrderedField.toLinearOrderedField.{u2} 𝕜 _inst_1)))))) (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))) (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (SMulZeroClass.toSMul.{u2, u1} 𝕜 E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u2, u1} 𝕜 E (CommMonoidWithZero.toZero.{u2} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕜 (Semifield.toCommGroupWithZero.{u2} 𝕜 (LinearOrderedSemifield.toSemifield.{u2} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u2} 𝕜 (NormedLinearOrderedField.toLinearOrderedField.{u2} 𝕜 _inst_1)))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕜 E (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u2} 𝕜 (NormedLinearOrderedField.toLinearOrderedField.{u2} 𝕜 _inst_1))))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} 𝕜 E (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u2} 𝕜 (NormedLinearOrderedField.toLinearOrderedField.{u2} 𝕜 _inst_1)))))) (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{u2, u1} 𝕜 E (NormedLinearOrderedField.toNormedField.{u2} 𝕜 _inst_1) (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_3))))) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)) x r)
Case conversion may be inaccurate. Consider using '#align strict_convex_closed_ball strictConvex_closedBallₓ'. -/
/-- A closed ball in a strictly convex space is strictly convex. -/
theorem strictConvex_closedBall [StrictConvexSpace 𝕜 E] (x : E) (r : ℝ) :
    StrictConvex 𝕜 (closedBall x r) :=
  by
  cases' le_or_lt r 0 with hr hr
  · exact (subsingleton_closed_ball x hr).StrictConvex
  rw [← vadd_closedBall_zero]
  exact (StrictConvexSpace.strictConvex_closedBall r hr).vadd _
#align strict_convex_closed_ball strictConvex_closedBall

variable [NormedSpace ℝ E]

/- warning: strict_convex_space.of_strict_convex_closed_unit_ball -> StrictConvexSpace.ofStrictConvexClosedUnitBall is a dubious translation:
lean 3 declaration is
  forall (𝕜 : Type.{u1}) {E : Type.{u2}} [_inst_1 : NormedLinearOrderedField.{u1} 𝕜] [_inst_2 : NormedAddCommGroup.{u2} E] [_inst_3 : NormedSpace.{u1, u2} 𝕜 E (NormedLinearOrderedField.toNormedField.{u1} 𝕜 _inst_1) (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)] [_inst_4 : NormedSpace.{0, u2} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)] [_inst_5 : LinearMap.CompatibleSMul.{u2, u2, u1, 0} E E (AddCommGroup.toAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) (AddCommGroup.toAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) 𝕜 Real Real.semiring (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 E (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NormedLinearOrderedField.toNormedField.{u1} 𝕜 _inst_1))))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NormedLinearOrderedField.toNormedField.{u1} 𝕜 _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NormedLinearOrderedField.toNormedField.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2))) (NormedSpace.toModule.{u1, u2} 𝕜 E (NormedLinearOrderedField.toNormedField.{u1} 𝕜 _inst_1) (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_3))))) (NormedSpace.toModule.{0, u2} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_4) (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 E (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NormedLinearOrderedField.toNormedField.{u1} 𝕜 _inst_1))))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NormedLinearOrderedField.toNormedField.{u1} 𝕜 _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NormedLinearOrderedField.toNormedField.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2))) (NormedSpace.toModule.{u1, u2} 𝕜 E (NormedLinearOrderedField.toNormedField.{u1} 𝕜 _inst_1) (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_3))))) (NormedSpace.toModule.{0, u2} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_4)], (StrictConvex.{u1, u2} 𝕜 E (StrictOrderedSemiring.toOrderedSemiring.{u1} 𝕜 (StrictOrderedRing.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u1} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u1} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u1} 𝕜 (NormedLinearOrderedField.toLinearOrderedField.{u1} 𝕜 _inst_1)))))) (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))) (AddCommGroup.toAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 E (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NormedLinearOrderedField.toNormedField.{u1} 𝕜 _inst_1))))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NormedLinearOrderedField.toNormedField.{u1} 𝕜 _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 (NormedRing.toRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NormedLinearOrderedField.toNormedField.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2))) (NormedSpace.toModule.{u1, u2} 𝕜 E (NormedLinearOrderedField.toNormedField.{u1} 𝕜 _inst_1) (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_3))))) (Metric.closedBall.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)) (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (NormedAddGroup.toAddGroup.{u2} E (NormedAddCommGroup.toNormedAddGroup.{u2} E _inst_2))))))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) -> (StrictConvexSpace.{u1, u2} 𝕜 E _inst_1 _inst_2 _inst_3)
but is expected to have type
  forall (𝕜 : Type.{u1}) {E : Type.{u2}} [_inst_1 : NormedLinearOrderedField.{u1} 𝕜] [_inst_2 : NormedAddCommGroup.{u2} E] [_inst_3 : NormedSpace.{u1, u2} 𝕜 E (NormedLinearOrderedField.toNormedField.{u1} 𝕜 _inst_1) (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)] [_inst_4 : NormedSpace.{0, u2} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)] [_inst_5 : LinearMap.CompatibleSMul.{u2, u2, u1, 0} E E (AddCommGroup.toAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) (AddCommGroup.toAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) 𝕜 Real Real.semiring (SMulZeroClass.toSMul.{u1, u2} 𝕜 E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u1, u2} 𝕜 E (CommMonoidWithZero.toZero.{u1} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u1} 𝕜 (Semifield.toCommGroupWithZero.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 (NormedLinearOrderedField.toLinearOrderedField.{u1} 𝕜 _inst_1)))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (StrictOrderedSemiring.toSemiring.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 (NormedLinearOrderedField.toLinearOrderedField.{u1} 𝕜 _inst_1))))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (StrictOrderedSemiring.toSemiring.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 (NormedLinearOrderedField.toLinearOrderedField.{u1} 𝕜 _inst_1)))))) (AddCommGroup.toAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) (NormedSpace.toModule.{u1, u2} 𝕜 E (NormedLinearOrderedField.toNormedField.{u1} 𝕜 _inst_1) (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_3))))) (NormedSpace.toModule.{0, u2} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_4) (SMulZeroClass.toSMul.{u1, u2} 𝕜 E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u1, u2} 𝕜 E (CommMonoidWithZero.toZero.{u1} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u1} 𝕜 (Semifield.toCommGroupWithZero.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 (NormedLinearOrderedField.toLinearOrderedField.{u1} 𝕜 _inst_1)))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (StrictOrderedSemiring.toSemiring.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 (NormedLinearOrderedField.toLinearOrderedField.{u1} 𝕜 _inst_1))))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (StrictOrderedSemiring.toSemiring.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 (NormedLinearOrderedField.toLinearOrderedField.{u1} 𝕜 _inst_1)))))) (AddCommGroup.toAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) (NormedSpace.toModule.{u1, u2} 𝕜 E (NormedLinearOrderedField.toNormedField.{u1} 𝕜 _inst_1) (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_3))))) (NormedSpace.toModule.{0, u2} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_4)], (StrictConvex.{u1, u2} 𝕜 E (OrderedCommSemiring.toOrderedSemiring.{u1} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 (NormedLinearOrderedField.toLinearOrderedField.{u1} 𝕜 _inst_1)))))) (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))) (AddCommGroup.toAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) (SMulZeroClass.toSMul.{u1, u2} 𝕜 E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u1, u2} 𝕜 E (CommMonoidWithZero.toZero.{u1} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u1} 𝕜 (Semifield.toCommGroupWithZero.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 (NormedLinearOrderedField.toLinearOrderedField.{u1} 𝕜 _inst_1)))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (StrictOrderedSemiring.toSemiring.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 (NormedLinearOrderedField.toLinearOrderedField.{u1} 𝕜 _inst_1))))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (StrictOrderedSemiring.toSemiring.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 (NormedLinearOrderedField.toLinearOrderedField.{u1} 𝕜 _inst_1)))))) (AddCommGroup.toAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) (NormedSpace.toModule.{u1, u2} 𝕜 E (NormedLinearOrderedField.toNormedField.{u1} 𝕜 _inst_1) (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_3))))) (Metric.closedBall.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)) (OfNat.ofNat.{u2} E 0 (Zero.toOfNat0.{u2} E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) -> (StrictConvexSpace.{u1, u2} 𝕜 E _inst_1 _inst_2 _inst_3)
Case conversion may be inaccurate. Consider using '#align strict_convex_space.of_strict_convex_closed_unit_ball StrictConvexSpace.ofStrictConvexClosedUnitBallₓ'. -/
/-- A real normed vector space is strictly convex provided that the unit ball is strictly convex. -/
theorem StrictConvexSpace.ofStrictConvexClosedUnitBall [LinearMap.CompatibleSMul E E 𝕜 ℝ]
    (h : StrictConvex 𝕜 (closedBall (0 : E) 1)) : StrictConvexSpace 𝕜 E :=
  ⟨fun r hr => by simpa only [smul_closedUnitBall_of_nonneg hr.le] using h.smul r⟩
#align strict_convex_space.of_strict_convex_closed_unit_ball StrictConvexSpace.ofStrictConvexClosedUnitBall

/- warning: strict_convex_space.of_norm_combo_lt_one -> StrictConvexSpace.ofNormComboLtOne is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)], (forall (x : E) (y : E), (Eq.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) x) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) -> (Eq.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) y) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) -> (Ne.{succ u1} E x y) -> (Exists.{1} Real (fun (a : Real) => Exists.{1} Real (fun (b : Real) => And (Eq.{1} Real (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) a b) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) (LT.lt.{0} Real Real.hasLt (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))))) (SMul.smul.{0, u1} Real E (SMulZeroClass.toHasSmul.{0, u1} Real E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSmulZeroClass.{0, u1} Real E (MulZeroClass.toHasZero.{0} Real (MulZeroOneClass.toMulZeroClass.{0} Real (MonoidWithZero.toMulZeroOneClass.{0} Real (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real E (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{0, u1} Real E (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))) (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2))) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4))))) a x) (SMul.smul.{0, u1} Real E (SMulZeroClass.toHasSmul.{0, u1} Real E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSmulZeroClass.{0, u1} Real E (MulZeroClass.toHasZero.{0} Real (MulZeroOneClass.toMulZeroClass.{0} Real (MonoidWithZero.toMulZeroOneClass.{0} Real (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real E (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{0, u1} Real E (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))) (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2))) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4))))) b y))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))))))) -> (StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4)
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)], (forall (x : E) (y : E), (Eq.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) x) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) -> (Eq.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) y) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) -> (Ne.{succ u1} E x y) -> (Exists.{1} Real (fun (a : Real) => Exists.{1} Real (fun (b : Real) => And (Eq.{1} Real (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) a b) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) (LT.lt.{0} Real Real.instLTReal (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))))) (HSMul.hSMul.{0, u1, u1} Real E E (instHSMul.{0, u1} Real E (SMulZeroClass.toSMul.{0, u1} Real E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{0, u1} Real E Real.instZeroReal (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real E Real.instMonoidWithZeroReal (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{0, u1} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4)))))) a x) (HSMul.hSMul.{0, u1, u1} Real E E (instHSMul.{0, u1} Real E (SMulZeroClass.toSMul.{0, u1} Real E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{0, u1} Real E Real.instZeroReal (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real E Real.instMonoidWithZeroReal (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{0, u1} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4)))))) b y))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))))))) -> (StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4)
Case conversion may be inaccurate. Consider using '#align strict_convex_space.of_norm_combo_lt_one StrictConvexSpace.ofNormComboLtOneₓ'. -/
/-- Strict convexity is equivalent to `‖a • x + b • y‖ < 1` for all `x` and `y` of norm at most `1`
and all strictly positive `a` and `b` such that `a + b = 1`. This lemma shows that it suffices to
check this for points of norm one and some `a`, `b` such that `a + b = 1`. -/
theorem StrictConvexSpace.ofNormComboLtOne
    (h : ∀ x y : E, ‖x‖ = 1 → ‖y‖ = 1 → x ≠ y → ∃ a b : ℝ, a + b = 1 ∧ ‖a • x + b • y‖ < 1) :
    StrictConvexSpace ℝ E :=
  by
  refine'
    StrictConvexSpace.ofStrictConvexClosedUnitBall ℝ
      ((convex_closedBall _ _).strictConvex' fun x hx y hy hne => _)
  rw [interior_closedBall (0 : E) one_ne_zero, closed_ball_diff_ball, mem_sphere_zero_iff_norm] at
    hx hy
  rcases h x y hx hy hne with ⟨a, b, hab, hlt⟩
  use b
  rwa [AffineMap.lineMap_apply_module, interior_closedBall (0 : E) one_ne_zero, mem_ball_zero_iff,
    sub_eq_iff_eq_add.2 hab.symm]
#align strict_convex_space.of_norm_combo_lt_one StrictConvexSpace.ofNormComboLtOne

/- warning: strict_convex_space.of_norm_combo_ne_one -> StrictConvexSpace.ofNormComboNeOne is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)], (forall (x : E) (y : E), (Eq.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) x) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) -> (Eq.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) y) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) -> (Ne.{succ u1} E x y) -> (Exists.{1} Real (fun (a : Real) => Exists.{1} Real (fun (b : Real) => And (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) a) (And (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) b) (And (Eq.{1} Real (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) a b) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) (Ne.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))))) (SMul.smul.{0, u1} Real E (SMulZeroClass.toHasSmul.{0, u1} Real E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSmulZeroClass.{0, u1} Real E (MulZeroClass.toHasZero.{0} Real (MulZeroOneClass.toMulZeroClass.{0} Real (MonoidWithZero.toMulZeroOneClass.{0} Real (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real E (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{0, u1} Real E (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))) (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2))) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4))))) a x) (SMul.smul.{0, u1} Real E (SMulZeroClass.toHasSmul.{0, u1} Real E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSmulZeroClass.{0, u1} Real E (MulZeroClass.toHasZero.{0} Real (MulZeroOneClass.toMulZeroClass.{0} Real (MonoidWithZero.toMulZeroOneClass.{0} Real (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real E (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{0, u1} Real E (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))) (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2))) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4))))) b y))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))))))))) -> (StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4)
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)], (forall (x : E) (y : E), (Eq.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) x) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) -> (Eq.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) y) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) -> (Ne.{succ u1} E x y) -> (Exists.{1} Real (fun (a : Real) => Exists.{1} Real (fun (b : Real) => And (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) a) (And (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) b) (And (Eq.{1} Real (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) a b) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) (Ne.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))))) (HSMul.hSMul.{0, u1, u1} Real E E (instHSMul.{0, u1} Real E (SMulZeroClass.toSMul.{0, u1} Real E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{0, u1} Real E Real.instZeroReal (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real E Real.instMonoidWithZeroReal (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{0, u1} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4)))))) a x) (HSMul.hSMul.{0, u1, u1} Real E E (instHSMul.{0, u1} Real E (SMulZeroClass.toSMul.{0, u1} Real E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{0, u1} Real E Real.instZeroReal (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real E Real.instMonoidWithZeroReal (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{0, u1} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4)))))) b y))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))))))))) -> (StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4)
Case conversion may be inaccurate. Consider using '#align strict_convex_space.of_norm_combo_ne_one StrictConvexSpace.ofNormComboNeOneₓ'. -/
theorem StrictConvexSpace.ofNormComboNeOne
    (h :
      ∀ x y : E,
        ‖x‖ = 1 → ‖y‖ = 1 → x ≠ y → ∃ a b : ℝ, 0 ≤ a ∧ 0 ≤ b ∧ a + b = 1 ∧ ‖a • x + b • y‖ ≠ 1) :
    StrictConvexSpace ℝ E :=
  by
  refine' StrictConvexSpace.ofStrictConvexClosedUnitBall ℝ ((convex_closedBall _ _).StrictConvex _)
  simp only [interior_closedBall _ one_ne_zero, closed_ball_diff_ball, Set.Pairwise,
    frontier_closedBall _ one_ne_zero, mem_sphere_zero_iff_norm]
  intro x hx y hy hne
  rcases h x y hx hy hne with ⟨a, b, ha, hb, hab, hne'⟩
  exact ⟨_, ⟨a, b, ha, hb, hab, rfl⟩, mt mem_sphere_zero_iff_norm.1 hne'⟩
#align strict_convex_space.of_norm_combo_ne_one StrictConvexSpace.ofNormComboNeOne

/- warning: strict_convex_space.of_norm_add_ne_two -> StrictConvexSpace.ofNormAddNeTwo is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)], (forall {{x : E}} {{y : E}}, (Eq.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) x) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) -> (Eq.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) y) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) -> (Ne.{succ u1} E x y) -> (Ne.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))))) x y)) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))))) -> (StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4)
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)], (forall {{x : E}} {{y : E}}, (Eq.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) x) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) -> (Eq.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) y) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) -> (Ne.{succ u1} E x y) -> (Ne.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))))) x y)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))))) -> (StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4)
Case conversion may be inaccurate. Consider using '#align strict_convex_space.of_norm_add_ne_two StrictConvexSpace.ofNormAddNeTwoₓ'. -/
theorem StrictConvexSpace.ofNormAddNeTwo
    (h : ∀ ⦃x y : E⦄, ‖x‖ = 1 → ‖y‖ = 1 → x ≠ y → ‖x + y‖ ≠ 2) : StrictConvexSpace ℝ E :=
  by
  refine'
    StrictConvexSpace.ofNormComboNeOne fun x y hx hy hne =>
      ⟨1 / 2, 1 / 2, one_half_pos.le, one_half_pos.le, add_halves _, _⟩
  rw [← smul_add, norm_smul, Real.norm_of_nonneg one_half_pos.le, one_div, ← div_eq_inv_mul, Ne.def,
    div_eq_one_iff_eq (two_ne_zero' ℝ)]
  exact h hx hy hne
#align strict_convex_space.of_norm_add_ne_two StrictConvexSpace.ofNormAddNeTwo

/- warning: strict_convex_space.of_pairwise_sphere_norm_ne_two -> StrictConvexSpace.ofPairwiseSphereNormNeTwo is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)], (Set.Pairwise.{u1} E (Metric.sphere.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)) (OfNat.ofNat.{u1} E 0 (OfNat.mk.{u1} E 0 (Zero.zero.{u1} E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) (fun (x : E) (y : E) => Ne.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))))) x y)) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))))) -> (StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4)
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)], (Set.Pairwise.{u1} E (Metric.sphere.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) (fun (x : E) (y : E) => Ne.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))))) x y)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))))) -> (StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4)
Case conversion may be inaccurate. Consider using '#align strict_convex_space.of_pairwise_sphere_norm_ne_two StrictConvexSpace.ofPairwiseSphereNormNeTwoₓ'. -/
theorem StrictConvexSpace.ofPairwiseSphereNormNeTwo
    (h : (sphere (0 : E) 1).Pairwise fun x y => ‖x + y‖ ≠ 2) : StrictConvexSpace ℝ E :=
  StrictConvexSpace.ofNormAddNeTwo fun x y hx hy =>
    h (mem_sphere_zero_iff_norm.2 hx) (mem_sphere_zero_iff_norm.2 hy)
#align strict_convex_space.of_pairwise_sphere_norm_ne_two StrictConvexSpace.ofPairwiseSphereNormNeTwo

/- warning: strict_convex_space.of_norm_add -> StrictConvexSpace.ofNormAdd is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)], (forall (x : E) (y : E), (Eq.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) x) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) -> (Eq.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) y) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) -> (Eq.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))))) x y)) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) -> (SameRay.{0, u1} Real Real.strictOrderedCommSemiring E (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4) x y)) -> (StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4)
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)], (forall (x : E) (y : E), (Eq.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) x) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) -> (Eq.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) y) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) -> (Eq.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))))) x y)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) -> (SameRay.{0, u1} Real Real.strictOrderedCommSemiring E (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4) x y)) -> (StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4)
Case conversion may be inaccurate. Consider using '#align strict_convex_space.of_norm_add StrictConvexSpace.ofNormAddₓ'. -/
/-- If `‖x + y‖ = ‖x‖ + ‖y‖` implies that `x y : E` are in the same ray, then `E` is a strictly
convex space. See also a more -/
theorem StrictConvexSpace.ofNormAdd
    (h : ∀ x y : E, ‖x‖ = 1 → ‖y‖ = 1 → ‖x + y‖ = 2 → SameRay ℝ x y) : StrictConvexSpace ℝ E :=
  by
  refine' StrictConvexSpace.ofPairwiseSphereNormNeTwo fun x hx y hy => mt fun h₂ => _
  rw [mem_sphere_zero_iff_norm] at hx hy
  exact (sameRay_iff_of_norm_eq (hx.trans hy.symm)).1 (h x y hx hy h₂)
#align strict_convex_space.of_norm_add StrictConvexSpace.ofNormAdd

variable [StrictConvexSpace ℝ E] {x y z : E} {a b r : ℝ}

/- warning: combo_mem_ball_of_ne -> combo_mem_ball_of_ne is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_5 : StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4] {x : E} {y : E} {z : E} {a : Real} {b : Real} {r : Real}, (Membership.Mem.{u1, u1} E (Set.{u1} E) (Set.hasMem.{u1} E) x (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)) z r)) -> (Membership.Mem.{u1, u1} E (Set.{u1} E) (Set.hasMem.{u1} E) y (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)) z r)) -> (Ne.{succ u1} E x y) -> (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) a) -> (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) b) -> (Eq.{1} Real (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) a b) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) -> (Membership.Mem.{u1, u1} E (Set.{u1} E) (Set.hasMem.{u1} E) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))))) (SMul.smul.{0, u1} Real E (SMulZeroClass.toHasSmul.{0, u1} Real E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSmulZeroClass.{0, u1} Real E (MulZeroClass.toHasZero.{0} Real (MulZeroOneClass.toMulZeroClass.{0} Real (MonoidWithZero.toMulZeroOneClass.{0} Real (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real E (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{0, u1} Real E (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))) (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2))) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4))))) a x) (SMul.smul.{0, u1} Real E (SMulZeroClass.toHasSmul.{0, u1} Real E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSmulZeroClass.{0, u1} Real E (MulZeroClass.toHasZero.{0} Real (MulZeroOneClass.toMulZeroClass.{0} Real (MonoidWithZero.toMulZeroOneClass.{0} Real (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real E (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{0, u1} Real E (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))) (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2))) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4))))) b y)) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)) z r))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_5 : StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4] {x : E} {y : E} {z : E} {a : Real} {b : Real} {r : Real}, (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)) z r)) -> (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) y (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)) z r)) -> (Ne.{succ u1} E x y) -> (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) a) -> (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) b) -> (Eq.{1} Real (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) a b) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) -> (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))))) (HSMul.hSMul.{0, u1, u1} Real E E (instHSMul.{0, u1} Real E (SMulZeroClass.toSMul.{0, u1} Real E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{0, u1} Real E Real.instZeroReal (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real E Real.instMonoidWithZeroReal (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{0, u1} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4)))))) a x) (HSMul.hSMul.{0, u1, u1} Real E E (instHSMul.{0, u1} Real E (SMulZeroClass.toSMul.{0, u1} Real E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{0, u1} Real E Real.instZeroReal (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real E Real.instMonoidWithZeroReal (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{0, u1} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4)))))) b y)) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)) z r))
Case conversion may be inaccurate. Consider using '#align combo_mem_ball_of_ne combo_mem_ball_of_neₓ'. -/
/-- If `x ≠ y` belong to the same closed ball, then a convex combination of `x` and `y` with
positive coefficients belongs to the corresponding open ball. -/
theorem combo_mem_ball_of_ne (hx : x ∈ closedBall z r) (hy : y ∈ closedBall z r) (hne : x ≠ y)
    (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) : a • x + b • y ∈ ball z r :=
  by
  rcases eq_or_ne r 0 with (rfl | hr)
  · rw [closed_ball_zero, mem_singleton_iff] at hx hy
    exact (hne (hx.trans hy.symm)).elim
  · simp only [← interior_closedBall _ hr] at hx hy⊢
    exact strictConvex_closedBall ℝ z r hx hy hne ha hb hab
#align combo_mem_ball_of_ne combo_mem_ball_of_ne

#print openSegment_subset_ball_of_ne /-
/-- If `x ≠ y` belong to the same closed ball, then the open segment with endpoints `x` and `y` is
included in the corresponding open ball. -/
theorem openSegment_subset_ball_of_ne (hx : x ∈ closedBall z r) (hy : y ∈ closedBall z r)
    (hne : x ≠ y) : openSegment ℝ x y ⊆ ball z r :=
  (openSegment_subset_iff _).2 fun a b => combo_mem_ball_of_ne hx hy hne
#align open_segment_subset_ball_of_ne openSegment_subset_ball_of_ne
-/

/- warning: norm_combo_lt_of_ne -> norm_combo_lt_of_ne is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_5 : StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4] {x : E} {y : E} {a : Real} {b : Real} {r : Real}, (LE.le.{0} Real Real.hasLe (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) x) r) -> (LE.le.{0} Real Real.hasLe (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) y) r) -> (Ne.{succ u1} E x y) -> (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) a) -> (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) b) -> (Eq.{1} Real (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) a b) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) -> (LT.lt.{0} Real Real.hasLt (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))))) (SMul.smul.{0, u1} Real E (SMulZeroClass.toHasSmul.{0, u1} Real E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSmulZeroClass.{0, u1} Real E (MulZeroClass.toHasZero.{0} Real (MulZeroOneClass.toMulZeroClass.{0} Real (MonoidWithZero.toMulZeroOneClass.{0} Real (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real E (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{0, u1} Real E (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))) (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2))) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4))))) a x) (SMul.smul.{0, u1} Real E (SMulZeroClass.toHasSmul.{0, u1} Real E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSmulZeroClass.{0, u1} Real E (MulZeroClass.toHasZero.{0} Real (MulZeroOneClass.toMulZeroClass.{0} Real (MonoidWithZero.toMulZeroOneClass.{0} Real (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real E (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{0, u1} Real E (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))) (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2))) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4))))) b y))) r)
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_5 : StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4] {x : E} {y : E} {a : Real} {b : Real} {r : Real}, (LE.le.{0} Real Real.instLEReal (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) x) r) -> (LE.le.{0} Real Real.instLEReal (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) y) r) -> (Ne.{succ u1} E x y) -> (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) a) -> (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) b) -> (Eq.{1} Real (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) a b) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) -> (LT.lt.{0} Real Real.instLTReal (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))))) (HSMul.hSMul.{0, u1, u1} Real E E (instHSMul.{0, u1} Real E (SMulZeroClass.toSMul.{0, u1} Real E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{0, u1} Real E Real.instZeroReal (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real E Real.instMonoidWithZeroReal (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{0, u1} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4)))))) a x) (HSMul.hSMul.{0, u1, u1} Real E E (instHSMul.{0, u1} Real E (SMulZeroClass.toSMul.{0, u1} Real E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{0, u1} Real E Real.instZeroReal (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real E Real.instMonoidWithZeroReal (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{0, u1} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4)))))) b y))) r)
Case conversion may be inaccurate. Consider using '#align norm_combo_lt_of_ne norm_combo_lt_of_neₓ'. -/
/-- If `x` and `y` are two distinct vectors of norm at most `r`, then a convex combination of `x`
and `y` with positive coefficients has norm strictly less than `r`. -/
theorem norm_combo_lt_of_ne (hx : ‖x‖ ≤ r) (hy : ‖y‖ ≤ r) (hne : x ≠ y) (ha : 0 < a) (hb : 0 < b)
    (hab : a + b = 1) : ‖a • x + b • y‖ < r :=
  by
  simp only [← mem_ball_zero_iff, ← mem_closedBall_zero_iff] at hx hy⊢
  exact combo_mem_ball_of_ne hx hy hne ha hb hab
#align norm_combo_lt_of_ne norm_combo_lt_of_ne

/- warning: norm_add_lt_of_not_same_ray -> norm_add_lt_of_not_sameRay is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_5 : StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4] {x : E} {y : E}, (Not (SameRay.{0, u1} Real Real.strictOrderedCommSemiring E (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4) x y)) -> (LT.lt.{0} Real Real.hasLt (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))))) x y)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) x) (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) y)))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_5 : StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4] {x : E} {y : E}, (Not (SameRay.{0, u1} Real Real.strictOrderedCommSemiring E (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4) x y)) -> (LT.lt.{0} Real Real.instLTReal (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))))) x y)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) x) (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) y)))
Case conversion may be inaccurate. Consider using '#align norm_add_lt_of_not_same_ray norm_add_lt_of_not_sameRayₓ'. -/
/-- In a strictly convex space, if `x` and `y` are not in the same ray, then `‖x + y‖ < ‖x‖ +
‖y‖`. -/
theorem norm_add_lt_of_not_sameRay (h : ¬SameRay ℝ x y) : ‖x + y‖ < ‖x‖ + ‖y‖ :=
  by
  simp only [sameRay_iff_inv_norm_smul_eq, not_or, ← Ne.def] at h
  rcases h with ⟨hx, hy, hne⟩
  rw [← norm_pos_iff] at hx hy
  have hxy : 0 < ‖x‖ + ‖y‖ := add_pos hx hy
  have :=
    combo_mem_ball_of_ne (inv_norm_smul_mem_closed_unit_ball x)
      (inv_norm_smul_mem_closed_unit_ball y) hne (div_pos hx hxy) (div_pos hy hxy)
      (by rw [← add_div, div_self hxy.ne'])
  rwa [mem_ball_zero_iff, div_eq_inv_mul, div_eq_inv_mul, mul_smul, mul_smul, smul_inv_smul₀ hx.ne',
    smul_inv_smul₀ hy.ne', ← smul_add, norm_smul, Real.norm_of_nonneg (inv_pos.2 hxy).le, ←
    div_eq_inv_mul, div_lt_one hxy] at this
#align norm_add_lt_of_not_same_ray norm_add_lt_of_not_sameRay

/- warning: lt_norm_sub_of_not_same_ray -> lt_norm_sub_of_not_sameRay is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_5 : StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4] {x : E} {y : E}, (Not (SameRay.{0, u1} Real Real.strictOrderedCommSemiring E (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4) x y)) -> (LT.lt.{0} Real Real.hasLt (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) x) (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) y)) (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) (HSub.hSub.{u1, u1, u1} E E E (instHSub.{u1} E (SubNegMonoid.toHasSub.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))) x y)))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_5 : StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4] {x : E} {y : E}, (Not (SameRay.{0, u1} Real Real.strictOrderedCommSemiring E (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4) x y)) -> (LT.lt.{0} Real Real.instLTReal (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.instSubReal) (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) x) (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) y)) (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) (HSub.hSub.{u1, u1, u1} E E E (instHSub.{u1} E (SubNegMonoid.toSub.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))) x y)))
Case conversion may be inaccurate. Consider using '#align lt_norm_sub_of_not_same_ray lt_norm_sub_of_not_sameRayₓ'. -/
theorem lt_norm_sub_of_not_sameRay (h : ¬SameRay ℝ x y) : ‖x‖ - ‖y‖ < ‖x - y‖ :=
  by
  nth_rw 1 [← sub_add_cancel x y] at h⊢
  exact sub_lt_iff_lt_add.2 (norm_add_lt_of_not_sameRay fun H' => h <| H'.add_left SameRay.rfl)
#align lt_norm_sub_of_not_same_ray lt_norm_sub_of_not_sameRay

/- warning: abs_lt_norm_sub_of_not_same_ray -> abs_lt_norm_sub_of_not_sameRay is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_5 : StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4] {x : E} {y : E}, (Not (SameRay.{0, u1} Real Real.strictOrderedCommSemiring E (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4) x y)) -> (LT.lt.{0} Real Real.hasLt (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.hasNeg Real.hasSup) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) x) (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) y))) (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) (HSub.hSub.{u1, u1, u1} E E E (instHSub.{u1} E (SubNegMonoid.toHasSub.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))) x y)))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_5 : StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4] {x : E} {y : E}, (Not (SameRay.{0, u1} Real Real.strictOrderedCommSemiring E (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4) x y)) -> (LT.lt.{0} Real Real.instLTReal (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.instNegReal Real.instSupReal) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.instSubReal) (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) x) (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) y))) (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) (HSub.hSub.{u1, u1, u1} E E E (instHSub.{u1} E (SubNegMonoid.toSub.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))) x y)))
Case conversion may be inaccurate. Consider using '#align abs_lt_norm_sub_of_not_same_ray abs_lt_norm_sub_of_not_sameRayₓ'. -/
theorem abs_lt_norm_sub_of_not_sameRay (h : ¬SameRay ℝ x y) : |‖x‖ - ‖y‖| < ‖x - y‖ :=
  by
  refine' abs_sub_lt_iff.2 ⟨lt_norm_sub_of_not_sameRay h, _⟩
  rw [norm_sub_rev]
  exact lt_norm_sub_of_not_sameRay (mt SameRay.symm h)
#align abs_lt_norm_sub_of_not_same_ray abs_lt_norm_sub_of_not_sameRay

/- warning: same_ray_iff_norm_add -> sameRay_iff_norm_add is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_5 : StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4] {x : E} {y : E}, Iff (SameRay.{0, u1} Real Real.strictOrderedCommSemiring E (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4) x y) (Eq.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))))) x y)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) x) (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) y)))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_5 : StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4] {x : E} {y : E}, Iff (SameRay.{0, u1} Real Real.strictOrderedCommSemiring E (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4) x y) (Eq.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))))) x y)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) x) (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) y)))
Case conversion may be inaccurate. Consider using '#align same_ray_iff_norm_add sameRay_iff_norm_addₓ'. -/
/-- In a strictly convex space, two vectors `x`, `y` are in the same ray if and only if the triangle
inequality for `x` and `y` becomes an equality. -/
theorem sameRay_iff_norm_add : SameRay ℝ x y ↔ ‖x + y‖ = ‖x‖ + ‖y‖ :=
  ⟨SameRay.norm_add, fun h => Classical.not_not.1 fun h' => (norm_add_lt_of_not_sameRay h').Ne h⟩
#align same_ray_iff_norm_add sameRay_iff_norm_add

/- warning: eq_of_norm_eq_of_norm_add_eq -> eq_of_norm_eq_of_norm_add_eq is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_5 : StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4] {x : E} {y : E}, (Eq.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) x) (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) y)) -> (Eq.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))))) x y)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) x) (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) y))) -> (Eq.{succ u1} E x y)
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_5 : StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4] {x : E} {y : E}, (Eq.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) x) (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) y)) -> (Eq.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))))) x y)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) x) (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) y))) -> (Eq.{succ u1} E x y)
Case conversion may be inaccurate. Consider using '#align eq_of_norm_eq_of_norm_add_eq eq_of_norm_eq_of_norm_add_eqₓ'. -/
/-- If `x` and `y` are two vectors in a strictly convex space have the same norm and the norm of
their sum is equal to the sum of their norms, then they are equal. -/
theorem eq_of_norm_eq_of_norm_add_eq (h₁ : ‖x‖ = ‖y‖) (h₂ : ‖x + y‖ = ‖x‖ + ‖y‖) : x = y :=
  (sameRay_iff_norm_add.mpr h₂).eq_of_norm_eq h₁
#align eq_of_norm_eq_of_norm_add_eq eq_of_norm_eq_of_norm_add_eq

/- warning: not_same_ray_iff_norm_add_lt -> not_sameRay_iff_norm_add_lt is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_5 : StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4] {x : E} {y : E}, Iff (Not (SameRay.{0, u1} Real Real.strictOrderedCommSemiring E (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4) x y)) (LT.lt.{0} Real Real.hasLt (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))))) x y)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) x) (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) y)))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_5 : StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4] {x : E} {y : E}, Iff (Not (SameRay.{0, u1} Real Real.strictOrderedCommSemiring E (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4) x y)) (LT.lt.{0} Real Real.instLTReal (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))))) x y)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) x) (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) y)))
Case conversion may be inaccurate. Consider using '#align not_same_ray_iff_norm_add_lt not_sameRay_iff_norm_add_ltₓ'. -/
/-- In a strictly convex space, two vectors `x`, `y` are not in the same ray if and only if the
triangle inequality for `x` and `y` is strict. -/
theorem not_sameRay_iff_norm_add_lt : ¬SameRay ℝ x y ↔ ‖x + y‖ < ‖x‖ + ‖y‖ :=
  sameRay_iff_norm_add.Not.trans (norm_add_le _ _).lt_iff_ne.symm
#align not_same_ray_iff_norm_add_lt not_sameRay_iff_norm_add_lt

/- warning: same_ray_iff_norm_sub -> sameRay_iff_norm_sub is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_5 : StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4] {x : E} {y : E}, Iff (SameRay.{0, u1} Real Real.strictOrderedCommSemiring E (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4) x y) (Eq.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) (HSub.hSub.{u1, u1, u1} E E E (instHSub.{u1} E (SubNegMonoid.toHasSub.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))) x y)) (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.hasNeg Real.hasSup) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) x) (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) y))))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_5 : StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4] {x : E} {y : E}, Iff (SameRay.{0, u1} Real Real.strictOrderedCommSemiring E (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4) x y) (Eq.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) (HSub.hSub.{u1, u1, u1} E E E (instHSub.{u1} E (SubNegMonoid.toSub.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))) x y)) (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.instNegReal Real.instSupReal) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.instSubReal) (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) x) (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) y))))
Case conversion may be inaccurate. Consider using '#align same_ray_iff_norm_sub sameRay_iff_norm_subₓ'. -/
theorem sameRay_iff_norm_sub : SameRay ℝ x y ↔ ‖x - y‖ = |‖x‖ - ‖y‖| :=
  ⟨SameRay.norm_sub, fun h =>
    Classical.not_not.1 fun h' => (abs_lt_norm_sub_of_not_sameRay h').ne' h⟩
#align same_ray_iff_norm_sub sameRay_iff_norm_sub

/- warning: not_same_ray_iff_abs_lt_norm_sub -> not_sameRay_iff_abs_lt_norm_sub is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_5 : StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4] {x : E} {y : E}, Iff (Not (SameRay.{0, u1} Real Real.strictOrderedCommSemiring E (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4) x y)) (LT.lt.{0} Real Real.hasLt (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.hasNeg Real.hasSup) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) x) (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) y))) (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) (HSub.hSub.{u1, u1, u1} E E E (instHSub.{u1} E (SubNegMonoid.toHasSub.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))) x y)))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_5 : StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4] {x : E} {y : E}, Iff (Not (SameRay.{0, u1} Real Real.strictOrderedCommSemiring E (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4) x y)) (LT.lt.{0} Real Real.instLTReal (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.instNegReal Real.instSupReal) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.instSubReal) (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) x) (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) y))) (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) (HSub.hSub.{u1, u1, u1} E E E (instHSub.{u1} E (SubNegMonoid.toSub.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))) x y)))
Case conversion may be inaccurate. Consider using '#align not_same_ray_iff_abs_lt_norm_sub not_sameRay_iff_abs_lt_norm_subₓ'. -/
theorem not_sameRay_iff_abs_lt_norm_sub : ¬SameRay ℝ x y ↔ |‖x‖ - ‖y‖| < ‖x - y‖ :=
  sameRay_iff_norm_sub.Not.trans <| ne_comm.trans (abs_norm_sub_norm_le _ _).lt_iff_ne.symm
#align not_same_ray_iff_abs_lt_norm_sub not_sameRay_iff_abs_lt_norm_sub

/- warning: dist_add_dist_eq_iff -> dist_add_dist_eq_iff is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_5 : StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4] {x : E} {y : E} {z : E}, Iff (Eq.{1} Real (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (Dist.dist.{u1} E (PseudoMetricSpace.toHasDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2))) x y) (Dist.dist.{u1} E (PseudoMetricSpace.toHasDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2))) y z)) (Dist.dist.{u1} E (PseudoMetricSpace.toHasDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2))) x z)) (Membership.Mem.{u1, u1} E (Set.{u1} E) (Set.hasMem.{u1} E) y (segment.{0, u1} Real E Real.orderedSemiring (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (SMulZeroClass.toHasSmul.{0, u1} Real E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSmulZeroClass.{0, u1} Real E (MulZeroClass.toHasZero.{0} Real (MulZeroOneClass.toMulZeroClass.{0} Real (MonoidWithZero.toMulZeroOneClass.{0} Real (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real E (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{0, u1} Real E (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))) (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2))) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4))))) x z))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_5 : StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4] {x : E} {y : E} {z : E}, Iff (Eq.{1} Real (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (Dist.dist.{u1} E (PseudoMetricSpace.toDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2))) x y) (Dist.dist.{u1} E (PseudoMetricSpace.toDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2))) y z)) (Dist.dist.{u1} E (PseudoMetricSpace.toDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2))) x z)) (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) y (segment.{0, u1} Real E Real.orderedSemiring (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (SMulZeroClass.toSMul.{0, u1} Real E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{0, u1} Real E Real.instZeroReal (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real E Real.instMonoidWithZeroReal (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{0, u1} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4))))) x z))
Case conversion may be inaccurate. Consider using '#align dist_add_dist_eq_iff dist_add_dist_eq_iffₓ'. -/
/-- In a strictly convex space, the triangle inequality turns into an equality if and only if the
middle point belongs to the segment joining two other points. -/
theorem dist_add_dist_eq_iff : dist x y + dist y z = dist x z ↔ y ∈ [x -[ℝ] z] := by
  simp only [mem_segment_iff_sameRay, sameRay_iff_norm_add, dist_eq_norm', sub_add_sub_cancel',
    eq_comm]
#align dist_add_dist_eq_iff dist_add_dist_eq_iff

/- warning: norm_midpoint_lt_iff -> norm_midpoint_lt_iff is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_5 : StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4] {x : E} {y : E}, (Eq.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) x) (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) y)) -> (Iff (LT.lt.{0} Real Real.hasLt (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) (SMul.smul.{0, u1} Real E (SMulZeroClass.toHasSmul.{0, u1} Real E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSmulZeroClass.{0, u1} Real E (MulZeroClass.toHasZero.{0} Real (MulZeroOneClass.toMulZeroClass.{0} Real (MonoidWithZero.toMulZeroOneClass.{0} Real (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real E (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{0, u1} Real E (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))) (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2))) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4))))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))))) x y))) (Norm.norm.{u1} E (NormedAddCommGroup.toHasNorm.{u1} E _inst_2) x)) (Ne.{succ u1} E x y))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_5 : StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4] {x : E} {y : E}, (Eq.{1} Real (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) x) (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) y)) -> (Iff (LT.lt.{0} Real Real.instLTReal (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) (HSMul.hSMul.{0, u1, u1} Real E E (instHSMul.{0, u1} Real E (SMulZeroClass.toSMul.{0, u1} Real E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{0, u1} Real E Real.instZeroReal (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real E Real.instMonoidWithZeroReal (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{0, u1} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4)))))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))))) x y))) (Norm.norm.{u1} E (NormedAddCommGroup.toNorm.{u1} E _inst_2) x)) (Ne.{succ u1} E x y))
Case conversion may be inaccurate. Consider using '#align norm_midpoint_lt_iff norm_midpoint_lt_iffₓ'. -/
theorem norm_midpoint_lt_iff (h : ‖x‖ = ‖y‖) : ‖(1 / 2 : ℝ) • (x + y)‖ < ‖x‖ ↔ x ≠ y := by
  rw [norm_smul, Real.norm_of_nonneg (one_div_nonneg.2 zero_le_two), ← inv_eq_one_div, ←
    div_eq_inv_mul, div_lt_iff (zero_lt_two' ℝ), mul_two, ← not_sameRay_iff_of_norm_eq h,
    not_sameRay_iff_norm_add_lt, h]
#align norm_midpoint_lt_iff norm_midpoint_lt_iff

variable {F : Type _} [NormedAddCommGroup F] [NormedSpace ℝ F]

variable {PF : Type _} {PE : Type _} [MetricSpace PF] [MetricSpace PE]

variable [NormedAddTorsor F PF] [NormedAddTorsor E PE]

include E

/- warning: eq_line_map_of_dist_eq_mul_of_dist_eq_mul -> eq_lineMap_of_dist_eq_mul_of_dist_eq_mul is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_5 : StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4] {r : Real} {PE : Type.{u2}} [_inst_9 : MetricSpace.{u2} PE] [_inst_11 : NormedAddTorsor.{u1, u2} E PE (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) (MetricSpace.toPseudoMetricSpace.{u2} PE _inst_9)] {x : PE} {y : PE} {z : PE}, (Eq.{1} Real (Dist.dist.{u2} PE (PseudoMetricSpace.toHasDist.{u2} PE (MetricSpace.toPseudoMetricSpace.{u2} PE _inst_9)) x y) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) r (Dist.dist.{u2} PE (PseudoMetricSpace.toHasDist.{u2} PE (MetricSpace.toPseudoMetricSpace.{u2} PE _inst_9)) x z))) -> (Eq.{1} Real (Dist.dist.{u2} PE (PseudoMetricSpace.toHasDist.{u2} PE (MetricSpace.toPseudoMetricSpace.{u2} PE _inst_9)) y z) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) r) (Dist.dist.{u2} PE (PseudoMetricSpace.toHasDist.{u2} PE (MetricSpace.toPseudoMetricSpace.{u2} PE _inst_9)) x z))) -> (Eq.{succ u2} PE y (coeFn.{max 1 (succ u1) (succ u2), succ u2} (AffineMap.{0, 0, 0, u1, u2} Real Real Real E PE Real.ring (NonUnitalNonAssocRing.toAddCommGroup.{0} Real (NonAssocRing.toNonUnitalNonAssocRing.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring))) (Semiring.toModule.{0} Real (Ring.toSemiring.{0} Real Real.ring)) (addGroupIsAddTorsor.{0} Real (AddGroupWithOne.toAddGroup.{0} Real (AddCommGroupWithOne.toAddGroupWithOne.{0} Real (Ring.toAddCommGroupWithOne.{0} Real Real.ring)))) (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4) (NormedAddTorsor.toAddTorsor'.{u1, u2} E PE _inst_2 _inst_9 _inst_11)) (fun (_x : AffineMap.{0, 0, 0, u1, u2} Real Real Real E PE Real.ring (NonUnitalNonAssocRing.toAddCommGroup.{0} Real (NonAssocRing.toNonUnitalNonAssocRing.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring))) (Semiring.toModule.{0} Real (Ring.toSemiring.{0} Real Real.ring)) (addGroupIsAddTorsor.{0} Real (AddGroupWithOne.toAddGroup.{0} Real (AddCommGroupWithOne.toAddGroupWithOne.{0} Real (Ring.toAddCommGroupWithOne.{0} Real Real.ring)))) (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4) (NormedAddTorsor.toAddTorsor'.{u1, u2} E PE _inst_2 _inst_9 _inst_11)) => Real -> PE) (AffineMap.hasCoeToFun.{0, 0, 0, u1, u2} Real Real Real E PE Real.ring (NonUnitalNonAssocRing.toAddCommGroup.{0} Real (NonAssocRing.toNonUnitalNonAssocRing.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring))) (Semiring.toModule.{0} Real (Ring.toSemiring.{0} Real Real.ring)) (addGroupIsAddTorsor.{0} Real (AddGroupWithOne.toAddGroup.{0} Real (AddCommGroupWithOne.toAddGroupWithOne.{0} Real (Ring.toAddCommGroupWithOne.{0} Real Real.ring)))) (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4) (NormedAddTorsor.toAddTorsor'.{u1, u2} E PE _inst_2 _inst_9 _inst_11)) (AffineMap.lineMap.{0, u1, u2} Real E PE Real.ring (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4) (NormedAddTorsor.toAddTorsor'.{u1, u2} E PE _inst_2 _inst_9 _inst_11) x z) r))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_5 : StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4] {r : Real} {PE : Type.{u2}} [_inst_9 : MetricSpace.{u2} PE] [_inst_11 : NormedAddTorsor.{u1, u2} E PE (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) (MetricSpace.toPseudoMetricSpace.{u2} PE _inst_9)] {x : PE} {y : PE} {z : PE}, (Eq.{1} Real (Dist.dist.{u2} PE (PseudoMetricSpace.toDist.{u2} PE (MetricSpace.toPseudoMetricSpace.{u2} PE _inst_9)) x y) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) r (Dist.dist.{u2} PE (PseudoMetricSpace.toDist.{u2} PE (MetricSpace.toPseudoMetricSpace.{u2} PE _inst_9)) x z))) -> (Eq.{1} Real (Dist.dist.{u2} PE (PseudoMetricSpace.toDist.{u2} PE (MetricSpace.toPseudoMetricSpace.{u2} PE _inst_9)) y z) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.instSubReal) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) r) (Dist.dist.{u2} PE (PseudoMetricSpace.toDist.{u2} PE (MetricSpace.toPseudoMetricSpace.{u2} PE _inst_9)) x z))) -> (Eq.{succ u2} PE y (FunLike.coe.{max (succ u1) (succ u2), 1, succ u2} (AffineMap.{0, 0, 0, u1, u2} Real Real Real E PE Real.instRingReal (Ring.toAddCommGroup.{0} Real Real.instRingReal) (Semiring.toModule.{0} Real (Ring.toSemiring.{0} Real Real.instRingReal)) (addGroupIsAddTorsor.{0} Real (AddGroupWithOne.toAddGroup.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal))) (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4) (NormedAddTorsor.toAddTorsor.{u1, u2} E PE (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) (MetricSpace.toPseudoMetricSpace.{u2} PE _inst_9) _inst_11)) Real (fun (_x : Real) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : Real) => PE) _x) (AffineMap.funLike.{0, 0, 0, u1, u2} Real Real Real E PE Real.instRingReal (Ring.toAddCommGroup.{0} Real Real.instRingReal) (Semiring.toModule.{0} Real (Ring.toSemiring.{0} Real Real.instRingReal)) (addGroupIsAddTorsor.{0} Real (AddGroupWithOne.toAddGroup.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal))) (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4) (NormedAddTorsor.toAddTorsor.{u1, u2} E PE (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) (MetricSpace.toPseudoMetricSpace.{u2} PE _inst_9) _inst_11)) (AffineMap.lineMap.{0, u1, u2} Real E PE Real.instRingReal (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4) (NormedAddTorsor.toAddTorsor.{u1, u2} E PE (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) (MetricSpace.toPseudoMetricSpace.{u2} PE _inst_9) _inst_11) x z) r))
Case conversion may be inaccurate. Consider using '#align eq_line_map_of_dist_eq_mul_of_dist_eq_mul eq_lineMap_of_dist_eq_mul_of_dist_eq_mulₓ'. -/
theorem eq_lineMap_of_dist_eq_mul_of_dist_eq_mul {x y z : PE} (hxy : dist x y = r * dist x z)
    (hyz : dist y z = (1 - r) * dist x z) : y = AffineMap.lineMap x z r :=
  by
  have : y -ᵥ x ∈ [(0 : E) -[ℝ] z -ᵥ x] := by
    rw [← dist_add_dist_eq_iff, dist_zero_left, dist_vsub_cancel_right, ← dist_eq_norm_vsub', ←
      dist_eq_norm_vsub', hxy, hyz, ← add_mul, add_sub_cancel'_right, one_mul]
  rcases eq_or_ne x z with (rfl | hne)
  · obtain rfl : y = x := by simpa
    simp
  · rw [← dist_ne_zero] at hne
    rcases this with ⟨a, b, ha, hb, hab, H⟩
    rw [smul_zero, zero_add] at H
    have H' := congr_arg norm H
    rw [norm_smul, Real.norm_of_nonneg hb, ← dist_eq_norm_vsub', ← dist_eq_norm_vsub', hxy,
      mul_left_inj' hne] at H'
    rw [AffineMap.lineMap_apply, ← H', H, vsub_vadd]
#align eq_line_map_of_dist_eq_mul_of_dist_eq_mul eq_lineMap_of_dist_eq_mul_of_dist_eq_mul

/- warning: eq_midpoint_of_dist_eq_half -> eq_midpoint_of_dist_eq_half is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_5 : StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4] {PE : Type.{u2}} [_inst_9 : MetricSpace.{u2} PE] [_inst_11 : NormedAddTorsor.{u1, u2} E PE (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) (MetricSpace.toPseudoMetricSpace.{u2} PE _inst_9)] {x : PE} {y : PE} {z : PE}, (Eq.{1} Real (Dist.dist.{u2} PE (PseudoMetricSpace.toHasDist.{u2} PE (MetricSpace.toPseudoMetricSpace.{u2} PE _inst_9)) x y) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (Dist.dist.{u2} PE (PseudoMetricSpace.toHasDist.{u2} PE (MetricSpace.toPseudoMetricSpace.{u2} PE _inst_9)) x z) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))))) -> (Eq.{1} Real (Dist.dist.{u2} PE (PseudoMetricSpace.toHasDist.{u2} PE (MetricSpace.toPseudoMetricSpace.{u2} PE _inst_9)) y z) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (Dist.dist.{u2} PE (PseudoMetricSpace.toHasDist.{u2} PE (MetricSpace.toPseudoMetricSpace.{u2} PE _inst_9)) x z) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))))) -> (Eq.{succ u2} PE y (midpoint.{0, u1, u2} Real E PE Real.ring (invertibleTwo.{0} Real Real.divisionRing (StrictOrderedSemiring.to_charZero.{0} Real Real.strictOrderedSemiring)) (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4) (NormedAddTorsor.toAddTorsor'.{u1, u2} E PE _inst_2 _inst_9 _inst_11) x z))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_5 : StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4] {PE : Type.{u2}} [_inst_9 : MetricSpace.{u2} PE] [_inst_11 : NormedAddTorsor.{u1, u2} E PE (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) (MetricSpace.toPseudoMetricSpace.{u2} PE _inst_9)] {x : PE} {y : PE} {z : PE}, (Eq.{1} Real (Dist.dist.{u2} PE (PseudoMetricSpace.toDist.{u2} PE (MetricSpace.toPseudoMetricSpace.{u2} PE _inst_9)) x y) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (Dist.dist.{u2} PE (PseudoMetricSpace.toDist.{u2} PE (MetricSpace.toPseudoMetricSpace.{u2} PE _inst_9)) x z) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))))) -> (Eq.{1} Real (Dist.dist.{u2} PE (PseudoMetricSpace.toDist.{u2} PE (MetricSpace.toPseudoMetricSpace.{u2} PE _inst_9)) y z) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (Dist.dist.{u2} PE (PseudoMetricSpace.toDist.{u2} PE (MetricSpace.toPseudoMetricSpace.{u2} PE _inst_9)) x z) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))))) -> (Eq.{succ u2} PE y (midpoint.{0, u1, u2} Real E PE Real.instRingReal (invertibleTwo.{0} Real Real.instDivisionRingReal (StrictOrderedSemiring.to_charZero.{0} Real Real.strictOrderedSemiring)) (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4) (NormedAddTorsor.toAddTorsor.{u1, u2} E PE (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) (MetricSpace.toPseudoMetricSpace.{u2} PE _inst_9) _inst_11) x z))
Case conversion may be inaccurate. Consider using '#align eq_midpoint_of_dist_eq_half eq_midpoint_of_dist_eq_halfₓ'. -/
theorem eq_midpoint_of_dist_eq_half {x y z : PE} (hx : dist x y = dist x z / 2)
    (hy : dist y z = dist x z / 2) : y = midpoint ℝ x z :=
  by
  apply eq_lineMap_of_dist_eq_mul_of_dist_eq_mul
  · rwa [invOf_eq_inv, ← div_eq_inv_mul]
  · rwa [invOf_eq_inv, ← one_div, sub_half, one_div, ← div_eq_inv_mul]
#align eq_midpoint_of_dist_eq_half eq_midpoint_of_dist_eq_half

namespace Isometry

include F

/- warning: isometry.affine_isometry_of_strict_convex_space -> Isometry.affineIsometryOfStrictConvexSpace is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_5 : StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4] {F : Type.{u2}} [_inst_6 : NormedAddCommGroup.{u2} F] [_inst_7 : NormedSpace.{0, u2} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} F _inst_6)] {PF : Type.{u3}} {PE : Type.{u4}} [_inst_8 : MetricSpace.{u3} PF] [_inst_9 : MetricSpace.{u4} PE] [_inst_10 : NormedAddTorsor.{u2, u3} F PF (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} F _inst_6) (MetricSpace.toPseudoMetricSpace.{u3} PF _inst_8)] [_inst_11 : NormedAddTorsor.{u1, u4} E PE (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) (MetricSpace.toPseudoMetricSpace.{u4} PE _inst_9)] {f : PF -> PE}, (Isometry.{u3, u4} PF PE (PseudoMetricSpace.toPseudoEMetricSpace.{u3} PF (MetricSpace.toPseudoMetricSpace.{u3} PF _inst_8)) (PseudoMetricSpace.toPseudoEMetricSpace.{u4} PE (MetricSpace.toPseudoMetricSpace.{u4} PE _inst_9)) f) -> (AffineIsometry.{0, u2, u1, u3, u4} Real F E PF PE Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} F _inst_6) (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_7 _inst_4 (MetricSpace.toPseudoMetricSpace.{u3} PF _inst_8) (MetricSpace.toPseudoMetricSpace.{u4} PE _inst_9) _inst_10 _inst_11)
but is expected to have type
  forall {E : Type.{u2}} [_inst_2 : NormedAddCommGroup.{u2} E] [_inst_4 : NormedSpace.{0, u2} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)] [_inst_5 : StrictConvexSpace.{0, u2} Real E Real.normedLinearOrderedField _inst_2 _inst_4] {F : Type.{u3}} [_inst_6 : NormedAddCommGroup.{u3} F] [_inst_7 : NormedSpace.{0, u3} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u3} F _inst_6)] {PF : Type.{u1}} {PE : Type.{u4}} [_inst_8 : MetricSpace.{u1} PF] [_inst_9 : MetricSpace.{u4} PE] [_inst_10 : NormedAddTorsor.{u3, u1} F PF (NormedAddCommGroup.toSeminormedAddCommGroup.{u3} F _inst_6) (MetricSpace.toPseudoMetricSpace.{u1} PF _inst_8)] [_inst_11 : NormedAddTorsor.{u2, u4} E PE (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) (MetricSpace.toPseudoMetricSpace.{u4} PE _inst_9)] {f : PF -> PE}, (Isometry.{u1, u4} PF PE (EMetricSpace.toPseudoEMetricSpace.{u1} PF (MetricSpace.toEMetricSpace.{u1} PF _inst_8)) (EMetricSpace.toPseudoEMetricSpace.{u4} PE (MetricSpace.toEMetricSpace.{u4} PE _inst_9)) f) -> (AffineIsometry.{0, u3, u2, u1, u4} Real F E PF PE Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u3} F _inst_6) (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_7 _inst_4 (MetricSpace.toPseudoMetricSpace.{u1} PF _inst_8) (MetricSpace.toPseudoMetricSpace.{u4} PE _inst_9) _inst_10 _inst_11)
Case conversion may be inaccurate. Consider using '#align isometry.affine_isometry_of_strict_convex_space Isometry.affineIsometryOfStrictConvexSpaceₓ'. -/
/-- An isometry of `normed_add_torsor`s for real normed spaces, strictly convex in the case of
the codomain, is an affine isometry.  Unlike Mazur-Ulam, this does not require the isometry to
be surjective.  -/
noncomputable def affineIsometryOfStrictConvexSpace {f : PF → PE} (hi : Isometry f) :
    PF →ᵃⁱ[ℝ] PE :=
  {
    AffineMap.ofMapMidpoint f
      (fun x y => by
        apply eq_midpoint_of_dist_eq_half
        ·
          rw [hi.dist_eq, hi.dist_eq, dist_left_midpoint, Real.norm_of_nonneg zero_le_two,
            div_eq_inv_mul]
        ·
          rw [hi.dist_eq, hi.dist_eq, dist_midpoint_right, Real.norm_of_nonneg zero_le_two,
            div_eq_inv_mul])
      hi.Continuous with
    norm_map := fun x => by simp [AffineMap.ofMapMidpoint, ← dist_eq_norm_vsub E, hi.dist_eq] }
#align isometry.affine_isometry_of_strict_convex_space Isometry.affineIsometryOfStrictConvexSpace

/- warning: isometry.coe_affine_isometry_of_strict_convex_space -> Isometry.coe_affineIsometryOfStrictConvexSpace is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_5 : StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4] {F : Type.{u2}} [_inst_6 : NormedAddCommGroup.{u2} F] [_inst_7 : NormedSpace.{0, u2} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} F _inst_6)] {PF : Type.{u3}} {PE : Type.{u4}} [_inst_8 : MetricSpace.{u3} PF] [_inst_9 : MetricSpace.{u4} PE] [_inst_10 : NormedAddTorsor.{u2, u3} F PF (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} F _inst_6) (MetricSpace.toPseudoMetricSpace.{u3} PF _inst_8)] [_inst_11 : NormedAddTorsor.{u1, u4} E PE (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) (MetricSpace.toPseudoMetricSpace.{u4} PE _inst_9)] {f : PF -> PE} (hi : Isometry.{u3, u4} PF PE (PseudoMetricSpace.toPseudoEMetricSpace.{u3} PF (MetricSpace.toPseudoMetricSpace.{u3} PF _inst_8)) (PseudoMetricSpace.toPseudoEMetricSpace.{u4} PE (MetricSpace.toPseudoMetricSpace.{u4} PE _inst_9)) f), Eq.{max (succ u3) (succ u4)} (PF -> PE) (coeFn.{max (succ u2) (succ u1) (succ u3) (succ u4), max (succ u3) (succ u4)} (AffineIsometry.{0, u2, u1, u3, u4} Real F E PF PE Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} F _inst_6) (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_7 _inst_4 (MetricSpace.toPseudoMetricSpace.{u3} PF _inst_8) (MetricSpace.toPseudoMetricSpace.{u4} PE _inst_9) _inst_10 _inst_11) (fun (_x : AffineIsometry.{0, u2, u1, u3, u4} Real F E PF PE Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} F _inst_6) (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_7 _inst_4 (MetricSpace.toPseudoMetricSpace.{u3} PF _inst_8) (MetricSpace.toPseudoMetricSpace.{u4} PE _inst_9) _inst_10 _inst_11) => PF -> PE) (AffineIsometry.hasCoeToFun.{0, u2, u1, u3, u4} Real F E PF PE Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} F _inst_6) (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_7 _inst_4 (MetricSpace.toPseudoMetricSpace.{u3} PF _inst_8) (MetricSpace.toPseudoMetricSpace.{u4} PE _inst_9) _inst_10 _inst_11) (Isometry.affineIsometryOfStrictConvexSpace.{u1, u2, u3, u4} E _inst_2 _inst_4 _inst_5 F _inst_6 _inst_7 PF PE _inst_8 _inst_9 _inst_10 _inst_11 f hi)) f
but is expected to have type
  forall {E : Type.{u2}} [_inst_2 : NormedAddCommGroup.{u2} E] [_inst_4 : NormedSpace.{0, u2} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)] [_inst_5 : StrictConvexSpace.{0, u2} Real E Real.normedLinearOrderedField _inst_2 _inst_4] {F : Type.{u1}} [_inst_6 : NormedAddCommGroup.{u1} F] [_inst_7 : NormedSpace.{0, u1} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_6)] {PF : Type.{u4}} {PE : Type.{u3}} [_inst_8 : MetricSpace.{u4} PF] [_inst_9 : MetricSpace.{u3} PE] [_inst_10 : NormedAddTorsor.{u1, u4} F PF (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_6) (MetricSpace.toPseudoMetricSpace.{u4} PF _inst_8)] [_inst_11 : NormedAddTorsor.{u2, u3} E PE (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) (MetricSpace.toPseudoMetricSpace.{u3} PE _inst_9)] {f : PF -> PE} (hi : Isometry.{u4, u3} PF PE (EMetricSpace.toPseudoEMetricSpace.{u4} PF (MetricSpace.toEMetricSpace.{u4} PF _inst_8)) (EMetricSpace.toPseudoEMetricSpace.{u3} PE (MetricSpace.toEMetricSpace.{u3} PE _inst_9)) f), Eq.{max (succ u4) (succ u3)} (forall (ᾰ : PF), (fun (x._@.Mathlib.Analysis.NormedSpace.AffineIsometry._hyg.1845 : PF) => PE) ᾰ) (FunLike.coe.{max (max (max (succ u4) (succ u2)) (succ u1)) (succ u3), succ u4, succ u3} (AffineIsometry.{0, u1, u2, u4, u3} Real F E PF PE Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_6) (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_7 _inst_4 (MetricSpace.toPseudoMetricSpace.{u4} PF _inst_8) (MetricSpace.toPseudoMetricSpace.{u3} PE _inst_9) _inst_10 _inst_11) PF (fun (_x : PF) => (fun (x._@.Mathlib.Analysis.NormedSpace.AffineIsometry._hyg.1845 : PF) => PE) _x) (AffineIsometry.instFunLikeAffineIsometry.{0, u1, u2, u4, u3} Real F E PF PE Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_6) (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_7 _inst_4 (MetricSpace.toPseudoMetricSpace.{u4} PF _inst_8) (MetricSpace.toPseudoMetricSpace.{u3} PE _inst_9) _inst_10 _inst_11) (Isometry.affineIsometryOfStrictConvexSpace.{u4, u2, u1, u3} E _inst_2 _inst_4 _inst_5 F _inst_6 _inst_7 PF PE _inst_8 _inst_9 _inst_10 _inst_11 f hi)) f
Case conversion may be inaccurate. Consider using '#align isometry.coe_affine_isometry_of_strict_convex_space Isometry.coe_affineIsometryOfStrictConvexSpaceₓ'. -/
@[simp]
theorem coe_affineIsometryOfStrictConvexSpace {f : PF → PE} (hi : Isometry f) :
    ⇑hi.affineIsometryOfStrictConvexSpace = f :=
  rfl
#align isometry.coe_affine_isometry_of_strict_convex_space Isometry.coe_affineIsometryOfStrictConvexSpace

/- warning: isometry.affine_isometry_of_strict_convex_space_apply -> Isometry.affineIsometryOfStrictConvexSpace_apply is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_5 : StrictConvexSpace.{0, u1} Real E Real.normedLinearOrderedField _inst_2 _inst_4] {F : Type.{u2}} [_inst_6 : NormedAddCommGroup.{u2} F] [_inst_7 : NormedSpace.{0, u2} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} F _inst_6)] {PF : Type.{u3}} {PE : Type.{u4}} [_inst_8 : MetricSpace.{u3} PF] [_inst_9 : MetricSpace.{u4} PE] [_inst_10 : NormedAddTorsor.{u2, u3} F PF (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} F _inst_6) (MetricSpace.toPseudoMetricSpace.{u3} PF _inst_8)] [_inst_11 : NormedAddTorsor.{u1, u4} E PE (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) (MetricSpace.toPseudoMetricSpace.{u4} PE _inst_9)] {f : PF -> PE} (hi : Isometry.{u3, u4} PF PE (PseudoMetricSpace.toPseudoEMetricSpace.{u3} PF (MetricSpace.toPseudoMetricSpace.{u3} PF _inst_8)) (PseudoMetricSpace.toPseudoEMetricSpace.{u4} PE (MetricSpace.toPseudoMetricSpace.{u4} PE _inst_9)) f) (p : PF), Eq.{succ u4} PE (coeFn.{max (succ u2) (succ u1) (succ u3) (succ u4), max (succ u3) (succ u4)} (AffineIsometry.{0, u2, u1, u3, u4} Real F E PF PE Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} F _inst_6) (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_7 _inst_4 (MetricSpace.toPseudoMetricSpace.{u3} PF _inst_8) (MetricSpace.toPseudoMetricSpace.{u4} PE _inst_9) _inst_10 _inst_11) (fun (_x : AffineIsometry.{0, u2, u1, u3, u4} Real F E PF PE Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} F _inst_6) (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_7 _inst_4 (MetricSpace.toPseudoMetricSpace.{u3} PF _inst_8) (MetricSpace.toPseudoMetricSpace.{u4} PE _inst_9) _inst_10 _inst_11) => PF -> PE) (AffineIsometry.hasCoeToFun.{0, u2, u1, u3, u4} Real F E PF PE Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} F _inst_6) (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_7 _inst_4 (MetricSpace.toPseudoMetricSpace.{u3} PF _inst_8) (MetricSpace.toPseudoMetricSpace.{u4} PE _inst_9) _inst_10 _inst_11) (Isometry.affineIsometryOfStrictConvexSpace.{u1, u2, u3, u4} E _inst_2 _inst_4 _inst_5 F _inst_6 _inst_7 PF PE _inst_8 _inst_9 _inst_10 _inst_11 f hi) p) (f p)
but is expected to have type
  forall {E : Type.{u2}} [_inst_2 : NormedAddCommGroup.{u2} E] [_inst_4 : NormedSpace.{0, u2} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)] [_inst_5 : StrictConvexSpace.{0, u2} Real E Real.normedLinearOrderedField _inst_2 _inst_4] {F : Type.{u1}} [_inst_6 : NormedAddCommGroup.{u1} F] [_inst_7 : NormedSpace.{0, u1} Real F Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_6)] {PF : Type.{u4}} {PE : Type.{u3}} [_inst_8 : MetricSpace.{u4} PF] [_inst_9 : MetricSpace.{u3} PE] [_inst_10 : NormedAddTorsor.{u1, u4} F PF (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_6) (MetricSpace.toPseudoMetricSpace.{u4} PF _inst_8)] [_inst_11 : NormedAddTorsor.{u2, u3} E PE (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) (MetricSpace.toPseudoMetricSpace.{u3} PE _inst_9)] {f : PF -> PE} (hi : Isometry.{u4, u3} PF PE (EMetricSpace.toPseudoEMetricSpace.{u4} PF (MetricSpace.toEMetricSpace.{u4} PF _inst_8)) (EMetricSpace.toPseudoEMetricSpace.{u3} PE (MetricSpace.toEMetricSpace.{u3} PE _inst_9)) f) (p : PF), Eq.{succ u3} ((fun (x._@.Mathlib.Analysis.NormedSpace.AffineIsometry._hyg.1845 : PF) => PE) p) (FunLike.coe.{max (max (max (succ u4) (succ u2)) (succ u1)) (succ u3), succ u4, succ u3} (AffineIsometry.{0, u1, u2, u4, u3} Real F E PF PE Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_6) (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_7 _inst_4 (MetricSpace.toPseudoMetricSpace.{u4} PF _inst_8) (MetricSpace.toPseudoMetricSpace.{u3} PE _inst_9) _inst_10 _inst_11) PF (fun (_x : PF) => (fun (x._@.Mathlib.Analysis.NormedSpace.AffineIsometry._hyg.1845 : PF) => PE) _x) (AffineIsometry.instFunLikeAffineIsometry.{0, u1, u2, u4, u3} Real F E PF PE Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F _inst_6) (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_7 _inst_4 (MetricSpace.toPseudoMetricSpace.{u4} PF _inst_8) (MetricSpace.toPseudoMetricSpace.{u3} PE _inst_9) _inst_10 _inst_11) (Isometry.affineIsometryOfStrictConvexSpace.{u4, u2, u1, u3} E _inst_2 _inst_4 _inst_5 F _inst_6 _inst_7 PF PE _inst_8 _inst_9 _inst_10 _inst_11 f hi) p) (f p)
Case conversion may be inaccurate. Consider using '#align isometry.affine_isometry_of_strict_convex_space_apply Isometry.affineIsometryOfStrictConvexSpace_applyₓ'. -/
@[simp]
theorem affineIsometryOfStrictConvexSpace_apply {f : PF → PE} (hi : Isometry f) (p : PF) :
    hi.affineIsometryOfStrictConvexSpace p = f p :=
  rfl
#align isometry.affine_isometry_of_strict_convex_space_apply Isometry.affineIsometryOfStrictConvexSpace_apply

end Isometry

