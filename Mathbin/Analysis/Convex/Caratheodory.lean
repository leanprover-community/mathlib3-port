/-
Copyright (c) 2020 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johan Commelin, Scott Morrison

! This file was ported from Lean 3 source module analysis.convex.caratheodory
! leanprover-community/mathlib commit 9d2f0748e6c50d7a2657c564b1ff2c695b39148d
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Analysis.Convex.Combination
import Mathbin.LinearAlgebra.AffineSpace.Independent
import Mathbin.Tactic.FieldSimp

/-!
# Carathéodory's convexity theorem

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

Convex hull can be regarded as a refinement of affine span. Both are closure operators but whereas
convex hull takes values in the lattice of convex subsets, affine span takes values in the much
coarser sublattice of affine subspaces.

The cost of this refinement is that one no longer has bases. However Carathéodory's convexity
theorem offers some compensation. Given a set `s` together with a point `x` in its convex hull,
Carathéodory says that one may find an affine-independent family of elements `s` whose convex hull
contains `x`. Thus the difference from the case of affine span is that the affine-independent family
depends on `x`.

In particular, in finite dimensions Carathéodory's theorem implies that the convex hull of a set `s`
in `𝕜ᵈ` is the union of the convex hulls of the `(d + 1)`-tuples in `s`.

## Main results

* `convex_hull_eq_union`: Carathéodory's convexity theorem

## Implementation details

This theorem was formalized as part of the Sphere Eversion project.

## Tags
convex hull, caratheodory

-/


open Set Finset

open BigOperators

universe u

variable {𝕜 : Type _} {E : Type u} [LinearOrderedField 𝕜] [AddCommGroup E] [Module 𝕜 E]

namespace Caratheodory

/- warning: caratheodory.mem_convex_hull_erase -> Caratheodory.mem_convexHull_erase is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u2}} {E : Type.{u1}} [_inst_1 : LinearOrderedField.{u2} 𝕜] [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u2, u1} 𝕜 E (Ring.toSemiring.{u2} 𝕜 (StrictOrderedRing.toRing.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] [_inst_4 : DecidableEq.{succ u1} E] {t : Finset.{u1} E}, (Not (AffineIndependent.{u2, u1, u1, u1} 𝕜 E E (StrictOrderedRing.toRing.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)) (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) t) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) t) E (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) t) E (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) t) E (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) t) E (coeSubtype.{succ u1} E (fun (x : E) => Membership.Mem.{u1, u1} E (Finset.{u1} E) (Finset.hasMem.{u1} E) x t)))))))) -> (forall {x : E}, (Membership.Mem.{u1, u1} E (Set.{u1} E) (Set.hasMem.{u1} E) x (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (fun (_x : ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) => (Set.{u1} E) -> (Set.{u1} E)) (ClosureOperator.hasCoeToFun.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (convexHull.{u2, u1} 𝕜 E (StrictOrderedSemiring.toOrderedSemiring.{u2} 𝕜 (StrictOrderedRing.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} E) (Set.{u1} E) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (Finset.Set.hasCoeT.{u1} E))) t))) -> (Exists.{succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} E) Type.{u1} (Set.hasCoeToSort.{u1} E) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} E) (Set.{u1} E) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (Finset.Set.hasCoeT.{u1} E))) t)) (fun (y : coeSort.{succ u1, succ (succ u1)} (Set.{u1} E) Type.{u1} (Set.hasCoeToSort.{u1} E) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} E) (Set.{u1} E) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (Finset.Set.hasCoeT.{u1} E))) t)) => Membership.Mem.{u1, u1} E (Set.{u1} E) (Set.hasMem.{u1} E) x (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (fun (_x : ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) => (Set.{u1} E) -> (Set.{u1} E)) (ClosureOperator.hasCoeToFun.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (convexHull.{u2, u1} 𝕜 E (StrictOrderedSemiring.toOrderedSemiring.{u2} 𝕜 (StrictOrderedRing.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} E) (Set.{u1} E) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (Finset.Set.hasCoeT.{u1} E))) (Finset.erase.{u1} E (fun (a : E) (b : E) => _inst_4 a b) t ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} E) Type.{u1} (Set.hasCoeToSort.{u1} E) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} E) (Set.{u1} E) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (Finset.Set.hasCoeT.{u1} E))) t)) E (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} E) Type.{u1} (Set.hasCoeToSort.{u1} E) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} E) (Set.{u1} E) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (Finset.Set.hasCoeT.{u1} E))) t)) E (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} E) Type.{u1} (Set.hasCoeToSort.{u1} E) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} E) (Set.{u1} E) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (Finset.Set.hasCoeT.{u1} E))) t)) E (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} E) Type.{u1} (Set.hasCoeToSort.{u1} E) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} E) (Set.{u1} E) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (Finset.Set.hasCoeT.{u1} E))) t)) E (coeSubtype.{succ u1} E (fun (x : E) => Membership.Mem.{u1, u1} E (Set.{u1} E) (Set.hasMem.{u1} E) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} E) (Set.{u1} E) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (Finset.Set.hasCoeT.{u1} E))) t)))))) y)))))))
but is expected to have type
  forall {𝕜 : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} 𝕜] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} 𝕜 E (StrictOrderedSemiring.toSemiring.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : DecidableEq.{succ u2} E] {t : Finset.{u2} E}, (Not (AffineIndependent.{u1, u2, u2, u2} 𝕜 E E (StrictOrderedRing.toRing.{u1} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u1} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u1} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u1} 𝕜 _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Finset.{u2} E) (Finset.instMembershipFinset.{u2} E) x t)) (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Finset.{u2} E) (Finset.instMembershipFinset.{u2} E) x t)))) -> (forall {x : E}, (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u1, u2} 𝕜 E (OrderedCommSemiring.toOrderedSemiring.{u1} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (Finset.toSet.{u2} E t))) -> (Exists.{succ u2} (Set.Elem.{u2} E (Finset.toSet.{u2} E t)) (fun (y : Set.Elem.{u2} E (Finset.toSet.{u2} E t)) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u1, u2} 𝕜 E (OrderedCommSemiring.toOrderedSemiring.{u1} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (Finset.toSet.{u2} E (Finset.erase.{u2} E (fun (a : E) (b : E) => _inst_4 a b) t (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (Finset.toSet.{u2} E t)) y)))))))
Case conversion may be inaccurate. Consider using '#align caratheodory.mem_convex_hull_erase Caratheodory.mem_convexHull_eraseₓ'. -/
/-- If `x` is in the convex hull of some finset `t` whose elements are not affine-independent,
then it is in the convex hull of a strict subset of `t`. -/
theorem mem_convexHull_erase [DecidableEq E] {t : Finset E} (h : ¬AffineIndependent 𝕜 (coe : t → E))
    {x : E} (m : x ∈ convexHull 𝕜 (↑t : Set E)) :
    ∃ y : (↑t : Set E), x ∈ convexHull 𝕜 (↑(t.eraseₓ y) : Set E) :=
  by
  simp only [Finset.convexHull_eq, mem_set_of_eq] at m⊢
  obtain ⟨f, fpos, fsum, rfl⟩ := m
  obtain ⟨g, gcombo, gsum, gpos⟩ := exists_nontrivial_relation_sum_zero_of_not_affine_ind h
  replace gpos := exists_pos_of_sum_zero_of_exists_nonzero g gsum gpos
  clear h
  let s := @Finset.filter _ (fun z => 0 < g z) (fun _ => LinearOrder.decidableLt _ _) t
  obtain ⟨i₀, mem, w⟩ : ∃ i₀ ∈ s, ∀ i ∈ s, f i₀ / g i₀ ≤ f i / g i :=
    by
    apply s.exists_min_image fun z => f z / g z
    obtain ⟨x, hx, hgx⟩ : ∃ x ∈ t, 0 < g x := gpos
    exact ⟨x, mem_filter.mpr ⟨hx, hgx⟩⟩
  have hg : 0 < g i₀ := by
    rw [mem_filter] at mem
    exact mem.2
  have hi₀ : i₀ ∈ t := filter_subset _ _ mem
  let k : E → 𝕜 := fun z => f z - f i₀ / g i₀ * g z
  have hk : k i₀ = 0 := by field_simp [k, ne_of_gt hg]
  have ksum : (∑ e in t.erase i₀, k e) = 1 := by
    calc
      (∑ e in t.erase i₀, k e) = ∑ e in t, k e := by
        conv_rhs => rw [← insert_erase hi₀, sum_insert (not_mem_erase i₀ t), hk, zero_add]
      _ = ∑ e in t, f e - f i₀ / g i₀ * g e := rfl
      _ = 1 := by rw [sum_sub_distrib, fsum, ← mul_sum, gsum, MulZeroClass.mul_zero, sub_zero]
      
  refine' ⟨⟨i₀, hi₀⟩, k, _, by convert ksum, _⟩
  · simp only [and_imp, sub_nonneg, mem_erase, Ne.def, Subtype.coe_mk]
    intro e hei₀ het
    by_cases hes : e ∈ s
    · have hge : 0 < g e := by
        rw [mem_filter] at hes
        exact hes.2
      rw [← le_div_iff hge]
      exact w _ hes
    · calc
        _ ≤ 0 := mul_nonpos_of_nonneg_of_nonpos _ _
        -- prove two goals below
            _ ≤
            f e :=
          fpos e het
        
      · apply div_nonneg (fpos i₀ (mem_of_subset (filter_subset _ t) mem)) (le_of_lt hg)
      · simpa only [mem_filter, het, true_and_iff, not_lt] using hes
  · simp only [Subtype.coe_mk, center_mass_eq_of_sum_1 _ id ksum, id]
    calc
      (∑ e in t.erase i₀, k e • e) = ∑ e in t, k e • e := sum_erase _ (by rw [hk, zero_smul])
      _ = ∑ e in t, (f e - f i₀ / g i₀ * g e) • e := rfl
      _ = t.center_mass f id := _
      
    simp only [sub_smul, mul_smul, sum_sub_distrib, ← smul_sum, gcombo, smul_zero, sub_zero,
      center_mass, fsum, inv_one, one_smul, id.def]
#align caratheodory.mem_convex_hull_erase Caratheodory.mem_convexHull_erase

variable {s : Set E} {x : E} (hx : x ∈ convexHull 𝕜 s)

include hx

#print Caratheodory.minCardFinsetOfMemConvexHull /-
/-- Given a point `x` in the convex hull of a set `s`, this is a finite subset of `s` of minimum
cardinality, whose convex hull contains `x`. -/
noncomputable def minCardFinsetOfMemConvexHull : Finset E :=
  Function.argminOn Finset.card Nat.lt_wfRel { t | ↑t ⊆ s ∧ x ∈ convexHull 𝕜 (t : Set E) }
    (by
      simpa only [convexHull_eq_union_convexHull_finite_subsets s, exists_prop, mem_Union] using hx)
#align caratheodory.min_card_finset_of_mem_convex_hull Caratheodory.minCardFinsetOfMemConvexHull
-/

/- warning: caratheodory.min_card_finset_of_mem_convex_hull_subseteq -> Caratheodory.minCardFinsetOfMemConvexHull_subseteq is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u2}} {E : Type.{u1}} [_inst_1 : LinearOrderedField.{u2} 𝕜] [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u2, u1} 𝕜 E (Ring.toSemiring.{u2} 𝕜 (StrictOrderedRing.toRing.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {s : Set.{u1} E} {x : E} (hx : Membership.Mem.{u1, u1} E (Set.{u1} E) (Set.hasMem.{u1} E) x (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (fun (_x : ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) => (Set.{u1} E) -> (Set.{u1} E)) (ClosureOperator.hasCoeToFun.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (convexHull.{u2, u1} 𝕜 E (StrictOrderedSemiring.toOrderedSemiring.{u2} 𝕜 (StrictOrderedRing.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3) s)), HasSubset.Subset.{u1} (Set.{u1} E) (Set.hasSubset.{u1} E) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} E) (Set.{u1} E) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (Finset.Set.hasCoeT.{u1} E))) (Caratheodory.minCardFinsetOfMemConvexHull.{u1, u2} 𝕜 E _inst_1 _inst_2 _inst_3 s x hx)) s
but is expected to have type
  forall {𝕜 : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} 𝕜] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} 𝕜 E (StrictOrderedSemiring.toSemiring.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {s : Set.{u2} E} {x : E} (hx : Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u1, u2} 𝕜 E (OrderedCommSemiring.toOrderedSemiring.{u1} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) s)), HasSubset.Subset.{u2} (Set.{u2} E) (Set.instHasSubsetSet.{u2} E) (Finset.toSet.{u2} E (Caratheodory.minCardFinsetOfMemConvexHull.{u2, u1} 𝕜 E _inst_1 _inst_2 _inst_3 s x hx)) s
Case conversion may be inaccurate. Consider using '#align caratheodory.min_card_finset_of_mem_convex_hull_subseteq Caratheodory.minCardFinsetOfMemConvexHull_subseteqₓ'. -/
theorem minCardFinsetOfMemConvexHull_subseteq : ↑(minCardFinsetOfMemConvexHull hx) ⊆ s :=
  (Function.argminOn_mem _ _ { t : Finset E | ↑t ⊆ s ∧ x ∈ convexHull 𝕜 (t : Set E) } _).1
#align caratheodory.min_card_finset_of_mem_convex_hull_subseteq Caratheodory.minCardFinsetOfMemConvexHull_subseteq

/- warning: caratheodory.mem_min_card_finset_of_mem_convex_hull -> Caratheodory.mem_minCardFinsetOfMemConvexHull is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u2}} {E : Type.{u1}} [_inst_1 : LinearOrderedField.{u2} 𝕜] [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u2, u1} 𝕜 E (Ring.toSemiring.{u2} 𝕜 (StrictOrderedRing.toRing.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {s : Set.{u1} E} {x : E} (hx : Membership.Mem.{u1, u1} E (Set.{u1} E) (Set.hasMem.{u1} E) x (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (fun (_x : ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) => (Set.{u1} E) -> (Set.{u1} E)) (ClosureOperator.hasCoeToFun.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (convexHull.{u2, u1} 𝕜 E (StrictOrderedSemiring.toOrderedSemiring.{u2} 𝕜 (StrictOrderedRing.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3) s)), Membership.Mem.{u1, u1} E (Set.{u1} E) (Set.hasMem.{u1} E) x (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (fun (_x : ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) => (Set.{u1} E) -> (Set.{u1} E)) (ClosureOperator.hasCoeToFun.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (convexHull.{u2, u1} 𝕜 E (StrictOrderedSemiring.toOrderedSemiring.{u2} 𝕜 (StrictOrderedRing.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} E) (Set.{u1} E) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (Finset.Set.hasCoeT.{u1} E))) (Caratheodory.minCardFinsetOfMemConvexHull.{u1, u2} 𝕜 E _inst_1 _inst_2 _inst_3 s x hx)))
but is expected to have type
  forall {𝕜 : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} 𝕜] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} 𝕜 E (StrictOrderedSemiring.toSemiring.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {s : Set.{u2} E} {x : E} (hx : Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u1, u2} 𝕜 E (OrderedCommSemiring.toOrderedSemiring.{u1} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) s)), Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u1, u2} 𝕜 E (OrderedCommSemiring.toOrderedSemiring.{u1} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (Finset.toSet.{u2} E (Caratheodory.minCardFinsetOfMemConvexHull.{u2, u1} 𝕜 E _inst_1 _inst_2 _inst_3 s x hx)))
Case conversion may be inaccurate. Consider using '#align caratheodory.mem_min_card_finset_of_mem_convex_hull Caratheodory.mem_minCardFinsetOfMemConvexHullₓ'. -/
theorem mem_minCardFinsetOfMemConvexHull :
    x ∈ convexHull 𝕜 (minCardFinsetOfMemConvexHull hx : Set E) :=
  (Function.argminOn_mem _ _ { t : Finset E | ↑t ⊆ s ∧ x ∈ convexHull 𝕜 (t : Set E) } _).2
#align caratheodory.mem_min_card_finset_of_mem_convex_hull Caratheodory.mem_minCardFinsetOfMemConvexHull

/- warning: caratheodory.min_card_finset_of_mem_convex_hull_nonempty -> Caratheodory.minCardFinsetOfMemConvexHull_nonempty is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u2}} {E : Type.{u1}} [_inst_1 : LinearOrderedField.{u2} 𝕜] [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u2, u1} 𝕜 E (Ring.toSemiring.{u2} 𝕜 (StrictOrderedRing.toRing.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {s : Set.{u1} E} {x : E} (hx : Membership.Mem.{u1, u1} E (Set.{u1} E) (Set.hasMem.{u1} E) x (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (fun (_x : ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) => (Set.{u1} E) -> (Set.{u1} E)) (ClosureOperator.hasCoeToFun.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (convexHull.{u2, u1} 𝕜 E (StrictOrderedSemiring.toOrderedSemiring.{u2} 𝕜 (StrictOrderedRing.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3) s)), Finset.Nonempty.{u1} E (Caratheodory.minCardFinsetOfMemConvexHull.{u1, u2} 𝕜 E _inst_1 _inst_2 _inst_3 s x hx)
but is expected to have type
  forall {𝕜 : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} 𝕜] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} 𝕜 E (StrictOrderedSemiring.toSemiring.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {s : Set.{u2} E} {x : E} (hx : Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u1, u2} 𝕜 E (OrderedCommSemiring.toOrderedSemiring.{u1} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) s)), Finset.Nonempty.{u2} E (Caratheodory.minCardFinsetOfMemConvexHull.{u2, u1} 𝕜 E _inst_1 _inst_2 _inst_3 s x hx)
Case conversion may be inaccurate. Consider using '#align caratheodory.min_card_finset_of_mem_convex_hull_nonempty Caratheodory.minCardFinsetOfMemConvexHull_nonemptyₓ'. -/
theorem minCardFinsetOfMemConvexHull_nonempty : (minCardFinsetOfMemConvexHull hx).Nonempty :=
  by
  rw [← Finset.coe_nonempty, ← @convexHull_nonempty_iff 𝕜]
  exact ⟨x, mem_min_card_finset_of_mem_convex_hull hx⟩
#align caratheodory.min_card_finset_of_mem_convex_hull_nonempty Caratheodory.minCardFinsetOfMemConvexHull_nonempty

/- warning: caratheodory.min_card_finset_of_mem_convex_hull_card_le_card -> Caratheodory.minCardFinsetOfMemConvexHull_card_le_card is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u2}} {E : Type.{u1}} [_inst_1 : LinearOrderedField.{u2} 𝕜] [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u2, u1} 𝕜 E (Ring.toSemiring.{u2} 𝕜 (StrictOrderedRing.toRing.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {s : Set.{u1} E} {x : E} (hx : Membership.Mem.{u1, u1} E (Set.{u1} E) (Set.hasMem.{u1} E) x (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (fun (_x : ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) => (Set.{u1} E) -> (Set.{u1} E)) (ClosureOperator.hasCoeToFun.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (convexHull.{u2, u1} 𝕜 E (StrictOrderedSemiring.toOrderedSemiring.{u2} 𝕜 (StrictOrderedRing.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3) s)) {t : Finset.{u1} E}, (HasSubset.Subset.{u1} (Set.{u1} E) (Set.hasSubset.{u1} E) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} E) (Set.{u1} E) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (Finset.Set.hasCoeT.{u1} E))) t) s) -> (Membership.Mem.{u1, u1} E (Set.{u1} E) (Set.hasMem.{u1} E) x (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (fun (_x : ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) => (Set.{u1} E) -> (Set.{u1} E)) (ClosureOperator.hasCoeToFun.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (convexHull.{u2, u1} 𝕜 E (StrictOrderedSemiring.toOrderedSemiring.{u2} 𝕜 (StrictOrderedRing.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} E) (Set.{u1} E) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (Finset.Set.hasCoeT.{u1} E))) t))) -> (LE.le.{0} Nat Nat.hasLe (Finset.card.{u1} E (Caratheodory.minCardFinsetOfMemConvexHull.{u1, u2} 𝕜 E _inst_1 _inst_2 _inst_3 s x hx)) (Finset.card.{u1} E t))
but is expected to have type
  forall {𝕜 : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} 𝕜] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} 𝕜 E (StrictOrderedSemiring.toSemiring.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {s : Set.{u2} E} {x : E} (hx : Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u1, u2} 𝕜 E (OrderedCommSemiring.toOrderedSemiring.{u1} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) s)) {t : Finset.{u2} E}, (HasSubset.Subset.{u2} (Set.{u2} E) (Set.instHasSubsetSet.{u2} E) (Finset.toSet.{u2} E t) s) -> (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u1, u2} 𝕜 E (OrderedCommSemiring.toOrderedSemiring.{u1} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (Finset.toSet.{u2} E t))) -> (LE.le.{0} Nat instLENat (Finset.card.{u2} E (Caratheodory.minCardFinsetOfMemConvexHull.{u2, u1} 𝕜 E _inst_1 _inst_2 _inst_3 s x hx)) (Finset.card.{u2} E t))
Case conversion may be inaccurate. Consider using '#align caratheodory.min_card_finset_of_mem_convex_hull_card_le_card Caratheodory.minCardFinsetOfMemConvexHull_card_le_cardₓ'. -/
theorem minCardFinsetOfMemConvexHull_card_le_card {t : Finset E} (ht₁ : ↑t ⊆ s)
    (ht₂ : x ∈ convexHull 𝕜 (t : Set E)) : (minCardFinsetOfMemConvexHull hx).card ≤ t.card :=
  Function.argminOn_le _ _ _ ⟨ht₁, ht₂⟩
#align caratheodory.min_card_finset_of_mem_convex_hull_card_le_card Caratheodory.minCardFinsetOfMemConvexHull_card_le_card

/- warning: caratheodory.affine_independent_min_card_finset_of_mem_convex_hull -> Caratheodory.affineIndependent_minCardFinsetOfMemConvexHull is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u2}} {E : Type.{u1}} [_inst_1 : LinearOrderedField.{u2} 𝕜] [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u2, u1} 𝕜 E (Ring.toSemiring.{u2} 𝕜 (StrictOrderedRing.toRing.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {s : Set.{u1} E} {x : E} (hx : Membership.Mem.{u1, u1} E (Set.{u1} E) (Set.hasMem.{u1} E) x (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (fun (_x : ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) => (Set.{u1} E) -> (Set.{u1} E)) (ClosureOperator.hasCoeToFun.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (convexHull.{u2, u1} 𝕜 E (StrictOrderedSemiring.toOrderedSemiring.{u2} 𝕜 (StrictOrderedRing.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3) s)), AffineIndependent.{u2, u1, u1, u1} 𝕜 E E (StrictOrderedRing.toRing.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)) (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) (Caratheodory.minCardFinsetOfMemConvexHull.{u1, u2} 𝕜 E _inst_1 _inst_2 _inst_3 s x hx)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) (Caratheodory.minCardFinsetOfMemConvexHull.{u1, u2} 𝕜 E _inst_1 _inst_2 _inst_3 s x hx)) E (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) (Caratheodory.minCardFinsetOfMemConvexHull.{u1, u2} 𝕜 E _inst_1 _inst_2 _inst_3 s x hx)) E (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) (Caratheodory.minCardFinsetOfMemConvexHull.{u1, u2} 𝕜 E _inst_1 _inst_2 _inst_3 s x hx)) E (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) (Caratheodory.minCardFinsetOfMemConvexHull.{u1, u2} 𝕜 E _inst_1 _inst_2 _inst_3 s x hx)) E (coeSubtype.{succ u1} E (fun (x_1 : E) => Membership.Mem.{u1, u1} E (Finset.{u1} E) (Finset.hasMem.{u1} E) x_1 (Caratheodory.minCardFinsetOfMemConvexHull.{u1, u2} 𝕜 E _inst_1 _inst_2 _inst_3 s x hx)))))))
but is expected to have type
  forall {𝕜 : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} 𝕜] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} 𝕜 E (StrictOrderedSemiring.toSemiring.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {s : Set.{u2} E} {x : E} (hx : Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u1, u2} 𝕜 E (OrderedCommSemiring.toOrderedSemiring.{u1} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) s)), AffineIndependent.{u1, u2, u2, u2} 𝕜 E E (StrictOrderedRing.toRing.{u1} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u1} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u1} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u1} 𝕜 _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) (Subtype.{succ u2} E (fun (x_1 : E) => Membership.mem.{u2, u2} E (Finset.{u2} E) (Finset.instMembershipFinset.{u2} E) x_1 (Caratheodory.minCardFinsetOfMemConvexHull.{u2, u1} 𝕜 E _inst_1 _inst_2 _inst_3 s x hx))) (Subtype.val.{succ u2} E (fun (x_1 : E) => Membership.mem.{u2, u2} E (Finset.{u2} E) (Finset.instMembershipFinset.{u2} E) x_1 (Caratheodory.minCardFinsetOfMemConvexHull.{u2, u1} 𝕜 E _inst_1 _inst_2 _inst_3 s x hx)))
Case conversion may be inaccurate. Consider using '#align caratheodory.affine_independent_min_card_finset_of_mem_convex_hull Caratheodory.affineIndependent_minCardFinsetOfMemConvexHullₓ'. -/
theorem affineIndependent_minCardFinsetOfMemConvexHull :
    AffineIndependent 𝕜 (coe : minCardFinsetOfMemConvexHull hx → E) :=
  by
  let k := (min_card_finset_of_mem_convex_hull hx).card - 1
  have hk : (min_card_finset_of_mem_convex_hull hx).card = k + 1 :=
    (Nat.succ_pred_eq_of_pos
        (finset.card_pos.mpr (min_card_finset_of_mem_convex_hull_nonempty hx))).symm
  classical
    by_contra
    obtain ⟨p, hp⟩ := mem_convex_hull_erase h (mem_min_card_finset_of_mem_convex_hull hx)
    have contra :=
      min_card_finset_of_mem_convex_hull_card_le_card hx
        (Set.Subset.trans (Finset.erase_subset (↑p) (min_card_finset_of_mem_convex_hull hx))
          (min_card_finset_of_mem_convex_hull_subseteq hx))
        hp
    rw [← not_lt] at contra
    apply contra
    erw [card_erase_of_mem p.2, hk]
    exact lt_add_one _
#align caratheodory.affine_independent_min_card_finset_of_mem_convex_hull Caratheodory.affineIndependent_minCardFinsetOfMemConvexHull

end Caratheodory

variable {s : Set E}

/- warning: convex_hull_eq_union -> convexHull_eq_union is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u2}} {E : Type.{u1}} [_inst_1 : LinearOrderedField.{u2} 𝕜] [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u2, u1} 𝕜 E (Ring.toSemiring.{u2} 𝕜 (StrictOrderedRing.toRing.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {s : Set.{u1} E}, Eq.{succ u1} (Set.{u1} E) (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (fun (_x : ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) => (Set.{u1} E) -> (Set.{u1} E)) (ClosureOperator.hasCoeToFun.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (convexHull.{u2, u1} 𝕜 E (StrictOrderedSemiring.toOrderedSemiring.{u2} 𝕜 (StrictOrderedRing.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3) s) (Set.iUnion.{u1, succ u1} E (Finset.{u1} E) (fun (t : Finset.{u1} E) => Set.iUnion.{u1, 0} E (HasSubset.Subset.{u1} (Set.{u1} E) (Set.hasSubset.{u1} E) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} E) (Set.{u1} E) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (Finset.Set.hasCoeT.{u1} E))) t) s) (fun (hss : HasSubset.Subset.{u1} (Set.{u1} E) (Set.hasSubset.{u1} E) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} E) (Set.{u1} E) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (Finset.Set.hasCoeT.{u1} E))) t) s) => Set.iUnion.{u1, 0} E (AffineIndependent.{u2, u1, u1, u1} 𝕜 E E (StrictOrderedRing.toRing.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)) (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) t) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) t) E (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) t) E (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) t) E (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) t) E (coeSubtype.{succ u1} E (fun (x : E) => Membership.Mem.{u1, u1} E (Finset.{u1} E) (Finset.hasMem.{u1} E) x t))))))) (fun (hai : AffineIndependent.{u2, u1, u1, u1} 𝕜 E E (StrictOrderedRing.toRing.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)) (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) t) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) t) E (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) t) E (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) t) E (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) t) E (coeSubtype.{succ u1} E (fun (x : E) => Membership.Mem.{u1, u1} E (Finset.{u1} E) (Finset.hasMem.{u1} E) x t))))))) => coeFn.{succ u1, succ u1} (ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (fun (_x : ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) => (Set.{u1} E) -> (Set.{u1} E)) (ClosureOperator.hasCoeToFun.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (convexHull.{u2, u1} 𝕜 E (StrictOrderedSemiring.toOrderedSemiring.{u2} 𝕜 (StrictOrderedRing.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} E) (Set.{u1} E) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (Finset.Set.hasCoeT.{u1} E))) t)))))
but is expected to have type
  forall {𝕜 : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} 𝕜] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} 𝕜 E (StrictOrderedSemiring.toSemiring.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {s : Set.{u2} E}, Eq.{succ u2} (Set.{u2} E) (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u1, u2} 𝕜 E (OrderedCommSemiring.toOrderedSemiring.{u1} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) s) (Set.iUnion.{u2, succ u2} E (Finset.{u2} E) (fun (t : Finset.{u2} E) => Set.iUnion.{u2, 0} E (HasSubset.Subset.{u2} (Set.{u2} E) (Set.instHasSubsetSet.{u2} E) (Finset.toSet.{u2} E t) s) (fun (hss : HasSubset.Subset.{u2} (Set.{u2} E) (Set.instHasSubsetSet.{u2} E) (Finset.toSet.{u2} E t) s) => Set.iUnion.{u2, 0} E (AffineIndependent.{u1, u2, u2, u2} 𝕜 E E (StrictOrderedRing.toRing.{u1} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u1} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u1} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u1} 𝕜 _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Finset.{u2} E) (Finset.instMembershipFinset.{u2} E) x t)) (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Finset.{u2} E) (Finset.instMembershipFinset.{u2} E) x t))) (fun (hai : AffineIndependent.{u1, u2, u2, u2} 𝕜 E E (StrictOrderedRing.toRing.{u1} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u1} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u1} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u1} 𝕜 _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Finset.{u2} E) (Finset.instMembershipFinset.{u2} E) x t)) (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Finset.{u2} E) (Finset.instMembershipFinset.{u2} E) x t))) => OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u1, u2} 𝕜 E (OrderedCommSemiring.toOrderedSemiring.{u1} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (Finset.toSet.{u2} E t)))))
Case conversion may be inaccurate. Consider using '#align convex_hull_eq_union convexHull_eq_unionₓ'. -/
/-- **Carathéodory's convexity theorem** -/
theorem convexHull_eq_union :
    convexHull 𝕜 s =
      ⋃ (t : Finset E) (hss : ↑t ⊆ s) (hai : AffineIndependent 𝕜 (coe : t → E)), convexHull 𝕜 ↑t :=
  by
  apply Set.Subset.antisymm
  · intro x hx
    simp only [exists_prop, Set.mem_iUnion]
    exact
      ⟨Caratheodory.minCardFinsetOfMemConvexHull hx,
        Caratheodory.minCardFinsetOfMemConvexHull_subseteq hx,
        Caratheodory.affineIndependent_minCardFinsetOfMemConvexHull hx,
        Caratheodory.mem_minCardFinsetOfMemConvexHull hx⟩
  · iterate 3 convert Set.iUnion_subset _; intro
    exact convexHull_mono ‹_›
#align convex_hull_eq_union convexHull_eq_union

/- warning: eq_pos_convex_span_of_mem_convex_hull -> eq_pos_convex_span_of_mem_convexHull is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u2}} {E : Type.{u1}} [_inst_1 : LinearOrderedField.{u2} 𝕜] [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u2, u1} 𝕜 E (Ring.toSemiring.{u2} 𝕜 (StrictOrderedRing.toRing.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {s : Set.{u1} E} {x : E}, (Membership.Mem.{u1, u1} E (Set.{u1} E) (Set.hasMem.{u1} E) x (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (fun (_x : ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) => (Set.{u1} E) -> (Set.{u1} E)) (ClosureOperator.hasCoeToFun.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (convexHull.{u2, u1} 𝕜 E (StrictOrderedSemiring.toOrderedSemiring.{u2} 𝕜 (StrictOrderedRing.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3) s)) -> (Exists.{succ (succ u1)} Type.{u1} (fun (ι : Type.{u1}) => Exists.{succ u1} (Fintype.{u1} ι) (fun (_x : Fintype.{u1} ι) => Exists.{succ u1} (ι -> E) (fun (z : ι -> E) => Exists.{max (succ u1) (succ u2)} (ι -> 𝕜) (fun (w : ι -> 𝕜) => Exists.{0} (HasSubset.Subset.{u1} (Set.{u1} E) (Set.hasSubset.{u1} E) (Set.range.{u1, succ u1} E ι z) s) (fun (hss : HasSubset.Subset.{u1} (Set.{u1} E) (Set.hasSubset.{u1} E) (Set.range.{u1, succ u1} E ι z) s) => Exists.{0} (AffineIndependent.{u2, u1, u1, u1} 𝕜 E E (StrictOrderedRing.toRing.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)) ι z) (fun (hai : AffineIndependent.{u2, u1, u1, u1} 𝕜 E E (StrictOrderedRing.toRing.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)) ι z) => Exists.{0} (forall (i : ι), LT.lt.{u2} 𝕜 (Preorder.toHasLt.{u2} 𝕜 (PartialOrder.toPreorder.{u2} 𝕜 (OrderedAddCommGroup.toPartialOrder.{u2} 𝕜 (StrictOrderedRing.toOrderedAddCommGroup.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1))))))) (OfNat.ofNat.{u2} 𝕜 0 (OfNat.mk.{u2} 𝕜 0 (Zero.zero.{u2} 𝕜 (MulZeroClass.toHasZero.{u2} 𝕜 (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} 𝕜 (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} 𝕜 (NonAssocRing.toNonUnitalNonAssocRing.{u2} 𝕜 (Ring.toNonAssocRing.{u2} 𝕜 (StrictOrderedRing.toRing.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1)))))))))))) (w i)) (fun (hw : forall (i : ι), LT.lt.{u2} 𝕜 (Preorder.toHasLt.{u2} 𝕜 (PartialOrder.toPreorder.{u2} 𝕜 (OrderedAddCommGroup.toPartialOrder.{u2} 𝕜 (StrictOrderedRing.toOrderedAddCommGroup.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1))))))) (OfNat.ofNat.{u2} 𝕜 0 (OfNat.mk.{u2} 𝕜 0 (Zero.zero.{u2} 𝕜 (MulZeroClass.toHasZero.{u2} 𝕜 (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} 𝕜 (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} 𝕜 (NonAssocRing.toNonUnitalNonAssocRing.{u2} 𝕜 (Ring.toNonAssocRing.{u2} 𝕜 (StrictOrderedRing.toRing.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1)))))))))))) (w i)) => And (Eq.{succ u2} 𝕜 (Finset.sum.{u2, u1} 𝕜 ι (AddCommGroup.toAddCommMonoid.{u2} 𝕜 (OrderedAddCommGroup.toAddCommGroup.{u2} 𝕜 (StrictOrderedRing.toOrderedAddCommGroup.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1)))))) (Finset.univ.{u1} ι _x) (fun (i : ι) => w i)) (OfNat.ofNat.{u2} 𝕜 1 (OfNat.mk.{u2} 𝕜 1 (One.one.{u2} 𝕜 (AddMonoidWithOne.toOne.{u2} 𝕜 (AddGroupWithOne.toAddMonoidWithOne.{u2} 𝕜 (AddCommGroupWithOne.toAddGroupWithOne.{u2} 𝕜 (Ring.toAddCommGroupWithOne.{u2} 𝕜 (StrictOrderedRing.toRing.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1)))))))))))) (Eq.{succ u1} E (Finset.sum.{u1, u1} E ι (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (Finset.univ.{u1} ι _x) (fun (i : ι) => SMul.smul.{u2, u1} 𝕜 E (SMulZeroClass.toHasSmul.{u2, u1} 𝕜 E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u2, u1} 𝕜 E (MulZeroClass.toHasZero.{u2} 𝕜 (MulZeroOneClass.toMulZeroClass.{u2} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u2} 𝕜 (Semiring.toMonoidWithZero.{u2} 𝕜 (Ring.toSemiring.{u2} 𝕜 (StrictOrderedRing.toRing.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1))))))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕜 E (Semiring.toMonoidWithZero.{u2} 𝕜 (Ring.toSemiring.{u2} 𝕜 (StrictOrderedRing.toRing.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1)))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (Module.toMulActionWithZero.{u2, u1} 𝕜 E (Ring.toSemiring.{u2} 𝕜 (StrictOrderedRing.toRing.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3)))) (w i) (z i))) x)))))))))
but is expected to have type
  forall {𝕜 : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} 𝕜] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} 𝕜 E (StrictOrderedSemiring.toSemiring.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {s : Set.{u2} E} {x : E}, (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u1, u2} 𝕜 E (OrderedCommSemiring.toOrderedSemiring.{u1} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) s)) -> (Exists.{succ (succ u2)} Type.{u2} (fun (ι : Type.{u2}) => Exists.{succ u2} (Fintype.{u2} ι) (fun (_x : Fintype.{u2} ι) => Exists.{succ u2} (ι -> E) (fun (z : ι -> E) => Exists.{max (succ u2) (succ u1)} (ι -> 𝕜) (fun (w : ι -> 𝕜) => Exists.{0} (HasSubset.Subset.{u2} (Set.{u2} E) (Set.instHasSubsetSet.{u2} E) (Set.range.{u2, succ u2} E ι z) s) (fun (hss : HasSubset.Subset.{u2} (Set.{u2} E) (Set.instHasSubsetSet.{u2} E) (Set.range.{u2, succ u2} E ι z) s) => Exists.{0} (AffineIndependent.{u1, u2, u2, u2} 𝕜 E E (StrictOrderedRing.toRing.{u1} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u1} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u1} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u1} 𝕜 _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) ι z) (fun (hai : AffineIndependent.{u1, u2, u2, u2} 𝕜 E E (StrictOrderedRing.toRing.{u1} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u1} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u1} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u1} 𝕜 _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) ι z) => Exists.{0} (forall (i : ι), LT.lt.{u1} 𝕜 (Preorder.toLT.{u1} 𝕜 (PartialOrder.toPreorder.{u1} 𝕜 (StrictOrderedRing.toPartialOrder.{u1} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u1} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u1} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u1} 𝕜 _inst_1)))))) (OfNat.ofNat.{u1} 𝕜 0 (Zero.toOfNat0.{u1} 𝕜 (CommMonoidWithZero.toZero.{u1} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u1} 𝕜 (Semifield.toCommGroupWithZero.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 _inst_1))))))) (w i)) (fun (hw : forall (i : ι), LT.lt.{u1} 𝕜 (Preorder.toLT.{u1} 𝕜 (PartialOrder.toPreorder.{u1} 𝕜 (StrictOrderedRing.toPartialOrder.{u1} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u1} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u1} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u1} 𝕜 _inst_1)))))) (OfNat.ofNat.{u1} 𝕜 0 (Zero.toOfNat0.{u1} 𝕜 (CommMonoidWithZero.toZero.{u1} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u1} 𝕜 (Semifield.toCommGroupWithZero.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 _inst_1))))))) (w i)) => And (Eq.{succ u1} 𝕜 (Finset.sum.{u1, u2} 𝕜 ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} 𝕜 (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 _inst_1)))))) (Finset.univ.{u2} ι _x) (fun (i : ι) => w i)) (OfNat.ofNat.{u1} 𝕜 1 (One.toOfNat1.{u1} 𝕜 (Semiring.toOne.{u1} 𝕜 (StrictOrderedSemiring.toSemiring.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 _inst_1))))))))) (Eq.{succ u2} E (Finset.sum.{u2, u2} E ι (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (Finset.univ.{u2} ι _x) (fun (i : ι) => HSMul.hSMul.{u1, u2, u2} 𝕜 E E (instHSMul.{u1, u2} 𝕜 E (SMulZeroClass.toSMul.{u1, u2} 𝕜 E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} 𝕜 E (CommMonoidWithZero.toZero.{u1} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u1} 𝕜 (Semifield.toCommGroupWithZero.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (StrictOrderedSemiring.toSemiring.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 _inst_1)))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (StrictOrderedSemiring.toSemiring.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3))))) (w i) (z i))) x)))))))))
Case conversion may be inaccurate. Consider using '#align eq_pos_convex_span_of_mem_convex_hull eq_pos_convex_span_of_mem_convexHullₓ'. -/
/-- A more explicit version of `convex_hull_eq_union`. -/
theorem eq_pos_convex_span_of_mem_convexHull {x : E} (hx : x ∈ convexHull 𝕜 s) :
    ∃ (ι : Sort (u + 1))(_ : Fintype ι),
      ∃ (z : ι → E)(w : ι → 𝕜)(hss : Set.range z ⊆ s)(hai : AffineIndependent 𝕜 z)(hw :
        ∀ i, 0 < w i), (∑ i, w i) = 1 ∧ (∑ i, w i • z i) = x :=
  by
  rw [convexHull_eq_union] at hx
  simp only [exists_prop, Set.mem_iUnion] at hx
  obtain ⟨t, ht₁, ht₂, ht₃⟩ := hx
  simp only [t.convex_hull_eq, exists_prop, Set.mem_setOf_eq] at ht₃
  obtain ⟨w, hw₁, hw₂, hw₃⟩ := ht₃
  let t' := t.filter fun i => w i ≠ 0
  refine' ⟨t', t'.fintype_coe_sort, (coe : t' → E), w ∘ (coe : t' → E), _, _, _, _, _⟩
  · rw [Subtype.range_coe_subtype]
    exact subset.trans (Finset.filter_subset _ t) ht₁
  · exact ht₂.comp_embedding ⟨_, inclusion_injective (Finset.filter_subset (fun i => w i ≠ 0) t)⟩
  ·
    exact fun i =>
      (hw₁ _ (finset.mem_filter.mp i.2).1).lt_of_ne (finset.mem_filter.mp i.property).2.symm
  · erw [Finset.sum_attach, Finset.sum_filter_ne_zero, hw₂]
  · change (∑ i : t' in t'.attach, (fun e => w e • e) ↑i) = x
    erw [Finset.sum_attach, Finset.sum_filter_of_ne]
    · rw [t.center_mass_eq_of_sum_1 id hw₂] at hw₃
      exact hw₃
    · intro e he hwe contra
      apply hwe
      rw [contra, zero_smul]
#align eq_pos_convex_span_of_mem_convex_hull eq_pos_convex_span_of_mem_convexHull

