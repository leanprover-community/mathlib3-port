/-
Copyright (c) 2022 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov

! This file was ported from Lean 3 source module analysis.convex.partition_of_unity
! leanprover-community/mathlib commit 781cb2eed038c4caf53bdbd8d20a95e5822d77df
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Topology.PartitionOfUnity
import Mathbin.Analysis.Convex.Combination

/-!
# Partition of unity and convex sets

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file we prove the following lemma, see `exists_continuous_forall_mem_convex_of_local`. Let
`X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be a
topological real vector space. Let `t : X → set E` be a family of convex sets. Suppose that for each
point `x : X`, there exists a neighborhood `U ∈ 𝓝 X` and a function `g : X → E` that is continuous
on `U` and sends each `y ∈ U` to a point of `t y`. Then there exists a continuous map `g : C(X, E)`
such that `g x ∈ t x` for all `x`.

We also formulate a useful corollary, see `exists_continuous_forall_mem_convex_of_local_const`, that
assumes that local functions `g` are constants.

## Tags

partition of unity
-/


open Set Function

open BigOperators Topology

variable {ι X E : Type _} [TopologicalSpace X] [AddCommGroup E] [Module ℝ E]

/- warning: partition_of_unity.finsum_smul_mem_convex -> PartitionOfUnity.finsum_smul_mem_convex is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {X : Type.{u2}} {E : Type.{u3}} [_inst_1 : TopologicalSpace.{u2} X] [_inst_2 : AddCommGroup.{u3} E] [_inst_3 : Module.{0, u3} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u3} E _inst_2)] {s : Set.{u2} X} (f : PartitionOfUnity.{u1, u2} ι X _inst_1 s) {g : ι -> X -> E} {t : Set.{u3} E} {x : X}, (Membership.Mem.{u2, u2} X (Set.{u2} X) (Set.hasMem.{u2} X) x s) -> (forall (i : ι), (Ne.{1} Real (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (PartitionOfUnity.{u1, u2} ι X _inst_1 s) (fun (_x : PartitionOfUnity.{u1, u2} ι X _inst_1 s) => ι -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.hasCoeToFun.{u1, u2} ι X _inst_1 s) f i) x) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) -> (Membership.Mem.{u3, u3} E (Set.{u3} E) (Set.hasMem.{u3} E) (g i x) t)) -> (Convex.{0, u3} Real E Real.orderedSemiring (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (SMulZeroClass.toHasSmul.{0, u3} Real E (AddZeroClass.toHasZero.{u3} E (AddMonoid.toAddZeroClass.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (AddCommGroup.toAddCommMonoid.{u3} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{0, u3} Real E (MulZeroClass.toHasZero.{0} Real (MulZeroOneClass.toMulZeroClass.{0} Real (MonoidWithZero.toMulZeroOneClass.{0} Real (Semiring.toMonoidWithZero.{0} Real Real.semiring)))) (AddZeroClass.toHasZero.{u3} E (AddMonoid.toAddZeroClass.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (AddCommGroup.toAddCommMonoid.{u3} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{0, u3} Real E (Semiring.toMonoidWithZero.{0} Real Real.semiring) (AddZeroClass.toHasZero.{u3} E (AddMonoid.toAddZeroClass.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (AddCommGroup.toAddCommMonoid.{u3} E _inst_2)))) (Module.toMulActionWithZero.{0, u3} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3)))) t) -> (Membership.Mem.{u3, u3} E (Set.{u3} E) (Set.hasMem.{u3} E) (finsum.{u3, succ u1} E ι (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (fun (i : ι) => SMul.smul.{0, u3} Real E (SMulZeroClass.toHasSmul.{0, u3} Real E (AddZeroClass.toHasZero.{u3} E (AddMonoid.toAddZeroClass.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (AddCommGroup.toAddCommMonoid.{u3} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{0, u3} Real E (MulZeroClass.toHasZero.{0} Real (MulZeroOneClass.toMulZeroClass.{0} Real (MonoidWithZero.toMulZeroOneClass.{0} Real (Semiring.toMonoidWithZero.{0} Real Real.semiring)))) (AddZeroClass.toHasZero.{u3} E (AddMonoid.toAddZeroClass.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (AddCommGroup.toAddCommMonoid.{u3} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{0, u3} Real E (Semiring.toMonoidWithZero.{0} Real Real.semiring) (AddZeroClass.toHasZero.{u3} E (AddMonoid.toAddZeroClass.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (AddCommGroup.toAddCommMonoid.{u3} E _inst_2)))) (Module.toMulActionWithZero.{0, u3} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3)))) (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (PartitionOfUnity.{u1, u2} ι X _inst_1 s) (fun (_x : PartitionOfUnity.{u1, u2} ι X _inst_1 s) => ι -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.hasCoeToFun.{u1, u2} ι X _inst_1 s) f i) x) (g i x))) t)
but is expected to have type
  forall {ι : Type.{u2}} {X : Type.{u3}} {E : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} X] [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{0, u1} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {s : Set.{u3} X} (f : PartitionOfUnity.{u2, u3} ι X _inst_1 s) {g : ι -> X -> E} {t : Set.{u1} E} {x : X}, (Membership.mem.{u3, u3} X (Set.{u3} X) (Set.instMembershipSet.{u3} X) x s) -> (forall (i : ι), (Ne.{1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) (FunLike.coe.{succ u3, succ u3, 1} (ContinuousMap.{u3, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u3, u3, 0} (ContinuousMap.{u3, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u3, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.toFun.{u2, u3} ι X _inst_1 s f i) x) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) 0 (Zero.toOfNat0.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instZeroReal))) -> (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) (g i x) t)) -> (Convex.{0, u1} Real E Real.orderedSemiring (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{0, u1} Real E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{0, u1} Real E Real.instZeroReal (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real E Real.instMonoidWithZeroReal (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{0, u1} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3)))) t) -> (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) (finsum.{u1, succ u2} E ι (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (fun (i : ι) => HSMul.hSMul.{0, u1, u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) E E (instHSMul.{0, u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) E (SMulZeroClass.toSMul.{0, u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{0, u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) E Real.instZeroReal (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{0, u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) E Real.instMonoidWithZeroReal (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{0, u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) E Real.semiring (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3))))) (FunLike.coe.{succ u3, succ u3, 1} (ContinuousMap.{u3, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u3, u3, 0} (ContinuousMap.{u3, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u3, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.toFun.{u2, u3} ι X _inst_1 s f i) x) (g i x))) t)
Case conversion may be inaccurate. Consider using '#align partition_of_unity.finsum_smul_mem_convex PartitionOfUnity.finsum_smul_mem_convexₓ'. -/
theorem PartitionOfUnity.finsum_smul_mem_convex {s : Set X} (f : PartitionOfUnity ι X s)
    {g : ι → X → E} {t : Set E} {x : X} (hx : x ∈ s) (hg : ∀ i, f i x ≠ 0 → g i x ∈ t)
    (ht : Convex ℝ t) : (∑ᶠ i, f i x • g i x) ∈ t :=
  ht.finsum_mem (fun i => f.NonNeg _ _) (f.sum_eq_one hx) hg
#align partition_of_unity.finsum_smul_mem_convex PartitionOfUnity.finsum_smul_mem_convex

variable [NormalSpace X] [ParacompactSpace X] [TopologicalSpace E] [ContinuousAdd E]
  [ContinuousSMul ℝ E] {t : X → Set E}

/- warning: exists_continuous_forall_mem_convex_of_local -> exists_continuous_forall_mem_convex_of_local is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{0, u2} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : NormalSpace.{u1} X _inst_1] [_inst_5 : ParacompactSpace.{u1} X _inst_1] [_inst_6 : TopologicalSpace.{u2} E] [_inst_7 : ContinuousAdd.{u2} E _inst_6 (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))] [_inst_8 : ContinuousSMul.{0, u2} Real E (SMulZeroClass.toHasSmul.{0, u2} Real E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{0, u2} Real E (MulZeroClass.toHasZero.{0} Real (MulZeroOneClass.toMulZeroClass.{0} Real (MonoidWithZero.toMulZeroOneClass.{0} Real (Semiring.toMonoidWithZero.{0} Real Real.semiring)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{0, u2} Real E (Semiring.toMonoidWithZero.{0} Real Real.semiring) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{0, u2} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) _inst_6] {t : X -> (Set.{u2} E)}, (forall (x : X), Convex.{0, u2} Real E Real.orderedSemiring (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{0, u2} Real E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{0, u2} Real E (MulZeroClass.toHasZero.{0} Real (MulZeroOneClass.toMulZeroClass.{0} Real (MonoidWithZero.toMulZeroOneClass.{0} Real (Semiring.toMonoidWithZero.{0} Real Real.semiring)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{0, u2} Real E (Semiring.toMonoidWithZero.{0} Real Real.semiring) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{0, u2} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (t x)) -> (forall (x : X), Exists.{succ u1} (Set.{u1} X) (fun (U : Set.{u1} X) => Exists.{0} (Membership.Mem.{u1, u1} (Set.{u1} X) (Filter.{u1} X) (Filter.hasMem.{u1} X) U (nhds.{u1} X _inst_1 x)) (fun (H : Membership.Mem.{u1, u1} (Set.{u1} X) (Filter.{u1} X) (Filter.hasMem.{u1} X) U (nhds.{u1} X _inst_1 x)) => Exists.{max (succ u1) (succ u2)} (X -> E) (fun (g : X -> E) => And (ContinuousOn.{u1, u2} X E _inst_1 _inst_6 g U) (forall (y : X), (Membership.Mem.{u1, u1} X (Set.{u1} X) (Set.hasMem.{u1} X) y U) -> (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) (g y) (t y))))))) -> (Exists.{max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} X E _inst_1 _inst_6) (fun (g : ContinuousMap.{u1, u2} X E _inst_1 _inst_6) => forall (x : X), Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} X E _inst_1 _inst_6) (fun (_x : ContinuousMap.{u1, u2} X E _inst_1 _inst_6) => X -> E) (ContinuousMap.hasCoeToFun.{u1, u2} X E _inst_1 _inst_6) g x) (t x)))
but is expected to have type
  forall {X : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{0, u2} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : NormalSpace.{u1} X _inst_1] [_inst_5 : ParacompactSpace.{u1} X _inst_1] [_inst_6 : TopologicalSpace.{u2} E] [_inst_7 : ContinuousAdd.{u2} E _inst_6 (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))] [_inst_8 : ContinuousSMul.{0, u2} Real E (SMulZeroClass.toSMul.{0, u2} Real E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{0, u2} Real E Real.instZeroReal (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{0, u2} Real E Real.instMonoidWithZeroReal (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{0, u2} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) _inst_6] {t : X -> (Set.{u2} E)}, (forall (x : X), Convex.{0, u2} Real E Real.orderedSemiring (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{0, u2} Real E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{0, u2} Real E Real.instZeroReal (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{0, u2} Real E Real.instMonoidWithZeroReal (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{0, u2} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (t x)) -> (forall (x : X), Exists.{succ u1} (Set.{u1} X) (fun (U : Set.{u1} X) => And (Membership.mem.{u1, u1} (Set.{u1} X) (Filter.{u1} X) (instMembershipSetFilter.{u1} X) U (nhds.{u1} X _inst_1 x)) (Exists.{max (succ u1) (succ u2)} (X -> E) (fun (g : X -> E) => And (ContinuousOn.{u1, u2} X E _inst_1 _inst_6 g U) (forall (y : X), (Membership.mem.{u1, u1} X (Set.{u1} X) (Set.instMembershipSet.{u1} X) y U) -> (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) (g y) (t y))))))) -> (Exists.{max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} X E _inst_1 _inst_6) (fun (g : ContinuousMap.{u1, u2} X E _inst_1 _inst_6) => forall (x : X), Membership.mem.{u2, u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => E) x) (Set.{u2} E) (Set.instMembershipSet.{u2} E) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} X E _inst_1 _inst_6) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => E) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} X E _inst_1 _inst_6) X E _inst_1 _inst_6 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} X E _inst_1 _inst_6)) g x) (t x)))
Case conversion may be inaccurate. Consider using '#align exists_continuous_forall_mem_convex_of_local exists_continuous_forall_mem_convex_of_localₓ'. -/
/-- Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be
a topological real vector space. Let `t : X → set E` be a family of convex sets. Suppose that for
each point `x : X`, there exists a neighborhood `U ∈ 𝓝 X` and a function `g : X → E` that is
continuous on `U` and sends each `y ∈ U` to a point of `t y`. Then there exists a continuous map
`g : C(X, E)` such that `g x ∈ t x` for all `x`. See also
`exists_continuous_forall_mem_convex_of_local_const`. -/
theorem exists_continuous_forall_mem_convex_of_local (ht : ∀ x, Convex ℝ (t x))
    (H : ∀ x : X, ∃ U ∈ 𝓝 x, ∃ g : X → E, ContinuousOn g U ∧ ∀ y ∈ U, g y ∈ t y) :
    ∃ g : C(X, E), ∀ x, g x ∈ t x :=
  by
  choose U hU g hgc hgt using H
  obtain ⟨f, hf⟩ :=
    PartitionOfUnity.exists_isSubordinate isClosed_univ (fun x => interior (U x))
      (fun x => isOpen_interior) fun x hx => mem_Union.2 ⟨x, mem_interior_iff_mem_nhds.2 (hU x)⟩
  refine'
    ⟨⟨fun x => ∑ᶠ i, f i x • g i x,
        hf.continuous_finsum_smul (fun i => isOpen_interior) fun i => (hgc i).mono interior_subset⟩,
      fun x => f.finsum_smul_mem_convex (mem_univ x) (fun i hi => hgt _ _ _) (ht _)⟩
  exact interior_subset (hf _ <| subset_closure hi)
#align exists_continuous_forall_mem_convex_of_local exists_continuous_forall_mem_convex_of_local

/- warning: exists_continuous_forall_mem_convex_of_local_const -> exists_continuous_forall_mem_convex_of_local_const is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{0, u2} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : NormalSpace.{u1} X _inst_1] [_inst_5 : ParacompactSpace.{u1} X _inst_1] [_inst_6 : TopologicalSpace.{u2} E] [_inst_7 : ContinuousAdd.{u2} E _inst_6 (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))] [_inst_8 : ContinuousSMul.{0, u2} Real E (SMulZeroClass.toHasSmul.{0, u2} Real E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{0, u2} Real E (MulZeroClass.toHasZero.{0} Real (MulZeroOneClass.toMulZeroClass.{0} Real (MonoidWithZero.toMulZeroOneClass.{0} Real (Semiring.toMonoidWithZero.{0} Real Real.semiring)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{0, u2} Real E (Semiring.toMonoidWithZero.{0} Real Real.semiring) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{0, u2} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) _inst_6] {t : X -> (Set.{u2} E)}, (forall (x : X), Convex.{0, u2} Real E Real.orderedSemiring (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{0, u2} Real E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{0, u2} Real E (MulZeroClass.toHasZero.{0} Real (MulZeroOneClass.toMulZeroClass.{0} Real (MonoidWithZero.toMulZeroOneClass.{0} Real (Semiring.toMonoidWithZero.{0} Real Real.semiring)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{0, u2} Real E (Semiring.toMonoidWithZero.{0} Real Real.semiring) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{0, u2} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (t x)) -> (forall (x : X), Exists.{succ u2} E (fun (c : E) => Filter.Eventually.{u1} X (fun (y : X) => Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) c (t y)) (nhds.{u1} X _inst_1 x))) -> (Exists.{max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} X E _inst_1 _inst_6) (fun (g : ContinuousMap.{u1, u2} X E _inst_1 _inst_6) => forall (x : X), Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} X E _inst_1 _inst_6) (fun (_x : ContinuousMap.{u1, u2} X E _inst_1 _inst_6) => X -> E) (ContinuousMap.hasCoeToFun.{u1, u2} X E _inst_1 _inst_6) g x) (t x)))
but is expected to have type
  forall {X : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{0, u2} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : NormalSpace.{u1} X _inst_1] [_inst_5 : ParacompactSpace.{u1} X _inst_1] [_inst_6 : TopologicalSpace.{u2} E] [_inst_7 : ContinuousAdd.{u2} E _inst_6 (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))] [_inst_8 : ContinuousSMul.{0, u2} Real E (SMulZeroClass.toSMul.{0, u2} Real E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{0, u2} Real E Real.instZeroReal (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{0, u2} Real E Real.instMonoidWithZeroReal (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{0, u2} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) _inst_6] {t : X -> (Set.{u2} E)}, (forall (x : X), Convex.{0, u2} Real E Real.orderedSemiring (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{0, u2} Real E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{0, u2} Real E Real.instZeroReal (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{0, u2} Real E Real.instMonoidWithZeroReal (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{0, u2} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (t x)) -> (forall (x : X), Exists.{succ u2} E (fun (c : E) => Filter.Eventually.{u1} X (fun (y : X) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) c (t y)) (nhds.{u1} X _inst_1 x))) -> (Exists.{max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} X E _inst_1 _inst_6) (fun (g : ContinuousMap.{u1, u2} X E _inst_1 _inst_6) => forall (x : X), Membership.mem.{u2, u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => E) x) (Set.{u2} E) (Set.instMembershipSet.{u2} E) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} X E _inst_1 _inst_6) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => E) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} X E _inst_1 _inst_6) X E _inst_1 _inst_6 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} X E _inst_1 _inst_6)) g x) (t x)))
Case conversion may be inaccurate. Consider using '#align exists_continuous_forall_mem_convex_of_local_const exists_continuous_forall_mem_convex_of_local_constₓ'. -/
/-- Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be
a topological real vector space. Let `t : X → set E` be a family of convex sets. Suppose that for
each point `x : X`, there exists a vector `c : E` that belongs to `t y` for all `y` in a
neighborhood of `x`. Then there exists a continuous map `g : C(X, E)` such that `g x ∈ t x` for all
`x`. See also `exists_continuous_forall_mem_convex_of_local`. -/
theorem exists_continuous_forall_mem_convex_of_local_const (ht : ∀ x, Convex ℝ (t x))
    (H : ∀ x : X, ∃ c : E, ∀ᶠ y in 𝓝 x, c ∈ t y) : ∃ g : C(X, E), ∀ x, g x ∈ t x :=
  exists_continuous_forall_mem_convex_of_local ht fun x =>
    let ⟨c, hc⟩ := H x
    ⟨_, hc, fun _ => c, continuousOn_const, fun y => id⟩
#align exists_continuous_forall_mem_convex_of_local_const exists_continuous_forall_mem_convex_of_local_const

