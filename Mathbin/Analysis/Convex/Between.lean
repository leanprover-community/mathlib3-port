/-
Copyright (c) 2022 Joseph Myers. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joseph Myers

! This file was ported from Lean 3 source module analysis.convex.between
! leanprover-community/mathlib commit 38df578a6450a8c5142b3727e3ae894c2300cae0
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Set.Intervals.Group
import Mathbin.Analysis.Convex.Segment
import Mathbin.LinearAlgebra.AffineSpace.FiniteDimensional
import Mathbin.Tactic.FieldSimp
import Mathbin.Algebra.CharP.Invertible

/-!
# Betweenness in affine spaces

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file defines notions of a point in an affine space being between two given points.

## Main definitions

* `affine_segment R x y`: The segment of points weakly between `x` and `y`.
* `wbtw R x y z`: The point `y` is weakly between `x` and `z`.
* `sbtw R x y z`: The point `y` is strictly between `x` and `z`.

-/


variable (R : Type _) {V V' P P' : Type _}

open AffineEquiv AffineMap

open BigOperators

section OrderedRing

variable [OrderedRing R] [AddCommGroup V] [Module R V] [AddTorsor V P]

variable [AddCommGroup V'] [Module R V'] [AddTorsor V' P']

include V

#print affineSegment /-
/-- The segment of points weakly between `x` and `y`. When convexity is refactored to support
abstract affine combination spaces, this will no longer need to be a separate definition from
`segment`. However, lemmas involving `+ᵥ` or `-ᵥ` will still be relevant after such a
refactoring, as distinct from versions involving `+` or `-` in a module. -/
def affineSegment (x y : P) :=
  lineMap x y '' Set.Icc (0 : R) 1
#align affine_segment affineSegment
-/

#print affineSegment_eq_segment /-
theorem affineSegment_eq_segment (x y : V) : affineSegment R x y = segment R x y := by
  rw [segment_eq_image_lineMap, affineSegment]
#align affine_segment_eq_segment affineSegment_eq_segment
-/

/- warning: affine_segment_comm -> affineSegment_comm is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (x : P) (y : P), Eq.{succ u3} (Set.{u3} P) (affineSegment.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y) (affineSegment.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 y x)
but is expected to have type
  forall (R : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u2} R] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} R V (OrderedSemiring.toSemiring.{u2} R (OrderedRing.toOrderedSemiring.{u2} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] (x : P) (y : P), Eq.{succ u3} (Set.{u3} P) (affineSegment.{u2, u1, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y) (affineSegment.{u2, u1, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 y x)
Case conversion may be inaccurate. Consider using '#align affine_segment_comm affineSegment_commₓ'. -/
theorem affineSegment_comm (x y : P) : affineSegment R x y = affineSegment R y x :=
  by
  refine' Set.ext fun z => _
  constructor <;>
    · rintro ⟨t, ht, hxy⟩
      refine' ⟨1 - t, _, _⟩
      · rwa [Set.sub_mem_Icc_iff_right, sub_self, sub_zero]
      · rwa [line_map_apply_one_sub]
#align affine_segment_comm affineSegment_comm

/- warning: left_mem_affine_segment -> left_mem_affineSegment is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (x : P) (y : P), Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) x (affineSegment.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y)
but is expected to have type
  forall (R : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u2} R] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} R V (OrderedSemiring.toSemiring.{u2} R (OrderedRing.toOrderedSemiring.{u2} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] (x : P) (y : P), Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) x (affineSegment.{u2, u1, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y)
Case conversion may be inaccurate. Consider using '#align left_mem_affine_segment left_mem_affineSegmentₓ'. -/
theorem left_mem_affineSegment (x y : P) : x ∈ affineSegment R x y :=
  ⟨0, Set.left_mem_Icc.2 zero_le_one, lineMap_apply_zero _ _⟩
#align left_mem_affine_segment left_mem_affineSegment

/- warning: right_mem_affine_segment -> right_mem_affineSegment is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (x : P) (y : P), Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) y (affineSegment.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y)
but is expected to have type
  forall (R : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u2} R] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} R V (OrderedSemiring.toSemiring.{u2} R (OrderedRing.toOrderedSemiring.{u2} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] (x : P) (y : P), Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) y (affineSegment.{u2, u1, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y)
Case conversion may be inaccurate. Consider using '#align right_mem_affine_segment right_mem_affineSegmentₓ'. -/
theorem right_mem_affineSegment (x y : P) : y ∈ affineSegment R x y :=
  ⟨1, Set.right_mem_Icc.2 zero_le_one, lineMap_apply_one _ _⟩
#align right_mem_affine_segment right_mem_affineSegment

include V'

variable {R}

/- warning: affine_segment_image -> affineSegment_image is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {V' : Type.{u3}} {P : Type.{u4}} {P' : Type.{u5}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : AddCommGroup.{u3} V'] [_inst_6 : Module.{u1, u3} R V' (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V' _inst_5)] [_inst_7 : AddTorsor.{u3, u5} V' P' (AddCommGroup.toAddGroup.{u3} V' _inst_5)] (f : AffineMap.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (x : P) (y : P), Eq.{succ u5} (Set.{u5} P') (Set.image.{u4, u5} P P' (coeFn.{max (succ u2) (succ u4) (succ u3) (succ u5), max (succ u4) (succ u5)} (AffineMap.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P -> P') (AffineMap.hasCoeToFun.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f) (affineSegment.{u1, u2, u4} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y)) (affineSegment.{u1, u3, u5} R V' P' _inst_1 _inst_5 _inst_6 _inst_7 (coeFn.{max (succ u2) (succ u4) (succ u3) (succ u5), max (succ u4) (succ u5)} (AffineMap.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P -> P') (AffineMap.hasCoeToFun.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f x) (coeFn.{max (succ u2) (succ u4) (succ u3) (succ u5), max (succ u4) (succ u5)} (AffineMap.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P -> P') (AffineMap.hasCoeToFun.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f y))
but is expected to have type
  forall {R : Type.{u5}} {V : Type.{u4}} {V' : Type.{u2}} {P : Type.{u3}} {P' : Type.{u1}} [_inst_1 : OrderedRing.{u5} R] [_inst_2 : AddCommGroup.{u4} V] [_inst_3 : Module.{u5, u4} R V (OrderedSemiring.toSemiring.{u5} R (OrderedRing.toOrderedSemiring.{u5} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V P (AddCommGroup.toAddGroup.{u4} V _inst_2)] [_inst_5 : AddCommGroup.{u2} V'] [_inst_6 : Module.{u5, u2} R V' (OrderedSemiring.toSemiring.{u5} R (OrderedRing.toOrderedSemiring.{u5} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V' _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V' P' (AddCommGroup.toAddGroup.{u2} V' _inst_5)] (f : AffineMap.{u5, u4, u3, u2, u1} R V P V' P' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (x : P) (y : P), Eq.{succ u1} (Set.{u1} P') (Set.image.{u3, u1} P P' (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u5, u4, u3, u2, u1} R V P V' P' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P) => P') _x) (AffineMap.funLike.{u5, u4, u3, u2, u1} R V P V' P' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f) (affineSegment.{u5, u4, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y)) (affineSegment.{u5, u2, u1} R V' ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P) => P') x) _inst_1 _inst_5 _inst_6 _inst_7 (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u5, u4, u3, u2, u1} R V P V' P' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P) => P') _x) (AffineMap.funLike.{u5, u4, u3, u2, u1} R V P V' P' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f x) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u5, u4, u3, u2, u1} R V P V' P' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P) => P') _x) (AffineMap.funLike.{u5, u4, u3, u2, u1} R V P V' P' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f y))
Case conversion may be inaccurate. Consider using '#align affine_segment_image affineSegment_imageₓ'. -/
@[simp]
theorem affineSegment_image (f : P →ᵃ[R] P') (x y : P) :
    f '' affineSegment R x y = affineSegment R (f x) (f y) :=
  by
  rw [affineSegment, affineSegment, Set.image_image, ← comp_line_map]
  rfl
#align affine_segment_image affineSegment_image

omit V'

variable (R)

#print affineSegment_const_vadd_image /-
@[simp]
theorem affineSegment_const_vadd_image (x y : P) (v : V) :
    (· +ᵥ ·) v '' affineSegment R x y = affineSegment R (v +ᵥ x) (v +ᵥ y) :=
  affineSegment_image (AffineEquiv.constVAdd R P v : P →ᵃ[R] P) x y
#align affine_segment_const_vadd_image affineSegment_const_vadd_image
-/

#print affineSegment_vadd_const_image /-
@[simp]
theorem affineSegment_vadd_const_image (x y : V) (p : P) :
    (· +ᵥ p) '' affineSegment R x y = affineSegment R (x +ᵥ p) (y +ᵥ p) :=
  affineSegment_image (AffineEquiv.vaddConst R p : V →ᵃ[R] P) x y
#align affine_segment_vadd_const_image affineSegment_vadd_const_image
-/

/- warning: affine_segment_const_vsub_image -> affineSegment_const_vsub_image is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (x : P) (y : P) (p : P), Eq.{succ u2} (Set.{u2} V) (Set.image.{u3, u2} P V (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p) (affineSegment.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y)) (affineSegment.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p x) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p y))
but is expected to have type
  forall (R : Type.{u1}) {V : Type.{u3}} {P : Type.{u2}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u1, u3} R V (OrderedSemiring.toSemiring.{u1} R (OrderedRing.toOrderedSemiring.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] (x : P) (y : P) (p : P), Eq.{succ u3} (Set.{u3} V) (Set.image.{u2, u3} P V (fun (x._@.Mathlib.Analysis.Convex.Between._hyg.933 : P) => VSub.vsub.{u3, u2} V P (AddTorsor.toVSub.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2) _inst_4) p x._@.Mathlib.Analysis.Convex.Between._hyg.933) (affineSegment.{u1, u3, u2} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y)) (affineSegment.{u1, u3, u3} R V V _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u3} V (AddCommGroup.toAddGroup.{u3} V _inst_2)) (VSub.vsub.{u3, u2} V P (AddTorsor.toVSub.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2) _inst_4) p x) (VSub.vsub.{u3, u2} V P (AddTorsor.toVSub.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2) _inst_4) p y))
Case conversion may be inaccurate. Consider using '#align affine_segment_const_vsub_image affineSegment_const_vsub_imageₓ'. -/
@[simp]
theorem affineSegment_const_vsub_image (x y p : P) :
    (· -ᵥ ·) p '' affineSegment R x y = affineSegment R (p -ᵥ x) (p -ᵥ y) :=
  affineSegment_image (AffineEquiv.constVSub R p : P →ᵃ[R] V) x y
#align affine_segment_const_vsub_image affineSegment_const_vsub_image

/- warning: affine_segment_vsub_const_image -> affineSegment_vsub_const_image is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (x : P) (y : P) (p : P), Eq.{succ u2} (Set.{u2} V) (Set.image.{u3, u2} P V (fun (_x : P) => VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) _x p) (affineSegment.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y)) (affineSegment.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) x p) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) y p))
but is expected to have type
  forall (R : Type.{u1}) {V : Type.{u3}} {P : Type.{u2}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u1, u3} R V (OrderedSemiring.toSemiring.{u1} R (OrderedRing.toOrderedSemiring.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] (x : P) (y : P) (p : P), Eq.{succ u3} (Set.{u3} V) (Set.image.{u2, u3} P V (fun (_x : P) => VSub.vsub.{u3, u2} V P (AddTorsor.toVSub.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2) _inst_4) _x p) (affineSegment.{u1, u3, u2} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y)) (affineSegment.{u1, u3, u3} R V V _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u3} V (AddCommGroup.toAddGroup.{u3} V _inst_2)) (VSub.vsub.{u3, u2} V P (AddTorsor.toVSub.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2) _inst_4) x p) (VSub.vsub.{u3, u2} V P (AddTorsor.toVSub.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2) _inst_4) y p))
Case conversion may be inaccurate. Consider using '#align affine_segment_vsub_const_image affineSegment_vsub_const_imageₓ'. -/
@[simp]
theorem affineSegment_vsub_const_image (x y p : P) :
    (· -ᵥ p) '' affineSegment R x y = affineSegment R (x -ᵥ p) (y -ᵥ p) :=
  affineSegment_image ((AffineEquiv.vaddConst R p).symm : P →ᵃ[R] V) x y
#align affine_segment_vsub_const_image affineSegment_vsub_const_image

variable {R}

#print mem_const_vadd_affineSegment /-
@[simp]
theorem mem_const_vadd_affineSegment {x y z : P} (v : V) :
    v +ᵥ z ∈ affineSegment R (v +ᵥ x) (v +ᵥ y) ↔ z ∈ affineSegment R x y := by
  rw [← affineSegment_const_vadd_image, (AddAction.injective v).mem_set_image]
#align mem_const_vadd_affine_segment mem_const_vadd_affineSegment
-/

#print mem_vadd_const_affineSegment /-
@[simp]
theorem mem_vadd_const_affineSegment {x y z : V} (p : P) :
    z +ᵥ p ∈ affineSegment R (x +ᵥ p) (y +ᵥ p) ↔ z ∈ affineSegment R x y := by
  rw [← affineSegment_vadd_const_image, (vadd_right_injective p).mem_set_image]
#align mem_vadd_const_affine_segment mem_vadd_const_affineSegment
-/

variable {R}

/- warning: mem_const_vsub_affine_segment -> mem_const_vsub_affineSegment is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P} (p : P), Iff (Membership.Mem.{u2, u2} V (Set.{u2} V) (Set.hasMem.{u2} V) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p z) (affineSegment.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p x) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p y))) (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) z (affineSegment.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y))
but is expected to have type
  forall {R : Type.{u1}} {V : Type.{u3}} {P : Type.{u2}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u1, u3} R V (OrderedSemiring.toSemiring.{u1} R (OrderedRing.toOrderedSemiring.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {x : P} {y : P} {z : P} (p : P), Iff (Membership.mem.{u3, u3} V (Set.{u3} V) (Set.instMembershipSet.{u3} V) (VSub.vsub.{u3, u2} V P (AddTorsor.toVSub.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2) _inst_4) p z) (affineSegment.{u1, u3, u3} R V V _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u3} V (AddCommGroup.toAddGroup.{u3} V _inst_2)) (VSub.vsub.{u3, u2} V P (AddTorsor.toVSub.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2) _inst_4) p x) (VSub.vsub.{u3, u2} V P (AddTorsor.toVSub.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2) _inst_4) p y))) (Membership.mem.{u2, u2} P (Set.{u2} P) (Set.instMembershipSet.{u2} P) z (affineSegment.{u1, u3, u2} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y))
Case conversion may be inaccurate. Consider using '#align mem_const_vsub_affine_segment mem_const_vsub_affineSegmentₓ'. -/
@[simp]
theorem mem_const_vsub_affineSegment {x y z : P} (p : P) :
    p -ᵥ z ∈ affineSegment R (p -ᵥ x) (p -ᵥ y) ↔ z ∈ affineSegment R x y := by
  rw [← affineSegment_const_vsub_image, (vsub_right_injective p).mem_set_image]
#align mem_const_vsub_affine_segment mem_const_vsub_affineSegment

/- warning: mem_vsub_const_affine_segment -> mem_vsub_const_affineSegment is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P} (p : P), Iff (Membership.Mem.{u2, u2} V (Set.{u2} V) (Set.hasMem.{u2} V) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) z p) (affineSegment.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) x p) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) y p))) (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) z (affineSegment.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y))
but is expected to have type
  forall {R : Type.{u1}} {V : Type.{u3}} {P : Type.{u2}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u1, u3} R V (OrderedSemiring.toSemiring.{u1} R (OrderedRing.toOrderedSemiring.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {x : P} {y : P} {z : P} (p : P), Iff (Membership.mem.{u3, u3} V (Set.{u3} V) (Set.instMembershipSet.{u3} V) (VSub.vsub.{u3, u2} V P (AddTorsor.toVSub.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2) _inst_4) z p) (affineSegment.{u1, u3, u3} R V V _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u3} V (AddCommGroup.toAddGroup.{u3} V _inst_2)) (VSub.vsub.{u3, u2} V P (AddTorsor.toVSub.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2) _inst_4) x p) (VSub.vsub.{u3, u2} V P (AddTorsor.toVSub.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2) _inst_4) y p))) (Membership.mem.{u2, u2} P (Set.{u2} P) (Set.instMembershipSet.{u2} P) z (affineSegment.{u1, u3, u2} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y))
Case conversion may be inaccurate. Consider using '#align mem_vsub_const_affine_segment mem_vsub_const_affineSegmentₓ'. -/
@[simp]
theorem mem_vsub_const_affineSegment {x y z : P} (p : P) :
    z -ᵥ p ∈ affineSegment R (x -ᵥ p) (y -ᵥ p) ↔ z ∈ affineSegment R x y := by
  rw [← affineSegment_vsub_const_image, (vsub_left_injective p).mem_set_image]
#align mem_vsub_const_affine_segment mem_vsub_const_affineSegment

variable (R)

#print Wbtw /-
/-- The point `y` is weakly between `x` and `z`. -/
def Wbtw (x y z : P) : Prop :=
  y ∈ affineSegment R x z
#align wbtw Wbtw
-/

#print Sbtw /-
/-- The point `y` is strictly between `x` and `z`. -/
def Sbtw (x y z : P) : Prop :=
  Wbtw R x y z ∧ y ≠ x ∧ y ≠ z
#align sbtw Sbtw
-/

variable {R}

include V'

/- warning: wbtw.map -> Wbtw.map is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {V' : Type.{u3}} {P : Type.{u4}} {P' : Type.{u5}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : AddCommGroup.{u3} V'] [_inst_6 : Module.{u1, u3} R V' (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V' _inst_5)] [_inst_7 : AddTorsor.{u3, u5} V' P' (AddCommGroup.toAddGroup.{u3} V' _inst_5)] {x : P} {y : P} {z : P}, (Wbtw.{u1, u2, u4} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (forall (f : AffineMap.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Wbtw.{u1, u3, u5} R V' P' _inst_1 _inst_5 _inst_6 _inst_7 (coeFn.{max (succ u2) (succ u4) (succ u3) (succ u5), max (succ u4) (succ u5)} (AffineMap.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P -> P') (AffineMap.hasCoeToFun.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f x) (coeFn.{max (succ u2) (succ u4) (succ u3) (succ u5), max (succ u4) (succ u5)} (AffineMap.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P -> P') (AffineMap.hasCoeToFun.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f y) (coeFn.{max (succ u2) (succ u4) (succ u3) (succ u5), max (succ u4) (succ u5)} (AffineMap.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P -> P') (AffineMap.hasCoeToFun.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f z))
but is expected to have type
  forall {R : Type.{u5}} {V : Type.{u4}} {V' : Type.{u2}} {P : Type.{u3}} {P' : Type.{u1}} [_inst_1 : OrderedRing.{u5} R] [_inst_2 : AddCommGroup.{u4} V] [_inst_3 : Module.{u5, u4} R V (OrderedSemiring.toSemiring.{u5} R (OrderedRing.toOrderedSemiring.{u5} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V P (AddCommGroup.toAddGroup.{u4} V _inst_2)] [_inst_5 : AddCommGroup.{u2} V'] [_inst_6 : Module.{u5, u2} R V' (OrderedSemiring.toSemiring.{u5} R (OrderedRing.toOrderedSemiring.{u5} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V' _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V' P' (AddCommGroup.toAddGroup.{u2} V' _inst_5)] {x : P} {y : P} {z : P}, (Wbtw.{u5, u4, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (forall (f : AffineMap.{u5, u4, u3, u2, u1} R V P V' P' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Wbtw.{u5, u2, u1} R V' ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P) => P') x) _inst_1 _inst_5 _inst_6 _inst_7 (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u5, u4, u3, u2, u1} R V P V' P' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P) => P') _x) (AffineMap.funLike.{u5, u4, u3, u2, u1} R V P V' P' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f x) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u5, u4, u3, u2, u1} R V P V' P' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P) => P') _x) (AffineMap.funLike.{u5, u4, u3, u2, u1} R V P V' P' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f y) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u5, u4, u3, u2, u1} R V P V' P' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P) => P') _x) (AffineMap.funLike.{u5, u4, u3, u2, u1} R V P V' P' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f z))
Case conversion may be inaccurate. Consider using '#align wbtw.map Wbtw.mapₓ'. -/
theorem Wbtw.map {x y z : P} (h : Wbtw R x y z) (f : P →ᵃ[R] P') : Wbtw R (f x) (f y) (f z) :=
  by
  rw [Wbtw, ← affineSegment_image]
  exact Set.mem_image_of_mem _ h
#align wbtw.map Wbtw.map

/- warning: function.injective.wbtw_map_iff -> Function.Injective.wbtw_map_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {V' : Type.{u3}} {P : Type.{u4}} {P' : Type.{u5}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : AddCommGroup.{u3} V'] [_inst_6 : Module.{u1, u3} R V' (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V' _inst_5)] [_inst_7 : AddTorsor.{u3, u5} V' P' (AddCommGroup.toAddGroup.{u3} V' _inst_5)] {x : P} {y : P} {z : P} {f : AffineMap.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7}, (Function.Injective.{succ u4, succ u5} P P' (coeFn.{max (succ u2) (succ u4) (succ u3) (succ u5), max (succ u4) (succ u5)} (AffineMap.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P -> P') (AffineMap.hasCoeToFun.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f)) -> (Iff (Wbtw.{u1, u3, u5} R V' P' _inst_1 _inst_5 _inst_6 _inst_7 (coeFn.{max (succ u2) (succ u4) (succ u3) (succ u5), max (succ u4) (succ u5)} (AffineMap.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P -> P') (AffineMap.hasCoeToFun.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f x) (coeFn.{max (succ u2) (succ u4) (succ u3) (succ u5), max (succ u4) (succ u5)} (AffineMap.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P -> P') (AffineMap.hasCoeToFun.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f y) (coeFn.{max (succ u2) (succ u4) (succ u3) (succ u5), max (succ u4) (succ u5)} (AffineMap.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P -> P') (AffineMap.hasCoeToFun.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f z)) (Wbtw.{u1, u2, u4} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z))
but is expected to have type
  forall {R : Type.{u5}} {V : Type.{u4}} {V' : Type.{u2}} {P : Type.{u3}} {P' : Type.{u1}} [_inst_1 : OrderedRing.{u5} R] [_inst_2 : AddCommGroup.{u4} V] [_inst_3 : Module.{u5, u4} R V (OrderedSemiring.toSemiring.{u5} R (OrderedRing.toOrderedSemiring.{u5} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V P (AddCommGroup.toAddGroup.{u4} V _inst_2)] [_inst_5 : AddCommGroup.{u2} V'] [_inst_6 : Module.{u5, u2} R V' (OrderedSemiring.toSemiring.{u5} R (OrderedRing.toOrderedSemiring.{u5} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V' _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V' P' (AddCommGroup.toAddGroup.{u2} V' _inst_5)] {x : P} {y : P} {z : P} {f : AffineMap.{u5, u4, u3, u2, u1} R V P V' P' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7}, (Function.Injective.{succ u3, succ u1} P P' (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u5, u4, u3, u2, u1} R V P V' P' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P) => P') _x) (AffineMap.funLike.{u5, u4, u3, u2, u1} R V P V' P' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f)) -> (Iff (Wbtw.{u5, u2, u1} R V' ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P) => P') x) _inst_1 _inst_5 _inst_6 _inst_7 (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u5, u4, u3, u2, u1} R V P V' P' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P) => P') _x) (AffineMap.funLike.{u5, u4, u3, u2, u1} R V P V' P' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f x) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u5, u4, u3, u2, u1} R V P V' P' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P) => P') _x) (AffineMap.funLike.{u5, u4, u3, u2, u1} R V P V' P' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f y) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u5, u4, u3, u2, u1} R V P V' P' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P) => P') _x) (AffineMap.funLike.{u5, u4, u3, u2, u1} R V P V' P' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f z)) (Wbtw.{u5, u4, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z))
Case conversion may be inaccurate. Consider using '#align function.injective.wbtw_map_iff Function.Injective.wbtw_map_iffₓ'. -/
theorem Function.Injective.wbtw_map_iff {x y z : P} {f : P →ᵃ[R] P'} (hf : Function.Injective f) :
    Wbtw R (f x) (f y) (f z) ↔ Wbtw R x y z :=
  by
  refine' ⟨fun h => _, fun h => h.map _⟩
  rwa [Wbtw, ← affineSegment_image, hf.mem_set_image] at h
#align function.injective.wbtw_map_iff Function.Injective.wbtw_map_iff

/- warning: function.injective.sbtw_map_iff -> Function.Injective.sbtw_map_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {V' : Type.{u3}} {P : Type.{u4}} {P' : Type.{u5}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : AddCommGroup.{u3} V'] [_inst_6 : Module.{u1, u3} R V' (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V' _inst_5)] [_inst_7 : AddTorsor.{u3, u5} V' P' (AddCommGroup.toAddGroup.{u3} V' _inst_5)] {x : P} {y : P} {z : P} {f : AffineMap.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7}, (Function.Injective.{succ u4, succ u5} P P' (coeFn.{max (succ u2) (succ u4) (succ u3) (succ u5), max (succ u4) (succ u5)} (AffineMap.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P -> P') (AffineMap.hasCoeToFun.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f)) -> (Iff (Sbtw.{u1, u3, u5} R V' P' _inst_1 _inst_5 _inst_6 _inst_7 (coeFn.{max (succ u2) (succ u4) (succ u3) (succ u5), max (succ u4) (succ u5)} (AffineMap.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P -> P') (AffineMap.hasCoeToFun.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f x) (coeFn.{max (succ u2) (succ u4) (succ u3) (succ u5), max (succ u4) (succ u5)} (AffineMap.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P -> P') (AffineMap.hasCoeToFun.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f y) (coeFn.{max (succ u2) (succ u4) (succ u3) (succ u5), max (succ u4) (succ u5)} (AffineMap.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P -> P') (AffineMap.hasCoeToFun.{u1, u2, u4, u3, u5} R V P V' P' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f z)) (Sbtw.{u1, u2, u4} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z))
but is expected to have type
  forall {R : Type.{u5}} {V : Type.{u4}} {V' : Type.{u2}} {P : Type.{u3}} {P' : Type.{u1}} [_inst_1 : OrderedRing.{u5} R] [_inst_2 : AddCommGroup.{u4} V] [_inst_3 : Module.{u5, u4} R V (OrderedSemiring.toSemiring.{u5} R (OrderedRing.toOrderedSemiring.{u5} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V P (AddCommGroup.toAddGroup.{u4} V _inst_2)] [_inst_5 : AddCommGroup.{u2} V'] [_inst_6 : Module.{u5, u2} R V' (OrderedSemiring.toSemiring.{u5} R (OrderedRing.toOrderedSemiring.{u5} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V' _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V' P' (AddCommGroup.toAddGroup.{u2} V' _inst_5)] {x : P} {y : P} {z : P} {f : AffineMap.{u5, u4, u3, u2, u1} R V P V' P' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7}, (Function.Injective.{succ u3, succ u1} P P' (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u5, u4, u3, u2, u1} R V P V' P' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P) => P') _x) (AffineMap.funLike.{u5, u4, u3, u2, u1} R V P V' P' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f)) -> (Iff (Sbtw.{u5, u2, u1} R V' ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P) => P') x) _inst_1 _inst_5 _inst_6 _inst_7 (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u5, u4, u3, u2, u1} R V P V' P' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P) => P') _x) (AffineMap.funLike.{u5, u4, u3, u2, u1} R V P V' P' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f x) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u5, u4, u3, u2, u1} R V P V' P' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P) => P') _x) (AffineMap.funLike.{u5, u4, u3, u2, u1} R V P V' P' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f y) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u5, u4, u3, u2, u1} R V P V' P' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P) => P') _x) (AffineMap.funLike.{u5, u4, u3, u2, u1} R V P V' P' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f z)) (Sbtw.{u5, u4, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z))
Case conversion may be inaccurate. Consider using '#align function.injective.sbtw_map_iff Function.Injective.sbtw_map_iffₓ'. -/
theorem Function.Injective.sbtw_map_iff {x y z : P} {f : P →ᵃ[R] P'} (hf : Function.Injective f) :
    Sbtw R (f x) (f y) (f z) ↔ Sbtw R x y z := by simp_rw [Sbtw, hf.wbtw_map_iff, hf.ne_iff]
#align function.injective.sbtw_map_iff Function.Injective.sbtw_map_iff

/- warning: affine_equiv.wbtw_map_iff -> AffineEquiv.wbtw_map_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {V' : Type.{u3}} {P : Type.{u4}} {P' : Type.{u5}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : AddCommGroup.{u3} V'] [_inst_6 : Module.{u1, u3} R V' (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V' _inst_5)] [_inst_7 : AddTorsor.{u3, u5} V' P' (AddCommGroup.toAddGroup.{u3} V' _inst_5)] {x : P} {y : P} {z : P} (f : AffineEquiv.{u1, u4, u5, u2, u3} R P P' V V' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Iff (Wbtw.{u1, u3, u5} R V' P' _inst_1 _inst_5 _inst_6 _inst_7 (coeFn.{max (succ u4) (succ u5) (succ u2) (succ u3), max (succ u4) (succ u5)} (AffineEquiv.{u1, u4, u5, u2, u3} R P P' V V' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u4, u5, u2, u3} R P P' V V' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P -> P') (AffineEquiv.hasCoeToFun.{u1, u4, u5, u2, u3} R P P' V V' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f x) (coeFn.{max (succ u4) (succ u5) (succ u2) (succ u3), max (succ u4) (succ u5)} (AffineEquiv.{u1, u4, u5, u2, u3} R P P' V V' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u4, u5, u2, u3} R P P' V V' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P -> P') (AffineEquiv.hasCoeToFun.{u1, u4, u5, u2, u3} R P P' V V' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f y) (coeFn.{max (succ u4) (succ u5) (succ u2) (succ u3), max (succ u4) (succ u5)} (AffineEquiv.{u1, u4, u5, u2, u3} R P P' V V' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u4, u5, u2, u3} R P P' V V' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P -> P') (AffineEquiv.hasCoeToFun.{u1, u4, u5, u2, u3} R P P' V V' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f z)) (Wbtw.{u1, u2, u4} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z)
but is expected to have type
  forall {R : Type.{u5}} {V : Type.{u2}} {V' : Type.{u1}} {P : Type.{u4}} {P' : Type.{u3}} [_inst_1 : OrderedRing.{u5} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u5, u2} R V (OrderedSemiring.toSemiring.{u5} R (OrderedRing.toOrderedSemiring.{u5} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : AddCommGroup.{u1} V'] [_inst_6 : Module.{u5, u1} R V' (OrderedSemiring.toSemiring.{u5} R (OrderedRing.toOrderedSemiring.{u5} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V' _inst_5)] [_inst_7 : AddTorsor.{u1, u3} V' P' (AddCommGroup.toAddGroup.{u1} V' _inst_5)] {x : P} {y : P} {z : P} (f : AffineEquiv.{u5, u4, u3, u2, u1} R P P' V V' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Iff (Wbtw.{u5, u1, u3} R V' ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1470 : P) => P') x) _inst_1 _inst_5 _inst_6 _inst_7 (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} R P P' V V' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1470 : P) => P') _x) (EmbeddingLike.toFunLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} R P P' V V' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P P' (EquivLike.toEmbeddingLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} R P P' V V' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P P' (AffineEquiv.equivLike.{u5, u4, u3, u2, u1} R P P' V V' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) f x) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} R P P' V V' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1470 : P) => P') _x) (EmbeddingLike.toFunLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} R P P' V V' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P P' (EquivLike.toEmbeddingLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} R P P' V V' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P P' (AffineEquiv.equivLike.{u5, u4, u3, u2, u1} R P P' V V' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) f y) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} R P P' V V' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1470 : P) => P') _x) (EmbeddingLike.toFunLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} R P P' V V' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P P' (EquivLike.toEmbeddingLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} R P P' V V' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P P' (AffineEquiv.equivLike.{u5, u4, u3, u2, u1} R P P' V V' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) f z)) (Wbtw.{u5, u2, u4} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z)
Case conversion may be inaccurate. Consider using '#align affine_equiv.wbtw_map_iff AffineEquiv.wbtw_map_iffₓ'. -/
@[simp]
theorem AffineEquiv.wbtw_map_iff {x y z : P} (f : P ≃ᵃ[R] P') :
    Wbtw R (f x) (f y) (f z) ↔ Wbtw R x y z :=
  by
  refine' Function.Injective.wbtw_map_iff (_ : Function.Injective f.to_affine_map)
  exact f.injective
#align affine_equiv.wbtw_map_iff AffineEquiv.wbtw_map_iff

/- warning: affine_equiv.sbtw_map_iff -> AffineEquiv.sbtw_map_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {V' : Type.{u3}} {P : Type.{u4}} {P' : Type.{u5}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : AddCommGroup.{u3} V'] [_inst_6 : Module.{u1, u3} R V' (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V' _inst_5)] [_inst_7 : AddTorsor.{u3, u5} V' P' (AddCommGroup.toAddGroup.{u3} V' _inst_5)] {x : P} {y : P} {z : P} (f : AffineEquiv.{u1, u4, u5, u2, u3} R P P' V V' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Iff (Sbtw.{u1, u3, u5} R V' P' _inst_1 _inst_5 _inst_6 _inst_7 (coeFn.{max (succ u4) (succ u5) (succ u2) (succ u3), max (succ u4) (succ u5)} (AffineEquiv.{u1, u4, u5, u2, u3} R P P' V V' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u4, u5, u2, u3} R P P' V V' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P -> P') (AffineEquiv.hasCoeToFun.{u1, u4, u5, u2, u3} R P P' V V' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f x) (coeFn.{max (succ u4) (succ u5) (succ u2) (succ u3), max (succ u4) (succ u5)} (AffineEquiv.{u1, u4, u5, u2, u3} R P P' V V' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u4, u5, u2, u3} R P P' V V' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P -> P') (AffineEquiv.hasCoeToFun.{u1, u4, u5, u2, u3} R P P' V V' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f y) (coeFn.{max (succ u4) (succ u5) (succ u2) (succ u3), max (succ u4) (succ u5)} (AffineEquiv.{u1, u4, u5, u2, u3} R P P' V V' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u4, u5, u2, u3} R P P' V V' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P -> P') (AffineEquiv.hasCoeToFun.{u1, u4, u5, u2, u3} R P P' V V' (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f z)) (Sbtw.{u1, u2, u4} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z)
but is expected to have type
  forall {R : Type.{u5}} {V : Type.{u2}} {V' : Type.{u1}} {P : Type.{u4}} {P' : Type.{u3}} [_inst_1 : OrderedRing.{u5} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u5, u2} R V (OrderedSemiring.toSemiring.{u5} R (OrderedRing.toOrderedSemiring.{u5} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : AddCommGroup.{u1} V'] [_inst_6 : Module.{u5, u1} R V' (OrderedSemiring.toSemiring.{u5} R (OrderedRing.toOrderedSemiring.{u5} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V' _inst_5)] [_inst_7 : AddTorsor.{u1, u3} V' P' (AddCommGroup.toAddGroup.{u1} V' _inst_5)] {x : P} {y : P} {z : P} (f : AffineEquiv.{u5, u4, u3, u2, u1} R P P' V V' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Iff (Sbtw.{u5, u1, u3} R V' ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1470 : P) => P') x) _inst_1 _inst_5 _inst_6 _inst_7 (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} R P P' V V' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1470 : P) => P') _x) (EmbeddingLike.toFunLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} R P P' V V' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P P' (EquivLike.toEmbeddingLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} R P P' V V' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P P' (AffineEquiv.equivLike.{u5, u4, u3, u2, u1} R P P' V V' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) f x) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} R P P' V V' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1470 : P) => P') _x) (EmbeddingLike.toFunLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} R P P' V V' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P P' (EquivLike.toEmbeddingLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} R P P' V V' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P P' (AffineEquiv.equivLike.{u5, u4, u3, u2, u1} R P P' V V' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) f y) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} R P P' V V' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1470 : P) => P') _x) (EmbeddingLike.toFunLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} R P P' V V' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P P' (EquivLike.toEmbeddingLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} R P P' V V' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P P' (AffineEquiv.equivLike.{u5, u4, u3, u2, u1} R P P' V V' (OrderedRing.toRing.{u5} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) f z)) (Sbtw.{u5, u2, u4} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z)
Case conversion may be inaccurate. Consider using '#align affine_equiv.sbtw_map_iff AffineEquiv.sbtw_map_iffₓ'. -/
@[simp]
theorem AffineEquiv.sbtw_map_iff {x y z : P} (f : P ≃ᵃ[R] P') :
    Sbtw R (f x) (f y) (f z) ↔ Sbtw R x y z :=
  by
  refine' Function.Injective.sbtw_map_iff (_ : Function.Injective f.to_affine_map)
  exact f.injective
#align affine_equiv.sbtw_map_iff AffineEquiv.sbtw_map_iff

omit V'

/- warning: wbtw_const_vadd_iff -> wbtw_const_vadd_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P} (v : V), Iff (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) v x) (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) v y) (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) v z)) (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z)
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P} (v : V), Iff (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 (HVAdd.hVAdd.{u2, u1, u1} V P P (instHVAdd.{u2, u1} V P (AddAction.toVAdd.{u2, u1} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4))) v x) (HVAdd.hVAdd.{u2, u1, u1} V P P (instHVAdd.{u2, u1} V P (AddAction.toVAdd.{u2, u1} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4))) v y) (HVAdd.hVAdd.{u2, u1, u1} V P P (instHVAdd.{u2, u1} V P (AddAction.toVAdd.{u2, u1} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4))) v z)) (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z)
Case conversion may be inaccurate. Consider using '#align wbtw_const_vadd_iff wbtw_const_vadd_iffₓ'. -/
@[simp]
theorem wbtw_const_vadd_iff {x y z : P} (v : V) :
    Wbtw R (v +ᵥ x) (v +ᵥ y) (v +ᵥ z) ↔ Wbtw R x y z :=
  mem_const_vadd_affineSegment _
#align wbtw_const_vadd_iff wbtw_const_vadd_iff

/- warning: wbtw_vadd_const_iff -> wbtw_vadd_const_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : V} {y : V} {z : V} (p : P), Iff (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) x p) (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) y p) (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) z p)) (Wbtw.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)) x y z)
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : V} {y : V} {z : V} (p : P), Iff (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 (HVAdd.hVAdd.{u2, u1, u1} V P P (instHVAdd.{u2, u1} V P (AddAction.toVAdd.{u2, u1} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4))) x p) (HVAdd.hVAdd.{u2, u1, u1} V P P (instHVAdd.{u2, u1} V P (AddAction.toVAdd.{u2, u1} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4))) y p) (HVAdd.hVAdd.{u2, u1, u1} V P P (instHVAdd.{u2, u1} V P (AddAction.toVAdd.{u2, u1} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4))) z p)) (Wbtw.{u3, u2, u2} R V V _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)) x y z)
Case conversion may be inaccurate. Consider using '#align wbtw_vadd_const_iff wbtw_vadd_const_iffₓ'. -/
@[simp]
theorem wbtw_vadd_const_iff {x y z : V} (p : P) :
    Wbtw R (x +ᵥ p) (y +ᵥ p) (z +ᵥ p) ↔ Wbtw R x y z :=
  mem_vadd_const_affineSegment _
#align wbtw_vadd_const_iff wbtw_vadd_const_iff

/- warning: wbtw_const_vsub_iff -> wbtw_const_vsub_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P} (p : P), Iff (Wbtw.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p x) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p y) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p z)) (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z)
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P} (p : P), Iff (Wbtw.{u3, u2, u2} R V V _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)) (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p x) (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p y) (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p z)) (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z)
Case conversion may be inaccurate. Consider using '#align wbtw_const_vsub_iff wbtw_const_vsub_iffₓ'. -/
@[simp]
theorem wbtw_const_vsub_iff {x y z : P} (p : P) :
    Wbtw R (p -ᵥ x) (p -ᵥ y) (p -ᵥ z) ↔ Wbtw R x y z :=
  mem_const_vsub_affineSegment _
#align wbtw_const_vsub_iff wbtw_const_vsub_iff

/- warning: wbtw_vsub_const_iff -> wbtw_vsub_const_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P} (p : P), Iff (Wbtw.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) x p) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) y p) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) z p)) (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z)
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P} (p : P), Iff (Wbtw.{u3, u2, u2} R V V _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)) (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) x p) (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) y p) (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) z p)) (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z)
Case conversion may be inaccurate. Consider using '#align wbtw_vsub_const_iff wbtw_vsub_const_iffₓ'. -/
@[simp]
theorem wbtw_vsub_const_iff {x y z : P} (p : P) :
    Wbtw R (x -ᵥ p) (y -ᵥ p) (z -ᵥ p) ↔ Wbtw R x y z :=
  mem_vsub_const_affineSegment _
#align wbtw_vsub_const_iff wbtw_vsub_const_iff

/- warning: sbtw_const_vadd_iff -> sbtw_const_vadd_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P} (v : V), Iff (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) v x) (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) v y) (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) v z)) (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z)
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P} (v : V), Iff (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 (HVAdd.hVAdd.{u2, u1, u1} V P P (instHVAdd.{u2, u1} V P (AddAction.toVAdd.{u2, u1} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4))) v x) (HVAdd.hVAdd.{u2, u1, u1} V P P (instHVAdd.{u2, u1} V P (AddAction.toVAdd.{u2, u1} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4))) v y) (HVAdd.hVAdd.{u2, u1, u1} V P P (instHVAdd.{u2, u1} V P (AddAction.toVAdd.{u2, u1} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4))) v z)) (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z)
Case conversion may be inaccurate. Consider using '#align sbtw_const_vadd_iff sbtw_const_vadd_iffₓ'. -/
@[simp]
theorem sbtw_const_vadd_iff {x y z : P} (v : V) :
    Sbtw R (v +ᵥ x) (v +ᵥ y) (v +ᵥ z) ↔ Sbtw R x y z := by
  simp_rw [Sbtw, wbtw_const_vadd_iff, (AddAction.injective v).ne_iff]
#align sbtw_const_vadd_iff sbtw_const_vadd_iff

/- warning: sbtw_vadd_const_iff -> sbtw_vadd_const_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : V} {y : V} {z : V} (p : P), Iff (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) x p) (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) y p) (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) z p)) (Sbtw.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)) x y z)
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : V} {y : V} {z : V} (p : P), Iff (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 (HVAdd.hVAdd.{u2, u1, u1} V P P (instHVAdd.{u2, u1} V P (AddAction.toVAdd.{u2, u1} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4))) x p) (HVAdd.hVAdd.{u2, u1, u1} V P P (instHVAdd.{u2, u1} V P (AddAction.toVAdd.{u2, u1} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4))) y p) (HVAdd.hVAdd.{u2, u1, u1} V P P (instHVAdd.{u2, u1} V P (AddAction.toVAdd.{u2, u1} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4))) z p)) (Sbtw.{u3, u2, u2} R V V _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)) x y z)
Case conversion may be inaccurate. Consider using '#align sbtw_vadd_const_iff sbtw_vadd_const_iffₓ'. -/
@[simp]
theorem sbtw_vadd_const_iff {x y z : V} (p : P) :
    Sbtw R (x +ᵥ p) (y +ᵥ p) (z +ᵥ p) ↔ Sbtw R x y z := by
  simp_rw [Sbtw, wbtw_vadd_const_iff, (vadd_right_injective p).ne_iff]
#align sbtw_vadd_const_iff sbtw_vadd_const_iff

/- warning: sbtw_const_vsub_iff -> sbtw_const_vsub_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P} (p : P), Iff (Sbtw.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p x) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p y) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p z)) (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z)
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P} (p : P), Iff (Sbtw.{u3, u2, u2} R V V _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)) (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p x) (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p y) (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p z)) (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z)
Case conversion may be inaccurate. Consider using '#align sbtw_const_vsub_iff sbtw_const_vsub_iffₓ'. -/
@[simp]
theorem sbtw_const_vsub_iff {x y z : P} (p : P) :
    Sbtw R (p -ᵥ x) (p -ᵥ y) (p -ᵥ z) ↔ Sbtw R x y z := by
  simp_rw [Sbtw, wbtw_const_vsub_iff, (vsub_right_injective p).ne_iff]
#align sbtw_const_vsub_iff sbtw_const_vsub_iff

/- warning: sbtw_vsub_const_iff -> sbtw_vsub_const_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P} (p : P), Iff (Sbtw.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) x p) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) y p) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) z p)) (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z)
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P} (p : P), Iff (Sbtw.{u3, u2, u2} R V V _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)) (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) x p) (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) y p) (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) z p)) (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z)
Case conversion may be inaccurate. Consider using '#align sbtw_vsub_const_iff sbtw_vsub_const_iffₓ'. -/
@[simp]
theorem sbtw_vsub_const_iff {x y z : P} (p : P) :
    Sbtw R (x -ᵥ p) (y -ᵥ p) (z -ᵥ p) ↔ Sbtw R x y z := by
  simp_rw [Sbtw, wbtw_vsub_const_iff, (vsub_left_injective p).ne_iff]
#align sbtw_vsub_const_iff sbtw_vsub_const_iff

/- warning: sbtw.wbtw -> Sbtw.wbtw is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z)
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z)
Case conversion may be inaccurate. Consider using '#align sbtw.wbtw Sbtw.wbtwₓ'. -/
theorem Sbtw.wbtw {x y z : P} (h : Sbtw R x y z) : Wbtw R x y z :=
  h.1
#align sbtw.wbtw Sbtw.wbtw

/- warning: sbtw.ne_left -> Sbtw.ne_left is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Ne.{succ u3} P y x)
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Ne.{succ u1} P y x)
Case conversion may be inaccurate. Consider using '#align sbtw.ne_left Sbtw.ne_leftₓ'. -/
theorem Sbtw.ne_left {x y z : P} (h : Sbtw R x y z) : y ≠ x :=
  h.2.1
#align sbtw.ne_left Sbtw.ne_left

/- warning: sbtw.left_ne -> Sbtw.left_ne is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Ne.{succ u3} P x y)
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Ne.{succ u1} P x y)
Case conversion may be inaccurate. Consider using '#align sbtw.left_ne Sbtw.left_neₓ'. -/
theorem Sbtw.left_ne {x y z : P} (h : Sbtw R x y z) : x ≠ y :=
  h.2.1.symm
#align sbtw.left_ne Sbtw.left_ne

/- warning: sbtw.ne_right -> Sbtw.ne_right is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Ne.{succ u3} P y z)
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Ne.{succ u1} P y z)
Case conversion may be inaccurate. Consider using '#align sbtw.ne_right Sbtw.ne_rightₓ'. -/
theorem Sbtw.ne_right {x y z : P} (h : Sbtw R x y z) : y ≠ z :=
  h.2.2
#align sbtw.ne_right Sbtw.ne_right

/- warning: sbtw.right_ne -> Sbtw.right_ne is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Ne.{succ u3} P z y)
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Ne.{succ u1} P z y)
Case conversion may be inaccurate. Consider using '#align sbtw.right_ne Sbtw.right_neₓ'. -/
theorem Sbtw.right_ne {x y z : P} (h : Sbtw R x y z) : z ≠ y :=
  h.2.2.symm
#align sbtw.right_ne Sbtw.right_ne

/- warning: sbtw.mem_image_Ioo -> Sbtw.mem_image_Ioo is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) y (Set.image.{u1, u3} R P (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} R R R V P (OrderedRing.toRing.{u1} R _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} R R R V P (OrderedRing.toRing.{u1} R _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) _inst_2 _inst_3 _inst_4) => R -> P) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} R R R V P (OrderedRing.toRing.{u1} R _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} R V P (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 x z)) (Set.Ioo.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (OrderedRing.toOrderedAddCommGroup.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))))))))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Membership.mem.{u1, u1} P (Set.{u1} P) (Set.instMembershipSet.{u1} P) y (Set.image.{u3, u1} R P (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u3, u3, u3, u2, u1} R R R V P (OrderedRing.toRing.{u3} R _inst_1) (Ring.toAddCommGroup.{u3} R (OrderedRing.toRing.{u3} R _inst_1)) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (OrderedRing.toRing.{u3} R _inst_1))) (addGroupIsAddTorsor.{u3} R (AddGroupWithOne.toAddGroup.{u3} R (Ring.toAddGroupWithOne.{u3} R (OrderedRing.toRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : R) => P) _x) (AffineMap.funLike.{u3, u3, u3, u2, u1} R R R V P (OrderedRing.toRing.{u3} R _inst_1) (Ring.toAddCommGroup.{u3} R (OrderedRing.toRing.{u3} R _inst_1)) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (OrderedRing.toRing.{u3} R _inst_1))) (addGroupIsAddTorsor.{u3} R (AddGroupWithOne.toAddGroup.{u3} R (Ring.toAddGroupWithOne.{u3} R (OrderedRing.toRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u3, u2, u1} R V P (OrderedRing.toRing.{u3} R _inst_1) _inst_2 _inst_3 _inst_4 x z)) (Set.Ioo.{u3} R (PartialOrder.toPreorder.{u3} R (OrderedRing.toPartialOrder.{u3} R _inst_1)) (OfNat.ofNat.{u3} R 0 (Zero.toOfNat0.{u3} R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))))) (OfNat.ofNat.{u3} R 1 (One.toOfNat1.{u3} R (Semiring.toOne.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align sbtw.mem_image_Ioo Sbtw.mem_image_Iooₓ'. -/
theorem Sbtw.mem_image_Ioo {x y z : P} (h : Sbtw R x y z) : y ∈ lineMap x z '' Set.Ioo (0 : R) 1 :=
  by
  rcases h with ⟨⟨t, ht, rfl⟩, hyx, hyz⟩
  rcases Set.eq_endpoints_or_mem_Ioo_of_mem_Icc ht with (rfl | rfl | ho)
  · exfalso
    simpa using hyx
  · exfalso
    simpa using hyz
  · exact ⟨t, ho, rfl⟩
#align sbtw.mem_image_Ioo Sbtw.mem_image_Ioo

/- warning: wbtw.mem_affine_span -> Wbtw.mem_affineSpan is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} R V P (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} R V P (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} R V P (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4)) y (affineSpan.{u1, u2, u3} R V P (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) x (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) z))))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} R V P (OrderedRing.toRing.{u3} R _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} R V P (OrderedRing.toRing.{u3} R _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} R V P (OrderedRing.toRing.{u3} R _inst_1) _inst_2 _inst_3 _inst_4)) y (affineSpan.{u3, u2, u1} R V P (OrderedRing.toRing.{u3} R _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) x (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) z))))
Case conversion may be inaccurate. Consider using '#align wbtw.mem_affine_span Wbtw.mem_affineSpanₓ'. -/
theorem Wbtw.mem_affineSpan {x y z : P} (h : Wbtw R x y z) : y ∈ line[R, x, z] :=
  by
  rcases h with ⟨r, ⟨-, rfl⟩⟩
  exact line_map_mem_affine_span_pair _ _ _
#align wbtw.mem_affine_span Wbtw.mem_affineSpan

/- warning: wbtw_comm -> wbtw_comm is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, Iff (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 z y x)
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, Iff (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 z y x)
Case conversion may be inaccurate. Consider using '#align wbtw_comm wbtw_commₓ'. -/
theorem wbtw_comm {x y z : P} : Wbtw R x y z ↔ Wbtw R z y x := by
  rw [Wbtw, Wbtw, affineSegment_comm]
#align wbtw_comm wbtw_comm

/- warning: wbtw.symm -> Wbtw.symm is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 z y x)
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 z y x)
Case conversion may be inaccurate. Consider using '#align wbtw.symm Wbtw.symmₓ'. -/
alias wbtw_comm ↔ Wbtw.symm _
#align wbtw.symm Wbtw.symm

/- warning: sbtw_comm -> sbtw_comm is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, Iff (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 z y x)
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, Iff (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 z y x)
Case conversion may be inaccurate. Consider using '#align sbtw_comm sbtw_commₓ'. -/
theorem sbtw_comm {x y z : P} : Sbtw R x y z ↔ Sbtw R z y x := by
  rw [Sbtw, Sbtw, wbtw_comm, ← and_assoc', ← and_assoc', and_right_comm]
#align sbtw_comm sbtw_comm

/- warning: sbtw.symm -> Sbtw.symm is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 z y x)
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 z y x)
Case conversion may be inaccurate. Consider using '#align sbtw.symm Sbtw.symmₓ'. -/
alias sbtw_comm ↔ Sbtw.symm _
#align sbtw.symm Sbtw.symm

variable (R)

/- warning: wbtw_self_left -> wbtw_self_left is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (x : P) (y : P), Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x x y
but is expected to have type
  forall (R : Type.{u3}) {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (x : P) (y : P), Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x x y
Case conversion may be inaccurate. Consider using '#align wbtw_self_left wbtw_self_leftₓ'. -/
@[simp]
theorem wbtw_self_left (x y : P) : Wbtw R x x y :=
  left_mem_affineSegment _ _ _
#align wbtw_self_left wbtw_self_left

/- warning: wbtw_self_right -> wbtw_self_right is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (x : P) (y : P), Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y y
but is expected to have type
  forall (R : Type.{u3}) {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (x : P) (y : P), Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y y
Case conversion may be inaccurate. Consider using '#align wbtw_self_right wbtw_self_rightₓ'. -/
@[simp]
theorem wbtw_self_right (x y : P) : Wbtw R x y y :=
  right_mem_affineSegment _ _ _
#align wbtw_self_right wbtw_self_right

/- warning: wbtw_self_iff -> wbtw_self_iff is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P}, Iff (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y x) (Eq.{succ u3} P y x)
but is expected to have type
  forall (R : Type.{u3}) {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P}, Iff (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y x) (Eq.{succ u1} P y x)
Case conversion may be inaccurate. Consider using '#align wbtw_self_iff wbtw_self_iffₓ'. -/
@[simp]
theorem wbtw_self_iff {x y : P} : Wbtw R x y x ↔ y = x :=
  by
  refine' ⟨fun h => _, fun h => _⟩
  · simpa [Wbtw, affineSegment] using h
  · rw [h]
    exact wbtw_self_left R x x
#align wbtw_self_iff wbtw_self_iff

/- warning: not_sbtw_self_left -> not_sbtw_self_left is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (x : P) (y : P), Not (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x x y)
but is expected to have type
  forall (R : Type.{u3}) {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (x : P) (y : P), Not (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x x y)
Case conversion may be inaccurate. Consider using '#align not_sbtw_self_left not_sbtw_self_leftₓ'. -/
@[simp]
theorem not_sbtw_self_left (x y : P) : ¬Sbtw R x x y := fun h => h.ne_left rfl
#align not_sbtw_self_left not_sbtw_self_left

/- warning: not_sbtw_self_right -> not_sbtw_self_right is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (x : P) (y : P), Not (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y y)
but is expected to have type
  forall (R : Type.{u3}) {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (x : P) (y : P), Not (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y y)
Case conversion may be inaccurate. Consider using '#align not_sbtw_self_right not_sbtw_self_rightₓ'. -/
@[simp]
theorem not_sbtw_self_right (x y : P) : ¬Sbtw R x y y := fun h => h.ne_right rfl
#align not_sbtw_self_right not_sbtw_self_right

variable {R}

/- warning: wbtw.left_ne_right_of_ne_left -> Wbtw.left_ne_right_of_ne_left is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Ne.{succ u3} P y x) -> (Ne.{succ u3} P x z)
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Ne.{succ u1} P y x) -> (Ne.{succ u1} P x z)
Case conversion may be inaccurate. Consider using '#align wbtw.left_ne_right_of_ne_left Wbtw.left_ne_right_of_ne_leftₓ'. -/
theorem Wbtw.left_ne_right_of_ne_left {x y z : P} (h : Wbtw R x y z) (hne : y ≠ x) : x ≠ z :=
  by
  rintro rfl
  rw [wbtw_self_iff] at h
  exact hne h
#align wbtw.left_ne_right_of_ne_left Wbtw.left_ne_right_of_ne_left

/- warning: wbtw.left_ne_right_of_ne_right -> Wbtw.left_ne_right_of_ne_right is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Ne.{succ u3} P y z) -> (Ne.{succ u3} P x z)
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Ne.{succ u1} P y z) -> (Ne.{succ u1} P x z)
Case conversion may be inaccurate. Consider using '#align wbtw.left_ne_right_of_ne_right Wbtw.left_ne_right_of_ne_rightₓ'. -/
theorem Wbtw.left_ne_right_of_ne_right {x y z : P} (h : Wbtw R x y z) (hne : y ≠ z) : x ≠ z :=
  by
  rintro rfl
  rw [wbtw_self_iff] at h
  exact hne h
#align wbtw.left_ne_right_of_ne_right Wbtw.left_ne_right_of_ne_right

/- warning: sbtw.left_ne_right -> Sbtw.left_ne_right is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Ne.{succ u3} P x z)
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Ne.{succ u1} P x z)
Case conversion may be inaccurate. Consider using '#align sbtw.left_ne_right Sbtw.left_ne_rightₓ'. -/
theorem Sbtw.left_ne_right {x y z : P} (h : Sbtw R x y z) : x ≠ z :=
  h.Wbtw.left_ne_right_of_ne_left h.2.1
#align sbtw.left_ne_right Sbtw.left_ne_right

/- warning: sbtw_iff_mem_image_Ioo_and_ne -> sbtw_iff_mem_image_Ioo_and_ne is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {x : P} {y : P} {z : P}, Iff (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) (And (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) y (Set.image.{u1, u3} R P (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} R R R V P (OrderedRing.toRing.{u1} R _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} R R R V P (OrderedRing.toRing.{u1} R _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) _inst_2 _inst_3 _inst_4) => R -> P) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} R R R V P (OrderedRing.toRing.{u1} R _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} R V P (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 x z)) (Set.Ioo.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (OrderedRing.toOrderedAddCommGroup.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))))))))) (Ne.{succ u3} P x z))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {x : P} {y : P} {z : P}, Iff (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) (And (Membership.mem.{u1, u1} P (Set.{u1} P) (Set.instMembershipSet.{u1} P) y (Set.image.{u3, u1} R P (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u3, u3, u3, u2, u1} R R R V P (OrderedRing.toRing.{u3} R _inst_1) (Ring.toAddCommGroup.{u3} R (OrderedRing.toRing.{u3} R _inst_1)) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (OrderedRing.toRing.{u3} R _inst_1))) (addGroupIsAddTorsor.{u3} R (AddGroupWithOne.toAddGroup.{u3} R (Ring.toAddGroupWithOne.{u3} R (OrderedRing.toRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : R) => P) _x) (AffineMap.funLike.{u3, u3, u3, u2, u1} R R R V P (OrderedRing.toRing.{u3} R _inst_1) (Ring.toAddCommGroup.{u3} R (OrderedRing.toRing.{u3} R _inst_1)) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (OrderedRing.toRing.{u3} R _inst_1))) (addGroupIsAddTorsor.{u3} R (AddGroupWithOne.toAddGroup.{u3} R (Ring.toAddGroupWithOne.{u3} R (OrderedRing.toRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u3, u2, u1} R V P (OrderedRing.toRing.{u3} R _inst_1) _inst_2 _inst_3 _inst_4 x z)) (Set.Ioo.{u3} R (PartialOrder.toPreorder.{u3} R (OrderedRing.toPartialOrder.{u3} R _inst_1)) (OfNat.ofNat.{u3} R 0 (Zero.toOfNat0.{u3} R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))))) (OfNat.ofNat.{u3} R 1 (One.toOfNat1.{u3} R (Semiring.toOne.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))))))) (Ne.{succ u1} P x z))
Case conversion may be inaccurate. Consider using '#align sbtw_iff_mem_image_Ioo_and_ne sbtw_iff_mem_image_Ioo_and_neₓ'. -/
theorem sbtw_iff_mem_image_Ioo_and_ne [NoZeroSMulDivisors R V] {x y z : P} :
    Sbtw R x y z ↔ y ∈ lineMap x z '' Set.Ioo (0 : R) 1 ∧ x ≠ z :=
  by
  refine' ⟨fun h => ⟨h.mem_image_Ioo, h.left_ne_right⟩, fun h => _⟩
  rcases h with ⟨⟨t, ht, rfl⟩, hxz⟩
  refine' ⟨⟨t, Set.mem_Icc_of_Ioo ht, rfl⟩, _⟩
  rw [line_map_apply, ← @vsub_ne_zero V, ← @vsub_ne_zero V _ _ _ _ z, vadd_vsub_assoc,
    vadd_vsub_assoc, ← neg_vsub_eq_vsub_rev z x, ← @neg_one_smul R, ← add_smul, ← sub_eq_add_neg]
  simp [smul_ne_zero, hxz.symm, sub_eq_zero, ht.1.Ne.symm, ht.2.Ne]
#align sbtw_iff_mem_image_Ioo_and_ne sbtw_iff_mem_image_Ioo_and_ne

variable (R)

/- warning: not_sbtw_self -> not_sbtw_self is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (x : P) (y : P), Not (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y x)
but is expected to have type
  forall (R : Type.{u3}) {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (x : P) (y : P), Not (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y x)
Case conversion may be inaccurate. Consider using '#align not_sbtw_self not_sbtw_selfₓ'. -/
@[simp]
theorem not_sbtw_self (x y : P) : ¬Sbtw R x y x := fun h => h.left_ne_right rfl
#align not_sbtw_self not_sbtw_self

/- warning: wbtw_swap_left_iff -> wbtw_swap_left_iff is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {x : P} {y : P} (z : P), Iff (And (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 y x z)) (Eq.{succ u3} P x y)
but is expected to have type
  forall (R : Type.{u3}) {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {x : P} {y : P} (z : P), Iff (And (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 y x z)) (Eq.{succ u1} P x y)
Case conversion may be inaccurate. Consider using '#align wbtw_swap_left_iff wbtw_swap_left_iffₓ'. -/
theorem wbtw_swap_left_iff [NoZeroSMulDivisors R V] {x y : P} (z : P) :
    Wbtw R x y z ∧ Wbtw R y x z ↔ x = y := by
  constructor
  · rintro ⟨hxyz, hyxz⟩
    rcases hxyz with ⟨ty, hty, rfl⟩
    rcases hyxz with ⟨tx, htx, hx⟩
    simp_rw [line_map_apply, ← add_vadd] at hx
    rw [← @vsub_eq_zero_iff_eq V, vadd_vsub, vsub_vadd_eq_vsub_sub, smul_sub, smul_smul, ← sub_smul,
      ← add_smul, smul_eq_zero] at hx
    rcases hx with (h | h)
    · nth_rw 1 [← mul_one tx] at h
      rw [← mul_sub, add_eq_zero_iff_neg_eq] at h
      have h' : ty = 0 := by
        refine' le_antisymm _ hty.1
        rw [← h, Left.neg_nonpos_iff]
        exact mul_nonneg htx.1 (sub_nonneg.2 hty.2)
      simp [h']
    · rw [vsub_eq_zero_iff_eq] at h
      simp [h]
  · rintro rfl
    exact ⟨wbtw_self_left _ _ _, wbtw_self_left _ _ _⟩
#align wbtw_swap_left_iff wbtw_swap_left_iff

/- warning: wbtw_swap_right_iff -> wbtw_swap_right_iff is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] (x : P) {y : P} {z : P}, Iff (And (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x z y)) (Eq.{succ u3} P y z)
but is expected to have type
  forall (R : Type.{u3}) {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] (x : P) {y : P} {z : P}, Iff (And (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x z y)) (Eq.{succ u1} P y z)
Case conversion may be inaccurate. Consider using '#align wbtw_swap_right_iff wbtw_swap_right_iffₓ'. -/
theorem wbtw_swap_right_iff [NoZeroSMulDivisors R V] (x : P) {y z : P} :
    Wbtw R x y z ∧ Wbtw R x z y ↔ y = z :=
  by
  nth_rw 1 [wbtw_comm]
  nth_rw 2 [wbtw_comm]
  rw [eq_comm]
  exact wbtw_swap_left_iff R x
#align wbtw_swap_right_iff wbtw_swap_right_iff

/- warning: wbtw_rotate_iff -> wbtw_rotate_iff is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] (x : P) {y : P} {z : P}, Iff (And (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 z x y)) (Eq.{succ u3} P x y)
but is expected to have type
  forall (R : Type.{u3}) {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] (x : P) {y : P} {z : P}, Iff (And (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 z x y)) (Eq.{succ u1} P x y)
Case conversion may be inaccurate. Consider using '#align wbtw_rotate_iff wbtw_rotate_iffₓ'. -/
theorem wbtw_rotate_iff [NoZeroSMulDivisors R V] (x : P) {y z : P} :
    Wbtw R x y z ∧ Wbtw R z x y ↔ x = y := by rw [wbtw_comm, wbtw_swap_right_iff, eq_comm]
#align wbtw_rotate_iff wbtw_rotate_iff

variable {R}

/- warning: wbtw.swap_left_iff -> Wbtw.swap_left_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {x : P} {y : P} {z : P}, (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Iff (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 y x z) (Eq.{succ u3} P x y))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {x : P} {y : P} {z : P}, (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Iff (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 y x z) (Eq.{succ u1} P x y))
Case conversion may be inaccurate. Consider using '#align wbtw.swap_left_iff Wbtw.swap_left_iffₓ'. -/
theorem Wbtw.swap_left_iff [NoZeroSMulDivisors R V] {x y z : P} (h : Wbtw R x y z) :
    Wbtw R y x z ↔ x = y := by rw [← wbtw_swap_left_iff R z, and_iff_right h]
#align wbtw.swap_left_iff Wbtw.swap_left_iff

/- warning: wbtw.swap_right_iff -> Wbtw.swap_right_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {x : P} {y : P} {z : P}, (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Iff (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x z y) (Eq.{succ u3} P y z))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {x : P} {y : P} {z : P}, (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Iff (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x z y) (Eq.{succ u1} P y z))
Case conversion may be inaccurate. Consider using '#align wbtw.swap_right_iff Wbtw.swap_right_iffₓ'. -/
theorem Wbtw.swap_right_iff [NoZeroSMulDivisors R V] {x y z : P} (h : Wbtw R x y z) :
    Wbtw R x z y ↔ y = z := by rw [← wbtw_swap_right_iff R x, and_iff_right h]
#align wbtw.swap_right_iff Wbtw.swap_right_iff

/- warning: wbtw.rotate_iff -> Wbtw.rotate_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {x : P} {y : P} {z : P}, (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Iff (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 z x y) (Eq.{succ u3} P x y))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {x : P} {y : P} {z : P}, (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Iff (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 z x y) (Eq.{succ u1} P x y))
Case conversion may be inaccurate. Consider using '#align wbtw.rotate_iff Wbtw.rotate_iffₓ'. -/
theorem Wbtw.rotate_iff [NoZeroSMulDivisors R V] {x y z : P} (h : Wbtw R x y z) :
    Wbtw R z x y ↔ x = y := by rw [← wbtw_rotate_iff R x, and_iff_right h]
#align wbtw.rotate_iff Wbtw.rotate_iff

/- warning: sbtw.not_swap_left -> Sbtw.not_swap_left is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {x : P} {y : P} {z : P}, (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Not (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 y x z))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {x : P} {y : P} {z : P}, (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Not (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 y x z))
Case conversion may be inaccurate. Consider using '#align sbtw.not_swap_left Sbtw.not_swap_leftₓ'. -/
theorem Sbtw.not_swap_left [NoZeroSMulDivisors R V] {x y z : P} (h : Sbtw R x y z) :
    ¬Wbtw R y x z := fun hs => h.left_ne (h.Wbtw.swap_left_iff.1 hs)
#align sbtw.not_swap_left Sbtw.not_swap_left

/- warning: sbtw.not_swap_right -> Sbtw.not_swap_right is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {x : P} {y : P} {z : P}, (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Not (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x z y))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {x : P} {y : P} {z : P}, (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Not (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x z y))
Case conversion may be inaccurate. Consider using '#align sbtw.not_swap_right Sbtw.not_swap_rightₓ'. -/
theorem Sbtw.not_swap_right [NoZeroSMulDivisors R V] {x y z : P} (h : Sbtw R x y z) :
    ¬Wbtw R x z y := fun hs => h.ne_right (h.Wbtw.swap_right_iff.1 hs)
#align sbtw.not_swap_right Sbtw.not_swap_right

/- warning: sbtw.not_rotate -> Sbtw.not_rotate is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {x : P} {y : P} {z : P}, (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Not (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 z x y))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {x : P} {y : P} {z : P}, (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Not (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 z x y))
Case conversion may be inaccurate. Consider using '#align sbtw.not_rotate Sbtw.not_rotateₓ'. -/
theorem Sbtw.not_rotate [NoZeroSMulDivisors R V] {x y z : P} (h : Sbtw R x y z) : ¬Wbtw R z x y :=
  fun hs => h.left_ne (h.Wbtw.rotate_iff.1 hs)
#align sbtw.not_rotate Sbtw.not_rotate

/- warning: wbtw_line_map_iff -> wbtw_lineMap_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {x : P} {y : P} {r : R}, Iff (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} R R R V P (OrderedRing.toRing.{u1} R _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} R R R V P (OrderedRing.toRing.{u1} R _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) _inst_2 _inst_3 _inst_4) => R -> P) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} R R R V P (OrderedRing.toRing.{u1} R _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} R V P (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 x y) r) y) (Or (Eq.{succ u3} P x y) (Membership.Mem.{u1, u1} R (Set.{u1} R) (Set.hasMem.{u1} R) r (Set.Icc.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (OrderedRing.toOrderedAddCommGroup.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))))))))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {x : P} {y : P} {r : R}, Iff (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u3, u3, u3, u2, u1} R R R V P (OrderedRing.toRing.{u3} R _inst_1) (Ring.toAddCommGroup.{u3} R (OrderedRing.toRing.{u3} R _inst_1)) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (OrderedRing.toRing.{u3} R _inst_1))) (addGroupIsAddTorsor.{u3} R (AddGroupWithOne.toAddGroup.{u3} R (Ring.toAddGroupWithOne.{u3} R (OrderedRing.toRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : R) => P) _x) (AffineMap.funLike.{u3, u3, u3, u2, u1} R R R V P (OrderedRing.toRing.{u3} R _inst_1) (Ring.toAddCommGroup.{u3} R (OrderedRing.toRing.{u3} R _inst_1)) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (OrderedRing.toRing.{u3} R _inst_1))) (addGroupIsAddTorsor.{u3} R (AddGroupWithOne.toAddGroup.{u3} R (Ring.toAddGroupWithOne.{u3} R (OrderedRing.toRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u3, u2, u1} R V P (OrderedRing.toRing.{u3} R _inst_1) _inst_2 _inst_3 _inst_4 x y) r) y) (Or (Eq.{succ u1} P x y) (Membership.mem.{u3, u3} R (Set.{u3} R) (Set.instMembershipSet.{u3} R) r (Set.Icc.{u3} R (PartialOrder.toPreorder.{u3} R (OrderedRing.toPartialOrder.{u3} R _inst_1)) (OfNat.ofNat.{u3} R 0 (Zero.toOfNat0.{u3} R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))))) (OfNat.ofNat.{u3} R 1 (One.toOfNat1.{u3} R (Semiring.toOne.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align wbtw_line_map_iff wbtw_lineMap_iffₓ'. -/
@[simp]
theorem wbtw_lineMap_iff [NoZeroSMulDivisors R V] {x y : P} {r : R} :
    Wbtw R x (lineMap x y r) y ↔ x = y ∨ r ∈ Set.Icc (0 : R) 1 :=
  by
  by_cases hxy : x = y; · simp [hxy]
  rw [or_iff_right hxy, Wbtw, affineSegment, (line_map_injective R hxy).mem_set_image]
#align wbtw_line_map_iff wbtw_lineMap_iff

/- warning: sbtw_line_map_iff -> sbtw_lineMap_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {x : P} {y : P} {r : R}, Iff (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} R R R V P (OrderedRing.toRing.{u1} R _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} R R R V P (OrderedRing.toRing.{u1} R _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) _inst_2 _inst_3 _inst_4) => R -> P) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} R R R V P (OrderedRing.toRing.{u1} R _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} R V P (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 x y) r) y) (And (Ne.{succ u3} P x y) (Membership.Mem.{u1, u1} R (Set.{u1} R) (Set.hasMem.{u1} R) r (Set.Ioo.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (OrderedRing.toOrderedAddCommGroup.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))))))))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {x : P} {y : P} {r : R}, Iff (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u3, u3, u3, u2, u1} R R R V P (OrderedRing.toRing.{u3} R _inst_1) (Ring.toAddCommGroup.{u3} R (OrderedRing.toRing.{u3} R _inst_1)) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (OrderedRing.toRing.{u3} R _inst_1))) (addGroupIsAddTorsor.{u3} R (AddGroupWithOne.toAddGroup.{u3} R (Ring.toAddGroupWithOne.{u3} R (OrderedRing.toRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : R) => P) _x) (AffineMap.funLike.{u3, u3, u3, u2, u1} R R R V P (OrderedRing.toRing.{u3} R _inst_1) (Ring.toAddCommGroup.{u3} R (OrderedRing.toRing.{u3} R _inst_1)) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (OrderedRing.toRing.{u3} R _inst_1))) (addGroupIsAddTorsor.{u3} R (AddGroupWithOne.toAddGroup.{u3} R (Ring.toAddGroupWithOne.{u3} R (OrderedRing.toRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u3, u2, u1} R V P (OrderedRing.toRing.{u3} R _inst_1) _inst_2 _inst_3 _inst_4 x y) r) y) (And (Ne.{succ u1} P x y) (Membership.mem.{u3, u3} R (Set.{u3} R) (Set.instMembershipSet.{u3} R) r (Set.Ioo.{u3} R (PartialOrder.toPreorder.{u3} R (OrderedRing.toPartialOrder.{u3} R _inst_1)) (OfNat.ofNat.{u3} R 0 (Zero.toOfNat0.{u3} R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))))) (OfNat.ofNat.{u3} R 1 (One.toOfNat1.{u3} R (Semiring.toOne.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align sbtw_line_map_iff sbtw_lineMap_iffₓ'. -/
@[simp]
theorem sbtw_lineMap_iff [NoZeroSMulDivisors R V] {x y : P} {r : R} :
    Sbtw R x (lineMap x y r) y ↔ x ≠ y ∧ r ∈ Set.Ioo (0 : R) 1 :=
  by
  rw [sbtw_iff_mem_image_Ioo_and_ne, and_comm', and_congr_right]
  intro hxy
  rw [(line_map_injective R hxy).mem_set_image]
#align sbtw_line_map_iff sbtw_lineMap_iff

omit V

/- warning: wbtw_mul_sub_add_iff -> wbtw_mul_sub_add_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : OrderedRing.{u1} R] [_inst_8 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))))] {x : R} {y : R} {r : R}, Iff (Wbtw.{u1, u1, u1} R R R _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) x (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) r (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (SubNegMonoid.toHasSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))))) y x)) x) y) (Or (Eq.{succ u1} R x y) (Membership.Mem.{u1, u1} R (Set.{u1} R) (Set.hasMem.{u1} R) r (Set.Icc.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (OrderedRing.toOrderedAddCommGroup.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : OrderedRing.{u1} R] [_inst_8 : NoZeroDivisors.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R (OrderedRing.toOrderedSemiring.{u1} R _inst_1))))] {x : R} {y : R} {r : R}, Iff (Wbtw.{u1, u1, u1} R R R _inst_1 (OrderedAddCommGroup.toAddCommGroup.{u1} R (OrderedRing.toOrderedAddCommGroup.{u1} R _inst_1)) (Semiring.toModule.{u1} R (OrderedSemiring.toSemiring.{u1} R (OrderedRing.toOrderedSemiring.{u1} R _inst_1))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (Ring.toAddGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) x (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) r (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) y x)) x) y) (Or (Eq.{succ u1} R x y) (Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) r (Set.Icc.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedRing.toPartialOrder.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R (OrderedRing.toOrderedSemiring.{u1} R _inst_1)))))) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (OrderedSemiring.toSemiring.{u1} R (OrderedRing.toOrderedSemiring.{u1} R _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align wbtw_mul_sub_add_iff wbtw_mul_sub_add_iffₓ'. -/
@[simp]
theorem wbtw_mul_sub_add_iff [NoZeroDivisors R] {x y r : R} :
    Wbtw R x (r * (y - x) + x) y ↔ x = y ∨ r ∈ Set.Icc (0 : R) 1 :=
  wbtw_lineMap_iff
#align wbtw_mul_sub_add_iff wbtw_mul_sub_add_iff

/- warning: sbtw_mul_sub_add_iff -> sbtw_mul_sub_add_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : OrderedRing.{u1} R] [_inst_8 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))))] {x : R} {y : R} {r : R}, Iff (Sbtw.{u1, u1, u1} R R R _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) x (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) r (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (SubNegMonoid.toHasSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))))) y x)) x) y) (And (Ne.{succ u1} R x y) (Membership.Mem.{u1, u1} R (Set.{u1} R) (Set.hasMem.{u1} R) r (Set.Ioo.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (OrderedRing.toOrderedAddCommGroup.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : OrderedRing.{u1} R] [_inst_8 : NoZeroDivisors.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R (OrderedRing.toOrderedSemiring.{u1} R _inst_1))))] {x : R} {y : R} {r : R}, Iff (Sbtw.{u1, u1, u1} R R R _inst_1 (OrderedAddCommGroup.toAddCommGroup.{u1} R (OrderedRing.toOrderedAddCommGroup.{u1} R _inst_1)) (Semiring.toModule.{u1} R (OrderedSemiring.toSemiring.{u1} R (OrderedRing.toOrderedSemiring.{u1} R _inst_1))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (Ring.toAddGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) x (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) r (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) y x)) x) y) (And (Ne.{succ u1} R x y) (Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) r (Set.Ioo.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedRing.toPartialOrder.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R (OrderedRing.toOrderedSemiring.{u1} R _inst_1)))))) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (OrderedSemiring.toSemiring.{u1} R (OrderedRing.toOrderedSemiring.{u1} R _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align sbtw_mul_sub_add_iff sbtw_mul_sub_add_iffₓ'. -/
@[simp]
theorem sbtw_mul_sub_add_iff [NoZeroDivisors R] {x y r : R} :
    Sbtw R x (r * (y - x) + x) y ↔ x ≠ y ∧ r ∈ Set.Ioo (0 : R) 1 :=
  sbtw_lineMap_iff
#align sbtw_mul_sub_add_iff sbtw_mul_sub_add_iff

/- warning: wbtw_zero_one_iff -> wbtw_zero_one_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : OrderedRing.{u1} R] {x : R}, Iff (Wbtw.{u1, u1, u1} R R R _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))))))) x (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))))))) (Membership.Mem.{u1, u1} R (Set.{u1} R) (Set.hasMem.{u1} R) x (Set.Icc.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (OrderedRing.toOrderedAddCommGroup.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : OrderedRing.{u1} R] {x : R}, Iff (Wbtw.{u1, u1, u1} R R R _inst_1 (OrderedAddCommGroup.toAddCommGroup.{u1} R (OrderedRing.toOrderedAddCommGroup.{u1} R _inst_1)) (Semiring.toModule.{u1} R (OrderedSemiring.toSemiring.{u1} R (OrderedRing.toOrderedSemiring.{u1} R _inst_1))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (Ring.toAddGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R (OrderedRing.toOrderedSemiring.{u1} R _inst_1)))))) x (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (OrderedSemiring.toSemiring.{u1} R (OrderedRing.toOrderedSemiring.{u1} R _inst_1)))))) (Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (Set.Icc.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedRing.toPartialOrder.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R (OrderedRing.toOrderedSemiring.{u1} R _inst_1)))))) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (OrderedSemiring.toSemiring.{u1} R (OrderedRing.toOrderedSemiring.{u1} R _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align wbtw_zero_one_iff wbtw_zero_one_iffₓ'. -/
@[simp]
theorem wbtw_zero_one_iff {x : R} : Wbtw R 0 x 1 ↔ x ∈ Set.Icc (0 : R) 1 :=
  by
  simp_rw [Wbtw, affineSegment, Set.mem_image, line_map_apply_ring]
  simp
#align wbtw_zero_one_iff wbtw_zero_one_iff

/- warning: wbtw_one_zero_iff -> wbtw_one_zero_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : OrderedRing.{u1} R] {x : R}, Iff (Wbtw.{u1, u1, u1} R R R _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))))) x (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))))))) (Membership.Mem.{u1, u1} R (Set.{u1} R) (Set.hasMem.{u1} R) x (Set.Icc.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (OrderedRing.toOrderedAddCommGroup.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : OrderedRing.{u1} R] {x : R}, Iff (Wbtw.{u1, u1, u1} R R R _inst_1 (OrderedAddCommGroup.toAddCommGroup.{u1} R (OrderedRing.toOrderedAddCommGroup.{u1} R _inst_1)) (Semiring.toModule.{u1} R (OrderedSemiring.toSemiring.{u1} R (OrderedRing.toOrderedSemiring.{u1} R _inst_1))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (Ring.toAddGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (OrderedSemiring.toSemiring.{u1} R (OrderedRing.toOrderedSemiring.{u1} R _inst_1))))) x (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R (OrderedRing.toOrderedSemiring.{u1} R _inst_1))))))) (Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (Set.Icc.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedRing.toPartialOrder.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R (OrderedRing.toOrderedSemiring.{u1} R _inst_1)))))) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (OrderedSemiring.toSemiring.{u1} R (OrderedRing.toOrderedSemiring.{u1} R _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align wbtw_one_zero_iff wbtw_one_zero_iffₓ'. -/
@[simp]
theorem wbtw_one_zero_iff {x : R} : Wbtw R 1 x 0 ↔ x ∈ Set.Icc (0 : R) 1 := by
  rw [wbtw_comm, wbtw_zero_one_iff]
#align wbtw_one_zero_iff wbtw_one_zero_iff

/- warning: sbtw_zero_one_iff -> sbtw_zero_one_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : OrderedRing.{u1} R] {x : R}, Iff (Sbtw.{u1, u1, u1} R R R _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))))))) x (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))))))) (Membership.Mem.{u1, u1} R (Set.{u1} R) (Set.hasMem.{u1} R) x (Set.Ioo.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (OrderedRing.toOrderedAddCommGroup.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : OrderedRing.{u1} R] {x : R}, Iff (Sbtw.{u1, u1, u1} R R R _inst_1 (OrderedAddCommGroup.toAddCommGroup.{u1} R (OrderedRing.toOrderedAddCommGroup.{u1} R _inst_1)) (Semiring.toModule.{u1} R (OrderedSemiring.toSemiring.{u1} R (OrderedRing.toOrderedSemiring.{u1} R _inst_1))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (Ring.toAddGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R (OrderedRing.toOrderedSemiring.{u1} R _inst_1)))))) x (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (OrderedSemiring.toSemiring.{u1} R (OrderedRing.toOrderedSemiring.{u1} R _inst_1)))))) (Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (Set.Ioo.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedRing.toPartialOrder.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R (OrderedRing.toOrderedSemiring.{u1} R _inst_1)))))) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (OrderedSemiring.toSemiring.{u1} R (OrderedRing.toOrderedSemiring.{u1} R _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align sbtw_zero_one_iff sbtw_zero_one_iffₓ'. -/
@[simp]
theorem sbtw_zero_one_iff {x : R} : Sbtw R 0 x 1 ↔ x ∈ Set.Ioo (0 : R) 1 :=
  by
  rw [Sbtw, wbtw_zero_one_iff, Set.mem_Icc, Set.mem_Ioo]
  exact
    ⟨fun h => ⟨h.1.1.lt_of_ne (Ne.symm h.2.1), h.1.2.lt_of_ne h.2.2⟩, fun h =>
      ⟨⟨h.1.le, h.2.le⟩, h.1.ne', h.2.Ne⟩⟩
#align sbtw_zero_one_iff sbtw_zero_one_iff

/- warning: sbtw_one_zero_iff -> sbtw_one_zero_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : OrderedRing.{u1} R] {x : R}, Iff (Sbtw.{u1, u1, u1} R R R _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))))) x (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))))))) (Membership.Mem.{u1, u1} R (Set.{u1} R) (Set.hasMem.{u1} R) x (Set.Ioo.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (OrderedRing.toOrderedAddCommGroup.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : OrderedRing.{u1} R] {x : R}, Iff (Sbtw.{u1, u1, u1} R R R _inst_1 (OrderedAddCommGroup.toAddCommGroup.{u1} R (OrderedRing.toOrderedAddCommGroup.{u1} R _inst_1)) (Semiring.toModule.{u1} R (OrderedSemiring.toSemiring.{u1} R (OrderedRing.toOrderedSemiring.{u1} R _inst_1))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (Ring.toAddGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (OrderedSemiring.toSemiring.{u1} R (OrderedRing.toOrderedSemiring.{u1} R _inst_1))))) x (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R (OrderedRing.toOrderedSemiring.{u1} R _inst_1))))))) (Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (Set.Ioo.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedRing.toPartialOrder.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R (OrderedRing.toOrderedSemiring.{u1} R _inst_1)))))) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (OrderedSemiring.toSemiring.{u1} R (OrderedRing.toOrderedSemiring.{u1} R _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align sbtw_one_zero_iff sbtw_one_zero_iffₓ'. -/
@[simp]
theorem sbtw_one_zero_iff {x : R} : Sbtw R 1 x 0 ↔ x ∈ Set.Ioo (0 : R) 1 := by
  rw [sbtw_comm, sbtw_zero_one_iff]
#align sbtw_one_zero_iff sbtw_one_zero_iff

include V

/- warning: wbtw.trans_left -> Wbtw.trans_left is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {w : P} {x : P} {y : P} {z : P}, (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 w y z) -> (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 w x y) -> (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 w x z)
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {w : P} {x : P} {y : P} {z : P}, (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 w y z) -> (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 w x y) -> (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 w x z)
Case conversion may be inaccurate. Consider using '#align wbtw.trans_left Wbtw.trans_leftₓ'. -/
theorem Wbtw.trans_left {w x y z : P} (h₁ : Wbtw R w y z) (h₂ : Wbtw R w x y) : Wbtw R w x z :=
  by
  rcases h₁ with ⟨t₁, ht₁, rfl⟩
  rcases h₂ with ⟨t₂, ht₂, rfl⟩
  refine' ⟨t₂ * t₁, ⟨mul_nonneg ht₂.1 ht₁.1, mul_le_one ht₂.2 ht₁.1 ht₁.2⟩, _⟩
  simp [line_map_apply, smul_smul]
#align wbtw.trans_left Wbtw.trans_left

/- warning: wbtw.trans_right -> Wbtw.trans_right is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {w : P} {x : P} {y : P} {z : P}, (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 w x z) -> (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 w y z)
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {w : P} {x : P} {y : P} {z : P}, (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 w x z) -> (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 w y z)
Case conversion may be inaccurate. Consider using '#align wbtw.trans_right Wbtw.trans_rightₓ'. -/
theorem Wbtw.trans_right {w x y z : P} (h₁ : Wbtw R w x z) (h₂ : Wbtw R x y z) : Wbtw R w y z :=
  by
  rw [wbtw_comm] at *
  exact h₁.trans_left h₂
#align wbtw.trans_right Wbtw.trans_right

/- warning: wbtw.trans_sbtw_left -> Wbtw.trans_sbtw_left is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {w : P} {x : P} {y : P} {z : P}, (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 w y z) -> (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 w x y) -> (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 w x z)
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {w : P} {x : P} {y : P} {z : P}, (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 w y z) -> (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 w x y) -> (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 w x z)
Case conversion may be inaccurate. Consider using '#align wbtw.trans_sbtw_left Wbtw.trans_sbtw_leftₓ'. -/
theorem Wbtw.trans_sbtw_left [NoZeroSMulDivisors R V] {w x y z : P} (h₁ : Wbtw R w y z)
    (h₂ : Sbtw R w x y) : Sbtw R w x z :=
  by
  refine' ⟨h₁.trans_left h₂.wbtw, h₂.ne_left, _⟩
  rintro rfl
  exact h₂.right_ne ((wbtw_swap_right_iff R w).1 ⟨h₁, h₂.wbtw⟩)
#align wbtw.trans_sbtw_left Wbtw.trans_sbtw_left

/- warning: wbtw.trans_sbtw_right -> Wbtw.trans_sbtw_right is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {w : P} {x : P} {y : P} {z : P}, (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 w x z) -> (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 w y z)
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {w : P} {x : P} {y : P} {z : P}, (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 w x z) -> (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 w y z)
Case conversion may be inaccurate. Consider using '#align wbtw.trans_sbtw_right Wbtw.trans_sbtw_rightₓ'. -/
theorem Wbtw.trans_sbtw_right [NoZeroSMulDivisors R V] {w x y z : P} (h₁ : Wbtw R w x z)
    (h₂ : Sbtw R x y z) : Sbtw R w y z :=
  by
  rw [wbtw_comm] at *
  rw [sbtw_comm] at *
  exact h₁.trans_sbtw_left h₂
#align wbtw.trans_sbtw_right Wbtw.trans_sbtw_right

/- warning: sbtw.trans_left -> Sbtw.trans_left is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {w : P} {x : P} {y : P} {z : P}, (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 w y z) -> (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 w x y) -> (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 w x z)
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {w : P} {x : P} {y : P} {z : P}, (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 w y z) -> (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 w x y) -> (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 w x z)
Case conversion may be inaccurate. Consider using '#align sbtw.trans_left Sbtw.trans_leftₓ'. -/
theorem Sbtw.trans_left [NoZeroSMulDivisors R V] {w x y z : P} (h₁ : Sbtw R w y z)
    (h₂ : Sbtw R w x y) : Sbtw R w x z :=
  h₁.Wbtw.trans_sbtw_left h₂
#align sbtw.trans_left Sbtw.trans_left

/- warning: sbtw.trans_right -> Sbtw.trans_right is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {w : P} {x : P} {y : P} {z : P}, (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 w x z) -> (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 w y z)
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {w : P} {x : P} {y : P} {z : P}, (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 w x z) -> (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 w y z)
Case conversion may be inaccurate. Consider using '#align sbtw.trans_right Sbtw.trans_rightₓ'. -/
theorem Sbtw.trans_right [NoZeroSMulDivisors R V] {w x y z : P} (h₁ : Sbtw R w x z)
    (h₂ : Sbtw R x y z) : Sbtw R w y z :=
  h₁.Wbtw.trans_sbtw_right h₂
#align sbtw.trans_right Sbtw.trans_right

/- warning: wbtw.trans_left_ne -> Wbtw.trans_left_ne is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {w : P} {x : P} {y : P} {z : P}, (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 w y z) -> (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 w x y) -> (Ne.{succ u3} P y z) -> (Ne.{succ u3} P x z)
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {w : P} {x : P} {y : P} {z : P}, (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 w y z) -> (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 w x y) -> (Ne.{succ u1} P y z) -> (Ne.{succ u1} P x z)
Case conversion may be inaccurate. Consider using '#align wbtw.trans_left_ne Wbtw.trans_left_neₓ'. -/
theorem Wbtw.trans_left_ne [NoZeroSMulDivisors R V] {w x y z : P} (h₁ : Wbtw R w y z)
    (h₂ : Wbtw R w x y) (h : y ≠ z) : x ≠ z :=
  by
  rintro rfl
  exact h (h₁.swap_right_iff.1 h₂)
#align wbtw.trans_left_ne Wbtw.trans_left_ne

/- warning: wbtw.trans_right_ne -> Wbtw.trans_right_ne is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {w : P} {x : P} {y : P} {z : P}, (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 w x z) -> (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Ne.{succ u3} P w x) -> (Ne.{succ u3} P w y)
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {w : P} {x : P} {y : P} {z : P}, (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 w x z) -> (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Ne.{succ u1} P w x) -> (Ne.{succ u1} P w y)
Case conversion may be inaccurate. Consider using '#align wbtw.trans_right_ne Wbtw.trans_right_neₓ'. -/
theorem Wbtw.trans_right_ne [NoZeroSMulDivisors R V] {w x y z : P} (h₁ : Wbtw R w x z)
    (h₂ : Wbtw R x y z) (h : w ≠ x) : w ≠ y :=
  by
  rintro rfl
  exact h (h₁.swap_left_iff.1 h₂)
#align wbtw.trans_right_ne Wbtw.trans_right_ne

/- warning: sbtw.trans_wbtw_left_ne -> Sbtw.trans_wbtw_left_ne is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {w : P} {x : P} {y : P} {z : P}, (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 w y z) -> (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 w x y) -> (Ne.{succ u3} P x z)
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {w : P} {x : P} {y : P} {z : P}, (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 w y z) -> (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 w x y) -> (Ne.{succ u1} P x z)
Case conversion may be inaccurate. Consider using '#align sbtw.trans_wbtw_left_ne Sbtw.trans_wbtw_left_neₓ'. -/
theorem Sbtw.trans_wbtw_left_ne [NoZeroSMulDivisors R V] {w x y z : P} (h₁ : Sbtw R w y z)
    (h₂ : Wbtw R w x y) : x ≠ z :=
  h₁.Wbtw.trans_left_ne h₂ h₁.ne_right
#align sbtw.trans_wbtw_left_ne Sbtw.trans_wbtw_left_ne

/- warning: sbtw.trans_wbtw_right_ne -> Sbtw.trans_wbtw_right_ne is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {w : P} {x : P} {y : P} {z : P}, (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 w x z) -> (Wbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Ne.{succ u3} P w y)
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroSMulDivisors.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (OrderedSemiring.toSemiring.{u3} R (OrderedRing.toOrderedSemiring.{u3} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {w : P} {x : P} {y : P} {z : P}, (Sbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 w x z) -> (Wbtw.{u3, u2, u1} R V P _inst_1 _inst_2 _inst_3 _inst_4 x y z) -> (Ne.{succ u1} P w y)
Case conversion may be inaccurate. Consider using '#align sbtw.trans_wbtw_right_ne Sbtw.trans_wbtw_right_neₓ'. -/
theorem Sbtw.trans_wbtw_right_ne [NoZeroSMulDivisors R V] {w x y z : P} (h₁ : Sbtw R w x z)
    (h₂ : Wbtw R x y z) : w ≠ y :=
  h₁.Wbtw.trans_right_ne h₂ h₁.left_ne
#align sbtw.trans_wbtw_right_ne Sbtw.trans_wbtw_right_ne

/- warning: sbtw.affine_combination_of_mem_affine_span_pair -> Sbtw.affineCombination_of_mem_affineSpan_pair is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : OrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_8 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))))] [_inst_9 : NoZeroSMulDivisors.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {ι : Type.{u4}} {p : ι -> P}, (AffineIndependent.{u1, u2, u3, u4} R V P (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 ι p) -> (forall {w : ι -> R} {w₁ : ι -> R} {w₂ : ι -> R} {s : Finset.{u4} ι}, (Eq.{succ u1} R (Finset.sum.{u1, u4} R ι (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))))))) -> (Eq.{succ u1} R (Finset.sum.{u1, u4} R ι (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) s (fun (i : ι) => w₁ i)) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))))))) -> (Eq.{succ u1} R (Finset.sum.{u1, u4} R ι (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) s (fun (i : ι) => w₂ i)) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))))))) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} R V P (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} R V P (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} R V P (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4)) (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} R (ι -> R) (ι -> R) V P (OrderedRing.toRing.{u1} R _inst_1) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => R) R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (fun (i : ι) => Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => R) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (fun (ᾰ : ι) => R) (fun (i : ι) => addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} R (ι -> R) (ι -> R) V P (OrderedRing.toRing.{u1} R _inst_1) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => R) R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (fun (i : ι) => Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => R) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (fun (ᾰ : ι) => R) (fun (i : ι) => addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) _inst_2 _inst_3 _inst_4) => (ι -> R) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} R (ι -> R) (ι -> R) V P (OrderedRing.toRing.{u1} R _inst_1) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => R) R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (fun (i : ι) => Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => R) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (fun (ᾰ : ι) => R) (fun (i : ι) => addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u1, u2, u3, u4} R V P (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 ι s p) w) (affineSpan.{u1, u2, u3} R V P (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} R (ι -> R) (ι -> R) V P (OrderedRing.toRing.{u1} R _inst_1) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => R) R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (fun (i : ι) => Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => R) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (fun (ᾰ : ι) => R) (fun (i : ι) => addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} R (ι -> R) (ι -> R) V P (OrderedRing.toRing.{u1} R _inst_1) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => R) R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (fun (i : ι) => Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => R) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (fun (ᾰ : ι) => R) (fun (i : ι) => addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) _inst_2 _inst_3 _inst_4) => (ι -> R) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} R (ι -> R) (ι -> R) V P (OrderedRing.toRing.{u1} R _inst_1) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => R) R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (fun (i : ι) => Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => R) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (fun (ᾰ : ι) => R) (fun (i : ι) => addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u1, u2, u3, u4} R V P (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 ι s p) w₁) (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} R (ι -> R) (ι -> R) V P (OrderedRing.toRing.{u1} R _inst_1) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => R) R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (fun (i : ι) => Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => R) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (fun (ᾰ : ι) => R) (fun (i : ι) => addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} R (ι -> R) (ι -> R) V P (OrderedRing.toRing.{u1} R _inst_1) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => R) R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (fun (i : ι) => Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => R) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (fun (ᾰ : ι) => R) (fun (i : ι) => addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) _inst_2 _inst_3 _inst_4) => (ι -> R) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} R (ι -> R) (ι -> R) V P (OrderedRing.toRing.{u1} R _inst_1) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => R) R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (fun (i : ι) => Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => R) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (fun (ᾰ : ι) => R) (fun (i : ι) => addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u1, u2, u3, u4} R V P (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 ι s p) w₂))))) -> (forall {i : ι}, (Membership.Mem.{u4, u4} ι (Finset.{u4} ι) (Finset.hasMem.{u4} ι) i s) -> (Sbtw.{u1, u1, u1} R R R _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (w₁ i) (w i) (w₂ i)) -> (Sbtw.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} R (ι -> R) (ι -> R) V P (OrderedRing.toRing.{u1} R _inst_1) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => R) R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (fun (i : ι) => Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => R) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (fun (ᾰ : ι) => R) (fun (i : ι) => addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} R (ι -> R) (ι -> R) V P (OrderedRing.toRing.{u1} R _inst_1) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => R) R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (fun (i : ι) => Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => R) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (fun (ᾰ : ι) => R) (fun (i : ι) => addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) _inst_2 _inst_3 _inst_4) => (ι -> R) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} R (ι -> R) (ι -> R) V P (OrderedRing.toRing.{u1} R _inst_1) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => R) R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (fun (i : ι) => Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => R) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (fun (ᾰ : ι) => R) (fun (i : ι) => addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u1, u2, u3, u4} R V P (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 ι s p) w₁) (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} R (ι -> R) (ι -> R) V P (OrderedRing.toRing.{u1} R _inst_1) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => R) R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (fun (i : ι) => Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => R) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (fun (ᾰ : ι) => R) (fun (i : ι) => addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} R (ι -> R) (ι -> R) V P (OrderedRing.toRing.{u1} R _inst_1) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => R) R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (fun (i : ι) => Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => R) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (fun (ᾰ : ι) => R) (fun (i : ι) => addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) _inst_2 _inst_3 _inst_4) => (ι -> R) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} R (ι -> R) (ι -> R) V P (OrderedRing.toRing.{u1} R _inst_1) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => R) R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (fun (i : ι) => Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => R) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (fun (ᾰ : ι) => R) (fun (i : ι) => addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u1, u2, u3, u4} R V P (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 ι s p) w) (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} R (ι -> R) (ι -> R) V P (OrderedRing.toRing.{u1} R _inst_1) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => R) R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (fun (i : ι) => Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => R) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (fun (ᾰ : ι) => R) (fun (i : ι) => addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} R (ι -> R) (ι -> R) V P (OrderedRing.toRing.{u1} R _inst_1) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => R) R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (fun (i : ι) => Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => R) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (fun (ᾰ : ι) => R) (fun (i : ι) => addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) _inst_2 _inst_3 _inst_4) => (ι -> R) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} R (ι -> R) (ι -> R) V P (OrderedRing.toRing.{u1} R _inst_1) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => R) R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (OrderedRing.toRing.{u1} R _inst_1))))) (fun (i : ι) => Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => R) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))) (fun (ᾰ : ι) => R) (fun (i : ι) => addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (OrderedRing.toRing.{u1} R _inst_1)))))) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u1, u2, u3, u4} R V P (OrderedRing.toRing.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 ι s p) w₂))))
but is expected to have type
  forall {R : Type.{u4}} {V : Type.{u3}} {P : Type.{u1}} [_inst_1 : OrderedRing.{u4} R] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u4, u3} R V (OrderedSemiring.toSemiring.{u4} R (OrderedRing.toOrderedSemiring.{u4} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] [_inst_8 : NoZeroDivisors.{u4} R (NonUnitalNonAssocRing.toMul.{u4} R (NonAssocRing.toNonUnitalNonAssocRing.{u4} R (Ring.toNonAssocRing.{u4} R (OrderedRing.toRing.{u4} R _inst_1)))) (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R (OrderedSemiring.toSemiring.{u4} R (OrderedRing.toOrderedSemiring.{u4} R _inst_1))))] [_inst_9 : NoZeroSMulDivisors.{u4, u3} R V (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R (OrderedSemiring.toSemiring.{u4} R (OrderedRing.toOrderedSemiring.{u4} R _inst_1)))) (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_2))))) (SMulZeroClass.toSMul.{u4, u3} R V (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u4, u3} R V (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R (OrderedSemiring.toSemiring.{u4} R (OrderedRing.toOrderedSemiring.{u4} R _inst_1)))) (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u4, u3} R V (Semiring.toMonoidWithZero.{u4} R (OrderedSemiring.toSemiring.{u4} R (OrderedRing.toOrderedSemiring.{u4} R _inst_1))) (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_2))))) (Module.toMulActionWithZero.{u4, u3} R V (OrderedSemiring.toSemiring.{u4} R (OrderedRing.toOrderedSemiring.{u4} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3))))] {ι : Type.{u2}} {p : ι -> P}, (AffineIndependent.{u4, u3, u1, u2} R V P (OrderedRing.toRing.{u4} R _inst_1) _inst_2 _inst_3 _inst_4 ι p) -> (forall {w : ι -> R} {w₁ : ι -> R} {w₂ : ι -> R} {s : Finset.{u2} ι}, (Eq.{succ u4} R (Finset.sum.{u4, u2} R ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u4} R (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u4} R (OrderedRing.toOrderedAddCommGroup.{u4} R _inst_1))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u4} R 1 (One.toOfNat1.{u4} R (Semiring.toOne.{u4} R (OrderedSemiring.toSemiring.{u4} R (OrderedRing.toOrderedSemiring.{u4} R _inst_1)))))) -> (Eq.{succ u4} R (Finset.sum.{u4, u2} R ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u4} R (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u4} R (OrderedRing.toOrderedAddCommGroup.{u4} R _inst_1))) s (fun (i : ι) => w₁ i)) (OfNat.ofNat.{u4} R 1 (One.toOfNat1.{u4} R (Semiring.toOne.{u4} R (OrderedSemiring.toSemiring.{u4} R (OrderedRing.toOrderedSemiring.{u4} R _inst_1)))))) -> (Eq.{succ u4} R (Finset.sum.{u4, u2} R ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u4} R (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u4} R (OrderedRing.toOrderedAddCommGroup.{u4} R _inst_1))) s (fun (i : ι) => w₂ i)) (OfNat.ofNat.{u4} R 1 (One.toOfNat1.{u4} R (Semiring.toOne.{u4} R (OrderedSemiring.toSemiring.{u4} R (OrderedRing.toOrderedSemiring.{u4} R _inst_1)))))) -> (Membership.mem.{u1, u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> R) => P) w) (AffineSubspace.{u4, u3, u1} R V ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> R) => P) w₂) (OrderedRing.toRing.{u4} R _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u4, u3, u1} R V ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> R) => P) w₂) (OrderedRing.toRing.{u4} R _inst_1) _inst_2 _inst_3 _inst_4) ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> R) => P) w₂) (AffineSubspace.instSetLikeAffineSubspace.{u4, u3, u1} R V ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> R) => P) w₂) (OrderedRing.toRing.{u4} R _inst_1) _inst_2 _inst_3 _inst_4)) (FunLike.coe.{max (max (succ (max u4 u2)) (succ u3)) (succ u1), succ (max u4 u2), succ u1} (AffineMap.{u4, max u4 u2, max u4 u2, u3, u1} R (ι -> R) (ι -> R) V P (OrderedRing.toRing.{u4} R _inst_1) (Pi.addCommGroup.{u2, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => R) (fun (i : ι) => Ring.toAddCommGroup.{u4} R (OrderedRing.toRing.{u4} R _inst_1))) (Pi.module.{u2, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => R) R (Ring.toSemiring.{u4} R (OrderedRing.toRing.{u4} R _inst_1)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} R (NonAssocRing.toNonUnitalNonAssocRing.{u4} R (Ring.toNonAssocRing.{u4} R (OrderedRing.toRing.{u4} R _inst_1))))) (fun (i : ι) => Semiring.toModule.{u4} R (Ring.toSemiring.{u4} R (OrderedRing.toRing.{u4} R _inst_1)))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u2} R (OrderedRing.toRing.{u4} R _inst_1) ι) _inst_2 _inst_3 _inst_4) (ι -> R) (fun (_x : ι -> R) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> R) => P) _x) (AffineMap.funLike.{u4, max u4 u2, max u4 u2, u3, u1} R (ι -> R) (ι -> R) V P (OrderedRing.toRing.{u4} R _inst_1) (Pi.addCommGroup.{u2, u4} ι (fun (i : ι) => R) (fun (i : ι) => Ring.toAddCommGroup.{u4} R (OrderedRing.toRing.{u4} R _inst_1))) (Pi.module.{u2, u4, u4} ι (fun (i : ι) => R) R (Ring.toSemiring.{u4} R (OrderedRing.toRing.{u4} R _inst_1)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} R (NonAssocRing.toNonUnitalNonAssocRing.{u4} R (Ring.toNonAssocRing.{u4} R (OrderedRing.toRing.{u4} R _inst_1))))) (fun (i : ι) => Semiring.toModule.{u4} R (Ring.toSemiring.{u4} R (OrderedRing.toRing.{u4} R _inst_1)))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u2} R (OrderedRing.toRing.{u4} R _inst_1) ι) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u4, u3, u1, u2} R V P (OrderedRing.toRing.{u4} R _inst_1) _inst_2 _inst_3 _inst_4 ι s p) w) (affineSpan.{u4, u3, u1} R V ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> R) => P) w₂) (OrderedRing.toRing.{u4} R _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> R) => P) w₁) (Set.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> R) => P) w₂)) (Set.instInsertSet.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> R) => P) w₂)) (FunLike.coe.{max (max (succ (max u4 u2)) (succ u3)) (succ u1), succ (max u4 u2), succ u1} (AffineMap.{u4, max u4 u2, max u4 u2, u3, u1} R (ι -> R) (ι -> R) V P (OrderedRing.toRing.{u4} R _inst_1) (Pi.addCommGroup.{u2, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => R) (fun (i : ι) => Ring.toAddCommGroup.{u4} R (OrderedRing.toRing.{u4} R _inst_1))) (Pi.module.{u2, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => R) R (Ring.toSemiring.{u4} R (OrderedRing.toRing.{u4} R _inst_1)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} R (NonAssocRing.toNonUnitalNonAssocRing.{u4} R (Ring.toNonAssocRing.{u4} R (OrderedRing.toRing.{u4} R _inst_1))))) (fun (i : ι) => Semiring.toModule.{u4} R (Ring.toSemiring.{u4} R (OrderedRing.toRing.{u4} R _inst_1)))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u2} R (OrderedRing.toRing.{u4} R _inst_1) ι) _inst_2 _inst_3 _inst_4) (ι -> R) (fun (_x : ι -> R) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> R) => P) _x) (AffineMap.funLike.{u4, max u4 u2, max u4 u2, u3, u1} R (ι -> R) (ι -> R) V P (OrderedRing.toRing.{u4} R _inst_1) (Pi.addCommGroup.{u2, u4} ι (fun (i : ι) => R) (fun (i : ι) => Ring.toAddCommGroup.{u4} R (OrderedRing.toRing.{u4} R _inst_1))) (Pi.module.{u2, u4, u4} ι (fun (i : ι) => R) R (Ring.toSemiring.{u4} R (OrderedRing.toRing.{u4} R _inst_1)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} R (NonAssocRing.toNonUnitalNonAssocRing.{u4} R (Ring.toNonAssocRing.{u4} R (OrderedRing.toRing.{u4} R _inst_1))))) (fun (i : ι) => Semiring.toModule.{u4} R (Ring.toSemiring.{u4} R (OrderedRing.toRing.{u4} R _inst_1)))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u2} R (OrderedRing.toRing.{u4} R _inst_1) ι) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u4, u3, u1, u2} R V P (OrderedRing.toRing.{u4} R _inst_1) _inst_2 _inst_3 _inst_4 ι s p) w₁) (Singleton.singleton.{u1, u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> R) => P) w₂) (Set.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> R) => P) w₂)) (Set.instSingletonSet.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> R) => P) w₂)) (FunLike.coe.{max (max (succ (max u4 u2)) (succ u3)) (succ u1), succ (max u4 u2), succ u1} (AffineMap.{u4, max u4 u2, max u4 u2, u3, u1} R (ι -> R) (ι -> R) V P (OrderedRing.toRing.{u4} R _inst_1) (Pi.addCommGroup.{u2, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => R) (fun (i : ι) => Ring.toAddCommGroup.{u4} R (OrderedRing.toRing.{u4} R _inst_1))) (Pi.module.{u2, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => R) R (Ring.toSemiring.{u4} R (OrderedRing.toRing.{u4} R _inst_1)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} R (NonAssocRing.toNonUnitalNonAssocRing.{u4} R (Ring.toNonAssocRing.{u4} R (OrderedRing.toRing.{u4} R _inst_1))))) (fun (i : ι) => Semiring.toModule.{u4} R (Ring.toSemiring.{u4} R (OrderedRing.toRing.{u4} R _inst_1)))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u2} R (OrderedRing.toRing.{u4} R _inst_1) ι) _inst_2 _inst_3 _inst_4) (ι -> R) (fun (_x : ι -> R) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> R) => P) _x) (AffineMap.funLike.{u4, max u4 u2, max u4 u2, u3, u1} R (ι -> R) (ι -> R) V P (OrderedRing.toRing.{u4} R _inst_1) (Pi.addCommGroup.{u2, u4} ι (fun (i : ι) => R) (fun (i : ι) => Ring.toAddCommGroup.{u4} R (OrderedRing.toRing.{u4} R _inst_1))) (Pi.module.{u2, u4, u4} ι (fun (i : ι) => R) R (Ring.toSemiring.{u4} R (OrderedRing.toRing.{u4} R _inst_1)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} R (NonAssocRing.toNonUnitalNonAssocRing.{u4} R (Ring.toNonAssocRing.{u4} R (OrderedRing.toRing.{u4} R _inst_1))))) (fun (i : ι) => Semiring.toModule.{u4} R (Ring.toSemiring.{u4} R (OrderedRing.toRing.{u4} R _inst_1)))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u2} R (OrderedRing.toRing.{u4} R _inst_1) ι) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u4, u3, u1, u2} R V P (OrderedRing.toRing.{u4} R _inst_1) _inst_2 _inst_3 _inst_4 ι s p) w₂))))) -> (forall {i : ι}, (Membership.mem.{u2, u2} ι (Finset.{u2} ι) (Finset.instMembershipFinset.{u2} ι) i s) -> (Sbtw.{u4, u4, u4} R R R _inst_1 (OrderedAddCommGroup.toAddCommGroup.{u4} R (OrderedRing.toOrderedAddCommGroup.{u4} R _inst_1)) (Semiring.toModule.{u4} R (OrderedSemiring.toSemiring.{u4} R (OrderedRing.toOrderedSemiring.{u4} R _inst_1))) (addGroupIsAddTorsor.{u4} R (AddGroupWithOne.toAddGroup.{u4} R (Ring.toAddGroupWithOne.{u4} R (OrderedRing.toRing.{u4} R _inst_1)))) (w₁ i) (w i) (w₂ i)) -> (Sbtw.{u4, u3, u1} R V ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> R) => P) w₁) _inst_1 _inst_2 _inst_3 _inst_4 (FunLike.coe.{max (max (succ (max u4 u2)) (succ u3)) (succ u1), succ (max u4 u2), succ u1} (AffineMap.{u4, max u4 u2, max u4 u2, u3, u1} R (ι -> R) (ι -> R) V P (OrderedRing.toRing.{u4} R _inst_1) (Pi.addCommGroup.{u2, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => R) (fun (i : ι) => Ring.toAddCommGroup.{u4} R (OrderedRing.toRing.{u4} R _inst_1))) (Pi.module.{u2, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => R) R (Ring.toSemiring.{u4} R (OrderedRing.toRing.{u4} R _inst_1)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} R (NonAssocRing.toNonUnitalNonAssocRing.{u4} R (Ring.toNonAssocRing.{u4} R (OrderedRing.toRing.{u4} R _inst_1))))) (fun (i : ι) => Semiring.toModule.{u4} R (Ring.toSemiring.{u4} R (OrderedRing.toRing.{u4} R _inst_1)))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u2} R (OrderedRing.toRing.{u4} R _inst_1) ι) _inst_2 _inst_3 _inst_4) (ι -> R) (fun (_x : ι -> R) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> R) => P) _x) (AffineMap.funLike.{u4, max u4 u2, max u4 u2, u3, u1} R (ι -> R) (ι -> R) V P (OrderedRing.toRing.{u4} R _inst_1) (Pi.addCommGroup.{u2, u4} ι (fun (i : ι) => R) (fun (i : ι) => Ring.toAddCommGroup.{u4} R (OrderedRing.toRing.{u4} R _inst_1))) (Pi.module.{u2, u4, u4} ι (fun (i : ι) => R) R (Ring.toSemiring.{u4} R (OrderedRing.toRing.{u4} R _inst_1)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} R (NonAssocRing.toNonUnitalNonAssocRing.{u4} R (Ring.toNonAssocRing.{u4} R (OrderedRing.toRing.{u4} R _inst_1))))) (fun (i : ι) => Semiring.toModule.{u4} R (Ring.toSemiring.{u4} R (OrderedRing.toRing.{u4} R _inst_1)))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u2} R (OrderedRing.toRing.{u4} R _inst_1) ι) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u4, u3, u1, u2} R V P (OrderedRing.toRing.{u4} R _inst_1) _inst_2 _inst_3 _inst_4 ι s p) w₁) (FunLike.coe.{max (max (succ (max u4 u2)) (succ u3)) (succ u1), succ (max u4 u2), succ u1} (AffineMap.{u4, max u4 u2, max u4 u2, u3, u1} R (ι -> R) (ι -> R) V P (OrderedRing.toRing.{u4} R _inst_1) (Pi.addCommGroup.{u2, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => R) (fun (i : ι) => Ring.toAddCommGroup.{u4} R (OrderedRing.toRing.{u4} R _inst_1))) (Pi.module.{u2, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => R) R (Ring.toSemiring.{u4} R (OrderedRing.toRing.{u4} R _inst_1)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} R (NonAssocRing.toNonUnitalNonAssocRing.{u4} R (Ring.toNonAssocRing.{u4} R (OrderedRing.toRing.{u4} R _inst_1))))) (fun (i : ι) => Semiring.toModule.{u4} R (Ring.toSemiring.{u4} R (OrderedRing.toRing.{u4} R _inst_1)))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u2} R (OrderedRing.toRing.{u4} R _inst_1) ι) _inst_2 _inst_3 _inst_4) (ι -> R) (fun (_x : ι -> R) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> R) => P) _x) (AffineMap.funLike.{u4, max u4 u2, max u4 u2, u3, u1} R (ι -> R) (ι -> R) V P (OrderedRing.toRing.{u4} R _inst_1) (Pi.addCommGroup.{u2, u4} ι (fun (i : ι) => R) (fun (i : ι) => Ring.toAddCommGroup.{u4} R (OrderedRing.toRing.{u4} R _inst_1))) (Pi.module.{u2, u4, u4} ι (fun (i : ι) => R) R (Ring.toSemiring.{u4} R (OrderedRing.toRing.{u4} R _inst_1)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} R (NonAssocRing.toNonUnitalNonAssocRing.{u4} R (Ring.toNonAssocRing.{u4} R (OrderedRing.toRing.{u4} R _inst_1))))) (fun (i : ι) => Semiring.toModule.{u4} R (Ring.toSemiring.{u4} R (OrderedRing.toRing.{u4} R _inst_1)))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u2} R (OrderedRing.toRing.{u4} R _inst_1) ι) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u4, u3, u1, u2} R V P (OrderedRing.toRing.{u4} R _inst_1) _inst_2 _inst_3 _inst_4 ι s p) w) (FunLike.coe.{max (max (succ (max u4 u2)) (succ u3)) (succ u1), succ (max u4 u2), succ u1} (AffineMap.{u4, max u4 u2, max u4 u2, u3, u1} R (ι -> R) (ι -> R) V P (OrderedRing.toRing.{u4} R _inst_1) (Pi.addCommGroup.{u2, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => R) (fun (i : ι) => Ring.toAddCommGroup.{u4} R (OrderedRing.toRing.{u4} R _inst_1))) (Pi.module.{u2, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => R) R (Ring.toSemiring.{u4} R (OrderedRing.toRing.{u4} R _inst_1)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} R (NonAssocRing.toNonUnitalNonAssocRing.{u4} R (Ring.toNonAssocRing.{u4} R (OrderedRing.toRing.{u4} R _inst_1))))) (fun (i : ι) => Semiring.toModule.{u4} R (Ring.toSemiring.{u4} R (OrderedRing.toRing.{u4} R _inst_1)))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u2} R (OrderedRing.toRing.{u4} R _inst_1) ι) _inst_2 _inst_3 _inst_4) (ι -> R) (fun (_x : ι -> R) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> R) => P) _x) (AffineMap.funLike.{u4, max u4 u2, max u4 u2, u3, u1} R (ι -> R) (ι -> R) V P (OrderedRing.toRing.{u4} R _inst_1) (Pi.addCommGroup.{u2, u4} ι (fun (i : ι) => R) (fun (i : ι) => Ring.toAddCommGroup.{u4} R (OrderedRing.toRing.{u4} R _inst_1))) (Pi.module.{u2, u4, u4} ι (fun (i : ι) => R) R (Ring.toSemiring.{u4} R (OrderedRing.toRing.{u4} R _inst_1)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} R (NonAssocRing.toNonUnitalNonAssocRing.{u4} R (Ring.toNonAssocRing.{u4} R (OrderedRing.toRing.{u4} R _inst_1))))) (fun (i : ι) => Semiring.toModule.{u4} R (Ring.toSemiring.{u4} R (OrderedRing.toRing.{u4} R _inst_1)))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u2} R (OrderedRing.toRing.{u4} R _inst_1) ι) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u4, u3, u1, u2} R V P (OrderedRing.toRing.{u4} R _inst_1) _inst_2 _inst_3 _inst_4 ι s p) w₂))))
Case conversion may be inaccurate. Consider using '#align sbtw.affine_combination_of_mem_affine_span_pair Sbtw.affineCombination_of_mem_affineSpan_pairₓ'. -/
theorem Sbtw.affineCombination_of_mem_affineSpan_pair [NoZeroDivisors R] [NoZeroSMulDivisors R V]
    {ι : Type _} {p : ι → P} (ha : AffineIndependent R p) {w w₁ w₂ : ι → R} {s : Finset ι}
    (hw : (∑ i in s, w i) = 1) (hw₁ : (∑ i in s, w₁ i) = 1) (hw₂ : (∑ i in s, w₂ i) = 1)
    (h :
      s.affineCombination R p w ∈ line[R, s.affineCombination R p w₁, s.affineCombination R p w₂])
    {i : ι} (his : i ∈ s) (hs : Sbtw R (w₁ i) (w i) (w₂ i)) :
    Sbtw R (s.affineCombination R p w₁) (s.affineCombination R p w) (s.affineCombination R p w₂) :=
  by
  rw [affineCombination_mem_affineSpan_pair ha hw hw₁ hw₂] at h
  rcases h with ⟨r, hr⟩
  dsimp only at hr
  rw [hr i his, sbtw_mul_sub_add_iff] at hs
  change ∀ i ∈ s, w i = (r • (w₂ - w₁) + w₁) i at hr
  rw [s.affine_combination_congr hr fun _ _ => rfl]
  dsimp only
  rw [← s.weighted_vsub_vadd_affine_combination, s.weighted_vsub_const_smul, ←
    s.affine_combination_vsub, ← line_map_apply, sbtw_lineMap_iff, and_iff_left hs.2, ←
    @vsub_ne_zero V, s.affine_combination_vsub]
  intro hz
  have hw₁w₂ : (∑ i in s, (w₁ - w₂) i) = 0 := by
    simp_rw [Pi.sub_apply, Finset.sum_sub_distrib, hw₁, hw₂, sub_self]
  refine' hs.1 _
  have ha' := ha s (w₁ - w₂) hw₁w₂ hz i his
  rwa [Pi.sub_apply, sub_eq_zero] at ha'
#align sbtw.affine_combination_of_mem_affine_span_pair Sbtw.affineCombination_of_mem_affineSpan_pair

end OrderedRing

section StrictOrderedCommRing

variable [StrictOrderedCommRing R] [AddCommGroup V] [Module R V] [AddTorsor V P]

include V

variable {R}

/- warning: wbtw.same_ray_vsub -> Wbtw.sameRay_vsub is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : StrictOrderedCommRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (StrictOrderedRing.toRing.{u1} R (StrictOrderedCommRing.toStrictOrderedRing.{u1} R _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Wbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (StrictOrderedCommRing.toStrictOrderedRing.{u1} R _inst_1)) _inst_2 _inst_3 _inst_4 x y z) -> (SameRay.{u1, u2} R (StrictOrderedCommRing.toStrictOrderedCommSemiring.{u1} R _inst_1) V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) y x) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) z y))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : StrictOrderedCommRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (StrictOrderedSemiring.toSemiring.{u3} R (StrictOrderedCommSemiring.toStrictOrderedSemiring.{u3} R (StrictOrderedCommRing.toStrictOrderedCommSemiring.{u3} R _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Wbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R _inst_1)) _inst_2 _inst_3 _inst_4 x y z) -> (SameRay.{u3, u2} R (StrictOrderedCommRing.toStrictOrderedCommSemiring.{u3} R _inst_1) V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) y x) (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) z y))
Case conversion may be inaccurate. Consider using '#align wbtw.same_ray_vsub Wbtw.sameRay_vsubₓ'. -/
theorem Wbtw.sameRay_vsub {x y z : P} (h : Wbtw R x y z) : SameRay R (y -ᵥ x) (z -ᵥ y) :=
  by
  rcases h with ⟨t, ⟨ht0, ht1⟩, rfl⟩
  simp_rw [line_map_apply]
  rcases ht0.lt_or_eq with (ht0' | rfl); swap; · simp
  rcases ht1.lt_or_eq with (ht1' | rfl); swap; · simp
  refine' Or.inr (Or.inr ⟨1 - t, t, sub_pos.2 ht1', ht0', _⟩)
  simp [vsub_vadd_eq_vsub_sub, smul_sub, smul_smul, ← sub_smul]
  ring_nf
#align wbtw.same_ray_vsub Wbtw.sameRay_vsub

/- warning: wbtw.same_ray_vsub_left -> Wbtw.sameRay_vsub_left is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : StrictOrderedCommRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (StrictOrderedRing.toRing.{u1} R (StrictOrderedCommRing.toStrictOrderedRing.{u1} R _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Wbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (StrictOrderedCommRing.toStrictOrderedRing.{u1} R _inst_1)) _inst_2 _inst_3 _inst_4 x y z) -> (SameRay.{u1, u2} R (StrictOrderedCommRing.toStrictOrderedCommSemiring.{u1} R _inst_1) V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) y x) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) z x))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : StrictOrderedCommRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (StrictOrderedSemiring.toSemiring.{u3} R (StrictOrderedCommSemiring.toStrictOrderedSemiring.{u3} R (StrictOrderedCommRing.toStrictOrderedCommSemiring.{u3} R _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Wbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R _inst_1)) _inst_2 _inst_3 _inst_4 x y z) -> (SameRay.{u3, u2} R (StrictOrderedCommRing.toStrictOrderedCommSemiring.{u3} R _inst_1) V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) y x) (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) z x))
Case conversion may be inaccurate. Consider using '#align wbtw.same_ray_vsub_left Wbtw.sameRay_vsub_leftₓ'. -/
theorem Wbtw.sameRay_vsub_left {x y z : P} (h : Wbtw R x y z) : SameRay R (y -ᵥ x) (z -ᵥ x) :=
  by
  rcases h with ⟨t, ⟨ht0, ht1⟩, rfl⟩
  simpa [line_map_apply] using SameRay.sameRay_nonneg_smul_left (z -ᵥ x) ht0
#align wbtw.same_ray_vsub_left Wbtw.sameRay_vsub_left

/- warning: wbtw.same_ray_vsub_right -> Wbtw.sameRay_vsub_right is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : StrictOrderedCommRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (StrictOrderedRing.toRing.{u1} R (StrictOrderedCommRing.toStrictOrderedRing.{u1} R _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Wbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (StrictOrderedCommRing.toStrictOrderedRing.{u1} R _inst_1)) _inst_2 _inst_3 _inst_4 x y z) -> (SameRay.{u1, u2} R (StrictOrderedCommRing.toStrictOrderedCommSemiring.{u1} R _inst_1) V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) z x) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) z y))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : StrictOrderedCommRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (StrictOrderedSemiring.toSemiring.{u3} R (StrictOrderedCommSemiring.toStrictOrderedSemiring.{u3} R (StrictOrderedCommRing.toStrictOrderedCommSemiring.{u3} R _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Wbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R _inst_1)) _inst_2 _inst_3 _inst_4 x y z) -> (SameRay.{u3, u2} R (StrictOrderedCommRing.toStrictOrderedCommSemiring.{u3} R _inst_1) V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) z x) (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) z y))
Case conversion may be inaccurate. Consider using '#align wbtw.same_ray_vsub_right Wbtw.sameRay_vsub_rightₓ'. -/
theorem Wbtw.sameRay_vsub_right {x y z : P} (h : Wbtw R x y z) : SameRay R (z -ᵥ x) (z -ᵥ y) :=
  by
  rcases h with ⟨t, ⟨ht0, ht1⟩, rfl⟩
  simpa [line_map_apply, vsub_vadd_eq_vsub_sub, sub_smul] using
    SameRay.sameRay_nonneg_smul_right (z -ᵥ x) (sub_nonneg.2 ht1)
#align wbtw.same_ray_vsub_right Wbtw.sameRay_vsub_right

end StrictOrderedCommRing

section LinearOrderedRing

variable [LinearOrderedRing R] [AddCommGroup V] [Module R V] [AddTorsor V P]

include V

variable {R}

/- warning: sbtw_of_sbtw_of_sbtw_of_mem_affine_span_pair -> sbtw_of_sbtw_of_sbtw_of_mem_affineSpan_pair is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : LinearOrderedRing.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : NoZeroSMulDivisors.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {t : Affine.Triangle.{u1, u2, u3} R V P (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)) _inst_2 _inst_3 _inst_4} {i₁ : Fin (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))} {i₂ : Fin (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))} {i₃ : Fin (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))}, (Ne.{1} (Fin (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) i₁ i₂) -> (forall {p₁ : P} {p₂ : P} {p : P}, (Sbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)) _inst_2 _inst_3 _inst_4 (Affine.Simplex.points.{u1, u2, u3} R V P (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)) _inst_2 _inst_3 _inst_4 (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) t i₂) p₁ (Affine.Simplex.points.{u1, u2, u3} R V P (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)) _inst_2 _inst_3 _inst_4 (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) t i₃)) -> (Sbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)) _inst_2 _inst_3 _inst_4 (Affine.Simplex.points.{u1, u2, u3} R V P (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)) _inst_2 _inst_3 _inst_4 (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) t i₁) p₂ (Affine.Simplex.points.{u1, u2, u3} R V P (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)) _inst_2 _inst_3 _inst_4 (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) t i₃)) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} R V P (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} R V P (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} R V P (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)) _inst_2 _inst_3 _inst_4)) p (affineSpan.{u1, u2, u3} R V P (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) (Affine.Simplex.points.{u1, u2, u3} R V P (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)) _inst_2 _inst_3 _inst_4 (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) t i₁) (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₁)))) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} R V P (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} R V P (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} R V P (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)) _inst_2 _inst_3 _inst_4)) p (affineSpan.{u1, u2, u3} R V P (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) (Affine.Simplex.points.{u1, u2, u3} R V P (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)) _inst_2 _inst_3 _inst_4 (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) t i₂) (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₂)))) -> (Sbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)) _inst_2 _inst_3 _inst_4 (Affine.Simplex.points.{u1, u2, u3} R V P (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)) _inst_2 _inst_3 _inst_4 (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) t i₁) p p₁))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : LinearOrderedRing.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (StrictOrderedSemiring.toSemiring.{u3} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u3} R (LinearOrderedRing.toLinearOrderedSemiring.{u3} R _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : NoZeroSMulDivisors.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (StrictOrderedSemiring.toSemiring.{u3} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u3} R (LinearOrderedRing.toLinearOrderedSemiring.{u3} R _inst_1))))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (StrictOrderedSemiring.toSemiring.{u3} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u3} R (LinearOrderedRing.toLinearOrderedSemiring.{u3} R _inst_1))))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (StrictOrderedSemiring.toSemiring.{u3} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u3} R (LinearOrderedRing.toLinearOrderedSemiring.{u3} R _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (StrictOrderedSemiring.toSemiring.{u3} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u3} R (LinearOrderedRing.toLinearOrderedSemiring.{u3} R _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {t : Affine.Triangle.{u3, u2, u1} R V P (StrictOrderedRing.toRing.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R _inst_1)) _inst_2 _inst_3 _inst_4} {i₁ : Fin (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))} {i₂ : Fin (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))} {i₃ : Fin (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))}, (Ne.{1} (Fin (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))) i₁ i₂) -> (forall {p₁ : P} {p₂ : P} {p : P}, (Sbtw.{u3, u2, u1} R V P (StrictOrderedRing.toOrderedRing.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R _inst_1)) _inst_2 _inst_3 _inst_4 (Affine.Simplex.points.{u3, u2, u1} R V P (StrictOrderedRing.toRing.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R _inst_1)) _inst_2 _inst_3 _inst_4 (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) t i₂) p₁ (Affine.Simplex.points.{u3, u2, u1} R V P (StrictOrderedRing.toRing.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R _inst_1)) _inst_2 _inst_3 _inst_4 (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) t i₃)) -> (Sbtw.{u3, u2, u1} R V P (StrictOrderedRing.toOrderedRing.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R _inst_1)) _inst_2 _inst_3 _inst_4 (Affine.Simplex.points.{u3, u2, u1} R V P (StrictOrderedRing.toRing.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R _inst_1)) _inst_2 _inst_3 _inst_4 (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) t i₁) p₂ (Affine.Simplex.points.{u3, u2, u1} R V P (StrictOrderedRing.toRing.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R _inst_1)) _inst_2 _inst_3 _inst_4 (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) t i₃)) -> (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} R V P (StrictOrderedRing.toRing.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R _inst_1)) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} R V P (StrictOrderedRing.toRing.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R _inst_1)) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} R V P (StrictOrderedRing.toRing.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R _inst_1)) _inst_2 _inst_3 _inst_4)) p (affineSpan.{u3, u2, u1} R V P (StrictOrderedRing.toRing.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R _inst_1)) _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) (Affine.Simplex.points.{u3, u2, u1} R V P (StrictOrderedRing.toRing.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R _inst_1)) _inst_2 _inst_3 _inst_4 (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) t i₁) (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) p₁)))) -> (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} R V P (StrictOrderedRing.toRing.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R _inst_1)) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} R V P (StrictOrderedRing.toRing.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R _inst_1)) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} R V P (StrictOrderedRing.toRing.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R _inst_1)) _inst_2 _inst_3 _inst_4)) p (affineSpan.{u3, u2, u1} R V P (StrictOrderedRing.toRing.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R _inst_1)) _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) (Affine.Simplex.points.{u3, u2, u1} R V P (StrictOrderedRing.toRing.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R _inst_1)) _inst_2 _inst_3 _inst_4 (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) t i₂) (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) p₂)))) -> (Sbtw.{u3, u2, u1} R V P (StrictOrderedRing.toOrderedRing.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R _inst_1)) _inst_2 _inst_3 _inst_4 (Affine.Simplex.points.{u3, u2, u1} R V P (StrictOrderedRing.toRing.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R _inst_1)) _inst_2 _inst_3 _inst_4 (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) t i₁) p p₁))
Case conversion may be inaccurate. Consider using '#align sbtw_of_sbtw_of_sbtw_of_mem_affine_span_pair sbtw_of_sbtw_of_sbtw_of_mem_affineSpan_pairₓ'. -/
/-- Suppose lines from two vertices of a triangle to interior points of the opposite side meet at
`p`. Then `p` lies in the interior of the first (and by symmetry the other) segment from a
vertex to the point on the opposite side. -/
theorem sbtw_of_sbtw_of_sbtw_of_mem_affineSpan_pair [NoZeroSMulDivisors R V]
    {t : Affine.Triangle R P} {i₁ i₂ i₃ : Fin 3} (h₁₂ : i₁ ≠ i₂) {p₁ p₂ p : P}
    (h₁ : Sbtw R (t.points i₂) p₁ (t.points i₃)) (h₂ : Sbtw R (t.points i₁) p₂ (t.points i₃))
    (h₁' : p ∈ line[R, t.points i₁, p₁]) (h₂' : p ∈ line[R, t.points i₂, p₂]) :
    Sbtw R (t.points i₁) p p₁ :=
  by
  -- Should not be needed; see comments on local instances in `data.sign`.
  letI : DecidableRel ((· < ·) : R → R → Prop) := LinearOrderedRing.decidableLt
  have h₁₃ : i₁ ≠ i₃ := by
    rintro rfl
    simpa using h₂
  have h₂₃ : i₂ ≠ i₃ := by
    rintro rfl
    simpa using h₁
  have h3 : ∀ i : Fin 3, i = i₁ ∨ i = i₂ ∨ i = i₃ :=
    by
    clear h₁ h₂ h₁' h₂'
    decide!
  have hu : (Finset.univ : Finset (Fin 3)) = {i₁, i₂, i₃} :=
    by
    clear h₁ h₂ h₁' h₂'
    decide!
  have hp : p ∈ affineSpan R (Set.range t.points) :=
    by
    have hle : line[R, t.points i₁, p₁] ≤ affineSpan R (Set.range t.points) :=
      by
      refine' affineSpan_pair_le_of_mem_of_mem (mem_affineSpan _ (Set.mem_range_self _)) _
      have hle : line[R, t.points i₂, t.points i₃] ≤ affineSpan R (Set.range t.points) :=
        by
        refine' affineSpan_mono _ _
        simp [Set.insert_subset]
      rw [AffineSubspace.le_def'] at hle
      exact hle _ h₁.wbtw.mem_affine_span
    rw [AffineSubspace.le_def'] at hle
    exact hle _ h₁'
  have h₁i := h₁.mem_image_Ioo
  have h₂i := h₂.mem_image_Ioo
  rw [Set.mem_image] at h₁i h₂i
  rcases h₁i with ⟨r₁, ⟨hr₁0, hr₁1⟩, rfl⟩
  rcases h₂i with ⟨r₂, ⟨hr₂0, hr₂1⟩, rfl⟩
  rcases eq_affineCombination_of_mem_affineSpan_of_fintype hp with ⟨w, hw, rfl⟩
  have h₁s :=
    sign_eq_of_affineCombination_mem_affineSpan_single_lineMap t.independent hw (Finset.mem_univ _)
      (Finset.mem_univ _) (Finset.mem_univ _) h₁₂ h₁₃ h₂₃ hr₁0 hr₁1 h₁'
  have h₂s :=
    sign_eq_of_affineCombination_mem_affineSpan_single_lineMap t.independent hw (Finset.mem_univ _)
      (Finset.mem_univ _) (Finset.mem_univ _) h₁₂.symm h₂₃ h₁₃ hr₂0 hr₂1 h₂'
  dsimp only at h₁s h₂s
  rw [←
    finset.univ.affine_combination_affine_combination_single_weights R t.points
      (Finset.mem_univ i₁),
    ←
    finset.univ.affine_combination_affine_combination_line_map_weights t.points (Finset.mem_univ _)
      (Finset.mem_univ _)] at
    h₁'⊢
  refine'
    Sbtw.affineCombination_of_mem_affineSpan_pair t.independent hw
      (finset.univ.sum_affine_combination_single_weights R (Finset.mem_univ _))
      (finset.univ.sum_affine_combination_line_map_weights (Finset.mem_univ _) (Finset.mem_univ _)
        _)
      h₁' (Finset.mem_univ i₁) _
  rw [Finset.affineCombinationSingleWeights_apply_self,
    Finset.affineCombinationLineMapWeights_apply_of_ne h₁₂ h₁₃, sbtw_one_zero_iff]
  have hs : ∀ i : Fin 3, SignType.sign (w i) = SignType.sign (w i₃) :=
    by
    intro i
    rcases h3 i with (rfl | rfl | rfl)
    · exact h₂s
    · exact h₁s
    · rfl
  have hss : SignType.sign (∑ i, w i) = 1 := by simp [hw]
  have hs' := sign_sum Finset.univ_nonempty (SignType.sign (w i₃)) fun i _ => hs i
  rw [hs'] at hss
  simp_rw [hss, sign_eq_one_iff] at hs
  refine' ⟨hs i₁, _⟩
  rw [hu] at hw
  rw [Finset.sum_insert, Finset.sum_insert, Finset.sum_singleton] at hw
  · by_contra hle
    rw [not_lt] at hle
    exact (hle.trans_lt (lt_add_of_pos_right _ (Left.add_pos (hs i₂) (hs i₃)))).ne' hw
  · simp [h₂₃]
  · simp [h₁₂, h₁₃]
#align sbtw_of_sbtw_of_sbtw_of_mem_affine_span_pair sbtw_of_sbtw_of_sbtw_of_mem_affineSpan_pair

end LinearOrderedRing

section LinearOrderedField

variable [LinearOrderedField R] [AddCommGroup V] [Module R V] [AddTorsor V P]

include V

variable {R}

/- warning: wbtw_iff_left_eq_or_right_mem_image_Ici -> wbtw_iff_left_eq_or_right_mem_image_Ici is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : LinearOrderedField.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, Iff (Wbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z) (Or (Eq.{succ u3} P x y) (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) z (Set.image.{u1, u3} R P (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} R R R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} R R R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))))) _inst_2 _inst_3 _inst_4) => R -> P) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} R R R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) _inst_2 _inst_3 _inst_4 x y)) (Set.Ici.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))))))))))))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : LinearOrderedField.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, Iff (Wbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z) (Or (Eq.{succ u1} P x y) (Membership.mem.{u1, u1} P (Set.{u1} P) (Set.instMembershipSet.{u1} P) z (Set.image.{u3, u1} R P (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u3, u3, u3, u2, u1} R R R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) (Ring.toAddCommGroup.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))))) (addGroupIsAddTorsor.{u3} R (AddGroupWithOne.toAddGroup.{u3} R (Ring.toAddGroupWithOne.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)))))) _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : R) => P) _x) (AffineMap.funLike.{u3, u3, u3, u2, u1} R R R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) (Ring.toAddCommGroup.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))))) (addGroupIsAddTorsor.{u3} R (AddGroupWithOne.toAddGroup.{u3} R (Ring.toAddGroupWithOne.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)))))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u3, u2, u1} R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) _inst_2 _inst_3 _inst_4 x y)) (Set.Ici.{u3} R (PartialOrder.toPreorder.{u3} R (StrictOrderedRing.toPartialOrder.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R (LinearOrderedCommRing.toLinearOrderedRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1))))) (OfNat.ofNat.{u3} R 1 (One.toOfNat1.{u3} R (Semiring.toOne.{u3} R (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))))))))))
Case conversion may be inaccurate. Consider using '#align wbtw_iff_left_eq_or_right_mem_image_Ici wbtw_iff_left_eq_or_right_mem_image_Iciₓ'. -/
theorem wbtw_iff_left_eq_or_right_mem_image_Ici {x y z : P} :
    Wbtw R x y z ↔ x = y ∨ z ∈ lineMap x y '' Set.Ici (1 : R) :=
  by
  refine' ⟨fun h => _, fun h => _⟩
  · rcases h with ⟨r, ⟨hr0, hr1⟩, rfl⟩
    rcases hr0.lt_or_eq with (hr0' | rfl)
    · rw [Set.mem_image]
      refine' Or.inr ⟨r⁻¹, one_le_inv hr0' hr1, _⟩
      simp only [line_map_apply, smul_smul, vadd_vsub]
      rw [inv_mul_cancel hr0'.ne', one_smul, vsub_vadd]
    · simp
  · rcases h with (rfl | ⟨r, ⟨hr, rfl⟩⟩)
    · exact wbtw_self_left _ _ _
    · rw [Set.mem_Ici] at hr
      refine' ⟨r⁻¹, ⟨inv_nonneg.2 (zero_le_one.trans hr), inv_le_one hr⟩, _⟩
      simp only [line_map_apply, smul_smul, vadd_vsub]
      rw [inv_mul_cancel (one_pos.trans_le hr).ne', one_smul, vsub_vadd]
#align wbtw_iff_left_eq_or_right_mem_image_Ici wbtw_iff_left_eq_or_right_mem_image_Ici

/- warning: wbtw.right_mem_image_Ici_of_left_ne -> Wbtw.right_mem_image_Ici_of_left_ne is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : LinearOrderedField.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Wbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z) -> (Ne.{succ u3} P x y) -> (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) z (Set.image.{u1, u3} R P (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} R R R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} R R R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))))) _inst_2 _inst_3 _inst_4) => R -> P) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} R R R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) _inst_2 _inst_3 _inst_4 x y)) (Set.Ici.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))))))))))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : LinearOrderedField.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Wbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z) -> (Ne.{succ u1} P x y) -> (Membership.mem.{u1, u1} P (Set.{u1} P) (Set.instMembershipSet.{u1} P) z (Set.image.{u3, u1} R P (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u3, u3, u3, u2, u1} R R R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) (Ring.toAddCommGroup.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))))) (addGroupIsAddTorsor.{u3} R (AddGroupWithOne.toAddGroup.{u3} R (Ring.toAddGroupWithOne.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)))))) _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : R) => P) _x) (AffineMap.funLike.{u3, u3, u3, u2, u1} R R R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) (Ring.toAddCommGroup.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))))) (addGroupIsAddTorsor.{u3} R (AddGroupWithOne.toAddGroup.{u3} R (Ring.toAddGroupWithOne.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)))))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u3, u2, u1} R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) _inst_2 _inst_3 _inst_4 x y)) (Set.Ici.{u3} R (PartialOrder.toPreorder.{u3} R (StrictOrderedRing.toPartialOrder.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R (LinearOrderedCommRing.toLinearOrderedRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1))))) (OfNat.ofNat.{u3} R 1 (One.toOfNat1.{u3} R (Semiring.toOne.{u3} R (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))))))))
Case conversion may be inaccurate. Consider using '#align wbtw.right_mem_image_Ici_of_left_ne Wbtw.right_mem_image_Ici_of_left_neₓ'. -/
theorem Wbtw.right_mem_image_Ici_of_left_ne {x y z : P} (h : Wbtw R x y z) (hne : x ≠ y) :
    z ∈ lineMap x y '' Set.Ici (1 : R) :=
  (wbtw_iff_left_eq_or_right_mem_image_Ici.1 h).resolve_left hne
#align wbtw.right_mem_image_Ici_of_left_ne Wbtw.right_mem_image_Ici_of_left_ne

/- warning: wbtw.right_mem_affine_span_of_left_ne -> Wbtw.right_mem_affineSpan_of_left_ne is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : LinearOrderedField.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Wbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z) -> (Ne.{succ u3} P x y) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) _inst_2 _inst_3 _inst_4)) z (affineSpan.{u1, u2, u3} R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) x (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) y))))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : LinearOrderedField.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Wbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z) -> (Ne.{succ u1} P x y) -> (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) _inst_2 _inst_3 _inst_4)) z (affineSpan.{u3, u2, u1} R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) x (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) y))))
Case conversion may be inaccurate. Consider using '#align wbtw.right_mem_affine_span_of_left_ne Wbtw.right_mem_affineSpan_of_left_neₓ'. -/
theorem Wbtw.right_mem_affineSpan_of_left_ne {x y z : P} (h : Wbtw R x y z) (hne : x ≠ y) :
    z ∈ line[R, x, y] :=
  by
  rcases h.right_mem_image_Ici_of_left_ne hne with ⟨r, ⟨-, rfl⟩⟩
  exact line_map_mem_affine_span_pair _ _ _
#align wbtw.right_mem_affine_span_of_left_ne Wbtw.right_mem_affineSpan_of_left_ne

/- warning: sbtw_iff_left_ne_and_right_mem_image_IoI -> sbtw_iff_left_ne_and_right_mem_image_Ioi is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : LinearOrderedField.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, Iff (Sbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z) (And (Ne.{succ u3} P x y) (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) z (Set.image.{u1, u3} R P (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} R R R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} R R R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))))) _inst_2 _inst_3 _inst_4) => R -> P) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} R R R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) _inst_2 _inst_3 _inst_4 x y)) (Set.Ioi.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))))))))))))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : LinearOrderedField.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, Iff (Sbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z) (And (Ne.{succ u1} P x y) (Membership.mem.{u1, u1} P (Set.{u1} P) (Set.instMembershipSet.{u1} P) z (Set.image.{u3, u1} R P (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u3, u3, u3, u2, u1} R R R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) (Ring.toAddCommGroup.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))))) (addGroupIsAddTorsor.{u3} R (AddGroupWithOne.toAddGroup.{u3} R (Ring.toAddGroupWithOne.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)))))) _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : R) => P) _x) (AffineMap.funLike.{u3, u3, u3, u2, u1} R R R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) (Ring.toAddCommGroup.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))))) (addGroupIsAddTorsor.{u3} R (AddGroupWithOne.toAddGroup.{u3} R (Ring.toAddGroupWithOne.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)))))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u3, u2, u1} R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) _inst_2 _inst_3 _inst_4 x y)) (Set.Ioi.{u3} R (PartialOrder.toPreorder.{u3} R (StrictOrderedRing.toPartialOrder.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R (LinearOrderedCommRing.toLinearOrderedRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1))))) (OfNat.ofNat.{u3} R 1 (One.toOfNat1.{u3} R (Semiring.toOne.{u3} R (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))))))))))
Case conversion may be inaccurate. Consider using '#align sbtw_iff_left_ne_and_right_mem_image_IoI sbtw_iff_left_ne_and_right_mem_image_Ioiₓ'. -/
theorem sbtw_iff_left_ne_and_right_mem_image_Ioi {x y z : P} :
    Sbtw R x y z ↔ x ≠ y ∧ z ∈ lineMap x y '' Set.Ioi (1 : R) :=
  by
  refine' ⟨fun h => ⟨h.left_ne, _⟩, fun h => _⟩
  · obtain ⟨r, ⟨hr, rfl⟩⟩ := h.wbtw.right_mem_image_Ici_of_left_ne h.left_ne
    rw [Set.mem_Ici] at hr
    rcases hr.lt_or_eq with (hrlt | rfl)
    · exact Set.mem_image_of_mem _ hrlt
    · exfalso
      simpa using h
  · rcases h with ⟨hne, r, hr, rfl⟩
    rw [Set.mem_Ioi] at hr
    refine'
      ⟨wbtw_iff_left_eq_or_right_mem_image_Ici.2
          (Or.inr (Set.mem_image_of_mem _ (Set.mem_of_mem_of_subset hr Set.Ioi_subset_Ici_self))),
        hne.symm, _⟩
    rw [line_map_apply, ← @vsub_ne_zero V, vsub_vadd_eq_vsub_sub]
    nth_rw 1 [← one_smul R (y -ᵥ x)]
    rw [← sub_smul, smul_ne_zero_iff, vsub_ne_zero, sub_ne_zero]
    exact ⟨hr.ne, hne.symm⟩
#align sbtw_iff_left_ne_and_right_mem_image_IoI sbtw_iff_left_ne_and_right_mem_image_Ioi

/- warning: sbtw.right_mem_image_Ioi -> Sbtw.right_mem_image_Ioi is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : LinearOrderedField.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Sbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z) -> (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) z (Set.image.{u1, u3} R P (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} R R R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} R R R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))))) _inst_2 _inst_3 _inst_4) => R -> P) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} R R R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) _inst_2 _inst_3 _inst_4 x y)) (Set.Ioi.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))))))))))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : LinearOrderedField.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Sbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z) -> (Membership.mem.{u1, u1} P (Set.{u1} P) (Set.instMembershipSet.{u1} P) z (Set.image.{u3, u1} R P (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u3, u3, u3, u2, u1} R R R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) (Ring.toAddCommGroup.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))))) (addGroupIsAddTorsor.{u3} R (AddGroupWithOne.toAddGroup.{u3} R (Ring.toAddGroupWithOne.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)))))) _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : R) => P) _x) (AffineMap.funLike.{u3, u3, u3, u2, u1} R R R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) (Ring.toAddCommGroup.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))))) (addGroupIsAddTorsor.{u3} R (AddGroupWithOne.toAddGroup.{u3} R (Ring.toAddGroupWithOne.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)))))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u3, u2, u1} R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) _inst_2 _inst_3 _inst_4 x y)) (Set.Ioi.{u3} R (PartialOrder.toPreorder.{u3} R (StrictOrderedRing.toPartialOrder.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R (LinearOrderedCommRing.toLinearOrderedRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1))))) (OfNat.ofNat.{u3} R 1 (One.toOfNat1.{u3} R (Semiring.toOne.{u3} R (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))))))))
Case conversion may be inaccurate. Consider using '#align sbtw.right_mem_image_Ioi Sbtw.right_mem_image_Ioiₓ'. -/
theorem Sbtw.right_mem_image_Ioi {x y z : P} (h : Sbtw R x y z) :
    z ∈ lineMap x y '' Set.Ioi (1 : R) :=
  (sbtw_iff_left_ne_and_right_mem_image_Ioi.1 h).2
#align sbtw.right_mem_image_Ioi Sbtw.right_mem_image_Ioi

/- warning: sbtw.right_mem_affine_span -> Sbtw.right_mem_affineSpan is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : LinearOrderedField.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Sbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) _inst_2 _inst_3 _inst_4)) z (affineSpan.{u1, u2, u3} R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) x (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) y))))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : LinearOrderedField.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Sbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z) -> (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) _inst_2 _inst_3 _inst_4)) z (affineSpan.{u3, u2, u1} R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) x (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) y))))
Case conversion may be inaccurate. Consider using '#align sbtw.right_mem_affine_span Sbtw.right_mem_affineSpanₓ'. -/
theorem Sbtw.right_mem_affineSpan {x y z : P} (h : Sbtw R x y z) : z ∈ line[R, x, y] :=
  h.Wbtw.right_mem_affineSpan_of_left_ne h.left_ne
#align sbtw.right_mem_affine_span Sbtw.right_mem_affineSpan

/- warning: wbtw_iff_right_eq_or_left_mem_image_Ici -> wbtw_iff_right_eq_or_left_mem_image_Ici is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : LinearOrderedField.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, Iff (Wbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z) (Or (Eq.{succ u3} P z y) (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) x (Set.image.{u1, u3} R P (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} R R R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} R R R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))))) _inst_2 _inst_3 _inst_4) => R -> P) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} R R R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) _inst_2 _inst_3 _inst_4 z y)) (Set.Ici.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))))))))))))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : LinearOrderedField.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, Iff (Wbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z) (Or (Eq.{succ u1} P z y) (Membership.mem.{u1, u1} P (Set.{u1} P) (Set.instMembershipSet.{u1} P) x (Set.image.{u3, u1} R P (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u3, u3, u3, u2, u1} R R R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) (Ring.toAddCommGroup.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))))) (addGroupIsAddTorsor.{u3} R (AddGroupWithOne.toAddGroup.{u3} R (Ring.toAddGroupWithOne.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)))))) _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : R) => P) _x) (AffineMap.funLike.{u3, u3, u3, u2, u1} R R R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) (Ring.toAddCommGroup.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))))) (addGroupIsAddTorsor.{u3} R (AddGroupWithOne.toAddGroup.{u3} R (Ring.toAddGroupWithOne.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)))))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u3, u2, u1} R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) _inst_2 _inst_3 _inst_4 z y)) (Set.Ici.{u3} R (PartialOrder.toPreorder.{u3} R (StrictOrderedRing.toPartialOrder.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R (LinearOrderedCommRing.toLinearOrderedRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1))))) (OfNat.ofNat.{u3} R 1 (One.toOfNat1.{u3} R (Semiring.toOne.{u3} R (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))))))))))
Case conversion may be inaccurate. Consider using '#align wbtw_iff_right_eq_or_left_mem_image_Ici wbtw_iff_right_eq_or_left_mem_image_Iciₓ'. -/
theorem wbtw_iff_right_eq_or_left_mem_image_Ici {x y z : P} :
    Wbtw R x y z ↔ z = y ∨ x ∈ lineMap z y '' Set.Ici (1 : R) := by
  rw [wbtw_comm, wbtw_iff_left_eq_or_right_mem_image_Ici]
#align wbtw_iff_right_eq_or_left_mem_image_Ici wbtw_iff_right_eq_or_left_mem_image_Ici

/- warning: wbtw.left_mem_image_Ici_of_right_ne -> Wbtw.left_mem_image_Ici_of_right_ne is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : LinearOrderedField.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Wbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z) -> (Ne.{succ u3} P z y) -> (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) x (Set.image.{u1, u3} R P (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} R R R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} R R R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))))) _inst_2 _inst_3 _inst_4) => R -> P) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} R R R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) _inst_2 _inst_3 _inst_4 z y)) (Set.Ici.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))))))))))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : LinearOrderedField.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Wbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z) -> (Ne.{succ u1} P z y) -> (Membership.mem.{u1, u1} P (Set.{u1} P) (Set.instMembershipSet.{u1} P) x (Set.image.{u3, u1} R P (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u3, u3, u3, u2, u1} R R R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) (Ring.toAddCommGroup.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))))) (addGroupIsAddTorsor.{u3} R (AddGroupWithOne.toAddGroup.{u3} R (Ring.toAddGroupWithOne.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)))))) _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : R) => P) _x) (AffineMap.funLike.{u3, u3, u3, u2, u1} R R R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) (Ring.toAddCommGroup.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))))) (addGroupIsAddTorsor.{u3} R (AddGroupWithOne.toAddGroup.{u3} R (Ring.toAddGroupWithOne.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)))))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u3, u2, u1} R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) _inst_2 _inst_3 _inst_4 z y)) (Set.Ici.{u3} R (PartialOrder.toPreorder.{u3} R (StrictOrderedRing.toPartialOrder.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R (LinearOrderedCommRing.toLinearOrderedRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1))))) (OfNat.ofNat.{u3} R 1 (One.toOfNat1.{u3} R (Semiring.toOne.{u3} R (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))))))))
Case conversion may be inaccurate. Consider using '#align wbtw.left_mem_image_Ici_of_right_ne Wbtw.left_mem_image_Ici_of_right_neₓ'. -/
theorem Wbtw.left_mem_image_Ici_of_right_ne {x y z : P} (h : Wbtw R x y z) (hne : z ≠ y) :
    x ∈ lineMap z y '' Set.Ici (1 : R) :=
  h.symm.right_mem_image_Ici_of_left_ne hne
#align wbtw.left_mem_image_Ici_of_right_ne Wbtw.left_mem_image_Ici_of_right_ne

/- warning: wbtw.left_mem_affine_span_of_right_ne -> Wbtw.left_mem_affineSpan_of_right_ne is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : LinearOrderedField.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Wbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z) -> (Ne.{succ u3} P z y) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) _inst_2 _inst_3 _inst_4)) x (affineSpan.{u1, u2, u3} R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) z (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) y))))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : LinearOrderedField.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Wbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z) -> (Ne.{succ u1} P z y) -> (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) _inst_2 _inst_3 _inst_4)) x (affineSpan.{u3, u2, u1} R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) z (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) y))))
Case conversion may be inaccurate. Consider using '#align wbtw.left_mem_affine_span_of_right_ne Wbtw.left_mem_affineSpan_of_right_neₓ'. -/
theorem Wbtw.left_mem_affineSpan_of_right_ne {x y z : P} (h : Wbtw R x y z) (hne : z ≠ y) :
    x ∈ line[R, z, y] :=
  h.symm.right_mem_affineSpan_of_left_ne hne
#align wbtw.left_mem_affine_span_of_right_ne Wbtw.left_mem_affineSpan_of_right_ne

/- warning: sbtw_iff_right_ne_and_left_mem_image_IoI -> sbtw_iff_right_ne_and_left_mem_image_Ioi is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : LinearOrderedField.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, Iff (Sbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z) (And (Ne.{succ u3} P z y) (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) x (Set.image.{u1, u3} R P (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} R R R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} R R R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))))) _inst_2 _inst_3 _inst_4) => R -> P) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} R R R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) _inst_2 _inst_3 _inst_4 z y)) (Set.Ioi.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))))))))))))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : LinearOrderedField.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, Iff (Sbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z) (And (Ne.{succ u1} P z y) (Membership.mem.{u1, u1} P (Set.{u1} P) (Set.instMembershipSet.{u1} P) x (Set.image.{u3, u1} R P (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u3, u3, u3, u2, u1} R R R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) (Ring.toAddCommGroup.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))))) (addGroupIsAddTorsor.{u3} R (AddGroupWithOne.toAddGroup.{u3} R (Ring.toAddGroupWithOne.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)))))) _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : R) => P) _x) (AffineMap.funLike.{u3, u3, u3, u2, u1} R R R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) (Ring.toAddCommGroup.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))))) (addGroupIsAddTorsor.{u3} R (AddGroupWithOne.toAddGroup.{u3} R (Ring.toAddGroupWithOne.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)))))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u3, u2, u1} R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) _inst_2 _inst_3 _inst_4 z y)) (Set.Ioi.{u3} R (PartialOrder.toPreorder.{u3} R (StrictOrderedRing.toPartialOrder.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R (LinearOrderedCommRing.toLinearOrderedRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1))))) (OfNat.ofNat.{u3} R 1 (One.toOfNat1.{u3} R (Semiring.toOne.{u3} R (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))))))))))
Case conversion may be inaccurate. Consider using '#align sbtw_iff_right_ne_and_left_mem_image_IoI sbtw_iff_right_ne_and_left_mem_image_Ioiₓ'. -/
theorem sbtw_iff_right_ne_and_left_mem_image_Ioi {x y z : P} :
    Sbtw R x y z ↔ z ≠ y ∧ x ∈ lineMap z y '' Set.Ioi (1 : R) := by
  rw [sbtw_comm, sbtw_iff_left_ne_and_right_mem_image_Ioi]
#align sbtw_iff_right_ne_and_left_mem_image_IoI sbtw_iff_right_ne_and_left_mem_image_Ioi

/- warning: sbtw.left_mem_image_Ioi -> Sbtw.left_mem_image_Ioi is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : LinearOrderedField.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Sbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z) -> (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) x (Set.image.{u1, u3} R P (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} R R R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} R R R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))))) _inst_2 _inst_3 _inst_4) => R -> P) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} R R R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (addGroupIsAddTorsor.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) _inst_2 _inst_3 _inst_4 z y)) (Set.Ioi.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))))))))))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : LinearOrderedField.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Sbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z) -> (Membership.mem.{u1, u1} P (Set.{u1} P) (Set.instMembershipSet.{u1} P) x (Set.image.{u3, u1} R P (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u3, u3, u3, u2, u1} R R R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) (Ring.toAddCommGroup.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))))) (addGroupIsAddTorsor.{u3} R (AddGroupWithOne.toAddGroup.{u3} R (Ring.toAddGroupWithOne.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)))))) _inst_2 _inst_3 _inst_4) R (fun (_x : R) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : R) => P) _x) (AffineMap.funLike.{u3, u3, u3, u2, u1} R R R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) (Ring.toAddCommGroup.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))))) (addGroupIsAddTorsor.{u3} R (AddGroupWithOne.toAddGroup.{u3} R (Ring.toAddGroupWithOne.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)))))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u3, u2, u1} R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) _inst_2 _inst_3 _inst_4 z y)) (Set.Ioi.{u3} R (PartialOrder.toPreorder.{u3} R (StrictOrderedRing.toPartialOrder.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R (LinearOrderedCommRing.toLinearOrderedRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1))))) (OfNat.ofNat.{u3} R 1 (One.toOfNat1.{u3} R (Semiring.toOne.{u3} R (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))))))))
Case conversion may be inaccurate. Consider using '#align sbtw.left_mem_image_Ioi Sbtw.left_mem_image_Ioiₓ'. -/
theorem Sbtw.left_mem_image_Ioi {x y z : P} (h : Sbtw R x y z) :
    x ∈ lineMap z y '' Set.Ioi (1 : R) :=
  h.symm.right_mem_image_Ioi
#align sbtw.left_mem_image_Ioi Sbtw.left_mem_image_Ioi

/- warning: sbtw.left_mem_affine_span -> Sbtw.left_mem_affineSpan is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : LinearOrderedField.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Sbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) _inst_2 _inst_3 _inst_4)) x (affineSpan.{u1, u2, u3} R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) z (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) y))))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : LinearOrderedField.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Sbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z) -> (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) _inst_2 _inst_3 _inst_4)) x (affineSpan.{u3, u2, u1} R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) z (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) y))))
Case conversion may be inaccurate. Consider using '#align sbtw.left_mem_affine_span Sbtw.left_mem_affineSpanₓ'. -/
theorem Sbtw.left_mem_affineSpan {x y z : P} (h : Sbtw R x y z) : x ∈ line[R, z, y] :=
  h.symm.right_mem_affineSpan
#align sbtw.left_mem_affine_span Sbtw.left_mem_affineSpan

/- warning: wbtw_smul_vadd_smul_vadd_of_nonneg_of_le -> wbtw_smul_vadd_smul_vadd_of_nonneg_of_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : LinearOrderedField.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (x : P) (v : V) {r₁ : R} {r₂ : R}, (LE.le.{u1} R (Preorder.toHasLe.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1))))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))))))))) r₁) -> (LE.le.{u1} R (Preorder.toHasLe.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1))))))) r₁ r₂) -> (Wbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 x (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) (SMul.smul.{u1, u2} R V (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) r₁ v) x) (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) (SMul.smul.{u1, u2} R V (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) r₂ v) x))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : LinearOrderedField.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (x : P) (v : V) {r₁ : R} {r₂ : R}, (LE.le.{u3} R (Preorder.toLE.{u3} R (PartialOrder.toPreorder.{u3} R (StrictOrderedRing.toPartialOrder.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R (LinearOrderedCommRing.toLinearOrderedRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))))) (OfNat.ofNat.{u3} R 0 (Zero.toOfNat0.{u3} R (CommMonoidWithZero.toZero.{u3} R (CommGroupWithZero.toCommMonoidWithZero.{u3} R (Semifield.toCommGroupWithZero.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))))) r₁) -> (LE.le.{u3} R (Preorder.toLE.{u3} R (PartialOrder.toPreorder.{u3} R (StrictOrderedRing.toPartialOrder.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R (LinearOrderedCommRing.toLinearOrderedRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))))) r₁ r₂) -> (Wbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 x (HVAdd.hVAdd.{u2, u1, u1} V P P (instHVAdd.{u2, u1} V P (AddAction.toVAdd.{u2, u1} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4))) (HSMul.hSMul.{u3, u2, u2} R V V (instHSMul.{u3, u2} R V (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (CommMonoidWithZero.toZero.{u3} R (CommGroupWithZero.toCommMonoidWithZero.{u3} R (Semifield.toCommGroupWithZero.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) r₁ v) x) (HVAdd.hVAdd.{u2, u1, u1} V P P (instHVAdd.{u2, u1} V P (AddAction.toVAdd.{u2, u1} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4))) (HSMul.hSMul.{u3, u2, u2} R V V (instHSMul.{u3, u2} R V (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (CommMonoidWithZero.toZero.{u3} R (CommGroupWithZero.toCommMonoidWithZero.{u3} R (Semifield.toCommGroupWithZero.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) r₂ v) x))
Case conversion may be inaccurate. Consider using '#align wbtw_smul_vadd_smul_vadd_of_nonneg_of_le wbtw_smul_vadd_smul_vadd_of_nonneg_of_leₓ'. -/
theorem wbtw_smul_vadd_smul_vadd_of_nonneg_of_le (x : P) (v : V) {r₁ r₂ : R} (hr₁ : 0 ≤ r₁)
    (hr₂ : r₁ ≤ r₂) : Wbtw R x (r₁ • v +ᵥ x) (r₂ • v +ᵥ x) :=
  by
  refine' ⟨r₁ / r₂, ⟨div_nonneg hr₁ (hr₁.trans hr₂), div_le_one_of_le hr₂ (hr₁.trans hr₂)⟩, _⟩
  by_cases h : r₁ = 0; · simp [h]
  simp [line_map_apply, smul_smul, ((hr₁.lt_of_ne' h).trans_le hr₂).Ne.symm]
#align wbtw_smul_vadd_smul_vadd_of_nonneg_of_le wbtw_smul_vadd_smul_vadd_of_nonneg_of_le

/- warning: wbtw_or_wbtw_smul_vadd_of_nonneg -> wbtw_or_wbtw_smul_vadd_of_nonneg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : LinearOrderedField.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (x : P) (v : V) {r₁ : R} {r₂ : R}, (LE.le.{u1} R (Preorder.toHasLe.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1))))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))))))))) r₁) -> (LE.le.{u1} R (Preorder.toHasLe.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1))))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))))))))) r₂) -> (Or (Wbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 x (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) (SMul.smul.{u1, u2} R V (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) r₁ v) x) (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) (SMul.smul.{u1, u2} R V (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) r₂ v) x)) (Wbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 x (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) (SMul.smul.{u1, u2} R V (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) r₂ v) x) (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) (SMul.smul.{u1, u2} R V (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) r₁ v) x)))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : LinearOrderedField.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (x : P) (v : V) {r₁ : R} {r₂ : R}, (LE.le.{u3} R (Preorder.toLE.{u3} R (PartialOrder.toPreorder.{u3} R (StrictOrderedRing.toPartialOrder.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R (LinearOrderedCommRing.toLinearOrderedRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))))) (OfNat.ofNat.{u3} R 0 (Zero.toOfNat0.{u3} R (CommMonoidWithZero.toZero.{u3} R (CommGroupWithZero.toCommMonoidWithZero.{u3} R (Semifield.toCommGroupWithZero.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))))) r₁) -> (LE.le.{u3} R (Preorder.toLE.{u3} R (PartialOrder.toPreorder.{u3} R (StrictOrderedRing.toPartialOrder.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R (LinearOrderedCommRing.toLinearOrderedRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))))) (OfNat.ofNat.{u3} R 0 (Zero.toOfNat0.{u3} R (CommMonoidWithZero.toZero.{u3} R (CommGroupWithZero.toCommMonoidWithZero.{u3} R (Semifield.toCommGroupWithZero.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))))) r₂) -> (Or (Wbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 x (HVAdd.hVAdd.{u2, u1, u1} V P P (instHVAdd.{u2, u1} V P (AddAction.toVAdd.{u2, u1} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4))) (HSMul.hSMul.{u3, u2, u2} R V V (instHSMul.{u3, u2} R V (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (CommMonoidWithZero.toZero.{u3} R (CommGroupWithZero.toCommMonoidWithZero.{u3} R (Semifield.toCommGroupWithZero.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) r₁ v) x) (HVAdd.hVAdd.{u2, u1, u1} V P P (instHVAdd.{u2, u1} V P (AddAction.toVAdd.{u2, u1} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4))) (HSMul.hSMul.{u3, u2, u2} R V V (instHSMul.{u3, u2} R V (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (CommMonoidWithZero.toZero.{u3} R (CommGroupWithZero.toCommMonoidWithZero.{u3} R (Semifield.toCommGroupWithZero.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) r₂ v) x)) (Wbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 x (HVAdd.hVAdd.{u2, u1, u1} V P P (instHVAdd.{u2, u1} V P (AddAction.toVAdd.{u2, u1} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4))) (HSMul.hSMul.{u3, u2, u2} R V V (instHSMul.{u3, u2} R V (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (CommMonoidWithZero.toZero.{u3} R (CommGroupWithZero.toCommMonoidWithZero.{u3} R (Semifield.toCommGroupWithZero.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) r₂ v) x) (HVAdd.hVAdd.{u2, u1, u1} V P P (instHVAdd.{u2, u1} V P (AddAction.toVAdd.{u2, u1} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4))) (HSMul.hSMul.{u3, u2, u2} R V V (instHSMul.{u3, u2} R V (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (CommMonoidWithZero.toZero.{u3} R (CommGroupWithZero.toCommMonoidWithZero.{u3} R (Semifield.toCommGroupWithZero.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) r₁ v) x)))
Case conversion may be inaccurate. Consider using '#align wbtw_or_wbtw_smul_vadd_of_nonneg wbtw_or_wbtw_smul_vadd_of_nonnegₓ'. -/
theorem wbtw_or_wbtw_smul_vadd_of_nonneg (x : P) (v : V) {r₁ r₂ : R} (hr₁ : 0 ≤ r₁) (hr₂ : 0 ≤ r₂) :
    Wbtw R x (r₁ • v +ᵥ x) (r₂ • v +ᵥ x) ∨ Wbtw R x (r₂ • v +ᵥ x) (r₁ • v +ᵥ x) :=
  by
  rcases le_total r₁ r₂ with (h | h)
  · exact Or.inl (wbtw_smul_vadd_smul_vadd_of_nonneg_of_le x v hr₁ h)
  · exact Or.inr (wbtw_smul_vadd_smul_vadd_of_nonneg_of_le x v hr₂ h)
#align wbtw_or_wbtw_smul_vadd_of_nonneg wbtw_or_wbtw_smul_vadd_of_nonneg

/- warning: wbtw_smul_vadd_smul_vadd_of_nonpos_of_le -> wbtw_smul_vadd_smul_vadd_of_nonpos_of_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : LinearOrderedField.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (x : P) (v : V) {r₁ : R} {r₂ : R}, (LE.le.{u1} R (Preorder.toHasLe.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1))))))) r₁ (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))))))))) -> (LE.le.{u1} R (Preorder.toHasLe.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1))))))) r₂ r₁) -> (Wbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 x (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) (SMul.smul.{u1, u2} R V (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) r₁ v) x) (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) (SMul.smul.{u1, u2} R V (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) r₂ v) x))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : LinearOrderedField.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (x : P) (v : V) {r₁ : R} {r₂ : R}, (LE.le.{u3} R (Preorder.toLE.{u3} R (PartialOrder.toPreorder.{u3} R (StrictOrderedRing.toPartialOrder.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R (LinearOrderedCommRing.toLinearOrderedRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))))) r₁ (OfNat.ofNat.{u3} R 0 (Zero.toOfNat0.{u3} R (CommMonoidWithZero.toZero.{u3} R (CommGroupWithZero.toCommMonoidWithZero.{u3} R (Semifield.toCommGroupWithZero.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))))))) -> (LE.le.{u3} R (Preorder.toLE.{u3} R (PartialOrder.toPreorder.{u3} R (StrictOrderedRing.toPartialOrder.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R (LinearOrderedCommRing.toLinearOrderedRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))))) r₂ r₁) -> (Wbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 x (HVAdd.hVAdd.{u2, u1, u1} V P P (instHVAdd.{u2, u1} V P (AddAction.toVAdd.{u2, u1} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4))) (HSMul.hSMul.{u3, u2, u2} R V V (instHSMul.{u3, u2} R V (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (CommMonoidWithZero.toZero.{u3} R (CommGroupWithZero.toCommMonoidWithZero.{u3} R (Semifield.toCommGroupWithZero.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) r₁ v) x) (HVAdd.hVAdd.{u2, u1, u1} V P P (instHVAdd.{u2, u1} V P (AddAction.toVAdd.{u2, u1} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4))) (HSMul.hSMul.{u3, u2, u2} R V V (instHSMul.{u3, u2} R V (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (CommMonoidWithZero.toZero.{u3} R (CommGroupWithZero.toCommMonoidWithZero.{u3} R (Semifield.toCommGroupWithZero.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) r₂ v) x))
Case conversion may be inaccurate. Consider using '#align wbtw_smul_vadd_smul_vadd_of_nonpos_of_le wbtw_smul_vadd_smul_vadd_of_nonpos_of_leₓ'. -/
theorem wbtw_smul_vadd_smul_vadd_of_nonpos_of_le (x : P) (v : V) {r₁ r₂ : R} (hr₁ : r₁ ≤ 0)
    (hr₂ : r₂ ≤ r₁) : Wbtw R x (r₁ • v +ᵥ x) (r₂ • v +ᵥ x) := by
  convert wbtw_smul_vadd_smul_vadd_of_nonneg_of_le x (-v) (Left.nonneg_neg_iff.2 hr₁)
        (neg_le_neg_iff.2 hr₂) using
      1 <;>
    rw [neg_smul_neg]
#align wbtw_smul_vadd_smul_vadd_of_nonpos_of_le wbtw_smul_vadd_smul_vadd_of_nonpos_of_le

/- warning: wbtw_or_wbtw_smul_vadd_of_nonpos -> wbtw_or_wbtw_smul_vadd_of_nonpos is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : LinearOrderedField.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (x : P) (v : V) {r₁ : R} {r₂ : R}, (LE.le.{u1} R (Preorder.toHasLe.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1))))))) r₁ (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))))))))) -> (LE.le.{u1} R (Preorder.toHasLe.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1))))))) r₂ (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))))))))) -> (Or (Wbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 x (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) (SMul.smul.{u1, u2} R V (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) r₁ v) x) (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) (SMul.smul.{u1, u2} R V (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) r₂ v) x)) (Wbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 x (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) (SMul.smul.{u1, u2} R V (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) r₂ v) x) (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) (SMul.smul.{u1, u2} R V (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) r₁ v) x)))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : LinearOrderedField.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (x : P) (v : V) {r₁ : R} {r₂ : R}, (LE.le.{u3} R (Preorder.toLE.{u3} R (PartialOrder.toPreorder.{u3} R (StrictOrderedRing.toPartialOrder.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R (LinearOrderedCommRing.toLinearOrderedRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))))) r₁ (OfNat.ofNat.{u3} R 0 (Zero.toOfNat0.{u3} R (CommMonoidWithZero.toZero.{u3} R (CommGroupWithZero.toCommMonoidWithZero.{u3} R (Semifield.toCommGroupWithZero.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))))))) -> (LE.le.{u3} R (Preorder.toLE.{u3} R (PartialOrder.toPreorder.{u3} R (StrictOrderedRing.toPartialOrder.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R (LinearOrderedCommRing.toLinearOrderedRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))))) r₂ (OfNat.ofNat.{u3} R 0 (Zero.toOfNat0.{u3} R (CommMonoidWithZero.toZero.{u3} R (CommGroupWithZero.toCommMonoidWithZero.{u3} R (Semifield.toCommGroupWithZero.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))))))) -> (Or (Wbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 x (HVAdd.hVAdd.{u2, u1, u1} V P P (instHVAdd.{u2, u1} V P (AddAction.toVAdd.{u2, u1} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4))) (HSMul.hSMul.{u3, u2, u2} R V V (instHSMul.{u3, u2} R V (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (CommMonoidWithZero.toZero.{u3} R (CommGroupWithZero.toCommMonoidWithZero.{u3} R (Semifield.toCommGroupWithZero.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) r₁ v) x) (HVAdd.hVAdd.{u2, u1, u1} V P P (instHVAdd.{u2, u1} V P (AddAction.toVAdd.{u2, u1} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4))) (HSMul.hSMul.{u3, u2, u2} R V V (instHSMul.{u3, u2} R V (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (CommMonoidWithZero.toZero.{u3} R (CommGroupWithZero.toCommMonoidWithZero.{u3} R (Semifield.toCommGroupWithZero.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) r₂ v) x)) (Wbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 x (HVAdd.hVAdd.{u2, u1, u1} V P P (instHVAdd.{u2, u1} V P (AddAction.toVAdd.{u2, u1} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4))) (HSMul.hSMul.{u3, u2, u2} R V V (instHSMul.{u3, u2} R V (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (CommMonoidWithZero.toZero.{u3} R (CommGroupWithZero.toCommMonoidWithZero.{u3} R (Semifield.toCommGroupWithZero.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) r₂ v) x) (HVAdd.hVAdd.{u2, u1, u1} V P P (instHVAdd.{u2, u1} V P (AddAction.toVAdd.{u2, u1} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4))) (HSMul.hSMul.{u3, u2, u2} R V V (instHSMul.{u3, u2} R V (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (CommMonoidWithZero.toZero.{u3} R (CommGroupWithZero.toCommMonoidWithZero.{u3} R (Semifield.toCommGroupWithZero.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) r₁ v) x)))
Case conversion may be inaccurate. Consider using '#align wbtw_or_wbtw_smul_vadd_of_nonpos wbtw_or_wbtw_smul_vadd_of_nonposₓ'. -/
theorem wbtw_or_wbtw_smul_vadd_of_nonpos (x : P) (v : V) {r₁ r₂ : R} (hr₁ : r₁ ≤ 0) (hr₂ : r₂ ≤ 0) :
    Wbtw R x (r₁ • v +ᵥ x) (r₂ • v +ᵥ x) ∨ Wbtw R x (r₂ • v +ᵥ x) (r₁ • v +ᵥ x) :=
  by
  rcases le_total r₁ r₂ with (h | h)
  · exact Or.inr (wbtw_smul_vadd_smul_vadd_of_nonpos_of_le x v hr₂ h)
  · exact Or.inl (wbtw_smul_vadd_smul_vadd_of_nonpos_of_le x v hr₁ h)
#align wbtw_or_wbtw_smul_vadd_of_nonpos wbtw_or_wbtw_smul_vadd_of_nonpos

/- warning: wbtw_smul_vadd_smul_vadd_of_nonpos_of_nonneg -> wbtw_smul_vadd_smul_vadd_of_nonpos_of_nonneg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : LinearOrderedField.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (x : P) (v : V) {r₁ : R} {r₂ : R}, (LE.le.{u1} R (Preorder.toHasLe.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1))))))) r₁ (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))))))))) -> (LE.le.{u1} R (Preorder.toHasLe.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1))))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))))))))) r₂) -> (Wbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) (SMul.smul.{u1, u2} R V (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) r₁ v) x) x (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) (SMul.smul.{u1, u2} R V (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) r₂ v) x))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : LinearOrderedField.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (x : P) (v : V) {r₁ : R} {r₂ : R}, (LE.le.{u3} R (Preorder.toLE.{u3} R (PartialOrder.toPreorder.{u3} R (StrictOrderedRing.toPartialOrder.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R (LinearOrderedCommRing.toLinearOrderedRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))))) r₁ (OfNat.ofNat.{u3} R 0 (Zero.toOfNat0.{u3} R (CommMonoidWithZero.toZero.{u3} R (CommGroupWithZero.toCommMonoidWithZero.{u3} R (Semifield.toCommGroupWithZero.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))))))) -> (LE.le.{u3} R (Preorder.toLE.{u3} R (PartialOrder.toPreorder.{u3} R (StrictOrderedRing.toPartialOrder.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R (LinearOrderedCommRing.toLinearOrderedRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))))) (OfNat.ofNat.{u3} R 0 (Zero.toOfNat0.{u3} R (CommMonoidWithZero.toZero.{u3} R (CommGroupWithZero.toCommMonoidWithZero.{u3} R (Semifield.toCommGroupWithZero.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))))) r₂) -> (Wbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 (HVAdd.hVAdd.{u2, u1, u1} V P P (instHVAdd.{u2, u1} V P (AddAction.toVAdd.{u2, u1} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4))) (HSMul.hSMul.{u3, u2, u2} R V V (instHSMul.{u3, u2} R V (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (CommMonoidWithZero.toZero.{u3} R (CommGroupWithZero.toCommMonoidWithZero.{u3} R (Semifield.toCommGroupWithZero.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) r₁ v) x) x (HVAdd.hVAdd.{u2, u1, u1} V P P (instHVAdd.{u2, u1} V P (AddAction.toVAdd.{u2, u1} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4))) (HSMul.hSMul.{u3, u2, u2} R V V (instHSMul.{u3, u2} R V (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (CommMonoidWithZero.toZero.{u3} R (CommGroupWithZero.toCommMonoidWithZero.{u3} R (Semifield.toCommGroupWithZero.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) r₂ v) x))
Case conversion may be inaccurate. Consider using '#align wbtw_smul_vadd_smul_vadd_of_nonpos_of_nonneg wbtw_smul_vadd_smul_vadd_of_nonpos_of_nonnegₓ'. -/
theorem wbtw_smul_vadd_smul_vadd_of_nonpos_of_nonneg (x : P) (v : V) {r₁ r₂ : R} (hr₁ : r₁ ≤ 0)
    (hr₂ : 0 ≤ r₂) : Wbtw R (r₁ • v +ᵥ x) x (r₂ • v +ᵥ x) := by
  convert wbtw_smul_vadd_smul_vadd_of_nonneg_of_le (r₁ • v +ᵥ x) v (Left.nonneg_neg_iff.2 hr₁)
        (neg_le_sub_iff_le_add.2 ((le_add_iff_nonneg_left r₁).2 hr₂)) using
      1 <;>
    simp [sub_smul, ← add_vadd]
#align wbtw_smul_vadd_smul_vadd_of_nonpos_of_nonneg wbtw_smul_vadd_smul_vadd_of_nonpos_of_nonneg

/- warning: wbtw_smul_vadd_smul_vadd_of_nonneg_of_nonpos -> wbtw_smul_vadd_smul_vadd_of_nonneg_of_nonpos is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : LinearOrderedField.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (x : P) (v : V) {r₁ : R} {r₂ : R}, (LE.le.{u1} R (Preorder.toHasLe.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1))))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))))))))) r₁) -> (LE.le.{u1} R (Preorder.toHasLe.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1))))))) r₂ (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))))))))) -> (Wbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) (SMul.smul.{u1, u2} R V (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) r₁ v) x) x (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) (SMul.smul.{u1, u2} R V (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) r₂ v) x))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : LinearOrderedField.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (x : P) (v : V) {r₁ : R} {r₂ : R}, (LE.le.{u3} R (Preorder.toLE.{u3} R (PartialOrder.toPreorder.{u3} R (StrictOrderedRing.toPartialOrder.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R (LinearOrderedCommRing.toLinearOrderedRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))))) (OfNat.ofNat.{u3} R 0 (Zero.toOfNat0.{u3} R (CommMonoidWithZero.toZero.{u3} R (CommGroupWithZero.toCommMonoidWithZero.{u3} R (Semifield.toCommGroupWithZero.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))))) r₁) -> (LE.le.{u3} R (Preorder.toLE.{u3} R (PartialOrder.toPreorder.{u3} R (StrictOrderedRing.toPartialOrder.{u3} R (LinearOrderedRing.toStrictOrderedRing.{u3} R (LinearOrderedCommRing.toLinearOrderedRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))))) r₂ (OfNat.ofNat.{u3} R 0 (Zero.toOfNat0.{u3} R (CommMonoidWithZero.toZero.{u3} R (CommGroupWithZero.toCommMonoidWithZero.{u3} R (Semifield.toCommGroupWithZero.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))))))) -> (Wbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 (HVAdd.hVAdd.{u2, u1, u1} V P P (instHVAdd.{u2, u1} V P (AddAction.toVAdd.{u2, u1} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4))) (HSMul.hSMul.{u3, u2, u2} R V V (instHSMul.{u3, u2} R V (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (CommMonoidWithZero.toZero.{u3} R (CommGroupWithZero.toCommMonoidWithZero.{u3} R (Semifield.toCommGroupWithZero.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) r₁ v) x) x (HVAdd.hVAdd.{u2, u1, u1} V P P (instHVAdd.{u2, u1} V P (AddAction.toVAdd.{u2, u1} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4))) (HSMul.hSMul.{u3, u2, u2} R V V (instHSMul.{u3, u2} R V (SMulZeroClass.toSMul.{u3, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R V (CommMonoidWithZero.toZero.{u3} R (CommGroupWithZero.toCommMonoidWithZero.{u3} R (Semifield.toCommGroupWithZero.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R V (Semiring.toMonoidWithZero.{u3} R (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) r₂ v) x))
Case conversion may be inaccurate. Consider using '#align wbtw_smul_vadd_smul_vadd_of_nonneg_of_nonpos wbtw_smul_vadd_smul_vadd_of_nonneg_of_nonposₓ'. -/
theorem wbtw_smul_vadd_smul_vadd_of_nonneg_of_nonpos (x : P) (v : V) {r₁ r₂ : R} (hr₁ : 0 ≤ r₁)
    (hr₂ : r₂ ≤ 0) : Wbtw R (r₁ • v +ᵥ x) x (r₂ • v +ᵥ x) :=
  by
  rw [wbtw_comm]
  exact wbtw_smul_vadd_smul_vadd_of_nonpos_of_nonneg x v hr₂ hr₁
#align wbtw_smul_vadd_smul_vadd_of_nonneg_of_nonpos wbtw_smul_vadd_smul_vadd_of_nonneg_of_nonpos

/- warning: wbtw.trans_left_right -> Wbtw.trans_left_right is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : LinearOrderedField.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {w : P} {x : P} {y : P} {z : P}, (Wbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 w y z) -> (Wbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 w x y) -> (Wbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z)
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : LinearOrderedField.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {w : P} {x : P} {y : P} {z : P}, (Wbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 w y z) -> (Wbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 w x y) -> (Wbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z)
Case conversion may be inaccurate. Consider using '#align wbtw.trans_left_right Wbtw.trans_left_rightₓ'. -/
theorem Wbtw.trans_left_right {w x y z : P} (h₁ : Wbtw R w y z) (h₂ : Wbtw R w x y) :
    Wbtw R x y z := by
  rcases h₁ with ⟨t₁, ht₁, rfl⟩
  rcases h₂ with ⟨t₂, ht₂, rfl⟩
  refine'
    ⟨(t₁ - t₂ * t₁) / (1 - t₂ * t₁),
      ⟨div_nonneg (sub_nonneg.2 (mul_le_of_le_one_left ht₁.1 ht₂.2))
          (sub_nonneg.2 (mul_le_one ht₂.2 ht₁.1 ht₁.2)),
        div_le_one_of_le (sub_le_sub_right ht₁.2 _) (sub_nonneg.2 (mul_le_one ht₂.2 ht₁.1 ht₁.2))⟩,
      _⟩
  simp only [line_map_apply, smul_smul, ← add_vadd, vsub_vadd_eq_vsub_sub, smul_sub, ← sub_smul, ←
    add_smul, vadd_vsub, vadd_right_cancel_iff, div_mul_eq_mul_div, div_sub_div_same]
  nth_rw 1 [← mul_one (t₁ - t₂ * t₁)]
  rw [← mul_sub, mul_div_assoc]
  by_cases h : 1 - t₂ * t₁ = 0
  · rw [sub_eq_zero, eq_comm] at h
    rw [h]
    suffices t₁ = 1 by simp [this]
    exact
      eq_of_le_of_not_lt ht₁.2 fun ht₁lt =>
        (mul_lt_one_of_nonneg_of_lt_one_right ht₂.2 ht₁.1 ht₁lt).Ne h
  · rw [div_self h]
    ring_nf
#align wbtw.trans_left_right Wbtw.trans_left_right

/- warning: wbtw.trans_right_left -> Wbtw.trans_right_left is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : LinearOrderedField.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {w : P} {x : P} {y : P} {z : P}, (Wbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 w x z) -> (Wbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z) -> (Wbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 w x y)
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : LinearOrderedField.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {w : P} {x : P} {y : P} {z : P}, (Wbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 w x z) -> (Wbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z) -> (Wbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 w x y)
Case conversion may be inaccurate. Consider using '#align wbtw.trans_right_left Wbtw.trans_right_leftₓ'. -/
theorem Wbtw.trans_right_left {w x y z : P} (h₁ : Wbtw R w x z) (h₂ : Wbtw R x y z) :
    Wbtw R w x y := by
  rw [wbtw_comm] at *
  exact h₁.trans_left_right h₂
#align wbtw.trans_right_left Wbtw.trans_right_left

/- warning: sbtw.trans_left_right -> Sbtw.trans_left_right is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : LinearOrderedField.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {w : P} {x : P} {y : P} {z : P}, (Sbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 w y z) -> (Sbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 w x y) -> (Sbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z)
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : LinearOrderedField.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {w : P} {x : P} {y : P} {z : P}, (Sbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 w y z) -> (Sbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 w x y) -> (Sbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z)
Case conversion may be inaccurate. Consider using '#align sbtw.trans_left_right Sbtw.trans_left_rightₓ'. -/
theorem Sbtw.trans_left_right {w x y z : P} (h₁ : Sbtw R w y z) (h₂ : Sbtw R w x y) :
    Sbtw R x y z :=
  ⟨h₁.Wbtw.trans_left_right h₂.Wbtw, h₂.right_ne, h₁.ne_right⟩
#align sbtw.trans_left_right Sbtw.trans_left_right

/- warning: sbtw.trans_right_left -> Sbtw.trans_right_left is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : LinearOrderedField.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {w : P} {x : P} {y : P} {z : P}, (Sbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 w x z) -> (Sbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z) -> (Sbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 w x y)
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : LinearOrderedField.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {w : P} {x : P} {y : P} {z : P}, (Sbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 w x z) -> (Sbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z) -> (Sbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 w x y)
Case conversion may be inaccurate. Consider using '#align sbtw.trans_right_left Sbtw.trans_right_leftₓ'. -/
theorem Sbtw.trans_right_left {w x y z : P} (h₁ : Sbtw R w x z) (h₂ : Sbtw R x y z) :
    Sbtw R w x y :=
  ⟨h₁.Wbtw.trans_right_left h₂.Wbtw, h₁.ne_left, h₂.left_ne⟩
#align sbtw.trans_right_left Sbtw.trans_right_left

/- warning: wbtw.collinear -> Wbtw.collinear is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : LinearOrderedField.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Wbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z) -> (Collinear.{u1, u2, u3} R V P (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) x (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) y (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) z))))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : LinearOrderedField.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Wbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z) -> (Collinear.{u3, u2, u1} R V P (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)) _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) x (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) y (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) z))))
Case conversion may be inaccurate. Consider using '#align wbtw.collinear Wbtw.collinearₓ'. -/
theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) :=
  by
  rw [collinear_iff_exists_forall_eq_smul_vadd]
  refine' ⟨x, z -ᵥ x, _⟩
  intro p hp
  simp_rw [Set.mem_insert_iff, Set.mem_singleton_iff] at hp
  rcases hp with (rfl | rfl | rfl)
  · refine' ⟨0, _⟩
    simp
  · rcases h with ⟨t, -, rfl⟩
    exact ⟨t, rfl⟩
  · refine' ⟨1, _⟩
    simp
#align wbtw.collinear Wbtw.collinear

/- warning: collinear.wbtw_or_wbtw_or_wbtw -> Collinear.wbtw_or_wbtw_or_wbtw is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : LinearOrderedField.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Collinear.{u1, u2, u3} R V P (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) x (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) y (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) z)))) -> (Or (Wbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z) (Or (Wbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 y z x) (Wbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 z x y)))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : LinearOrderedField.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, (Collinear.{u3, u2, u1} R V P (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)) _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) x (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) y (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) z)))) -> (Or (Wbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z) (Or (Wbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 y z x) (Wbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 z x y)))
Case conversion may be inaccurate. Consider using '#align collinear.wbtw_or_wbtw_or_wbtw Collinear.wbtw_or_wbtw_or_wbtwₓ'. -/
theorem Collinear.wbtw_or_wbtw_or_wbtw {x y z : P} (h : Collinear R ({x, y, z} : Set P)) :
    Wbtw R x y z ∨ Wbtw R y z x ∨ Wbtw R z x y :=
  by
  rw [collinear_iff_of_mem (Set.mem_insert _ _)] at h
  rcases h with ⟨v, h⟩
  simp_rw [Set.mem_insert_iff, Set.mem_singleton_iff] at h
  have hy := h y (Or.inr (Or.inl rfl))
  have hz := h z (Or.inr (Or.inr rfl))
  rcases hy with ⟨ty, rfl⟩
  rcases hz with ⟨tz, rfl⟩
  rcases lt_trichotomy ty 0 with (hy0 | rfl | hy0)
  · rcases lt_trichotomy tz 0 with (hz0 | rfl | hz0)
    · nth_rw 2 [wbtw_comm]
      rw [← or_assoc']
      exact Or.inl (wbtw_or_wbtw_smul_vadd_of_nonpos _ _ hy0.le hz0.le)
    · simp
    · exact Or.inr (Or.inr (wbtw_smul_vadd_smul_vadd_of_nonneg_of_nonpos _ _ hz0.le hy0.le))
  · simp
  · rcases lt_trichotomy tz 0 with (hz0 | rfl | hz0)
    · refine' Or.inr (Or.inr (wbtw_smul_vadd_smul_vadd_of_nonpos_of_nonneg _ _ hz0.le hy0.le))
    · simp
    · nth_rw 2 [wbtw_comm]
      rw [← or_assoc']
      exact Or.inl (wbtw_or_wbtw_smul_vadd_of_nonneg _ _ hy0.le hz0.le)
#align collinear.wbtw_or_wbtw_or_wbtw Collinear.wbtw_or_wbtw_or_wbtw

/- warning: wbtw_iff_same_ray_vsub -> wbtw_iff_sameRay_vsub is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : LinearOrderedField.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, Iff (Wbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z) (SameRay.{u1, u2} R (StrictOrderedCommRing.toStrictOrderedCommSemiring.{u1} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1))) V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) y x) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) z y))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : LinearOrderedField.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P} {z : P}, Iff (Wbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 x y z) (SameRay.{u3, u2} R (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u3} R (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1))) V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) y x) (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) z y))
Case conversion may be inaccurate. Consider using '#align wbtw_iff_same_ray_vsub wbtw_iff_sameRay_vsubₓ'. -/
theorem wbtw_iff_sameRay_vsub {x y z : P} : Wbtw R x y z ↔ SameRay R (y -ᵥ x) (z -ᵥ y) :=
  by
  refine' ⟨Wbtw.sameRay_vsub, fun h => _⟩
  rcases h with (h | h | ⟨r₁, r₂, hr₁, hr₂, h⟩)
  · rw [vsub_eq_zero_iff_eq] at h
    simp [h]
  · rw [vsub_eq_zero_iff_eq] at h
    simp [h]
  · refine'
      ⟨r₂ / (r₁ + r₂),
        ⟨div_nonneg hr₂.le (add_nonneg hr₁.le hr₂.le),
          div_le_one_of_le (le_add_of_nonneg_left hr₁.le) (add_nonneg hr₁.le hr₂.le)⟩,
        _⟩
    have h' : z = r₂⁻¹ • r₁ • (y -ᵥ x) +ᵥ y := by simp [h, hr₂.ne']
    rw [eq_comm]
    simp only [line_map_apply, h', vadd_vsub_assoc, smul_smul, ← add_smul, eq_vadd_iff_vsub_eq,
      smul_add]
    convert(one_smul _ _).symm
    field_simp [(add_pos hr₁ hr₂).ne', hr₂.ne']
    ring
#align wbtw_iff_same_ray_vsub wbtw_iff_sameRay_vsub

variable (R)

/- warning: wbtw_point_reflection -> wbtw_pointReflection is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : LinearOrderedField.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (x : P) (y : P), Wbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 y x (coeFn.{max (succ u3) (succ u2), succ u3} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (fun (_x : AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) => P -> P) (AffineEquiv.hasCoeToFun.{u1, u3, u3, u2, u2} R P P V V (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.pointReflection.{u1, u3, u2} R P V (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) _inst_2 _inst_3 _inst_4 x) y)
but is expected to have type
  forall (R : Type.{u3}) {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : LinearOrderedField.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (x : P) (y : P), Wbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 y x (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u1} (AffineEquiv.{u3, u1, u1, u2, u2} R P P V V (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1470 : P) => P) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u2), succ u1, succ u1} (AffineEquiv.{u3, u1, u1, u2, u2} R P P V V (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P P (EquivLike.toEmbeddingLike.{max (succ u1) (succ u2), succ u1, succ u1} (AffineEquiv.{u3, u1, u1, u2, u2} R P P V V (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P P (AffineEquiv.equivLike.{u3, u1, u1, u2, u2} R P P V V (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4))) (AffineEquiv.pointReflection.{u3, u1, u2} R P V (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) _inst_2 _inst_3 _inst_4 x) y)
Case conversion may be inaccurate. Consider using '#align wbtw_point_reflection wbtw_pointReflectionₓ'. -/
theorem wbtw_pointReflection (x y : P) : Wbtw R y x (pointReflection R x y) :=
  by
  refine' ⟨2⁻¹, ⟨by norm_num, by norm_num⟩, _⟩
  rw [line_map_apply, point_reflection_apply, vadd_vsub_assoc, ← two_smul R (x -ᵥ y)]
  simp
#align wbtw_point_reflection wbtw_pointReflection

/- warning: sbtw_point_reflection_of_ne -> sbtw_pointReflection_of_ne is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : LinearOrderedField.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P}, (Ne.{succ u3} P x y) -> (Sbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 y x (coeFn.{max (succ u3) (succ u2), succ u3} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (fun (_x : AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) => P -> P) (AffineEquiv.hasCoeToFun.{u1, u3, u3, u2, u2} R P P V V (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.pointReflection.{u1, u3, u2} R P V (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) _inst_2 _inst_3 _inst_4 x) y))
but is expected to have type
  forall (R : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : LinearOrderedField.{u2} R] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} R V (DivisionSemiring.toSemiring.{u2} R (Semifield.toDivisionSemiring.{u2} R (LinearOrderedSemifield.toSemifield.{u2} R (LinearOrderedField.toLinearOrderedSemifield.{u2} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {x : P} {y : P}, (Ne.{succ u3} P x y) -> (Sbtw.{u2, u1, u3} R V P (OrderedCommRing.toOrderedRing.{u2} R (StrictOrderedCommRing.toOrderedCommRing.{u2} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u2} R (LinearOrderedField.toLinearOrderedCommRing.{u2} R _inst_1)))) _inst_2 _inst_3 _inst_4 y x (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u3} (AffineEquiv.{u2, u3, u3, u1, u1} R P P V V (DivisionRing.toRing.{u2} R (Field.toDivisionRing.{u2} R (LinearOrderedField.toField.{u2} R _inst_1))) _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1470 : P) => P) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u1), succ u3, succ u3} (AffineEquiv.{u2, u3, u3, u1, u1} R P P V V (DivisionRing.toRing.{u2} R (Field.toDivisionRing.{u2} R (LinearOrderedField.toField.{u2} R _inst_1))) _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P P (EquivLike.toEmbeddingLike.{max (succ u3) (succ u1), succ u3, succ u3} (AffineEquiv.{u2, u3, u3, u1, u1} R P P V V (DivisionRing.toRing.{u2} R (Field.toDivisionRing.{u2} R (LinearOrderedField.toField.{u2} R _inst_1))) _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P P (AffineEquiv.equivLike.{u2, u3, u3, u1, u1} R P P V V (DivisionRing.toRing.{u2} R (Field.toDivisionRing.{u2} R (LinearOrderedField.toField.{u2} R _inst_1))) _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4))) (AffineEquiv.pointReflection.{u2, u3, u1} R P V (DivisionRing.toRing.{u2} R (Field.toDivisionRing.{u2} R (LinearOrderedField.toField.{u2} R _inst_1))) _inst_2 _inst_3 _inst_4 x) y))
Case conversion may be inaccurate. Consider using '#align sbtw_point_reflection_of_ne sbtw_pointReflection_of_neₓ'. -/
theorem sbtw_pointReflection_of_ne {x y : P} (h : x ≠ y) : Sbtw R y x (pointReflection R x y) :=
  by
  refine' ⟨wbtw_pointReflection _ _ _, h, _⟩
  nth_rw 1 [← point_reflection_self R x]
  exact (point_reflection_involutive R x).Injective.Ne h
#align sbtw_point_reflection_of_ne sbtw_pointReflection_of_ne

/- warning: wbtw_midpoint -> wbtw_midpoint is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : LinearOrderedField.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (x : P) (y : P), Wbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 x (midpoint.{u1, u2, u3} R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) (invertibleTwo.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)) (StrictOrderedSemiring.to_charZero.{u1} R (StrictOrderedRing.toStrictOrderedSemiring.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))))) _inst_2 _inst_3 _inst_4 x y) y
but is expected to have type
  forall (R : Type.{u3}) {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : LinearOrderedField.{u3} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} R V (DivisionSemiring.toSemiring.{u3} R (Semifield.toDivisionSemiring.{u3} R (LinearOrderedSemifield.toSemifield.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (x : P) (y : P), Wbtw.{u3, u2, u1} R V P (OrderedCommRing.toOrderedRing.{u3} R (StrictOrderedCommRing.toOrderedCommRing.{u3} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u3} R (LinearOrderedField.toLinearOrderedCommRing.{u3} R _inst_1)))) _inst_2 _inst_3 _inst_4 x (midpoint.{u3, u2, u1} R V P (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1))) (invertibleTwo.{u3} R (Field.toDivisionRing.{u3} R (LinearOrderedField.toField.{u3} R _inst_1)) (StrictOrderedSemiring.to_charZero.{u3} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u3} R (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u3} R (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u3} R (LinearOrderedField.toLinearOrderedSemifield.{u3} R _inst_1)))))) _inst_2 _inst_3 _inst_4 x y) y
Case conversion may be inaccurate. Consider using '#align wbtw_midpoint wbtw_midpointₓ'. -/
theorem wbtw_midpoint (x y : P) : Wbtw R x (midpoint R x y) y :=
  by
  convert wbtw_pointReflection R (midpoint R x y) x
  simp
#align wbtw_midpoint wbtw_midpoint

/- warning: sbtw_midpoint_of_ne -> sbtw_midpoint_of_ne is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : LinearOrderedField.{u1} R] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {y : P}, (Ne.{succ u3} P x y) -> (Sbtw.{u1, u2, u3} R V P (StrictOrderedRing.toOrderedRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))) _inst_2 _inst_3 _inst_4 x (midpoint.{u1, u2, u3} R V P (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1))) (invertibleTwo.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_1)) (StrictOrderedSemiring.to_charZero.{u1} R (StrictOrderedRing.toStrictOrderedSemiring.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_1)))))) _inst_2 _inst_3 _inst_4 x y) y)
but is expected to have type
  forall (R : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : LinearOrderedField.{u2} R] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} R V (DivisionSemiring.toSemiring.{u2} R (Semifield.toDivisionSemiring.{u2} R (LinearOrderedSemifield.toSemifield.{u2} R (LinearOrderedField.toLinearOrderedSemifield.{u2} R _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {x : P} {y : P}, (Ne.{succ u3} P x y) -> (Sbtw.{u2, u1, u3} R V P (OrderedCommRing.toOrderedRing.{u2} R (StrictOrderedCommRing.toOrderedCommRing.{u2} R (LinearOrderedCommRing.toStrictOrderedCommRing.{u2} R (LinearOrderedField.toLinearOrderedCommRing.{u2} R _inst_1)))) _inst_2 _inst_3 _inst_4 x (midpoint.{u2, u1, u3} R V P (DivisionRing.toRing.{u2} R (Field.toDivisionRing.{u2} R (LinearOrderedField.toField.{u2} R _inst_1))) (invertibleTwo.{u2} R (Field.toDivisionRing.{u2} R (LinearOrderedField.toField.{u2} R _inst_1)) (StrictOrderedSemiring.to_charZero.{u2} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} R (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} R (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} R (LinearOrderedField.toLinearOrderedSemifield.{u2} R _inst_1)))))) _inst_2 _inst_3 _inst_4 x y) y)
Case conversion may be inaccurate. Consider using '#align sbtw_midpoint_of_ne sbtw_midpoint_of_neₓ'. -/
theorem sbtw_midpoint_of_ne {x y : P} (h : x ≠ y) : Sbtw R x (midpoint R x y) y :=
  by
  have h : midpoint R x y ≠ x := by simp [h]
  convert sbtw_pointReflection_of_ne R h
  simp
#align sbtw_midpoint_of_ne sbtw_midpoint_of_ne

end LinearOrderedField

