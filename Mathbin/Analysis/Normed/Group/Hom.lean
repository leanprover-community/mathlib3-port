/-
Copyright (c) 2021 Johan Commelin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johan Commelin

! This file was ported from Lean 3 source module analysis.normed.group.hom
! leanprover-community/mathlib commit 69c6a5a12d8a2b159f20933e60115a4f2de62b58
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Analysis.Normed.Group.Basic

/-!
# Normed groups homomorphisms

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file gathers definitions and elementary constructions about bounded group homomorphisms
between normed (abelian) groups (abbreviated to "normed group homs").

The main lemmas relate the boundedness condition to continuity and Lipschitzness.

The main construction is to endow the type of normed group homs between two given normed groups
with a group structure and a norm, giving rise to a normed group structure. We provide several
simple constructions for normed group homs, like kernel, range and equalizer.

Some easy other constructions are related to subgroups of normed groups.

Since a lot of elementary properties don't require `‖x‖ = 0 → x = 0` we start setting up the
theory of `seminormed_add_group_hom` and we specialize to `normed_add_group_hom` when needed.
-/


noncomputable section

open NNReal BigOperators

#print NormedAddGroupHom /-
/-- A morphism of seminormed abelian groups is a bounded group homomorphism. -/
structure NormedAddGroupHom (V W : Type _) [SeminormedAddCommGroup V]
  [SeminormedAddCommGroup W] where
  toFun : V → W
  map_add' : ∀ v₁ v₂, to_fun (v₁ + v₂) = to_fun v₁ + to_fun v₂
  bound' : ∃ C, ∀ v, ‖to_fun v‖ ≤ C * ‖v‖
#align normed_add_group_hom NormedAddGroupHom
-/

namespace AddMonoidHom

variable {V W : Type _} [SeminormedAddCommGroup V] [SeminormedAddCommGroup W]
  {f g : NormedAddGroupHom V W}

/- warning: add_monoid_hom.mk_normed_add_group_hom -> AddMonoidHom.mkNormedAddGroupHom is a dubious translation:
lean 3 declaration is
  forall {V : Type.{u1}} {W : Type.{u2}} [_inst_1 : SeminormedAddCommGroup.{u1} V] [_inst_2 : SeminormedAddCommGroup.{u2} W] (f : AddMonoidHom.{u1, u2} V W (AddMonoid.toAddZeroClass.{u1} V (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))))) (AddMonoid.toAddZeroClass.{u2} W (SubNegMonoid.toAddMonoid.{u2} W (AddGroup.toSubNegMonoid.{u2} W (SeminormedAddGroup.toAddGroup.{u2} W (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} W _inst_2)))))) (C : Real), (forall (v : V), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} W (SeminormedAddCommGroup.toHasNorm.{u2} W _inst_2) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} V W (AddMonoid.toAddZeroClass.{u1} V (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))))) (AddMonoid.toAddZeroClass.{u2} W (SubNegMonoid.toAddMonoid.{u2} W (AddGroup.toSubNegMonoid.{u2} W (SeminormedAddGroup.toAddGroup.{u2} W (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} W _inst_2)))))) (fun (_x : AddMonoidHom.{u1, u2} V W (AddMonoid.toAddZeroClass.{u1} V (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))))) (AddMonoid.toAddZeroClass.{u2} W (SubNegMonoid.toAddMonoid.{u2} W (AddGroup.toSubNegMonoid.{u2} W (SeminormedAddGroup.toAddGroup.{u2} W (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} W _inst_2)))))) => V -> W) (AddMonoidHom.hasCoeToFun.{u1, u2} V W (AddMonoid.toAddZeroClass.{u1} V (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))))) (AddMonoid.toAddZeroClass.{u2} W (SubNegMonoid.toAddMonoid.{u2} W (AddGroup.toSubNegMonoid.{u2} W (SeminormedAddGroup.toAddGroup.{u2} W (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} W _inst_2)))))) f v)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) C (Norm.norm.{u1} V (SeminormedAddCommGroup.toHasNorm.{u1} V _inst_1) v))) -> (NormedAddGroupHom.{u1, u2} V W _inst_1 _inst_2)
but is expected to have type
  forall {V : Type.{u1}} {W : Type.{u2}} [_inst_1 : SeminormedAddCommGroup.{u1} V] [_inst_2 : SeminormedAddCommGroup.{u2} W] (f : AddMonoidHom.{u1, u2} V W (AddMonoid.toAddZeroClass.{u1} V (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))))) (AddMonoid.toAddZeroClass.{u2} W (SubNegMonoid.toAddMonoid.{u2} W (AddGroup.toSubNegMonoid.{u2} W (SeminormedAddGroup.toAddGroup.{u2} W (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} W _inst_2)))))) (C : Real), (forall (v : V), LE.le.{0} Real Real.instLEReal (Norm.norm.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : V) => W) v) (SeminormedAddCommGroup.toNorm.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : V) => W) v) _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AddMonoidHom.{u1, u2} V W (AddMonoid.toAddZeroClass.{u1} V (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))))) (AddMonoid.toAddZeroClass.{u2} W (SubNegMonoid.toAddMonoid.{u2} W (AddGroup.toSubNegMonoid.{u2} W (SeminormedAddGroup.toAddGroup.{u2} W (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} W _inst_2)))))) V (fun (_x : V) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : V) => W) _x) (AddHomClass.toFunLike.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} V W (AddMonoid.toAddZeroClass.{u1} V (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))))) (AddMonoid.toAddZeroClass.{u2} W (SubNegMonoid.toAddMonoid.{u2} W (AddGroup.toSubNegMonoid.{u2} W (SeminormedAddGroup.toAddGroup.{u2} W (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} W _inst_2)))))) V W (AddZeroClass.toAdd.{u1} V (AddMonoid.toAddZeroClass.{u1} V (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1)))))) (AddZeroClass.toAdd.{u2} W (AddMonoid.toAddZeroClass.{u2} W (SubNegMonoid.toAddMonoid.{u2} W (AddGroup.toSubNegMonoid.{u2} W (SeminormedAddGroup.toAddGroup.{u2} W (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} W _inst_2)))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} V W (AddMonoid.toAddZeroClass.{u1} V (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))))) (AddMonoid.toAddZeroClass.{u2} W (SubNegMonoid.toAddMonoid.{u2} W (AddGroup.toSubNegMonoid.{u2} W (SeminormedAddGroup.toAddGroup.{u2} W (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} W _inst_2)))))) V W (AddMonoid.toAddZeroClass.{u1} V (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))))) (AddMonoid.toAddZeroClass.{u2} W (SubNegMonoid.toAddMonoid.{u2} W (AddGroup.toSubNegMonoid.{u2} W (SeminormedAddGroup.toAddGroup.{u2} W (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} W _inst_2))))) (AddMonoidHom.addMonoidHomClass.{u1, u2} V W (AddMonoid.toAddZeroClass.{u1} V (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))))) (AddMonoid.toAddZeroClass.{u2} W (SubNegMonoid.toAddMonoid.{u2} W (AddGroup.toSubNegMonoid.{u2} W (SeminormedAddGroup.toAddGroup.{u2} W (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} W _inst_2)))))))) f v)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) C (Norm.norm.{u1} V (SeminormedAddCommGroup.toNorm.{u1} V _inst_1) v))) -> (NormedAddGroupHom.{u1, u2} V W _inst_1 _inst_2)
Case conversion may be inaccurate. Consider using '#align add_monoid_hom.mk_normed_add_group_hom AddMonoidHom.mkNormedAddGroupHomₓ'. -/
/-- Associate to a group homomorphism a bounded group homomorphism under a norm control condition.

See `add_monoid_hom.mk_normed_add_group_hom'` for a version that uses `ℝ≥0` for the bound. -/
def mkNormedAddGroupHom (f : V →+ W) (C : ℝ) (h : ∀ v, ‖f v‖ ≤ C * ‖v‖) : NormedAddGroupHom V W :=
  { f with bound' := ⟨C, h⟩ }
#align add_monoid_hom.mk_normed_add_group_hom AddMonoidHom.mkNormedAddGroupHom

/- warning: add_monoid_hom.mk_normed_add_group_hom' -> AddMonoidHom.mkNormedAddGroupHom' is a dubious translation:
lean 3 declaration is
  forall {V : Type.{u1}} {W : Type.{u2}} [_inst_1 : SeminormedAddCommGroup.{u1} V] [_inst_2 : SeminormedAddCommGroup.{u2} W] (f : AddMonoidHom.{u1, u2} V W (AddMonoid.toAddZeroClass.{u1} V (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))))) (AddMonoid.toAddZeroClass.{u2} W (SubNegMonoid.toAddMonoid.{u2} W (AddGroup.toSubNegMonoid.{u2} W (SeminormedAddGroup.toAddGroup.{u2} W (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} W _inst_2)))))) (C : NNReal), (forall (x : V), LE.le.{0} NNReal (Preorder.toHasLe.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (NNNorm.nnnorm.{u2} W (SeminormedAddGroup.toNNNorm.{u2} W (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} W _inst_2)) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} V W (AddMonoid.toAddZeroClass.{u1} V (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))))) (AddMonoid.toAddZeroClass.{u2} W (SubNegMonoid.toAddMonoid.{u2} W (AddGroup.toSubNegMonoid.{u2} W (SeminormedAddGroup.toAddGroup.{u2} W (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} W _inst_2)))))) (fun (_x : AddMonoidHom.{u1, u2} V W (AddMonoid.toAddZeroClass.{u1} V (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))))) (AddMonoid.toAddZeroClass.{u2} W (SubNegMonoid.toAddMonoid.{u2} W (AddGroup.toSubNegMonoid.{u2} W (SeminormedAddGroup.toAddGroup.{u2} W (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} W _inst_2)))))) => V -> W) (AddMonoidHom.hasCoeToFun.{u1, u2} V W (AddMonoid.toAddZeroClass.{u1} V (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))))) (AddMonoid.toAddZeroClass.{u2} W (SubNegMonoid.toAddMonoid.{u2} W (AddGroup.toSubNegMonoid.{u2} W (SeminormedAddGroup.toAddGroup.{u2} W (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} W _inst_2)))))) f x)) (HMul.hMul.{0, 0, 0} NNReal NNReal NNReal (instHMul.{0} NNReal (Distrib.toHasMul.{0} NNReal (NonUnitalNonAssocSemiring.toDistrib.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))) C (NNNorm.nnnorm.{u1} V (SeminormedAddGroup.toNNNorm.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1)) x))) -> (NormedAddGroupHom.{u1, u2} V W _inst_1 _inst_2)
but is expected to have type
  forall {V : Type.{u1}} {W : Type.{u2}} [_inst_1 : SeminormedAddCommGroup.{u1} V] [_inst_2 : SeminormedAddCommGroup.{u2} W] (f : AddMonoidHom.{u1, u2} V W (AddMonoid.toAddZeroClass.{u1} V (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))))) (AddMonoid.toAddZeroClass.{u2} W (SubNegMonoid.toAddMonoid.{u2} W (AddGroup.toSubNegMonoid.{u2} W (SeminormedAddGroup.toAddGroup.{u2} W (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} W _inst_2)))))) (C : NNReal), (forall (x : V), LE.le.{0} NNReal (Preorder.toLE.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) (NNNorm.nnnorm.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : V) => W) x) (SeminormedAddGroup.toNNNorm.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : V) => W) x) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : V) => W) x) _inst_2)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AddMonoidHom.{u1, u2} V W (AddMonoid.toAddZeroClass.{u1} V (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))))) (AddMonoid.toAddZeroClass.{u2} W (SubNegMonoid.toAddMonoid.{u2} W (AddGroup.toSubNegMonoid.{u2} W (SeminormedAddGroup.toAddGroup.{u2} W (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} W _inst_2)))))) V (fun (_x : V) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : V) => W) _x) (AddHomClass.toFunLike.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} V W (AddMonoid.toAddZeroClass.{u1} V (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))))) (AddMonoid.toAddZeroClass.{u2} W (SubNegMonoid.toAddMonoid.{u2} W (AddGroup.toSubNegMonoid.{u2} W (SeminormedAddGroup.toAddGroup.{u2} W (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} W _inst_2)))))) V W (AddZeroClass.toAdd.{u1} V (AddMonoid.toAddZeroClass.{u1} V (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1)))))) (AddZeroClass.toAdd.{u2} W (AddMonoid.toAddZeroClass.{u2} W (SubNegMonoid.toAddMonoid.{u2} W (AddGroup.toSubNegMonoid.{u2} W (SeminormedAddGroup.toAddGroup.{u2} W (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} W _inst_2)))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} V W (AddMonoid.toAddZeroClass.{u1} V (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))))) (AddMonoid.toAddZeroClass.{u2} W (SubNegMonoid.toAddMonoid.{u2} W (AddGroup.toSubNegMonoid.{u2} W (SeminormedAddGroup.toAddGroup.{u2} W (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} W _inst_2)))))) V W (AddMonoid.toAddZeroClass.{u1} V (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))))) (AddMonoid.toAddZeroClass.{u2} W (SubNegMonoid.toAddMonoid.{u2} W (AddGroup.toSubNegMonoid.{u2} W (SeminormedAddGroup.toAddGroup.{u2} W (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} W _inst_2))))) (AddMonoidHom.addMonoidHomClass.{u1, u2} V W (AddMonoid.toAddZeroClass.{u1} V (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))))) (AddMonoid.toAddZeroClass.{u2} W (SubNegMonoid.toAddMonoid.{u2} W (AddGroup.toSubNegMonoid.{u2} W (SeminormedAddGroup.toAddGroup.{u2} W (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} W _inst_2)))))))) f x)) (HMul.hMul.{0, 0, 0} NNReal NNReal NNReal (instHMul.{0} NNReal (CanonicallyOrderedCommSemiring.toMul.{0} NNReal instNNRealCanonicallyOrderedCommSemiring)) C (NNNorm.nnnorm.{u1} V (SeminormedAddGroup.toNNNorm.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1)) x))) -> (NormedAddGroupHom.{u1, u2} V W _inst_1 _inst_2)
Case conversion may be inaccurate. Consider using '#align add_monoid_hom.mk_normed_add_group_hom' AddMonoidHom.mkNormedAddGroupHom'ₓ'. -/
/-- Associate to a group homomorphism a bounded group homomorphism under a norm control condition.

See `add_monoid_hom.mk_normed_add_group_hom` for a version that uses `ℝ` for the bound. -/
def mkNormedAddGroupHom' (f : V →+ W) (C : ℝ≥0) (hC : ∀ x, ‖f x‖₊ ≤ C * ‖x‖₊) :
    NormedAddGroupHom V W :=
  { f with bound' := ⟨C, hC⟩ }
#align add_monoid_hom.mk_normed_add_group_hom' AddMonoidHom.mkNormedAddGroupHom'

end AddMonoidHom

/- warning: exists_pos_bound_of_bound -> exists_pos_bound_of_bound is a dubious translation:
lean 3 declaration is
  forall {V : Type.{u1}} {W : Type.{u2}} [_inst_1 : SeminormedAddCommGroup.{u1} V] [_inst_2 : SeminormedAddCommGroup.{u2} W] {f : V -> W} (M : Real), (forall (x : V), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} W (SeminormedAddCommGroup.toHasNorm.{u2} W _inst_2) (f x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) M (Norm.norm.{u1} V (SeminormedAddCommGroup.toHasNorm.{u1} V _inst_1) x))) -> (Exists.{1} Real (fun (N : Real) => And (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) N) (forall (x : V), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} W (SeminormedAddCommGroup.toHasNorm.{u2} W _inst_2) (f x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) N (Norm.norm.{u1} V (SeminormedAddCommGroup.toHasNorm.{u1} V _inst_1) x)))))
but is expected to have type
  forall {V : Type.{u2}} {W : Type.{u1}} [_inst_1 : SeminormedAddCommGroup.{u2} V] [_inst_2 : SeminormedAddCommGroup.{u1} W] {f : V -> W} (M : Real), (forall (x : V), LE.le.{0} Real Real.instLEReal (Norm.norm.{u1} W (SeminormedAddCommGroup.toNorm.{u1} W _inst_2) (f x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) M (Norm.norm.{u2} V (SeminormedAddCommGroup.toNorm.{u2} V _inst_1) x))) -> (Exists.{1} Real (fun (N : Real) => And (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) N) (forall (x : V), LE.le.{0} Real Real.instLEReal (Norm.norm.{u1} W (SeminormedAddCommGroup.toNorm.{u1} W _inst_2) (f x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) N (Norm.norm.{u2} V (SeminormedAddCommGroup.toNorm.{u2} V _inst_1) x)))))
Case conversion may be inaccurate. Consider using '#align exists_pos_bound_of_bound exists_pos_bound_of_boundₓ'. -/
theorem exists_pos_bound_of_bound {V W : Type _} [SeminormedAddCommGroup V]
    [SeminormedAddCommGroup W] {f : V → W} (M : ℝ) (h : ∀ x, ‖f x‖ ≤ M * ‖x‖) :
    ∃ N, 0 < N ∧ ∀ x, ‖f x‖ ≤ N * ‖x‖ :=
  ⟨max M 1, lt_of_lt_of_le zero_lt_one (le_max_right _ _), fun x =>
    calc
      ‖f x‖ ≤ M * ‖x‖ := h x
      _ ≤ max M 1 * ‖x‖ := mul_le_mul_of_nonneg_right (le_max_left _ _) (norm_nonneg _)
      ⟩
#align exists_pos_bound_of_bound exists_pos_bound_of_bound

namespace NormedAddGroupHom

variable {V V₁ V₂ V₃ : Type _} [SeminormedAddCommGroup V] [SeminormedAddCommGroup V₁]
  [SeminormedAddCommGroup V₂] [SeminormedAddCommGroup V₃]

variable {f g : NormedAddGroupHom V₁ V₂}

instance : CoeFun (NormedAddGroupHom V₁ V₂) fun _ => V₁ → V₂ :=
  ⟨NormedAddGroupHom.toFun⟩

initialize_simps_projections NormedAddGroupHom (toFun → apply)

/- warning: normed_add_group_hom.coe_inj -> NormedAddGroupHom.coe_inj is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] {f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3} {g : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3}, (Eq.{max (succ u1) (succ u2)} ((fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) g)) -> (Eq.{max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) f g)
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] {f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3} {g : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3}, (Eq.{max (succ u2) (succ u1)} (V₁ -> V₂) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) f) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) g)) -> (Eq.{max (succ u2) (succ u1)} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) f g)
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.coe_inj NormedAddGroupHom.coe_injₓ'. -/
theorem coe_inj (H : (f : V₁ → V₂) = g) : f = g := by
  cases f <;> cases g <;> congr <;> exact funext H
#align normed_add_group_hom.coe_inj NormedAddGroupHom.coe_inj

#print NormedAddGroupHom.coe_injective /-
theorem coe_injective : @Function.Injective (NormedAddGroupHom V₁ V₂) (V₁ → V₂) coeFn := by
  apply coe_inj
#align normed_add_group_hom.coe_injective NormedAddGroupHom.coe_injective
-/

/- warning: normed_add_group_hom.coe_inj_iff -> NormedAddGroupHom.coe_inj_iff is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] {f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3} {g : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3}, Iff (Eq.{max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) f g) (Eq.{max (succ u1) (succ u2)} ((fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) g))
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] {f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3} {g : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3}, Iff (Eq.{max (succ u2) (succ u1)} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) f g) (Eq.{max (succ u2) (succ u1)} (V₁ -> V₂) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) f) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) g))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.coe_inj_iff NormedAddGroupHom.coe_inj_iffₓ'. -/
theorem coe_inj_iff : f = g ↔ (f : V₁ → V₂) = g :=
  ⟨congr_arg _, coe_inj⟩
#align normed_add_group_hom.coe_inj_iff NormedAddGroupHom.coe_inj_iff

#print NormedAddGroupHom.ext /-
@[ext]
theorem ext (H : ∀ x, f x = g x) : f = g :=
  coe_inj <| funext H
#align normed_add_group_hom.ext NormedAddGroupHom.ext
-/

/- warning: normed_add_group_hom.ext_iff -> NormedAddGroupHom.ext_iff is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] {f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3} {g : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3}, Iff (Eq.{max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) f g) (forall (x : V₁), Eq.{succ u2} V₂ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) g x))
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] {f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3} {g : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3}, Iff (Eq.{max (succ u2) (succ u1)} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) f g) (forall (x : V₁), Eq.{succ u1} V₂ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) g x))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.ext_iff NormedAddGroupHom.ext_iffₓ'. -/
theorem ext_iff : f = g ↔ ∀ x, f x = g x :=
  ⟨by rintro rfl x <;> rfl, ext⟩
#align normed_add_group_hom.ext_iff NormedAddGroupHom.ext_iff

variable (f g)

/- warning: normed_add_group_hom.to_fun_eq_coe -> NormedAddGroupHom.toFun_eq_coe is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3), Eq.{max (succ u1) (succ u2)} (V₁ -> V₂) (NormedAddGroupHom.toFun.{u1, u2} V₁ V₂ _inst_2 _inst_3 f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f)
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] (f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3), Eq.{max (succ u2) (succ u1)} (V₁ -> V₂) (NormedAddGroupHom.toFun.{u2, u1} V₁ V₂ _inst_2 _inst_3 f) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) f)
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.to_fun_eq_coe NormedAddGroupHom.toFun_eq_coeₓ'. -/
@[simp]
theorem toFun_eq_coe : f.toFun = f :=
  rfl
#align normed_add_group_hom.to_fun_eq_coe NormedAddGroupHom.toFun_eq_coe

/- warning: normed_add_group_hom.coe_mk -> NormedAddGroupHom.coe_mk is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : V₁ -> V₂) (h₁ : forall (v₁ : V₁) (v₂ : V₁), Eq.{succ u2} V₂ (f (HAdd.hAdd.{u1, u1, u1} V₁ V₁ V₁ (instHAdd.{u1} V₁ (AddZeroClass.toHasAdd.{u1} V₁ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))))) v₁ v₂)) (HAdd.hAdd.{u2, u2, u2} V₂ V₂ V₂ (instHAdd.{u2} V₂ (AddZeroClass.toHasAdd.{u2} V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))))) (f v₁) (f v₂))) (h₂ : Real) (h₃ : forall (v : V₁), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} V₂ (SeminormedAddCommGroup.toHasNorm.{u2} V₂ _inst_3) (f v)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) h₂ (Norm.norm.{u1} V₁ (SeminormedAddCommGroup.toHasNorm.{u1} V₁ _inst_2) v))), Eq.{max (succ u1) (succ u2)} (V₁ -> V₂) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.mk.{u1, u2} V₁ V₂ _inst_2 _inst_3 f h₁ (Exists.intro.{1} Real (fun (C : Real) => forall (v : V₁), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} V₂ (SeminormedAddCommGroup.toHasNorm.{u2} V₂ _inst_3) (f v)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) C (Norm.norm.{u1} V₁ (SeminormedAddCommGroup.toHasNorm.{u1} V₁ _inst_2) v))) h₂ h₃))) f
but is expected to have type
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : V₁ -> V₂) (h₁ : forall (v₁ : V₁) (v₂ : V₁), Eq.{succ u2} V₂ (f (HAdd.hAdd.{u1, u1, u1} V₁ V₁ V₁ (instHAdd.{u1} V₁ (AddZeroClass.toAdd.{u1} V₁ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))))) v₁ v₂)) (HAdd.hAdd.{u2, u2, u2} V₂ V₂ V₂ (instHAdd.{u2} V₂ (AddZeroClass.toAdd.{u2} V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))))) (f v₁) (f v₂))) (h₂ : Real) (h₃ : forall (v : V₁), LE.le.{0} Real Real.instLEReal (Norm.norm.{u2} V₂ (SeminormedAddCommGroup.toNorm.{u2} V₂ _inst_3) (f v)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) h₂ (Norm.norm.{u1} V₁ (SeminormedAddCommGroup.toNorm.{u1} V₁ _inst_2) v))), Eq.{max (succ u1) (succ u2)} (V₁ -> V₂) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u1 u2, u1, u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u1} V₁ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u2} V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u1, u2} V₁ V₂ _inst_2 _inst_3))) (NormedAddGroupHom.mk.{u1, u2} V₁ V₂ _inst_2 _inst_3 f h₁ (Exists.intro.{1} Real (fun (C : Real) => forall (v : V₁), LE.le.{0} Real Real.instLEReal (Norm.norm.{u2} V₂ (SeminormedAddCommGroup.toNorm.{u2} V₂ _inst_3) (f v)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) C (Norm.norm.{u1} V₁ (SeminormedAddCommGroup.toNorm.{u1} V₁ _inst_2) v))) h₂ h₃))) f
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.coe_mk NormedAddGroupHom.coe_mkₓ'. -/
@[simp]
theorem coe_mk (f) (h₁) (h₂) (h₃) : ⇑(⟨f, h₁, h₂, h₃⟩ : NormedAddGroupHom V₁ V₂) = f :=
  rfl
#align normed_add_group_hom.coe_mk NormedAddGroupHom.coe_mk

/- warning: normed_add_group_hom.coe_mk_normed_add_group_hom -> NormedAddGroupHom.coe_mkNormedAddGroupHom is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.coe_mk_normed_add_group_hom NormedAddGroupHom.coe_mkNormedAddGroupHomₓ'. -/
@[simp]
theorem coe_mkNormedAddGroupHom (f : V₁ →+ V₂) (C) (hC) : ⇑(f.mkNormedAddGroupHom C hC) = f :=
  rfl
#align normed_add_group_hom.coe_mk_normed_add_group_hom NormedAddGroupHom.coe_mkNormedAddGroupHom

/- warning: normed_add_group_hom.coe_mk_normed_add_group_hom' -> NormedAddGroupHom.coe_mkNormedAddGroupHom' is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.coe_mk_normed_add_group_hom' NormedAddGroupHom.coe_mkNormedAddGroupHom'ₓ'. -/
@[simp]
theorem coe_mkNormedAddGroupHom' (f : V₁ →+ V₂) (C) (hC) : ⇑(f.mkNormedAddGroupHom' C hC) = f :=
  rfl
#align normed_add_group_hom.coe_mk_normed_add_group_hom' NormedAddGroupHom.coe_mkNormedAddGroupHom'

#print NormedAddGroupHom.toAddMonoidHom /-
/-- The group homomorphism underlying a bounded group homomorphism. -/
def toAddMonoidHom (f : NormedAddGroupHom V₁ V₂) : V₁ →+ V₂ :=
  AddMonoidHom.mk' f f.map_add'
#align normed_add_group_hom.to_add_monoid_hom NormedAddGroupHom.toAddMonoidHom
-/

/- warning: normed_add_group_hom.coe_to_add_monoid_hom -> NormedAddGroupHom.coe_toAddMonoidHom is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3), Eq.{max (succ u1) (succ u2)} (V₁ -> V₂) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} V₁ V₂ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) (fun (_x : AddMonoidHom.{u1, u2} V₁ V₂ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) => V₁ -> V₂) (AddMonoidHom.hasCoeToFun.{u1, u2} V₁ V₂ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) (NormedAddGroupHom.toAddMonoidHom.{u1, u2} V₁ V₂ _inst_2 _inst_3 f)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f)
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] (f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : V₁), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : V₁) => V₂) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AddMonoidHom.{u2, u1} V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) V₁ (fun (_x : V₁) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : V₁) => V₂) _x) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (AddMonoidHom.addMonoidHomClass.{u2, u1} V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))))) (NormedAddGroupHom.toAddMonoidHom.{u2, u1} V₁ V₂ _inst_2 _inst_3 f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) f)
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.coe_to_add_monoid_hom NormedAddGroupHom.coe_toAddMonoidHomₓ'. -/
@[simp]
theorem coe_toAddMonoidHom : ⇑f.toAddMonoidHom = f :=
  rfl
#align normed_add_group_hom.coe_to_add_monoid_hom NormedAddGroupHom.coe_toAddMonoidHom

/- warning: normed_add_group_hom.to_add_monoid_hom_injective -> NormedAddGroupHom.toAddMonoidHom_injective is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂], Function.Injective.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (AddMonoidHom.{u1, u2} V₁ V₂ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) (NormedAddGroupHom.toAddMonoidHom.{u1, u2} V₁ V₂ _inst_2 _inst_3)
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂], Function.Injective.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (AddMonoidHom.{u2, u1} V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (NormedAddGroupHom.toAddMonoidHom.{u2, u1} V₁ V₂ _inst_2 _inst_3)
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.to_add_monoid_hom_injective NormedAddGroupHom.toAddMonoidHom_injectiveₓ'. -/
theorem toAddMonoidHom_injective :
    Function.Injective (@NormedAddGroupHom.toAddMonoidHom V₁ V₂ _ _) := fun f g h =>
  coe_inj <| show ⇑f.toAddMonoidHom = g by rw [h]; rfl
#align normed_add_group_hom.to_add_monoid_hom_injective NormedAddGroupHom.toAddMonoidHom_injective

/- warning: normed_add_group_hom.mk_to_add_monoid_hom -> NormedAddGroupHom.mk_toAddMonoidHom is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : V₁ -> V₂) (h₁ : forall (v₁ : V₁) (v₂ : V₁), Eq.{succ u2} V₂ (f (HAdd.hAdd.{u1, u1, u1} V₁ V₁ V₁ (instHAdd.{u1} V₁ (AddZeroClass.toHasAdd.{u1} V₁ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))))) v₁ v₂)) (HAdd.hAdd.{u2, u2, u2} V₂ V₂ V₂ (instHAdd.{u2} V₂ (AddZeroClass.toHasAdd.{u2} V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))))) (f v₁) (f v₂))) (h₂ : Exists.{1} Real (fun (C : Real) => forall (v : V₁), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} V₂ (SeminormedAddCommGroup.toHasNorm.{u2} V₂ _inst_3) (f v)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) C (Norm.norm.{u1} V₁ (SeminormedAddCommGroup.toHasNorm.{u1} V₁ _inst_2) v)))), Eq.{max (succ u2) (succ u1)} (AddMonoidHom.{u1, u2} V₁ V₂ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) (NormedAddGroupHom.toAddMonoidHom.{u1, u2} V₁ V₂ _inst_2 _inst_3 (NormedAddGroupHom.mk.{u1, u2} V₁ V₂ _inst_2 _inst_3 f h₁ h₂)) (AddMonoidHom.mk'.{u1, u2} V₁ V₂ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))) (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)) f h₁)
but is expected to have type
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : V₁ -> V₂) (h₁ : forall (v₁ : V₁) (v₂ : V₁), Eq.{succ u2} V₂ (f (HAdd.hAdd.{u1, u1, u1} V₁ V₁ V₁ (instHAdd.{u1} V₁ (AddZeroClass.toAdd.{u1} V₁ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))))) v₁ v₂)) (HAdd.hAdd.{u2, u2, u2} V₂ V₂ V₂ (instHAdd.{u2} V₂ (AddZeroClass.toAdd.{u2} V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))))) (f v₁) (f v₂))) (h₂ : Exists.{1} Real (fun (C : Real) => forall (v : V₁), LE.le.{0} Real Real.instLEReal (Norm.norm.{u2} V₂ (SeminormedAddCommGroup.toNorm.{u2} V₂ _inst_3) (f v)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) C (Norm.norm.{u1} V₁ (SeminormedAddCommGroup.toNorm.{u1} V₁ _inst_2) v)))), Eq.{max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} V₁ V₂ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) (NormedAddGroupHom.toAddMonoidHom.{u1, u2} V₁ V₂ _inst_2 _inst_3 (NormedAddGroupHom.mk.{u1, u2} V₁ V₂ _inst_2 _inst_3 f h₁ h₂)) (AddMonoidHom.mk'.{u1, u2} V₁ V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)) (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))) f h₁)
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.mk_to_add_monoid_hom NormedAddGroupHom.mk_toAddMonoidHomₓ'. -/
@[simp]
theorem mk_toAddMonoidHom (f) (h₁) (h₂) :
    (⟨f, h₁, h₂⟩ : NormedAddGroupHom V₁ V₂).toAddMonoidHom = AddMonoidHom.mk' f h₁ :=
  rfl
#align normed_add_group_hom.mk_to_add_monoid_hom NormedAddGroupHom.mk_toAddMonoidHom

instance : AddMonoidHomClass (NormedAddGroupHom V₁ V₂) V₁ V₂
    where
  coe := coeFn
  coe_injective' := coe_injective
  map_add f := f.toAddMonoidHom.map_add
  map_zero f := f.toAddMonoidHom.map_zero

/- warning: normed_add_group_hom.bound -> NormedAddGroupHom.bound is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3), Exists.{1} Real (fun (C : Real) => And (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) C) (forall (x : V₁), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} V₂ (SeminormedAddCommGroup.toHasNorm.{u2} V₂ _inst_3) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) C (Norm.norm.{u1} V₁ (SeminormedAddCommGroup.toHasNorm.{u1} V₁ _inst_2) x))))
but is expected to have type
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3), Exists.{1} Real (fun (C : Real) => And (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) C) (forall (x : V₁), LE.le.{0} Real Real.instLEReal (Norm.norm.{u2} V₂ (SeminormedAddCommGroup.toNorm.{u2} V₂ _inst_3) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u1 u2, u1, u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u1} V₁ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u2} V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u1, u2} V₁ V₂ _inst_2 _inst_3))) f x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) C (Norm.norm.{u1} V₁ (SeminormedAddCommGroup.toNorm.{u1} V₁ _inst_2) x))))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.bound NormedAddGroupHom.boundₓ'. -/
theorem bound : ∃ C, 0 < C ∧ ∀ x, ‖f x‖ ≤ C * ‖x‖ :=
  let ⟨C, hC⟩ := f.bound'
  exists_pos_bound_of_bound _ hC
#align normed_add_group_hom.bound NormedAddGroupHom.bound

/- warning: normed_add_group_hom.antilipschitz_of_norm_ge -> NormedAddGroupHom.antilipschitz_of_norm_ge is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) {K : NNReal}, (forall (x : V₁), LE.le.{0} Real Real.hasLe (Norm.norm.{u1} V₁ (SeminormedAddCommGroup.toHasNorm.{u1} V₁ _inst_2) x) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) NNReal Real (HasLiftT.mk.{1, 1} NNReal Real (CoeTCₓ.coe.{1, 1} NNReal Real (coeBase.{1, 1} NNReal Real NNReal.Real.hasCoe))) K) (Norm.norm.{u2} V₂ (SeminormedAddCommGroup.toHasNorm.{u2} V₂ _inst_3) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f x)))) -> (AntilipschitzWith.{u1, u2} V₁ V₂ (PseudoMetricSpace.toPseudoEMetricSpace.{u1} V₁ (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} V₁ _inst_2)) (PseudoMetricSpace.toPseudoEMetricSpace.{u2} V₂ (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} V₂ _inst_3)) K (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f))
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] (f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) {K : NNReal}, (forall (x : V₁), LE.le.{0} Real Real.instLEReal (Norm.norm.{u2} V₁ (SeminormedAddCommGroup.toNorm.{u2} V₁ _inst_2) x) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (NNReal.toReal K) (Norm.norm.{u1} V₂ (SeminormedAddCommGroup.toNorm.{u1} V₂ _inst_3) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) f x)))) -> (AntilipschitzWith.{u2, u1} V₁ V₂ (PseudoMetricSpace.toPseudoEMetricSpace.{u2} V₁ (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} V₁ _inst_2)) (PseudoMetricSpace.toPseudoEMetricSpace.{u1} V₂ (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} V₂ _inst_3)) K (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) f))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.antilipschitz_of_norm_ge NormedAddGroupHom.antilipschitz_of_norm_geₓ'. -/
theorem antilipschitz_of_norm_ge {K : ℝ≥0} (h : ∀ x, ‖x‖ ≤ K * ‖f x‖) : AntilipschitzWith K f :=
  AntilipschitzWith.of_le_mul_dist fun x y => by simpa only [dist_eq_norm, map_sub] using h (x - y)
#align normed_add_group_hom.antilipschitz_of_norm_ge NormedAddGroupHom.antilipschitz_of_norm_ge

#print NormedAddGroupHom.SurjectiveOnWith /-
/-- A normed group hom is surjective on the subgroup `K` with constant `C` if every element
`x` of `K` has a preimage whose norm is bounded above by `C*‖x‖`. This is a more
abstract version of `f` having a right inverse defined on `K` with operator norm
at most `C`. -/
def SurjectiveOnWith (f : NormedAddGroupHom V₁ V₂) (K : AddSubgroup V₂) (C : ℝ) : Prop :=
  ∀ h ∈ K, ∃ g, f g = h ∧ ‖g‖ ≤ C * ‖h‖
#align normed_add_group_hom.surjective_on_with NormedAddGroupHom.SurjectiveOnWith
-/

/- warning: normed_add_group_hom.surjective_on_with.mono -> NormedAddGroupHom.SurjectiveOnWith.mono is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] {f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3} {K : AddSubgroup.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))} {C : Real} {C' : Real}, (NormedAddGroupHom.SurjectiveOnWith.{u1, u2} V₁ V₂ _inst_2 _inst_3 f K C) -> (LE.le.{0} Real Real.hasLe C C') -> (NormedAddGroupHom.SurjectiveOnWith.{u1, u2} V₁ V₂ _inst_2 _inst_3 f K C')
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] {f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3} {K : AddSubgroup.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))} {C : Real} {C' : Real}, (NormedAddGroupHom.SurjectiveOnWith.{u2, u1} V₁ V₂ _inst_2 _inst_3 f K C) -> (LE.le.{0} Real Real.instLEReal C C') -> (NormedAddGroupHom.SurjectiveOnWith.{u2, u1} V₁ V₂ _inst_2 _inst_3 f K C')
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.surjective_on_with.mono NormedAddGroupHom.SurjectiveOnWith.monoₓ'. -/
theorem SurjectiveOnWith.mono {f : NormedAddGroupHom V₁ V₂} {K : AddSubgroup V₂} {C C' : ℝ}
    (h : f.SurjectiveOnWith K C) (H : C ≤ C') : f.SurjectiveOnWith K C' :=
  by
  intro k k_in
  rcases h k k_in with ⟨g, rfl, hg⟩
  use g, rfl
  by_cases Hg : ‖f g‖ = 0
  · simpa [Hg] using hg
  · exact hg.trans ((mul_le_mul_right <| (Ne.symm Hg).le_iff_lt.mp (norm_nonneg _)).mpr H)
#align normed_add_group_hom.surjective_on_with.mono NormedAddGroupHom.SurjectiveOnWith.mono

/- warning: normed_add_group_hom.surjective_on_with.exists_pos -> NormedAddGroupHom.SurjectiveOnWith.exists_pos is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] {f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3} {K : AddSubgroup.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))} {C : Real}, (NormedAddGroupHom.SurjectiveOnWith.{u1, u2} V₁ V₂ _inst_2 _inst_3 f K C) -> (Exists.{1} Real (fun (C' : Real) => Exists.{0} (GT.gt.{0} Real Real.hasLt C' (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) (fun (H : GT.gt.{0} Real Real.hasLt C' (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) => NormedAddGroupHom.SurjectiveOnWith.{u1, u2} V₁ V₂ _inst_2 _inst_3 f K C')))
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] {f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3} {K : AddSubgroup.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))} {C : Real}, (NormedAddGroupHom.SurjectiveOnWith.{u2, u1} V₁ V₂ _inst_2 _inst_3 f K C) -> (Exists.{1} Real (fun (C' : Real) => And (GT.gt.{0} Real Real.instLTReal C' (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (NormedAddGroupHom.SurjectiveOnWith.{u2, u1} V₁ V₂ _inst_2 _inst_3 f K C')))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.surjective_on_with.exists_pos NormedAddGroupHom.SurjectiveOnWith.exists_posₓ'. -/
theorem SurjectiveOnWith.exists_pos {f : NormedAddGroupHom V₁ V₂} {K : AddSubgroup V₂} {C : ℝ}
    (h : f.SurjectiveOnWith K C) : ∃ C' > 0, f.SurjectiveOnWith K C' :=
  by
  refine' ⟨|C| + 1, _, _⟩
  · linarith [abs_nonneg C]
  · apply h.mono
    linarith [le_abs_self C]
#align normed_add_group_hom.surjective_on_with.exists_pos NormedAddGroupHom.SurjectiveOnWith.exists_pos

/- warning: normed_add_group_hom.surjective_on_with.surj_on -> NormedAddGroupHom.SurjectiveOnWith.surjOn is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] {f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3} {K : AddSubgroup.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))} {C : Real}, (NormedAddGroupHom.SurjectiveOnWith.{u1, u2} V₁ V₂ _inst_2 _inst_3 f K C) -> (Set.SurjOn.{u1, u2} V₁ V₂ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f) (Set.univ.{u1} V₁) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (AddSubgroup.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))) (Set.{u2} V₂) (HasLiftT.mk.{succ u2, succ u2} (AddSubgroup.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))) (Set.{u2} V₂) (CoeTCₓ.coe.{succ u2, succ u2} (AddSubgroup.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))) (Set.{u2} V₂) (SetLike.Set.hasCoeT.{u2, u2} (AddSubgroup.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))) V₂ (AddSubgroup.setLike.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) K))
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] {f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3} {K : AddSubgroup.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))} {C : Real}, (NormedAddGroupHom.SurjectiveOnWith.{u2, u1} V₁ V₂ _inst_2 _inst_3 f K C) -> (Set.SurjOn.{u2, u1} V₁ V₂ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) f) (Set.univ.{u2} V₁) (SetLike.coe.{u1, u1} (AddSubgroup.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))) V₂ (AddSubgroup.instSetLikeAddSubgroup.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))) K))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.surjective_on_with.surj_on NormedAddGroupHom.SurjectiveOnWith.surjOnₓ'. -/
theorem SurjectiveOnWith.surjOn {f : NormedAddGroupHom V₁ V₂} {K : AddSubgroup V₂} {C : ℝ}
    (h : f.SurjectiveOnWith K C) : Set.SurjOn f Set.univ K := fun x hx =>
  (h x hx).imp fun a ⟨ha, _⟩ => ⟨Set.mem_univ _, ha⟩
#align normed_add_group_hom.surjective_on_with.surj_on NormedAddGroupHom.SurjectiveOnWith.surjOn

/-! ### The operator norm -/


#print NormedAddGroupHom.opNorm /-
/-- The operator norm of a seminormed group homomorphism is the inf of all its bounds. -/
def opNorm (f : NormedAddGroupHom V₁ V₂) :=
  sInf { c | 0 ≤ c ∧ ∀ x, ‖f x‖ ≤ c * ‖x‖ }
#align normed_add_group_hom.op_norm NormedAddGroupHom.opNorm
-/

#print NormedAddGroupHom.hasOpNorm /-
instance hasOpNorm : Norm (NormedAddGroupHom V₁ V₂) :=
  ⟨opNorm⟩
#align normed_add_group_hom.has_op_norm NormedAddGroupHom.hasOpNorm
-/

/- warning: normed_add_group_hom.norm_def -> NormedAddGroupHom.norm_def is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3), Eq.{1} Real (Norm.norm.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u1, u2} V₁ V₂ _inst_2 _inst_3) f) (InfSet.sInf.{0} Real Real.hasInf (setOf.{0} Real (fun (c : Real) => And (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) c) (forall (x : V₁), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} V₂ (SeminormedAddCommGroup.toHasNorm.{u2} V₂ _inst_3) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) c (Norm.norm.{u1} V₁ (SeminormedAddCommGroup.toHasNorm.{u1} V₁ _inst_2) x))))))
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] (f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3), Eq.{1} Real (Norm.norm.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u2, u1} V₁ V₂ _inst_2 _inst_3) f) (InfSet.sInf.{0} Real Real.instInfSetReal (setOf.{0} Real (fun (c : Real) => And (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) c) (forall (x : V₁), LE.le.{0} Real Real.instLEReal (Norm.norm.{u1} V₂ (SeminormedAddCommGroup.toNorm.{u1} V₂ _inst_3) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) f x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) c (Norm.norm.{u2} V₁ (SeminormedAddCommGroup.toNorm.{u2} V₁ _inst_2) x))))))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.norm_def NormedAddGroupHom.norm_defₓ'. -/
theorem norm_def : ‖f‖ = sInf { c | 0 ≤ c ∧ ∀ x, ‖f x‖ ≤ c * ‖x‖ } :=
  rfl
#align normed_add_group_hom.norm_def NormedAddGroupHom.norm_def

/- warning: normed_add_group_hom.bounds_nonempty -> NormedAddGroupHom.bounds_nonempty is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] {f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3}, Exists.{1} Real (fun (c : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) c (setOf.{0} Real (fun (c : Real) => And (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) c) (forall (x : V₁), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} V₂ (SeminormedAddCommGroup.toHasNorm.{u2} V₂ _inst_3) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) c (Norm.norm.{u1} V₁ (SeminormedAddCommGroup.toHasNorm.{u1} V₁ _inst_2) x))))))
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] {f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3}, Exists.{1} Real (fun (c : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) c (setOf.{0} Real (fun (c : Real) => And (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) c) (forall (x : V₁), LE.le.{0} Real Real.instLEReal (Norm.norm.{u1} V₂ (SeminormedAddCommGroup.toNorm.{u1} V₂ _inst_3) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) f x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) c (Norm.norm.{u2} V₁ (SeminormedAddCommGroup.toNorm.{u2} V₁ _inst_2) x))))))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.bounds_nonempty NormedAddGroupHom.bounds_nonemptyₓ'. -/
-- So that invocations of `le_cInf` make sense: we show that the set of
-- bounds is nonempty and bounded below.
theorem bounds_nonempty {f : NormedAddGroupHom V₁ V₂} :
    ∃ c, c ∈ { c | 0 ≤ c ∧ ∀ x, ‖f x‖ ≤ c * ‖x‖ } :=
  let ⟨M, hMp, hMb⟩ := f.bound
  ⟨M, le_of_lt hMp, hMb⟩
#align normed_add_group_hom.bounds_nonempty NormedAddGroupHom.bounds_nonempty

/- warning: normed_add_group_hom.bounds_bdd_below -> NormedAddGroupHom.bounds_bddBelow is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] {f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3}, BddBelow.{0} Real Real.preorder (setOf.{0} Real (fun (c : Real) => And (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) c) (forall (x : V₁), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} V₂ (SeminormedAddCommGroup.toHasNorm.{u2} V₂ _inst_3) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) c (Norm.norm.{u1} V₁ (SeminormedAddCommGroup.toHasNorm.{u1} V₁ _inst_2) x)))))
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] {f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3}, BddBelow.{0} Real Real.instPreorderReal (setOf.{0} Real (fun (c : Real) => And (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) c) (forall (x : V₁), LE.le.{0} Real Real.instLEReal (Norm.norm.{u1} V₂ (SeminormedAddCommGroup.toNorm.{u1} V₂ _inst_3) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) f x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) c (Norm.norm.{u2} V₁ (SeminormedAddCommGroup.toNorm.{u2} V₁ _inst_2) x)))))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.bounds_bdd_below NormedAddGroupHom.bounds_bddBelowₓ'. -/
theorem bounds_bddBelow {f : NormedAddGroupHom V₁ V₂} :
    BddBelow { c | 0 ≤ c ∧ ∀ x, ‖f x‖ ≤ c * ‖x‖ } :=
  ⟨0, fun _ ⟨hn, _⟩ => hn⟩
#align normed_add_group_hom.bounds_bdd_below NormedAddGroupHom.bounds_bddBelow

/- warning: normed_add_group_hom.op_norm_nonneg -> NormedAddGroupHom.opNorm_nonneg is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3), LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) (Norm.norm.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u1, u2} V₁ V₂ _inst_2 _inst_3) f)
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] (f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3), LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) (Norm.norm.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u2, u1} V₁ V₂ _inst_2 _inst_3) f)
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.op_norm_nonneg NormedAddGroupHom.opNorm_nonnegₓ'. -/
theorem opNorm_nonneg : 0 ≤ ‖f‖ :=
  le_csInf bounds_nonempty fun _ ⟨hx, _⟩ => hx
#align normed_add_group_hom.op_norm_nonneg NormedAddGroupHom.opNorm_nonneg

/- warning: normed_add_group_hom.le_op_norm -> NormedAddGroupHom.le_opNorm is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (x : V₁), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} V₂ (SeminormedAddCommGroup.toHasNorm.{u2} V₂ _inst_3) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Norm.norm.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u1, u2} V₁ V₂ _inst_2 _inst_3) f) (Norm.norm.{u1} V₁ (SeminormedAddCommGroup.toHasNorm.{u1} V₁ _inst_2) x))
but is expected to have type
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (x : V₁), LE.le.{0} Real Real.instLEReal (Norm.norm.{u2} V₂ (SeminormedAddCommGroup.toNorm.{u2} V₂ _inst_3) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u1 u2, u1, u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u1} V₁ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u2} V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u1, u2} V₁ V₂ _inst_2 _inst_3))) f x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Norm.norm.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u1, u2} V₁ V₂ _inst_2 _inst_3) f) (Norm.norm.{u1} V₁ (SeminormedAddCommGroup.toNorm.{u1} V₁ _inst_2) x))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.le_op_norm NormedAddGroupHom.le_opNormₓ'. -/
/-- The fundamental property of the operator norm: `‖f x‖ ≤ ‖f‖ * ‖x‖`. -/
theorem le_opNorm (x : V₁) : ‖f x‖ ≤ ‖f‖ * ‖x‖ :=
  by
  obtain ⟨C, Cpos, hC⟩ := f.bound
  replace hC := hC x
  by_cases h : ‖x‖ = 0
  · rwa [h, MulZeroClass.mul_zero] at hC⊢
  have hlt : 0 < ‖x‖ := lt_of_le_of_ne (norm_nonneg x) (Ne.symm h)
  exact
    (div_le_iff hlt).mp
      (le_csInf bounds_nonempty fun c ⟨_, hc⟩ => (div_le_iff hlt).mpr <| by apply hc)
#align normed_add_group_hom.le_op_norm NormedAddGroupHom.le_opNorm

/- warning: normed_add_group_hom.le_op_norm_of_le -> NormedAddGroupHom.le_opNorm_of_le is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) {c : Real} {x : V₁}, (LE.le.{0} Real Real.hasLe (Norm.norm.{u1} V₁ (SeminormedAddCommGroup.toHasNorm.{u1} V₁ _inst_2) x) c) -> (LE.le.{0} Real Real.hasLe (Norm.norm.{u2} V₂ (SeminormedAddCommGroup.toHasNorm.{u2} V₂ _inst_3) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Norm.norm.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u1, u2} V₁ V₂ _inst_2 _inst_3) f) c))
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] (f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) {c : Real} {x : V₁}, (LE.le.{0} Real Real.instLEReal (Norm.norm.{u2} V₁ (SeminormedAddCommGroup.toNorm.{u2} V₁ _inst_2) x) c) -> (LE.le.{0} Real Real.instLEReal (Norm.norm.{u1} V₂ (SeminormedAddCommGroup.toNorm.{u1} V₂ _inst_3) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) f x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Norm.norm.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u2, u1} V₁ V₂ _inst_2 _inst_3) f) c))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.le_op_norm_of_le NormedAddGroupHom.le_opNorm_of_leₓ'. -/
theorem le_opNorm_of_le {c : ℝ} {x} (h : ‖x‖ ≤ c) : ‖f x‖ ≤ ‖f‖ * c :=
  le_trans (f.le_opNorm x) (mul_le_mul_of_nonneg_left h f.opNorm_nonneg)
#align normed_add_group_hom.le_op_norm_of_le NormedAddGroupHom.le_opNorm_of_le

/- warning: normed_add_group_hom.le_of_op_norm_le -> NormedAddGroupHom.le_of_opNorm_le is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) {c : Real}, (LE.le.{0} Real Real.hasLe (Norm.norm.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u1, u2} V₁ V₂ _inst_2 _inst_3) f) c) -> (forall (x : V₁), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} V₂ (SeminormedAddCommGroup.toHasNorm.{u2} V₂ _inst_3) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) c (Norm.norm.{u1} V₁ (SeminormedAddCommGroup.toHasNorm.{u1} V₁ _inst_2) x)))
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] (f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) {c : Real}, (LE.le.{0} Real Real.instLEReal (Norm.norm.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u2, u1} V₁ V₂ _inst_2 _inst_3) f) c) -> (forall (x : V₁), LE.le.{0} Real Real.instLEReal (Norm.norm.{u1} V₂ (SeminormedAddCommGroup.toNorm.{u1} V₂ _inst_3) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) f x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) c (Norm.norm.{u2} V₁ (SeminormedAddCommGroup.toNorm.{u2} V₁ _inst_2) x)))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.le_of_op_norm_le NormedAddGroupHom.le_of_opNorm_leₓ'. -/
theorem le_of_opNorm_le {c : ℝ} (h : ‖f‖ ≤ c) (x : V₁) : ‖f x‖ ≤ c * ‖x‖ :=
  (f.le_opNorm x).trans (mul_le_mul_of_nonneg_right h (norm_nonneg x))
#align normed_add_group_hom.le_of_op_norm_le NormedAddGroupHom.le_of_opNorm_le

/- warning: normed_add_group_hom.lipschitz -> NormedAddGroupHom.lipschitz is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3), LipschitzWith.{u1, u2} V₁ V₂ (PseudoMetricSpace.toPseudoEMetricSpace.{u1} V₁ (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} V₁ _inst_2)) (PseudoMetricSpace.toPseudoEMetricSpace.{u2} V₂ (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} V₂ _inst_3)) (Subtype.mk.{1} Real (fun (r : Real) => LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) r) (Norm.norm.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u1, u2} V₁ V₂ _inst_2 _inst_3) f) (NormedAddGroupHom.opNorm_nonneg.{u1, u2} V₁ V₂ _inst_2 _inst_3 f)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f)
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] (f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3), LipschitzWith.{u2, u1} V₁ V₂ (PseudoMetricSpace.toPseudoEMetricSpace.{u2} V₁ (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} V₁ _inst_2)) (PseudoMetricSpace.toPseudoEMetricSpace.{u1} V₂ (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} V₂ _inst_3)) (Subtype.mk.{1} Real (fun (r : Real) => LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) r) (Norm.norm.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u2, u1} V₁ V₂ _inst_2 _inst_3) f) (NormedAddGroupHom.opNorm_nonneg.{u1, u2} V₁ V₂ _inst_2 _inst_3 f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) f)
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.lipschitz NormedAddGroupHom.lipschitzₓ'. -/
/-- continuous linear maps are Lipschitz continuous. -/
theorem lipschitz : LipschitzWith ⟨‖f‖, opNorm_nonneg f⟩ f :=
  LipschitzWith.of_dist_le_mul fun x y => by rw [dist_eq_norm, dist_eq_norm, ← map_sub];
    apply le_op_norm
#align normed_add_group_hom.lipschitz NormedAddGroupHom.lipschitz

/- warning: normed_add_group_hom.uniform_continuous -> NormedAddGroupHom.uniformContinuous is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3), UniformContinuous.{u1, u2} V₁ V₂ (PseudoMetricSpace.toUniformSpace.{u1} V₁ (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} V₁ _inst_2)) (PseudoMetricSpace.toUniformSpace.{u2} V₂ (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} V₂ _inst_3)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f)
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] (f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3), UniformContinuous.{u2, u1} V₁ V₂ (PseudoMetricSpace.toUniformSpace.{u2} V₁ (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} V₁ _inst_2)) (PseudoMetricSpace.toUniformSpace.{u1} V₂ (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} V₂ _inst_3)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) f)
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.uniform_continuous NormedAddGroupHom.uniformContinuousₓ'. -/
protected theorem uniformContinuous (f : NormedAddGroupHom V₁ V₂) : UniformContinuous f :=
  f.lipschitz.UniformContinuous
#align normed_add_group_hom.uniform_continuous NormedAddGroupHom.uniformContinuous

/- warning: normed_add_group_hom.continuous -> NormedAddGroupHom.continuous is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3), Continuous.{u1, u2} V₁ V₂ (UniformSpace.toTopologicalSpace.{u1} V₁ (PseudoMetricSpace.toUniformSpace.{u1} V₁ (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} V₁ _inst_2))) (UniformSpace.toTopologicalSpace.{u2} V₂ (PseudoMetricSpace.toUniformSpace.{u2} V₂ (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} V₂ _inst_3))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f)
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] (f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3), Continuous.{u2, u1} V₁ V₂ (UniformSpace.toTopologicalSpace.{u2} V₁ (PseudoMetricSpace.toUniformSpace.{u2} V₁ (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} V₁ _inst_2))) (UniformSpace.toTopologicalSpace.{u1} V₂ (PseudoMetricSpace.toUniformSpace.{u1} V₂ (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} V₂ _inst_3))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) f)
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.continuous NormedAddGroupHom.continuousₓ'. -/
@[continuity]
protected theorem continuous (f : NormedAddGroupHom V₁ V₂) : Continuous f :=
  f.UniformContinuous.Continuous
#align normed_add_group_hom.continuous NormedAddGroupHom.continuous

/- warning: normed_add_group_hom.ratio_le_op_norm -> NormedAddGroupHom.ratio_le_opNorm is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (x : V₁), LE.le.{0} Real Real.hasLe (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (Norm.norm.{u2} V₂ (SeminormedAddCommGroup.toHasNorm.{u2} V₂ _inst_3) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f x)) (Norm.norm.{u1} V₁ (SeminormedAddCommGroup.toHasNorm.{u1} V₁ _inst_2) x)) (Norm.norm.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u1, u2} V₁ V₂ _inst_2 _inst_3) f)
but is expected to have type
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (x : V₁), LE.le.{0} Real Real.instLEReal (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (Norm.norm.{u2} V₂ (SeminormedAddCommGroup.toNorm.{u2} V₂ _inst_3) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u1 u2, u1, u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u1} V₁ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u2} V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u1, u2} V₁ V₂ _inst_2 _inst_3))) f x)) (Norm.norm.{u1} V₁ (SeminormedAddCommGroup.toNorm.{u1} V₁ _inst_2) x)) (Norm.norm.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u1, u2} V₁ V₂ _inst_2 _inst_3) f)
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.ratio_le_op_norm NormedAddGroupHom.ratio_le_opNormₓ'. -/
theorem ratio_le_opNorm (x : V₁) : ‖f x‖ / ‖x‖ ≤ ‖f‖ :=
  div_le_of_nonneg_of_le_mul (norm_nonneg _) f.opNorm_nonneg (le_opNorm _ _)
#align normed_add_group_hom.ratio_le_op_norm NormedAddGroupHom.ratio_le_opNorm

/- warning: normed_add_group_hom.op_norm_le_bound -> NormedAddGroupHom.opNorm_le_bound is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) {M : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) M) -> (forall (x : V₁), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} V₂ (SeminormedAddCommGroup.toHasNorm.{u2} V₂ _inst_3) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) M (Norm.norm.{u1} V₁ (SeminormedAddCommGroup.toHasNorm.{u1} V₁ _inst_2) x))) -> (LE.le.{0} Real Real.hasLe (Norm.norm.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u1, u2} V₁ V₂ _inst_2 _inst_3) f) M)
but is expected to have type
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) {M : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) M) -> (forall (x : V₁), LE.le.{0} Real Real.instLEReal (Norm.norm.{u2} V₂ (SeminormedAddCommGroup.toNorm.{u2} V₂ _inst_3) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u1 u2, u1, u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u1} V₁ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u2} V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u1, u2} V₁ V₂ _inst_2 _inst_3))) f x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) M (Norm.norm.{u1} V₁ (SeminormedAddCommGroup.toNorm.{u1} V₁ _inst_2) x))) -> (LE.le.{0} Real Real.instLEReal (Norm.norm.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u1, u2} V₁ V₂ _inst_2 _inst_3) f) M)
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.op_norm_le_bound NormedAddGroupHom.opNorm_le_boundₓ'. -/
/-- If one controls the norm of every `f x`, then one controls the norm of `f`. -/
theorem opNorm_le_bound {M : ℝ} (hMp : 0 ≤ M) (hM : ∀ x, ‖f x‖ ≤ M * ‖x‖) : ‖f‖ ≤ M :=
  csInf_le bounds_bddBelow ⟨hMp, hM⟩
#align normed_add_group_hom.op_norm_le_bound NormedAddGroupHom.opNorm_le_bound

/- warning: normed_add_group_hom.op_norm_eq_of_bounds -> NormedAddGroupHom.opNorm_eq_of_bounds is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) {M : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) M) -> (forall (x : V₁), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} V₂ (SeminormedAddCommGroup.toHasNorm.{u2} V₂ _inst_3) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) M (Norm.norm.{u1} V₁ (SeminormedAddCommGroup.toHasNorm.{u1} V₁ _inst_2) x))) -> (forall (N : Real), (GE.ge.{0} Real Real.hasLe N (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) -> (forall (x : V₁), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} V₂ (SeminormedAddCommGroup.toHasNorm.{u2} V₂ _inst_3) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) N (Norm.norm.{u1} V₁ (SeminormedAddCommGroup.toHasNorm.{u1} V₁ _inst_2) x))) -> (LE.le.{0} Real Real.hasLe M N)) -> (Eq.{1} Real (Norm.norm.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u1, u2} V₁ V₂ _inst_2 _inst_3) f) M)
but is expected to have type
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) {M : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) M) -> (forall (x : V₁), LE.le.{0} Real Real.instLEReal (Norm.norm.{u2} V₂ (SeminormedAddCommGroup.toNorm.{u2} V₂ _inst_3) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u1 u2, u1, u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u1} V₁ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u2} V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u1, u2} V₁ V₂ _inst_2 _inst_3))) f x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) M (Norm.norm.{u1} V₁ (SeminormedAddCommGroup.toNorm.{u1} V₁ _inst_2) x))) -> (forall (N : Real), (GE.ge.{0} Real Real.instLEReal N (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) -> (forall (x : V₁), LE.le.{0} Real Real.instLEReal (Norm.norm.{u2} V₂ (SeminormedAddCommGroup.toNorm.{u2} V₂ _inst_3) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u1 u2, u1, u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u1} V₁ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u2} V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u1, u2} V₁ V₂ _inst_2 _inst_3))) f x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) N (Norm.norm.{u1} V₁ (SeminormedAddCommGroup.toNorm.{u1} V₁ _inst_2) x))) -> (LE.le.{0} Real Real.instLEReal M N)) -> (Eq.{1} Real (Norm.norm.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u1, u2} V₁ V₂ _inst_2 _inst_3) f) M)
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.op_norm_eq_of_bounds NormedAddGroupHom.opNorm_eq_of_boundsₓ'. -/
theorem opNorm_eq_of_bounds {M : ℝ} (M_nonneg : 0 ≤ M) (h_above : ∀ x, ‖f x‖ ≤ M * ‖x‖)
    (h_below : ∀ N ≥ 0, (∀ x, ‖f x‖ ≤ N * ‖x‖) → M ≤ N) : ‖f‖ = M :=
  le_antisymm (f.opNorm_le_bound M_nonneg h_above)
    ((le_csInf_iff NormedAddGroupHom.bounds_bddBelow ⟨M, M_nonneg, h_above⟩).mpr
      fun N ⟨N_nonneg, hN⟩ => h_below N N_nonneg hN)
#align normed_add_group_hom.op_norm_eq_of_bounds NormedAddGroupHom.opNorm_eq_of_bounds

/- warning: normed_add_group_hom.op_norm_le_of_lipschitz -> NormedAddGroupHom.opNorm_le_of_lipschitz is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] {f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3} {K : NNReal}, (LipschitzWith.{u1, u2} V₁ V₂ (PseudoMetricSpace.toPseudoEMetricSpace.{u1} V₁ (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} V₁ _inst_2)) (PseudoMetricSpace.toPseudoEMetricSpace.{u2} V₂ (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} V₂ _inst_3)) K (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f)) -> (LE.le.{0} Real Real.hasLe (Norm.norm.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u1, u2} V₁ V₂ _inst_2 _inst_3) f) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) NNReal Real (HasLiftT.mk.{1, 1} NNReal Real (CoeTCₓ.coe.{1, 1} NNReal Real (coeBase.{1, 1} NNReal Real NNReal.Real.hasCoe))) K))
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] {f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3} {K : NNReal}, (LipschitzWith.{u2, u1} V₁ V₂ (PseudoMetricSpace.toPseudoEMetricSpace.{u2} V₁ (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} V₁ _inst_2)) (PseudoMetricSpace.toPseudoEMetricSpace.{u1} V₂ (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} V₂ _inst_3)) K (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) f)) -> (LE.le.{0} Real Real.instLEReal (Norm.norm.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u2, u1} V₁ V₂ _inst_2 _inst_3) f) (NNReal.toReal K))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.op_norm_le_of_lipschitz NormedAddGroupHom.opNorm_le_of_lipschitzₓ'. -/
theorem opNorm_le_of_lipschitz {f : NormedAddGroupHom V₁ V₂} {K : ℝ≥0} (hf : LipschitzWith K f) :
    ‖f‖ ≤ K :=
  f.opNorm_le_bound K.2 fun x => by simpa only [dist_zero_right, map_zero] using hf.dist_le_mul x 0
#align normed_add_group_hom.op_norm_le_of_lipschitz NormedAddGroupHom.opNorm_le_of_lipschitz

/- warning: normed_add_group_hom.mk_normed_add_group_hom_norm_le -> NormedAddGroupHom.mkNormedAddGroupHom_norm_le is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : AddMonoidHom.{u1, u2} V₁ V₂ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) {C : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) C) -> (forall (h : forall (x : V₁), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} V₂ (SeminormedAddCommGroup.toHasNorm.{u2} V₂ _inst_3) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} V₁ V₂ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) (fun (_x : AddMonoidHom.{u1, u2} V₁ V₂ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) => V₁ -> V₂) (AddMonoidHom.hasCoeToFun.{u1, u2} V₁ V₂ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) f x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) C (Norm.norm.{u1} V₁ (SeminormedAddCommGroup.toHasNorm.{u1} V₁ _inst_2) x))), LE.le.{0} Real Real.hasLe (Norm.norm.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u1, u2} V₁ V₂ _inst_2 _inst_3) (AddMonoidHom.mkNormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3 f C h)) C)
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] (f : AddMonoidHom.{u2, u1} V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) {C : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) C) -> (forall (h : forall (x : V₁), LE.le.{0} Real Real.instLEReal (Norm.norm.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : V₁) => V₂) x) (SeminormedAddCommGroup.toNorm.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : V₁) => V₂) x) _inst_3) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AddMonoidHom.{u2, u1} V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) V₁ (fun (_x : V₁) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : V₁) => V₂) _x) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (AddMonoidHom.addMonoidHomClass.{u2, u1} V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))))) f x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) C (Norm.norm.{u2} V₁ (SeminormedAddCommGroup.toNorm.{u2} V₁ _inst_2) x))), LE.le.{0} Real Real.instLEReal (Norm.norm.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u2, u1} V₁ V₂ _inst_2 _inst_3) (AddMonoidHom.mkNormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3 f C h)) C)
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.mk_normed_add_group_hom_norm_le NormedAddGroupHom.mkNormedAddGroupHom_norm_leₓ'. -/
/-- If a bounded group homomorphism map is constructed from a group homomorphism via the constructor
`mk_normed_add_group_hom`, then its norm is bounded by the bound given to the constructor if it is
nonnegative. -/
theorem mkNormedAddGroupHom_norm_le (f : V₁ →+ V₂) {C : ℝ} (hC : 0 ≤ C) (h : ∀ x, ‖f x‖ ≤ C * ‖x‖) :
    ‖f.mkNormedAddGroupHom C h‖ ≤ C :=
  opNorm_le_bound _ hC h
#align normed_add_group_hom.mk_normed_add_group_hom_norm_le NormedAddGroupHom.mkNormedAddGroupHom_norm_le

/- warning: normed_add_group_hom.mk_normed_add_group_hom_norm_le' -> NormedAddGroupHom.mkNormedAddGroupHom_norm_le' is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : AddMonoidHom.{u1, u2} V₁ V₂ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) {C : Real} (h : forall (x : V₁), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} V₂ (SeminormedAddCommGroup.toHasNorm.{u2} V₂ _inst_3) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} V₁ V₂ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) (fun (_x : AddMonoidHom.{u1, u2} V₁ V₂ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) => V₁ -> V₂) (AddMonoidHom.hasCoeToFun.{u1, u2} V₁ V₂ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) f x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) C (Norm.norm.{u1} V₁ (SeminormedAddCommGroup.toHasNorm.{u1} V₁ _inst_2) x))), LE.le.{0} Real Real.hasLe (Norm.norm.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u1, u2} V₁ V₂ _inst_2 _inst_3) (AddMonoidHom.mkNormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3 f C h)) (LinearOrder.max.{0} Real Real.linearOrder C (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] (f : AddMonoidHom.{u2, u1} V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) {C : Real} (h : forall (x : V₁), LE.le.{0} Real Real.instLEReal (Norm.norm.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : V₁) => V₂) x) (SeminormedAddCommGroup.toNorm.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : V₁) => V₂) x) _inst_3) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AddMonoidHom.{u2, u1} V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) V₁ (fun (_x : V₁) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : V₁) => V₂) _x) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (AddMonoidHom.addMonoidHomClass.{u2, u1} V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))))) f x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) C (Norm.norm.{u2} V₁ (SeminormedAddCommGroup.toNorm.{u2} V₁ _inst_2) x))), LE.le.{0} Real Real.instLEReal (Norm.norm.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u2, u1} V₁ V₂ _inst_2 _inst_3) (AddMonoidHom.mkNormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3 f C h)) (Max.max.{0} Real (LinearOrderedRing.toMax.{0} Real Real.instLinearOrderedRingReal) C (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.mk_normed_add_group_hom_norm_le' NormedAddGroupHom.mkNormedAddGroupHom_norm_le'ₓ'. -/
/-- If a bounded group homomorphism map is constructed from a group homomorphism
via the constructor `mk_normed_add_group_hom`, then its norm is bounded by the bound
given to the constructor or zero if this bound is negative. -/
theorem mkNormedAddGroupHom_norm_le' (f : V₁ →+ V₂) {C : ℝ} (h : ∀ x, ‖f x‖ ≤ C * ‖x‖) :
    ‖f.mkNormedAddGroupHom C h‖ ≤ max C 0 :=
  opNorm_le_bound _ (le_max_right _ _) fun x =>
    (h x).trans <| mul_le_mul_of_nonneg_right (le_max_left _ _) (norm_nonneg x)
#align normed_add_group_hom.mk_normed_add_group_hom_norm_le' NormedAddGroupHom.mkNormedAddGroupHom_norm_le'

/- warning: add_monoid_hom.mk_normed_add_group_hom_norm_le -> AddMonoidHom.mkNormedAddGroupHom_norm_le is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : AddMonoidHom.{u1, u2} V₁ V₂ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) {C : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) C) -> (forall (h : forall (x : V₁), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} V₂ (SeminormedAddCommGroup.toHasNorm.{u2} V₂ _inst_3) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} V₁ V₂ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) (fun (_x : AddMonoidHom.{u1, u2} V₁ V₂ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) => V₁ -> V₂) (AddMonoidHom.hasCoeToFun.{u1, u2} V₁ V₂ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) f x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) C (Norm.norm.{u1} V₁ (SeminormedAddCommGroup.toHasNorm.{u1} V₁ _inst_2) x))), LE.le.{0} Real Real.hasLe (Norm.norm.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u1, u2} V₁ V₂ _inst_2 _inst_3) (AddMonoidHom.mkNormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3 f C h)) C)
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] (f : AddMonoidHom.{u2, u1} V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) {C : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) C) -> (forall (h : forall (x : V₁), LE.le.{0} Real Real.instLEReal (Norm.norm.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : V₁) => V₂) x) (SeminormedAddCommGroup.toNorm.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : V₁) => V₂) x) _inst_3) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AddMonoidHom.{u2, u1} V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) V₁ (fun (_x : V₁) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : V₁) => V₂) _x) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (AddMonoidHom.addMonoidHomClass.{u2, u1} V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))))) f x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) C (Norm.norm.{u2} V₁ (SeminormedAddCommGroup.toNorm.{u2} V₁ _inst_2) x))), LE.le.{0} Real Real.instLEReal (Norm.norm.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u2, u1} V₁ V₂ _inst_2 _inst_3) (AddMonoidHom.mkNormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3 f C h)) C)
Case conversion may be inaccurate. Consider using '#align add_monoid_hom.mk_normed_add_group_hom_norm_le AddMonoidHom.mkNormedAddGroupHom_norm_leₓ'. -/
alias mk_normed_add_group_hom_norm_le ← _root_.add_monoid_hom.mk_normed_add_group_hom_norm_le
#align add_monoid_hom.mk_normed_add_group_hom_norm_le AddMonoidHom.mkNormedAddGroupHom_norm_le

/- warning: add_monoid_hom.mk_normed_add_group_hom_norm_le' -> AddMonoidHom.mkNormedAddGroupHom_norm_le' is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : AddMonoidHom.{u1, u2} V₁ V₂ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) {C : Real} (h : forall (x : V₁), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} V₂ (SeminormedAddCommGroup.toHasNorm.{u2} V₂ _inst_3) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} V₁ V₂ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) (fun (_x : AddMonoidHom.{u1, u2} V₁ V₂ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) => V₁ -> V₂) (AddMonoidHom.hasCoeToFun.{u1, u2} V₁ V₂ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) f x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) C (Norm.norm.{u1} V₁ (SeminormedAddCommGroup.toHasNorm.{u1} V₁ _inst_2) x))), LE.le.{0} Real Real.hasLe (Norm.norm.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u1, u2} V₁ V₂ _inst_2 _inst_3) (AddMonoidHom.mkNormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3 f C h)) (LinearOrder.max.{0} Real Real.linearOrder C (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] (f : AddMonoidHom.{u2, u1} V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) {C : Real} (h : forall (x : V₁), LE.le.{0} Real Real.instLEReal (Norm.norm.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : V₁) => V₂) x) (SeminormedAddCommGroup.toNorm.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : V₁) => V₂) x) _inst_3) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AddMonoidHom.{u2, u1} V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) V₁ (fun (_x : V₁) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : V₁) => V₂) _x) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (AddMonoidHom.addMonoidHomClass.{u2, u1} V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))))) f x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) C (Norm.norm.{u2} V₁ (SeminormedAddCommGroup.toNorm.{u2} V₁ _inst_2) x))), LE.le.{0} Real Real.instLEReal (Norm.norm.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u2, u1} V₁ V₂ _inst_2 _inst_3) (AddMonoidHom.mkNormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3 f C h)) (Max.max.{0} Real (LinearOrderedRing.toMax.{0} Real Real.instLinearOrderedRingReal) C (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))
Case conversion may be inaccurate. Consider using '#align add_monoid_hom.mk_normed_add_group_hom_norm_le' AddMonoidHom.mkNormedAddGroupHom_norm_le'ₓ'. -/
alias mk_normed_add_group_hom_norm_le' ← _root_.add_monoid_hom.mk_normed_add_group_hom_norm_le'
#align add_monoid_hom.mk_normed_add_group_hom_norm_le' AddMonoidHom.mkNormedAddGroupHom_norm_le'

/-! ### Addition of normed group homs -/


/-- Addition of normed group homs. -/
instance : Add (NormedAddGroupHom V₁ V₂) :=
  ⟨fun f g =>
    (f.toAddMonoidHom + g.toAddMonoidHom).mkNormedAddGroupHom (‖f‖ + ‖g‖) fun v =>
      calc
        ‖f v + g v‖ ≤ ‖f v‖ + ‖g v‖ := norm_add_le _ _
        _ ≤ ‖f‖ * ‖v‖ + ‖g‖ * ‖v‖ := (add_le_add (le_opNorm f v) (le_opNorm g v))
        _ = (‖f‖ + ‖g‖) * ‖v‖ := by rw [add_mul]
        ⟩

/- warning: normed_add_group_hom.op_norm_add_le -> NormedAddGroupHom.opNorm_add_le is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (g : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3), LE.le.{0} Real Real.hasLe (Norm.norm.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u1, u2} V₁ V₂ _inst_2 _inst_3) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (instHAdd.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasAdd.{u1, u2} V₁ V₂ _inst_2 _inst_3)) f g)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (Norm.norm.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u1, u2} V₁ V₂ _inst_2 _inst_3) f) (Norm.norm.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u1, u2} V₁ V₂ _inst_2 _inst_3) g))
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] (f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (g : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3), LE.le.{0} Real Real.instLEReal (Norm.norm.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u2, u1} V₁ V₂ _inst_2 _inst_3) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (instHAdd.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.add.{u2, u1} V₁ V₂ _inst_2 _inst_3)) f g)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (Norm.norm.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u2, u1} V₁ V₂ _inst_2 _inst_3) f) (Norm.norm.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u2, u1} V₁ V₂ _inst_2 _inst_3) g))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.op_norm_add_le NormedAddGroupHom.opNorm_add_leₓ'. -/
/-- The operator norm satisfies the triangle inequality. -/
theorem opNorm_add_le : ‖f + g‖ ≤ ‖f‖ + ‖g‖ :=
  mkNormedAddGroupHom_norm_le _ (add_nonneg (opNorm_nonneg _) (opNorm_nonneg _)) _
#align normed_add_group_hom.op_norm_add_le NormedAddGroupHom.opNorm_add_le

library_note "addition on function coercions"/--
Terms containing `@has_add.add (has_coe_to_fun.F ...) pi.has_add`
seem to cause leanchecker to [crash due to an out-of-memory
condition](https://github.com/leanprover-community/lean/issues/543).
As a workaround, we add a type annotation: `(f + g : V₁ → V₂)`
-/


/- warning: normed_add_group_hom.coe_add -> NormedAddGroupHom.coe_add is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (g : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3), Eq.{max (succ u1) (succ u2)} (V₁ -> V₂) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (instHAdd.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasAdd.{u1, u2} V₁ V₂ _inst_2 _inst_3)) f g)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (V₁ -> V₂) (V₁ -> V₂) (V₁ -> V₂) (instHAdd.{max u1 u2} (V₁ -> V₂) (Pi.instAdd.{u1, u2} V₁ (fun (ᾰ : V₁) => V₂) (fun (i : V₁) => AddZeroClass.toHasAdd.{u2} V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) g))
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] (f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (g : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3), Eq.{max (succ u2) (succ u1)} (V₁ -> V₂) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (instHAdd.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.add.{u2, u1} V₁ V₂ _inst_2 _inst_3)) f g)) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (V₁ -> V₂) (V₁ -> V₂) (V₁ -> V₂) (instHAdd.{max u2 u1} (V₁ -> V₂) (Pi.instAdd.{u2, u1} V₁ (fun (ᾰ : V₁) => V₂) (fun (i : V₁) => AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) f) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) g))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.coe_add NormedAddGroupHom.coe_addₓ'. -/
-- see Note [addition on function coercions]
@[simp]
theorem coe_add (f g : NormedAddGroupHom V₁ V₂) : ⇑(f + g) = (f + g : V₁ → V₂) :=
  rfl
#align normed_add_group_hom.coe_add NormedAddGroupHom.coe_add

/- warning: normed_add_group_hom.add_apply -> NormedAddGroupHom.add_apply is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (g : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (v : V₁), Eq.{succ u2} V₂ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (instHAdd.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasAdd.{u1, u2} V₁ V₂ _inst_2 _inst_3)) f g) v) (HAdd.hAdd.{u2, u2, u2} V₂ V₂ V₂ (instHAdd.{u2} V₂ (AddZeroClass.toHasAdd.{u2} V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f v) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) g v))
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] (f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (g : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (v : V₁), Eq.{succ u1} V₂ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (instHAdd.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.add.{u2, u1} V₁ V₂ _inst_2 _inst_3)) f g) v) (HAdd.hAdd.{u1, u1, u1} V₂ V₂ V₂ (instHAdd.{u1} V₂ (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) f v) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) g v))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.add_apply NormedAddGroupHom.add_applyₓ'. -/
@[simp]
theorem add_apply (f g : NormedAddGroupHom V₁ V₂) (v : V₁) :
    (f + g : NormedAddGroupHom V₁ V₂) v = f v + g v :=
  rfl
#align normed_add_group_hom.add_apply NormedAddGroupHom.add_apply

/-! ### The zero normed group hom -/


instance : Zero (NormedAddGroupHom V₁ V₂) :=
  ⟨(0 : V₁ →+ V₂).mkNormedAddGroupHom 0 (by simp)⟩

instance : Inhabited (NormedAddGroupHom V₁ V₂) :=
  ⟨0⟩

/- warning: normed_add_group_hom.op_norm_zero -> NormedAddGroupHom.opNorm_zero is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂], Eq.{1} Real (Norm.norm.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u1, u2} V₁ V₂ _inst_2 _inst_3) (OfNat.ofNat.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) 0 (OfNat.mk.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) 0 (Zero.zero.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasZero.{u1, u2} V₁ V₂ _inst_2 _inst_3))))) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂], Eq.{1} Real (Norm.norm.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u2, u1} V₁ V₂ _inst_2 _inst_3) (OfNat.ofNat.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) 0 (Zero.toOfNat0.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.zero.{u2, u1} V₁ V₂ _inst_2 _inst_3)))) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.op_norm_zero NormedAddGroupHom.opNorm_zeroₓ'. -/
/-- The norm of the `0` operator is `0`. -/
theorem opNorm_zero : ‖(0 : NormedAddGroupHom V₁ V₂)‖ = 0 :=
  le_antisymm
    (csInf_le bounds_bddBelow
      ⟨ge_of_eq rfl, fun _ => le_of_eq (by rw [MulZeroClass.zero_mul]; exact norm_zero)⟩)
    (opNorm_nonneg _)
#align normed_add_group_hom.op_norm_zero NormedAddGroupHom.opNorm_zero

/- warning: normed_add_group_hom.op_norm_zero_iff -> NormedAddGroupHom.opNorm_zero_iff is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_5 : NormedAddCommGroup.{u1} V₁] [_inst_6 : NormedAddCommGroup.{u2} V₂] {f : NormedAddGroupHom.{u1, u2} V₁ V₂ (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} V₁ _inst_5) (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} V₂ _inst_6)}, Iff (Eq.{1} Real (Norm.norm.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} V₁ _inst_5) (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} V₂ _inst_6)) (NormedAddGroupHom.hasOpNorm.{u1, u2} V₁ V₂ (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} V₁ _inst_5) (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} V₂ _inst_6)) f) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) (Eq.{max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} V₁ _inst_5) (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} V₂ _inst_6)) f (OfNat.ofNat.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} V₁ _inst_5) (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} V₂ _inst_6)) 0 (OfNat.mk.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} V₁ _inst_5) (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} V₂ _inst_6)) 0 (Zero.zero.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} V₁ _inst_5) (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} V₂ _inst_6)) (NormedAddGroupHom.hasZero.{u1, u2} V₁ V₂ (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} V₁ _inst_5) (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} V₂ _inst_6))))))
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_5 : NormedAddCommGroup.{u2} V₁] [_inst_6 : NormedAddCommGroup.{u1} V₂] {f : NormedAddGroupHom.{u2, u1} V₁ V₂ (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} V₁ _inst_5) (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} V₂ _inst_6)}, Iff (Eq.{1} Real (Norm.norm.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} V₁ _inst_5) (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} V₂ _inst_6)) (NormedAddGroupHom.hasOpNorm.{u2, u1} V₁ V₂ (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} V₁ _inst_5) (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} V₂ _inst_6)) f) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (Eq.{max (succ u2) (succ u1)} (NormedAddGroupHom.{u2, u1} V₁ V₂ (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} V₁ _inst_5) (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} V₂ _inst_6)) f (OfNat.ofNat.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} V₁ _inst_5) (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} V₂ _inst_6)) 0 (Zero.toOfNat0.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} V₁ _inst_5) (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} V₂ _inst_6)) (NormedAddGroupHom.zero.{u2, u1} V₁ V₂ (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} V₁ _inst_5) (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} V₂ _inst_6)))))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.op_norm_zero_iff NormedAddGroupHom.opNorm_zero_iffₓ'. -/
/-- For normed groups, an operator is zero iff its norm vanishes. -/
theorem opNorm_zero_iff {V₁ V₂ : Type _} [NormedAddCommGroup V₁] [NormedAddCommGroup V₂]
    {f : NormedAddGroupHom V₁ V₂} : ‖f‖ = 0 ↔ f = 0 :=
  Iff.intro
    (fun hn =>
      ext fun x =>
        norm_le_zero_iff.1
          (calc
            _ ≤ ‖f‖ * ‖x‖ := le_opNorm _ _
            _ = _ := by rw [hn, MulZeroClass.zero_mul]
            ))
    fun hf => by rw [hf, op_norm_zero]
#align normed_add_group_hom.op_norm_zero_iff NormedAddGroupHom.opNorm_zero_iff

/- warning: normed_add_group_hom.coe_zero -> NormedAddGroupHom.coe_zero is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂], Eq.{max (succ u1) (succ u2)} (V₁ -> V₂) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) (OfNat.ofNat.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) 0 (OfNat.mk.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) 0 (Zero.zero.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasZero.{u1, u2} V₁ V₂ _inst_2 _inst_3))))) (OfNat.ofNat.{max u1 u2} (V₁ -> V₂) 0 (OfNat.mk.{max u1 u2} (V₁ -> V₂) 0 (Zero.zero.{max u1 u2} (V₁ -> V₂) (Pi.instZero.{u1, u2} V₁ (fun (ᾰ : V₁) => V₂) (fun (i : V₁) => AddZeroClass.toHasZero.{u2} V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))))))))
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂], Eq.{max (succ u2) (succ u1)} (V₁ -> V₂) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) (OfNat.ofNat.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) 0 (Zero.toOfNat0.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.zero.{u2, u1} V₁ V₂ _inst_2 _inst_3)))) (OfNat.ofNat.{max u2 u1} (V₁ -> V₂) 0 (Zero.toOfNat0.{max u2 u1} (V₁ -> V₂) (Pi.instZero.{u2, u1} V₁ (fun (a : V₁) => V₂) (fun (i : V₁) => NegZeroClass.toZero.{u1} V₂ (SubNegZeroMonoid.toNegZeroClass.{u1} V₂ (SubtractionMonoid.toSubNegZeroMonoid.{u1} V₂ (SubtractionCommMonoid.toSubtractionMonoid.{u1} V₂ (AddCommGroup.toDivisionAddCommMonoid.{u1} V₂ (SeminormedAddCommGroup.toAddCommGroup.{u1} V₂ _inst_3)))))))))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.coe_zero NormedAddGroupHom.coe_zeroₓ'. -/
-- see Note [addition on function coercions]
@[simp]
theorem coe_zero : ⇑(0 : NormedAddGroupHom V₁ V₂) = (0 : V₁ → V₂) :=
  rfl
#align normed_add_group_hom.coe_zero NormedAddGroupHom.coe_zero

/- warning: normed_add_group_hom.zero_apply -> NormedAddGroupHom.zero_apply is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (v : V₁), Eq.{succ u2} V₂ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) (OfNat.ofNat.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) 0 (OfNat.mk.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) 0 (Zero.zero.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasZero.{u1, u2} V₁ V₂ _inst_2 _inst_3)))) v) (OfNat.ofNat.{u2} V₂ 0 (OfNat.mk.{u2} V₂ 0 (Zero.zero.{u2} V₂ (AddZeroClass.toHasZero.{u2} V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))))))
but is expected to have type
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (v : V₁), Eq.{succ u2} V₂ (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u1 u2, u1, u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u1} V₁ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u2} V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u1, u2} V₁ V₂ _inst_2 _inst_3))) (OfNat.ofNat.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) 0 (Zero.toOfNat0.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.zero.{u1, u2} V₁ V₂ _inst_2 _inst_3))) v) (OfNat.ofNat.{u2} V₂ 0 (Zero.toOfNat0.{u2} V₂ (NegZeroClass.toZero.{u2} V₂ (SubNegZeroMonoid.toNegZeroClass.{u2} V₂ (SubtractionMonoid.toSubNegZeroMonoid.{u2} V₂ (SubtractionCommMonoid.toSubtractionMonoid.{u2} V₂ (AddCommGroup.toDivisionAddCommMonoid.{u2} V₂ (SeminormedAddCommGroup.toAddCommGroup.{u2} V₂ _inst_3))))))))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.zero_apply NormedAddGroupHom.zero_applyₓ'. -/
@[simp]
theorem zero_apply (v : V₁) : (0 : NormedAddGroupHom V₁ V₂) v = 0 :=
  rfl
#align normed_add_group_hom.zero_apply NormedAddGroupHom.zero_apply

variable {f g}

/-! ### The identity normed group hom -/


variable (V)

#print NormedAddGroupHom.id /-
/-- The identity as a continuous normed group hom. -/
@[simps]
def id : NormedAddGroupHom V V :=
  (AddMonoidHom.id V).mkNormedAddGroupHom 1 (by simp [le_refl])
#align normed_add_group_hom.id NormedAddGroupHom.id
-/

/- warning: normed_add_group_hom.norm_id_le -> NormedAddGroupHom.norm_id_le is a dubious translation:
lean 3 declaration is
  forall (V : Type.{u1}) [_inst_1 : SeminormedAddCommGroup.{u1} V], LE.le.{0} Real Real.hasLe (Norm.norm.{u1} (NormedAddGroupHom.{u1, u1} V V _inst_1 _inst_1) (NormedAddGroupHom.hasOpNorm.{u1, u1} V V _inst_1 _inst_1) (NormedAddGroupHom.id.{u1} V _inst_1)) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))
but is expected to have type
  forall (V : Type.{u1}) [_inst_1 : SeminormedAddCommGroup.{u1} V], LE.le.{0} Real Real.instLEReal (Norm.norm.{u1} (NormedAddGroupHom.{u1, u1} V V _inst_1 _inst_1) (NormedAddGroupHom.hasOpNorm.{u1, u1} V V _inst_1 _inst_1) (NormedAddGroupHom.id.{u1} V _inst_1)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.norm_id_le NormedAddGroupHom.norm_id_leₓ'. -/
/-- The norm of the identity is at most `1`. It is in fact `1`, except when the norm of every
element vanishes, where it is `0`. (Since we are working with seminorms this can happen even if the
space is non-trivial.) It means that one can not do better than an inequality in general. -/
theorem norm_id_le : ‖(id V : NormedAddGroupHom V V)‖ ≤ 1 :=
  opNorm_le_bound _ zero_le_one fun x => by simp
#align normed_add_group_hom.norm_id_le NormedAddGroupHom.norm_id_le

/- warning: normed_add_group_hom.norm_id_of_nontrivial_seminorm -> NormedAddGroupHom.norm_id_of_nontrivial_seminorm is a dubious translation:
lean 3 declaration is
  forall (V : Type.{u1}) [_inst_1 : SeminormedAddCommGroup.{u1} V], (Exists.{succ u1} V (fun (x : V) => Ne.{1} Real (Norm.norm.{u1} V (SeminormedAddCommGroup.toHasNorm.{u1} V _inst_1) x) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))) -> (Eq.{1} Real (Norm.norm.{u1} (NormedAddGroupHom.{u1, u1} V V _inst_1 _inst_1) (NormedAddGroupHom.hasOpNorm.{u1, u1} V V _inst_1 _inst_1) (NormedAddGroupHom.id.{u1} V _inst_1)) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))
but is expected to have type
  forall (V : Type.{u1}) [_inst_1 : SeminormedAddCommGroup.{u1} V], (Exists.{succ u1} V (fun (x : V) => Ne.{1} Real (Norm.norm.{u1} V (SeminormedAddCommGroup.toNorm.{u1} V _inst_1) x) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))) -> (Eq.{1} Real (Norm.norm.{u1} (NormedAddGroupHom.{u1, u1} V V _inst_1 _inst_1) (NormedAddGroupHom.hasOpNorm.{u1, u1} V V _inst_1 _inst_1) (NormedAddGroupHom.id.{u1} V _inst_1)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.norm_id_of_nontrivial_seminorm NormedAddGroupHom.norm_id_of_nontrivial_seminormₓ'. -/
/-- If there is an element with norm different from `0`, then the norm of the identity equals `1`.
(Since we are working with seminorms supposing that the space is non-trivial is not enough.) -/
theorem norm_id_of_nontrivial_seminorm (h : ∃ x : V, ‖x‖ ≠ 0) : ‖id V‖ = 1 :=
  le_antisymm (norm_id_le V) <| by
    let ⟨x, hx⟩ := h
    have := (id V).ratio_le_opNorm x
    rwa [id_apply, div_self hx] at this
#align normed_add_group_hom.norm_id_of_nontrivial_seminorm NormedAddGroupHom.norm_id_of_nontrivial_seminorm

/- warning: normed_add_group_hom.norm_id -> NormedAddGroupHom.norm_id is a dubious translation:
lean 3 declaration is
  forall {V : Type.{u1}} [_inst_5 : NormedAddCommGroup.{u1} V] [_inst_6 : Nontrivial.{u1} V], Eq.{1} Real (Norm.norm.{u1} (NormedAddGroupHom.{u1, u1} V V (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} V _inst_5) (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} V _inst_5)) (NormedAddGroupHom.hasOpNorm.{u1, u1} V V (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} V _inst_5) (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} V _inst_5)) (NormedAddGroupHom.id.{u1} V (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} V _inst_5))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))
but is expected to have type
  forall {V : Type.{u1}} [_inst_5 : NormedAddCommGroup.{u1} V] [_inst_6 : Nontrivial.{u1} V], Eq.{1} Real (Norm.norm.{u1} (NormedAddGroupHom.{u1, u1} V V (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} V _inst_5) (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} V _inst_5)) (NormedAddGroupHom.hasOpNorm.{u1, u1} V V (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} V _inst_5) (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} V _inst_5)) (NormedAddGroupHom.id.{u1} V (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} V _inst_5))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.norm_id NormedAddGroupHom.norm_idₓ'. -/
/-- If a normed space is non-trivial, then the norm of the identity equals `1`. -/
theorem norm_id {V : Type _} [NormedAddCommGroup V] [Nontrivial V] : ‖id V‖ = 1 :=
  by
  refine' norm_id_of_nontrivial_seminorm V _
  obtain ⟨x, hx⟩ := exists_ne (0 : V)
  exact ⟨x, ne_of_gt (norm_pos_iff.2 hx)⟩
#align normed_add_group_hom.norm_id NormedAddGroupHom.norm_id

#print NormedAddGroupHom.coe_id /-
theorem coe_id : (NormedAddGroupHom.id V : V → V) = (id : V → V) :=
  rfl
#align normed_add_group_hom.coe_id NormedAddGroupHom.coe_id
-/

/-! ### The negation of a normed group hom -/


/-- Opposite of a normed group hom. -/
instance : Neg (NormedAddGroupHom V₁ V₂) :=
  ⟨fun f => (-f.toAddMonoidHom).mkNormedAddGroupHom ‖f‖ fun v => by simp [le_op_norm f v]⟩

/- warning: normed_add_group_hom.coe_neg -> NormedAddGroupHom.coe_neg is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3), Eq.{max (succ u1) (succ u2)} (V₁ -> V₂) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) (Neg.neg.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasNeg.{u1, u2} V₁ V₂ _inst_2 _inst_3) f)) (Neg.neg.{max u1 u2} (V₁ -> V₂) (Pi.instNeg.{u1, u2} V₁ (fun (ᾰ : V₁) => V₂) (fun (i : V₁) => SubNegMonoid.toHasNeg.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f))
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] (f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3), Eq.{max (succ u2) (succ u1)} (V₁ -> V₂) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) (Neg.neg.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.neg.{u2, u1} V₁ V₂ _inst_2 _inst_3) f)) (Neg.neg.{max u2 u1} (V₁ -> V₂) (Pi.instNeg.{u2, u1} V₁ (fun (ᾰ : V₁) => V₂) (fun (i : V₁) => NegZeroClass.toNeg.{u1} V₂ (SubNegZeroMonoid.toNegZeroClass.{u1} V₂ (SubtractionMonoid.toSubNegZeroMonoid.{u1} V₂ (SubtractionCommMonoid.toSubtractionMonoid.{u1} V₂ (AddCommGroup.toDivisionAddCommMonoid.{u1} V₂ (SeminormedAddCommGroup.toAddCommGroup.{u1} V₂ _inst_3))))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) f))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.coe_neg NormedAddGroupHom.coe_negₓ'. -/
-- see Note [addition on function coercions]
@[simp]
theorem coe_neg (f : NormedAddGroupHom V₁ V₂) : ⇑(-f) = (-f : V₁ → V₂) :=
  rfl
#align normed_add_group_hom.coe_neg NormedAddGroupHom.coe_neg

/- warning: normed_add_group_hom.neg_apply -> NormedAddGroupHom.neg_apply is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (v : V₁), Eq.{succ u2} V₂ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) (Neg.neg.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasNeg.{u1, u2} V₁ V₂ _inst_2 _inst_3) f) v) (Neg.neg.{u2} V₂ (SubNegMonoid.toHasNeg.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f v))
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] (f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (v : V₁), Eq.{succ u1} V₂ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) (Neg.neg.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.neg.{u2, u1} V₁ V₂ _inst_2 _inst_3) f) v) (Neg.neg.{u1} V₂ (NegZeroClass.toNeg.{u1} V₂ (SubNegZeroMonoid.toNegZeroClass.{u1} V₂ (SubtractionMonoid.toSubNegZeroMonoid.{u1} V₂ (SubtractionCommMonoid.toSubtractionMonoid.{u1} V₂ (AddCommGroup.toDivisionAddCommMonoid.{u1} V₂ (SeminormedAddCommGroup.toAddCommGroup.{u1} V₂ _inst_3)))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) f v))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.neg_apply NormedAddGroupHom.neg_applyₓ'. -/
@[simp]
theorem neg_apply (f : NormedAddGroupHom V₁ V₂) (v : V₁) :
    (-f : NormedAddGroupHom V₁ V₂) v = -f v :=
  rfl
#align normed_add_group_hom.neg_apply NormedAddGroupHom.neg_apply

/- warning: normed_add_group_hom.op_norm_neg -> NormedAddGroupHom.opNorm_neg is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3), Eq.{1} Real (Norm.norm.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u1, u2} V₁ V₂ _inst_2 _inst_3) (Neg.neg.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasNeg.{u1, u2} V₁ V₂ _inst_2 _inst_3) f)) (Norm.norm.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u1, u2} V₁ V₂ _inst_2 _inst_3) f)
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] (f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3), Eq.{1} Real (Norm.norm.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u2, u1} V₁ V₂ _inst_2 _inst_3) (Neg.neg.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.neg.{u2, u1} V₁ V₂ _inst_2 _inst_3) f)) (Norm.norm.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u2, u1} V₁ V₂ _inst_2 _inst_3) f)
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.op_norm_neg NormedAddGroupHom.opNorm_negₓ'. -/
theorem opNorm_neg (f : NormedAddGroupHom V₁ V₂) : ‖-f‖ = ‖f‖ := by
  simp only [norm_def, coe_neg, norm_neg, Pi.neg_apply]
#align normed_add_group_hom.op_norm_neg NormedAddGroupHom.opNorm_neg

/-! ### Subtraction of normed group homs -/


/-- Subtraction of normed group homs. -/
instance : Sub (NormedAddGroupHom V₁ V₂) :=
  ⟨fun f g =>
    { f.toAddMonoidHom - g.toAddMonoidHom with
      bound' :=
        by
        simp only [AddMonoidHom.sub_apply, AddMonoidHom.toFun_eq_coe, sub_eq_add_neg]
        exact (f + -g).bound' }⟩

/- warning: normed_add_group_hom.coe_sub -> NormedAddGroupHom.coe_sub is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (g : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3), Eq.{max (succ u1) (succ u2)} (V₁ -> V₂) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (instHSub.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasSub.{u1, u2} V₁ V₂ _inst_2 _inst_3)) f g)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (V₁ -> V₂) (V₁ -> V₂) (V₁ -> V₂) (instHSub.{max u1 u2} (V₁ -> V₂) (Pi.instSub.{u1, u2} V₁ (fun (ᾰ : V₁) => V₂) (fun (i : V₁) => SubNegMonoid.toHasSub.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) g))
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] (f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (g : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3), Eq.{max (succ u2) (succ u1)} (V₁ -> V₂) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (instHSub.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.sub.{u2, u1} V₁ V₂ _inst_2 _inst_3)) f g)) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (V₁ -> V₂) (V₁ -> V₂) (V₁ -> V₂) (instHSub.{max u2 u1} (V₁ -> V₂) (Pi.instSub.{u2, u1} V₁ (fun (ᾰ : V₁) => V₂) (fun (i : V₁) => SubNegMonoid.toSub.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) f) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) g))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.coe_sub NormedAddGroupHom.coe_subₓ'. -/
-- see Note [addition on function coercions]
@[simp]
theorem coe_sub (f g : NormedAddGroupHom V₁ V₂) : ⇑(f - g) = (f - g : V₁ → V₂) :=
  rfl
#align normed_add_group_hom.coe_sub NormedAddGroupHom.coe_sub

/- warning: normed_add_group_hom.sub_apply -> NormedAddGroupHom.sub_apply is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (g : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (v : V₁), Eq.{succ u2} V₂ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (instHSub.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasSub.{u1, u2} V₁ V₂ _inst_2 _inst_3)) f g) v) (HSub.hSub.{u2, u2, u2} V₂ V₂ V₂ (instHSub.{u2} V₂ (SubNegMonoid.toHasSub.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f v) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) g v))
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] (f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (g : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (v : V₁), Eq.{succ u1} V₂ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (instHSub.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.sub.{u2, u1} V₁ V₂ _inst_2 _inst_3)) f g) v) (HSub.hSub.{u1, u1, u1} V₂ V₂ V₂ (instHSub.{u1} V₂ (SubNegMonoid.toSub.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) f v) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) g v))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.sub_apply NormedAddGroupHom.sub_applyₓ'. -/
@[simp]
theorem sub_apply (f g : NormedAddGroupHom V₁ V₂) (v : V₁) :
    (f - g : NormedAddGroupHom V₁ V₂) v = f v - g v :=
  rfl
#align normed_add_group_hom.sub_apply NormedAddGroupHom.sub_apply

/-! ### Scalar actions on normed group homs -/


section SMul

variable {R R' : Type _} [MonoidWithZero R] [DistribMulAction R V₂] [PseudoMetricSpace R]
  [BoundedSMul R V₂] [MonoidWithZero R'] [DistribMulAction R' V₂] [PseudoMetricSpace R']
  [BoundedSMul R' V₂]

instance : SMul R (NormedAddGroupHom V₁ V₂)
    where smul r f :=
    { toFun := r • f
      map_add' := (r • f.toAddMonoidHom).map_add'
      bound' :=
        let ⟨b, hb⟩ := f.bound'
        ⟨dist r 0 * b, fun x => by
          have := dist_smul_pair r (f x) (f 0)
          rw [map_zero, smul_zero, dist_zero_right, dist_zero_right] at this
          rw [mul_assoc]
          refine' this.trans _
          refine' mul_le_mul_of_nonneg_left _ dist_nonneg
          exact hb x⟩ }

/- warning: normed_add_group_hom.coe_smul -> NormedAddGroupHom.coe_smul is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] {R : Type.{u3}} [_inst_5 : MonoidWithZero.{u3} R] [_inst_6 : DistribMulAction.{u3, u2} R V₂ (MonoidWithZero.toMonoid.{u3} R _inst_5) (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))] [_inst_7 : PseudoMetricSpace.{u3} R] [_inst_8 : BoundedSMul.{u3, u2} R V₂ _inst_7 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} V₂ _inst_3) (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R _inst_5))) (AddZeroClass.toHasZero.{u2} V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) (SMulZeroClass.toHasSmul.{u3, u2} R V₂ (AddZeroClass.toHasZero.{u2} V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) (DistribSMul.toSmulZeroClass.{u3, u2} R V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))) (DistribMulAction.toDistribSMul.{u3, u2} R V₂ (MonoidWithZero.toMonoid.{u3} R _inst_5) (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))) _inst_6)))] (r : R) (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3), Eq.{succ (max u1 u2)} (V₁ -> V₂) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) (SMul.smul.{u3, max u1 u2} R (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasSmul.{u1, u2, u3} V₁ V₂ _inst_2 _inst_3 R _inst_5 _inst_6 _inst_7 _inst_8) r f)) (SMul.smul.{u3, max u1 u2} R (V₁ -> V₂) (Function.hasSMul.{u1, u3, u2} V₁ R V₂ (SMulZeroClass.toHasSmul.{u3, u2} R V₂ (AddZeroClass.toHasZero.{u2} V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) (DistribSMul.toSmulZeroClass.{u3, u2} R V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))) (DistribMulAction.toDistribSMul.{u3, u2} R V₂ (MonoidWithZero.toMonoid.{u3} R _inst_5) (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))) _inst_6)))) r (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f))
but is expected to have type
  forall {V₁ : Type.{u3}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u3} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] {R : Type.{u1}} [_inst_5 : MonoidWithZero.{u1} R] [_inst_6 : DistribMulAction.{u1, u2} R V₂ (MonoidWithZero.toMonoid.{u1} R _inst_5) (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))] [_inst_7 : PseudoMetricSpace.{u1} R] [_inst_8 : BoundedSMul.{u1, u2} R V₂ _inst_7 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} V₂ _inst_3) (MonoidWithZero.toZero.{u1} R _inst_5) (NegZeroClass.toZero.{u2} V₂ (SubNegZeroMonoid.toNegZeroClass.{u2} V₂ (SubtractionMonoid.toSubNegZeroMonoid.{u2} V₂ (SubtractionCommMonoid.toSubtractionMonoid.{u2} V₂ (AddCommGroup.toDivisionAddCommMonoid.{u2} V₂ (SeminormedAddCommGroup.toAddCommGroup.{u2} V₂ _inst_3)))))) (SMulZeroClass.toSMul.{u1, u2} R V₂ (NegZeroClass.toZero.{u2} V₂ (SubNegZeroMonoid.toNegZeroClass.{u2} V₂ (SubtractionMonoid.toSubNegZeroMonoid.{u2} V₂ (SubtractionCommMonoid.toSubtractionMonoid.{u2} V₂ (AddCommGroup.toDivisionAddCommMonoid.{u2} V₂ (SeminormedAddCommGroup.toAddCommGroup.{u2} V₂ _inst_3)))))) (DistribSMul.toSMulZeroClass.{u1, u2} R V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))) (DistribMulAction.toDistribSMul.{u1, u2} R V₂ (MonoidWithZero.toMonoid.{u1} R _inst_5) (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))) _inst_6)))] (r : R) (f : NormedAddGroupHom.{u3, u2} V₁ V₂ _inst_2 _inst_3), Eq.{max (succ u3) (succ u2)} (V₁ -> V₂) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (NormedAddGroupHom.{u3, u2} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u3 u2, u3, u2} (NormedAddGroupHom.{u3, u2} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u3} V₁ (AddMonoid.toAddZeroClass.{u3} V₁ (SubNegMonoid.toAddMonoid.{u3} V₁ (AddGroup.toSubNegMonoid.{u3} V₁ (SeminormedAddGroup.toAddGroup.{u3} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u3} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u2} V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u3 u2, u3, u2} (NormedAddGroupHom.{u3, u2} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u3} V₁ (SubNegMonoid.toAddMonoid.{u3} V₁ (AddGroup.toSubNegMonoid.{u3} V₁ (SeminormedAddGroup.toAddGroup.{u3} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u3} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u3, u2} V₁ V₂ _inst_2 _inst_3))) (HSMul.hSMul.{u1, max u3 u2, max u3 u2} R (NormedAddGroupHom.{u3, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.{u3, u2} V₁ V₂ _inst_2 _inst_3) (instHSMul.{u1, max u3 u2} R (NormedAddGroupHom.{u3, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.smul.{u3, u2, u1} V₁ V₂ _inst_2 _inst_3 R _inst_5 _inst_6 _inst_7 _inst_8)) r f)) (HSMul.hSMul.{u1, max u3 u2, max u3 u2} R (V₁ -> V₂) (V₁ -> V₂) (instHSMul.{u1, max u3 u2} R (V₁ -> V₂) (Pi.instSMul.{u3, u2, u1} V₁ R (fun (a : V₁) => V₂) (fun (i : V₁) => SMulZeroClass.toSMul.{u1, u2} R V₂ (NegZeroClass.toZero.{u2} V₂ (SubNegZeroMonoid.toNegZeroClass.{u2} V₂ (SubtractionMonoid.toSubNegZeroMonoid.{u2} V₂ (SubtractionCommMonoid.toSubtractionMonoid.{u2} V₂ (AddCommGroup.toDivisionAddCommMonoid.{u2} V₂ (SeminormedAddCommGroup.toAddCommGroup.{u2} V₂ _inst_3)))))) (DistribSMul.toSMulZeroClass.{u1, u2} R V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))) (DistribMulAction.toDistribSMul.{u1, u2} R V₂ (MonoidWithZero.toMonoid.{u1} R _inst_5) (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))) _inst_6))))) r (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (NormedAddGroupHom.{u3, u2} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u3 u2, u3, u2} (NormedAddGroupHom.{u3, u2} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u3} V₁ (AddMonoid.toAddZeroClass.{u3} V₁ (SubNegMonoid.toAddMonoid.{u3} V₁ (AddGroup.toSubNegMonoid.{u3} V₁ (SeminormedAddGroup.toAddGroup.{u3} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u3} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u2} V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u3 u2, u3, u2} (NormedAddGroupHom.{u3, u2} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u3} V₁ (SubNegMonoid.toAddMonoid.{u3} V₁ (AddGroup.toSubNegMonoid.{u3} V₁ (SeminormedAddGroup.toAddGroup.{u3} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u3} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u3, u2} V₁ V₂ _inst_2 _inst_3))) f))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.coe_smul NormedAddGroupHom.coe_smulₓ'. -/
@[simp]
theorem coe_smul (r : R) (f : NormedAddGroupHom V₁ V₂) : ⇑(r • f) = r • f :=
  rfl
#align normed_add_group_hom.coe_smul NormedAddGroupHom.coe_smul

/- warning: normed_add_group_hom.smul_apply -> NormedAddGroupHom.smul_apply is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] {R : Type.{u3}} [_inst_5 : MonoidWithZero.{u3} R] [_inst_6 : DistribMulAction.{u3, u2} R V₂ (MonoidWithZero.toMonoid.{u3} R _inst_5) (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))] [_inst_7 : PseudoMetricSpace.{u3} R] [_inst_8 : BoundedSMul.{u3, u2} R V₂ _inst_7 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} V₂ _inst_3) (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R _inst_5))) (AddZeroClass.toHasZero.{u2} V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) (SMulZeroClass.toHasSmul.{u3, u2} R V₂ (AddZeroClass.toHasZero.{u2} V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) (DistribSMul.toSmulZeroClass.{u3, u2} R V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))) (DistribMulAction.toDistribSMul.{u3, u2} R V₂ (MonoidWithZero.toMonoid.{u3} R _inst_5) (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))) _inst_6)))] (r : R) (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (v : V₁), Eq.{succ u2} V₂ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) (SMul.smul.{u3, max u1 u2} R (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasSmul.{u1, u2, u3} V₁ V₂ _inst_2 _inst_3 R _inst_5 _inst_6 _inst_7 _inst_8) r f) v) (SMul.smul.{u3, u2} R V₂ (SMulZeroClass.toHasSmul.{u3, u2} R V₂ (AddZeroClass.toHasZero.{u2} V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) (DistribSMul.toSmulZeroClass.{u3, u2} R V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))) (DistribMulAction.toDistribSMul.{u3, u2} R V₂ (MonoidWithZero.toMonoid.{u3} R _inst_5) (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))) _inst_6))) r (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f v))
but is expected to have type
  forall {V₁ : Type.{u3}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u3} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] {R : Type.{u1}} [_inst_5 : MonoidWithZero.{u1} R] [_inst_6 : DistribMulAction.{u1, u2} R V₂ (MonoidWithZero.toMonoid.{u1} R _inst_5) (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))] [_inst_7 : PseudoMetricSpace.{u1} R] [_inst_8 : BoundedSMul.{u1, u2} R V₂ _inst_7 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} V₂ _inst_3) (MonoidWithZero.toZero.{u1} R _inst_5) (NegZeroClass.toZero.{u2} V₂ (SubNegZeroMonoid.toNegZeroClass.{u2} V₂ (SubtractionMonoid.toSubNegZeroMonoid.{u2} V₂ (SubtractionCommMonoid.toSubtractionMonoid.{u2} V₂ (AddCommGroup.toDivisionAddCommMonoid.{u2} V₂ (SeminormedAddCommGroup.toAddCommGroup.{u2} V₂ _inst_3)))))) (SMulZeroClass.toSMul.{u1, u2} R V₂ (NegZeroClass.toZero.{u2} V₂ (SubNegZeroMonoid.toNegZeroClass.{u2} V₂ (SubtractionMonoid.toSubNegZeroMonoid.{u2} V₂ (SubtractionCommMonoid.toSubtractionMonoid.{u2} V₂ (AddCommGroup.toDivisionAddCommMonoid.{u2} V₂ (SeminormedAddCommGroup.toAddCommGroup.{u2} V₂ _inst_3)))))) (DistribSMul.toSMulZeroClass.{u1, u2} R V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))) (DistribMulAction.toDistribSMul.{u1, u2} R V₂ (MonoidWithZero.toMonoid.{u1} R _inst_5) (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))) _inst_6)))] (r : R) (f : NormedAddGroupHom.{u3, u2} V₁ V₂ _inst_2 _inst_3) (v : V₁), Eq.{succ u2} V₂ (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (NormedAddGroupHom.{u3, u2} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u3 u2, u3, u2} (NormedAddGroupHom.{u3, u2} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u3} V₁ (AddMonoid.toAddZeroClass.{u3} V₁ (SubNegMonoid.toAddMonoid.{u3} V₁ (AddGroup.toSubNegMonoid.{u3} V₁ (SeminormedAddGroup.toAddGroup.{u3} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u3} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u2} V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u3 u2, u3, u2} (NormedAddGroupHom.{u3, u2} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u3} V₁ (SubNegMonoid.toAddMonoid.{u3} V₁ (AddGroup.toSubNegMonoid.{u3} V₁ (SeminormedAddGroup.toAddGroup.{u3} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u3} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u3, u2} V₁ V₂ _inst_2 _inst_3))) (HSMul.hSMul.{u1, max u3 u2, max u3 u2} R (NormedAddGroupHom.{u3, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.{u3, u2} V₁ V₂ _inst_2 _inst_3) (instHSMul.{u1, max u3 u2} R (NormedAddGroupHom.{u3, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.smul.{u3, u2, u1} V₁ V₂ _inst_2 _inst_3 R _inst_5 _inst_6 _inst_7 _inst_8)) r f) v) (HSMul.hSMul.{u1, u2, u2} R V₂ V₂ (instHSMul.{u1, u2} R V₂ (SMulZeroClass.toSMul.{u1, u2} R V₂ (NegZeroClass.toZero.{u2} V₂ (SubNegZeroMonoid.toNegZeroClass.{u2} V₂ (SubtractionMonoid.toSubNegZeroMonoid.{u2} V₂ (SubtractionCommMonoid.toSubtractionMonoid.{u2} V₂ (AddCommGroup.toDivisionAddCommMonoid.{u2} V₂ (SeminormedAddCommGroup.toAddCommGroup.{u2} V₂ _inst_3)))))) (DistribSMul.toSMulZeroClass.{u1, u2} R V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))) (DistribMulAction.toDistribSMul.{u1, u2} R V₂ (MonoidWithZero.toMonoid.{u1} R _inst_5) (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))) _inst_6)))) r (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (NormedAddGroupHom.{u3, u2} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u3 u2, u3, u2} (NormedAddGroupHom.{u3, u2} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u3} V₁ (AddMonoid.toAddZeroClass.{u3} V₁ (SubNegMonoid.toAddMonoid.{u3} V₁ (AddGroup.toSubNegMonoid.{u3} V₁ (SeminormedAddGroup.toAddGroup.{u3} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u3} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u2} V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u3 u2, u3, u2} (NormedAddGroupHom.{u3, u2} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u3} V₁ (SubNegMonoid.toAddMonoid.{u3} V₁ (AddGroup.toSubNegMonoid.{u3} V₁ (SeminormedAddGroup.toAddGroup.{u3} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u3} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u3, u2} V₁ V₂ _inst_2 _inst_3))) f v))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.smul_apply NormedAddGroupHom.smul_applyₓ'. -/
@[simp]
theorem smul_apply (r : R) (f : NormedAddGroupHom V₁ V₂) (v : V₁) : (r • f) v = r • f v :=
  rfl
#align normed_add_group_hom.smul_apply NormedAddGroupHom.smul_apply

instance [SMulCommClass R R' V₂] : SMulCommClass R R' (NormedAddGroupHom V₁ V₂)
    where smul_comm r r' f := ext fun v => smul_comm _ _ _

instance [SMul R R'] [IsScalarTower R R' V₂] : IsScalarTower R R' (NormedAddGroupHom V₁ V₂)
    where smul_assoc r r' f := ext fun v => smul_assoc _ _ _

instance [DistribMulAction Rᵐᵒᵖ V₂] [IsCentralScalar R V₂] :
    IsCentralScalar R (NormedAddGroupHom V₁ V₂)
    where op_smul_eq_smul r f := ext fun v => op_smul_eq_smul _ _

end SMul

#print NormedAddGroupHom.nsmul /-
instance nsmul : SMul ℕ (NormedAddGroupHom V₁ V₂)
    where smul n f :=
    { toFun := n • f
      map_add' := (n • f.toAddMonoidHom).map_add'
      bound' :=
        let ⟨b, hb⟩ := f.bound'
        ⟨n • b, fun v => by
          rw [Pi.smul_apply, nsmul_eq_mul, mul_assoc]
          exact (norm_nsmul_le _ _).trans (mul_le_mul_of_nonneg_left (hb _) (Nat.cast_nonneg _))⟩ }
#align normed_add_group_hom.has_nat_scalar NormedAddGroupHom.nsmul
-/

/- warning: normed_add_group_hom.coe_nsmul -> NormedAddGroupHom.coe_nsmul is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (r : Nat) (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3), Eq.{succ (max u1 u2)} (V₁ -> V₂) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) (SMul.smul.{0, max u1 u2} Nat (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.nsmul.{u1, u2} V₁ V₂ _inst_2 _inst_3) r f)) (SMul.smul.{0, max u1 u2} Nat (V₁ -> V₂) (Function.hasSMul.{u1, 0, u2} V₁ Nat V₂ (AddMonoid.SMul.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) r (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f))
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] (r : Nat) (f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3), Eq.{max (succ u2) (succ u1)} (V₁ -> V₂) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) (HSMul.hSMul.{0, max u2 u1, max u2 u1} Nat (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (instHSMul.{0, max u2 u1} Nat (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.nsmul.{u2, u1} V₁ V₂ _inst_2 _inst_3)) r f)) (HSMul.hSMul.{0, max u2 u1, max u2 u1} Nat (V₁ -> V₂) (V₁ -> V₂) (instHSMul.{0, max u2 u1} Nat (V₁ -> V₂) (AddMonoid.SMul.{max u2 u1} (V₁ -> V₂) (Pi.addMonoid.{u2, u1} V₁ (fun (a : V₁) => V₂) (fun (i : V₁) => SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))))) r (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) f))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.coe_nsmul NormedAddGroupHom.coe_nsmulₓ'. -/
@[simp]
theorem coe_nsmul (r : ℕ) (f : NormedAddGroupHom V₁ V₂) : ⇑(r • f) = r • f :=
  rfl
#align normed_add_group_hom.coe_nsmul NormedAddGroupHom.coe_nsmul

/- warning: normed_add_group_hom.nsmul_apply -> NormedAddGroupHom.nsmul_apply is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (r : Nat) (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (v : V₁), Eq.{succ u2} V₂ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) (SMul.smul.{0, max u1 u2} Nat (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.nsmul.{u1, u2} V₁ V₂ _inst_2 _inst_3) r f) v) (SMul.smul.{0, u2} Nat V₂ (AddMonoid.SMul.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))) r (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f v))
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] (r : Nat) (f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (v : V₁), Eq.{succ u1} V₂ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) (HSMul.hSMul.{0, max u2 u1, max u2 u1} Nat (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (instHSMul.{0, max u2 u1} Nat (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.nsmul.{u2, u1} V₁ V₂ _inst_2 _inst_3)) r f) v) (HSMul.hSMul.{0, u1, u1} Nat V₂ V₂ (instHSMul.{0, u1} Nat V₂ (AddMonoid.SMul.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) r (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) f v))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.nsmul_apply NormedAddGroupHom.nsmul_applyₓ'. -/
@[simp]
theorem nsmul_apply (r : ℕ) (f : NormedAddGroupHom V₁ V₂) (v : V₁) : (r • f) v = r • f v :=
  rfl
#align normed_add_group_hom.nsmul_apply NormedAddGroupHom.nsmul_apply

#print NormedAddGroupHom.zsmul /-
instance zsmul : SMul ℤ (NormedAddGroupHom V₁ V₂)
    where smul z f :=
    { toFun := z • f
      map_add' := (z • f.toAddMonoidHom).map_add'
      bound' :=
        let ⟨b, hb⟩ := f.bound'
        ⟨‖z‖ • b, fun v => by
          rw [Pi.smul_apply, smul_eq_mul, mul_assoc]
          exact (norm_zsmul_le _ _).trans (mul_le_mul_of_nonneg_left (hb _) <| norm_nonneg _)⟩ }
#align normed_add_group_hom.has_int_scalar NormedAddGroupHom.zsmul
-/

/- warning: normed_add_group_hom.coe_zsmul -> NormedAddGroupHom.coe_zsmul is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (r : Int) (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3), Eq.{succ (max u1 u2)} (V₁ -> V₂) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) (SMul.smul.{0, max u1 u2} Int (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.zsmul.{u1, u2} V₁ V₂ _inst_2 _inst_3) r f)) (SMul.smul.{0, max u1 u2} Int (V₁ -> V₂) (Function.hasSMul.{u1, 0, u2} V₁ Int V₂ (SubNegMonoid.SMulInt.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))) r (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f))
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] (r : Int) (f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3), Eq.{max (succ u2) (succ u1)} (V₁ -> V₂) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) (HSMul.hSMul.{0, max u2 u1, max u2 u1} Int (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (instHSMul.{0, max u2 u1} Int (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.zsmul.{u2, u1} V₁ V₂ _inst_2 _inst_3)) r f)) (HSMul.hSMul.{0, max u2 u1, max u2 u1} Int (V₁ -> V₂) (V₁ -> V₂) (instHSMul.{0, max u2 u1} Int (V₁ -> V₂) (SubNegMonoid.SMulInt.{max u2 u1} (V₁ -> V₂) (Pi.subNegMonoid.{u2, u1} V₁ (fun (a : V₁) => V₂) (fun (i : V₁) => AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) r (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) f))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.coe_zsmul NormedAddGroupHom.coe_zsmulₓ'. -/
@[simp]
theorem coe_zsmul (r : ℤ) (f : NormedAddGroupHom V₁ V₂) : ⇑(r • f) = r • f :=
  rfl
#align normed_add_group_hom.coe_zsmul NormedAddGroupHom.coe_zsmul

/- warning: normed_add_group_hom.zsmul_apply -> NormedAddGroupHom.zsmul_apply is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] (r : Int) (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (v : V₁), Eq.{succ u2} V₂ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) (SMul.smul.{0, max u1 u2} Int (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.zsmul.{u1, u2} V₁ V₂ _inst_2 _inst_3) r f) v) (SMul.smul.{0, u2} Int V₂ (SubNegMonoid.SMulInt.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))) r (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f v))
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] (r : Int) (f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (v : V₁), Eq.{succ u1} V₂ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) (HSMul.hSMul.{0, max u2 u1, max u2 u1} Int (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (instHSMul.{0, max u2 u1} Int (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.zsmul.{u2, u1} V₁ V₂ _inst_2 _inst_3)) r f) v) (HSMul.hSMul.{0, u1, u1} Int V₂ V₂ (instHSMul.{0, u1} Int V₂ (SubNegMonoid.SMulInt.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) r (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) f v))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.zsmul_apply NormedAddGroupHom.zsmul_applyₓ'. -/
@[simp]
theorem zsmul_apply (r : ℤ) (f : NormedAddGroupHom V₁ V₂) (v : V₁) : (r • f) v = r • f v :=
  rfl
#align normed_add_group_hom.zsmul_apply NormedAddGroupHom.zsmul_apply

/-! ### Normed group structure on normed group homs -/


/-- Homs between two given normed groups form a commutative additive group. -/
instance : AddCommGroup (NormedAddGroupHom V₁ V₂) :=
  coe_injective.AddCommGroup _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl)
    fun _ _ => rfl

#print NormedAddGroupHom.toSeminormedAddCommGroup /-
/-- Normed group homomorphisms themselves form a seminormed group with respect to
    the operator norm. -/
instance toSeminormedAddCommGroup : SeminormedAddCommGroup (NormedAddGroupHom V₁ V₂) :=
  AddGroupSeminorm.toSeminormedAddCommGroup
    { toFun := opNorm
      map_zero' := opNorm_zero
      neg' := opNorm_neg
      add_le' := opNorm_add_le }
#align normed_add_group_hom.to_seminormed_add_comm_group NormedAddGroupHom.toSeminormedAddCommGroup
-/

#print NormedAddGroupHom.toNormedAddCommGroup /-
/-- Normed group homomorphisms themselves form a normed group with respect to
    the operator norm. -/
instance toNormedAddCommGroup {V₁ V₂ : Type _} [NormedAddCommGroup V₁] [NormedAddCommGroup V₂] :
    NormedAddCommGroup (NormedAddGroupHom V₁ V₂) :=
  AddGroupNorm.toNormedAddCommGroup
    { toFun := opNorm
      map_zero' := opNorm_zero
      neg' := opNorm_neg
      add_le' := opNorm_add_le
      eq_zero_of_map_eq_zero' := fun f => opNorm_zero_iff.1 }
#align normed_add_group_hom.to_normed_add_comm_group NormedAddGroupHom.toNormedAddCommGroup
-/

#print NormedAddGroupHom.coeAddHom /-
/-- Coercion of a `normed_add_group_hom` is an `add_monoid_hom`. Similar to `add_monoid_hom.coe_fn`.
-/
@[simps]
def coeAddHom : NormedAddGroupHom V₁ V₂ →+ V₁ → V₂
    where
  toFun := coeFn
  map_zero' := coe_zero
  map_add' := coe_add
#align normed_add_group_hom.coe_fn_add_hom NormedAddGroupHom.coeAddHom
-/

/- warning: normed_add_group_hom.coe_sum -> NormedAddGroupHom.coe_sum is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] {ι : Type.{u3}} (s : Finset.{u3} ι) (f : ι -> (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3)), Eq.{max (succ u1) (succ u2)} (V₁ -> V₂) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) (Finset.sum.{max u1 u2, u3} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) ι (AddCommGroup.toAddCommMonoid.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.addCommGroup.{u1, u2} V₁ V₂ _inst_2 _inst_3)) s (fun (i : ι) => f i))) (Finset.sum.{max u1 u2, u3} (V₁ -> V₂) ι (Pi.addCommMonoid.{u1, u2} V₁ (fun (ᾰ : V₁) => V₂) (fun (i : V₁) => AddCommGroup.toAddCommMonoid.{u2} V₂ (SeminormedAddCommGroup.toAddCommGroup.{u2} V₂ _inst_3))) s (fun (i : ι) => coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) (f i)))
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] {ι : Type.{u3}} (s : Finset.{u3} ι) (f : ι -> (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3)), Eq.{max (succ u2) (succ u1)} (V₁ -> V₂) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) (Finset.sum.{max u2 u1, u3} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) ι (AddCommGroup.toAddCommMonoid.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.toAddCommGroup.{u2, u1} V₁ V₂ _inst_2 _inst_3)) s (fun (i : ι) => f i))) (Finset.sum.{max u2 u1, u3} (V₁ -> V₂) ι (Pi.addCommMonoid.{u2, u1} V₁ (fun (ᾰ : V₁) => V₂) (fun (i : V₁) => AddCommGroup.toAddCommMonoid.{u1} V₂ (SeminormedAddCommGroup.toAddCommGroup.{u1} V₂ _inst_3))) s (fun (i : ι) => FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) (f i)))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.coe_sum NormedAddGroupHom.coe_sumₓ'. -/
@[simp]
theorem coe_sum {ι : Type _} (s : Finset ι) (f : ι → NormedAddGroupHom V₁ V₂) :
    ⇑(∑ i in s, f i) = ∑ i in s, f i :=
  (coeAddHom : _ →+ V₁ → V₂).map_sum f s
#align normed_add_group_hom.coe_sum NormedAddGroupHom.coe_sum

/- warning: normed_add_group_hom.sum_apply -> NormedAddGroupHom.sum_apply is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] {ι : Type.{u3}} (s : Finset.{u3} ι) (f : ι -> (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3)) (v : V₁), Eq.{succ u2} V₂ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) (Finset.sum.{max u1 u2, u3} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) ι (AddCommGroup.toAddCommMonoid.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.addCommGroup.{u1, u2} V₁ V₂ _inst_2 _inst_3)) s (fun (i : ι) => f i)) v) (Finset.sum.{u2, u3} V₂ ι (AddCommGroup.toAddCommMonoid.{u2} V₂ (SeminormedAddCommGroup.toAddCommGroup.{u2} V₂ _inst_3)) s (fun (i : ι) => coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) (f i) v))
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u2} V₁] [_inst_3 : SeminormedAddCommGroup.{u1} V₂] {ι : Type.{u3}} (s : Finset.{u3} ι) (f : ι -> (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3)) (v : V₁), Eq.{succ u1} V₂ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) (Finset.sum.{max u2 u1, u3} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) ι (AddCommGroup.toAddCommMonoid.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.toAddCommGroup.{u2, u1} V₁ V₂ _inst_2 _inst_3)) s (fun (i : ι) => f i)) v) (Finset.sum.{u1, u3} V₂ ι (AddCommGroup.toAddCommMonoid.{u1} V₂ (SeminormedAddCommGroup.toAddCommGroup.{u1} V₂ _inst_3)) s (fun (i : ι) => FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_2 _inst_3))) (f i) v))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.sum_apply NormedAddGroupHom.sum_applyₓ'. -/
theorem sum_apply {ι : Type _} (s : Finset ι) (f : ι → NormedAddGroupHom V₁ V₂) (v : V₁) :
    (∑ i in s, f i) v = ∑ i in s, f i v := by simp only [coe_sum, Finset.sum_apply]
#align normed_add_group_hom.sum_apply NormedAddGroupHom.sum_apply

/-! ### Module structure on normed group homs -/


instance {R : Type _} [MonoidWithZero R] [DistribMulAction R V₂] [PseudoMetricSpace R]
    [BoundedSMul R V₂] : DistribMulAction R (NormedAddGroupHom V₁ V₂) :=
  Function.Injective.distribMulAction coeAddHom coe_injective coe_smul

instance {R : Type _} [Semiring R] [Module R V₂] [PseudoMetricSpace R] [BoundedSMul R V₂] :
    Module R (NormedAddGroupHom V₁ V₂) :=
  Function.Injective.module _ coeAddHom coe_injective coe_smul

/-! ### Composition of normed group homs -/


#print NormedAddGroupHom.comp /-
/-- The composition of continuous normed group homs. -/
@[simps]
protected def comp (g : NormedAddGroupHom V₂ V₃) (f : NormedAddGroupHom V₁ V₂) :
    NormedAddGroupHom V₁ V₃ :=
  (g.toAddMonoidHom.comp f.toAddMonoidHom).mkNormedAddGroupHom (‖g‖ * ‖f‖) fun v =>
    calc
      ‖g (f v)‖ ≤ ‖g‖ * ‖f v‖ := le_opNorm _ _
      _ ≤ ‖g‖ * (‖f‖ * ‖v‖) := (mul_le_mul_of_nonneg_left (le_opNorm _ _) (opNorm_nonneg _))
      _ = ‖g‖ * ‖f‖ * ‖v‖ := by rw [mul_assoc]
      
#align normed_add_group_hom.comp NormedAddGroupHom.comp
-/

/- warning: normed_add_group_hom.norm_comp_le -> NormedAddGroupHom.norm_comp_le is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} {V₃ : Type.{u3}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] [_inst_4 : SeminormedAddCommGroup.{u3} V₃] (g : NormedAddGroupHom.{u2, u3} V₂ V₃ _inst_3 _inst_4) (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3), LE.le.{0} Real Real.hasLe (Norm.norm.{max u1 u3} (NormedAddGroupHom.{u1, u3} V₁ V₃ _inst_2 _inst_4) (NormedAddGroupHom.hasOpNorm.{u1, u3} V₁ V₃ _inst_2 _inst_4) (NormedAddGroupHom.comp.{u1, u2, u3} V₁ V₂ V₃ _inst_2 _inst_3 _inst_4 g f)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Norm.norm.{max u2 u3} (NormedAddGroupHom.{u2, u3} V₂ V₃ _inst_3 _inst_4) (NormedAddGroupHom.hasOpNorm.{u2, u3} V₂ V₃ _inst_3 _inst_4) g) (Norm.norm.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u1, u2} V₁ V₂ _inst_2 _inst_3) f))
but is expected to have type
  forall {V₁ : Type.{u1}} {V₂ : Type.{u3}} {V₃ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u3} V₂] [_inst_4 : SeminormedAddCommGroup.{u2} V₃] (g : NormedAddGroupHom.{u3, u2} V₂ V₃ _inst_3 _inst_4) (f : NormedAddGroupHom.{u1, u3} V₁ V₂ _inst_2 _inst_3), LE.le.{0} Real Real.instLEReal (Norm.norm.{max u2 u1} (NormedAddGroupHom.{u1, u2} V₁ V₃ _inst_2 _inst_4) (NormedAddGroupHom.hasOpNorm.{u1, u2} V₁ V₃ _inst_2 _inst_4) (NormedAddGroupHom.comp.{u1, u3, u2} V₁ V₂ V₃ _inst_2 _inst_3 _inst_4 g f)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Norm.norm.{max u3 u2} (NormedAddGroupHom.{u3, u2} V₂ V₃ _inst_3 _inst_4) (NormedAddGroupHom.hasOpNorm.{u3, u2} V₂ V₃ _inst_3 _inst_4) g) (Norm.norm.{max u1 u3} (NormedAddGroupHom.{u1, u3} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u1, u3} V₁ V₂ _inst_2 _inst_3) f))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.norm_comp_le NormedAddGroupHom.norm_comp_leₓ'. -/
theorem norm_comp_le (g : NormedAddGroupHom V₂ V₃) (f : NormedAddGroupHom V₁ V₂) :
    ‖g.comp f‖ ≤ ‖g‖ * ‖f‖ :=
  mkNormedAddGroupHom_norm_le _ (mul_nonneg (opNorm_nonneg _) (opNorm_nonneg _)) _
#align normed_add_group_hom.norm_comp_le NormedAddGroupHom.norm_comp_le

/- warning: normed_add_group_hom.norm_comp_le_of_le -> NormedAddGroupHom.norm_comp_le_of_le is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} {V₃ : Type.{u3}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] [_inst_4 : SeminormedAddCommGroup.{u3} V₃] {f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3} {g : NormedAddGroupHom.{u2, u3} V₂ V₃ _inst_3 _inst_4} {C₁ : Real} {C₂ : Real}, (LE.le.{0} Real Real.hasLe (Norm.norm.{max u2 u3} (NormedAddGroupHom.{u2, u3} V₂ V₃ _inst_3 _inst_4) (NormedAddGroupHom.hasOpNorm.{u2, u3} V₂ V₃ _inst_3 _inst_4) g) C₂) -> (LE.le.{0} Real Real.hasLe (Norm.norm.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u1, u2} V₁ V₂ _inst_2 _inst_3) f) C₁) -> (LE.le.{0} Real Real.hasLe (Norm.norm.{max u1 u3} (NormedAddGroupHom.{u1, u3} V₁ V₃ _inst_2 _inst_4) (NormedAddGroupHom.hasOpNorm.{u1, u3} V₁ V₃ _inst_2 _inst_4) (NormedAddGroupHom.comp.{u1, u2, u3} V₁ V₂ V₃ _inst_2 _inst_3 _inst_4 g f)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) C₂ C₁))
but is expected to have type
  forall {V₁ : Type.{u1}} {V₂ : Type.{u3}} {V₃ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u3} V₂] [_inst_4 : SeminormedAddCommGroup.{u2} V₃] {f : NormedAddGroupHom.{u1, u3} V₁ V₂ _inst_2 _inst_3} {g : NormedAddGroupHom.{u3, u2} V₂ V₃ _inst_3 _inst_4} {C₁ : Real} {C₂ : Real}, (LE.le.{0} Real Real.instLEReal (Norm.norm.{max u3 u2} (NormedAddGroupHom.{u3, u2} V₂ V₃ _inst_3 _inst_4) (NormedAddGroupHom.hasOpNorm.{u3, u2} V₂ V₃ _inst_3 _inst_4) g) C₂) -> (LE.le.{0} Real Real.instLEReal (Norm.norm.{max u1 u3} (NormedAddGroupHom.{u1, u3} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u1, u3} V₁ V₂ _inst_2 _inst_3) f) C₁) -> (LE.le.{0} Real Real.instLEReal (Norm.norm.{max u2 u1} (NormedAddGroupHom.{u1, u2} V₁ V₃ _inst_2 _inst_4) (NormedAddGroupHom.hasOpNorm.{u1, u2} V₁ V₃ _inst_2 _inst_4) (NormedAddGroupHom.comp.{u1, u3, u2} V₁ V₂ V₃ _inst_2 _inst_3 _inst_4 g f)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) C₂ C₁))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.norm_comp_le_of_le NormedAddGroupHom.norm_comp_le_of_leₓ'. -/
theorem norm_comp_le_of_le {g : NormedAddGroupHom V₂ V₃} {C₁ C₂ : ℝ} (hg : ‖g‖ ≤ C₂)
    (hf : ‖f‖ ≤ C₁) : ‖g.comp f‖ ≤ C₂ * C₁ :=
  le_trans (norm_comp_le g f) <| mul_le_mul hg hf (norm_nonneg _) (le_trans (norm_nonneg _) hg)
#align normed_add_group_hom.norm_comp_le_of_le NormedAddGroupHom.norm_comp_le_of_le

/- warning: normed_add_group_hom.norm_comp_le_of_le' -> NormedAddGroupHom.norm_comp_le_of_le' is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} {V₃ : Type.{u3}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] [_inst_4 : SeminormedAddCommGroup.{u3} V₃] {f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3} {g : NormedAddGroupHom.{u2, u3} V₂ V₃ _inst_3 _inst_4} (C₁ : Real) (C₂ : Real) (C₃ : Real), (Eq.{1} Real C₃ (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) C₂ C₁)) -> (LE.le.{0} Real Real.hasLe (Norm.norm.{max u2 u3} (NormedAddGroupHom.{u2, u3} V₂ V₃ _inst_3 _inst_4) (NormedAddGroupHom.hasOpNorm.{u2, u3} V₂ V₃ _inst_3 _inst_4) g) C₂) -> (LE.le.{0} Real Real.hasLe (Norm.norm.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u1, u2} V₁ V₂ _inst_2 _inst_3) f) C₁) -> (LE.le.{0} Real Real.hasLe (Norm.norm.{max u1 u3} (NormedAddGroupHom.{u1, u3} V₁ V₃ _inst_2 _inst_4) (NormedAddGroupHom.hasOpNorm.{u1, u3} V₁ V₃ _inst_2 _inst_4) (NormedAddGroupHom.comp.{u1, u2, u3} V₁ V₂ V₃ _inst_2 _inst_3 _inst_4 g f)) C₃)
but is expected to have type
  forall {V₁ : Type.{u1}} {V₂ : Type.{u3}} {V₃ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u3} V₂] [_inst_4 : SeminormedAddCommGroup.{u2} V₃] {f : NormedAddGroupHom.{u1, u3} V₁ V₂ _inst_2 _inst_3} {g : NormedAddGroupHom.{u3, u2} V₂ V₃ _inst_3 _inst_4} (C₁ : Real) (C₂ : Real) (C₃ : Real), (Eq.{1} Real C₃ (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) C₂ C₁)) -> (LE.le.{0} Real Real.instLEReal (Norm.norm.{max u3 u2} (NormedAddGroupHom.{u3, u2} V₂ V₃ _inst_3 _inst_4) (NormedAddGroupHom.hasOpNorm.{u3, u2} V₂ V₃ _inst_3 _inst_4) g) C₂) -> (LE.le.{0} Real Real.instLEReal (Norm.norm.{max u1 u3} (NormedAddGroupHom.{u1, u3} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasOpNorm.{u1, u3} V₁ V₂ _inst_2 _inst_3) f) C₁) -> (LE.le.{0} Real Real.instLEReal (Norm.norm.{max u2 u1} (NormedAddGroupHom.{u1, u2} V₁ V₃ _inst_2 _inst_4) (NormedAddGroupHom.hasOpNorm.{u1, u2} V₁ V₃ _inst_2 _inst_4) (NormedAddGroupHom.comp.{u1, u3, u2} V₁ V₂ V₃ _inst_2 _inst_3 _inst_4 g f)) C₃)
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.norm_comp_le_of_le' NormedAddGroupHom.norm_comp_le_of_le'ₓ'. -/
theorem norm_comp_le_of_le' {g : NormedAddGroupHom V₂ V₃} (C₁ C₂ C₃ : ℝ) (h : C₃ = C₂ * C₁)
    (hg : ‖g‖ ≤ C₂) (hf : ‖f‖ ≤ C₁) : ‖g.comp f‖ ≤ C₃ := by rw [h]; exact norm_comp_le_of_le hg hf
#align normed_add_group_hom.norm_comp_le_of_le' NormedAddGroupHom.norm_comp_le_of_le'

/- warning: normed_add_group_hom.comp_hom -> NormedAddGroupHom.compHom is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.comp_hom NormedAddGroupHom.compHomₓ'. -/
/-- Composition of normed groups hom as an additive group morphism. -/
def compHom : NormedAddGroupHom V₂ V₃ →+ NormedAddGroupHom V₁ V₂ →+ NormedAddGroupHom V₁ V₃ :=
  AddMonoidHom.mk'
    (fun g => AddMonoidHom.mk' (fun f => g.comp f) (by intros ; ext; exact map_add g _ _))
    (by intros ; ext;
      simp only [comp_apply, Pi.add_apply, Function.comp_apply, AddMonoidHom.add_apply,
        AddMonoidHom.mk'_apply, coe_add])
#align normed_add_group_hom.comp_hom NormedAddGroupHom.compHom

/- warning: normed_add_group_hom.comp_zero -> NormedAddGroupHom.comp_zero is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} {V₃ : Type.{u3}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] [_inst_4 : SeminormedAddCommGroup.{u3} V₃] (f : NormedAddGroupHom.{u2, u3} V₂ V₃ _inst_3 _inst_4), Eq.{max (succ u1) (succ u3)} (NormedAddGroupHom.{u1, u3} V₁ V₃ _inst_2 _inst_4) (NormedAddGroupHom.comp.{u1, u2, u3} V₁ V₂ V₃ _inst_2 _inst_3 _inst_4 f (OfNat.ofNat.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) 0 (OfNat.mk.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) 0 (Zero.zero.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.hasZero.{u1, u2} V₁ V₂ _inst_2 _inst_3))))) (OfNat.ofNat.{max u1 u3} (NormedAddGroupHom.{u1, u3} V₁ V₃ _inst_2 _inst_4) 0 (OfNat.mk.{max u1 u3} (NormedAddGroupHom.{u1, u3} V₁ V₃ _inst_2 _inst_4) 0 (Zero.zero.{max u1 u3} (NormedAddGroupHom.{u1, u3} V₁ V₃ _inst_2 _inst_4) (NormedAddGroupHom.hasZero.{u1, u3} V₁ V₃ _inst_2 _inst_4))))
but is expected to have type
  forall {V₁ : Type.{u1}} {V₂ : Type.{u3}} {V₃ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u3} V₂] [_inst_4 : SeminormedAddCommGroup.{u2} V₃] (f : NormedAddGroupHom.{u3, u2} V₂ V₃ _inst_3 _inst_4), Eq.{max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₃ _inst_2 _inst_4) (NormedAddGroupHom.comp.{u1, u3, u2} V₁ V₂ V₃ _inst_2 _inst_3 _inst_4 f (OfNat.ofNat.{max u1 u3} (NormedAddGroupHom.{u1, u3} V₁ V₂ _inst_2 _inst_3) 0 (Zero.toOfNat0.{max u1 u3} (NormedAddGroupHom.{u1, u3} V₁ V₂ _inst_2 _inst_3) (NormedAddGroupHom.zero.{u1, u3} V₁ V₂ _inst_2 _inst_3)))) (OfNat.ofNat.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₃ _inst_2 _inst_4) 0 (Zero.toOfNat0.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₃ _inst_2 _inst_4) (NormedAddGroupHom.zero.{u1, u2} V₁ V₃ _inst_2 _inst_4)))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.comp_zero NormedAddGroupHom.comp_zeroₓ'. -/
@[simp]
theorem comp_zero (f : NormedAddGroupHom V₂ V₃) : f.comp (0 : NormedAddGroupHom V₁ V₂) = 0 := by
  ext; exact map_zero f
#align normed_add_group_hom.comp_zero NormedAddGroupHom.comp_zero

/- warning: normed_add_group_hom.zero_comp -> NormedAddGroupHom.zero_comp is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} {V₃ : Type.{u3}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] [_inst_4 : SeminormedAddCommGroup.{u3} V₃] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3), Eq.{max (succ u1) (succ u3)} (NormedAddGroupHom.{u1, u3} V₁ V₃ _inst_2 _inst_4) (NormedAddGroupHom.comp.{u1, u2, u3} V₁ V₂ V₃ _inst_2 _inst_3 _inst_4 (OfNat.ofNat.{max u2 u3} (NormedAddGroupHom.{u2, u3} V₂ V₃ _inst_3 _inst_4) 0 (OfNat.mk.{max u2 u3} (NormedAddGroupHom.{u2, u3} V₂ V₃ _inst_3 _inst_4) 0 (Zero.zero.{max u2 u3} (NormedAddGroupHom.{u2, u3} V₂ V₃ _inst_3 _inst_4) (NormedAddGroupHom.hasZero.{u2, u3} V₂ V₃ _inst_3 _inst_4)))) f) (OfNat.ofNat.{max u1 u3} (NormedAddGroupHom.{u1, u3} V₁ V₃ _inst_2 _inst_4) 0 (OfNat.mk.{max u1 u3} (NormedAddGroupHom.{u1, u3} V₁ V₃ _inst_2 _inst_4) 0 (Zero.zero.{max u1 u3} (NormedAddGroupHom.{u1, u3} V₁ V₃ _inst_2 _inst_4) (NormedAddGroupHom.hasZero.{u1, u3} V₁ V₃ _inst_2 _inst_4))))
but is expected to have type
  forall {V₁ : Type.{u3}} {V₂ : Type.{u2}} {V₃ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u3} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] [_inst_4 : SeminormedAddCommGroup.{u1} V₃] (f : NormedAddGroupHom.{u3, u2} V₁ V₂ _inst_2 _inst_3), Eq.{max (succ u3) (succ u1)} (NormedAddGroupHom.{u3, u1} V₁ V₃ _inst_2 _inst_4) (NormedAddGroupHom.comp.{u3, u2, u1} V₁ V₂ V₃ _inst_2 _inst_3 _inst_4 (OfNat.ofNat.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₂ V₃ _inst_3 _inst_4) 0 (Zero.toOfNat0.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₂ V₃ _inst_3 _inst_4) (NormedAddGroupHom.zero.{u2, u1} V₂ V₃ _inst_3 _inst_4))) f) (OfNat.ofNat.{max u3 u1} (NormedAddGroupHom.{u3, u1} V₁ V₃ _inst_2 _inst_4) 0 (Zero.toOfNat0.{max u3 u1} (NormedAddGroupHom.{u3, u1} V₁ V₃ _inst_2 _inst_4) (NormedAddGroupHom.zero.{u3, u1} V₁ V₃ _inst_2 _inst_4)))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.zero_comp NormedAddGroupHom.zero_compₓ'. -/
@[simp]
theorem zero_comp (f : NormedAddGroupHom V₁ V₂) : (0 : NormedAddGroupHom V₂ V₃).comp f = 0 := by
  ext; rfl
#align normed_add_group_hom.zero_comp NormedAddGroupHom.zero_comp

#print NormedAddGroupHom.comp_assoc /-
theorem comp_assoc {V₄ : Type _} [SeminormedAddCommGroup V₄] (h : NormedAddGroupHom V₃ V₄)
    (g : NormedAddGroupHom V₂ V₃) (f : NormedAddGroupHom V₁ V₂) :
    (h.comp g).comp f = h.comp (g.comp f) := by ext; rfl
#align normed_add_group_hom.comp_assoc NormedAddGroupHom.comp_assoc
-/

/- warning: normed_add_group_hom.coe_comp -> NormedAddGroupHom.coe_comp is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} {V₃ : Type.{u3}} [_inst_2 : SeminormedAddCommGroup.{u1} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] [_inst_4 : SeminormedAddCommGroup.{u3} V₃] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (g : NormedAddGroupHom.{u2, u3} V₂ V₃ _inst_3 _inst_4), Eq.{max (succ u1) (succ u3)} ((fun (_x : NormedAddGroupHom.{u1, u3} V₁ V₃ _inst_2 _inst_4) => V₁ -> V₃) (NormedAddGroupHom.comp.{u1, u2, u3} V₁ V₂ V₃ _inst_2 _inst_3 _inst_4 g f)) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (NormedAddGroupHom.{u1, u3} V₁ V₃ _inst_2 _inst_4) (fun (_x : NormedAddGroupHom.{u1, u3} V₁ V₃ _inst_2 _inst_4) => V₁ -> V₃) (NormedAddGroupHom.hasCoeToFun.{u1, u3} V₁ V₃ _inst_2 _inst_4) (NormedAddGroupHom.comp.{u1, u2, u3} V₁ V₂ V₃ _inst_2 _inst_3 _inst_4 g f)) (Function.comp.{succ u1, succ u2, succ u3} V₁ V₂ V₃ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (NormedAddGroupHom.{u2, u3} V₂ V₃ _inst_3 _inst_4) (fun (_x : NormedAddGroupHom.{u2, u3} V₂ V₃ _inst_3 _inst_4) => V₂ -> V₃) (NormedAddGroupHom.hasCoeToFun.{u2, u3} V₂ V₃ _inst_3 _inst_4) g) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_2 _inst_3) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_2 _inst_3) f))
but is expected to have type
  forall {V₁ : Type.{u3}} {V₂ : Type.{u2}} {V₃ : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u3} V₁] [_inst_3 : SeminormedAddCommGroup.{u2} V₂] [_inst_4 : SeminormedAddCommGroup.{u1} V₃] (f : NormedAddGroupHom.{u3, u2} V₁ V₂ _inst_2 _inst_3) (g : NormedAddGroupHom.{u2, u1} V₂ V₃ _inst_3 _inst_4), Eq.{max (succ u3) (succ u1)} (V₁ -> V₃) (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (NormedAddGroupHom.{u3, u1} V₁ V₃ _inst_2 _inst_4) V₁ (fun (_x : V₁) => V₃) (AddHomClass.toFunLike.{max u3 u1, u3, u1} (NormedAddGroupHom.{u3, u1} V₁ V₃ _inst_2 _inst_4) V₁ V₃ (AddZeroClass.toAdd.{u3} V₁ (AddMonoid.toAddZeroClass.{u3} V₁ (SubNegMonoid.toAddMonoid.{u3} V₁ (AddGroup.toSubNegMonoid.{u3} V₁ (SeminormedAddGroup.toAddGroup.{u3} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u3} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u1} V₃ (AddMonoid.toAddZeroClass.{u1} V₃ (SubNegMonoid.toAddMonoid.{u1} V₃ (AddGroup.toSubNegMonoid.{u1} V₃ (SeminormedAddGroup.toAddGroup.{u1} V₃ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₃ _inst_4)))))) (AddMonoidHomClass.toAddHomClass.{max u3 u1, u3, u1} (NormedAddGroupHom.{u3, u1} V₁ V₃ _inst_2 _inst_4) V₁ V₃ (AddMonoid.toAddZeroClass.{u3} V₁ (SubNegMonoid.toAddMonoid.{u3} V₁ (AddGroup.toSubNegMonoid.{u3} V₁ (SeminormedAddGroup.toAddGroup.{u3} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u3} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u1} V₃ (SubNegMonoid.toAddMonoid.{u1} V₃ (AddGroup.toSubNegMonoid.{u1} V₃ (SeminormedAddGroup.toAddGroup.{u1} V₃ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₃ _inst_4))))) (NormedAddGroupHom.toAddMonoidHomClass.{u3, u1} V₁ V₃ _inst_2 _inst_4))) (NormedAddGroupHom.comp.{u3, u2, u1} V₁ V₂ V₃ _inst_2 _inst_3 _inst_4 g f)) (Function.comp.{succ u3, succ u2, succ u1} V₁ V₂ V₃ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₂ V₃ _inst_3 _inst_4) V₂ (fun (_x : V₂) => V₃) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₂ V₃ _inst_3 _inst_4) V₂ V₃ (AddZeroClass.toAdd.{u2} V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) (AddZeroClass.toAdd.{u1} V₃ (AddMonoid.toAddZeroClass.{u1} V₃ (SubNegMonoid.toAddMonoid.{u1} V₃ (AddGroup.toSubNegMonoid.{u1} V₃ (SeminormedAddGroup.toAddGroup.{u1} V₃ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₃ _inst_4)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₂ V₃ _inst_3 _inst_4) V₂ V₃ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))) (AddMonoid.toAddZeroClass.{u1} V₃ (SubNegMonoid.toAddMonoid.{u1} V₃ (AddGroup.toSubNegMonoid.{u1} V₃ (SeminormedAddGroup.toAddGroup.{u1} V₃ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₃ _inst_4))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₂ V₃ _inst_3 _inst_4))) g) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (NormedAddGroupHom.{u3, u2} V₁ V₂ _inst_2 _inst_3) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u3 u2, u3, u2} (NormedAddGroupHom.{u3, u2} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddZeroClass.toAdd.{u3} V₁ (AddMonoid.toAddZeroClass.{u3} V₁ (SubNegMonoid.toAddMonoid.{u3} V₁ (AddGroup.toSubNegMonoid.{u3} V₁ (SeminormedAddGroup.toAddGroup.{u3} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u3} V₁ _inst_2)))))) (AddZeroClass.toAdd.{u2} V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3)))))) (AddMonoidHomClass.toAddHomClass.{max u3 u2, u3, u2} (NormedAddGroupHom.{u3, u2} V₁ V₂ _inst_2 _inst_3) V₁ V₂ (AddMonoid.toAddZeroClass.{u3} V₁ (SubNegMonoid.toAddMonoid.{u3} V₁ (AddGroup.toSubNegMonoid.{u3} V₁ (SeminormedAddGroup.toAddGroup.{u3} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u3} V₁ _inst_2))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_3))))) (NormedAddGroupHom.toAddMonoidHomClass.{u3, u2} V₁ V₂ _inst_2 _inst_3))) f))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.coe_comp NormedAddGroupHom.coe_compₓ'. -/
theorem coe_comp (f : NormedAddGroupHom V₁ V₂) (g : NormedAddGroupHom V₂ V₃) :
    (g.comp f : V₁ → V₃) = (g : V₂ → V₃) ∘ (f : V₁ → V₂) :=
  rfl
#align normed_add_group_hom.coe_comp NormedAddGroupHom.coe_comp

end NormedAddGroupHom

namespace NormedAddGroupHom

variable {V W V₁ V₂ V₃ : Type _} [SeminormedAddCommGroup V] [SeminormedAddCommGroup W]
  [SeminormedAddCommGroup V₁] [SeminormedAddCommGroup V₂] [SeminormedAddCommGroup V₃]

/- warning: normed_add_group_hom.incl -> NormedAddGroupHom.incl is a dubious translation:
lean 3 declaration is
  forall {V : Type.{u1}} [_inst_1 : SeminormedAddCommGroup.{u1} V] (s : AddSubgroup.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))), NormedAddGroupHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))) V (AddSubgroup.setLike.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1)))) s) V (AddSubgroup.seminormedAddCommGroup.{u1} V _inst_1 s) _inst_1
but is expected to have type
  forall {V : Type.{u1}} [_inst_1 : SeminormedAddCommGroup.{u1} V] (s : AddSubgroup.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))), NormedAddGroupHom.{u1, u1} (Subtype.{succ u1} V (fun (x : V) => Membership.mem.{u1, u1} V (AddSubgroup.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))) (SetLike.instMembership.{u1, u1} (AddSubgroup.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))) V (AddSubgroup.instSetLikeAddSubgroup.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1)))) x s)) V (AddSubgroup.seminormedAddCommGroup.{u1} V _inst_1 s) _inst_1
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.incl NormedAddGroupHom.inclₓ'. -/
/-- The inclusion of an `add_subgroup`, as bounded group homomorphism. -/
@[simps]
def incl (s : AddSubgroup V) : NormedAddGroupHom s V
    where
  toFun := (coe : s → V)
  map_add' v w := AddSubgroup.coe_add _ _ _
  bound' := ⟨1, fun v => by rw [one_mul]; rfl⟩
#align normed_add_group_hom.incl NormedAddGroupHom.incl

/- warning: normed_add_group_hom.norm_incl -> NormedAddGroupHom.norm_incl is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.norm_incl NormedAddGroupHom.norm_inclₓ'. -/
theorem norm_incl {V' : AddSubgroup V} (x : V') : ‖incl _ x‖ = ‖x‖ :=
  rfl
#align normed_add_group_hom.norm_incl NormedAddGroupHom.norm_incl

/-!### Kernel -/


section Kernels

variable (f : NormedAddGroupHom V₁ V₂) (g : NormedAddGroupHom V₂ V₃)

#print NormedAddGroupHom.ker /-
/-- The kernel of a bounded group homomorphism. Naturally endowed with a
`seminormed_add_comm_group` instance. -/
def ker : AddSubgroup V₁ :=
  f.toAddMonoidHom.ker
#align normed_add_group_hom.ker NormedAddGroupHom.ker
-/

/- warning: normed_add_group_hom.mem_ker -> NormedAddGroupHom.mem_ker is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_3 : SeminormedAddCommGroup.{u1} V₁] [_inst_4 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4) (v : V₁), Iff (Membership.Mem.{u1, u1} V₁ (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) (SetLike.hasMem.{u1, u1} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) V₁ (AddSubgroup.setLike.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3)))) v (NormedAddGroupHom.ker.{u1, u2} V₁ V₂ _inst_3 _inst_4 f)) (Eq.{succ u2} V₂ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_3 _inst_4) f v) (OfNat.ofNat.{u2} V₂ 0 (OfNat.mk.{u2} V₂ 0 (Zero.zero.{u2} V₂ (AddZeroClass.toHasZero.{u2} V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_4))))))))))
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_3 : SeminormedAddCommGroup.{u2} V₁] [_inst_4 : SeminormedAddCommGroup.{u1} V₂] (f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_3 _inst_4) (v : V₁), Iff (Membership.mem.{u2, u2} V₁ (AddSubgroup.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_3))) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_3))) V₁ (AddSubgroup.instSetLikeAddSubgroup.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_3)))) v (NormedAddGroupHom.ker.{u2, u1} V₁ V₂ _inst_3 _inst_4 f)) (Eq.{succ u1} V₂ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_3 _inst_4) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_3 _inst_4) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_3)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_4)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_3 _inst_4) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_3))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_4))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_3 _inst_4))) f v) (OfNat.ofNat.{u1} V₂ 0 (Zero.toOfNat0.{u1} V₂ (NegZeroClass.toZero.{u1} V₂ (SubNegZeroMonoid.toNegZeroClass.{u1} V₂ (SubtractionMonoid.toSubNegZeroMonoid.{u1} V₂ (SubtractionCommMonoid.toSubtractionMonoid.{u1} V₂ (AddCommGroup.toDivisionAddCommMonoid.{u1} V₂ (SeminormedAddCommGroup.toAddCommGroup.{u1} V₂ _inst_4)))))))))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.mem_ker NormedAddGroupHom.mem_kerₓ'. -/
theorem mem_ker (v : V₁) : v ∈ f.ker ↔ f v = 0 := by erw [f.to_add_monoid_hom.mem_ker]; rfl
#align normed_add_group_hom.mem_ker NormedAddGroupHom.mem_ker

/- warning: normed_add_group_hom.ker.lift -> NormedAddGroupHom.ker.lift is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} {V₃ : Type.{u3}} [_inst_3 : SeminormedAddCommGroup.{u1} V₁] [_inst_4 : SeminormedAddCommGroup.{u2} V₂] [_inst_5 : SeminormedAddCommGroup.{u3} V₃] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4) (g : NormedAddGroupHom.{u2, u3} V₂ V₃ _inst_4 _inst_5), (Eq.{max (succ u1) (succ u3)} (NormedAddGroupHom.{u1, u3} V₁ V₃ _inst_3 _inst_5) (NormedAddGroupHom.comp.{u1, u2, u3} V₁ V₂ V₃ _inst_3 _inst_4 _inst_5 g f) (OfNat.ofNat.{max u1 u3} (NormedAddGroupHom.{u1, u3} V₁ V₃ _inst_3 _inst_5) 0 (OfNat.mk.{max u1 u3} (NormedAddGroupHom.{u1, u3} V₁ V₃ _inst_3 _inst_5) 0 (Zero.zero.{max u1 u3} (NormedAddGroupHom.{u1, u3} V₁ V₃ _inst_3 _inst_5) (NormedAddGroupHom.hasZero.{u1, u3} V₁ V₃ _inst_3 _inst_5))))) -> (NormedAddGroupHom.{u1, u2} V₁ (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_4))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_4))) V₂ (AddSubgroup.setLike.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_4)))) (NormedAddGroupHom.ker.{u2, u3} V₂ V₃ _inst_4 _inst_5 g)) _inst_3 (AddSubgroup.seminormedAddCommGroup.{u2} V₂ _inst_4 (NormedAddGroupHom.ker.{u2, u3} V₂ V₃ _inst_4 _inst_5 g)))
but is expected to have type
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} {V₃ : Type.{u3}} [_inst_3 : SeminormedAddCommGroup.{u1} V₁] [_inst_4 : SeminormedAddCommGroup.{u2} V₂] [_inst_5 : SeminormedAddCommGroup.{u3} V₃] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4) (g : NormedAddGroupHom.{u2, u3} V₂ V₃ _inst_4 _inst_5), (Eq.{max (succ u1) (succ u3)} (NormedAddGroupHom.{u1, u3} V₁ V₃ _inst_3 _inst_5) (NormedAddGroupHom.comp.{u1, u2, u3} V₁ V₂ V₃ _inst_3 _inst_4 _inst_5 g f) (OfNat.ofNat.{max u1 u3} (NormedAddGroupHom.{u1, u3} V₁ V₃ _inst_3 _inst_5) 0 (Zero.toOfNat0.{max u1 u3} (NormedAddGroupHom.{u1, u3} V₁ V₃ _inst_3 _inst_5) (NormedAddGroupHom.zero.{u1, u3} V₁ V₃ _inst_3 _inst_5)))) -> (NormedAddGroupHom.{u1, u2} V₁ (Subtype.{succ u2} V₂ (fun (x : V₂) => Membership.mem.{u2, u2} V₂ (AddSubgroup.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_4))) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_4))) V₂ (AddSubgroup.instSetLikeAddSubgroup.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_4)))) x (NormedAddGroupHom.ker.{u2, u3} V₂ V₃ _inst_4 _inst_5 g))) _inst_3 (AddSubgroup.seminormedAddCommGroup.{u2} V₂ _inst_4 (NormedAddGroupHom.ker.{u2, u3} V₂ V₃ _inst_4 _inst_5 g)))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.ker.lift NormedAddGroupHom.ker.liftₓ'. -/
/-- Given a normed group hom `f : V₁ → V₂` satisfying `g.comp f = 0` for some `g : V₂ → V₃`,
    the corestriction of `f` to the kernel of `g`. -/
@[simps]
def ker.lift (h : g.comp f = 0) : NormedAddGroupHom V₁ g.ker
    where
  toFun v := ⟨f v, by erw [g.mem_ker]; show (g.comp f) v = 0; rw [h]; rfl⟩
  map_add' v w := by simp only [map_add]; rfl
  bound' := f.bound'
#align normed_add_group_hom.ker.lift NormedAddGroupHom.ker.lift

/- warning: normed_add_group_hom.ker.incl_comp_lift -> NormedAddGroupHom.ker.incl_comp_lift is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} {V₃ : Type.{u3}} [_inst_3 : SeminormedAddCommGroup.{u1} V₁] [_inst_4 : SeminormedAddCommGroup.{u2} V₂] [_inst_5 : SeminormedAddCommGroup.{u3} V₃] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4) (g : NormedAddGroupHom.{u2, u3} V₂ V₃ _inst_4 _inst_5) (h : Eq.{max (succ u1) (succ u3)} (NormedAddGroupHom.{u1, u3} V₁ V₃ _inst_3 _inst_5) (NormedAddGroupHom.comp.{u1, u2, u3} V₁ V₂ V₃ _inst_3 _inst_4 _inst_5 g f) (OfNat.ofNat.{max u1 u3} (NormedAddGroupHom.{u1, u3} V₁ V₃ _inst_3 _inst_5) 0 (OfNat.mk.{max u1 u3} (NormedAddGroupHom.{u1, u3} V₁ V₃ _inst_3 _inst_5) 0 (Zero.zero.{max u1 u3} (NormedAddGroupHom.{u1, u3} V₁ V₃ _inst_3 _inst_5) (NormedAddGroupHom.hasZero.{u1, u3} V₁ V₃ _inst_3 _inst_5))))), Eq.{max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4) (NormedAddGroupHom.comp.{u1, u2, u2} V₁ (coeSort.{succ u2, succ (succ u2)} (AddSubgroup.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_4))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubgroup.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_4))) V₂ (AddSubgroup.setLike.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_4)))) (NormedAddGroupHom.ker.{u2, u3} V₂ V₃ _inst_4 _inst_5 g)) V₂ _inst_3 (AddSubgroup.seminormedAddCommGroup.{u2} V₂ _inst_4 (NormedAddGroupHom.ker.{u2, u3} V₂ V₃ _inst_4 _inst_5 g)) _inst_4 (NormedAddGroupHom.incl.{u2} V₂ _inst_4 (NormedAddGroupHom.ker.{u2, u3} V₂ V₃ _inst_4 _inst_5 g)) (NormedAddGroupHom.ker.lift.{u1, u2, u3} V₁ V₂ V₃ _inst_3 _inst_4 _inst_5 f g h)) f
but is expected to have type
  forall {V₁ : Type.{u3}} {V₂ : Type.{u1}} {V₃ : Type.{u2}} [_inst_3 : SeminormedAddCommGroup.{u3} V₁] [_inst_4 : SeminormedAddCommGroup.{u1} V₂] [_inst_5 : SeminormedAddCommGroup.{u2} V₃] (f : NormedAddGroupHom.{u3, u1} V₁ V₂ _inst_3 _inst_4) (g : NormedAddGroupHom.{u1, u2} V₂ V₃ _inst_4 _inst_5) (h : Eq.{max (succ u3) (succ u2)} (NormedAddGroupHom.{u3, u2} V₁ V₃ _inst_3 _inst_5) (NormedAddGroupHom.comp.{u3, u1, u2} V₁ V₂ V₃ _inst_3 _inst_4 _inst_5 g f) (OfNat.ofNat.{max u3 u2} (NormedAddGroupHom.{u3, u2} V₁ V₃ _inst_3 _inst_5) 0 (Zero.toOfNat0.{max u3 u2} (NormedAddGroupHom.{u3, u2} V₁ V₃ _inst_3 _inst_5) (NormedAddGroupHom.zero.{u3, u2} V₁ V₃ _inst_3 _inst_5)))), Eq.{max (succ u3) (succ u1)} (NormedAddGroupHom.{u3, u1} V₁ V₂ _inst_3 _inst_4) (NormedAddGroupHom.comp.{u3, u1, u1} V₁ (Subtype.{succ u1} V₂ (fun (x : V₂) => Membership.mem.{u1, u1} V₂ (AddSubgroup.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_4))) (SetLike.instMembership.{u1, u1} (AddSubgroup.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_4))) V₂ (AddSubgroup.instSetLikeAddSubgroup.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_4)))) x (NormedAddGroupHom.ker.{u1, u2} V₂ V₃ _inst_4 _inst_5 g))) V₂ _inst_3 (AddSubgroup.seminormedAddCommGroup.{u1} V₂ _inst_4 (NormedAddGroupHom.ker.{u1, u2} V₂ V₃ _inst_4 _inst_5 g)) _inst_4 (NormedAddGroupHom.incl.{u1} V₂ _inst_4 (NormedAddGroupHom.ker.{u1, u2} V₂ V₃ _inst_4 _inst_5 g)) (NormedAddGroupHom.ker.lift.{u3, u1, u2} V₁ V₂ V₃ _inst_3 _inst_4 _inst_5 f g h)) f
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.ker.incl_comp_lift NormedAddGroupHom.ker.incl_comp_liftₓ'. -/
@[simp]
theorem ker.incl_comp_lift (h : g.comp f = 0) : (incl g.ker).comp (ker.lift f g h) = f := by ext;
  rfl
#align normed_add_group_hom.ker.incl_comp_lift NormedAddGroupHom.ker.incl_comp_lift

/- warning: normed_add_group_hom.ker_zero -> NormedAddGroupHom.ker_zero is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_3 : SeminormedAddCommGroup.{u1} V₁] [_inst_4 : SeminormedAddCommGroup.{u2} V₂], Eq.{succ u1} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) (NormedAddGroupHom.ker.{u1, u2} V₁ V₂ _inst_3 _inst_4 (OfNat.ofNat.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4) 0 (OfNat.mk.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4) 0 (Zero.zero.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4) (NormedAddGroupHom.hasZero.{u1, u2} V₁ V₂ _inst_3 _inst_4))))) (Top.top.{u1} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) (AddSubgroup.hasTop.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))))
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_3 : SeminormedAddCommGroup.{u2} V₁] [_inst_4 : SeminormedAddCommGroup.{u1} V₂], Eq.{succ u2} (AddSubgroup.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_3))) (NormedAddGroupHom.ker.{u2, u1} V₁ V₂ _inst_3 _inst_4 (OfNat.ofNat.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_3 _inst_4) 0 (Zero.toOfNat0.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_3 _inst_4) (NormedAddGroupHom.zero.{u2, u1} V₁ V₂ _inst_3 _inst_4)))) (Top.top.{u2} (AddSubgroup.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_3))) (AddSubgroup.instTopAddSubgroup.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_3))))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.ker_zero NormedAddGroupHom.ker_zeroₓ'. -/
@[simp]
theorem ker_zero : (0 : NormedAddGroupHom V₁ V₂).ker = ⊤ := by ext; simp [mem_ker]
#align normed_add_group_hom.ker_zero NormedAddGroupHom.ker_zero

/- warning: normed_add_group_hom.coe_ker -> NormedAddGroupHom.coe_ker is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_3 : SeminormedAddCommGroup.{u1} V₁] [_inst_4 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4), Eq.{succ u1} (Set.{u1} V₁) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) (Set.{u1} V₁) (HasLiftT.mk.{succ u1, succ u1} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) (Set.{u1} V₁) (CoeTCₓ.coe.{succ u1, succ u1} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) (Set.{u1} V₁) (SetLike.Set.hasCoeT.{u1, u1} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) V₁ (AddSubgroup.setLike.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3)))))) (NormedAddGroupHom.ker.{u1, u2} V₁ V₂ _inst_3 _inst_4 f)) (Set.preimage.{u1, u2} V₁ V₂ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_3 _inst_4) f) (Singleton.singleton.{u2, u2} V₂ (Set.{u2} V₂) (Set.hasSingleton.{u2} V₂) (OfNat.ofNat.{u2} V₂ 0 (OfNat.mk.{u2} V₂ 0 (Zero.zero.{u2} V₂ (AddZeroClass.toHasZero.{u2} V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_4)))))))))))
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_3 : SeminormedAddCommGroup.{u2} V₁] [_inst_4 : SeminormedAddCommGroup.{u1} V₂] (f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_3 _inst_4), Eq.{succ u2} (Set.{u2} V₁) (SetLike.coe.{u2, u2} (AddSubgroup.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_3))) V₁ (AddSubgroup.instSetLikeAddSubgroup.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_3))) (NormedAddGroupHom.ker.{u2, u1} V₁ V₂ _inst_3 _inst_4 f)) (Set.preimage.{u2, u1} V₁ V₂ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_3 _inst_4) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_3 _inst_4) V₁ V₂ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_3)))))) (AddZeroClass.toAdd.{u1} V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_4)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_3 _inst_4) V₁ V₂ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_3))))) (AddMonoid.toAddZeroClass.{u1} V₂ (SubNegMonoid.toAddMonoid.{u1} V₂ (AddGroup.toSubNegMonoid.{u1} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_4))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V₁ V₂ _inst_3 _inst_4))) f) (Singleton.singleton.{u1, u1} V₂ (Set.{u1} V₂) (Set.instSingletonSet.{u1} V₂) (OfNat.ofNat.{u1} V₂ 0 (Zero.toOfNat0.{u1} V₂ (NegZeroClass.toZero.{u1} V₂ (SubNegZeroMonoid.toNegZeroClass.{u1} V₂ (SubtractionMonoid.toSubNegZeroMonoid.{u1} V₂ (SubtractionCommMonoid.toSubtractionMonoid.{u1} V₂ (AddCommGroup.toDivisionAddCommMonoid.{u1} V₂ (SeminormedAddCommGroup.toAddCommGroup.{u1} V₂ _inst_4))))))))))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.coe_ker NormedAddGroupHom.coe_kerₓ'. -/
theorem coe_ker : (f.ker : Set V₁) = (f : V₁ → V₂) ⁻¹' {0} :=
  rfl
#align normed_add_group_hom.coe_ker NormedAddGroupHom.coe_ker

/- warning: normed_add_group_hom.is_closed_ker -> NormedAddGroupHom.isClosed_ker is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} [_inst_3 : SeminormedAddCommGroup.{u1} V₁] {V₂ : Type.{u2}} [_inst_6 : NormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} V₂ _inst_6)), IsClosed.{u1} V₁ (UniformSpace.toTopologicalSpace.{u1} V₁ (PseudoMetricSpace.toUniformSpace.{u1} V₁ (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} V₁ _inst_3))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) (Set.{u1} V₁) (HasLiftT.mk.{succ u1, succ u1} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) (Set.{u1} V₁) (CoeTCₓ.coe.{succ u1, succ u1} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) (Set.{u1} V₁) (SetLike.Set.hasCoeT.{u1, u1} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) V₁ (AddSubgroup.setLike.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3)))))) (NormedAddGroupHom.ker.{u1, u2} V₁ V₂ _inst_3 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} V₂ _inst_6) f))
but is expected to have type
  forall {V₁ : Type.{u1}} [_inst_3 : SeminormedAddCommGroup.{u1} V₁] {V₂ : Type.{u2}} [_inst_6 : NormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} V₂ _inst_6)), IsClosed.{u1} V₁ (UniformSpace.toTopologicalSpace.{u1} V₁ (PseudoMetricSpace.toUniformSpace.{u1} V₁ (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} V₁ _inst_3))) (SetLike.coe.{u1, u1} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) V₁ (AddSubgroup.instSetLikeAddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) (NormedAddGroupHom.ker.{u1, u2} V₁ V₂ _inst_3 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} V₂ _inst_6) f))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.is_closed_ker NormedAddGroupHom.isClosed_kerₓ'. -/
theorem isClosed_ker {V₂ : Type _} [NormedAddCommGroup V₂] (f : NormedAddGroupHom V₁ V₂) :
    IsClosed (f.ker : Set V₁) :=
  f.coe_ker ▸ IsClosed.preimage f.Continuous (T1Space.t1 0)
#align normed_add_group_hom.is_closed_ker NormedAddGroupHom.isClosed_ker

end Kernels

/-! ### Range -/


section Range

variable (f : NormedAddGroupHom V₁ V₂) (g : NormedAddGroupHom V₂ V₃)

#print NormedAddGroupHom.range /-
/-- The image of a bounded group homomorphism. Naturally endowed with a
`seminormed_add_comm_group` instance. -/
def range : AddSubgroup V₂ :=
  f.toAddMonoidHom.range
#align normed_add_group_hom.range NormedAddGroupHom.range
-/

/- warning: normed_add_group_hom.mem_range -> NormedAddGroupHom.mem_range is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_3 : SeminormedAddCommGroup.{u1} V₁] [_inst_4 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4) (v : V₂), Iff (Membership.Mem.{u2, u2} V₂ (AddSubgroup.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_4))) (SetLike.hasMem.{u2, u2} (AddSubgroup.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_4))) V₂ (AddSubgroup.setLike.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_4)))) v (NormedAddGroupHom.range.{u1, u2} V₁ V₂ _inst_3 _inst_4 f)) (Exists.{succ u1} V₁ (fun (w : V₁) => Eq.{succ u2} V₂ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_3 _inst_4) f w) v))
but is expected to have type
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_3 : SeminormedAddCommGroup.{u1} V₁] [_inst_4 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4) (v : V₂), Iff (Membership.mem.{u2, u2} V₂ (AddSubgroup.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_4))) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_4))) V₂ (AddSubgroup.instSetLikeAddSubgroup.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_4)))) v (NormedAddGroupHom.range.{u1, u2} V₁ V₂ _inst_3 _inst_4 f)) (Exists.{succ u1} V₁ (fun (w : V₁) => Eq.{succ u2} V₂ (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u1 u2, u1, u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4) V₁ V₂ (AddZeroClass.toAdd.{u1} V₁ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3)))))) (AddZeroClass.toAdd.{u2} V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_4)))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4) V₁ V₂ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_4))))) (NormedAddGroupHom.toAddMonoidHomClass.{u1, u2} V₁ V₂ _inst_3 _inst_4))) f w) v))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.mem_range NormedAddGroupHom.mem_rangeₓ'. -/
theorem mem_range (v : V₂) : v ∈ f.range ↔ ∃ w, f w = v := by rw [range, AddMonoidHom.mem_range];
  rfl
#align normed_add_group_hom.mem_range NormedAddGroupHom.mem_range

/- warning: normed_add_group_hom.mem_range_self -> NormedAddGroupHom.mem_range_self is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_3 : SeminormedAddCommGroup.{u1} V₁] [_inst_4 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4) (v : V₁), Membership.Mem.{u2, u2} V₂ (AddSubgroup.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_4))) (SetLike.hasMem.{u2, u2} (AddSubgroup.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_4))) V₂ (AddSubgroup.setLike.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_4)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_3 _inst_4) f v) (NormedAddGroupHom.range.{u1, u2} V₁ V₂ _inst_3 _inst_4 f)
but is expected to have type
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_3 : SeminormedAddCommGroup.{u1} V₁] [_inst_4 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4) (v : V₁), Membership.mem.{u2, u2} V₂ (AddSubgroup.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_4))) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_4))) V₂ (AddSubgroup.instSetLikeAddSubgroup.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_4)))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u1 u2, u1, u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4) V₁ V₂ (AddZeroClass.toAdd.{u1} V₁ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3)))))) (AddZeroClass.toAdd.{u2} V₂ (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_4)))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4) V₁ V₂ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))))) (AddMonoid.toAddZeroClass.{u2} V₂ (SubNegMonoid.toAddMonoid.{u2} V₂ (AddGroup.toSubNegMonoid.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_4))))) (NormedAddGroupHom.toAddMonoidHomClass.{u1, u2} V₁ V₂ _inst_3 _inst_4))) f v) (NormedAddGroupHom.range.{u1, u2} V₁ V₂ _inst_3 _inst_4 f)
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.mem_range_self NormedAddGroupHom.mem_range_selfₓ'. -/
@[simp]
theorem mem_range_self (v : V₁) : f v ∈ f.range :=
  ⟨v, rfl⟩
#align normed_add_group_hom.mem_range_self NormedAddGroupHom.mem_range_self

/- warning: normed_add_group_hom.comp_range -> NormedAddGroupHom.comp_range is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} {V₃ : Type.{u3}} [_inst_3 : SeminormedAddCommGroup.{u1} V₁] [_inst_4 : SeminormedAddCommGroup.{u2} V₂] [_inst_5 : SeminormedAddCommGroup.{u3} V₃] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4) (g : NormedAddGroupHom.{u2, u3} V₂ V₃ _inst_4 _inst_5), Eq.{succ u3} (AddSubgroup.{u3} V₃ (SeminormedAddGroup.toAddGroup.{u3} V₃ (SeminormedAddCommGroup.toSeminormedAddGroup.{u3} V₃ _inst_5))) (NormedAddGroupHom.range.{u1, u3} V₁ V₃ _inst_3 _inst_5 (NormedAddGroupHom.comp.{u1, u2, u3} V₁ V₂ V₃ _inst_3 _inst_4 _inst_5 g f)) (AddSubgroup.map.{u2, u3} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_4)) V₃ (SeminormedAddGroup.toAddGroup.{u3} V₃ (SeminormedAddCommGroup.toSeminormedAddGroup.{u3} V₃ _inst_5)) (NormedAddGroupHom.toAddMonoidHom.{u2, u3} V₂ V₃ _inst_4 _inst_5 g) (NormedAddGroupHom.range.{u1, u2} V₁ V₂ _inst_3 _inst_4 f))
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} {V₃ : Type.{u3}} [_inst_3 : SeminormedAddCommGroup.{u2} V₁] [_inst_4 : SeminormedAddCommGroup.{u1} V₂] [_inst_5 : SeminormedAddCommGroup.{u3} V₃] (f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_3 _inst_4) (g : NormedAddGroupHom.{u1, u3} V₂ V₃ _inst_4 _inst_5), Eq.{succ u3} (AddSubgroup.{u3} V₃ (SeminormedAddGroup.toAddGroup.{u3} V₃ (SeminormedAddCommGroup.toSeminormedAddGroup.{u3} V₃ _inst_5))) (NormedAddGroupHom.range.{u2, u3} V₁ V₃ _inst_3 _inst_5 (NormedAddGroupHom.comp.{u2, u1, u3} V₁ V₂ V₃ _inst_3 _inst_4 _inst_5 g f)) (AddSubgroup.map.{u1, u3} V₂ (SeminormedAddGroup.toAddGroup.{u1} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₂ _inst_4)) V₃ (SeminormedAddGroup.toAddGroup.{u3} V₃ (SeminormedAddCommGroup.toSeminormedAddGroup.{u3} V₃ _inst_5)) (NormedAddGroupHom.toAddMonoidHom.{u1, u3} V₂ V₃ _inst_4 _inst_5 g) (NormedAddGroupHom.range.{u2, u1} V₁ V₂ _inst_3 _inst_4 f))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.comp_range NormedAddGroupHom.comp_rangeₓ'. -/
theorem comp_range : (g.comp f).range = AddSubgroup.map g.toAddMonoidHom f.range := by
  erw [AddMonoidHom.map_range]; rfl
#align normed_add_group_hom.comp_range NormedAddGroupHom.comp_range

/- warning: normed_add_group_hom.incl_range -> NormedAddGroupHom.incl_range is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} [_inst_3 : SeminormedAddCommGroup.{u1} V₁] (s : AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))), Eq.{succ u1} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) (NormedAddGroupHom.range.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) V₁ (AddSubgroup.setLike.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3)))) s) V₁ (AddSubgroup.seminormedAddCommGroup.{u1} V₁ _inst_3 s) _inst_3 (NormedAddGroupHom.incl.{u1} V₁ _inst_3 s)) s
but is expected to have type
  forall {V₁ : Type.{u1}} [_inst_3 : SeminormedAddCommGroup.{u1} V₁] (s : AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))), Eq.{succ u1} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) (NormedAddGroupHom.range.{u1, u1} (Subtype.{succ u1} V₁ (fun (x : V₁) => Membership.mem.{u1, u1} V₁ (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) (SetLike.instMembership.{u1, u1} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) V₁ (AddSubgroup.instSetLikeAddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3)))) x s)) V₁ (AddSubgroup.seminormedAddCommGroup.{u1} V₁ _inst_3 s) _inst_3 (NormedAddGroupHom.incl.{u1} V₁ _inst_3 s)) s
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.incl_range NormedAddGroupHom.incl_rangeₓ'. -/
theorem incl_range (s : AddSubgroup V₁) : (incl s).range = s := by ext x;
  exact ⟨fun ⟨y, hy⟩ => by rw [← hy] <;> simp, fun hx => ⟨⟨x, hx⟩, by simp⟩⟩
#align normed_add_group_hom.incl_range NormedAddGroupHom.incl_range

/- warning: normed_add_group_hom.range_comp_incl_top -> NormedAddGroupHom.range_comp_incl_top is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_3 : SeminormedAddCommGroup.{u1} V₁] [_inst_4 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4), Eq.{succ u2} (AddSubgroup.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_4))) (NormedAddGroupHom.range.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) V₁ (AddSubgroup.setLike.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3)))) (Top.top.{u1} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) (AddSubgroup.hasTop.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))))) V₂ (AddSubgroup.seminormedAddCommGroup.{u1} V₁ _inst_3 (Top.top.{u1} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) (AddSubgroup.hasTop.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))))) _inst_4 (NormedAddGroupHom.comp.{u1, u1, u2} (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) V₁ (AddSubgroup.setLike.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3)))) (Top.top.{u1} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) (AddSubgroup.hasTop.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))))) V₁ V₂ (AddSubgroup.seminormedAddCommGroup.{u1} V₁ _inst_3 (Top.top.{u1} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) (AddSubgroup.hasTop.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))))) _inst_3 _inst_4 f (NormedAddGroupHom.incl.{u1} V₁ _inst_3 (Top.top.{u1} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) (AddSubgroup.hasTop.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))))))) (NormedAddGroupHom.range.{u1, u2} V₁ V₂ _inst_3 _inst_4 f)
but is expected to have type
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_3 : SeminormedAddCommGroup.{u1} V₁] [_inst_4 : SeminormedAddCommGroup.{u2} V₂] (f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4), Eq.{succ u2} (AddSubgroup.{u2} V₂ (SeminormedAddGroup.toAddGroup.{u2} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₂ _inst_4))) (NormedAddGroupHom.range.{u1, u2} (Subtype.{succ u1} V₁ (fun (x : V₁) => Membership.mem.{u1, u1} V₁ (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) (SetLike.instMembership.{u1, u1} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) V₁ (AddSubgroup.instSetLikeAddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3)))) x (Top.top.{u1} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) (AddSubgroup.instTopAddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3)))))) V₂ (AddSubgroup.seminormedAddCommGroup.{u1} V₁ _inst_3 (Top.top.{u1} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) (AddSubgroup.instTopAddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))))) _inst_4 (NormedAddGroupHom.comp.{u1, u1, u2} (Subtype.{succ u1} V₁ (fun (x : V₁) => Membership.mem.{u1, u1} V₁ (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) (SetLike.instMembership.{u1, u1} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) V₁ (AddSubgroup.instSetLikeAddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3)))) x (Top.top.{u1} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) (AddSubgroup.instTopAddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3)))))) V₁ V₂ (AddSubgroup.seminormedAddCommGroup.{u1} V₁ _inst_3 (Top.top.{u1} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) (AddSubgroup.instTopAddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))))) _inst_3 _inst_4 f (NormedAddGroupHom.incl.{u1} V₁ _inst_3 (Top.top.{u1} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) (AddSubgroup.instTopAddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))))))) (NormedAddGroupHom.range.{u1, u2} V₁ V₂ _inst_3 _inst_4 f)
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.range_comp_incl_top NormedAddGroupHom.range_comp_incl_topₓ'. -/
@[simp]
theorem range_comp_incl_top : (f.comp (incl (⊤ : AddSubgroup V₁))).range = f.range := by
  simpa [comp_range, incl_range, ← AddMonoidHom.range_eq_map]
#align normed_add_group_hom.range_comp_incl_top NormedAddGroupHom.range_comp_incl_top

end Range

variable {f : NormedAddGroupHom V W}

#print NormedAddGroupHom.NormNoninc /-
/-- A `normed_add_group_hom` is *norm-nonincreasing* if `‖f v‖ ≤ ‖v‖` for all `v`. -/
def NormNoninc (f : NormedAddGroupHom V W) : Prop :=
  ∀ v, ‖f v‖ ≤ ‖v‖
#align normed_add_group_hom.norm_noninc NormedAddGroupHom.NormNoninc
-/

namespace NormNoninc

/- warning: normed_add_group_hom.norm_noninc.norm_noninc_iff_norm_le_one -> NormedAddGroupHom.NormNoninc.normNoninc_iff_norm_le_one is a dubious translation:
lean 3 declaration is
  forall {V : Type.{u1}} {W : Type.{u2}} [_inst_1 : SeminormedAddCommGroup.{u1} V] [_inst_2 : SeminormedAddCommGroup.{u2} W] {f : NormedAddGroupHom.{u1, u2} V W _inst_1 _inst_2}, Iff (NormedAddGroupHom.NormNoninc.{u1, u2} V W _inst_1 _inst_2 f) (LE.le.{0} Real Real.hasLe (Norm.norm.{max u1 u2} (NormedAddGroupHom.{u1, u2} V W _inst_1 _inst_2) (NormedAddGroupHom.hasOpNorm.{u1, u2} V W _inst_1 _inst_2) f) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))
but is expected to have type
  forall {V : Type.{u2}} {W : Type.{u1}} [_inst_1 : SeminormedAddCommGroup.{u2} V] [_inst_2 : SeminormedAddCommGroup.{u1} W] {f : NormedAddGroupHom.{u2, u1} V W _inst_1 _inst_2}, Iff (NormedAddGroupHom.NormNoninc.{u2, u1} V W _inst_1 _inst_2 f) (LE.le.{0} Real Real.instLEReal (Norm.norm.{max u2 u1} (NormedAddGroupHom.{u2, u1} V W _inst_1 _inst_2) (NormedAddGroupHom.hasOpNorm.{u2, u1} V W _inst_1 _inst_2) f) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.norm_noninc.norm_noninc_iff_norm_le_one NormedAddGroupHom.NormNoninc.normNoninc_iff_norm_le_oneₓ'. -/
theorem normNoninc_iff_norm_le_one : f.NormNoninc ↔ ‖f‖ ≤ 1 :=
  by
  refine' ⟨fun h => _, fun h => fun v => _⟩
  · refine' op_norm_le_bound _ zero_le_one fun v => _
    simpa [one_mul] using h v
  · simpa using le_of_op_norm_le f h v
#align normed_add_group_hom.norm_noninc.norm_noninc_iff_norm_le_one NormedAddGroupHom.NormNoninc.normNoninc_iff_norm_le_one

/- warning: normed_add_group_hom.norm_noninc.zero -> NormedAddGroupHom.NormNoninc.zero is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_3 : SeminormedAddCommGroup.{u1} V₁] [_inst_4 : SeminormedAddCommGroup.{u2} V₂], NormedAddGroupHom.NormNoninc.{u1, u2} V₁ V₂ _inst_3 _inst_4 (OfNat.ofNat.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4) 0 (OfNat.mk.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4) 0 (Zero.zero.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4) (NormedAddGroupHom.hasZero.{u1, u2} V₁ V₂ _inst_3 _inst_4))))
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_3 : SeminormedAddCommGroup.{u2} V₁] [_inst_4 : SeminormedAddCommGroup.{u1} V₂], NormedAddGroupHom.NormNoninc.{u2, u1} V₁ V₂ _inst_3 _inst_4 (OfNat.ofNat.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_3 _inst_4) 0 (Zero.toOfNat0.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_3 _inst_4) (NormedAddGroupHom.zero.{u2, u1} V₁ V₂ _inst_3 _inst_4)))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.norm_noninc.zero NormedAddGroupHom.NormNoninc.zeroₓ'. -/
theorem zero : (0 : NormedAddGroupHom V₁ V₂).NormNoninc := fun v => by simp
#align normed_add_group_hom.norm_noninc.zero NormedAddGroupHom.NormNoninc.zero

#print NormedAddGroupHom.NormNoninc.id /-
theorem id : (id V).NormNoninc := fun v => le_rfl
#align normed_add_group_hom.norm_noninc.id NormedAddGroupHom.NormNoninc.id
-/

/- warning: normed_add_group_hom.norm_noninc.comp -> NormedAddGroupHom.NormNoninc.comp is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} {V₃ : Type.{u3}} [_inst_3 : SeminormedAddCommGroup.{u1} V₁] [_inst_4 : SeminormedAddCommGroup.{u2} V₂] [_inst_5 : SeminormedAddCommGroup.{u3} V₃] {g : NormedAddGroupHom.{u2, u3} V₂ V₃ _inst_4 _inst_5} {f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4}, (NormedAddGroupHom.NormNoninc.{u2, u3} V₂ V₃ _inst_4 _inst_5 g) -> (NormedAddGroupHom.NormNoninc.{u1, u2} V₁ V₂ _inst_3 _inst_4 f) -> (NormedAddGroupHom.NormNoninc.{u1, u3} V₁ V₃ _inst_3 _inst_5 (NormedAddGroupHom.comp.{u1, u2, u3} V₁ V₂ V₃ _inst_3 _inst_4 _inst_5 g f))
but is expected to have type
  forall {V₁ : Type.{u1}} {V₂ : Type.{u3}} {V₃ : Type.{u2}} [_inst_3 : SeminormedAddCommGroup.{u1} V₁] [_inst_4 : SeminormedAddCommGroup.{u3} V₂] [_inst_5 : SeminormedAddCommGroup.{u2} V₃] {g : NormedAddGroupHom.{u3, u2} V₂ V₃ _inst_4 _inst_5} {f : NormedAddGroupHom.{u1, u3} V₁ V₂ _inst_3 _inst_4}, (NormedAddGroupHom.NormNoninc.{u3, u2} V₂ V₃ _inst_4 _inst_5 g) -> (NormedAddGroupHom.NormNoninc.{u1, u3} V₁ V₂ _inst_3 _inst_4 f) -> (NormedAddGroupHom.NormNoninc.{u1, u2} V₁ V₃ _inst_3 _inst_5 (NormedAddGroupHom.comp.{u1, u3, u2} V₁ V₂ V₃ _inst_3 _inst_4 _inst_5 g f))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.norm_noninc.comp NormedAddGroupHom.NormNoninc.compₓ'. -/
theorem comp {g : NormedAddGroupHom V₂ V₃} {f : NormedAddGroupHom V₁ V₂} (hg : g.NormNoninc)
    (hf : f.NormNoninc) : (g.comp f).NormNoninc := fun v => (hg (f v)).trans (hf v)
#align normed_add_group_hom.norm_noninc.comp NormedAddGroupHom.NormNoninc.comp

/- warning: normed_add_group_hom.norm_noninc.neg_iff -> NormedAddGroupHom.NormNoninc.neg_iff is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} [_inst_3 : SeminormedAddCommGroup.{u1} V₁] [_inst_4 : SeminormedAddCommGroup.{u2} V₂] {f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4}, Iff (NormedAddGroupHom.NormNoninc.{u1, u2} V₁ V₂ _inst_3 _inst_4 (Neg.neg.{max u1 u2} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4) (NormedAddGroupHom.hasNeg.{u1, u2} V₁ V₂ _inst_3 _inst_4) f)) (NormedAddGroupHom.NormNoninc.{u1, u2} V₁ V₂ _inst_3 _inst_4 f)
but is expected to have type
  forall {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_3 : SeminormedAddCommGroup.{u2} V₁] [_inst_4 : SeminormedAddCommGroup.{u1} V₂] {f : NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_3 _inst_4}, Iff (NormedAddGroupHom.NormNoninc.{u2, u1} V₁ V₂ _inst_3 _inst_4 (Neg.neg.{max u2 u1} (NormedAddGroupHom.{u2, u1} V₁ V₂ _inst_3 _inst_4) (NormedAddGroupHom.neg.{u2, u1} V₁ V₂ _inst_3 _inst_4) f)) (NormedAddGroupHom.NormNoninc.{u2, u1} V₁ V₂ _inst_3 _inst_4 f)
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.norm_noninc.neg_iff NormedAddGroupHom.NormNoninc.neg_iffₓ'. -/
@[simp]
theorem neg_iff {f : NormedAddGroupHom V₁ V₂} : (-f).NormNoninc ↔ f.NormNoninc :=
  ⟨fun h x => by simpa using h x, fun h x => (norm_neg (f x)).le.trans (h x)⟩
#align normed_add_group_hom.norm_noninc.neg_iff NormedAddGroupHom.NormNoninc.neg_iff

end NormNoninc

section Isometry

/- warning: normed_add_group_hom.norm_eq_of_isometry -> NormedAddGroupHom.norm_eq_of_isometry is a dubious translation:
lean 3 declaration is
  forall {V : Type.{u1}} {W : Type.{u2}} [_inst_1 : SeminormedAddCommGroup.{u1} V] [_inst_2 : SeminormedAddCommGroup.{u2} W] {f : NormedAddGroupHom.{u1, u2} V W _inst_1 _inst_2}, (Isometry.{u1, u2} V W (PseudoMetricSpace.toPseudoEMetricSpace.{u1} V (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} V _inst_1)) (PseudoMetricSpace.toPseudoEMetricSpace.{u2} W (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} W _inst_2)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V W _inst_1 _inst_2) (fun (_x : NormedAddGroupHom.{u1, u2} V W _inst_1 _inst_2) => V -> W) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V W _inst_1 _inst_2) f)) -> (forall (v : V), Eq.{1} Real (Norm.norm.{u2} W (SeminormedAddCommGroup.toHasNorm.{u2} W _inst_2) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V W _inst_1 _inst_2) (fun (_x : NormedAddGroupHom.{u1, u2} V W _inst_1 _inst_2) => V -> W) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V W _inst_1 _inst_2) f v)) (Norm.norm.{u1} V (SeminormedAddCommGroup.toHasNorm.{u1} V _inst_1) v))
but is expected to have type
  forall {V : Type.{u2}} {W : Type.{u1}} [_inst_1 : SeminormedAddCommGroup.{u2} V] [_inst_2 : SeminormedAddCommGroup.{u1} W] {f : NormedAddGroupHom.{u2, u1} V W _inst_1 _inst_2}, (Isometry.{u2, u1} V W (PseudoMetricSpace.toPseudoEMetricSpace.{u2} V (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} V _inst_1)) (PseudoMetricSpace.toPseudoEMetricSpace.{u1} W (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} W _inst_2)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V W _inst_1 _inst_2) V (fun (_x : V) => W) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V W _inst_1 _inst_2) V W (AddZeroClass.toAdd.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (SeminormedAddGroup.toAddGroup.{u2} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V _inst_1)))))) (AddZeroClass.toAdd.{u1} W (AddMonoid.toAddZeroClass.{u1} W (SubNegMonoid.toAddMonoid.{u1} W (AddGroup.toSubNegMonoid.{u1} W (SeminormedAddGroup.toAddGroup.{u1} W (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} W _inst_2)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V W _inst_1 _inst_2) V W (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (SeminormedAddGroup.toAddGroup.{u2} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V _inst_1))))) (AddMonoid.toAddZeroClass.{u1} W (SubNegMonoid.toAddMonoid.{u1} W (AddGroup.toSubNegMonoid.{u1} W (SeminormedAddGroup.toAddGroup.{u1} W (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} W _inst_2))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V W _inst_1 _inst_2))) f)) -> (forall (v : V), Eq.{1} Real (Norm.norm.{u1} W (SeminormedAddCommGroup.toNorm.{u1} W _inst_2) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V W _inst_1 _inst_2) V (fun (_x : V) => W) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V W _inst_1 _inst_2) V W (AddZeroClass.toAdd.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (SeminormedAddGroup.toAddGroup.{u2} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V _inst_1)))))) (AddZeroClass.toAdd.{u1} W (AddMonoid.toAddZeroClass.{u1} W (SubNegMonoid.toAddMonoid.{u1} W (AddGroup.toSubNegMonoid.{u1} W (SeminormedAddGroup.toAddGroup.{u1} W (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} W _inst_2)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V W _inst_1 _inst_2) V W (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (SeminormedAddGroup.toAddGroup.{u2} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V _inst_1))))) (AddMonoid.toAddZeroClass.{u1} W (SubNegMonoid.toAddMonoid.{u1} W (AddGroup.toSubNegMonoid.{u1} W (SeminormedAddGroup.toAddGroup.{u1} W (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} W _inst_2))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V W _inst_1 _inst_2))) f v)) (Norm.norm.{u2} V (SeminormedAddCommGroup.toNorm.{u2} V _inst_1) v))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.norm_eq_of_isometry NormedAddGroupHom.norm_eq_of_isometryₓ'. -/
theorem norm_eq_of_isometry {f : NormedAddGroupHom V W} (hf : Isometry f) (v : V) : ‖f v‖ = ‖v‖ :=
  (AddMonoidHomClass.isometry_iff_norm f).mp hf v
#align normed_add_group_hom.norm_eq_of_isometry NormedAddGroupHom.norm_eq_of_isometry

#print NormedAddGroupHom.isometry_id /-
theorem isometry_id : @Isometry V V _ _ (id V) :=
  isometry_id
#align normed_add_group_hom.isometry_id NormedAddGroupHom.isometry_id
-/

/- warning: normed_add_group_hom.isometry_comp -> NormedAddGroupHom.isometry_comp is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} {V₂ : Type.{u2}} {V₃ : Type.{u3}} [_inst_3 : SeminormedAddCommGroup.{u1} V₁] [_inst_4 : SeminormedAddCommGroup.{u2} V₂] [_inst_5 : SeminormedAddCommGroup.{u3} V₃] {g : NormedAddGroupHom.{u2, u3} V₂ V₃ _inst_4 _inst_5} {f : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4}, (Isometry.{u2, u3} V₂ V₃ (PseudoMetricSpace.toPseudoEMetricSpace.{u2} V₂ (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} V₂ _inst_4)) (PseudoMetricSpace.toPseudoEMetricSpace.{u3} V₃ (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} V₃ _inst_5)) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (NormedAddGroupHom.{u2, u3} V₂ V₃ _inst_4 _inst_5) (fun (_x : NormedAddGroupHom.{u2, u3} V₂ V₃ _inst_4 _inst_5) => V₂ -> V₃) (NormedAddGroupHom.hasCoeToFun.{u2, u3} V₂ V₃ _inst_4 _inst_5) g)) -> (Isometry.{u1, u2} V₁ V₂ (PseudoMetricSpace.toPseudoEMetricSpace.{u1} V₁ (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} V₁ _inst_3)) (PseudoMetricSpace.toPseudoEMetricSpace.{u2} V₂ (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} V₂ _inst_4)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4) (fun (_x : NormedAddGroupHom.{u1, u2} V₁ V₂ _inst_3 _inst_4) => V₁ -> V₂) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V₁ V₂ _inst_3 _inst_4) f)) -> (Isometry.{u1, u3} V₁ V₃ (PseudoMetricSpace.toPseudoEMetricSpace.{u1} V₁ (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} V₁ _inst_3)) (PseudoMetricSpace.toPseudoEMetricSpace.{u3} V₃ (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} V₃ _inst_5)) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (NormedAddGroupHom.{u1, u3} V₁ V₃ _inst_3 _inst_5) (fun (_x : NormedAddGroupHom.{u1, u3} V₁ V₃ _inst_3 _inst_5) => V₁ -> V₃) (NormedAddGroupHom.hasCoeToFun.{u1, u3} V₁ V₃ _inst_3 _inst_5) (NormedAddGroupHom.comp.{u1, u2, u3} V₁ V₂ V₃ _inst_3 _inst_4 _inst_5 g f)))
but is expected to have type
  forall {V₁ : Type.{u1}} {V₂ : Type.{u3}} {V₃ : Type.{u2}} [_inst_3 : SeminormedAddCommGroup.{u1} V₁] [_inst_4 : SeminormedAddCommGroup.{u3} V₂] [_inst_5 : SeminormedAddCommGroup.{u2} V₃] {g : NormedAddGroupHom.{u3, u2} V₂ V₃ _inst_4 _inst_5} {f : NormedAddGroupHom.{u1, u3} V₁ V₂ _inst_3 _inst_4}, (Isometry.{u3, u2} V₂ V₃ (PseudoMetricSpace.toPseudoEMetricSpace.{u3} V₂ (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} V₂ _inst_4)) (PseudoMetricSpace.toPseudoEMetricSpace.{u2} V₃ (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} V₃ _inst_5)) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (NormedAddGroupHom.{u3, u2} V₂ V₃ _inst_4 _inst_5) V₂ (fun (_x : V₂) => V₃) (AddHomClass.toFunLike.{max u3 u2, u3, u2} (NormedAddGroupHom.{u3, u2} V₂ V₃ _inst_4 _inst_5) V₂ V₃ (AddZeroClass.toAdd.{u3} V₂ (AddMonoid.toAddZeroClass.{u3} V₂ (SubNegMonoid.toAddMonoid.{u3} V₂ (AddGroup.toSubNegMonoid.{u3} V₂ (SeminormedAddGroup.toAddGroup.{u3} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u3} V₂ _inst_4)))))) (AddZeroClass.toAdd.{u2} V₃ (AddMonoid.toAddZeroClass.{u2} V₃ (SubNegMonoid.toAddMonoid.{u2} V₃ (AddGroup.toSubNegMonoid.{u2} V₃ (SeminormedAddGroup.toAddGroup.{u2} V₃ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₃ _inst_5)))))) (AddMonoidHomClass.toAddHomClass.{max u3 u2, u3, u2} (NormedAddGroupHom.{u3, u2} V₂ V₃ _inst_4 _inst_5) V₂ V₃ (AddMonoid.toAddZeroClass.{u3} V₂ (SubNegMonoid.toAddMonoid.{u3} V₂ (AddGroup.toSubNegMonoid.{u3} V₂ (SeminormedAddGroup.toAddGroup.{u3} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u3} V₂ _inst_4))))) (AddMonoid.toAddZeroClass.{u2} V₃ (SubNegMonoid.toAddMonoid.{u2} V₃ (AddGroup.toSubNegMonoid.{u2} V₃ (SeminormedAddGroup.toAddGroup.{u2} V₃ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₃ _inst_5))))) (NormedAddGroupHom.toAddMonoidHomClass.{u3, u2} V₂ V₃ _inst_4 _inst_5))) g)) -> (Isometry.{u1, u3} V₁ V₂ (PseudoMetricSpace.toPseudoEMetricSpace.{u1} V₁ (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} V₁ _inst_3)) (PseudoMetricSpace.toPseudoEMetricSpace.{u3} V₂ (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} V₂ _inst_4)) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (NormedAddGroupHom.{u1, u3} V₁ V₂ _inst_3 _inst_4) V₁ (fun (_x : V₁) => V₂) (AddHomClass.toFunLike.{max u1 u3, u1, u3} (NormedAddGroupHom.{u1, u3} V₁ V₂ _inst_3 _inst_4) V₁ V₂ (AddZeroClass.toAdd.{u1} V₁ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3)))))) (AddZeroClass.toAdd.{u3} V₂ (AddMonoid.toAddZeroClass.{u3} V₂ (SubNegMonoid.toAddMonoid.{u3} V₂ (AddGroup.toSubNegMonoid.{u3} V₂ (SeminormedAddGroup.toAddGroup.{u3} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u3} V₂ _inst_4)))))) (AddMonoidHomClass.toAddHomClass.{max u1 u3, u1, u3} (NormedAddGroupHom.{u1, u3} V₁ V₂ _inst_3 _inst_4) V₁ V₂ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))))) (AddMonoid.toAddZeroClass.{u3} V₂ (SubNegMonoid.toAddMonoid.{u3} V₂ (AddGroup.toSubNegMonoid.{u3} V₂ (SeminormedAddGroup.toAddGroup.{u3} V₂ (SeminormedAddCommGroup.toSeminormedAddGroup.{u3} V₂ _inst_4))))) (NormedAddGroupHom.toAddMonoidHomClass.{u1, u3} V₁ V₂ _inst_3 _inst_4))) f)) -> (Isometry.{u1, u2} V₁ V₃ (PseudoMetricSpace.toPseudoEMetricSpace.{u1} V₁ (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} V₁ _inst_3)) (PseudoMetricSpace.toPseudoEMetricSpace.{u2} V₃ (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} V₃ _inst_5)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (NormedAddGroupHom.{u1, u2} V₁ V₃ _inst_3 _inst_5) V₁ (fun (_x : V₁) => V₃) (AddHomClass.toFunLike.{max u1 u2, u1, u2} (NormedAddGroupHom.{u1, u2} V₁ V₃ _inst_3 _inst_5) V₁ V₃ (AddZeroClass.toAdd.{u1} V₁ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3)))))) (AddZeroClass.toAdd.{u2} V₃ (AddMonoid.toAddZeroClass.{u2} V₃ (SubNegMonoid.toAddMonoid.{u2} V₃ (AddGroup.toSubNegMonoid.{u2} V₃ (SeminormedAddGroup.toAddGroup.{u2} V₃ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₃ _inst_5)))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} (NormedAddGroupHom.{u1, u2} V₁ V₃ _inst_3 _inst_5) V₁ V₃ (AddMonoid.toAddZeroClass.{u1} V₁ (SubNegMonoid.toAddMonoid.{u1} V₁ (AddGroup.toSubNegMonoid.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))))) (AddMonoid.toAddZeroClass.{u2} V₃ (SubNegMonoid.toAddMonoid.{u2} V₃ (AddGroup.toSubNegMonoid.{u2} V₃ (SeminormedAddGroup.toAddGroup.{u2} V₃ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₃ _inst_5))))) (NormedAddGroupHom.toAddMonoidHomClass.{u1, u2} V₁ V₃ _inst_3 _inst_5))) (NormedAddGroupHom.comp.{u1, u3, u2} V₁ V₂ V₃ _inst_3 _inst_4 _inst_5 g f)))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.isometry_comp NormedAddGroupHom.isometry_compₓ'. -/
theorem isometry_comp {g : NormedAddGroupHom V₂ V₃} {f : NormedAddGroupHom V₁ V₂} (hg : Isometry g)
    (hf : Isometry f) : Isometry (g.comp f) :=
  hg.comp hf
#align normed_add_group_hom.isometry_comp NormedAddGroupHom.isometry_comp

/- warning: normed_add_group_hom.norm_noninc_of_isometry -> NormedAddGroupHom.normNoninc_of_isometry is a dubious translation:
lean 3 declaration is
  forall {V : Type.{u1}} {W : Type.{u2}} [_inst_1 : SeminormedAddCommGroup.{u1} V] [_inst_2 : SeminormedAddCommGroup.{u2} W] {f : NormedAddGroupHom.{u1, u2} V W _inst_1 _inst_2}, (Isometry.{u1, u2} V W (PseudoMetricSpace.toPseudoEMetricSpace.{u1} V (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} V _inst_1)) (PseudoMetricSpace.toPseudoEMetricSpace.{u2} W (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} W _inst_2)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V W _inst_1 _inst_2) (fun (_x : NormedAddGroupHom.{u1, u2} V W _inst_1 _inst_2) => V -> W) (NormedAddGroupHom.hasCoeToFun.{u1, u2} V W _inst_1 _inst_2) f)) -> (NormedAddGroupHom.NormNoninc.{u1, u2} V W _inst_1 _inst_2 f)
but is expected to have type
  forall {V : Type.{u2}} {W : Type.{u1}} [_inst_1 : SeminormedAddCommGroup.{u2} V] [_inst_2 : SeminormedAddCommGroup.{u1} W] {f : NormedAddGroupHom.{u2, u1} V W _inst_1 _inst_2}, (Isometry.{u2, u1} V W (PseudoMetricSpace.toPseudoEMetricSpace.{u2} V (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} V _inst_1)) (PseudoMetricSpace.toPseudoEMetricSpace.{u1} W (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} W _inst_2)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NormedAddGroupHom.{u2, u1} V W _inst_1 _inst_2) V (fun (_x : V) => W) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V W _inst_1 _inst_2) V W (AddZeroClass.toAdd.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (SeminormedAddGroup.toAddGroup.{u2} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V _inst_1)))))) (AddZeroClass.toAdd.{u1} W (AddMonoid.toAddZeroClass.{u1} W (SubNegMonoid.toAddMonoid.{u1} W (AddGroup.toSubNegMonoid.{u1} W (SeminormedAddGroup.toAddGroup.{u1} W (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} W _inst_2)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NormedAddGroupHom.{u2, u1} V W _inst_1 _inst_2) V W (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (SeminormedAddGroup.toAddGroup.{u2} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V _inst_1))))) (AddMonoid.toAddZeroClass.{u1} W (SubNegMonoid.toAddMonoid.{u1} W (AddGroup.toSubNegMonoid.{u1} W (SeminormedAddGroup.toAddGroup.{u1} W (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} W _inst_2))))) (NormedAddGroupHom.toAddMonoidHomClass.{u2, u1} V W _inst_1 _inst_2))) f)) -> (NormedAddGroupHom.NormNoninc.{u2, u1} V W _inst_1 _inst_2 f)
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.norm_noninc_of_isometry NormedAddGroupHom.normNoninc_of_isometryₓ'. -/
theorem normNoninc_of_isometry (hf : Isometry f) : f.NormNoninc := fun v =>
  le_of_eq <| norm_eq_of_isometry hf v
#align normed_add_group_hom.norm_noninc_of_isometry NormedAddGroupHom.normNoninc_of_isometry

end Isometry

variable {W₁ W₂ W₃ : Type _} [SeminormedAddCommGroup W₁] [SeminormedAddCommGroup W₂]
  [SeminormedAddCommGroup W₃]

variable (f) (g : NormedAddGroupHom V W)

variable {f₁ g₁ : NormedAddGroupHom V₁ W₁}

variable {f₂ g₂ : NormedAddGroupHom V₂ W₂}

variable {f₃ g₃ : NormedAddGroupHom V₃ W₃}

#print NormedAddGroupHom.equalizer /-
/-- The equalizer of two morphisms `f g : normed_add_group_hom V W`. -/
def equalizer :=
  (f - g).ker
#align normed_add_group_hom.equalizer NormedAddGroupHom.equalizer
-/

namespace Equalizer

/- warning: normed_add_group_hom.equalizer.ι -> NormedAddGroupHom.Equalizer.ι is a dubious translation:
lean 3 declaration is
  forall {V : Type.{u1}} {W : Type.{u2}} [_inst_1 : SeminormedAddCommGroup.{u1} V] [_inst_2 : SeminormedAddCommGroup.{u2} W] (f : NormedAddGroupHom.{u1, u2} V W _inst_1 _inst_2) (g : NormedAddGroupHom.{u1, u2} V W _inst_1 _inst_2), NormedAddGroupHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))) V (AddSubgroup.setLike.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1)))) (NormedAddGroupHom.equalizer.{u1, u2} V W _inst_1 _inst_2 f g)) V (AddSubgroup.seminormedAddCommGroup.{u1} V _inst_1 (NormedAddGroupHom.equalizer.{u1, u2} V W _inst_1 _inst_2 f g)) _inst_1
but is expected to have type
  forall {V : Type.{u1}} {W : Type.{u2}} [_inst_1 : SeminormedAddCommGroup.{u1} V] [_inst_2 : SeminormedAddCommGroup.{u2} W] (f : NormedAddGroupHom.{u1, u2} V W _inst_1 _inst_2) (g : NormedAddGroupHom.{u1, u2} V W _inst_1 _inst_2), NormedAddGroupHom.{u1, u1} (Subtype.{succ u1} V (fun (x : V) => Membership.mem.{u1, u1} V (AddSubgroup.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))) (SetLike.instMembership.{u1, u1} (AddSubgroup.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))) V (AddSubgroup.instSetLikeAddSubgroup.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1)))) x (NormedAddGroupHom.equalizer.{u1, u2} V W _inst_1 _inst_2 f g))) V (AddSubgroup.seminormedAddCommGroup.{u1} V _inst_1 (NormedAddGroupHom.equalizer.{u1, u2} V W _inst_1 _inst_2 f g)) _inst_1
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.equalizer.ι NormedAddGroupHom.Equalizer.ιₓ'. -/
/-- The inclusion of `f.equalizer g` as a `normed_add_group_hom`. -/
def ι : NormedAddGroupHom (f.equalizer g) V :=
  incl _
#align normed_add_group_hom.equalizer.ι NormedAddGroupHom.Equalizer.ι

/- warning: normed_add_group_hom.equalizer.comp_ι_eq -> NormedAddGroupHom.Equalizer.comp_ι_eq is a dubious translation:
lean 3 declaration is
  forall {V : Type.{u1}} {W : Type.{u2}} [_inst_1 : SeminormedAddCommGroup.{u1} V] [_inst_2 : SeminormedAddCommGroup.{u2} W] (f : NormedAddGroupHom.{u1, u2} V W _inst_1 _inst_2) (g : NormedAddGroupHom.{u1, u2} V W _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))) V (AddSubgroup.setLike.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1)))) (NormedAddGroupHom.equalizer.{u1, u2} V W _inst_1 _inst_2 f g)) W (AddSubgroup.seminormedAddCommGroup.{u1} V _inst_1 (NormedAddGroupHom.equalizer.{u1, u2} V W _inst_1 _inst_2 f g)) _inst_2) (NormedAddGroupHom.comp.{u1, u1, u2} (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))) V (AddSubgroup.setLike.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1)))) (NormedAddGroupHom.equalizer.{u1, u2} V W _inst_1 _inst_2 f g)) V W (AddSubgroup.seminormedAddCommGroup.{u1} V _inst_1 (NormedAddGroupHom.equalizer.{u1, u2} V W _inst_1 _inst_2 f g)) _inst_1 _inst_2 f (NormedAddGroupHom.Equalizer.ι.{u1, u2} V W _inst_1 _inst_2 f g)) (NormedAddGroupHom.comp.{u1, u1, u2} (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))) V (AddSubgroup.setLike.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1)))) (NormedAddGroupHom.equalizer.{u1, u2} V W _inst_1 _inst_2 f g)) V W (AddSubgroup.seminormedAddCommGroup.{u1} V _inst_1 (NormedAddGroupHom.equalizer.{u1, u2} V W _inst_1 _inst_2 f g)) _inst_1 _inst_2 g (NormedAddGroupHom.Equalizer.ι.{u1, u2} V W _inst_1 _inst_2 f g))
but is expected to have type
  forall {V : Type.{u2}} {W : Type.{u1}} [_inst_1 : SeminormedAddCommGroup.{u2} V] [_inst_2 : SeminormedAddCommGroup.{u1} W] (f : NormedAddGroupHom.{u2, u1} V W _inst_1 _inst_2) (g : NormedAddGroupHom.{u2, u1} V W _inst_1 _inst_2), Eq.{max (succ u2) (succ u1)} (NormedAddGroupHom.{u2, u1} (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (AddSubgroup.{u2} V (SeminormedAddGroup.toAddGroup.{u2} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} V (SeminormedAddGroup.toAddGroup.{u2} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V _inst_1))) V (AddSubgroup.instSetLikeAddSubgroup.{u2} V (SeminormedAddGroup.toAddGroup.{u2} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V _inst_1)))) x (NormedAddGroupHom.equalizer.{u2, u1} V W _inst_1 _inst_2 f g))) W (AddSubgroup.seminormedAddCommGroup.{u2} V _inst_1 (NormedAddGroupHom.equalizer.{u2, u1} V W _inst_1 _inst_2 f g)) _inst_2) (NormedAddGroupHom.comp.{u2, u2, u1} (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (AddSubgroup.{u2} V (SeminormedAddGroup.toAddGroup.{u2} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} V (SeminormedAddGroup.toAddGroup.{u2} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V _inst_1))) V (AddSubgroup.instSetLikeAddSubgroup.{u2} V (SeminormedAddGroup.toAddGroup.{u2} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V _inst_1)))) x (NormedAddGroupHom.equalizer.{u2, u1} V W _inst_1 _inst_2 f g))) V W (AddSubgroup.seminormedAddCommGroup.{u2} V _inst_1 (NormedAddGroupHom.equalizer.{u2, u1} V W _inst_1 _inst_2 f g)) _inst_1 _inst_2 f (NormedAddGroupHom.Equalizer.ι.{u2, u1} V W _inst_1 _inst_2 f g)) (NormedAddGroupHom.comp.{u2, u2, u1} (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (AddSubgroup.{u2} V (SeminormedAddGroup.toAddGroup.{u2} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} V (SeminormedAddGroup.toAddGroup.{u2} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V _inst_1))) V (AddSubgroup.instSetLikeAddSubgroup.{u2} V (SeminormedAddGroup.toAddGroup.{u2} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V _inst_1)))) x (NormedAddGroupHom.equalizer.{u2, u1} V W _inst_1 _inst_2 f g))) V W (AddSubgroup.seminormedAddCommGroup.{u2} V _inst_1 (NormedAddGroupHom.equalizer.{u2, u1} V W _inst_1 _inst_2 f g)) _inst_1 _inst_2 g (NormedAddGroupHom.Equalizer.ι.{u2, u1} V W _inst_1 _inst_2 f g))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.equalizer.comp_ι_eq NormedAddGroupHom.Equalizer.comp_ι_eqₓ'. -/
theorem comp_ι_eq : f.comp (ι f g) = g.comp (ι f g) := by ext;
  rw [comp_apply, comp_apply, ← sub_eq_zero, ← NormedAddGroupHom.sub_apply]; exact x.2
#align normed_add_group_hom.equalizer.comp_ι_eq NormedAddGroupHom.Equalizer.comp_ι_eq

variable {f g}

/- warning: normed_add_group_hom.equalizer.lift -> NormedAddGroupHom.Equalizer.lift is a dubious translation:
lean 3 declaration is
  forall {V : Type.{u1}} {W : Type.{u2}} {V₁ : Type.{u3}} [_inst_1 : SeminormedAddCommGroup.{u1} V] [_inst_2 : SeminormedAddCommGroup.{u2} W] [_inst_3 : SeminormedAddCommGroup.{u3} V₁] {f : NormedAddGroupHom.{u1, u2} V W _inst_1 _inst_2} {g : NormedAddGroupHom.{u1, u2} V W _inst_1 _inst_2} (φ : NormedAddGroupHom.{u3, u1} V₁ V _inst_3 _inst_1), (Eq.{max (succ u3) (succ u2)} (NormedAddGroupHom.{u3, u2} V₁ W _inst_3 _inst_2) (NormedAddGroupHom.comp.{u3, u1, u2} V₁ V W _inst_3 _inst_1 _inst_2 f φ) (NormedAddGroupHom.comp.{u3, u1, u2} V₁ V W _inst_3 _inst_1 _inst_2 g φ)) -> (NormedAddGroupHom.{u3, u1} V₁ (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))) V (AddSubgroup.setLike.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1)))) (NormedAddGroupHom.equalizer.{u1, u2} V W _inst_1 _inst_2 f g)) _inst_3 (AddSubgroup.seminormedAddCommGroup.{u1} V _inst_1 (NormedAddGroupHom.equalizer.{u1, u2} V W _inst_1 _inst_2 f g)))
but is expected to have type
  forall {V : Type.{u1}} {W : Type.{u2}} {V₁ : Type.{u3}} [_inst_1 : SeminormedAddCommGroup.{u1} V] [_inst_2 : SeminormedAddCommGroup.{u2} W] [_inst_3 : SeminormedAddCommGroup.{u3} V₁] {f : NormedAddGroupHom.{u1, u2} V W _inst_1 _inst_2} {g : NormedAddGroupHom.{u1, u2} V W _inst_1 _inst_2} (φ : NormedAddGroupHom.{u3, u1} V₁ V _inst_3 _inst_1), (Eq.{max (succ u2) (succ u3)} (NormedAddGroupHom.{u3, u2} V₁ W _inst_3 _inst_2) (NormedAddGroupHom.comp.{u3, u1, u2} V₁ V W _inst_3 _inst_1 _inst_2 f φ) (NormedAddGroupHom.comp.{u3, u1, u2} V₁ V W _inst_3 _inst_1 _inst_2 g φ)) -> (NormedAddGroupHom.{u3, u1} V₁ (Subtype.{succ u1} V (fun (x : V) => Membership.mem.{u1, u1} V (AddSubgroup.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))) (SetLike.instMembership.{u1, u1} (AddSubgroup.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))) V (AddSubgroup.instSetLikeAddSubgroup.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1)))) x (NormedAddGroupHom.equalizer.{u1, u2} V W _inst_1 _inst_2 f g))) _inst_3 (AddSubgroup.seminormedAddCommGroup.{u1} V _inst_1 (NormedAddGroupHom.equalizer.{u1, u2} V W _inst_1 _inst_2 f g)))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.equalizer.lift NormedAddGroupHom.Equalizer.liftₓ'. -/
/-- If `φ : normed_add_group_hom V₁ V` is such that `f.comp φ = g.comp φ`, the induced morphism
`normed_add_group_hom V₁ (f.equalizer g)`. -/
@[simps]
def lift (φ : NormedAddGroupHom V₁ V) (h : f.comp φ = g.comp φ) :
    NormedAddGroupHom V₁ (f.equalizer g)
    where
  toFun v :=
    ⟨φ v,
      show (f - g) (φ v) = 0 by
        rw [NormedAddGroupHom.sub_apply, sub_eq_zero, ← comp_apply, h, comp_apply]⟩
  map_add' v₁ v₂ := by ext; simp only [map_add, AddSubgroup.coe_add, Subtype.coe_mk]
  bound' := by obtain ⟨C, C_pos, hC⟩ := φ.bound; exact ⟨C, hC⟩
#align normed_add_group_hom.equalizer.lift NormedAddGroupHom.Equalizer.lift

/- warning: normed_add_group_hom.equalizer.ι_comp_lift -> NormedAddGroupHom.Equalizer.ι_comp_lift is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.equalizer.ι_comp_lift NormedAddGroupHom.Equalizer.ι_comp_liftₓ'. -/
@[simp]
theorem ι_comp_lift (φ : NormedAddGroupHom V₁ V) (h : f.comp φ = g.comp φ) :
    (ι _ _).comp (lift φ h) = φ := by ext; rfl
#align normed_add_group_hom.equalizer.ι_comp_lift NormedAddGroupHom.Equalizer.ι_comp_lift

/- warning: normed_add_group_hom.equalizer.lift_equiv -> NormedAddGroupHom.Equalizer.liftEquiv is a dubious translation:
lean 3 declaration is
  forall {V : Type.{u1}} {W : Type.{u2}} {V₁ : Type.{u3}} [_inst_1 : SeminormedAddCommGroup.{u1} V] [_inst_2 : SeminormedAddCommGroup.{u2} W] [_inst_3 : SeminormedAddCommGroup.{u3} V₁] {f : NormedAddGroupHom.{u1, u2} V W _inst_1 _inst_2} {g : NormedAddGroupHom.{u1, u2} V W _inst_1 _inst_2}, Equiv.{max 1 (succ u3) (succ u1), max (succ u3) (succ u1)} (Subtype.{max (succ u3) (succ u1)} (NormedAddGroupHom.{u3, u1} V₁ V _inst_3 _inst_1) (fun (φ : NormedAddGroupHom.{u3, u1} V₁ V _inst_3 _inst_1) => Eq.{max (succ u3) (succ u2)} (NormedAddGroupHom.{u3, u2} V₁ W _inst_3 _inst_2) (NormedAddGroupHom.comp.{u3, u1, u2} V₁ V W _inst_3 _inst_1 _inst_2 f φ) (NormedAddGroupHom.comp.{u3, u1, u2} V₁ V W _inst_3 _inst_1 _inst_2 g φ))) (NormedAddGroupHom.{u3, u1} V₁ (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))) V (AddSubgroup.setLike.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1)))) (NormedAddGroupHom.equalizer.{u1, u2} V W _inst_1 _inst_2 f g)) _inst_3 (AddSubgroup.seminormedAddCommGroup.{u1} V _inst_1 (NormedAddGroupHom.equalizer.{u1, u2} V W _inst_1 _inst_2 f g)))
but is expected to have type
  forall {V : Type.{u1}} {W : Type.{u2}} {V₁ : Type.{u3}} [_inst_1 : SeminormedAddCommGroup.{u1} V] [_inst_2 : SeminormedAddCommGroup.{u2} W] [_inst_3 : SeminormedAddCommGroup.{u3} V₁] {f : NormedAddGroupHom.{u1, u2} V W _inst_1 _inst_2} {g : NormedAddGroupHom.{u1, u2} V W _inst_1 _inst_2}, Equiv.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Subtype.{max (succ u1) (succ u3)} (NormedAddGroupHom.{u3, u1} V₁ V _inst_3 _inst_1) (fun (φ : NormedAddGroupHom.{u3, u1} V₁ V _inst_3 _inst_1) => Eq.{max (succ u2) (succ u3)} (NormedAddGroupHom.{u3, u2} V₁ W _inst_3 _inst_2) (NormedAddGroupHom.comp.{u3, u1, u2} V₁ V W _inst_3 _inst_1 _inst_2 f φ) (NormedAddGroupHom.comp.{u3, u1, u2} V₁ V W _inst_3 _inst_1 _inst_2 g φ))) (NormedAddGroupHom.{u3, u1} V₁ (Subtype.{succ u1} V (fun (x : V) => Membership.mem.{u1, u1} V (AddSubgroup.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))) (SetLike.instMembership.{u1, u1} (AddSubgroup.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))) V (AddSubgroup.instSetLikeAddSubgroup.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1)))) x (NormedAddGroupHom.equalizer.{u1, u2} V W _inst_1 _inst_2 f g))) _inst_3 (AddSubgroup.seminormedAddCommGroup.{u1} V _inst_1 (NormedAddGroupHom.equalizer.{u1, u2} V W _inst_1 _inst_2 f g)))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.equalizer.lift_equiv NormedAddGroupHom.Equalizer.liftEquivₓ'. -/
/-- The lifting property of the equalizer as an equivalence. -/
@[simps]
def liftEquiv :
    { φ : NormedAddGroupHom V₁ V // f.comp φ = g.comp φ } ≃ NormedAddGroupHom V₁ (f.equalizer g)
    where
  toFun φ := lift φ φ.Prop
  invFun ψ := ⟨(ι f g).comp ψ, by rw [← comp_assoc, ← comp_assoc, comp_ι_eq]⟩
  left_inv φ := by simp
  right_inv ψ := by ext; rfl
#align normed_add_group_hom.equalizer.lift_equiv NormedAddGroupHom.Equalizer.liftEquiv

/- warning: normed_add_group_hom.equalizer.map -> NormedAddGroupHom.Equalizer.map is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.equalizer.map NormedAddGroupHom.Equalizer.mapₓ'. -/
/-- Given `φ : normed_add_group_hom V₁ V₂` and `ψ : normed_add_group_hom W₁ W₂` such that
`ψ.comp f₁ = f₂.comp φ` and `ψ.comp g₁ = g₂.comp φ`, the induced morphism
`normed_add_group_hom (f₁.equalizer g₁) (f₂.equalizer g₂)`. -/
def map (φ : NormedAddGroupHom V₁ V₂) (ψ : NormedAddGroupHom W₁ W₂) (hf : ψ.comp f₁ = f₂.comp φ)
    (hg : ψ.comp g₁ = g₂.comp φ) : NormedAddGroupHom (f₁.equalizer g₁) (f₂.equalizer g₂) :=
  lift (φ.comp <| ι _ _) <| by simp only [← comp_assoc, ← hf, ← hg];
    simp only [comp_assoc, comp_ι_eq]
#align normed_add_group_hom.equalizer.map NormedAddGroupHom.Equalizer.map

variable {φ : NormedAddGroupHom V₁ V₂} {ψ : NormedAddGroupHom W₁ W₂}

variable {φ' : NormedAddGroupHom V₂ V₃} {ψ' : NormedAddGroupHom W₂ W₃}

/- warning: normed_add_group_hom.equalizer.ι_comp_map -> NormedAddGroupHom.Equalizer.ι_comp_map is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.equalizer.ι_comp_map NormedAddGroupHom.Equalizer.ι_comp_mapₓ'. -/
@[simp]
theorem ι_comp_map (hf : ψ.comp f₁ = f₂.comp φ) (hg : ψ.comp g₁ = g₂.comp φ) :
    (ι f₂ g₂).comp (map φ ψ hf hg) = φ.comp (ι _ _) :=
  ι_comp_lift _ _
#align normed_add_group_hom.equalizer.ι_comp_map NormedAddGroupHom.Equalizer.ι_comp_map

/- warning: normed_add_group_hom.equalizer.map_id -> NormedAddGroupHom.Equalizer.map_id is a dubious translation:
lean 3 declaration is
  forall {V₁ : Type.{u1}} [_inst_3 : SeminormedAddCommGroup.{u1} V₁] {W₁ : Type.{u2}} [_inst_6 : SeminormedAddCommGroup.{u2} W₁] {f₁ : NormedAddGroupHom.{u1, u2} V₁ W₁ _inst_3 _inst_6} {g₁ : NormedAddGroupHom.{u1, u2} V₁ W₁ _inst_3 _inst_6}, Eq.{succ u1} (NormedAddGroupHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) V₁ (AddSubgroup.setLike.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3)))) (NormedAddGroupHom.equalizer.{u1, u2} V₁ W₁ _inst_3 _inst_6 f₁ g₁)) (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) V₁ (AddSubgroup.setLike.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3)))) (NormedAddGroupHom.equalizer.{u1, u2} V₁ W₁ _inst_3 _inst_6 f₁ g₁)) (AddSubgroup.seminormedAddCommGroup.{u1} V₁ _inst_3 (NormedAddGroupHom.equalizer.{u1, u2} V₁ W₁ _inst_3 _inst_6 f₁ g₁)) (AddSubgroup.seminormedAddCommGroup.{u1} V₁ _inst_3 (NormedAddGroupHom.equalizer.{u1, u2} V₁ W₁ _inst_3 _inst_6 f₁ g₁))) (NormedAddGroupHom.Equalizer.map.{u1, u1, u2, u2} V₁ V₁ _inst_3 _inst_3 W₁ W₁ _inst_6 _inst_6 f₁ g₁ f₁ g₁ (NormedAddGroupHom.id.{u1} V₁ _inst_3) (NormedAddGroupHom.id.{u2} W₁ _inst_6) (rfl.{max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ W₁ _inst_3 _inst_6) (NormedAddGroupHom.comp.{u1, u2, u2} V₁ W₁ W₁ _inst_3 _inst_6 _inst_6 (NormedAddGroupHom.id.{u2} W₁ _inst_6) f₁)) (rfl.{max (succ u1) (succ u2)} (NormedAddGroupHom.{u1, u2} V₁ W₁ _inst_3 _inst_6) (NormedAddGroupHom.comp.{u1, u2, u2} V₁ W₁ W₁ _inst_3 _inst_6 _inst_6 (NormedAddGroupHom.id.{u2} W₁ _inst_6) g₁))) (NormedAddGroupHom.id.{u1} (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3))) V₁ (AddSubgroup.setLike.{u1} V₁ (SeminormedAddGroup.toAddGroup.{u1} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V₁ _inst_3)))) (NormedAddGroupHom.equalizer.{u1, u2} V₁ W₁ _inst_3 _inst_6 f₁ g₁)) (AddSubgroup.seminormedAddCommGroup.{u1} V₁ _inst_3 (NormedAddGroupHom.equalizer.{u1, u2} V₁ W₁ _inst_3 _inst_6 f₁ g₁)))
but is expected to have type
  forall {V₁ : Type.{u2}} [_inst_3 : SeminormedAddCommGroup.{u2} V₁] {W₁ : Type.{u1}} [_inst_6 : SeminormedAddCommGroup.{u1} W₁] {f₁ : NormedAddGroupHom.{u2, u1} V₁ W₁ _inst_3 _inst_6} {g₁ : NormedAddGroupHom.{u2, u1} V₁ W₁ _inst_3 _inst_6}, Eq.{succ u2} (NormedAddGroupHom.{u2, u2} (Subtype.{succ u2} V₁ (fun (x : V₁) => Membership.mem.{u2, u2} V₁ (AddSubgroup.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_3))) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_3))) V₁ (AddSubgroup.instSetLikeAddSubgroup.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_3)))) x (NormedAddGroupHom.equalizer.{u2, u1} V₁ W₁ _inst_3 _inst_6 f₁ g₁))) (Subtype.{succ u2} V₁ (fun (x : V₁) => Membership.mem.{u2, u2} V₁ (AddSubgroup.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_3))) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_3))) V₁ (AddSubgroup.instSetLikeAddSubgroup.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_3)))) x (NormedAddGroupHom.equalizer.{u2, u1} V₁ W₁ _inst_3 _inst_6 f₁ g₁))) (AddSubgroup.seminormedAddCommGroup.{u2} V₁ _inst_3 (NormedAddGroupHom.equalizer.{u2, u1} V₁ W₁ _inst_3 _inst_6 f₁ g₁)) (AddSubgroup.seminormedAddCommGroup.{u2} V₁ _inst_3 (NormedAddGroupHom.equalizer.{u2, u1} V₁ W₁ _inst_3 _inst_6 f₁ g₁))) (NormedAddGroupHom.Equalizer.map.{u2, u2, u1, u1} V₁ V₁ _inst_3 _inst_3 W₁ W₁ _inst_6 _inst_6 f₁ g₁ f₁ g₁ (NormedAddGroupHom.id.{u2} V₁ _inst_3) (NormedAddGroupHom.id.{u1} W₁ _inst_6) (rfl.{max (succ u2) (succ u1)} (NormedAddGroupHom.{u2, u1} V₁ W₁ _inst_3 _inst_6) (NormedAddGroupHom.comp.{u2, u1, u1} V₁ W₁ W₁ _inst_3 _inst_6 _inst_6 (NormedAddGroupHom.id.{u1} W₁ _inst_6) f₁)) (rfl.{max (succ u2) (succ u1)} (NormedAddGroupHom.{u2, u1} V₁ W₁ _inst_3 _inst_6) (NormedAddGroupHom.comp.{u2, u1, u1} V₁ W₁ W₁ _inst_3 _inst_6 _inst_6 (NormedAddGroupHom.id.{u1} W₁ _inst_6) g₁))) (NormedAddGroupHom.id.{u2} (Subtype.{succ u2} V₁ (fun (x : V₁) => Membership.mem.{u2, u2} V₁ (AddSubgroup.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_3))) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_3))) V₁ (AddSubgroup.instSetLikeAddSubgroup.{u2} V₁ (SeminormedAddGroup.toAddGroup.{u2} V₁ (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V₁ _inst_3)))) x (NormedAddGroupHom.equalizer.{u2, u1} V₁ W₁ _inst_3 _inst_6 f₁ g₁))) (AddSubgroup.seminormedAddCommGroup.{u2} V₁ _inst_3 (NormedAddGroupHom.equalizer.{u2, u1} V₁ W₁ _inst_3 _inst_6 f₁ g₁)))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.equalizer.map_id NormedAddGroupHom.Equalizer.map_idₓ'. -/
@[simp]
theorem map_id : map (id V₁) (id W₁) rfl rfl = id (f₁.equalizer g₁) := by ext; rfl
#align normed_add_group_hom.equalizer.map_id NormedAddGroupHom.Equalizer.map_id

/- warning: normed_add_group_hom.equalizer.comm_sq₂ -> NormedAddGroupHom.Equalizer.comm_sq₂ is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.equalizer.comm_sq₂ NormedAddGroupHom.Equalizer.comm_sq₂ₓ'. -/
theorem comm_sq₂ (hf : ψ.comp f₁ = f₂.comp φ) (hf' : ψ'.comp f₂ = f₃.comp φ') :
    (ψ'.comp ψ).comp f₁ = f₃.comp (φ'.comp φ) := by
  rw [comp_assoc, hf, ← comp_assoc, hf', comp_assoc]
#align normed_add_group_hom.equalizer.comm_sq₂ NormedAddGroupHom.Equalizer.comm_sq₂

/- warning: normed_add_group_hom.equalizer.map_comp_map -> NormedAddGroupHom.Equalizer.map_comp_map is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.equalizer.map_comp_map NormedAddGroupHom.Equalizer.map_comp_mapₓ'. -/
theorem map_comp_map (hf : ψ.comp f₁ = f₂.comp φ) (hg : ψ.comp g₁ = g₂.comp φ)
    (hf' : ψ'.comp f₂ = f₃.comp φ') (hg' : ψ'.comp g₂ = g₃.comp φ') :
    (map φ' ψ' hf' hg').comp (map φ ψ hf hg) =
      map (φ'.comp φ) (ψ'.comp ψ) (comm_sq₂ hf hf') (comm_sq₂ hg hg') :=
  by ext; rfl
#align normed_add_group_hom.equalizer.map_comp_map NormedAddGroupHom.Equalizer.map_comp_map

/- warning: normed_add_group_hom.equalizer.ι_norm_noninc -> NormedAddGroupHom.Equalizer.ι_normNoninc is a dubious translation:
lean 3 declaration is
  forall {V : Type.{u1}} {W : Type.{u2}} [_inst_1 : SeminormedAddCommGroup.{u1} V] [_inst_2 : SeminormedAddCommGroup.{u2} W] {f : NormedAddGroupHom.{u1, u2} V W _inst_1 _inst_2} {g : NormedAddGroupHom.{u1, u2} V W _inst_1 _inst_2}, NormedAddGroupHom.NormNoninc.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))) V (AddSubgroup.setLike.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1)))) (NormedAddGroupHom.equalizer.{u1, u2} V W _inst_1 _inst_2 f g)) V (AddSubgroup.seminormedAddCommGroup.{u1} V _inst_1 (NormedAddGroupHom.equalizer.{u1, u2} V W _inst_1 _inst_2 f g)) _inst_1 (NormedAddGroupHom.Equalizer.ι.{u1, u2} V W _inst_1 _inst_2 f g)
but is expected to have type
  forall {V : Type.{u2}} {W : Type.{u1}} [_inst_1 : SeminormedAddCommGroup.{u2} V] [_inst_2 : SeminormedAddCommGroup.{u1} W] {f : NormedAddGroupHom.{u2, u1} V W _inst_1 _inst_2} {g : NormedAddGroupHom.{u2, u1} V W _inst_1 _inst_2}, NormedAddGroupHom.NormNoninc.{u2, u2} (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (AddSubgroup.{u2} V (SeminormedAddGroup.toAddGroup.{u2} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} V (SeminormedAddGroup.toAddGroup.{u2} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V _inst_1))) V (AddSubgroup.instSetLikeAddSubgroup.{u2} V (SeminormedAddGroup.toAddGroup.{u2} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V _inst_1)))) x (NormedAddGroupHom.equalizer.{u2, u1} V W _inst_1 _inst_2 f g))) V (AddSubgroup.seminormedAddCommGroup.{u2} V _inst_1 (NormedAddGroupHom.equalizer.{u2, u1} V W _inst_1 _inst_2 f g)) _inst_1 (NormedAddGroupHom.Equalizer.ι.{u2, u1} V W _inst_1 _inst_2 f g)
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.equalizer.ι_norm_noninc NormedAddGroupHom.Equalizer.ι_normNonincₓ'. -/
theorem ι_normNoninc : (ι f g).NormNoninc := fun v => le_rfl
#align normed_add_group_hom.equalizer.ι_norm_noninc NormedAddGroupHom.Equalizer.ι_normNoninc

/- warning: normed_add_group_hom.equalizer.lift_norm_noninc -> NormedAddGroupHom.Equalizer.lift_normNoninc is a dubious translation:
lean 3 declaration is
  forall {V : Type.{u1}} {W : Type.{u2}} {V₁ : Type.{u3}} [_inst_1 : SeminormedAddCommGroup.{u1} V] [_inst_2 : SeminormedAddCommGroup.{u2} W] [_inst_3 : SeminormedAddCommGroup.{u3} V₁] {f : NormedAddGroupHom.{u1, u2} V W _inst_1 _inst_2} {g : NormedAddGroupHom.{u1, u2} V W _inst_1 _inst_2} (φ : NormedAddGroupHom.{u3, u1} V₁ V _inst_3 _inst_1) (h : Eq.{max (succ u3) (succ u2)} (NormedAddGroupHom.{u3, u2} V₁ W _inst_3 _inst_2) (NormedAddGroupHom.comp.{u3, u1, u2} V₁ V W _inst_3 _inst_1 _inst_2 f φ) (NormedAddGroupHom.comp.{u3, u1, u2} V₁ V W _inst_3 _inst_1 _inst_2 g φ)), (NormedAddGroupHom.NormNoninc.{u3, u1} V₁ V _inst_3 _inst_1 φ) -> (NormedAddGroupHom.NormNoninc.{u3, u1} V₁ (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1))) V (AddSubgroup.setLike.{u1} V (SeminormedAddGroup.toAddGroup.{u1} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} V _inst_1)))) (NormedAddGroupHom.equalizer.{u1, u2} V W _inst_1 _inst_2 f g)) _inst_3 (AddSubgroup.seminormedAddCommGroup.{u1} V _inst_1 (NormedAddGroupHom.equalizer.{u1, u2} V W _inst_1 _inst_2 f g)) (NormedAddGroupHom.Equalizer.lift.{u1, u2, u3} V W V₁ _inst_1 _inst_2 _inst_3 f g φ h))
but is expected to have type
  forall {V : Type.{u2}} {W : Type.{u1}} {V₁ : Type.{u3}} [_inst_1 : SeminormedAddCommGroup.{u2} V] [_inst_2 : SeminormedAddCommGroup.{u1} W] [_inst_3 : SeminormedAddCommGroup.{u3} V₁] {f : NormedAddGroupHom.{u2, u1} V W _inst_1 _inst_2} {g : NormedAddGroupHom.{u2, u1} V W _inst_1 _inst_2} (φ : NormedAddGroupHom.{u3, u2} V₁ V _inst_3 _inst_1) (h : Eq.{max (succ u1) (succ u3)} (NormedAddGroupHom.{u3, u1} V₁ W _inst_3 _inst_2) (NormedAddGroupHom.comp.{u3, u2, u1} V₁ V W _inst_3 _inst_1 _inst_2 f φ) (NormedAddGroupHom.comp.{u3, u2, u1} V₁ V W _inst_3 _inst_1 _inst_2 g φ)), (NormedAddGroupHom.NormNoninc.{u3, u2} V₁ V _inst_3 _inst_1 φ) -> (NormedAddGroupHom.NormNoninc.{u3, u2} V₁ (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (AddSubgroup.{u2} V (SeminormedAddGroup.toAddGroup.{u2} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} V (SeminormedAddGroup.toAddGroup.{u2} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V _inst_1))) V (AddSubgroup.instSetLikeAddSubgroup.{u2} V (SeminormedAddGroup.toAddGroup.{u2} V (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} V _inst_1)))) x (NormedAddGroupHom.equalizer.{u2, u1} V W _inst_1 _inst_2 f g))) _inst_3 (AddSubgroup.seminormedAddCommGroup.{u2} V _inst_1 (NormedAddGroupHom.equalizer.{u2, u1} V W _inst_1 _inst_2 f g)) (NormedAddGroupHom.Equalizer.lift.{u2, u1, u3} V W V₁ _inst_1 _inst_2 _inst_3 f g φ h))
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.equalizer.lift_norm_noninc NormedAddGroupHom.Equalizer.lift_normNonincₓ'. -/
/-- The lifting of a norm nonincreasing morphism is norm nonincreasing. -/
theorem lift_normNoninc (φ : NormedAddGroupHom V₁ V) (h : f.comp φ = g.comp φ) (hφ : φ.NormNoninc) :
    (lift φ h).NormNoninc :=
  hφ
#align normed_add_group_hom.equalizer.lift_norm_noninc NormedAddGroupHom.Equalizer.lift_normNoninc

/- warning: normed_add_group_hom.equalizer.norm_lift_le -> NormedAddGroupHom.Equalizer.norm_lift_le is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.equalizer.norm_lift_le NormedAddGroupHom.Equalizer.norm_lift_leₓ'. -/
/-- If `φ` satisfies `‖φ‖ ≤ C`, then the same is true for the lifted morphism. -/
theorem norm_lift_le (φ : NormedAddGroupHom V₁ V) (h : f.comp φ = g.comp φ) (C : ℝ) (hφ : ‖φ‖ ≤ C) :
    ‖lift φ h‖ ≤ C :=
  hφ
#align normed_add_group_hom.equalizer.norm_lift_le NormedAddGroupHom.Equalizer.norm_lift_le

/- warning: normed_add_group_hom.equalizer.map_norm_noninc -> NormedAddGroupHom.Equalizer.map_normNoninc is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.equalizer.map_norm_noninc NormedAddGroupHom.Equalizer.map_normNonincₓ'. -/
theorem map_normNoninc (hf : ψ.comp f₁ = f₂.comp φ) (hg : ψ.comp g₁ = g₂.comp φ)
    (hφ : φ.NormNoninc) : (map φ ψ hf hg).NormNoninc :=
  lift_normNoninc _ _ <| hφ.comp ι_normNoninc
#align normed_add_group_hom.equalizer.map_norm_noninc NormedAddGroupHom.Equalizer.map_normNoninc

/- warning: normed_add_group_hom.equalizer.norm_map_le -> NormedAddGroupHom.Equalizer.norm_map_le is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align normed_add_group_hom.equalizer.norm_map_le NormedAddGroupHom.Equalizer.norm_map_leₓ'. -/
theorem norm_map_le (hf : ψ.comp f₁ = f₂.comp φ) (hg : ψ.comp g₁ = g₂.comp φ) (C : ℝ)
    (hφ : ‖φ.comp (ι f₁ g₁)‖ ≤ C) : ‖map φ ψ hf hg‖ ≤ C :=
  norm_lift_le _ _ _ hφ
#align normed_add_group_hom.equalizer.norm_map_le NormedAddGroupHom.Equalizer.norm_map_le

end Equalizer

end NormedAddGroupHom

