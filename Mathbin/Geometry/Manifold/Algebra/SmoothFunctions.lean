/-
Copyright ¬© 2020 Nicol√≤ Cavalleri. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Nicol√≤ Cavalleri

! This file was ported from Lean 3 source module geometry.manifold.algebra.smooth_functions
! leanprover-community/mathlib commit 28aa996fc6fb4317f0083c4e6daf79878d81be33
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Geometry.Manifold.Algebra.Structures

/-!
# Algebraic structures over smooth functions

In this file, we define instances of algebraic structures over smooth functions.
-/


noncomputable section

open Manifold

variable {ùïú : Type _} [NontriviallyNormedField ùïú] {E : Type _} [NormedAddCommGroup E]
  [NormedSpace ùïú E] {E' : Type _} [NormedAddCommGroup E'] [NormedSpace ùïú E'] {H : Type _}
  [TopologicalSpace H] {I : ModelWithCorners ùïú E H} {H' : Type _} [TopologicalSpace H']
  {I' : ModelWithCorners ùïú E' H'} {N : Type _} [TopologicalSpace N] [ChartedSpace H N]
  {E'' : Type _} [NormedAddCommGroup E''] [NormedSpace ùïú E''] {H'' : Type _} [TopologicalSpace H'']
  {I'' : ModelWithCorners ùïú E'' H''} {N' : Type _} [TopologicalSpace N'] [ChartedSpace H'' N']

namespace SmoothMap

@[to_additive]
instance hasMul {G : Type _} [Mul G] [TopologicalSpace G] [ChartedSpace H' G] [HasSmoothMul I' G] :
    Mul C^‚àû‚üÆI, N; I', G‚üØ :=
  ‚ü®fun f g => ‚ü®f * g, f.Smooth.mul g.Smooth‚ü©‚ü©
#align smooth_map.has_mul SmoothMap.hasMul
#align smooth_map.has_add SmoothMap.has_add

@[simp, to_additive]
theorem coe_mul {G : Type _} [Mul G] [TopologicalSpace G] [ChartedSpace H' G] [HasSmoothMul I' G]
    (f g : C^‚àû‚üÆI, N; I', G‚üØ) : ‚áë(f * g) = f * g :=
  rfl
#align smooth_map.coe_mul SmoothMap.coe_mul
#align smooth_map.coe_add SmoothMap.coe_add

@[simp, to_additive]
theorem mul_comp {G : Type _} [Mul G] [TopologicalSpace G] [ChartedSpace H' G] [HasSmoothMul I' G]
    (f g : C^‚àû‚üÆI'', N'; I', G‚üØ) (h : C^‚àû‚üÆI, N; I'', N'‚üØ) : (f * g).comp h = f.comp h * g.comp h :=
  by ext <;> simp only [ContMdiffMap.comp_apply, coe_mul, Pi.mul_apply]
#align smooth_map.mul_comp SmoothMap.mul_comp
#align smooth_map.add_comp SmoothMap.add_comp

@[to_additive]
instance hasOne {G : Type _} [Monoid G] [TopologicalSpace G] [ChartedSpace H' G] :
    One C^‚àû‚üÆI, N; I', G‚üØ :=
  ‚ü®ContMdiffMap.const (1 : G)‚ü©
#align smooth_map.has_one SmoothMap.hasOne
#align smooth_map.has_zero SmoothMap.hasZero

@[simp, to_additive]
theorem coe_one {G : Type _} [Monoid G] [TopologicalSpace G] [ChartedSpace H' G] :
    ‚áë(1 : C^‚àû‚üÆI, N; I', G‚üØ) = 1 :=
  rfl
#align smooth_map.coe_one SmoothMap.coe_one
#align smooth_map.coe_zero SmoothMap.coe_zero

section GroupStructure

/-!
### Group structure

In this section we show that smooth functions valued in a Lie group inherit a group structure
under pointwise multiplication.
-/


@[to_additive]
instance semigroup {G : Type _} [Semigroup G] [TopologicalSpace G] [ChartedSpace H' G]
    [HasSmoothMul I' G] : Semigroup C^‚àû‚üÆI, N; I', G‚üØ :=
  { SmoothMap.hasMul with mul_assoc := fun a b c => by ext <;> exact mul_assoc _ _ _ }
#align smooth_map.semigroup SmoothMap.semigroup
#align smooth_map.add_semigroup SmoothMap.add_semigroup

@[to_additive]
instance monoid {G : Type _} [Monoid G] [TopologicalSpace G] [ChartedSpace H' G]
    [HasSmoothMul I' G] : Monoid C^‚àû‚üÆI, N; I', G‚üØ :=
  { SmoothMap.semigroup,
    SmoothMap.hasOne with
    one_mul := fun a => by ext <;> exact one_mul _
    mul_one := fun a => by ext <;> exact mul_one _ }
#align smooth_map.monoid SmoothMap.monoid
#align smooth_map.add_monoid SmoothMap.add_monoid

/-- Coercion to a function as an `monoid_hom`. Similar to `monoid_hom.coe_fn`. -/
@[to_additive "Coercion to a function as an `add_monoid_hom`. Similar to `add_monoid_hom.coe_fn`.",
  simps]
def coeFnMonoidHom {G : Type _} [Monoid G] [TopologicalSpace G] [ChartedSpace H' G]
    [HasSmoothMul I' G] : C^‚àû‚üÆI, N; I', G‚üØ ‚Üí* N ‚Üí G
    where
  toFun := coeFn
  map_one' := coe_one
  map_mul' := coe_mul
#align smooth_map.coe_fn_monoid_hom SmoothMap.coeFnMonoidHom
#align smooth_map.coe_fn_add_monoid_hom SmoothMap.coe_fn_add_monoid_hom

@[to_additive]
instance commMonoid {G : Type _} [CommMonoid G] [TopologicalSpace G] [ChartedSpace H' G]
    [HasSmoothMul I' G] : CommMonoid C^‚àû‚üÆI, N; I', G‚üØ :=
  { SmoothMap.monoid, SmoothMap.hasOne with mul_comm := fun a b => by ext <;> exact mul_comm _ _ }
#align smooth_map.comm_monoid SmoothMap.commMonoid
#align smooth_map.add_comm_monoid SmoothMap.add_comm_monoid

@[to_additive]
instance group {G : Type _} [Group G] [TopologicalSpace G] [ChartedSpace H' G] [LieGroup I' G] :
    Group C^‚àû‚üÆI, N; I', G‚üØ :=
  { SmoothMap.monoid with
    inv := fun f => ‚ü®fun x => (f x)‚Åª¬π, f.Smooth.inv‚ü©
    mul_left_inv := fun a => by ext <;> exact mul_left_inv _
    div := fun f g => ‚ü®f / g, f.Smooth.div g.Smooth‚ü©
    div_eq_mul_inv := fun f g => by ext <;> exact div_eq_mul_inv _ _ }
#align smooth_map.group SmoothMap.group
#align smooth_map.add_group SmoothMap.add_group

@[simp, to_additive]
theorem coe_inv {G : Type _} [Group G] [TopologicalSpace G] [ChartedSpace H' G] [LieGroup I' G]
    (f : C^‚àû‚üÆI, N; I', G‚üØ) : ‚áëf‚Åª¬π = f‚Åª¬π :=
  rfl
#align smooth_map.coe_inv SmoothMap.coe_inv
#align smooth_map.coe_neg SmoothMap.coe_neg

@[simp, to_additive]
theorem coe_div {G : Type _} [Group G] [TopologicalSpace G] [ChartedSpace H' G] [LieGroup I' G]
    (f g : C^‚àû‚üÆI, N; I', G‚üØ) : ‚áë(f / g) = f / g :=
  rfl
#align smooth_map.coe_div SmoothMap.coe_div
#align smooth_map.coe_sub SmoothMap.coe_sub

@[to_additive]
instance commGroup {G : Type _} [CommGroup G] [TopologicalSpace G] [ChartedSpace H' G]
    [LieGroup I' G] : CommGroup C^‚àû‚üÆI, N; I', G‚üØ :=
  { SmoothMap.group, SmoothMap.commMonoid with }
#align smooth_map.comm_group SmoothMap.commGroup
#align smooth_map.add_comm_group SmoothMap.add_comm_group

end GroupStructure

section RingStructure

/-!
### Ring stucture

In this section we show that smooth functions valued in a smooth ring `R` inherit a ring structure
under pointwise multiplication.
-/


instance semiring {R : Type _} [Semiring R] [TopologicalSpace R] [ChartedSpace H' R]
    [SmoothRing I' R] : Semiring C^‚àû‚üÆI, N; I', R‚üØ :=
  { SmoothMap.add_comm_monoid,
    SmoothMap.monoid with
    left_distrib := fun a b c => by ext <;> exact left_distrib _ _ _
    right_distrib := fun a b c => by ext <;> exact right_distrib _ _ _
    zero_mul := fun a => by ext <;> exact zero_mul _
    mul_zero := fun a => by ext <;> exact mul_zero _ }
#align smooth_map.semiring SmoothMap.semiring

instance ring {R : Type _} [Ring R] [TopologicalSpace R] [ChartedSpace H' R] [SmoothRing I' R] :
    Ring C^‚àû‚üÆI, N; I', R‚üØ :=
  { SmoothMap.semiring, SmoothMap.add_comm_group with }
#align smooth_map.ring SmoothMap.ring

instance commRing {R : Type _} [CommRing R] [TopologicalSpace R] [ChartedSpace H' R]
    [SmoothRing I' R] : CommRing C^‚àû‚üÆI, N; I', R‚üØ :=
  { SmoothMap.semiring, SmoothMap.add_comm_group, SmoothMap.commMonoid with }
#align smooth_map.comm_ring SmoothMap.commRing

/-- Coercion to a function as a `ring_hom`. -/
@[simps]
def coeFnRingHom {R : Type _} [CommRing R] [TopologicalSpace R] [ChartedSpace H' R]
    [SmoothRing I' R] : C^‚àû‚üÆI, N; I', R‚üØ ‚Üí+* N ‚Üí R :=
  { (coeFnMonoidHom : C^‚àû‚üÆI, N; I', R‚üØ ‚Üí* _), (coe_fn_add_monoid_hom : C^‚àû‚üÆI, N; I', R‚üØ ‚Üí+ _) with
    toFun := coeFn }
#align smooth_map.coe_fn_ring_hom SmoothMap.coeFnRingHom

/-- `function.eval` as a `ring_hom` on the ring of smooth functions. -/
def evalRingHom {R : Type _} [CommRing R] [TopologicalSpace R] [ChartedSpace H' R] [SmoothRing I' R]
    (n : N) : C^‚àû‚üÆI, N; I', R‚üØ ‚Üí+* R :=
  (Pi.evalRingHom _ n : (N ‚Üí R) ‚Üí+* R).comp SmoothMap.coeFnRingHom
#align smooth_map.eval_ring_hom SmoothMap.evalRingHom

end RingStructure

section ModuleStructure

/-!
### Semiodule stucture

In this section we show that smooth functions valued in a vector space `M` over a normed
field `ùïú` inherit a vector space structure.
-/


instance hasSmul {V : Type _} [NormedAddCommGroup V] [NormedSpace ùïú V] :
    SMul ùïú C^‚àû‚üÆI, N; ùìò(ùïú, V), V‚üØ :=
  ‚ü®fun r f => ‚ü®r ‚Ä¢ f, smooth_const.smul f.Smooth‚ü©‚ü©
#align smooth_map.has_smul SmoothMap.hasSmul

@[simp]
theorem coe_smul {V : Type _} [NormedAddCommGroup V] [NormedSpace ùïú V] (r : ùïú)
    (f : C^‚àû‚üÆI, N; ùìò(ùïú, V), V‚üØ) : ‚áë(r ‚Ä¢ f) = r ‚Ä¢ f :=
  rfl
#align smooth_map.coe_smul SmoothMap.coe_smul

@[simp]
theorem smul_comp {V : Type _} [NormedAddCommGroup V] [NormedSpace ùïú V] (r : ùïú)
    (g : C^‚àû‚üÆI'', N'; ùìò(ùïú, V), V‚üØ) (h : C^‚àû‚üÆI, N; I'', N'‚üØ) : (r ‚Ä¢ g).comp h = r ‚Ä¢ g.comp h :=
  rfl
#align smooth_map.smul_comp SmoothMap.smul_comp

instance module {V : Type _} [NormedAddCommGroup V] [NormedSpace ùïú V] :
    Module ùïú C^‚àû‚üÆI, N; ùìò(ùïú, V), V‚üØ :=
  Function.Injective.module ùïú coe_fn_add_monoid_hom ContMdiffMap.coe_inj coe_smul
#align smooth_map.module SmoothMap.module

/-- Coercion to a function as a `linear_map`. -/
@[simps]
def coeFnLinearMap {V : Type _} [NormedAddCommGroup V] [NormedSpace ùïú V] :
    C^‚àû‚üÆI, N; ùìò(ùïú, V), V‚üØ ‚Üí‚Çó[ùïú] N ‚Üí V :=
  {
    (coe_fn_add_monoid_hom :
      C^‚àû‚üÆI, N; ùìò(ùïú, V), V‚üØ ‚Üí+ _) with
    toFun := coeFn
    map_smul' := coe_smul }
#align smooth_map.coe_fn_linear_map SmoothMap.coeFnLinearMap

end ModuleStructure

section AlgebraStructure

/-!
### Algebra structure

In this section we show that smooth functions valued in a normed algebra `A` over a normed field `ùïú`
inherit an algebra structure.
-/


variable {A : Type _} [NormedRing A] [NormedAlgebra ùïú A] [SmoothRing ùìò(ùïú, A) A]

/-- Smooth constant functions as a `ring_hom`. -/
def c : ùïú ‚Üí+* C^‚àû‚üÆI, N; ùìò(ùïú, A), A‚üØ
    where
  toFun := fun c : ùïú => ‚ü®fun x => (algebraMap ùïú A) c, smooth_const‚ü©
  map_one' := by ext x <;> exact (algebraMap ùïú A).map_one
  map_mul' c‚ÇÅ c‚ÇÇ := by ext x <;> exact (algebraMap ùïú A).map_mul _ _
  map_zero' := by ext x <;> exact (algebraMap ùïú A).map_zero
  map_add' c‚ÇÅ c‚ÇÇ := by ext x <;> exact (algebraMap ùïú A).map_add _ _
#align smooth_map.C SmoothMap.c

instance algebra : Algebra ùïú C^‚àû‚üÆI, N; ùìò(ùïú, A), A‚üØ :=
  {
    SmoothMap.semiring with
    smul := fun r f => ‚ü®r ‚Ä¢ f, smooth_const.smul f.Smooth‚ü©
    toRingHom := SmoothMap.c
    commutes' := fun c f => by ext x <;> exact Algebra.commutes' _ _
    smul_def' := fun c f => by ext x <;> exact Algebra.smul_def' _ _ }
#align smooth_map.algebra SmoothMap.algebra

/-- Coercion to a function as an `alg_hom`. -/
@[simps]
def coeFnAlgHom : C^‚àû‚üÆI, N; ùìò(ùïú, A), A‚üØ ‚Üí‚Çê[ùïú] N ‚Üí A
    where
  toFun := coeFn
  commutes' r := rfl
  -- `..(smooth_map.coe_fn_ring_hom : C^‚àû‚üÆI, N; ùìò(ùïú, A), A‚üØ ‚Üí+* _)` times out for some reason
  map_zero' := SmoothMap.coe_zero
  map_one' := SmoothMap.coe_one
  map_add' := SmoothMap.coe_add
  map_mul' := SmoothMap.coe_mul
#align smooth_map.coe_fn_alg_hom SmoothMap.coeFnAlgHom

end AlgebraStructure

section ModuleOverContinuousFunctions

/-!
### Structure as module over scalar functions

If `V` is a module over `ùïú`, then we show that the space of smooth functions from `N` to `V`
is naturally a vector space over the ring of smooth functions from `N` to `ùïú`. -/


instance hasSmul' {V : Type _} [NormedAddCommGroup V] [NormedSpace ùïú V] :
    SMul C^‚àû‚üÆI, N; ùïú‚üØ C^‚àû‚üÆI, N; ùìò(ùïú, V), V‚üØ :=
  ‚ü®fun f g => ‚ü®fun x => f x ‚Ä¢ g x, Smooth.smul f.2 g.2‚ü©‚ü©
#align smooth_map.has_smul' SmoothMap.hasSmul'

@[simp]
theorem smul_comp' {V : Type _} [NormedAddCommGroup V] [NormedSpace ùïú V] (f : C^‚àû‚üÆI'', N'; ùïú‚üØ)
    (g : C^‚àû‚üÆI'', N'; ùìò(ùïú, V), V‚üØ) (h : C^‚àû‚üÆI, N; I'', N'‚üØ) :
    (f ‚Ä¢ g).comp h = f.comp h ‚Ä¢ g.comp h :=
  rfl
#align smooth_map.smul_comp' SmoothMap.smul_comp'

instance module' {V : Type _} [NormedAddCommGroup V] [NormedSpace ùïú V] :
    Module C^‚àû‚üÆI, N; ùìò(ùïú), ùïú‚üØ C^‚àû‚üÆI, N; ùìò(ùïú, V), V‚üØ
    where
  smul := (¬∑ ‚Ä¢ ¬∑)
  smul_add c f g := by ext x <;> exact smul_add (c x) (f x) (g x)
  add_smul c‚ÇÅ c‚ÇÇ f := by ext x <;> exact add_smul (c‚ÇÅ x) (c‚ÇÇ x) (f x)
  mul_smul c‚ÇÅ c‚ÇÇ f := by ext x <;> exact mul_smul (c‚ÇÅ x) (c‚ÇÇ x) (f x)
  one_smul f := by ext x <;> exact one_smul ùïú (f x)
  zero_smul f := by ext x <;> exact zero_smul _ _
  smul_zero r := by ext x <;> exact smul_zero _
#align smooth_map.module' SmoothMap.module'

end ModuleOverContinuousFunctions

end SmoothMap

