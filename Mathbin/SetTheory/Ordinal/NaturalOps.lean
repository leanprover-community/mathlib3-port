/-
Copyright (c) 2022 Violeta Hernández Palacios. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Violeta Hernández Palacios

! This file was ported from Lean 3 source module set_theory.ordinal.natural_ops
! leanprover-community/mathlib commit 2e0975f6a25dd3fbfb9e41556a77f075f6269748
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.SetTheory.Ordinal.Arithmetic

/-!
# Natural operations on ordinals

The goal of this file is to define natural addition and multiplication on ordinals, also known as
the Hessenberg sum and product, and provide a basic API. The natural addition of two ordinals
`a ♯ b` is recursively defined as the least ordinal greater than `a' ♯ b` and `a ♯ b'` for `a' < a`
and `b' < b`. The natural multiplication `a ⨳ b` is likewise recursively defined as the least
ordinal such that `a ⨳ b ♯ a' ⨳ b'` is greater than `a' ⨳ b ♯ a ⨳ b'` for any `a' < a` and
`b' < b`.

These operations form a rich algebraic structure: they're commutative, associative, preserve order,
have the usual `0` and `1` from ordinals, and distribute over one another.

Moreover, these operations are the addition and multiplication of ordinals when viewed as
combinatorial `game`s. This makes them particularly useful for game theory.

Finally, both operations admit simple, intuitive descriptions in terms of the Cantor normal form.
The natural addition of two ordinals corresponds to adding their Cantor normal forms as if they were
polynomials in `ω`. Likewise, their natural multiplication corresponds to multiplying the Cantor
normal forms as polynomials.

# Implementation notes

Given the rich algebraic structure of these two operations, we choose to create a type synonym
`nat_ordinal`, where we provide the appropriate instances. However, to avoid casting back and forth
between both types, we attempt to prove and state most results on `ordinal`.

# Todo

- Define natural multiplication and provide a basic API.
- Prove the characterizations of natural addition and multiplication in terms of the Cantor normal
  form.
-/


universe u v

open Function Order

noncomputable section

#print NatOrdinal /-
/-- A type synonym for ordinals with natural addition and multiplication. -/
def NatOrdinal : Type _ :=
  Ordinal deriving Zero, Inhabited, One, LinearOrder, SuccOrder, WellFoundedRelation
#align nat_ordinal NatOrdinal
-/

#print Ordinal.toNatOrdinal /-
/-- The identity function between `ordinal` and `nat_ordinal`. -/
@[match_pattern]
def Ordinal.toNatOrdinal : Ordinal ≃o NatOrdinal :=
  OrderIso.refl _
#align ordinal.to_nat_ordinal Ordinal.toNatOrdinal
-/

#print NatOrdinal.toOrdinal /-
/-- The identity function between `nat_ordinal` and `ordinal`. -/
@[match_pattern]
def NatOrdinal.toOrdinal : NatOrdinal ≃o Ordinal :=
  OrderIso.refl _
#align nat_ordinal.to_ordinal NatOrdinal.toOrdinal
-/

open Ordinal

namespace NatOrdinal

variable {a b c : NatOrdinal.{u}}

#print NatOrdinal.toOrdinal_symm_eq /-
@[simp]
theorem toOrdinal_symm_eq : NatOrdinal.toOrdinal.symm = Ordinal.toNatOrdinal :=
  rfl
#align nat_ordinal.to_ordinal_symm_eq NatOrdinal.toOrdinal_symm_eq
-/

/- warning: nat_ordinal.to_ordinal_to_nat_ordinal -> NatOrdinal.toOrdinal_toNatOrdinal is a dubious translation:
lean 3 declaration is
  forall (a : NatOrdinal.{u1}), Eq.{succ (succ u1)} NatOrdinal.{u1} (coeFn.{succ (succ u1), succ (succ u1)} (OrderIso.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (fun (_x : RelIso.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))))) => Ordinal.{u1} -> NatOrdinal.{u1}) (RelIso.hasCoeToFun.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))))) Ordinal.toNatOrdinal.{u1} (coeFn.{succ (succ u1), succ (succ u1)} (OrderIso.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))) (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (fun (_x : RelIso.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})))) => NatOrdinal.{u1} -> Ordinal.{u1}) (RelIso.hasCoeToFun.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})))) NatOrdinal.toOrdinal.{u1} a)) a
but is expected to have type
  forall (a : NatOrdinal.{u1}), Eq.{succ (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) (FunLike.coe.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1}) NatOrdinal.{u1} (fun (a : NatOrdinal.{u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) a) (EmbeddingLike.toFunLike.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1}) NatOrdinal.{u1} Ordinal.{u1} (Function.instEmbeddingLikeEmbedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1})) (RelEmbedding.toEmbedding.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) NatOrdinal.toOrdinal.{u1})) a)) (FunLike.coe.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1}) Ordinal.{u1} (fun (_x : Ordinal.{u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) _x) (EmbeddingLike.toFunLike.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1}) Ordinal.{u1} NatOrdinal.{u1} (Function.instEmbeddingLikeEmbedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1})) (RelEmbedding.toEmbedding.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) Ordinal.toNatOrdinal.{u1})) (FunLike.coe.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1}) NatOrdinal.{u1} (fun (_x : NatOrdinal.{u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) _x) (EmbeddingLike.toFunLike.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1}) NatOrdinal.{u1} Ordinal.{u1} (Function.instEmbeddingLikeEmbedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1})) (RelEmbedding.toEmbedding.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) NatOrdinal.toOrdinal.{u1})) a)) a
Case conversion may be inaccurate. Consider using '#align nat_ordinal.to_ordinal_to_nat_ordinal NatOrdinal.toOrdinal_toNatOrdinalₓ'. -/
@[simp]
theorem toOrdinal_toNatOrdinal (a : NatOrdinal) : a.toOrdinal.toNatOrdinal = a :=
  rfl
#align nat_ordinal.to_ordinal_to_nat_ordinal NatOrdinal.toOrdinal_toNatOrdinal

#print NatOrdinal.lt_wf /-
theorem lt_wf : @WellFounded NatOrdinal (· < ·) :=
  Ordinal.lt_wf
#align nat_ordinal.lt_wf NatOrdinal.lt_wf
-/

instance : WellFoundedLT NatOrdinal :=
  Ordinal.wellFoundedLT

instance : IsWellOrder NatOrdinal (· < ·) :=
  Ordinal.HasLt.Lt.isWellOrder

/- warning: nat_ordinal.to_ordinal_zero -> NatOrdinal.toOrdinal_zero is a dubious translation:
lean 3 declaration is
  Eq.{succ (succ u1)} Ordinal.{u1} (coeFn.{succ (succ u1), succ (succ u1)} (OrderIso.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))) (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (fun (_x : RelIso.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})))) => NatOrdinal.{u1} -> Ordinal.{u1}) (RelIso.hasCoeToFun.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})))) NatOrdinal.toOrdinal.{u1} (OfNat.ofNat.{succ u1} NatOrdinal.{u1} 0 (OfNat.mk.{succ u1} NatOrdinal.{u1} 0 (Zero.zero.{succ u1} NatOrdinal.{u1} NatOrdinal.hasZero.{u1})))) (OfNat.ofNat.{succ u1} Ordinal.{u1} 0 (OfNat.mk.{succ u1} Ordinal.{u1} 0 (Zero.zero.{succ u1} Ordinal.{u1} Ordinal.hasZero.{u1})))
but is expected to have type
  Eq.{succ (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) (OfNat.ofNat.{succ u1} NatOrdinal.{u1} 0 (Zero.toOfNat0.{succ u1} NatOrdinal.{u1} instNatOrdinalZero.{u1}))) (FunLike.coe.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1}) NatOrdinal.{u1} (fun (_x : NatOrdinal.{u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) _x) (EmbeddingLike.toFunLike.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1}) NatOrdinal.{u1} Ordinal.{u1} (Function.instEmbeddingLikeEmbedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1})) (RelEmbedding.toEmbedding.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) NatOrdinal.toOrdinal.{u1})) (OfNat.ofNat.{succ u1} NatOrdinal.{u1} 0 (Zero.toOfNat0.{succ u1} NatOrdinal.{u1} instNatOrdinalZero.{u1}))) (OfNat.ofNat.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) (OfNat.ofNat.{succ u1} NatOrdinal.{u1} 0 (Zero.toOfNat0.{succ u1} NatOrdinal.{u1} instNatOrdinalZero.{u1}))) 0 (Zero.toOfNat0.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) (OfNat.ofNat.{succ u1} NatOrdinal.{u1} 0 (Zero.toOfNat0.{succ u1} NatOrdinal.{u1} instNatOrdinalZero.{u1}))) Ordinal.zero.{u1}))
Case conversion may be inaccurate. Consider using '#align nat_ordinal.to_ordinal_zero NatOrdinal.toOrdinal_zeroₓ'. -/
@[simp]
theorem toOrdinal_zero : toOrdinal 0 = 0 :=
  rfl
#align nat_ordinal.to_ordinal_zero NatOrdinal.toOrdinal_zero

/- warning: nat_ordinal.to_ordinal_one -> NatOrdinal.toOrdinal_one is a dubious translation:
lean 3 declaration is
  Eq.{succ (succ u1)} Ordinal.{u1} (coeFn.{succ (succ u1), succ (succ u1)} (OrderIso.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))) (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (fun (_x : RelIso.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})))) => NatOrdinal.{u1} -> Ordinal.{u1}) (RelIso.hasCoeToFun.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})))) NatOrdinal.toOrdinal.{u1} (OfNat.ofNat.{succ u1} NatOrdinal.{u1} 1 (OfNat.mk.{succ u1} NatOrdinal.{u1} 1 (One.one.{succ u1} NatOrdinal.{u1} NatOrdinal.hasOne.{u1})))) (OfNat.ofNat.{succ u1} Ordinal.{u1} 1 (OfNat.mk.{succ u1} Ordinal.{u1} 1 (One.one.{succ u1} Ordinal.{u1} Ordinal.hasOne.{u1})))
but is expected to have type
  Eq.{succ (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) (OfNat.ofNat.{succ u1} NatOrdinal.{u1} 1 (One.toOfNat1.{succ u1} NatOrdinal.{u1} instNatOrdinalOne.{u1}))) (FunLike.coe.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1}) NatOrdinal.{u1} (fun (_x : NatOrdinal.{u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) _x) (EmbeddingLike.toFunLike.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1}) NatOrdinal.{u1} Ordinal.{u1} (Function.instEmbeddingLikeEmbedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1})) (RelEmbedding.toEmbedding.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) NatOrdinal.toOrdinal.{u1})) (OfNat.ofNat.{succ u1} NatOrdinal.{u1} 1 (One.toOfNat1.{succ u1} NatOrdinal.{u1} instNatOrdinalOne.{u1}))) (OfNat.ofNat.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) (OfNat.ofNat.{succ u1} NatOrdinal.{u1} 1 (One.toOfNat1.{succ u1} NatOrdinal.{u1} instNatOrdinalOne.{u1}))) 1 (One.toOfNat1.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) (OfNat.ofNat.{succ u1} NatOrdinal.{u1} 1 (One.toOfNat1.{succ u1} NatOrdinal.{u1} instNatOrdinalOne.{u1}))) Ordinal.one.{u1}))
Case conversion may be inaccurate. Consider using '#align nat_ordinal.to_ordinal_one NatOrdinal.toOrdinal_oneₓ'. -/
@[simp]
theorem toOrdinal_one : toOrdinal 1 = 1 :=
  rfl
#align nat_ordinal.to_ordinal_one NatOrdinal.toOrdinal_one

/- warning: nat_ordinal.to_ordinal_eq_zero -> NatOrdinal.toOrdinal_eq_zero is a dubious translation:
lean 3 declaration is
  forall (a : NatOrdinal.{u1}), Iff (Eq.{succ (succ u1)} Ordinal.{u1} (coeFn.{succ (succ u1), succ (succ u1)} (OrderIso.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))) (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (fun (_x : RelIso.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})))) => NatOrdinal.{u1} -> Ordinal.{u1}) (RelIso.hasCoeToFun.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})))) NatOrdinal.toOrdinal.{u1} a) (OfNat.ofNat.{succ u1} Ordinal.{u1} 0 (OfNat.mk.{succ u1} Ordinal.{u1} 0 (Zero.zero.{succ u1} Ordinal.{u1} Ordinal.hasZero.{u1})))) (Eq.{succ (succ u1)} NatOrdinal.{u1} a (OfNat.ofNat.{succ u1} NatOrdinal.{u1} 0 (OfNat.mk.{succ u1} NatOrdinal.{u1} 0 (Zero.zero.{succ u1} NatOrdinal.{u1} NatOrdinal.hasZero.{u1}))))
but is expected to have type
  forall (a : NatOrdinal.{u1}), Iff (Eq.{succ (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) a) (FunLike.coe.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1}) NatOrdinal.{u1} (fun (_x : NatOrdinal.{u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) _x) (EmbeddingLike.toFunLike.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1}) NatOrdinal.{u1} Ordinal.{u1} (Function.instEmbeddingLikeEmbedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1})) (RelEmbedding.toEmbedding.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) NatOrdinal.toOrdinal.{u1})) a) (OfNat.ofNat.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) a) 0 (Zero.toOfNat0.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) a) Ordinal.zero.{u1}))) (Eq.{succ (succ u1)} NatOrdinal.{u1} a (OfNat.ofNat.{succ u1} NatOrdinal.{u1} 0 (Zero.toOfNat0.{succ u1} NatOrdinal.{u1} instNatOrdinalZero.{u1})))
Case conversion may be inaccurate. Consider using '#align nat_ordinal.to_ordinal_eq_zero NatOrdinal.toOrdinal_eq_zeroₓ'. -/
@[simp]
theorem toOrdinal_eq_zero (a) : toOrdinal a = 0 ↔ a = 0 :=
  Iff.rfl
#align nat_ordinal.to_ordinal_eq_zero NatOrdinal.toOrdinal_eq_zero

/- warning: nat_ordinal.to_ordinal_eq_one -> NatOrdinal.toOrdinal_eq_one is a dubious translation:
lean 3 declaration is
  forall (a : NatOrdinal.{u1}), Iff (Eq.{succ (succ u1)} Ordinal.{u1} (coeFn.{succ (succ u1), succ (succ u1)} (OrderIso.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))) (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (fun (_x : RelIso.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})))) => NatOrdinal.{u1} -> Ordinal.{u1}) (RelIso.hasCoeToFun.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})))) NatOrdinal.toOrdinal.{u1} a) (OfNat.ofNat.{succ u1} Ordinal.{u1} 1 (OfNat.mk.{succ u1} Ordinal.{u1} 1 (One.one.{succ u1} Ordinal.{u1} Ordinal.hasOne.{u1})))) (Eq.{succ (succ u1)} NatOrdinal.{u1} a (OfNat.ofNat.{succ u1} NatOrdinal.{u1} 1 (OfNat.mk.{succ u1} NatOrdinal.{u1} 1 (One.one.{succ u1} NatOrdinal.{u1} NatOrdinal.hasOne.{u1}))))
but is expected to have type
  forall (a : NatOrdinal.{u1}), Iff (Eq.{succ (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) a) (FunLike.coe.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1}) NatOrdinal.{u1} (fun (_x : NatOrdinal.{u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) _x) (EmbeddingLike.toFunLike.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1}) NatOrdinal.{u1} Ordinal.{u1} (Function.instEmbeddingLikeEmbedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1})) (RelEmbedding.toEmbedding.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) NatOrdinal.toOrdinal.{u1})) a) (OfNat.ofNat.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) a) 1 (One.toOfNat1.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) a) Ordinal.one.{u1}))) (Eq.{succ (succ u1)} NatOrdinal.{u1} a (OfNat.ofNat.{succ u1} NatOrdinal.{u1} 1 (One.toOfNat1.{succ u1} NatOrdinal.{u1} instNatOrdinalOne.{u1})))
Case conversion may be inaccurate. Consider using '#align nat_ordinal.to_ordinal_eq_one NatOrdinal.toOrdinal_eq_oneₓ'. -/
@[simp]
theorem toOrdinal_eq_one (a) : toOrdinal a = 1 ↔ a = 1 :=
  Iff.rfl
#align nat_ordinal.to_ordinal_eq_one NatOrdinal.toOrdinal_eq_one

/- warning: nat_ordinal.to_ordinal_max -> NatOrdinal.toOrdinal_max is a dubious translation:
lean 3 declaration is
  forall {a : NatOrdinal.{u1}} {b : NatOrdinal.{u1}}, Eq.{succ (succ u1)} Ordinal.{u1} (coeFn.{succ (succ u1), succ (succ u1)} (OrderIso.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))) (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (fun (_x : RelIso.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})))) => NatOrdinal.{u1} -> Ordinal.{u1}) (RelIso.hasCoeToFun.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})))) NatOrdinal.toOrdinal.{u1} (LinearOrder.max.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1} a b)) (LinearOrder.max.{succ u1} Ordinal.{u1} Ordinal.linearOrder.{u1} (coeFn.{succ (succ u1), succ (succ u1)} (OrderIso.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))) (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (fun (_x : RelIso.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})))) => NatOrdinal.{u1} -> Ordinal.{u1}) (RelIso.hasCoeToFun.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})))) NatOrdinal.toOrdinal.{u1} a) (coeFn.{succ (succ u1), succ (succ u1)} (OrderIso.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))) (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (fun (_x : RelIso.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})))) => NatOrdinal.{u1} -> Ordinal.{u1}) (RelIso.hasCoeToFun.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})))) NatOrdinal.toOrdinal.{u1} b))
but is expected to have type
  forall {a : NatOrdinal.{u1}} {b : NatOrdinal.{u1}}, Eq.{succ (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) (Max.max.{succ u1} NatOrdinal.{u1} (LinearOrder.toMax.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}) a b)) (FunLike.coe.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1}) NatOrdinal.{u1} (fun (_x : NatOrdinal.{u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) _x) (EmbeddingLike.toFunLike.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1}) NatOrdinal.{u1} Ordinal.{u1} (Function.instEmbeddingLikeEmbedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1})) (RelEmbedding.toEmbedding.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) NatOrdinal.toOrdinal.{u1})) (Max.max.{succ u1} NatOrdinal.{u1} (LinearOrder.toMax.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}) a b)) (Max.max.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) a) (LinearOrder.toMax.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) a) Ordinal.linearOrder.{u1}) (FunLike.coe.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1}) NatOrdinal.{u1} (fun (_x : NatOrdinal.{u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) _x) (EmbeddingLike.toFunLike.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1}) NatOrdinal.{u1} Ordinal.{u1} (Function.instEmbeddingLikeEmbedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1})) (RelEmbedding.toEmbedding.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) NatOrdinal.toOrdinal.{u1})) a) (FunLike.coe.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1}) NatOrdinal.{u1} (fun (_x : NatOrdinal.{u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) _x) (EmbeddingLike.toFunLike.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1}) NatOrdinal.{u1} Ordinal.{u1} (Function.instEmbeddingLikeEmbedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1})) (RelEmbedding.toEmbedding.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) NatOrdinal.toOrdinal.{u1})) b))
Case conversion may be inaccurate. Consider using '#align nat_ordinal.to_ordinal_max NatOrdinal.toOrdinal_maxₓ'. -/
@[simp]
theorem toOrdinal_max : (max a b).toOrdinal = max a.toOrdinal b.toOrdinal :=
  rfl
#align nat_ordinal.to_ordinal_max NatOrdinal.toOrdinal_max

/- warning: nat_ordinal.to_ordinal_min -> NatOrdinal.toOrdinal_min is a dubious translation:
lean 3 declaration is
  forall {a : NatOrdinal.{u1}} {b : NatOrdinal.{u1}}, Eq.{succ (succ u1)} Ordinal.{u1} (coeFn.{succ (succ u1), succ (succ u1)} (OrderIso.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))) (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (fun (_x : RelIso.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})))) => NatOrdinal.{u1} -> Ordinal.{u1}) (RelIso.hasCoeToFun.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})))) NatOrdinal.toOrdinal.{u1} (LinearOrder.min.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1} a b)) (LinearOrder.min.{succ u1} Ordinal.{u1} Ordinal.linearOrder.{u1} (coeFn.{succ (succ u1), succ (succ u1)} (OrderIso.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))) (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (fun (_x : RelIso.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})))) => NatOrdinal.{u1} -> Ordinal.{u1}) (RelIso.hasCoeToFun.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})))) NatOrdinal.toOrdinal.{u1} a) (coeFn.{succ (succ u1), succ (succ u1)} (OrderIso.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))) (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (fun (_x : RelIso.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})))) => NatOrdinal.{u1} -> Ordinal.{u1}) (RelIso.hasCoeToFun.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})))) NatOrdinal.toOrdinal.{u1} b))
but is expected to have type
  forall {a : NatOrdinal.{u1}} {b : NatOrdinal.{u1}}, Eq.{succ (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) (Min.min.{succ u1} NatOrdinal.{u1} (LinearOrder.toMin.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}) a b)) (FunLike.coe.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1}) NatOrdinal.{u1} (fun (_x : NatOrdinal.{u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) _x) (EmbeddingLike.toFunLike.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1}) NatOrdinal.{u1} Ordinal.{u1} (Function.instEmbeddingLikeEmbedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1})) (RelEmbedding.toEmbedding.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) NatOrdinal.toOrdinal.{u1})) (Min.min.{succ u1} NatOrdinal.{u1} (LinearOrder.toMin.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}) a b)) (Min.min.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) a) (LinearOrder.toMin.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) a) Ordinal.linearOrder.{u1}) (FunLike.coe.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1}) NatOrdinal.{u1} (fun (_x : NatOrdinal.{u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) _x) (EmbeddingLike.toFunLike.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1}) NatOrdinal.{u1} Ordinal.{u1} (Function.instEmbeddingLikeEmbedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1})) (RelEmbedding.toEmbedding.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) NatOrdinal.toOrdinal.{u1})) a) (FunLike.coe.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1}) NatOrdinal.{u1} (fun (_x : NatOrdinal.{u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) _x) (EmbeddingLike.toFunLike.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1}) NatOrdinal.{u1} Ordinal.{u1} (Function.instEmbeddingLikeEmbedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1})) (RelEmbedding.toEmbedding.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) NatOrdinal.toOrdinal.{u1})) b))
Case conversion may be inaccurate. Consider using '#align nat_ordinal.to_ordinal_min NatOrdinal.toOrdinal_minₓ'. -/
@[simp]
theorem toOrdinal_min : (min a b).toOrdinal = min a.toOrdinal b.toOrdinal :=
  rfl
#align nat_ordinal.to_ordinal_min NatOrdinal.toOrdinal_min

/- warning: nat_ordinal.succ_def -> NatOrdinal.succ_def is a dubious translation:
lean 3 declaration is
  forall (a : NatOrdinal.{u1}), Eq.{succ (succ u1)} NatOrdinal.{u1} (Order.succ.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))) NatOrdinal.succOrder.{u1} a) (coeFn.{succ (succ u1), succ (succ u1)} (OrderIso.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (fun (_x : RelIso.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))))) => Ordinal.{u1} -> NatOrdinal.{u1}) (RelIso.hasCoeToFun.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))))) Ordinal.toNatOrdinal.{u1} (HAdd.hAdd.{succ u1, succ u1, succ u1} Ordinal.{u1} Ordinal.{u1} Ordinal.{u1} (instHAdd.{succ u1} Ordinal.{u1} Ordinal.hasAdd.{u1}) (coeFn.{succ (succ u1), succ (succ u1)} (OrderIso.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))) (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (fun (_x : RelIso.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})))) => NatOrdinal.{u1} -> Ordinal.{u1}) (RelIso.hasCoeToFun.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})))) NatOrdinal.toOrdinal.{u1} a) (OfNat.ofNat.{succ u1} Ordinal.{u1} 1 (OfNat.mk.{succ u1} Ordinal.{u1} 1 (One.one.{succ u1} Ordinal.{u1} Ordinal.hasOne.{u1})))))
but is expected to have type
  forall (a : NatOrdinal.{u1}), Eq.{succ (succ u1)} NatOrdinal.{u1} (Order.succ.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))) NatOrdinal.succOrder.{u1} a) (FunLike.coe.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1}) Ordinal.{u1} (fun (_x : Ordinal.{u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) _x) (EmbeddingLike.toFunLike.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1}) Ordinal.{u1} NatOrdinal.{u1} (Function.instEmbeddingLikeEmbedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1})) (RelEmbedding.toEmbedding.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) Ordinal.toNatOrdinal.{u1})) (HAdd.hAdd.{succ u1, succ u1, succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) a) Ordinal.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) a) (instHAdd.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) a) Ordinal.add.{u1}) (FunLike.coe.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1}) NatOrdinal.{u1} (fun (_x : NatOrdinal.{u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) _x) (EmbeddingLike.toFunLike.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1}) NatOrdinal.{u1} Ordinal.{u1} (Function.instEmbeddingLikeEmbedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1})) (RelEmbedding.toEmbedding.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) NatOrdinal.toOrdinal.{u1})) a) (OfNat.ofNat.{succ u1} Ordinal.{u1} 1 (One.toOfNat1.{succ u1} Ordinal.{u1} Ordinal.one.{u1}))))
Case conversion may be inaccurate. Consider using '#align nat_ordinal.succ_def NatOrdinal.succ_defₓ'. -/
theorem succ_def (a : NatOrdinal) : succ a = (a.toOrdinal + 1).toNatOrdinal :=
  rfl
#align nat_ordinal.succ_def NatOrdinal.succ_def

/- warning: nat_ordinal.rec -> NatOrdinal.rec is a dubious translation:
lean 3 declaration is
  forall {β : NatOrdinal.{u1} -> Sort.{u2}}, (forall (a : Ordinal.{u1}), β (coeFn.{succ (succ u1), succ (succ u1)} (OrderIso.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (fun (_x : RelIso.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))))) => Ordinal.{u1} -> NatOrdinal.{u1}) (RelIso.hasCoeToFun.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))))) Ordinal.toNatOrdinal.{u1} a)) -> (forall (a : NatOrdinal.{u1}), β a)
but is expected to have type
  forall {β : NatOrdinal.{u1} -> Sort.{u2}}, (forall (a : Ordinal.{u1}), β (FunLike.coe.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1}) Ordinal.{u1} (fun (_x : Ordinal.{u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) _x) (EmbeddingLike.toFunLike.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1}) Ordinal.{u1} NatOrdinal.{u1} (Function.instEmbeddingLikeEmbedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1})) (RelEmbedding.toEmbedding.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) Ordinal.toNatOrdinal.{u1})) a)) -> (forall (a : NatOrdinal.{u1}), β a)
Case conversion may be inaccurate. Consider using '#align nat_ordinal.rec NatOrdinal.recₓ'. -/
/-- A recursor for `nat_ordinal`. Use as `induction x using nat_ordinal.rec`. -/
protected def rec {β : NatOrdinal → Sort _} (h : ∀ a, β (toNatOrdinal a)) : ∀ a, β a := fun a =>
  h a.toOrdinal
#align nat_ordinal.rec NatOrdinal.rec

#print NatOrdinal.induction /-
/-- `ordinal.induction` but for `nat_ordinal`. -/
theorem induction {p : NatOrdinal → Prop} : ∀ (i) (h : ∀ j, (∀ k, k < j → p k) → p j), p i :=
  Ordinal.induction
#align nat_ordinal.induction NatOrdinal.induction
-/

end NatOrdinal

namespace Ordinal

variable {a b c : Ordinal.{u}}

#print Ordinal.toNatOrdinal_symm_eq /-
@[simp]
theorem toNatOrdinal_symm_eq : toNatOrdinal.symm = NatOrdinal.toOrdinal :=
  rfl
#align ordinal.to_nat_ordinal_symm_eq Ordinal.toNatOrdinal_symm_eq
-/

/- warning: ordinal.to_nat_ordinal_to_ordinal -> Ordinal.toNatOrdinal_toOrdinal is a dubious translation:
lean 3 declaration is
  forall (a : Ordinal.{u1}), Eq.{succ (succ u1)} Ordinal.{u1} (coeFn.{succ (succ u1), succ (succ u1)} (OrderIso.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))) (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (fun (_x : RelIso.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})))) => NatOrdinal.{u1} -> Ordinal.{u1}) (RelIso.hasCoeToFun.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})))) NatOrdinal.toOrdinal.{u1} (coeFn.{succ (succ u1), succ (succ u1)} (OrderIso.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (fun (_x : RelIso.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))))) => Ordinal.{u1} -> NatOrdinal.{u1}) (RelIso.hasCoeToFun.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))))) Ordinal.toNatOrdinal.{u1} a)) a
but is expected to have type
  forall (a : Ordinal.{u1}), Eq.{succ (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) (FunLike.coe.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1}) Ordinal.{u1} (fun (a : Ordinal.{u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) a) (EmbeddingLike.toFunLike.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1}) Ordinal.{u1} NatOrdinal.{u1} (Function.instEmbeddingLikeEmbedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1})) (RelEmbedding.toEmbedding.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) Ordinal.toNatOrdinal.{u1})) a)) (FunLike.coe.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1}) NatOrdinal.{u1} (fun (_x : NatOrdinal.{u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) _x) (EmbeddingLike.toFunLike.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1}) NatOrdinal.{u1} Ordinal.{u1} (Function.instEmbeddingLikeEmbedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1})) (RelEmbedding.toEmbedding.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) NatOrdinal.toOrdinal.{u1})) (FunLike.coe.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1}) Ordinal.{u1} (fun (_x : Ordinal.{u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) _x) (EmbeddingLike.toFunLike.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1}) Ordinal.{u1} NatOrdinal.{u1} (Function.instEmbeddingLikeEmbedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1})) (RelEmbedding.toEmbedding.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) Ordinal.toNatOrdinal.{u1})) a)) a
Case conversion may be inaccurate. Consider using '#align ordinal.to_nat_ordinal_to_ordinal Ordinal.toNatOrdinal_toOrdinalₓ'. -/
@[simp]
theorem toNatOrdinal_toOrdinal (a : Ordinal) : a.toNatOrdinal.toOrdinal = a :=
  rfl
#align ordinal.to_nat_ordinal_to_ordinal Ordinal.toNatOrdinal_toOrdinal

/- warning: ordinal.to_nat_ordinal_zero -> Ordinal.toNatOrdinal_zero is a dubious translation:
lean 3 declaration is
  Eq.{succ (succ u1)} NatOrdinal.{u1} (coeFn.{succ (succ u1), succ (succ u1)} (OrderIso.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (fun (_x : RelIso.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))))) => Ordinal.{u1} -> NatOrdinal.{u1}) (RelIso.hasCoeToFun.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))))) Ordinal.toNatOrdinal.{u1} (OfNat.ofNat.{succ u1} Ordinal.{u1} 0 (OfNat.mk.{succ u1} Ordinal.{u1} 0 (Zero.zero.{succ u1} Ordinal.{u1} Ordinal.hasZero.{u1})))) (OfNat.ofNat.{succ u1} NatOrdinal.{u1} 0 (OfNat.mk.{succ u1} NatOrdinal.{u1} 0 (Zero.zero.{succ u1} NatOrdinal.{u1} NatOrdinal.hasZero.{u1})))
but is expected to have type
  Eq.{succ (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) (OfNat.ofNat.{succ u1} Ordinal.{u1} 0 (Zero.toOfNat0.{succ u1} Ordinal.{u1} Ordinal.zero.{u1}))) (FunLike.coe.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1}) Ordinal.{u1} (fun (_x : Ordinal.{u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) _x) (EmbeddingLike.toFunLike.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1}) Ordinal.{u1} NatOrdinal.{u1} (Function.instEmbeddingLikeEmbedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1})) (RelEmbedding.toEmbedding.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) Ordinal.toNatOrdinal.{u1})) (OfNat.ofNat.{succ u1} Ordinal.{u1} 0 (Zero.toOfNat0.{succ u1} Ordinal.{u1} Ordinal.zero.{u1}))) (OfNat.ofNat.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) (OfNat.ofNat.{succ u1} Ordinal.{u1} 0 (Zero.toOfNat0.{succ u1} Ordinal.{u1} Ordinal.zero.{u1}))) 0 (Zero.toOfNat0.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) (OfNat.ofNat.{succ u1} Ordinal.{u1} 0 (Zero.toOfNat0.{succ u1} Ordinal.{u1} Ordinal.zero.{u1}))) instNatOrdinalZero.{u1}))
Case conversion may be inaccurate. Consider using '#align ordinal.to_nat_ordinal_zero Ordinal.toNatOrdinal_zeroₓ'. -/
@[simp]
theorem toNatOrdinal_zero : toNatOrdinal 0 = 0 :=
  rfl
#align ordinal.to_nat_ordinal_zero Ordinal.toNatOrdinal_zero

/- warning: ordinal.to_nat_ordinal_one -> Ordinal.toNatOrdinal_one is a dubious translation:
lean 3 declaration is
  Eq.{succ (succ u1)} NatOrdinal.{u1} (coeFn.{succ (succ u1), succ (succ u1)} (OrderIso.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (fun (_x : RelIso.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))))) => Ordinal.{u1} -> NatOrdinal.{u1}) (RelIso.hasCoeToFun.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))))) Ordinal.toNatOrdinal.{u1} (OfNat.ofNat.{succ u1} Ordinal.{u1} 1 (OfNat.mk.{succ u1} Ordinal.{u1} 1 (One.one.{succ u1} Ordinal.{u1} Ordinal.hasOne.{u1})))) (OfNat.ofNat.{succ u1} NatOrdinal.{u1} 1 (OfNat.mk.{succ u1} NatOrdinal.{u1} 1 (One.one.{succ u1} NatOrdinal.{u1} NatOrdinal.hasOne.{u1})))
but is expected to have type
  Eq.{succ (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) (OfNat.ofNat.{succ u1} Ordinal.{u1} 1 (One.toOfNat1.{succ u1} Ordinal.{u1} Ordinal.one.{u1}))) (FunLike.coe.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1}) Ordinal.{u1} (fun (_x : Ordinal.{u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) _x) (EmbeddingLike.toFunLike.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1}) Ordinal.{u1} NatOrdinal.{u1} (Function.instEmbeddingLikeEmbedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1})) (RelEmbedding.toEmbedding.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) Ordinal.toNatOrdinal.{u1})) (OfNat.ofNat.{succ u1} Ordinal.{u1} 1 (One.toOfNat1.{succ u1} Ordinal.{u1} Ordinal.one.{u1}))) (OfNat.ofNat.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) (OfNat.ofNat.{succ u1} Ordinal.{u1} 1 (One.toOfNat1.{succ u1} Ordinal.{u1} Ordinal.one.{u1}))) 1 (One.toOfNat1.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) (OfNat.ofNat.{succ u1} Ordinal.{u1} 1 (One.toOfNat1.{succ u1} Ordinal.{u1} Ordinal.one.{u1}))) instNatOrdinalOne.{u1}))
Case conversion may be inaccurate. Consider using '#align ordinal.to_nat_ordinal_one Ordinal.toNatOrdinal_oneₓ'. -/
@[simp]
theorem toNatOrdinal_one : toNatOrdinal 1 = 1 :=
  rfl
#align ordinal.to_nat_ordinal_one Ordinal.toNatOrdinal_one

/- warning: ordinal.to_nat_ordinal_eq_zero -> Ordinal.toNatOrdinal_eq_zero is a dubious translation:
lean 3 declaration is
  forall (a : Ordinal.{u1}), Iff (Eq.{succ (succ u1)} NatOrdinal.{u1} (coeFn.{succ (succ u1), succ (succ u1)} (OrderIso.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (fun (_x : RelIso.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))))) => Ordinal.{u1} -> NatOrdinal.{u1}) (RelIso.hasCoeToFun.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))))) Ordinal.toNatOrdinal.{u1} a) (OfNat.ofNat.{succ u1} NatOrdinal.{u1} 0 (OfNat.mk.{succ u1} NatOrdinal.{u1} 0 (Zero.zero.{succ u1} NatOrdinal.{u1} NatOrdinal.hasZero.{u1})))) (Eq.{succ (succ u1)} Ordinal.{u1} a (OfNat.ofNat.{succ u1} Ordinal.{u1} 0 (OfNat.mk.{succ u1} Ordinal.{u1} 0 (Zero.zero.{succ u1} Ordinal.{u1} Ordinal.hasZero.{u1}))))
but is expected to have type
  forall (a : Ordinal.{u1}), Iff (Eq.{succ (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) a) (FunLike.coe.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1}) Ordinal.{u1} (fun (_x : Ordinal.{u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) _x) (EmbeddingLike.toFunLike.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1}) Ordinal.{u1} NatOrdinal.{u1} (Function.instEmbeddingLikeEmbedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1})) (RelEmbedding.toEmbedding.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) Ordinal.toNatOrdinal.{u1})) a) (OfNat.ofNat.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) a) 0 (Zero.toOfNat0.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) a) instNatOrdinalZero.{u1}))) (Eq.{succ (succ u1)} Ordinal.{u1} a (OfNat.ofNat.{succ u1} Ordinal.{u1} 0 (Zero.toOfNat0.{succ u1} Ordinal.{u1} Ordinal.zero.{u1})))
Case conversion may be inaccurate. Consider using '#align ordinal.to_nat_ordinal_eq_zero Ordinal.toNatOrdinal_eq_zeroₓ'. -/
@[simp]
theorem toNatOrdinal_eq_zero (a) : toNatOrdinal a = 0 ↔ a = 0 :=
  Iff.rfl
#align ordinal.to_nat_ordinal_eq_zero Ordinal.toNatOrdinal_eq_zero

/- warning: ordinal.to_nat_ordinal_eq_one -> Ordinal.toNatOrdinal_eq_one is a dubious translation:
lean 3 declaration is
  forall (a : Ordinal.{u1}), Iff (Eq.{succ (succ u1)} NatOrdinal.{u1} (coeFn.{succ (succ u1), succ (succ u1)} (OrderIso.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (fun (_x : RelIso.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))))) => Ordinal.{u1} -> NatOrdinal.{u1}) (RelIso.hasCoeToFun.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))))) Ordinal.toNatOrdinal.{u1} a) (OfNat.ofNat.{succ u1} NatOrdinal.{u1} 1 (OfNat.mk.{succ u1} NatOrdinal.{u1} 1 (One.one.{succ u1} NatOrdinal.{u1} NatOrdinal.hasOne.{u1})))) (Eq.{succ (succ u1)} Ordinal.{u1} a (OfNat.ofNat.{succ u1} Ordinal.{u1} 1 (OfNat.mk.{succ u1} Ordinal.{u1} 1 (One.one.{succ u1} Ordinal.{u1} Ordinal.hasOne.{u1}))))
but is expected to have type
  forall (a : Ordinal.{u1}), Iff (Eq.{succ (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) a) (FunLike.coe.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1}) Ordinal.{u1} (fun (_x : Ordinal.{u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) _x) (EmbeddingLike.toFunLike.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1}) Ordinal.{u1} NatOrdinal.{u1} (Function.instEmbeddingLikeEmbedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1})) (RelEmbedding.toEmbedding.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) Ordinal.toNatOrdinal.{u1})) a) (OfNat.ofNat.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) a) 1 (One.toOfNat1.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) a) instNatOrdinalOne.{u1}))) (Eq.{succ (succ u1)} Ordinal.{u1} a (OfNat.ofNat.{succ u1} Ordinal.{u1} 1 (One.toOfNat1.{succ u1} Ordinal.{u1} Ordinal.one.{u1})))
Case conversion may be inaccurate. Consider using '#align ordinal.to_nat_ordinal_eq_one Ordinal.toNatOrdinal_eq_oneₓ'. -/
@[simp]
theorem toNatOrdinal_eq_one (a) : toNatOrdinal a = 1 ↔ a = 1 :=
  Iff.rfl
#align ordinal.to_nat_ordinal_eq_one Ordinal.toNatOrdinal_eq_one

/- warning: ordinal.to_nat_ordinal_max -> Ordinal.toNatOrdinal_max is a dubious translation:
lean 3 declaration is
  forall {a : Ordinal.{u1}} {b : Ordinal.{u1}}, Eq.{succ (succ u1)} NatOrdinal.{u1} (coeFn.{succ (succ u1), succ (succ u1)} (OrderIso.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (fun (_x : RelIso.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))))) => Ordinal.{u1} -> NatOrdinal.{u1}) (RelIso.hasCoeToFun.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))))) Ordinal.toNatOrdinal.{u1} (LinearOrder.max.{succ u1} Ordinal.{u1} Ordinal.linearOrder.{u1} a b)) (LinearOrder.max.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1} (coeFn.{succ (succ u1), succ (succ u1)} (OrderIso.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (fun (_x : RelIso.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))))) => Ordinal.{u1} -> NatOrdinal.{u1}) (RelIso.hasCoeToFun.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))))) Ordinal.toNatOrdinal.{u1} a) (coeFn.{succ (succ u1), succ (succ u1)} (OrderIso.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (fun (_x : RelIso.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))))) => Ordinal.{u1} -> NatOrdinal.{u1}) (RelIso.hasCoeToFun.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))))) Ordinal.toNatOrdinal.{u1} b))
but is expected to have type
  forall {a : Ordinal.{u1}} {b : Ordinal.{u1}}, Eq.{succ (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) (Max.max.{succ u1} Ordinal.{u1} (LinearOrder.toMax.{succ u1} Ordinal.{u1} Ordinal.linearOrder.{u1}) a b)) (FunLike.coe.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1}) Ordinal.{u1} (fun (_x : Ordinal.{u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) _x) (EmbeddingLike.toFunLike.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1}) Ordinal.{u1} NatOrdinal.{u1} (Function.instEmbeddingLikeEmbedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1})) (RelEmbedding.toEmbedding.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) Ordinal.toNatOrdinal.{u1})) (Max.max.{succ u1} Ordinal.{u1} (LinearOrder.toMax.{succ u1} Ordinal.{u1} Ordinal.linearOrder.{u1}) a b)) (Max.max.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) a) (LinearOrder.toMax.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) a) NatOrdinal.linearOrder.{u1}) (FunLike.coe.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1}) Ordinal.{u1} (fun (_x : Ordinal.{u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) _x) (EmbeddingLike.toFunLike.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1}) Ordinal.{u1} NatOrdinal.{u1} (Function.instEmbeddingLikeEmbedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1})) (RelEmbedding.toEmbedding.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) Ordinal.toNatOrdinal.{u1})) a) (FunLike.coe.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1}) Ordinal.{u1} (fun (_x : Ordinal.{u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) _x) (EmbeddingLike.toFunLike.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1}) Ordinal.{u1} NatOrdinal.{u1} (Function.instEmbeddingLikeEmbedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1})) (RelEmbedding.toEmbedding.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) Ordinal.toNatOrdinal.{u1})) b))
Case conversion may be inaccurate. Consider using '#align ordinal.to_nat_ordinal_max Ordinal.toNatOrdinal_maxₓ'. -/
@[simp]
theorem toNatOrdinal_max : toNatOrdinal (max a b) = max a.toNatOrdinal b.toNatOrdinal :=
  rfl
#align ordinal.to_nat_ordinal_max Ordinal.toNatOrdinal_max

/- warning: ordinal.to_nat_ordinal_min -> Ordinal.toNatOrdinal_min is a dubious translation:
lean 3 declaration is
  forall {a : Ordinal.{u1}} {b : Ordinal.{u1}}, Eq.{succ (succ u1)} NatOrdinal.{u1} (coeFn.{succ (succ u1), succ (succ u1)} (OrderIso.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (fun (_x : RelIso.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))))) => Ordinal.{u1} -> NatOrdinal.{u1}) (RelIso.hasCoeToFun.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))))) Ordinal.toNatOrdinal.{u1} (LinearOrder.min.{succ u1} Ordinal.{u1} Ordinal.linearOrder.{u1} a b)) (LinearOrder.min.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1} (coeFn.{succ (succ u1), succ (succ u1)} (OrderIso.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (fun (_x : RelIso.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))))) => Ordinal.{u1} -> NatOrdinal.{u1}) (RelIso.hasCoeToFun.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))))) Ordinal.toNatOrdinal.{u1} a) (coeFn.{succ (succ u1), succ (succ u1)} (OrderIso.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (fun (_x : RelIso.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))))) => Ordinal.{u1} -> NatOrdinal.{u1}) (RelIso.hasCoeToFun.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))))) Ordinal.toNatOrdinal.{u1} b))
but is expected to have type
  forall {a : Ordinal.{u1}} {b : Ordinal.{u1}}, Eq.{succ (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) (Min.min.{succ u1} Ordinal.{u1} (LinearOrder.toMin.{succ u1} Ordinal.{u1} Ordinal.linearOrder.{u1}) a b)) (FunLike.coe.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1}) Ordinal.{u1} (fun (_x : Ordinal.{u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) _x) (EmbeddingLike.toFunLike.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1}) Ordinal.{u1} NatOrdinal.{u1} (Function.instEmbeddingLikeEmbedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1})) (RelEmbedding.toEmbedding.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) Ordinal.toNatOrdinal.{u1})) (Min.min.{succ u1} Ordinal.{u1} (LinearOrder.toMin.{succ u1} Ordinal.{u1} Ordinal.linearOrder.{u1}) a b)) (Min.min.{succ u1} Ordinal.{u1} (LinearOrder.toMin.{succ u1} Ordinal.{u1} Ordinal.linearOrder.{u1}) (FunLike.coe.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1}) Ordinal.{u1} (fun (_x : Ordinal.{u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) _x) (EmbeddingLike.toFunLike.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1}) Ordinal.{u1} NatOrdinal.{u1} (Function.instEmbeddingLikeEmbedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1})) (RelEmbedding.toEmbedding.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) Ordinal.toNatOrdinal.{u1})) a) (FunLike.coe.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1}) Ordinal.{u1} (fun (_x : Ordinal.{u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) _x) (EmbeddingLike.toFunLike.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1}) Ordinal.{u1} NatOrdinal.{u1} (Function.instEmbeddingLikeEmbedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1})) (RelEmbedding.toEmbedding.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) Ordinal.toNatOrdinal.{u1})) b))
Case conversion may be inaccurate. Consider using '#align ordinal.to_nat_ordinal_min Ordinal.toNatOrdinal_minₓ'. -/
@[simp]
theorem toNatOrdinal_min :
    (LinearOrder.min a b).toNatOrdinal = LinearOrder.min a.toNatOrdinal b.toNatOrdinal :=
  rfl
#align ordinal.to_nat_ordinal_min Ordinal.toNatOrdinal_min

#print Ordinal.nadd /-
/-- Natural addition on ordinals `a ♯ b`, also known as the Hessenberg sum, is recursively defined
as the least ordinal greater than `a' ♯ b` and `a ♯ b'` for all `a' < a` and `b' < b`. In contrast
to normal ordinal addition, it is commutative.

Natural addition can equivalently be characterized as the ordinal resulting from adding up
corresponding coefficients in the Cantor normal forms of `a` and `b`. -/
noncomputable def nadd : Ordinal → Ordinal → Ordinal
  | a, b =>
    max (blsub.{u, u} a fun a' h => nadd a' b) (blsub.{u, u} b fun b' h => nadd a b')decreasing_by
  solve_by_elim [PSigma.Lex.left, PSigma.Lex.right]
#align ordinal.nadd Ordinal.nadd
-/

-- mathport name: ordinal.nadd
scoped[NaturalOps] infixl:65 " ♯ " => Ordinal.nadd

/- warning: ordinal.nadd_def -> Ordinal.nadd_def is a dubious translation:
lean 3 declaration is
  forall (a : Ordinal.{u1}) (b : Ordinal.{u1}), Eq.{succ (succ u1)} Ordinal.{u1} (Ordinal.nadd.{u1} a b) (LinearOrder.max.{succ u1} Ordinal.{u1} Ordinal.linearOrder.{u1} (Ordinal.blsub.{u1, u1} a (fun (a' : Ordinal.{u1}) (h : LT.lt.{succ u1} Ordinal.{u1} (Preorder.toLT.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) a' a) => Ordinal.nadd.{u1} a' b)) (Ordinal.blsub.{u1, u1} b (fun (b' : Ordinal.{u1}) (h : LT.lt.{succ u1} Ordinal.{u1} (Preorder.toLT.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) b' b) => Ordinal.nadd.{u1} a b')))
but is expected to have type
  forall (a : Ordinal.{u1}) (b : Ordinal.{u1}), Eq.{succ (succ u1)} Ordinal.{u1} (Ordinal.nadd.{u1} a b) (Max.max.{succ u1} Ordinal.{u1} (LinearOrder.toMax.{succ u1} Ordinal.{u1} Ordinal.linearOrder.{u1}) (Ordinal.blsub.{u1, u1} a (fun (a' : Ordinal.{u1}) (h : LT.lt.{succ u1} Ordinal.{u1} (Preorder.toLT.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) a' a) => Ordinal.nadd.{u1} a' b)) (Ordinal.blsub.{u1, u1} b (fun (b' : Ordinal.{u1}) (h : LT.lt.{succ u1} Ordinal.{u1} (Preorder.toLT.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) b' b) => Ordinal.nadd.{u1} a b')))
Case conversion may be inaccurate. Consider using '#align ordinal.nadd_def Ordinal.nadd_defₓ'. -/
theorem nadd_def (a b : Ordinal) :
    a ♯ b = max (blsub.{u, u} a fun a' h => a' ♯ b) (blsub.{u, u} b fun b' h => a ♯ b') := by
  rw [nadd]
#align ordinal.nadd_def Ordinal.nadd_def

/- warning: ordinal.lt_nadd_iff -> Ordinal.lt_nadd_iff is a dubious translation:
lean 3 declaration is
  forall {a : Ordinal.{u1}} {b : Ordinal.{u1}} {c : Ordinal.{u1}}, Iff (LT.lt.{succ u1} Ordinal.{u1} (Preorder.toLT.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) a (Ordinal.nadd.{u1} b c)) (Or (Exists.{succ (succ u1)} Ordinal.{u1} (fun (b' : Ordinal.{u1}) => Exists.{0} (LT.lt.{succ u1} Ordinal.{u1} (Preorder.toLT.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) b' b) (fun (H : LT.lt.{succ u1} Ordinal.{u1} (Preorder.toLT.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) b' b) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) a (Ordinal.nadd.{u1} b' c)))) (Exists.{succ (succ u1)} Ordinal.{u1} (fun (c' : Ordinal.{u1}) => Exists.{0} (LT.lt.{succ u1} Ordinal.{u1} (Preorder.toLT.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) c' c) (fun (H : LT.lt.{succ u1} Ordinal.{u1} (Preorder.toLT.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) c' c) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) a (Ordinal.nadd.{u1} b c')))))
but is expected to have type
  forall {a : Ordinal.{u1}} {b : Ordinal.{u1}} {c : Ordinal.{u1}}, Iff (LT.lt.{succ u1} Ordinal.{u1} (Preorder.toLT.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) a (Ordinal.nadd.{u1} b c)) (Or (Exists.{succ (succ u1)} Ordinal.{u1} (fun (b' : Ordinal.{u1}) => And (LT.lt.{succ u1} Ordinal.{u1} (Preorder.toLT.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) b' b) (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) a (Ordinal.nadd.{u1} b' c)))) (Exists.{succ (succ u1)} Ordinal.{u1} (fun (c' : Ordinal.{u1}) => And (LT.lt.{succ u1} Ordinal.{u1} (Preorder.toLT.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) c' c) (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) a (Ordinal.nadd.{u1} b c')))))
Case conversion may be inaccurate. Consider using '#align ordinal.lt_nadd_iff Ordinal.lt_nadd_iffₓ'. -/
theorem lt_nadd_iff : a < b ♯ c ↔ (∃ b' < b, a ≤ b' ♯ c) ∨ ∃ c' < c, a ≤ b ♯ c' :=
  by
  rw [nadd_def]
  simp [lt_blsub_iff]
#align ordinal.lt_nadd_iff Ordinal.lt_nadd_iff

#print Ordinal.nadd_le_iff /-
theorem nadd_le_iff : b ♯ c ≤ a ↔ (∀ b' < b, b' ♯ c < a) ∧ ∀ c' < c, b ♯ c' < a :=
  by
  rw [nadd_def]
  simp [blsub_le_iff]
#align ordinal.nadd_le_iff Ordinal.nadd_le_iff
-/

#print Ordinal.nadd_lt_nadd_left /-
theorem nadd_lt_nadd_left (h : b < c) (a) : a ♯ b < a ♯ c :=
  lt_nadd_iff.2 (Or.inr ⟨b, h, le_rfl⟩)
#align ordinal.nadd_lt_nadd_left Ordinal.nadd_lt_nadd_left
-/

#print Ordinal.nadd_lt_nadd_right /-
theorem nadd_lt_nadd_right (h : b < c) (a) : b ♯ a < c ♯ a :=
  lt_nadd_iff.2 (Or.inl ⟨b, h, le_rfl⟩)
#align ordinal.nadd_lt_nadd_right Ordinal.nadd_lt_nadd_right
-/

#print Ordinal.nadd_le_nadd_left /-
theorem nadd_le_nadd_left (h : b ≤ c) (a) : a ♯ b ≤ a ♯ c :=
  by
  rcases lt_or_eq_of_le h with (h | rfl)
  · exact (nadd_lt_nadd_left h a).le
  · exact le_rfl
#align ordinal.nadd_le_nadd_left Ordinal.nadd_le_nadd_left
-/

#print Ordinal.nadd_le_nadd_right /-
theorem nadd_le_nadd_right (h : b ≤ c) (a) : b ♯ a ≤ c ♯ a :=
  by
  rcases lt_or_eq_of_le h with (h | rfl)
  · exact (nadd_lt_nadd_right h a).le
  · exact le_rfl
#align ordinal.nadd_le_nadd_right Ordinal.nadd_le_nadd_right
-/

variable (a b)

#print Ordinal.nadd_comm /-
theorem nadd_comm : ∀ a b, a ♯ b = b ♯ a
  | a, b => by
    rw [nadd_def, nadd_def, max_comm]
    congr <;> ext (c hc) <;> apply nadd_comm decreasing_by
  solve_by_elim [PSigma.Lex.left, PSigma.Lex.right]
#align ordinal.nadd_comm Ordinal.nadd_comm
-/

/- warning: ordinal.blsub_nadd_of_mono -> Ordinal.blsub_nadd_of_mono is a dubious translation:
lean 3 declaration is
  forall (a : Ordinal.{u1}) (b : Ordinal.{u1}) {f : forall (c : Ordinal.{u1}), (LT.lt.{succ u1} Ordinal.{u1} (Preorder.toLT.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) c (Ordinal.nadd.{u1} a b)) -> Ordinal.{max u1 u2}}, (forall {i : Ordinal.{u1}} {j : Ordinal.{u1}} (hi : LT.lt.{succ u1} Ordinal.{u1} (Preorder.toLT.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) i (Ordinal.nadd.{u1} a b)) (hj : LT.lt.{succ u1} Ordinal.{u1} (Preorder.toLT.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) j (Ordinal.nadd.{u1} a b)), (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) i j) -> (LE.le.{succ (max u1 u2)} Ordinal.{max u1 u2} (Preorder.toLE.{succ (max u1 u2)} Ordinal.{max u1 u2} (PartialOrder.toPreorder.{succ (max u1 u2)} Ordinal.{max u1 u2} Ordinal.partialOrder.{max u1 u2})) (f i hi) (f j hj))) -> (Eq.{succ (succ (max u1 u2))} Ordinal.{max u1 u2} (Ordinal.blsub.{u1, u2} (Ordinal.nadd.{u1} a b) f) (LinearOrder.max.{succ (max u1 u2)} Ordinal.{max u1 u2} Ordinal.linearOrder.{max u1 u2} (Ordinal.blsub.{u1, u2} a (fun (a' : Ordinal.{u1}) (ha' : LT.lt.{succ u1} Ordinal.{u1} (Preorder.toLT.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) a' a) => f (Ordinal.nadd.{u1} a' b) (Ordinal.nadd_lt_nadd_right.{u1} a' a ha' b))) (Ordinal.blsub.{u1, u2} b (fun (b' : Ordinal.{u1}) (hb' : LT.lt.{succ u1} Ordinal.{u1} (Preorder.toLT.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) b' b) => f (Ordinal.nadd.{u1} a b') (Ordinal.nadd_lt_nadd_left.{u1} b' b hb' a)))))
but is expected to have type
  forall (a : Ordinal.{u1}) (b : Ordinal.{u1}) {f : forall (c : Ordinal.{u1}), (LT.lt.{succ u1} Ordinal.{u1} (Preorder.toLT.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) c (Ordinal.nadd.{u1} a b)) -> Ordinal.{max u1 u2}}, (forall {i : Ordinal.{u1}} {j : Ordinal.{u1}} (hi : LT.lt.{succ u1} Ordinal.{u1} (Preorder.toLT.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) i (Ordinal.nadd.{u1} a b)) (hj : LT.lt.{succ u1} Ordinal.{u1} (Preorder.toLT.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) j (Ordinal.nadd.{u1} a b)), (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) i j) -> (LE.le.{max (succ u1) (succ u2)} Ordinal.{max u1 u2} (Preorder.toLE.{max (succ u1) (succ u2)} Ordinal.{max u1 u2} (PartialOrder.toPreorder.{max (succ u1) (succ u2)} Ordinal.{max u1 u2} Ordinal.partialOrder.{max u1 u2})) (f i hi) (f j hj))) -> (Eq.{max (succ (succ u1)) (succ (succ u2))} Ordinal.{max u1 u2} (Ordinal.blsub.{u1, u2} (Ordinal.nadd.{u1} a b) f) (Max.max.{max (succ u1) (succ u2)} Ordinal.{max u1 u2} (LinearOrder.toMax.{max (succ u1) (succ u2)} Ordinal.{max u1 u2} Ordinal.linearOrder.{max u1 u2}) (Ordinal.blsub.{u1, u2} a (fun (a' : Ordinal.{u1}) (ha' : LT.lt.{succ u1} Ordinal.{u1} (Preorder.toLT.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) a' a) => f (Ordinal.nadd.{u1} a' b) (Ordinal.nadd_lt_nadd_right.{u1} a' a ha' b))) (Ordinal.blsub.{u1, u2} b (fun (b' : Ordinal.{u1}) (hb' : LT.lt.{succ u1} Ordinal.{u1} (Preorder.toLT.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) b' b) => f (Ordinal.nadd.{u1} a b') (Ordinal.nadd_lt_nadd_left.{u1} b' b hb' a)))))
Case conversion may be inaccurate. Consider using '#align ordinal.blsub_nadd_of_mono Ordinal.blsub_nadd_of_monoₓ'. -/
theorem blsub_nadd_of_mono {f : ∀ c < a ♯ b, Ordinal.{max u v}}
    (hf : ∀ {i j} (hi hj), i ≤ j → f i hi ≤ f j hj) :
    blsub _ f =
      max (blsub.{u, v} a fun a' ha' => f (a' ♯ b) <| nadd_lt_nadd_right ha' b)
        (blsub.{u, v} b fun b' hb' => f (a ♯ b') <| nadd_lt_nadd_left hb' a) :=
  by
  apply (blsub_le_iff.2 fun i h => _).antisymm (max_le _ _)
  · rcases lt_nadd_iff.1 h with (⟨a', ha', hi⟩ | ⟨b', hb', hi⟩)
    · exact lt_max_of_lt_left ((hf h (nadd_lt_nadd_right ha' b) hi).trans_lt (lt_blsub _ _ _))
    · exact lt_max_of_lt_right ((hf h (nadd_lt_nadd_left hb' a) hi).trans_lt (lt_blsub _ _ _))
  all_goals
    apply blsub_le_of_brange_subset.{u, u, v}
    rintro c ⟨d, hd, rfl⟩
    apply mem_brange_self
#align ordinal.blsub_nadd_of_mono Ordinal.blsub_nadd_of_mono

#print Ordinal.nadd_assoc /-
theorem nadd_assoc : ∀ a b c, a ♯ b ♯ c = a ♯ (b ♯ c)
  | a, b, c =>
    by
    rw [nadd_def a (b ♯ c), nadd_def, blsub_nadd_of_mono, blsub_nadd_of_mono, max_assoc]
    · congr <;> ext (d hd) <;> apply nadd_assoc
    · exact fun i j _ _ h => nadd_le_nadd_left h a
    · exact fun i j _ _ h => nadd_le_nadd_right h c decreasing_by
  solve_by_elim [PSigma.Lex.left, PSigma.Lex.right]
#align ordinal.nadd_assoc Ordinal.nadd_assoc
-/

#print Ordinal.nadd_zero /-
@[simp]
theorem nadd_zero : a ♯ 0 = a :=
  by
  induction' a using Ordinal.induction with a IH
  rw [nadd_def, blsub_zero, max_zero_right]
  convert blsub_id a
  ext (b hb)
  exact IH _ hb
#align ordinal.nadd_zero Ordinal.nadd_zero
-/

#print Ordinal.zero_nadd /-
@[simp]
theorem zero_nadd : 0 ♯ a = a := by rw [nadd_comm, nadd_zero]
#align ordinal.zero_nadd Ordinal.zero_nadd
-/

/- warning: ordinal.nadd_one -> Ordinal.nadd_one is a dubious translation:
lean 3 declaration is
  forall (a : Ordinal.{u1}), Eq.{succ (succ u1)} Ordinal.{u1} (Ordinal.nadd.{u1} a (OfNat.ofNat.{succ u1} Ordinal.{u1} 1 (OfNat.mk.{succ u1} Ordinal.{u1} 1 (One.one.{succ u1} Ordinal.{u1} Ordinal.hasOne.{u1})))) (Order.succ.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}) Ordinal.succOrder.{u1} a)
but is expected to have type
  forall (a : Ordinal.{u1}), Eq.{succ (succ u1)} Ordinal.{u1} (Ordinal.nadd.{u1} a (OfNat.ofNat.{succ u1} Ordinal.{u1} 1 (One.toOfNat1.{succ u1} Ordinal.{u1} Ordinal.one.{u1}))) (Order.succ.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}) Ordinal.succOrder.{u1} a)
Case conversion may be inaccurate. Consider using '#align ordinal.nadd_one Ordinal.nadd_oneₓ'. -/
@[simp]
theorem nadd_one : a ♯ 1 = succ a :=
  by
  induction' a using Ordinal.induction with a IH
  rw [nadd_def, blsub_one, nadd_zero, max_eq_right_iff, blsub_le_iff]
  intro i hi
  rwa [IH i hi, succ_lt_succ_iff]
#align ordinal.nadd_one Ordinal.nadd_one

/- warning: ordinal.one_nadd -> Ordinal.one_nadd is a dubious translation:
lean 3 declaration is
  forall (a : Ordinal.{u1}), Eq.{succ (succ u1)} Ordinal.{u1} (Ordinal.nadd.{u1} (OfNat.ofNat.{succ u1} Ordinal.{u1} 1 (OfNat.mk.{succ u1} Ordinal.{u1} 1 (One.one.{succ u1} Ordinal.{u1} Ordinal.hasOne.{u1}))) a) (Order.succ.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}) Ordinal.succOrder.{u1} a)
but is expected to have type
  forall (a : Ordinal.{u1}), Eq.{succ (succ u1)} Ordinal.{u1} (Ordinal.nadd.{u1} (OfNat.ofNat.{succ u1} Ordinal.{u1} 1 (One.toOfNat1.{succ u1} Ordinal.{u1} Ordinal.one.{u1})) a) (Order.succ.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}) Ordinal.succOrder.{u1} a)
Case conversion may be inaccurate. Consider using '#align ordinal.one_nadd Ordinal.one_naddₓ'. -/
@[simp]
theorem one_nadd : 1 ♯ a = succ a := by rw [nadd_comm, nadd_one]
#align ordinal.one_nadd Ordinal.one_nadd

#print Ordinal.nadd_succ /-
theorem nadd_succ : a ♯ succ b = succ (a ♯ b) := by rw [← nadd_one (a ♯ b), nadd_assoc, nadd_one]
#align ordinal.nadd_succ Ordinal.nadd_succ
-/

#print Ordinal.succ_nadd /-
theorem succ_nadd : succ a ♯ b = succ (a ♯ b) := by rw [← one_nadd (a ♯ b), ← nadd_assoc, one_nadd]
#align ordinal.succ_nadd Ordinal.succ_nadd
-/

#print Ordinal.nadd_nat /-
@[simp]
theorem nadd_nat (n : ℕ) : a ♯ n = a + n :=
  by
  induction' n with n hn
  · simp
  · rw [Nat.cast_succ, add_one_eq_succ, nadd_succ, add_succ, hn]
#align ordinal.nadd_nat Ordinal.nadd_nat
-/

#print Ordinal.nat_nadd /-
@[simp]
theorem nat_nadd (n : ℕ) : ↑n ♯ a = a + n := by rw [nadd_comm, nadd_nat]
#align ordinal.nat_nadd Ordinal.nat_nadd
-/

#print Ordinal.add_le_nadd /-
theorem add_le_nadd : a + b ≤ a ♯ b := by
  apply b.limit_rec_on
  · simp
  · intro c h
    rwa [add_succ, nadd_succ, succ_le_succ_iff]
  · intro c hc H
    rw [← IsNormal.blsub_eq.{u, u} (add_is_normal a) hc, blsub_le_iff]
    exact fun i hi => (H i hi).trans_lt (nadd_lt_nadd_left hi a)
#align ordinal.add_le_nadd Ordinal.add_le_nadd
-/

end Ordinal

open Ordinal

namespace NatOrdinal

instance : Add NatOrdinal :=
  ⟨nadd⟩

#print NatOrdinal.add_covariantClass_lt /-
instance add_covariantClass_lt : CovariantClass NatOrdinal.{u} NatOrdinal.{u} (· + ·) (· < ·) :=
  ⟨fun a b c h => nadd_lt_nadd_left h a⟩
#align nat_ordinal.add_covariant_class_lt NatOrdinal.add_covariantClass_lt
-/

#print NatOrdinal.add_covariantClass_le /-
instance add_covariantClass_le : CovariantClass NatOrdinal.{u} NatOrdinal.{u} (· + ·) (· ≤ ·) :=
  ⟨fun a b c h => nadd_le_nadd_left h a⟩
#align nat_ordinal.add_covariant_class_le NatOrdinal.add_covariantClass_le
-/

#print NatOrdinal.add_contravariantClass_le /-
instance add_contravariantClass_le :
    ContravariantClass NatOrdinal.{u} NatOrdinal.{u} (· + ·) (· ≤ ·) :=
  ⟨fun a b c h => by
    by_contra' h'
    exact h.not_lt (add_lt_add_left h' a)⟩
#align nat_ordinal.add_contravariant_class_le NatOrdinal.add_contravariantClass_le
-/

instance : OrderedCancelAddCommMonoid NatOrdinal :=
  { NatOrdinal.linearOrder with
    add := (· + ·)
    add_assoc := nadd_assoc
    add_le_add_left := fun a b => add_le_add_left
    le_of_add_le_add_left := fun a b c => le_of_add_le_add_left
    zero := 0
    zero_add := zero_nadd
    add_zero := nadd_zero
    add_comm := nadd_comm }

instance : AddMonoidWithOne NatOrdinal :=
  AddMonoidWithOne.unary

/- warning: nat_ordinal.add_one_eq_succ -> NatOrdinal.add_one_eq_succ is a dubious translation:
lean 3 declaration is
  forall (a : NatOrdinal.{u1}), Eq.{succ (succ u1)} NatOrdinal.{u1} (HAdd.hAdd.{succ u1, succ u1, succ u1} NatOrdinal.{u1} NatOrdinal.{u1} NatOrdinal.{u1} (instHAdd.{succ u1} NatOrdinal.{u1} NatOrdinal.hasAdd.{u1}) a (OfNat.ofNat.{succ u1} NatOrdinal.{u1} 1 (OfNat.mk.{succ u1} NatOrdinal.{u1} 1 (One.one.{succ u1} NatOrdinal.{u1} NatOrdinal.hasOne.{u1})))) (Order.succ.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (OrderedCancelAddCommMonoid.toPartialOrder.{succ u1} NatOrdinal.{u1} NatOrdinal.orderedCancelAddCommMonoid.{u1})) NatOrdinal.succOrder.{u1} a)
but is expected to have type
  forall (a : NatOrdinal.{u1}), Eq.{succ (succ u1)} NatOrdinal.{u1} (HAdd.hAdd.{succ u1, succ u1, succ u1} NatOrdinal.{u1} NatOrdinal.{u1} NatOrdinal.{u1} (instHAdd.{succ u1} NatOrdinal.{u1} NatOrdinal.instAddNatOrdinal.{u1}) a (OfNat.ofNat.{succ u1} NatOrdinal.{u1} 1 (One.toOfNat1.{succ u1} NatOrdinal.{u1} instNatOrdinalOne.{u1}))) (Order.succ.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (OrderedCancelAddCommMonoid.toPartialOrder.{succ u1} NatOrdinal.{u1} NatOrdinal.instOrderedCancelAddCommMonoidNatOrdinal.{u1})) NatOrdinal.succOrder.{u1} a)
Case conversion may be inaccurate. Consider using '#align nat_ordinal.add_one_eq_succ NatOrdinal.add_one_eq_succₓ'. -/
@[simp]
theorem add_one_eq_succ : ∀ a : NatOrdinal, a + 1 = succ a :=
  nadd_one
#align nat_ordinal.add_one_eq_succ NatOrdinal.add_one_eq_succ

/- warning: nat_ordinal.to_ordinal_cast_nat -> NatOrdinal.toOrdinal_cast_nat is a dubious translation:
lean 3 declaration is
  forall (n : Nat), Eq.{succ (succ u1)} Ordinal.{u1} (coeFn.{succ (succ u1), succ (succ u1)} (OrderIso.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))) (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (fun (_x : RelIso.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})))) => NatOrdinal.{u1} -> Ordinal.{u1}) (RelIso.hasCoeToFun.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})))) NatOrdinal.toOrdinal.{u1} ((fun (a : Type) (b : Type.{succ u1}) [self : HasLiftT.{1, succ (succ u1)} a b] => self.0) Nat NatOrdinal.{u1} (HasLiftT.mk.{1, succ (succ u1)} Nat NatOrdinal.{u1} (CoeTCₓ.coe.{1, succ (succ u1)} Nat NatOrdinal.{u1} (Nat.castCoe.{succ u1} NatOrdinal.{u1} (AddMonoidWithOne.toNatCast.{succ u1} NatOrdinal.{u1} NatOrdinal.addMonoidWithOne.{u1})))) n)) ((fun (a : Type) (b : Type.{succ u1}) [self : HasLiftT.{1, succ (succ u1)} a b] => self.0) Nat Ordinal.{u1} (HasLiftT.mk.{1, succ (succ u1)} Nat Ordinal.{u1} (CoeTCₓ.coe.{1, succ (succ u1)} Nat Ordinal.{u1} (Nat.castCoe.{succ u1} Ordinal.{u1} (AddMonoidWithOne.toNatCast.{succ u1} Ordinal.{u1} Ordinal.addMonoidWithOne.{u1})))) n)
but is expected to have type
  forall (n : Nat), Eq.{succ (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) (Nat.cast.{succ u1} NatOrdinal.{u1} (AddMonoidWithOne.toNatCast.{succ u1} NatOrdinal.{u1} NatOrdinal.addMonoidWithOne.{u1}) n)) (FunLike.coe.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1}) NatOrdinal.{u1} (fun (_x : NatOrdinal.{u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) _x) (EmbeddingLike.toFunLike.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1}) NatOrdinal.{u1} Ordinal.{u1} (Function.instEmbeddingLikeEmbedding.{succ (succ u1), succ (succ u1)} NatOrdinal.{u1} Ordinal.{u1})) (RelEmbedding.toEmbedding.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{succ u1, succ u1} NatOrdinal.{u1} Ordinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) NatOrdinal.toOrdinal.{u1})) (Nat.cast.{succ u1} NatOrdinal.{u1} (AddMonoidWithOne.toNatCast.{succ u1} NatOrdinal.{u1} NatOrdinal.addMonoidWithOne.{u1}) n)) (Nat.cast.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) (Nat.cast.{succ u1} NatOrdinal.{u1} (AddMonoidWithOne.toNatCast.{succ u1} NatOrdinal.{u1} NatOrdinal.addMonoidWithOne.{u1}) n)) (AddMonoidWithOne.toNatCast.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : NatOrdinal.{u1}) => Ordinal.{u1}) (Nat.cast.{succ u1} NatOrdinal.{u1} (AddMonoidWithOne.toNatCast.{succ u1} NatOrdinal.{u1} NatOrdinal.addMonoidWithOne.{u1}) n)) Ordinal.addMonoidWithOne.{u1}) n)
Case conversion may be inaccurate. Consider using '#align nat_ordinal.to_ordinal_cast_nat NatOrdinal.toOrdinal_cast_natₓ'. -/
@[simp]
theorem toOrdinal_cast_nat (n : ℕ) : toOrdinal n = n :=
  by
  induction' n with n hn
  · rfl
  · change nadd (to_ordinal n) 1 = n + 1
    rw [hn]
    apply nadd_one
#align nat_ordinal.to_ordinal_cast_nat NatOrdinal.toOrdinal_cast_nat

end NatOrdinal

open NatOrdinal

open NaturalOps

namespace Ordinal

/- warning: ordinal.to_nat_ordinal_cast_nat -> Ordinal.toNatOrdinal_cast_nat is a dubious translation:
lean 3 declaration is
  forall (n : Nat), Eq.{succ (succ u1)} NatOrdinal.{u1} (coeFn.{succ (succ u1), succ (succ u1)} (OrderIso.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) (fun (_x : RelIso.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))))) => Ordinal.{u1} -> NatOrdinal.{u1}) (RelIso.hasCoeToFun.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1}))) (LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (LinearOrder.toLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1}))))))) Ordinal.toNatOrdinal.{u1} ((fun (a : Type) (b : Type.{succ u1}) [self : HasLiftT.{1, succ (succ u1)} a b] => self.0) Nat Ordinal.{u1} (HasLiftT.mk.{1, succ (succ u1)} Nat Ordinal.{u1} (CoeTCₓ.coe.{1, succ (succ u1)} Nat Ordinal.{u1} (Nat.castCoe.{succ u1} Ordinal.{u1} (AddMonoidWithOne.toNatCast.{succ u1} Ordinal.{u1} Ordinal.addMonoidWithOne.{u1})))) n)) ((fun (a : Type) (b : Type.{succ u1}) [self : HasLiftT.{1, succ (succ u1)} a b] => self.0) Nat NatOrdinal.{u1} (HasLiftT.mk.{1, succ (succ u1)} Nat NatOrdinal.{u1} (CoeTCₓ.coe.{1, succ (succ u1)} Nat NatOrdinal.{u1} (Nat.castCoe.{succ u1} NatOrdinal.{u1} (AddMonoidWithOne.toNatCast.{succ u1} NatOrdinal.{u1} NatOrdinal.addMonoidWithOne.{u1})))) n)
but is expected to have type
  forall (n : Nat), Eq.{succ (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) (Nat.cast.{succ u1} Ordinal.{u1} (AddMonoidWithOne.toNatCast.{succ u1} Ordinal.{u1} Ordinal.addMonoidWithOne.{u1}) n)) (FunLike.coe.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1}) Ordinal.{u1} (fun (_x : Ordinal.{u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) _x) (EmbeddingLike.toFunLike.{succ (succ u1), succ (succ u1), succ (succ u1)} (Function.Embedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1}) Ordinal.{u1} NatOrdinal.{u1} (Function.instEmbeddingLikeEmbedding.{succ (succ u1), succ (succ u1)} Ordinal.{u1} NatOrdinal.{u1})) (RelEmbedding.toEmbedding.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{succ u1, succ u1} Ordinal.{u1} NatOrdinal.{u1} (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Ordinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Ordinal.{u1}) => LE.le.{succ u1} Ordinal.{u1} (Preorder.toLE.{succ u1} Ordinal.{u1} (PartialOrder.toPreorder.{succ u1} Ordinal.{u1} Ordinal.partialOrder.{u1})) x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : NatOrdinal.{u1}) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : NatOrdinal.{u1}) => LE.le.{succ u1} NatOrdinal.{u1} (Preorder.toLE.{succ u1} NatOrdinal.{u1} (PartialOrder.toPreorder.{succ u1} NatOrdinal.{u1} (SemilatticeInf.toPartialOrder.{succ u1} NatOrdinal.{u1} (Lattice.toSemilatticeInf.{succ u1} NatOrdinal.{u1} (DistribLattice.toLattice.{succ u1} NatOrdinal.{u1} (instDistribLattice.{succ u1} NatOrdinal.{u1} NatOrdinal.linearOrder.{u1})))))) x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) Ordinal.toNatOrdinal.{u1})) (Nat.cast.{succ u1} Ordinal.{u1} (AddMonoidWithOne.toNatCast.{succ u1} Ordinal.{u1} Ordinal.addMonoidWithOne.{u1}) n)) (Nat.cast.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) (Nat.cast.{succ u1} Ordinal.{u1} (AddMonoidWithOne.toNatCast.{succ u1} Ordinal.{u1} Ordinal.addMonoidWithOne.{u1}) n)) (AddMonoidWithOne.toNatCast.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Ordinal.{u1}) => NatOrdinal.{u1}) (Nat.cast.{succ u1} Ordinal.{u1} (AddMonoidWithOne.toNatCast.{succ u1} Ordinal.{u1} Ordinal.addMonoidWithOne.{u1}) n)) NatOrdinal.addMonoidWithOne.{u1}) n)
Case conversion may be inaccurate. Consider using '#align ordinal.to_nat_ordinal_cast_nat Ordinal.toNatOrdinal_cast_natₓ'. -/
@[simp]
theorem toNatOrdinal_cast_nat (n : ℕ) : toNatOrdinal n = n :=
  by
  rw [← to_ordinal_cast_nat n]
  rfl
#align ordinal.to_nat_ordinal_cast_nat Ordinal.toNatOrdinal_cast_nat

#print Ordinal.lt_of_nadd_lt_nadd_left /-
theorem lt_of_nadd_lt_nadd_left : ∀ {a b c}, a ♯ b < a ♯ c → b < c :=
  @lt_of_add_lt_add_left NatOrdinal _ _ _
#align ordinal.lt_of_nadd_lt_nadd_left Ordinal.lt_of_nadd_lt_nadd_left
-/

#print Ordinal.lt_of_nadd_lt_nadd_right /-
theorem lt_of_nadd_lt_nadd_right : ∀ {a b c}, b ♯ a < c ♯ a → b < c :=
  @lt_of_add_lt_add_right NatOrdinal _ _ _
#align ordinal.lt_of_nadd_lt_nadd_right Ordinal.lt_of_nadd_lt_nadd_right
-/

#print Ordinal.le_of_nadd_le_nadd_left /-
theorem le_of_nadd_le_nadd_left : ∀ {a b c}, a ♯ b ≤ a ♯ c → b ≤ c :=
  @le_of_add_le_add_left NatOrdinal _ _ _
#align ordinal.le_of_nadd_le_nadd_left Ordinal.le_of_nadd_le_nadd_left
-/

#print Ordinal.le_of_nadd_le_nadd_right /-
theorem le_of_nadd_le_nadd_right : ∀ {a b c}, b ♯ a ≤ c ♯ a → b ≤ c :=
  @le_of_add_le_add_right NatOrdinal _ _ _
#align ordinal.le_of_nadd_le_nadd_right Ordinal.le_of_nadd_le_nadd_right
-/

#print Ordinal.nadd_lt_nadd_iff_left /-
theorem nadd_lt_nadd_iff_left : ∀ (a) {b c}, a ♯ b < a ♯ c ↔ b < c :=
  @add_lt_add_iff_left NatOrdinal _ _ _ _
#align ordinal.nadd_lt_nadd_iff_left Ordinal.nadd_lt_nadd_iff_left
-/

#print Ordinal.nadd_lt_nadd_iff_right /-
theorem nadd_lt_nadd_iff_right : ∀ (a) {b c}, b ♯ a < c ♯ a ↔ b < c :=
  @add_lt_add_iff_right NatOrdinal _ _ _ _
#align ordinal.nadd_lt_nadd_iff_right Ordinal.nadd_lt_nadd_iff_right
-/

#print Ordinal.nadd_le_nadd_iff_left /-
theorem nadd_le_nadd_iff_left : ∀ (a) {b c}, a ♯ b ≤ a ♯ c ↔ b ≤ c :=
  @add_le_add_iff_left NatOrdinal _ _ _ _
#align ordinal.nadd_le_nadd_iff_left Ordinal.nadd_le_nadd_iff_left
-/

#print Ordinal.nadd_le_nadd_iff_right /-
theorem nadd_le_nadd_iff_right : ∀ (a) {b c}, b ♯ a ≤ c ♯ a ↔ b ≤ c :=
  @add_le_add_iff_right NatOrdinal _ _ _ _
#align ordinal.nadd_le_nadd_iff_right Ordinal.nadd_le_nadd_iff_right
-/

#print Ordinal.nadd_left_cancel /-
theorem nadd_left_cancel : ∀ {a b c}, a ♯ b = a ♯ c → b = c :=
  @add_left_cancel NatOrdinal _ _
#align ordinal.nadd_left_cancel Ordinal.nadd_left_cancel
-/

#print Ordinal.nadd_right_cancel /-
theorem nadd_right_cancel : ∀ {a b c}, a ♯ b = c ♯ b → a = c :=
  @add_right_cancel NatOrdinal _ _
#align ordinal.nadd_right_cancel Ordinal.nadd_right_cancel
-/

#print Ordinal.nadd_left_cancel_iff /-
theorem nadd_left_cancel_iff : ∀ {a b c}, a ♯ b = a ♯ c ↔ b = c :=
  @add_left_cancel_iff NatOrdinal _ _
#align ordinal.nadd_left_cancel_iff Ordinal.nadd_left_cancel_iff
-/

#print Ordinal.nadd_right_cancel_iff /-
theorem nadd_right_cancel_iff : ∀ {a b c}, b ♯ a = c ♯ a ↔ b = c :=
  @add_right_cancel_iff NatOrdinal _ _
#align ordinal.nadd_right_cancel_iff Ordinal.nadd_right_cancel_iff
-/

end Ordinal

