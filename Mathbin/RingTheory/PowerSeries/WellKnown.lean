/-
Copyright (c) 2020 Yury G. Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury G. Kudryashov

! This file was ported from Lean 3 source module ring_theory.power_series.well_known
! leanprover-community/mathlib commit 38df578a6450a8c5142b3727e3ae894c2300cae0
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.RingTheory.PowerSeries.Basic
import Mathbin.Data.Nat.Parity
import Mathbin.Algebra.BigOperators.NatAntidiagonal

/-!
# Definition of well-known power series

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file we define the following power series:

* `power_series.inv_units_sub`: given `u : Rˣ`, this is the series for `1 / (u - x)`.
  It is given by `∑ n, x ^ n /ₚ u ^ (n + 1)`.

* `power_series.sin`, `power_series.cos`, `power_series.exp` : power series for sin, cosine, and
  exponential functions.
-/


namespace PowerSeries

section Ring

variable {R S : Type _} [Ring R] [Ring S]

/- warning: power_series.inv_units_sub -> PowerSeries.invUnitsSub is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R], (Units.{u1} R (Ring.toMonoid.{u1} R _inst_1)) -> (PowerSeries.{u1} R)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R], (Units.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) -> (PowerSeries.{u1} R)
Case conversion may be inaccurate. Consider using '#align power_series.inv_units_sub PowerSeries.invUnitsSubₓ'. -/
/-- The power series for `1 / (u - x)`. -/
def invUnitsSub (u : Rˣ) : PowerSeries R :=
  mk fun n => 1 /ₚ u ^ (n + 1)
#align power_series.inv_units_sub PowerSeries.invUnitsSub

/- warning: power_series.coeff_inv_units_sub -> PowerSeries.coeff_invUnitsSub is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] (u : Units.{u1} R (Ring.toMonoid.{u1} R _inst_1)) (n : Nat), Eq.{succ u1} R (coeFn.{succ u1, succ u1} (LinearMap.{u1, u1, u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (PowerSeries.{u1} R) R (PowerSeries.addCommMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (PowerSeries.module.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (fun (_x : LinearMap.{u1, u1, u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (PowerSeries.{u1} R) R (PowerSeries.addCommMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (PowerSeries.module.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1))) => (PowerSeries.{u1} R) -> R) (LinearMap.hasCoeToFun.{u1, u1, u1, u1} R R (PowerSeries.{u1} R) R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (PowerSeries.addCommMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (PowerSeries.module.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (PowerSeries.coeff.{u1} R (Ring.toSemiring.{u1} R _inst_1) n) (PowerSeries.invUnitsSub.{u1} R _inst_1 u)) (divp.{u1} R (Ring.toMonoid.{u1} R _inst_1) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))))) (HPow.hPow.{u1, 0, u1} (Units.{u1} R (Ring.toMonoid.{u1} R _inst_1)) Nat (Units.{u1} R (Ring.toMonoid.{u1} R _inst_1)) (instHPow.{u1, 0} (Units.{u1} R (Ring.toMonoid.{u1} R _inst_1)) Nat (Monoid.Pow.{u1} (Units.{u1} R (Ring.toMonoid.{u1} R _inst_1)) (DivInvMonoid.toMonoid.{u1} (Units.{u1} R (Ring.toMonoid.{u1} R _inst_1)) (Group.toDivInvMonoid.{u1} (Units.{u1} R (Ring.toMonoid.{u1} R _inst_1)) (Units.group.{u1} R (Ring.toMonoid.{u1} R _inst_1)))))) u (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] (u : Units.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (n : Nat), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : PowerSeries.{u1} R) => R) (PowerSeries.invUnitsSub.{u1} R _inst_1 u)) (FunLike.coe.{succ u1, succ u1, succ u1} (LinearMap.{u1, u1, u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (PowerSeries.{u1} R) R (PowerSeries.instAddCommMonoidPowerSeries.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (PowerSeries.instModulePowerSeriesInstAddCommMonoidPowerSeries.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (PowerSeries.{u1} R) (fun (_x : PowerSeries.{u1} R) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : PowerSeries.{u1} R) => R) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u1, u1} R R (PowerSeries.{u1} R) R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (PowerSeries.instAddCommMonoidPowerSeries.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (PowerSeries.instModulePowerSeriesInstAddCommMonoidPowerSeries.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (PowerSeries.coeff.{u1} R (Ring.toSemiring.{u1} R _inst_1) n) (PowerSeries.invUnitsSub.{u1} R _inst_1 u)) (divp.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : PowerSeries.{u1} R) => R) (PowerSeries.invUnitsSub.{u1} R _inst_1 u)) (MonoidWithZero.toMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : PowerSeries.{u1} R) => R) (PowerSeries.invUnitsSub.{u1} R _inst_1 u)) (Semiring.toMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : PowerSeries.{u1} R) => R) (PowerSeries.invUnitsSub.{u1} R _inst_1 u)) (Ring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : PowerSeries.{u1} R) => R) (PowerSeries.invUnitsSub.{u1} R _inst_1 u)) _inst_1))) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : PowerSeries.{u1} R) => R) (PowerSeries.invUnitsSub.{u1} R _inst_1 u)) 1 (One.toOfNat1.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : PowerSeries.{u1} R) => R) (PowerSeries.invUnitsSub.{u1} R _inst_1 u)) (Semiring.toOne.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : PowerSeries.{u1} R) => R) (PowerSeries.invUnitsSub.{u1} R _inst_1 u)) (Ring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : PowerSeries.{u1} R) => R) (PowerSeries.invUnitsSub.{u1} R _inst_1 u)) _inst_1)))) (HPow.hPow.{u1, 0, u1} (Units.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) Nat (Units.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : PowerSeries.{u1} R) => R) (PowerSeries.invUnitsSub.{u1} R _inst_1 u)) (MonoidWithZero.toMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : PowerSeries.{u1} R) => R) (PowerSeries.invUnitsSub.{u1} R _inst_1 u)) (Semiring.toMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : PowerSeries.{u1} R) => R) (PowerSeries.invUnitsSub.{u1} R _inst_1 u)) (Ring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : PowerSeries.{u1} R) => R) (PowerSeries.invUnitsSub.{u1} R _inst_1 u)) _inst_1)))) (instHPow.{u1, 0} (Units.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) Nat (Monoid.Pow.{u1} (Units.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (DivInvMonoid.toMonoid.{u1} (Units.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Group.toDivInvMonoid.{u1} (Units.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Units.instGroupUnits.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))))))) u (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))
Case conversion may be inaccurate. Consider using '#align power_series.coeff_inv_units_sub PowerSeries.coeff_invUnitsSubₓ'. -/
@[simp]
theorem coeff_invUnitsSub (u : Rˣ) (n : ℕ) : coeff R n (invUnitsSub u) = 1 /ₚ u ^ (n + 1) :=
  coeff_mk _ _
#align power_series.coeff_inv_units_sub PowerSeries.coeff_invUnitsSub

/- warning: power_series.constant_coeff_inv_units_sub -> PowerSeries.constantCoeff_invUnitsSub is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] (u : Units.{u1} R (Ring.toMonoid.{u1} R _inst_1)), Eq.{succ u1} R (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} (PowerSeries.{u1} R) R (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} R) (PowerSeries.semiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} (PowerSeries.{u1} R) R (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} R) (PowerSeries.semiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) => (PowerSeries.{u1} R) -> R) (RingHom.hasCoeToFun.{u1, u1} (PowerSeries.{u1} R) R (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} R) (PowerSeries.semiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (PowerSeries.constantCoeff.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (PowerSeries.invUnitsSub.{u1} R _inst_1 u)) (divp.{u1} R (Ring.toMonoid.{u1} R _inst_1) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))))) u)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] (u : Units.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : PowerSeries.{u1} R) => R) (PowerSeries.invUnitsSub.{u1} R _inst_1 u)) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} (PowerSeries.{u1} R) R (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} R) (PowerSeries.instSemiringPowerSeries.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (PowerSeries.{u1} R) (fun (_x : PowerSeries.{u1} R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : PowerSeries.{u1} R) => R) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} (PowerSeries.{u1} R) R (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} R) (PowerSeries.instSemiringPowerSeries.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (PowerSeries.{u1} R) R (NonUnitalNonAssocSemiring.toMul.{u1} (PowerSeries.{u1} R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (PowerSeries.{u1} R) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} R) (PowerSeries.instSemiringPowerSeries.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} (PowerSeries.{u1} R) R (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} R) (PowerSeries.instSemiringPowerSeries.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (PowerSeries.{u1} R) R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (PowerSeries.{u1} R) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} R) (PowerSeries.instSemiringPowerSeries.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} (PowerSeries.{u1} R) R (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} R) (PowerSeries.instSemiringPowerSeries.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (PowerSeries.{u1} R) R (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} R) (PowerSeries.instSemiringPowerSeries.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} (PowerSeries.{u1} R) R (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} R) (PowerSeries.instSemiringPowerSeries.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))))) (PowerSeries.constantCoeff.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (PowerSeries.invUnitsSub.{u1} R _inst_1 u)) (divp.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) u)
Case conversion may be inaccurate. Consider using '#align power_series.constant_coeff_inv_units_sub PowerSeries.constantCoeff_invUnitsSubₓ'. -/
@[simp]
theorem constantCoeff_invUnitsSub (u : Rˣ) : constantCoeff R (invUnitsSub u) = 1 /ₚ u := by
  rw [← coeff_zero_eq_constant_coeff_apply, coeff_inv_units_sub, zero_add, pow_one]
#align power_series.constant_coeff_inv_units_sub PowerSeries.constantCoeff_invUnitsSub

/- warning: power_series.inv_units_sub_mul_X -> PowerSeries.invUnitsSub_mul_X is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] (u : Units.{u1} R (Ring.toMonoid.{u1} R _inst_1)), Eq.{succ u1} (PowerSeries.{u1} R) (HMul.hMul.{u1, u1, u1} (PowerSeries.{u1} R) (PowerSeries.{u1} R) (PowerSeries.{u1} R) (instHMul.{u1} (PowerSeries.{u1} R) (Distrib.toHasMul.{u1} (PowerSeries.{u1} R) (Ring.toDistrib.{u1} (PowerSeries.{u1} R) (PowerSeries.ring.{u1} R _inst_1)))) (PowerSeries.invUnitsSub.{u1} R _inst_1 u) (PowerSeries.X.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (HSub.hSub.{u1, u1, u1} (PowerSeries.{u1} R) (PowerSeries.{u1} R) (PowerSeries.{u1} R) (instHSub.{u1} (PowerSeries.{u1} R) (SubNegMonoid.toHasSub.{u1} (PowerSeries.{u1} R) (AddGroup.toSubNegMonoid.{u1} (PowerSeries.{u1} R) (PowerSeries.addGroup.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))))) (HMul.hMul.{u1, u1, u1} (PowerSeries.{u1} R) (PowerSeries.{u1} R) (PowerSeries.{u1} R) (instHMul.{u1} (PowerSeries.{u1} R) (Distrib.toHasMul.{u1} (PowerSeries.{u1} R) (Ring.toDistrib.{u1} (PowerSeries.{u1} R) (PowerSeries.ring.{u1} R _inst_1)))) (PowerSeries.invUnitsSub.{u1} R _inst_1 u) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (PowerSeries.{u1} R) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} R) (PowerSeries.semiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (fun (_x : RingHom.{u1, u1} R (PowerSeries.{u1} R) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} R) (PowerSeries.semiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) => R -> (PowerSeries.{u1} R)) (RingHom.hasCoeToFun.{u1, u1} R (PowerSeries.{u1} R) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} R) (PowerSeries.semiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (PowerSeries.C.{u1} R (Ring.toSemiring.{u1} R _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} R (Ring.toMonoid.{u1} R _inst_1)) R (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} R (Ring.toMonoid.{u1} R _inst_1)) R (CoeTCₓ.coe.{succ u1, succ u1} (Units.{u1} R (Ring.toMonoid.{u1} R _inst_1)) R (coeBase.{succ u1, succ u1} (Units.{u1} R (Ring.toMonoid.{u1} R _inst_1)) R (Units.hasCoe.{u1} R (Ring.toMonoid.{u1} R _inst_1))))) u))) (OfNat.ofNat.{u1} (PowerSeries.{u1} R) 1 (OfNat.mk.{u1} (PowerSeries.{u1} R) 1 (One.one.{u1} (PowerSeries.{u1} R) (AddMonoidWithOne.toOne.{u1} (PowerSeries.{u1} R) (AddGroupWithOne.toAddMonoidWithOne.{u1} (PowerSeries.{u1} R) (AddCommGroupWithOne.toAddGroupWithOne.{u1} (PowerSeries.{u1} R) (Ring.toAddCommGroupWithOne.{u1} (PowerSeries.{u1} R) (PowerSeries.ring.{u1} R _inst_1)))))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] (u : Units.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))), Eq.{succ u1} (PowerSeries.{u1} R) (HMul.hMul.{u1, u1, u1} (PowerSeries.{u1} R) (PowerSeries.{u1} R) (PowerSeries.{u1} R) (instHMul.{u1} (PowerSeries.{u1} R) (NonUnitalNonAssocRing.toMul.{u1} (PowerSeries.{u1} R) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (PowerSeries.{u1} R) (Ring.toNonAssocRing.{u1} (PowerSeries.{u1} R) (PowerSeries.instRingPowerSeries.{u1} R _inst_1))))) (PowerSeries.invUnitsSub.{u1} R _inst_1 u) (PowerSeries.X.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (HSub.hSub.{u1, u1, u1} (PowerSeries.{u1} R) (PowerSeries.{u1} R) (PowerSeries.{u1} R) (instHSub.{u1} (PowerSeries.{u1} R) (Ring.toSub.{u1} (PowerSeries.{u1} R) (PowerSeries.instRingPowerSeries.{u1} R _inst_1))) (HMul.hMul.{u1, u1, u1} (PowerSeries.{u1} R) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => PowerSeries.{u1} R) (Units.val.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) u)) (PowerSeries.{u1} R) (instHMul.{u1} (PowerSeries.{u1} R) (NonUnitalNonAssocRing.toMul.{u1} (PowerSeries.{u1} R) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (PowerSeries.{u1} R) (Ring.toNonAssocRing.{u1} (PowerSeries.{u1} R) (PowerSeries.instRingPowerSeries.{u1} R _inst_1))))) (PowerSeries.invUnitsSub.{u1} R _inst_1 u) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (PowerSeries.{u1} R) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} R) (PowerSeries.instSemiringPowerSeries.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => PowerSeries.{u1} R) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (PowerSeries.{u1} R) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} R) (PowerSeries.instSemiringPowerSeries.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) R (PowerSeries.{u1} R) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} (PowerSeries.{u1} R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (PowerSeries.{u1} R) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} R) (PowerSeries.instSemiringPowerSeries.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (PowerSeries.{u1} R) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} R) (PowerSeries.instSemiringPowerSeries.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) R (PowerSeries.{u1} R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (PowerSeries.{u1} R) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} R) (PowerSeries.instSemiringPowerSeries.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (PowerSeries.{u1} R) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} R) (PowerSeries.instSemiringPowerSeries.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) R (PowerSeries.{u1} R) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} R) (PowerSeries.instSemiringPowerSeries.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (RingHom.instRingHomClassRingHom.{u1, u1} R (PowerSeries.{u1} R) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} R) (PowerSeries.instSemiringPowerSeries.{u1} R (Ring.toSemiring.{u1} R _inst_1))))))) (PowerSeries.C.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Units.val.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) u))) (OfNat.ofNat.{u1} (PowerSeries.{u1} R) 1 (One.toOfNat1.{u1} (PowerSeries.{u1} R) (Semiring.toOne.{u1} (PowerSeries.{u1} R) (PowerSeries.instSemiringPowerSeries.{u1} R (Ring.toSemiring.{u1} R _inst_1))))))
Case conversion may be inaccurate. Consider using '#align power_series.inv_units_sub_mul_X PowerSeries.invUnitsSub_mul_Xₓ'. -/
@[simp]
theorem invUnitsSub_mul_X (u : Rˣ) : invUnitsSub u * X = invUnitsSub u * C R u - 1 :=
  by
  ext (_ | n)
  · simp
  · simp [n.succ_ne_zero, pow_succ]
#align power_series.inv_units_sub_mul_X PowerSeries.invUnitsSub_mul_X

/- warning: power_series.inv_units_sub_mul_sub -> PowerSeries.invUnitsSub_mul_sub is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] (u : Units.{u1} R (Ring.toMonoid.{u1} R _inst_1)), Eq.{succ u1} (PowerSeries.{u1} R) (HMul.hMul.{u1, u1, u1} (PowerSeries.{u1} R) (PowerSeries.{u1} R) (PowerSeries.{u1} R) (instHMul.{u1} (PowerSeries.{u1} R) (Distrib.toHasMul.{u1} (PowerSeries.{u1} R) (Ring.toDistrib.{u1} (PowerSeries.{u1} R) (PowerSeries.ring.{u1} R _inst_1)))) (PowerSeries.invUnitsSub.{u1} R _inst_1 u) (HSub.hSub.{u1, u1, u1} (PowerSeries.{u1} R) (PowerSeries.{u1} R) (PowerSeries.{u1} R) (instHSub.{u1} (PowerSeries.{u1} R) (SubNegMonoid.toHasSub.{u1} (PowerSeries.{u1} R) (AddGroup.toSubNegMonoid.{u1} (PowerSeries.{u1} R) (PowerSeries.addGroup.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (PowerSeries.{u1} R) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} R) (PowerSeries.semiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (fun (_x : RingHom.{u1, u1} R (PowerSeries.{u1} R) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} R) (PowerSeries.semiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) => R -> (PowerSeries.{u1} R)) (RingHom.hasCoeToFun.{u1, u1} R (PowerSeries.{u1} R) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} R) (PowerSeries.semiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (PowerSeries.C.{u1} R (Ring.toSemiring.{u1} R _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} R (Ring.toMonoid.{u1} R _inst_1)) R (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} R (Ring.toMonoid.{u1} R _inst_1)) R (CoeTCₓ.coe.{succ u1, succ u1} (Units.{u1} R (Ring.toMonoid.{u1} R _inst_1)) R (coeBase.{succ u1, succ u1} (Units.{u1} R (Ring.toMonoid.{u1} R _inst_1)) R (Units.hasCoe.{u1} R (Ring.toMonoid.{u1} R _inst_1))))) u)) (PowerSeries.X.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (OfNat.ofNat.{u1} (PowerSeries.{u1} R) 1 (OfNat.mk.{u1} (PowerSeries.{u1} R) 1 (One.one.{u1} (PowerSeries.{u1} R) (AddMonoidWithOne.toOne.{u1} (PowerSeries.{u1} R) (AddGroupWithOne.toAddMonoidWithOne.{u1} (PowerSeries.{u1} R) (AddCommGroupWithOne.toAddGroupWithOne.{u1} (PowerSeries.{u1} R) (Ring.toAddCommGroupWithOne.{u1} (PowerSeries.{u1} R) (PowerSeries.ring.{u1} R _inst_1))))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] (u : Units.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))), Eq.{succ u1} (PowerSeries.{u1} R) (HMul.hMul.{u1, u1, u1} (PowerSeries.{u1} R) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => PowerSeries.{u1} R) (Units.val.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) u)) (PowerSeries.{u1} R) (instHMul.{u1} (PowerSeries.{u1} R) (NonUnitalNonAssocRing.toMul.{u1} (PowerSeries.{u1} R) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (PowerSeries.{u1} R) (Ring.toNonAssocRing.{u1} (PowerSeries.{u1} R) (PowerSeries.instRingPowerSeries.{u1} R _inst_1))))) (PowerSeries.invUnitsSub.{u1} R _inst_1 u) (HSub.hSub.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => PowerSeries.{u1} R) (Units.val.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) u)) (PowerSeries.{u1} R) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => PowerSeries.{u1} R) (Units.val.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) u)) (instHSub.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => PowerSeries.{u1} R) (Units.val.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) u)) (Ring.toSub.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => PowerSeries.{u1} R) (Units.val.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) u)) (PowerSeries.instRingPowerSeries.{u1} R _inst_1))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (PowerSeries.{u1} R) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} R) (PowerSeries.instSemiringPowerSeries.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => PowerSeries.{u1} R) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (PowerSeries.{u1} R) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} R) (PowerSeries.instSemiringPowerSeries.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) R (PowerSeries.{u1} R) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} (PowerSeries.{u1} R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (PowerSeries.{u1} R) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} R) (PowerSeries.instSemiringPowerSeries.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (PowerSeries.{u1} R) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} R) (PowerSeries.instSemiringPowerSeries.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) R (PowerSeries.{u1} R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (PowerSeries.{u1} R) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} R) (PowerSeries.instSemiringPowerSeries.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (PowerSeries.{u1} R) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} R) (PowerSeries.instSemiringPowerSeries.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) R (PowerSeries.{u1} R) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} R) (PowerSeries.instSemiringPowerSeries.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (RingHom.instRingHomClassRingHom.{u1, u1} R (PowerSeries.{u1} R) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} R) (PowerSeries.instSemiringPowerSeries.{u1} R (Ring.toSemiring.{u1} R _inst_1))))))) (PowerSeries.C.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Units.val.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) u)) (PowerSeries.X.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (OfNat.ofNat.{u1} (PowerSeries.{u1} R) 1 (One.toOfNat1.{u1} (PowerSeries.{u1} R) (Semiring.toOne.{u1} (PowerSeries.{u1} R) (PowerSeries.instSemiringPowerSeries.{u1} R (Ring.toSemiring.{u1} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align power_series.inv_units_sub_mul_sub PowerSeries.invUnitsSub_mul_subₓ'. -/
@[simp]
theorem invUnitsSub_mul_sub (u : Rˣ) : invUnitsSub u * (C R u - X) = 1 := by
  simp [mul_sub, sub_sub_cancel]
#align power_series.inv_units_sub_mul_sub PowerSeries.invUnitsSub_mul_sub

/- warning: power_series.map_inv_units_sub -> PowerSeries.map_invUnitsSub is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align power_series.map_inv_units_sub PowerSeries.map_invUnitsSubₓ'. -/
theorem map_invUnitsSub (f : R →+* S) (u : Rˣ) :
    map f (invUnitsSub u) = invUnitsSub (Units.map (f : R →* S) u) := by ext; simp [← map_pow]
#align power_series.map_inv_units_sub PowerSeries.map_invUnitsSub

end Ring

section Field

variable (A A' : Type _) [Ring A] [Ring A'] [Algebra ℚ A] [Algebra ℚ A']

open Nat

#print PowerSeries.exp /-
/-- Power series for the exponential function at zero. -/
def exp : PowerSeries A :=
  mk fun n => algebraMap ℚ A (1 / n !)
#align power_series.exp PowerSeries.exp
-/

#print PowerSeries.sin /-
/-- Power series for the sine function at zero. -/
def sin : PowerSeries A :=
  mk fun n => if Even n then 0 else algebraMap ℚ A ((-1) ^ (n / 2) / n !)
#align power_series.sin PowerSeries.sin
-/

#print PowerSeries.cos /-
/-- Power series for the cosine function at zero. -/
def cos : PowerSeries A :=
  mk fun n => if Even n then algebraMap ℚ A ((-1) ^ (n / 2) / n !) else 0
#align power_series.cos PowerSeries.cos
-/

variable {A A'} (n : ℕ) (f : A →+* A')

/- warning: power_series.coeff_exp -> PowerSeries.coeff_exp is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} [_inst_1 : Ring.{u1} A] [_inst_3 : Algebra.{0, u1} Rat A Rat.commSemiring (Ring.toSemiring.{u1} A _inst_1)] (n : Nat), Eq.{succ u1} A (coeFn.{succ u1, succ u1} (LinearMap.{u1, u1, u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u1} A _inst_1) (RingHom.id.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (PowerSeries.{u1} A) A (PowerSeries.addCommMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (PowerSeries.module.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (fun (_x : LinearMap.{u1, u1, u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u1} A _inst_1) (RingHom.id.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (PowerSeries.{u1} A) A (PowerSeries.addCommMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (PowerSeries.module.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))) => (PowerSeries.{u1} A) -> A) (LinearMap.hasCoeToFun.{u1, u1, u1, u1} A A (PowerSeries.{u1} A) A (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u1} A _inst_1) (PowerSeries.addCommMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (PowerSeries.module.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (RingHom.id.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (PowerSeries.coeff.{u1} A (Ring.toSemiring.{u1} A _inst_1) n) (PowerSeries.exp.{u1} A _inst_1 _inst_3)) (coeFn.{succ u1, succ u1} (RingHom.{0, u1} Rat A (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (fun (_x : RingHom.{0, u1} Rat A (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) => Rat -> A) (RingHom.hasCoeToFun.{0, u1} Rat A (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (algebraMap.{0, u1} Rat A Rat.commSemiring (Ring.toSemiring.{u1} A _inst_1) _inst_3) (HDiv.hDiv.{0, 0, 0} Rat Rat Rat (instHDiv.{0} Rat Rat.hasDiv) (OfNat.ofNat.{0} Rat 1 (OfNat.mk.{0} Rat 1 (One.one.{0} Rat Rat.hasOne))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Rat (HasLiftT.mk.{1, 1} Nat Rat (CoeTCₓ.coe.{1, 1} Nat Rat (Nat.castCoe.{0} Rat (AddMonoidWithOne.toNatCast.{0} Rat (AddGroupWithOne.toAddMonoidWithOne.{0} Rat (AddCommGroupWithOne.toAddGroupWithOne.{0} Rat (Ring.toAddCommGroupWithOne.{0} Rat (DivisionRing.toRing.{0} Rat Rat.divisionRing)))))))) (Nat.factorial n))))
but is expected to have type
  forall {A : Type.{u1}} [_inst_1 : Ring.{u1} A] [_inst_3 : Algebra.{0, u1} Rat A Rat.commSemiring (Ring.toSemiring.{u1} A _inst_1)] (n : Nat), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : PowerSeries.{u1} A) => A) (PowerSeries.exp.{u1} A _inst_1 _inst_3)) (FunLike.coe.{succ u1, succ u1, succ u1} (LinearMap.{u1, u1, u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u1} A _inst_1) (RingHom.id.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (PowerSeries.{u1} A) A (PowerSeries.instAddCommMonoidPowerSeries.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (PowerSeries.instModulePowerSeriesInstAddCommMonoidPowerSeries.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (PowerSeries.{u1} A) (fun (_x : PowerSeries.{u1} A) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : PowerSeries.{u1} A) => A) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u1, u1} A A (PowerSeries.{u1} A) A (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u1} A _inst_1) (PowerSeries.instAddCommMonoidPowerSeries.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (PowerSeries.instModulePowerSeriesInstAddCommMonoidPowerSeries.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (RingHom.id.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (PowerSeries.coeff.{u1} A (Ring.toSemiring.{u1} A _inst_1) n) (PowerSeries.exp.{u1} A _inst_1 _inst_3)) (FunLike.coe.{succ u1, 1, succ u1} (RingHom.{0, u1} Rat A (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) Rat (fun (_x : Rat) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Rat) => A) _x) (MulHomClass.toFunLike.{u1, 0, u1} (RingHom.{0, u1} Rat A (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) Rat A (NonUnitalNonAssocSemiring.toMul.{0} Rat (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Rat (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)))) (NonUnitalNonAssocSemiring.toMul.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, 0, u1} (RingHom.{0, u1} Rat A (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) Rat A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Rat (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, 0, u1} (RingHom.{0, u1} Rat A (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) Rat A (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (RingHom.instRingHomClassRingHom.{0, u1} Rat A (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))))) (algebraMap.{0, u1} Rat A Rat.commSemiring (Ring.toSemiring.{u1} A _inst_1) _inst_3) (HDiv.hDiv.{0, 0, 0} Rat Rat Rat (instHDiv.{0} Rat Rat.instDivRat) (OfNat.ofNat.{0} Rat 1 (Rat.instOfNatRat 1)) (Nat.cast.{0} Rat (Semiring.toNatCast.{0} Rat Rat.semiring) (Nat.factorial n))))
Case conversion may be inaccurate. Consider using '#align power_series.coeff_exp PowerSeries.coeff_expₓ'. -/
@[simp]
theorem coeff_exp : coeff A n (exp A) = algebraMap ℚ A (1 / n !) :=
  coeff_mk _ _
#align power_series.coeff_exp PowerSeries.coeff_exp

/- warning: power_series.constant_coeff_exp -> PowerSeries.constantCoeff_exp is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} [_inst_1 : Ring.{u1} A] [_inst_3 : Algebra.{0, u1} Rat A Rat.commSemiring (Ring.toSemiring.{u1} A _inst_1)], Eq.{succ u1} A (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} (PowerSeries.{u1} A) A (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.semiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (fun (_x : RingHom.{u1, u1} (PowerSeries.{u1} A) A (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.semiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) => (PowerSeries.{u1} A) -> A) (RingHom.hasCoeToFun.{u1, u1} (PowerSeries.{u1} A) A (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.semiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (PowerSeries.constantCoeff.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PowerSeries.exp.{u1} A _inst_1 _inst_3)) (OfNat.ofNat.{u1} A 1 (OfNat.mk.{u1} A 1 (One.one.{u1} A (AddMonoidWithOne.toOne.{u1} A (AddGroupWithOne.toAddMonoidWithOne.{u1} A (AddCommGroupWithOne.toAddGroupWithOne.{u1} A (Ring.toAddCommGroupWithOne.{u1} A _inst_1)))))))
but is expected to have type
  forall {A : Type.{u1}} [_inst_1 : Ring.{u1} A] [_inst_3 : Algebra.{0, u1} Rat A Rat.commSemiring (Ring.toSemiring.{u1} A _inst_1)], Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : PowerSeries.{u1} A) => A) (PowerSeries.exp.{u1} A _inst_1 _inst_3)) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} (PowerSeries.{u1} A) A (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (PowerSeries.{u1} A) (fun (_x : PowerSeries.{u1} A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : PowerSeries.{u1} A) => A) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} (PowerSeries.{u1} A) A (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (PowerSeries.{u1} A) A (NonUnitalNonAssocSemiring.toMul.{u1} (PowerSeries.{u1} A) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (PowerSeries.{u1} A) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (Ring.toSemiring.{u1} A _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} (PowerSeries.{u1} A) A (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (PowerSeries.{u1} A) A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (PowerSeries.{u1} A) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} (PowerSeries.{u1} A) A (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (PowerSeries.{u1} A) A (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} (PowerSeries.{u1} A) A (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))))) (PowerSeries.constantCoeff.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PowerSeries.exp.{u1} A _inst_1 _inst_3)) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : PowerSeries.{u1} A) => A) (PowerSeries.exp.{u1} A _inst_1 _inst_3)) 1 (One.toOfNat1.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : PowerSeries.{u1} A) => A) (PowerSeries.exp.{u1} A _inst_1 _inst_3)) (Semiring.toOne.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : PowerSeries.{u1} A) => A) (PowerSeries.exp.{u1} A _inst_1 _inst_3)) (Ring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : PowerSeries.{u1} A) => A) (PowerSeries.exp.{u1} A _inst_1 _inst_3)) _inst_1))))
Case conversion may be inaccurate. Consider using '#align power_series.constant_coeff_exp PowerSeries.constantCoeff_expₓ'. -/
@[simp]
theorem constantCoeff_exp : constantCoeff A (exp A) = 1 := by
  rw [← coeff_zero_eq_constant_coeff_apply, coeff_exp]; simp
#align power_series.constant_coeff_exp PowerSeries.constantCoeff_exp

/- warning: power_series.coeff_sin_bit0 -> PowerSeries.coeff_sin_bit0 is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} [_inst_1 : Ring.{u1} A] [_inst_3 : Algebra.{0, u1} Rat A Rat.commSemiring (Ring.toSemiring.{u1} A _inst_1)] (n : Nat), Eq.{succ u1} A (coeFn.{succ u1, succ u1} (LinearMap.{u1, u1, u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u1} A _inst_1) (RingHom.id.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (PowerSeries.{u1} A) A (PowerSeries.addCommMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (PowerSeries.module.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (fun (_x : LinearMap.{u1, u1, u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u1} A _inst_1) (RingHom.id.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (PowerSeries.{u1} A) A (PowerSeries.addCommMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (PowerSeries.module.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))) => (PowerSeries.{u1} A) -> A) (LinearMap.hasCoeToFun.{u1, u1, u1, u1} A A (PowerSeries.{u1} A) A (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u1} A _inst_1) (PowerSeries.addCommMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (PowerSeries.module.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (RingHom.id.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (PowerSeries.coeff.{u1} A (Ring.toSemiring.{u1} A _inst_1) (bit0.{0} Nat Nat.hasAdd n)) (PowerSeries.sin.{u1} A _inst_1 _inst_3)) (OfNat.ofNat.{u1} A 0 (OfNat.mk.{u1} A 0 (Zero.zero.{u1} A (MulZeroClass.toHasZero.{u1} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1))))))))
but is expected to have type
  forall {A : Type.{u1}} [_inst_1 : Ring.{u1} A] [_inst_3 : Algebra.{0, u1} Rat A Rat.commSemiring (Ring.toSemiring.{u1} A _inst_1)] (n : Nat), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : PowerSeries.{u1} A) => A) (PowerSeries.sin.{u1} A _inst_1 _inst_3)) (FunLike.coe.{succ u1, succ u1, succ u1} (LinearMap.{u1, u1, u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u1} A _inst_1) (RingHom.id.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (PowerSeries.{u1} A) A (PowerSeries.instAddCommMonoidPowerSeries.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (PowerSeries.instModulePowerSeriesInstAddCommMonoidPowerSeries.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (PowerSeries.{u1} A) (fun (_x : PowerSeries.{u1} A) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : PowerSeries.{u1} A) => A) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u1, u1} A A (PowerSeries.{u1} A) A (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u1} A _inst_1) (PowerSeries.instAddCommMonoidPowerSeries.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (PowerSeries.instModulePowerSeriesInstAddCommMonoidPowerSeries.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (RingHom.id.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (PowerSeries.coeff.{u1} A (Ring.toSemiring.{u1} A _inst_1) (bit0.{0} Nat instAddNat n)) (PowerSeries.sin.{u1} A _inst_1 _inst_3)) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : PowerSeries.{u1} A) => A) (PowerSeries.sin.{u1} A _inst_1 _inst_3)) 0 (Zero.toOfNat0.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : PowerSeries.{u1} A) => A) (PowerSeries.sin.{u1} A _inst_1 _inst_3)) (MonoidWithZero.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : PowerSeries.{u1} A) => A) (PowerSeries.sin.{u1} A _inst_1 _inst_3)) (Semiring.toMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : PowerSeries.{u1} A) => A) (PowerSeries.sin.{u1} A _inst_1 _inst_3)) (Ring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : PowerSeries.{u1} A) => A) (PowerSeries.sin.{u1} A _inst_1 _inst_3)) _inst_1)))))
Case conversion may be inaccurate. Consider using '#align power_series.coeff_sin_bit0 PowerSeries.coeff_sin_bit0ₓ'. -/
@[simp]
theorem coeff_sin_bit0 : coeff A (bit0 n) (sin A) = 0 := by rw [sin, coeff_mk, if_pos (even_bit0 n)]
#align power_series.coeff_sin_bit0 PowerSeries.coeff_sin_bit0

/- warning: power_series.coeff_sin_bit1 -> PowerSeries.coeff_sin_bit1 is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align power_series.coeff_sin_bit1 PowerSeries.coeff_sin_bit1ₓ'. -/
@[simp]
theorem coeff_sin_bit1 : coeff A (bit1 n) (sin A) = (-1) ^ n * coeff A (bit1 n) (exp A) := by
  rw [sin, coeff_mk, if_neg n.not_even_bit1, Nat.bit1_div_two, ← mul_one_div, map_mul, map_pow,
    map_neg, map_one, coeff_exp]
#align power_series.coeff_sin_bit1 PowerSeries.coeff_sin_bit1

/- warning: power_series.coeff_cos_bit0 -> PowerSeries.coeff_cos_bit0 is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align power_series.coeff_cos_bit0 PowerSeries.coeff_cos_bit0ₓ'. -/
@[simp]
theorem coeff_cos_bit0 : coeff A (bit0 n) (cos A) = (-1) ^ n * coeff A (bit0 n) (exp A) := by
  rw [cos, coeff_mk, if_pos (even_bit0 n), Nat.bit0_div_two, ← mul_one_div, map_mul, map_pow,
    map_neg, map_one, coeff_exp]
#align power_series.coeff_cos_bit0 PowerSeries.coeff_cos_bit0

/- warning: power_series.coeff_cos_bit1 -> PowerSeries.coeff_cos_bit1 is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} [_inst_1 : Ring.{u1} A] [_inst_3 : Algebra.{0, u1} Rat A Rat.commSemiring (Ring.toSemiring.{u1} A _inst_1)] (n : Nat), Eq.{succ u1} A (coeFn.{succ u1, succ u1} (LinearMap.{u1, u1, u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u1} A _inst_1) (RingHom.id.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (PowerSeries.{u1} A) A (PowerSeries.addCommMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (PowerSeries.module.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (fun (_x : LinearMap.{u1, u1, u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u1} A _inst_1) (RingHom.id.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (PowerSeries.{u1} A) A (PowerSeries.addCommMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (PowerSeries.module.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))) => (PowerSeries.{u1} A) -> A) (LinearMap.hasCoeToFun.{u1, u1, u1, u1} A A (PowerSeries.{u1} A) A (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u1} A _inst_1) (PowerSeries.addCommMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (PowerSeries.module.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (RingHom.id.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (PowerSeries.coeff.{u1} A (Ring.toSemiring.{u1} A _inst_1) (bit1.{0} Nat Nat.hasOne Nat.hasAdd n)) (PowerSeries.cos.{u1} A _inst_1 _inst_3)) (OfNat.ofNat.{u1} A 0 (OfNat.mk.{u1} A 0 (Zero.zero.{u1} A (MulZeroClass.toHasZero.{u1} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1))))))))
but is expected to have type
  forall {A : Type.{u1}} [_inst_1 : Ring.{u1} A] [_inst_3 : Algebra.{0, u1} Rat A Rat.commSemiring (Ring.toSemiring.{u1} A _inst_1)] (n : Nat), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : PowerSeries.{u1} A) => A) (PowerSeries.cos.{u1} A _inst_1 _inst_3)) (FunLike.coe.{succ u1, succ u1, succ u1} (LinearMap.{u1, u1, u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u1} A _inst_1) (RingHom.id.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (PowerSeries.{u1} A) A (PowerSeries.instAddCommMonoidPowerSeries.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (PowerSeries.instModulePowerSeriesInstAddCommMonoidPowerSeries.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (PowerSeries.{u1} A) (fun (_x : PowerSeries.{u1} A) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : PowerSeries.{u1} A) => A) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u1, u1} A A (PowerSeries.{u1} A) A (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u1} A _inst_1) (PowerSeries.instAddCommMonoidPowerSeries.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (PowerSeries.instModulePowerSeriesInstAddCommMonoidPowerSeries.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (RingHom.id.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (PowerSeries.coeff.{u1} A (Ring.toSemiring.{u1} A _inst_1) (bit1.{0} Nat (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring) instAddNat n)) (PowerSeries.cos.{u1} A _inst_1 _inst_3)) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : PowerSeries.{u1} A) => A) (PowerSeries.cos.{u1} A _inst_1 _inst_3)) 0 (Zero.toOfNat0.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : PowerSeries.{u1} A) => A) (PowerSeries.cos.{u1} A _inst_1 _inst_3)) (MonoidWithZero.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : PowerSeries.{u1} A) => A) (PowerSeries.cos.{u1} A _inst_1 _inst_3)) (Semiring.toMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : PowerSeries.{u1} A) => A) (PowerSeries.cos.{u1} A _inst_1 _inst_3)) (Ring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : PowerSeries.{u1} A) => A) (PowerSeries.cos.{u1} A _inst_1 _inst_3)) _inst_1)))))
Case conversion may be inaccurate. Consider using '#align power_series.coeff_cos_bit1 PowerSeries.coeff_cos_bit1ₓ'. -/
@[simp]
theorem coeff_cos_bit1 : coeff A (bit1 n) (cos A) = 0 := by
  rw [cos, coeff_mk, if_neg n.not_even_bit1]
#align power_series.coeff_cos_bit1 PowerSeries.coeff_cos_bit1

/- warning: power_series.map_exp -> PowerSeries.map_exp is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {A' : Type.{u2}} [_inst_1 : Ring.{u1} A] [_inst_2 : Ring.{u2} A'] [_inst_3 : Algebra.{0, u1} Rat A Rat.commSemiring (Ring.toSemiring.{u1} A _inst_1)] [_inst_4 : Algebra.{0, u2} Rat A' Rat.commSemiring (Ring.toSemiring.{u2} A' _inst_2)] (f : RingHom.{u1, u2} A A' (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} A' (Ring.toNonAssocRing.{u2} A' _inst_2))), Eq.{succ u2} (PowerSeries.{u2} A') (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} (PowerSeries.{u1} A) (PowerSeries.{u2} A') (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.semiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u2} (PowerSeries.{u2} A') (PowerSeries.semiring.{u2} A' (Ring.toSemiring.{u2} A' _inst_2)))) (fun (_x : RingHom.{u1, u2} (PowerSeries.{u1} A) (PowerSeries.{u2} A') (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.semiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u2} (PowerSeries.{u2} A') (PowerSeries.semiring.{u2} A' (Ring.toSemiring.{u2} A' _inst_2)))) => (PowerSeries.{u1} A) -> (PowerSeries.{u2} A')) (RingHom.hasCoeToFun.{u1, u2} (PowerSeries.{u1} A) (PowerSeries.{u2} A') (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.semiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u2} (PowerSeries.{u2} A') (PowerSeries.semiring.{u2} A' (Ring.toSemiring.{u2} A' _inst_2)))) (PowerSeries.map.{u1, u2} A (Ring.toSemiring.{u1} A _inst_1) A' (Ring.toSemiring.{u2} A' _inst_2) f) (PowerSeries.exp.{u1} A _inst_1 _inst_3)) (PowerSeries.exp.{u2} A' _inst_2 _inst_4)
but is expected to have type
  forall {A : Type.{u1}} {A' : Type.{u2}} [_inst_1 : Ring.{u1} A] [_inst_2 : Ring.{u2} A'] [_inst_3 : Algebra.{0, u1} Rat A Rat.commSemiring (Ring.toSemiring.{u1} A _inst_1)] [_inst_4 : Algebra.{0, u2} Rat A' Rat.commSemiring (Ring.toSemiring.{u2} A' _inst_2)] (f : RingHom.{u1, u2} A A' (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} A' (Ring.toSemiring.{u2} A' _inst_2))), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : PowerSeries.{u1} A) => PowerSeries.{u2} A') (PowerSeries.exp.{u1} A _inst_1 _inst_3)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} (PowerSeries.{u1} A) (PowerSeries.{u2} A') (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u2} (PowerSeries.{u2} A') (PowerSeries.instSemiringPowerSeries.{u2} A' (Ring.toSemiring.{u2} A' _inst_2)))) (PowerSeries.{u1} A) (fun (_x : PowerSeries.{u1} A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : PowerSeries.{u1} A) => PowerSeries.{u2} A') _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} (PowerSeries.{u1} A) (PowerSeries.{u2} A') (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u2} (PowerSeries.{u2} A') (PowerSeries.instSemiringPowerSeries.{u2} A' (Ring.toSemiring.{u2} A' _inst_2)))) (PowerSeries.{u1} A) (PowerSeries.{u2} A') (NonUnitalNonAssocSemiring.toMul.{u1} (PowerSeries.{u1} A) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (PowerSeries.{u1} A) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (Ring.toSemiring.{u1} A _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u2} (PowerSeries.{u2} A') (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (PowerSeries.{u2} A') (Semiring.toNonAssocSemiring.{u2} (PowerSeries.{u2} A') (PowerSeries.instSemiringPowerSeries.{u2} A' (Ring.toSemiring.{u2} A' _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} (PowerSeries.{u1} A) (PowerSeries.{u2} A') (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u2} (PowerSeries.{u2} A') (PowerSeries.instSemiringPowerSeries.{u2} A' (Ring.toSemiring.{u2} A' _inst_2)))) (PowerSeries.{u1} A) (PowerSeries.{u2} A') (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (PowerSeries.{u1} A) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (PowerSeries.{u2} A') (Semiring.toNonAssocSemiring.{u2} (PowerSeries.{u2} A') (PowerSeries.instSemiringPowerSeries.{u2} A' (Ring.toSemiring.{u2} A' _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} (PowerSeries.{u1} A) (PowerSeries.{u2} A') (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u2} (PowerSeries.{u2} A') (PowerSeries.instSemiringPowerSeries.{u2} A' (Ring.toSemiring.{u2} A' _inst_2)))) (PowerSeries.{u1} A) (PowerSeries.{u2} A') (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u2} (PowerSeries.{u2} A') (PowerSeries.instSemiringPowerSeries.{u2} A' (Ring.toSemiring.{u2} A' _inst_2))) (RingHom.instRingHomClassRingHom.{u1, u2} (PowerSeries.{u1} A) (PowerSeries.{u2} A') (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u2} (PowerSeries.{u2} A') (PowerSeries.instSemiringPowerSeries.{u2} A' (Ring.toSemiring.{u2} A' _inst_2))))))) (PowerSeries.map.{u1, u2} A (Ring.toSemiring.{u1} A _inst_1) A' (Ring.toSemiring.{u2} A' _inst_2) f) (PowerSeries.exp.{u1} A _inst_1 _inst_3)) (PowerSeries.exp.{u2} A' _inst_2 _inst_4)
Case conversion may be inaccurate. Consider using '#align power_series.map_exp PowerSeries.map_expₓ'. -/
@[simp]
theorem map_exp : map (f : A →+* A') (exp A) = exp A' := by ext; simp
#align power_series.map_exp PowerSeries.map_exp

/- warning: power_series.map_sin -> PowerSeries.map_sin is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {A' : Type.{u2}} [_inst_1 : Ring.{u1} A] [_inst_2 : Ring.{u2} A'] [_inst_3 : Algebra.{0, u1} Rat A Rat.commSemiring (Ring.toSemiring.{u1} A _inst_1)] [_inst_4 : Algebra.{0, u2} Rat A' Rat.commSemiring (Ring.toSemiring.{u2} A' _inst_2)] (f : RingHom.{u1, u2} A A' (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} A' (Ring.toNonAssocRing.{u2} A' _inst_2))), Eq.{succ u2} (PowerSeries.{u2} A') (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} (PowerSeries.{u1} A) (PowerSeries.{u2} A') (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.semiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u2} (PowerSeries.{u2} A') (PowerSeries.semiring.{u2} A' (Ring.toSemiring.{u2} A' _inst_2)))) (fun (_x : RingHom.{u1, u2} (PowerSeries.{u1} A) (PowerSeries.{u2} A') (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.semiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u2} (PowerSeries.{u2} A') (PowerSeries.semiring.{u2} A' (Ring.toSemiring.{u2} A' _inst_2)))) => (PowerSeries.{u1} A) -> (PowerSeries.{u2} A')) (RingHom.hasCoeToFun.{u1, u2} (PowerSeries.{u1} A) (PowerSeries.{u2} A') (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.semiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u2} (PowerSeries.{u2} A') (PowerSeries.semiring.{u2} A' (Ring.toSemiring.{u2} A' _inst_2)))) (PowerSeries.map.{u1, u2} A (Ring.toSemiring.{u1} A _inst_1) A' (Ring.toSemiring.{u2} A' _inst_2) f) (PowerSeries.sin.{u1} A _inst_1 _inst_3)) (PowerSeries.sin.{u2} A' _inst_2 _inst_4)
but is expected to have type
  forall {A : Type.{u1}} {A' : Type.{u2}} [_inst_1 : Ring.{u1} A] [_inst_2 : Ring.{u2} A'] [_inst_3 : Algebra.{0, u1} Rat A Rat.commSemiring (Ring.toSemiring.{u1} A _inst_1)] [_inst_4 : Algebra.{0, u2} Rat A' Rat.commSemiring (Ring.toSemiring.{u2} A' _inst_2)] (f : RingHom.{u1, u2} A A' (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} A' (Ring.toSemiring.{u2} A' _inst_2))), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : PowerSeries.{u1} A) => PowerSeries.{u2} A') (PowerSeries.sin.{u1} A _inst_1 _inst_3)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} (PowerSeries.{u1} A) (PowerSeries.{u2} A') (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u2} (PowerSeries.{u2} A') (PowerSeries.instSemiringPowerSeries.{u2} A' (Ring.toSemiring.{u2} A' _inst_2)))) (PowerSeries.{u1} A) (fun (_x : PowerSeries.{u1} A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : PowerSeries.{u1} A) => PowerSeries.{u2} A') _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} (PowerSeries.{u1} A) (PowerSeries.{u2} A') (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u2} (PowerSeries.{u2} A') (PowerSeries.instSemiringPowerSeries.{u2} A' (Ring.toSemiring.{u2} A' _inst_2)))) (PowerSeries.{u1} A) (PowerSeries.{u2} A') (NonUnitalNonAssocSemiring.toMul.{u1} (PowerSeries.{u1} A) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (PowerSeries.{u1} A) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (Ring.toSemiring.{u1} A _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u2} (PowerSeries.{u2} A') (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (PowerSeries.{u2} A') (Semiring.toNonAssocSemiring.{u2} (PowerSeries.{u2} A') (PowerSeries.instSemiringPowerSeries.{u2} A' (Ring.toSemiring.{u2} A' _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} (PowerSeries.{u1} A) (PowerSeries.{u2} A') (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u2} (PowerSeries.{u2} A') (PowerSeries.instSemiringPowerSeries.{u2} A' (Ring.toSemiring.{u2} A' _inst_2)))) (PowerSeries.{u1} A) (PowerSeries.{u2} A') (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (PowerSeries.{u1} A) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (PowerSeries.{u2} A') (Semiring.toNonAssocSemiring.{u2} (PowerSeries.{u2} A') (PowerSeries.instSemiringPowerSeries.{u2} A' (Ring.toSemiring.{u2} A' _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} (PowerSeries.{u1} A) (PowerSeries.{u2} A') (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u2} (PowerSeries.{u2} A') (PowerSeries.instSemiringPowerSeries.{u2} A' (Ring.toSemiring.{u2} A' _inst_2)))) (PowerSeries.{u1} A) (PowerSeries.{u2} A') (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u2} (PowerSeries.{u2} A') (PowerSeries.instSemiringPowerSeries.{u2} A' (Ring.toSemiring.{u2} A' _inst_2))) (RingHom.instRingHomClassRingHom.{u1, u2} (PowerSeries.{u1} A) (PowerSeries.{u2} A') (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u2} (PowerSeries.{u2} A') (PowerSeries.instSemiringPowerSeries.{u2} A' (Ring.toSemiring.{u2} A' _inst_2))))))) (PowerSeries.map.{u1, u2} A (Ring.toSemiring.{u1} A _inst_1) A' (Ring.toSemiring.{u2} A' _inst_2) f) (PowerSeries.sin.{u1} A _inst_1 _inst_3)) (PowerSeries.sin.{u2} A' _inst_2 _inst_4)
Case conversion may be inaccurate. Consider using '#align power_series.map_sin PowerSeries.map_sinₓ'. -/
@[simp]
theorem map_sin : map f (sin A) = sin A' := by ext; simp [sin, apply_ite f]
#align power_series.map_sin PowerSeries.map_sin

/- warning: power_series.map_cos -> PowerSeries.map_cos is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {A' : Type.{u2}} [_inst_1 : Ring.{u1} A] [_inst_2 : Ring.{u2} A'] [_inst_3 : Algebra.{0, u1} Rat A Rat.commSemiring (Ring.toSemiring.{u1} A _inst_1)] [_inst_4 : Algebra.{0, u2} Rat A' Rat.commSemiring (Ring.toSemiring.{u2} A' _inst_2)] (f : RingHom.{u1, u2} A A' (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} A' (Ring.toNonAssocRing.{u2} A' _inst_2))), Eq.{succ u2} (PowerSeries.{u2} A') (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} (PowerSeries.{u1} A) (PowerSeries.{u2} A') (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.semiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u2} (PowerSeries.{u2} A') (PowerSeries.semiring.{u2} A' (Ring.toSemiring.{u2} A' _inst_2)))) (fun (_x : RingHom.{u1, u2} (PowerSeries.{u1} A) (PowerSeries.{u2} A') (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.semiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u2} (PowerSeries.{u2} A') (PowerSeries.semiring.{u2} A' (Ring.toSemiring.{u2} A' _inst_2)))) => (PowerSeries.{u1} A) -> (PowerSeries.{u2} A')) (RingHom.hasCoeToFun.{u1, u2} (PowerSeries.{u1} A) (PowerSeries.{u2} A') (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.semiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u2} (PowerSeries.{u2} A') (PowerSeries.semiring.{u2} A' (Ring.toSemiring.{u2} A' _inst_2)))) (PowerSeries.map.{u1, u2} A (Ring.toSemiring.{u1} A _inst_1) A' (Ring.toSemiring.{u2} A' _inst_2) f) (PowerSeries.cos.{u1} A _inst_1 _inst_3)) (PowerSeries.cos.{u2} A' _inst_2 _inst_4)
but is expected to have type
  forall {A : Type.{u1}} {A' : Type.{u2}} [_inst_1 : Ring.{u1} A] [_inst_2 : Ring.{u2} A'] [_inst_3 : Algebra.{0, u1} Rat A Rat.commSemiring (Ring.toSemiring.{u1} A _inst_1)] [_inst_4 : Algebra.{0, u2} Rat A' Rat.commSemiring (Ring.toSemiring.{u2} A' _inst_2)] (f : RingHom.{u1, u2} A A' (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} A' (Ring.toSemiring.{u2} A' _inst_2))), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : PowerSeries.{u1} A) => PowerSeries.{u2} A') (PowerSeries.cos.{u1} A _inst_1 _inst_3)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} (PowerSeries.{u1} A) (PowerSeries.{u2} A') (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u2} (PowerSeries.{u2} A') (PowerSeries.instSemiringPowerSeries.{u2} A' (Ring.toSemiring.{u2} A' _inst_2)))) (PowerSeries.{u1} A) (fun (_x : PowerSeries.{u1} A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : PowerSeries.{u1} A) => PowerSeries.{u2} A') _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} (PowerSeries.{u1} A) (PowerSeries.{u2} A') (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u2} (PowerSeries.{u2} A') (PowerSeries.instSemiringPowerSeries.{u2} A' (Ring.toSemiring.{u2} A' _inst_2)))) (PowerSeries.{u1} A) (PowerSeries.{u2} A') (NonUnitalNonAssocSemiring.toMul.{u1} (PowerSeries.{u1} A) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (PowerSeries.{u1} A) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (Ring.toSemiring.{u1} A _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u2} (PowerSeries.{u2} A') (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (PowerSeries.{u2} A') (Semiring.toNonAssocSemiring.{u2} (PowerSeries.{u2} A') (PowerSeries.instSemiringPowerSeries.{u2} A' (Ring.toSemiring.{u2} A' _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} (PowerSeries.{u1} A) (PowerSeries.{u2} A') (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u2} (PowerSeries.{u2} A') (PowerSeries.instSemiringPowerSeries.{u2} A' (Ring.toSemiring.{u2} A' _inst_2)))) (PowerSeries.{u1} A) (PowerSeries.{u2} A') (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (PowerSeries.{u1} A) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (PowerSeries.{u2} A') (Semiring.toNonAssocSemiring.{u2} (PowerSeries.{u2} A') (PowerSeries.instSemiringPowerSeries.{u2} A' (Ring.toSemiring.{u2} A' _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} (PowerSeries.{u1} A) (PowerSeries.{u2} A') (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u2} (PowerSeries.{u2} A') (PowerSeries.instSemiringPowerSeries.{u2} A' (Ring.toSemiring.{u2} A' _inst_2)))) (PowerSeries.{u1} A) (PowerSeries.{u2} A') (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u2} (PowerSeries.{u2} A') (PowerSeries.instSemiringPowerSeries.{u2} A' (Ring.toSemiring.{u2} A' _inst_2))) (RingHom.instRingHomClassRingHom.{u1, u2} (PowerSeries.{u1} A) (PowerSeries.{u2} A') (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (Semiring.toNonAssocSemiring.{u2} (PowerSeries.{u2} A') (PowerSeries.instSemiringPowerSeries.{u2} A' (Ring.toSemiring.{u2} A' _inst_2))))))) (PowerSeries.map.{u1, u2} A (Ring.toSemiring.{u1} A _inst_1) A' (Ring.toSemiring.{u2} A' _inst_2) f) (PowerSeries.cos.{u1} A _inst_1 _inst_3)) (PowerSeries.cos.{u2} A' _inst_2 _inst_4)
Case conversion may be inaccurate. Consider using '#align power_series.map_cos PowerSeries.map_cosₓ'. -/
@[simp]
theorem map_cos : map f (cos A) = cos A' := by ext; simp [cos, apply_ite f]
#align power_series.map_cos PowerSeries.map_cos

end Field

open RingHom

open Finset Nat

variable {A : Type _} [CommRing A]

/- warning: power_series.exp_mul_exp_eq_exp_add -> PowerSeries.exp_mul_exp_eq_exp_add is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align power_series.exp_mul_exp_eq_exp_add PowerSeries.exp_mul_exp_eq_exp_addₓ'. -/
/-- Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ -/
theorem exp_mul_exp_eq_exp_add [Algebra ℚ A] (a b : A) :
    rescale a (exp A) * rescale b (exp A) = rescale (a + b) (exp A) :=
  by
  ext
  simp only [coeff_mul, exp, rescale, coeff_mk, coe_mk, factorial,
    nat.sum_antidiagonal_eq_sum_range_succ_mk, add_pow, sum_mul]
  apply sum_congr rfl
  rintro x hx
  suffices
    a ^ x * b ^ (n - x) *
        (algebraMap ℚ A (1 / ↑x.factorial) * algebraMap ℚ A (1 / ↑(n - x).factorial)) =
      a ^ x * b ^ (n - x) * (↑(n.choose x) * (algebraMap ℚ A) (1 / ↑n.factorial))
    by convert this using 1 <;> ring
  congr 1
  rw [← map_natCast (algebraMap ℚ A) (n.choose x), ← map_mul, ← map_mul]
  refine' RingHom.congr_arg _ _
  rw [mul_one_div ↑(n.choose x) _, one_div_mul_one_div]
  symm
  rw [div_eq_iff, div_mul_eq_mul_div, one_mul, choose_eq_factorial_div_factorial]
  norm_cast
  rw [cast_div_char_zero]
  · apply factorial_mul_factorial_dvd_factorial (mem_range_succ_iff.1 hx)
  · apply mem_range_succ_iff.1 hx
  · rintro h; apply factorial_ne_zero n; rw [cast_eq_zero.1 h]
#align power_series.exp_mul_exp_eq_exp_add PowerSeries.exp_mul_exp_eq_exp_add

/- warning: power_series.exp_mul_exp_neg_eq_one -> PowerSeries.exp_mul_exp_neg_eq_one is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} [_inst_1 : CommRing.{u1} A] [_inst_2 : Algebra.{0, u1} Rat A Rat.commSemiring (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1))], Eq.{succ u1} (PowerSeries.{u1} A) (HMul.hMul.{u1, u1, u1} (PowerSeries.{u1} A) (PowerSeries.{u1} A) (PowerSeries.{u1} A) (instHMul.{u1} (PowerSeries.{u1} A) (Distrib.toHasMul.{u1} (PowerSeries.{u1} A) (Ring.toDistrib.{u1} (PowerSeries.{u1} A) (PowerSeries.ring.{u1} A (CommRing.toRing.{u1} A _inst_1))))) (PowerSeries.exp.{u1} A (CommRing.toRing.{u1} A _inst_1) _inst_2) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} (PowerSeries.{u1} A) (PowerSeries.{u1} A) (NonAssocRing.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (Ring.toNonAssocRing.{u1} (PowerSeries.{u1} A) (PowerSeries.ring.{u1} A (CommRing.toRing.{u1} A _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (Ring.toNonAssocRing.{u1} (PowerSeries.{u1} A) (PowerSeries.ring.{u1} A (CommRing.toRing.{u1} A _inst_1))))) (fun (_x : RingHom.{u1, u1} (PowerSeries.{u1} A) (PowerSeries.{u1} A) (NonAssocRing.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (Ring.toNonAssocRing.{u1} (PowerSeries.{u1} A) (PowerSeries.ring.{u1} A (CommRing.toRing.{u1} A _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (Ring.toNonAssocRing.{u1} (PowerSeries.{u1} A) (PowerSeries.ring.{u1} A (CommRing.toRing.{u1} A _inst_1))))) => (PowerSeries.{u1} A) -> (PowerSeries.{u1} A)) (RingHom.hasCoeToFun.{u1, u1} (PowerSeries.{u1} A) (PowerSeries.{u1} A) (NonAssocRing.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (Ring.toNonAssocRing.{u1} (PowerSeries.{u1} A) (PowerSeries.ring.{u1} A (CommRing.toRing.{u1} A _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (Ring.toNonAssocRing.{u1} (PowerSeries.{u1} A) (PowerSeries.ring.{u1} A (CommRing.toRing.{u1} A _inst_1))))) (PowerSeries.evalNegHom.{u1} A _inst_1) (PowerSeries.exp.{u1} A (CommRing.toRing.{u1} A _inst_1) _inst_2))) (OfNat.ofNat.{u1} (PowerSeries.{u1} A) 1 (OfNat.mk.{u1} (PowerSeries.{u1} A) 1 (One.one.{u1} (PowerSeries.{u1} A) (AddMonoidWithOne.toOne.{u1} (PowerSeries.{u1} A) (AddGroupWithOne.toAddMonoidWithOne.{u1} (PowerSeries.{u1} A) (AddCommGroupWithOne.toAddGroupWithOne.{u1} (PowerSeries.{u1} A) (Ring.toAddCommGroupWithOne.{u1} (PowerSeries.{u1} A) (PowerSeries.ring.{u1} A (CommRing.toRing.{u1} A _inst_1)))))))))
but is expected to have type
  forall {A : Type.{u1}} [_inst_1 : CommRing.{u1} A] [_inst_2 : Algebra.{0, u1} Rat A Rat.commSemiring (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1))], Eq.{succ u1} (PowerSeries.{u1} A) (HMul.hMul.{u1, u1, u1} (PowerSeries.{u1} A) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : PowerSeries.{u1} A) => PowerSeries.{u1} A) (PowerSeries.exp.{u1} A (CommRing.toRing.{u1} A _inst_1) _inst_2)) (PowerSeries.{u1} A) (instHMul.{u1} (PowerSeries.{u1} A) (NonUnitalNonAssocRing.toMul.{u1} (PowerSeries.{u1} A) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (PowerSeries.{u1} A) (Ring.toNonAssocRing.{u1} (PowerSeries.{u1} A) (PowerSeries.instRingPowerSeries.{u1} A (CommRing.toRing.{u1} A _inst_1)))))) (PowerSeries.exp.{u1} A (CommRing.toRing.{u1} A _inst_1) _inst_2) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} (PowerSeries.{u1} A) (PowerSeries.{u1} A) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1)))) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1))))) (PowerSeries.{u1} A) (fun (_x : PowerSeries.{u1} A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : PowerSeries.{u1} A) => PowerSeries.{u1} A) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} (PowerSeries.{u1} A) (PowerSeries.{u1} A) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1)))) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1))))) (PowerSeries.{u1} A) (PowerSeries.{u1} A) (NonUnitalNonAssocSemiring.toMul.{u1} (PowerSeries.{u1} A) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (PowerSeries.{u1} A) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1)))))) (NonUnitalNonAssocSemiring.toMul.{u1} (PowerSeries.{u1} A) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (PowerSeries.{u1} A) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} (PowerSeries.{u1} A) (PowerSeries.{u1} A) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1)))) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1))))) (PowerSeries.{u1} A) (PowerSeries.{u1} A) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (PowerSeries.{u1} A) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (PowerSeries.{u1} A) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} (PowerSeries.{u1} A) (PowerSeries.{u1} A) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1)))) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1))))) (PowerSeries.{u1} A) (PowerSeries.{u1} A) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1)))) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} (PowerSeries.{u1} A) (PowerSeries.{u1} A) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1)))) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1)))))))) (PowerSeries.evalNegHom.{u1} A _inst_1) (PowerSeries.exp.{u1} A (CommRing.toRing.{u1} A _inst_1) _inst_2))) (OfNat.ofNat.{u1} (PowerSeries.{u1} A) 1 (One.toOfNat1.{u1} (PowerSeries.{u1} A) (Semiring.toOne.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1))))))
Case conversion may be inaccurate. Consider using '#align power_series.exp_mul_exp_neg_eq_one PowerSeries.exp_mul_exp_neg_eq_oneₓ'. -/
/-- Shows that $e^{x} * e^{-x} = 1$ -/
theorem exp_mul_exp_neg_eq_one [Algebra ℚ A] : exp A * evalNegHom (exp A) = 1 := by
  convert exp_mul_exp_eq_exp_add (1 : A) (-1) <;> simp
#align power_series.exp_mul_exp_neg_eq_one PowerSeries.exp_mul_exp_neg_eq_one

/- warning: power_series.exp_pow_eq_rescale_exp -> PowerSeries.exp_pow_eq_rescale_exp is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} [_inst_1 : CommRing.{u1} A] [_inst_2 : Algebra.{0, u1} Rat A Rat.commSemiring (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1))] (k : Nat), Eq.{succ u1} (PowerSeries.{u1} A) (HPow.hPow.{u1, 0, u1} (PowerSeries.{u1} A) Nat (PowerSeries.{u1} A) (instHPow.{u1, 0} (PowerSeries.{u1} A) Nat (Monoid.Pow.{u1} (PowerSeries.{u1} A) (Ring.toMonoid.{u1} (PowerSeries.{u1} A) (PowerSeries.ring.{u1} A (CommRing.toRing.{u1} A _inst_1))))) (PowerSeries.exp.{u1} A (CommRing.toRing.{u1} A _inst_1) _inst_2) k) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} (PowerSeries.{u1} A) (PowerSeries.{u1} A) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.semiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1)))) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.semiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1))))) (fun (_x : RingHom.{u1, u1} (PowerSeries.{u1} A) (PowerSeries.{u1} A) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.semiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1)))) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.semiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1))))) => (PowerSeries.{u1} A) -> (PowerSeries.{u1} A)) (RingHom.hasCoeToFun.{u1, u1} (PowerSeries.{u1} A) (PowerSeries.{u1} A) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.semiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1)))) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.semiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1))))) (PowerSeries.rescale.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat A (HasLiftT.mk.{1, succ u1} Nat A (CoeTCₓ.coe.{1, succ u1} Nat A (Nat.castCoe.{u1} A (AddMonoidWithOne.toNatCast.{u1} A (AddGroupWithOne.toAddMonoidWithOne.{u1} A (AddCommGroupWithOne.toAddGroupWithOne.{u1} A (Ring.toAddCommGroupWithOne.{u1} A (CommRing.toRing.{u1} A _inst_1)))))))) k)) (PowerSeries.exp.{u1} A (CommRing.toRing.{u1} A _inst_1) _inst_2))
but is expected to have type
  forall {A : Type.{u1}} [_inst_1 : CommRing.{u1} A] [_inst_2 : Algebra.{0, u1} Rat A Rat.commSemiring (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1))] (k : Nat), Eq.{succ u1} (PowerSeries.{u1} A) (HPow.hPow.{u1, 0, u1} (PowerSeries.{u1} A) Nat (PowerSeries.{u1} A) (instHPow.{u1, 0} (PowerSeries.{u1} A) Nat (Monoid.Pow.{u1} (PowerSeries.{u1} A) (MonoidWithZero.toMonoid.{u1} (PowerSeries.{u1} A) (Semiring.toMonoidWithZero.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1))))))) (PowerSeries.exp.{u1} A (CommRing.toRing.{u1} A _inst_1) _inst_2) k) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} (PowerSeries.{u1} A) (PowerSeries.{u1} A) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1)))) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1))))) (PowerSeries.{u1} A) (fun (_x : PowerSeries.{u1} A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : PowerSeries.{u1} A) => PowerSeries.{u1} A) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} (PowerSeries.{u1} A) (PowerSeries.{u1} A) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1)))) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1))))) (PowerSeries.{u1} A) (PowerSeries.{u1} A) (NonUnitalNonAssocSemiring.toMul.{u1} (PowerSeries.{u1} A) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (PowerSeries.{u1} A) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1)))))) (NonUnitalNonAssocSemiring.toMul.{u1} (PowerSeries.{u1} A) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (PowerSeries.{u1} A) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} (PowerSeries.{u1} A) (PowerSeries.{u1} A) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1)))) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1))))) (PowerSeries.{u1} A) (PowerSeries.{u1} A) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (PowerSeries.{u1} A) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (PowerSeries.{u1} A) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} (PowerSeries.{u1} A) (PowerSeries.{u1} A) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1)))) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1))))) (PowerSeries.{u1} A) (PowerSeries.{u1} A) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1)))) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} (PowerSeries.{u1} A) (PowerSeries.{u1} A) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1)))) (Semiring.toNonAssocSemiring.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1)))))))) (PowerSeries.rescale.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1) (Nat.cast.{u1} A (Semiring.toNatCast.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1))) k)) (PowerSeries.exp.{u1} A (CommRing.toRing.{u1} A _inst_1) _inst_2))
Case conversion may be inaccurate. Consider using '#align power_series.exp_pow_eq_rescale_exp PowerSeries.exp_pow_eq_rescale_expₓ'. -/
/-- Shows that $(e^{X})^k = e^{kX}$. -/
theorem exp_pow_eq_rescale_exp [Algebra ℚ A] (k : ℕ) : exp A ^ k = rescale (k : A) (exp A) :=
  by
  induction' k with k h
  ·
    simp only [rescale_zero, constant_coeff_exp, Function.comp_apply, map_one, cast_zero, pow_zero,
      coe_comp]
  simpa only [succ_eq_add_one, cast_add, ← exp_mul_exp_eq_exp_add (k : A), ← h, cast_one, id_apply,
    rescale_one] using pow_succ' (exp A) k
#align power_series.exp_pow_eq_rescale_exp PowerSeries.exp_pow_eq_rescale_exp

/- warning: power_series.exp_pow_sum -> PowerSeries.exp_pow_sum is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} [_inst_1 : CommRing.{u1} A] [_inst_2 : Algebra.{0, u1} Rat A Rat.commSemiring (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1))] (n : Nat), Eq.{succ u1} (PowerSeries.{u1} A) (Finset.sum.{u1, 0} (PowerSeries.{u1} A) Nat (PowerSeries.addCommMonoid.{u1} A (AddCommGroup.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toAddCommGroup.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1)))))) (Finset.range n) (fun (k : Nat) => HPow.hPow.{u1, 0, u1} (PowerSeries.{u1} A) Nat (PowerSeries.{u1} A) (instHPow.{u1, 0} (PowerSeries.{u1} A) Nat (Monoid.Pow.{u1} (PowerSeries.{u1} A) (Ring.toMonoid.{u1} (PowerSeries.{u1} A) (PowerSeries.ring.{u1} A (CommRing.toRing.{u1} A _inst_1))))) (PowerSeries.exp.{u1} A (CommRing.toRing.{u1} A _inst_1) _inst_2) k)) (PowerSeries.mk.{u1} A (fun (p : Nat) => Finset.sum.{u1, 0} A Nat (AddCommGroup.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toAddCommGroup.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))))) (Finset.range n) (fun (k : Nat) => HMul.hMul.{u1, u1, u1} A A A (instHMul.{u1} A (Distrib.toHasMul.{u1} A (Ring.toDistrib.{u1} A (CommRing.toRing.{u1} A _inst_1)))) (HPow.hPow.{u1, 0, u1} A Nat A (instHPow.{u1, 0} A Nat (Monoid.Pow.{u1} A (Ring.toMonoid.{u1} A (CommRing.toRing.{u1} A _inst_1)))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat A (HasLiftT.mk.{1, succ u1} Nat A (CoeTCₓ.coe.{1, succ u1} Nat A (Nat.castCoe.{u1} A (AddMonoidWithOne.toNatCast.{u1} A (AddGroupWithOne.toAddMonoidWithOne.{u1} A (AddCommGroupWithOne.toAddGroupWithOne.{u1} A (Ring.toAddCommGroupWithOne.{u1} A (CommRing.toRing.{u1} A _inst_1)))))))) k) p) (coeFn.{succ u1, succ u1} (RingHom.{0, u1} Rat A (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1)))) (fun (_x : RingHom.{0, u1} Rat A (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1)))) => Rat -> A) (RingHom.hasCoeToFun.{0, u1} Rat A (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1)))) (algebraMap.{0, u1} Rat A Rat.commSemiring (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1)) _inst_2) (Inv.inv.{0} Rat Rat.hasInv ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Rat (HasLiftT.mk.{1, 1} Nat Rat (CoeTCₓ.coe.{1, 1} Nat Rat (Nat.castCoe.{0} Rat (AddMonoidWithOne.toNatCast.{0} Rat (AddGroupWithOne.toAddMonoidWithOne.{0} Rat (AddCommGroupWithOne.toAddGroupWithOne.{0} Rat (Ring.toAddCommGroupWithOne.{0} Rat (DivisionRing.toRing.{0} Rat Rat.divisionRing)))))))) (Nat.factorial p)))))))
but is expected to have type
  forall {A : Type.{u1}} [_inst_1 : CommRing.{u1} A] [_inst_2 : Algebra.{0, u1} Rat A Rat.commSemiring (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1))] (n : Nat), Eq.{succ u1} (PowerSeries.{u1} A) (Finset.sum.{u1, 0} (PowerSeries.{u1} A) Nat (PowerSeries.instAddCommMonoidPowerSeries.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1)))))) (Finset.range n) (fun (k : Nat) => HPow.hPow.{u1, 0, u1} (PowerSeries.{u1} A) Nat (PowerSeries.{u1} A) (instHPow.{u1, 0} (PowerSeries.{u1} A) Nat (Monoid.Pow.{u1} (PowerSeries.{u1} A) (MonoidWithZero.toMonoid.{u1} (PowerSeries.{u1} A) (Semiring.toMonoidWithZero.{u1} (PowerSeries.{u1} A) (PowerSeries.instSemiringPowerSeries.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1))))))) (PowerSeries.exp.{u1} A (CommRing.toRing.{u1} A _inst_1) _inst_2) k)) (PowerSeries.mk.{u1} A (fun (p : Nat) => Finset.sum.{u1, 0} A Nat (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))))) (Finset.range n) (fun (k : Nat) => HMul.hMul.{u1, u1, u1} A ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Rat) => A) (Inv.inv.{0} Rat Rat.instInvRat (Nat.cast.{0} Rat (Semiring.toNatCast.{0} Rat Rat.semiring) (Nat.factorial p)))) A (instHMul.{u1} A (NonUnitalNonAssocRing.toMul.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))))) (Nat.cast.{u1} A (Semiring.toNatCast.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1))) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) k p)) (FunLike.coe.{succ u1, 1, succ u1} (RingHom.{0, u1} Rat A (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1)))) Rat (fun (_x : Rat) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Rat) => A) _x) (MulHomClass.toFunLike.{u1, 0, u1} (RingHom.{0, u1} Rat A (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1)))) Rat A (NonUnitalNonAssocSemiring.toMul.{0} Rat (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Rat (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)))) (NonUnitalNonAssocSemiring.toMul.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1))))) (NonUnitalRingHomClass.toMulHomClass.{u1, 0, u1} (RingHom.{0, u1} Rat A (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1)))) Rat A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Rat (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1)))) (RingHomClass.toNonUnitalRingHomClass.{u1, 0, u1} (RingHom.{0, u1} Rat A (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1)))) Rat A (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1))) (RingHom.instRingHomClassRingHom.{0, u1} Rat A (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1))))))) (algebraMap.{0, u1} Rat A Rat.commSemiring (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_1)) _inst_2) (Inv.inv.{0} Rat Rat.instInvRat (Nat.cast.{0} Rat (Semiring.toNatCast.{0} Rat Rat.semiring) (Nat.factorial p)))))))
Case conversion may be inaccurate. Consider using '#align power_series.exp_pow_sum PowerSeries.exp_pow_sumₓ'. -/
/-- Shows that
$\sum_{k = 0}^{n - 1} (e^{X})^k = \sum_{p = 0}^{\infty} \sum_{k = 0}^{n - 1} \frac{k^p}{p!}X^p$. -/
theorem exp_pow_sum [Algebra ℚ A] (n : ℕ) :
    ((Finset.range n).Sum fun k => exp A ^ k) =
      PowerSeries.mk fun p => (Finset.range n).Sum fun k => k ^ p * algebraMap ℚ A p.factorial⁻¹ :=
  by
  simp only [exp_pow_eq_rescale_exp, rescale]
  ext
  simp only [one_div, coeff_mk, coe_mk, coeff_exp, factorial, LinearMap.map_sum]
#align power_series.exp_pow_sum PowerSeries.exp_pow_sum

end PowerSeries

