/-
Copyright (c) 2021 Eric Wieser. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Eric Wieser

! This file was ported from Lean 3 source module ring_theory.subring.pointwise
! leanprover-community/mathlib commit 932872382355f00112641d305ba0619305dc8642
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.RingTheory.Subring.Basic
import Mathbin.GroupTheory.Subgroup.Pointwise
import Mathbin.RingTheory.Subsemiring.Pointwise
import Mathbin.Data.Set.Pointwise.Basic

/-! # Pointwise instances on `subring`s

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file provides the action `subring.pointwise_mul_action` which matches the action of
`mul_action_set`.

This actions is available in the `pointwise` locale.

## Implementation notes

This file is almost identical to `ring_theory/subsemiring/pointwise.lean`. Where possible, try to
keep them in sync.

-/


open Set

variable {M R : Type _}

namespace Subring

section Monoid

variable [Monoid M] [Ring R] [MulSemiringAction M R]

#print Subring.pointwiseMulAction /-
/-- The action on a subring corresponding to applying the action to every element.

This is available as an instance in the `pointwise` locale. -/
protected def pointwiseMulAction : MulAction M (Subring R)
    where
  smul a S := S.map (MulSemiringAction.toRingHom _ _ a)
  one_smul S := (congr_arg (fun f => S.map f) (RingHom.ext <| one_smul M)).trans S.map_id
  mul_smul a₁ a₂ S :=
    (congr_arg (fun f => S.map f) (RingHom.ext <| mul_smul _ _)).trans (S.map_map _ _).symm
#align subring.pointwise_mul_action Subring.pointwiseMulAction
-/

scoped[Pointwise] attribute [instance] Subring.pointwiseMulAction

open Pointwise

#print Subring.pointwise_smul_def /-
theorem pointwise_smul_def {a : M} (S : Subring R) :
    a • S = S.map (MulSemiringAction.toRingHom _ _ a) :=
  rfl
#align subring.pointwise_smul_def Subring.pointwise_smul_def
-/

/- warning: subring.coe_pointwise_smul -> Subring.coe_pointwise_smul is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : Monoid.{u1} M] [_inst_2 : Ring.{u2} R] [_inst_3 : MulSemiringAction.{u1, u2} M R _inst_1 (Ring.toSemiring.{u2} R _inst_2)] (m : M) (S : Subring.{u2} R _inst_2), Eq.{succ u2} (Set.{u2} R) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Subring.{u2} R _inst_2) (Set.{u2} R) (HasLiftT.mk.{succ u2, succ u2} (Subring.{u2} R _inst_2) (Set.{u2} R) (CoeTCₓ.coe.{succ u2, succ u2} (Subring.{u2} R _inst_2) (Set.{u2} R) (SetLike.Set.hasCoeT.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.setLike.{u2} R _inst_2)))) (SMul.smul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toHasSmul.{u1, u2} M (Subring.{u2} R _inst_2) _inst_1 (Subring.pointwiseMulAction.{u1, u2} M R _inst_1 _inst_2 _inst_3)) m S)) (SMul.smul.{u1, u2} M (Set.{u2} R) (Set.smulSet.{u1, u2} M R (SMulZeroClass.toHasSmul.{u1, u2} M R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_2))))))) (DistribSMul.toSmulZeroClass.{u1, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_2)))))) (DistribMulAction.toDistribSMul.{u1, u2} M R _inst_1 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_2))))) (MulSemiringAction.toDistribMulAction.{u1, u2} M R _inst_1 (Ring.toSemiring.{u2} R _inst_2) _inst_3))))) m ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Subring.{u2} R _inst_2) (Set.{u2} R) (HasLiftT.mk.{succ u2, succ u2} (Subring.{u2} R _inst_2) (Set.{u2} R) (CoeTCₓ.coe.{succ u2, succ u2} (Subring.{u2} R _inst_2) (Set.{u2} R) (SetLike.Set.hasCoeT.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.setLike.{u2} R _inst_2)))) S))
but is expected to have type
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : Monoid.{u1} M] [_inst_2 : Ring.{u2} R] [_inst_3 : MulSemiringAction.{u1, u2} M R _inst_1 (Ring.toSemiring.{u2} R _inst_2)] (m : M) (S : Subring.{u2} R _inst_2), Eq.{succ u2} (Set.{u2} R) (SetLike.coe.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.instSetLikeSubring.{u2} R _inst_2) (HSMul.hSMul.{u1, u2, u2} M (Subring.{u2} R _inst_2) (Subring.{u2} R _inst_2) (instHSMul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toSMul.{u1, u2} M (Subring.{u2} R _inst_2) _inst_1 (Subring.pointwiseMulAction.{u1, u2} M R _inst_1 _inst_2 _inst_3))) m S)) (HSMul.hSMul.{u1, u2, u2} M (Set.{u2} R) (Set.{u2} R) (instHSMul.{u1, u2} M (Set.{u2} R) (Set.smulSet.{u1, u2} M R (SMulZeroClass.toSMul.{u1, u2} M R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_2))) (DistribSMul.toSMulZeroClass.{u1, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (Ring.toAddGroupWithOne.{u2} R _inst_2)))) (DistribMulAction.toDistribSMul.{u1, u2} M R _inst_1 (AddMonoidWithOne.toAddMonoid.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (Ring.toAddGroupWithOne.{u2} R _inst_2))) (MulSemiringAction.toDistribMulAction.{u1, u2} M R _inst_1 (Ring.toSemiring.{u2} R _inst_2) _inst_3)))))) m (SetLike.coe.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.instSetLikeSubring.{u2} R _inst_2) S))
Case conversion may be inaccurate. Consider using '#align subring.coe_pointwise_smul Subring.coe_pointwise_smulₓ'. -/
@[simp]
theorem coe_pointwise_smul (m : M) (S : Subring R) : ↑(m • S) = m • (S : Set R) :=
  rfl
#align subring.coe_pointwise_smul Subring.coe_pointwise_smul

#print Subring.pointwise_smul_toAddSubgroup /-
@[simp]
theorem pointwise_smul_toAddSubgroup (m : M) (S : Subring R) :
    (m • S).toAddSubgroup = m • S.toAddSubgroup :=
  rfl
#align subring.pointwise_smul_to_add_subgroup Subring.pointwise_smul_toAddSubgroup
-/

#print Subring.pointwise_smul_toSubsemiring /-
@[simp]
theorem pointwise_smul_toSubsemiring (m : M) (S : Subring R) :
    (m • S).toSubsemiring = m • S.toSubsemiring :=
  rfl
#align subring.pointwise_smul_to_subsemiring Subring.pointwise_smul_toSubsemiring
-/

/- warning: subring.smul_mem_pointwise_smul -> Subring.smul_mem_pointwise_smul is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : Monoid.{u1} M] [_inst_2 : Ring.{u2} R] [_inst_3 : MulSemiringAction.{u1, u2} M R _inst_1 (Ring.toSemiring.{u2} R _inst_2)] (m : M) (r : R) (S : Subring.{u2} R _inst_2), (Membership.Mem.{u2, u2} R (Subring.{u2} R _inst_2) (SetLike.hasMem.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.setLike.{u2} R _inst_2)) r S) -> (Membership.Mem.{u2, u2} R (Subring.{u2} R _inst_2) (SetLike.hasMem.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.setLike.{u2} R _inst_2)) (SMul.smul.{u1, u2} M R (SMulZeroClass.toHasSmul.{u1, u2} M R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_2))))))) (DistribSMul.toSmulZeroClass.{u1, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_2)))))) (DistribMulAction.toDistribSMul.{u1, u2} M R _inst_1 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_2))))) (MulSemiringAction.toDistribMulAction.{u1, u2} M R _inst_1 (Ring.toSemiring.{u2} R _inst_2) _inst_3)))) m r) (SMul.smul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toHasSmul.{u1, u2} M (Subring.{u2} R _inst_2) _inst_1 (Subring.pointwiseMulAction.{u1, u2} M R _inst_1 _inst_2 _inst_3)) m S))
but is expected to have type
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : Monoid.{u1} M] [_inst_2 : Ring.{u2} R] [_inst_3 : MulSemiringAction.{u1, u2} M R _inst_1 (Ring.toSemiring.{u2} R _inst_2)] (m : M) (r : R) (S : Subring.{u2} R _inst_2), (Membership.mem.{u2, u2} R (Subring.{u2} R _inst_2) (SetLike.instMembership.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.instSetLikeSubring.{u2} R _inst_2)) r S) -> (Membership.mem.{u2, u2} R (Subring.{u2} R _inst_2) (SetLike.instMembership.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.instSetLikeSubring.{u2} R _inst_2)) (HSMul.hSMul.{u1, u2, u2} M R R (instHSMul.{u1, u2} M R (SMulZeroClass.toSMul.{u1, u2} M R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_2))) (DistribSMul.toSMulZeroClass.{u1, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (Ring.toAddGroupWithOne.{u2} R _inst_2)))) (DistribMulAction.toDistribSMul.{u1, u2} M R _inst_1 (AddMonoidWithOne.toAddMonoid.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (Ring.toAddGroupWithOne.{u2} R _inst_2))) (MulSemiringAction.toDistribMulAction.{u1, u2} M R _inst_1 (Ring.toSemiring.{u2} R _inst_2) _inst_3))))) m r) (HSMul.hSMul.{u1, u2, u2} M (Subring.{u2} R _inst_2) (Subring.{u2} R _inst_2) (instHSMul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toSMul.{u1, u2} M (Subring.{u2} R _inst_2) _inst_1 (Subring.pointwiseMulAction.{u1, u2} M R _inst_1 _inst_2 _inst_3))) m S))
Case conversion may be inaccurate. Consider using '#align subring.smul_mem_pointwise_smul Subring.smul_mem_pointwise_smulₓ'. -/
theorem smul_mem_pointwise_smul (m : M) (r : R) (S : Subring R) : r ∈ S → m • r ∈ m • S :=
  (Set.smul_mem_smul_set : _ → _ ∈ m • (S : Set R))
#align subring.smul_mem_pointwise_smul Subring.smul_mem_pointwise_smul

/- warning: subring.mem_smul_pointwise_iff_exists -> Subring.mem_smul_pointwise_iff_exists is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : Monoid.{u1} M] [_inst_2 : Ring.{u2} R] [_inst_3 : MulSemiringAction.{u1, u2} M R _inst_1 (Ring.toSemiring.{u2} R _inst_2)] (m : M) (r : R) (S : Subring.{u2} R _inst_2), Iff (Membership.Mem.{u2, u2} R (Subring.{u2} R _inst_2) (SetLike.hasMem.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.setLike.{u2} R _inst_2)) r (SMul.smul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toHasSmul.{u1, u2} M (Subring.{u2} R _inst_2) _inst_1 (Subring.pointwiseMulAction.{u1, u2} M R _inst_1 _inst_2 _inst_3)) m S)) (Exists.{succ u2} R (fun (s : R) => And (Membership.Mem.{u2, u2} R (Subring.{u2} R _inst_2) (SetLike.hasMem.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.setLike.{u2} R _inst_2)) s S) (Eq.{succ u2} R (SMul.smul.{u1, u2} M R (SMulZeroClass.toHasSmul.{u1, u2} M R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_2))))))) (DistribSMul.toSmulZeroClass.{u1, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_2)))))) (DistribMulAction.toDistribSMul.{u1, u2} M R _inst_1 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_2))))) (MulSemiringAction.toDistribMulAction.{u1, u2} M R _inst_1 (Ring.toSemiring.{u2} R _inst_2) _inst_3)))) m s) r)))
but is expected to have type
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : Monoid.{u1} M] [_inst_2 : Ring.{u2} R] [_inst_3 : MulSemiringAction.{u1, u2} M R _inst_1 (Ring.toSemiring.{u2} R _inst_2)] (m : M) (r : R) (S : Subring.{u2} R _inst_2), Iff (Membership.mem.{u2, u2} R (Subring.{u2} R _inst_2) (SetLike.instMembership.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.instSetLikeSubring.{u2} R _inst_2)) r (HSMul.hSMul.{u1, u2, u2} M (Subring.{u2} R _inst_2) (Subring.{u2} R _inst_2) (instHSMul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toSMul.{u1, u2} M (Subring.{u2} R _inst_2) _inst_1 (Subring.pointwiseMulAction.{u1, u2} M R _inst_1 _inst_2 _inst_3))) m S)) (Exists.{succ u2} R (fun (s : R) => And (Membership.mem.{u2, u2} R (Subring.{u2} R _inst_2) (SetLike.instMembership.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.instSetLikeSubring.{u2} R _inst_2)) s S) (Eq.{succ u2} R (HSMul.hSMul.{u1, u2, u2} M R R (instHSMul.{u1, u2} M R (SMulZeroClass.toSMul.{u1, u2} M R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_2))) (DistribSMul.toSMulZeroClass.{u1, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (Ring.toAddGroupWithOne.{u2} R _inst_2)))) (DistribMulAction.toDistribSMul.{u1, u2} M R _inst_1 (AddMonoidWithOne.toAddMonoid.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (Ring.toAddGroupWithOne.{u2} R _inst_2))) (MulSemiringAction.toDistribMulAction.{u1, u2} M R _inst_1 (Ring.toSemiring.{u2} R _inst_2) _inst_3))))) m s) r)))
Case conversion may be inaccurate. Consider using '#align subring.mem_smul_pointwise_iff_exists Subring.mem_smul_pointwise_iff_existsₓ'. -/
theorem mem_smul_pointwise_iff_exists (m : M) (r : R) (S : Subring R) :
    r ∈ m • S ↔ ∃ s : R, s ∈ S ∧ m • s = r :=
  (Set.mem_smul_set : r ∈ m • (S : Set R) ↔ _)
#align subring.mem_smul_pointwise_iff_exists Subring.mem_smul_pointwise_iff_exists

/- warning: subring.smul_bot -> Subring.smul_bot is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : Monoid.{u1} M] [_inst_2 : Ring.{u2} R] [_inst_3 : MulSemiringAction.{u1, u2} M R _inst_1 (Ring.toSemiring.{u2} R _inst_2)] (a : M), Eq.{succ u2} (Subring.{u2} R _inst_2) (SMul.smul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toHasSmul.{u1, u2} M (Subring.{u2} R _inst_2) _inst_1 (Subring.pointwiseMulAction.{u1, u2} M R _inst_1 _inst_2 _inst_3)) a (Bot.bot.{u2} (Subring.{u2} R _inst_2) (Subring.hasBot.{u2} R _inst_2))) (Bot.bot.{u2} (Subring.{u2} R _inst_2) (Subring.hasBot.{u2} R _inst_2))
but is expected to have type
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : Monoid.{u1} M] [_inst_2 : Ring.{u2} R] [_inst_3 : MulSemiringAction.{u1, u2} M R _inst_1 (Ring.toSemiring.{u2} R _inst_2)] (a : M), Eq.{succ u2} (Subring.{u2} R _inst_2) (HSMul.hSMul.{u1, u2, u2} M (Subring.{u2} R _inst_2) (Subring.{u2} R _inst_2) (instHSMul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toSMul.{u1, u2} M (Subring.{u2} R _inst_2) _inst_1 (Subring.pointwiseMulAction.{u1, u2} M R _inst_1 _inst_2 _inst_3))) a (Bot.bot.{u2} (Subring.{u2} R _inst_2) (Subring.instBotSubring.{u2} R _inst_2))) (Bot.bot.{u2} (Subring.{u2} R _inst_2) (Subring.instBotSubring.{u2} R _inst_2))
Case conversion may be inaccurate. Consider using '#align subring.smul_bot Subring.smul_botₓ'. -/
@[simp]
theorem smul_bot (a : M) : a • (⊥ : Subring R) = ⊥ :=
  map_bot _
#align subring.smul_bot Subring.smul_bot

/- warning: subring.smul_sup -> Subring.smul_sup is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : Monoid.{u1} M] [_inst_2 : Ring.{u2} R] [_inst_3 : MulSemiringAction.{u1, u2} M R _inst_1 (Ring.toSemiring.{u2} R _inst_2)] (a : M) (S : Subring.{u2} R _inst_2) (T : Subring.{u2} R _inst_2), Eq.{succ u2} (Subring.{u2} R _inst_2) (SMul.smul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toHasSmul.{u1, u2} M (Subring.{u2} R _inst_2) _inst_1 (Subring.pointwiseMulAction.{u1, u2} M R _inst_1 _inst_2 _inst_3)) a (Sup.sup.{u2} (Subring.{u2} R _inst_2) (SemilatticeSup.toHasSup.{u2} (Subring.{u2} R _inst_2) (Lattice.toSemilatticeSup.{u2} (Subring.{u2} R _inst_2) (ConditionallyCompleteLattice.toLattice.{u2} (Subring.{u2} R _inst_2) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Subring.{u2} R _inst_2) (Subring.completeLattice.{u2} R _inst_2))))) S T)) (Sup.sup.{u2} (Subring.{u2} R _inst_2) (SemilatticeSup.toHasSup.{u2} (Subring.{u2} R _inst_2) (Lattice.toSemilatticeSup.{u2} (Subring.{u2} R _inst_2) (ConditionallyCompleteLattice.toLattice.{u2} (Subring.{u2} R _inst_2) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Subring.{u2} R _inst_2) (Subring.completeLattice.{u2} R _inst_2))))) (SMul.smul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toHasSmul.{u1, u2} M (Subring.{u2} R _inst_2) _inst_1 (Subring.pointwiseMulAction.{u1, u2} M R _inst_1 _inst_2 _inst_3)) a S) (SMul.smul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toHasSmul.{u1, u2} M (Subring.{u2} R _inst_2) _inst_1 (Subring.pointwiseMulAction.{u1, u2} M R _inst_1 _inst_2 _inst_3)) a T))
but is expected to have type
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : Monoid.{u1} M] [_inst_2 : Ring.{u2} R] [_inst_3 : MulSemiringAction.{u1, u2} M R _inst_1 (Ring.toSemiring.{u2} R _inst_2)] (a : M) (S : Subring.{u2} R _inst_2) (T : Subring.{u2} R _inst_2), Eq.{succ u2} (Subring.{u2} R _inst_2) (HSMul.hSMul.{u1, u2, u2} M (Subring.{u2} R _inst_2) (Subring.{u2} R _inst_2) (instHSMul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toSMul.{u1, u2} M (Subring.{u2} R _inst_2) _inst_1 (Subring.pointwiseMulAction.{u1, u2} M R _inst_1 _inst_2 _inst_3))) a (Sup.sup.{u2} (Subring.{u2} R _inst_2) (SemilatticeSup.toSup.{u2} (Subring.{u2} R _inst_2) (Lattice.toSemilatticeSup.{u2} (Subring.{u2} R _inst_2) (ConditionallyCompleteLattice.toLattice.{u2} (Subring.{u2} R _inst_2) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Subring.{u2} R _inst_2) (Subring.instCompleteLatticeSubring.{u2} R _inst_2))))) S T)) (Sup.sup.{u2} (Subring.{u2} R _inst_2) (SemilatticeSup.toSup.{u2} (Subring.{u2} R _inst_2) (Lattice.toSemilatticeSup.{u2} (Subring.{u2} R _inst_2) (ConditionallyCompleteLattice.toLattice.{u2} (Subring.{u2} R _inst_2) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Subring.{u2} R _inst_2) (Subring.instCompleteLatticeSubring.{u2} R _inst_2))))) (HSMul.hSMul.{u1, u2, u2} M (Subring.{u2} R _inst_2) (Subring.{u2} R _inst_2) (instHSMul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toSMul.{u1, u2} M (Subring.{u2} R _inst_2) _inst_1 (Subring.pointwiseMulAction.{u1, u2} M R _inst_1 _inst_2 _inst_3))) a S) (HSMul.hSMul.{u1, u2, u2} M (Subring.{u2} R _inst_2) (Subring.{u2} R _inst_2) (instHSMul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toSMul.{u1, u2} M (Subring.{u2} R _inst_2) _inst_1 (Subring.pointwiseMulAction.{u1, u2} M R _inst_1 _inst_2 _inst_3))) a T))
Case conversion may be inaccurate. Consider using '#align subring.smul_sup Subring.smul_supₓ'. -/
theorem smul_sup (a : M) (S T : Subring R) : a • (S ⊔ T) = a • S ⊔ a • T :=
  map_sup _ _ _
#align subring.smul_sup Subring.smul_sup

#print Subring.smul_closure /-
theorem smul_closure (a : M) (s : Set R) : a • closure s = closure (a • s) :=
  RingHom.map_closure _ _
#align subring.smul_closure Subring.smul_closure
-/

/- warning: subring.pointwise_central_scalar -> Subring.pointwise_central_scalar is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : Monoid.{u1} M] [_inst_2 : Ring.{u2} R] [_inst_3 : MulSemiringAction.{u1, u2} M R _inst_1 (Ring.toSemiring.{u2} R _inst_2)] [_inst_4 : MulSemiringAction.{u1, u2} (MulOpposite.{u1} M) R (MulOpposite.monoid.{u1} M _inst_1) (Ring.toSemiring.{u2} R _inst_2)] [_inst_5 : IsCentralScalar.{u1, u2} M R (SMulZeroClass.toHasSmul.{u1, u2} M R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_2))))))) (DistribSMul.toSmulZeroClass.{u1, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_2)))))) (DistribMulAction.toDistribSMul.{u1, u2} M R _inst_1 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_2))))) (MulSemiringAction.toDistribMulAction.{u1, u2} M R _inst_1 (Ring.toSemiring.{u2} R _inst_2) _inst_3)))) (SMulZeroClass.toHasSmul.{u1, u2} (MulOpposite.{u1} M) R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_2))))))) (DistribSMul.toSmulZeroClass.{u1, u2} (MulOpposite.{u1} M) R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_2)))))) (DistribMulAction.toDistribSMul.{u1, u2} (MulOpposite.{u1} M) R (MulOpposite.monoid.{u1} M _inst_1) (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_2))))) (MulSemiringAction.toDistribMulAction.{u1, u2} (MulOpposite.{u1} M) R (MulOpposite.monoid.{u1} M _inst_1) (Ring.toSemiring.{u2} R _inst_2) _inst_4))))], IsCentralScalar.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toHasSmul.{u1, u2} M (Subring.{u2} R _inst_2) _inst_1 (Subring.pointwiseMulAction.{u1, u2} M R _inst_1 _inst_2 _inst_3)) (MulAction.toHasSmul.{u1, u2} (MulOpposite.{u1} M) (Subring.{u2} R _inst_2) (MulOpposite.monoid.{u1} M _inst_1) (Subring.pointwiseMulAction.{u1, u2} (MulOpposite.{u1} M) R (MulOpposite.monoid.{u1} M _inst_1) _inst_2 _inst_4))
but is expected to have type
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : Monoid.{u1} M] [_inst_2 : Ring.{u2} R] [_inst_3 : MulSemiringAction.{u1, u2} M R _inst_1 (Ring.toSemiring.{u2} R _inst_2)] [_inst_4 : MulSemiringAction.{u1, u2} (MulOpposite.{u1} M) R (MulOpposite.monoid.{u1} M _inst_1) (Ring.toSemiring.{u2} R _inst_2)] [_inst_5 : IsCentralScalar.{u1, u2} M R (SMulZeroClass.toSMul.{u1, u2} M R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_2))) (DistribSMul.toSMulZeroClass.{u1, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (Ring.toAddGroupWithOne.{u2} R _inst_2)))) (DistribMulAction.toDistribSMul.{u1, u2} M R _inst_1 (AddMonoidWithOne.toAddMonoid.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (Ring.toAddGroupWithOne.{u2} R _inst_2))) (MulSemiringAction.toDistribMulAction.{u1, u2} M R _inst_1 (Ring.toSemiring.{u2} R _inst_2) _inst_3)))) (SMulZeroClass.toSMul.{u1, u2} (MulOpposite.{u1} M) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_2))) (DistribSMul.toSMulZeroClass.{u1, u2} (MulOpposite.{u1} M) R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (Ring.toAddGroupWithOne.{u2} R _inst_2)))) (DistribMulAction.toDistribSMul.{u1, u2} (MulOpposite.{u1} M) R (MulOpposite.monoid.{u1} M _inst_1) (AddMonoidWithOne.toAddMonoid.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (Ring.toAddGroupWithOne.{u2} R _inst_2))) (MulSemiringAction.toDistribMulAction.{u1, u2} (MulOpposite.{u1} M) R (MulOpposite.monoid.{u1} M _inst_1) (Ring.toSemiring.{u2} R _inst_2) _inst_4))))], IsCentralScalar.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toSMul.{u1, u2} M (Subring.{u2} R _inst_2) _inst_1 (Subring.pointwiseMulAction.{u1, u2} M R _inst_1 _inst_2 _inst_3)) (MulAction.toSMul.{u1, u2} (MulOpposite.{u1} M) (Subring.{u2} R _inst_2) (MulOpposite.monoid.{u1} M _inst_1) (Subring.pointwiseMulAction.{u1, u2} (MulOpposite.{u1} M) R (MulOpposite.monoid.{u1} M _inst_1) _inst_2 _inst_4))
Case conversion may be inaccurate. Consider using '#align subring.pointwise_central_scalar Subring.pointwise_central_scalarₓ'. -/
instance pointwise_central_scalar [MulSemiringAction Mᵐᵒᵖ R] [IsCentralScalar M R] :
    IsCentralScalar M (Subring R) :=
  ⟨fun a S => (congr_arg fun f => S.map f) <| RingHom.ext <| op_smul_eq_smul _⟩
#align subring.pointwise_central_scalar Subring.pointwise_central_scalar

end Monoid

section Group

variable [Group M] [Ring R] [MulSemiringAction M R]

open Pointwise

/- warning: subring.smul_mem_pointwise_smul_iff -> Subring.smul_mem_pointwise_smul_iff is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : Group.{u1} M] [_inst_2 : Ring.{u2} R] [_inst_3 : MulSemiringAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Ring.toSemiring.{u2} R _inst_2)] {a : M} {S : Subring.{u2} R _inst_2} {x : R}, Iff (Membership.Mem.{u2, u2} R (Subring.{u2} R _inst_2) (SetLike.hasMem.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.setLike.{u2} R _inst_2)) (SMul.smul.{u1, u2} M R (SMulZeroClass.toHasSmul.{u1, u2} M R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_2))))))) (DistribSMul.toSmulZeroClass.{u1, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_2)))))) (DistribMulAction.toDistribSMul.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_2))))) (MulSemiringAction.toDistribMulAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Ring.toSemiring.{u2} R _inst_2) _inst_3)))) a x) (SMul.smul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toHasSmul.{u1, u2} M (Subring.{u2} R _inst_2) (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Subring.pointwiseMulAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) _inst_2 _inst_3)) a S)) (Membership.Mem.{u2, u2} R (Subring.{u2} R _inst_2) (SetLike.hasMem.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.setLike.{u2} R _inst_2)) x S)
but is expected to have type
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : Group.{u1} M] [_inst_2 : Ring.{u2} R] [_inst_3 : MulSemiringAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Ring.toSemiring.{u2} R _inst_2)] {a : M} {S : Subring.{u2} R _inst_2} {x : R}, Iff (Membership.mem.{u2, u2} R (Subring.{u2} R _inst_2) (SetLike.instMembership.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.instSetLikeSubring.{u2} R _inst_2)) (HSMul.hSMul.{u1, u2, u2} M R R (instHSMul.{u1, u2} M R (SMulZeroClass.toSMul.{u1, u2} M R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_2))) (DistribSMul.toSMulZeroClass.{u1, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (Ring.toAddGroupWithOne.{u2} R _inst_2)))) (DistribMulAction.toDistribSMul.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (AddMonoidWithOne.toAddMonoid.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (Ring.toAddGroupWithOne.{u2} R _inst_2))) (MulSemiringAction.toDistribMulAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Ring.toSemiring.{u2} R _inst_2) _inst_3))))) a x) (HSMul.hSMul.{u1, u2, u2} M (Subring.{u2} R _inst_2) (Subring.{u2} R _inst_2) (instHSMul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toSMul.{u1, u2} M (Subring.{u2} R _inst_2) (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Subring.pointwiseMulAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) _inst_2 _inst_3))) a S)) (Membership.mem.{u2, u2} R (Subring.{u2} R _inst_2) (SetLike.instMembership.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.instSetLikeSubring.{u2} R _inst_2)) x S)
Case conversion may be inaccurate. Consider using '#align subring.smul_mem_pointwise_smul_iff Subring.smul_mem_pointwise_smul_iffₓ'. -/
@[simp]
theorem smul_mem_pointwise_smul_iff {a : M} {S : Subring R} {x : R} : a • x ∈ a • S ↔ x ∈ S :=
  smul_mem_smul_set_iff
#align subring.smul_mem_pointwise_smul_iff Subring.smul_mem_pointwise_smul_iff

/- warning: subring.mem_pointwise_smul_iff_inv_smul_mem -> Subring.mem_pointwise_smul_iff_inv_smul_mem is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : Group.{u1} M] [_inst_2 : Ring.{u2} R] [_inst_3 : MulSemiringAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Ring.toSemiring.{u2} R _inst_2)] {a : M} {S : Subring.{u2} R _inst_2} {x : R}, Iff (Membership.Mem.{u2, u2} R (Subring.{u2} R _inst_2) (SetLike.hasMem.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.setLike.{u2} R _inst_2)) x (SMul.smul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toHasSmul.{u1, u2} M (Subring.{u2} R _inst_2) (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Subring.pointwiseMulAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) _inst_2 _inst_3)) a S)) (Membership.Mem.{u2, u2} R (Subring.{u2} R _inst_2) (SetLike.hasMem.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.setLike.{u2} R _inst_2)) (SMul.smul.{u1, u2} M R (SMulZeroClass.toHasSmul.{u1, u2} M R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_2))))))) (DistribSMul.toSmulZeroClass.{u1, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_2)))))) (DistribMulAction.toDistribSMul.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_2))))) (MulSemiringAction.toDistribMulAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Ring.toSemiring.{u2} R _inst_2) _inst_3)))) (Inv.inv.{u1} M (DivInvMonoid.toHasInv.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) a) x) S)
but is expected to have type
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : Group.{u1} M] [_inst_2 : Ring.{u2} R] [_inst_3 : MulSemiringAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Ring.toSemiring.{u2} R _inst_2)] {a : M} {S : Subring.{u2} R _inst_2} {x : R}, Iff (Membership.mem.{u2, u2} R (Subring.{u2} R _inst_2) (SetLike.instMembership.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.instSetLikeSubring.{u2} R _inst_2)) x (HSMul.hSMul.{u1, u2, u2} M (Subring.{u2} R _inst_2) (Subring.{u2} R _inst_2) (instHSMul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toSMul.{u1, u2} M (Subring.{u2} R _inst_2) (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Subring.pointwiseMulAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) _inst_2 _inst_3))) a S)) (Membership.mem.{u2, u2} R (Subring.{u2} R _inst_2) (SetLike.instMembership.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.instSetLikeSubring.{u2} R _inst_2)) (HSMul.hSMul.{u1, u2, u2} M R R (instHSMul.{u1, u2} M R (SMulZeroClass.toSMul.{u1, u2} M R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_2))) (DistribSMul.toSMulZeroClass.{u1, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (Ring.toAddGroupWithOne.{u2} R _inst_2)))) (DistribMulAction.toDistribSMul.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (AddMonoidWithOne.toAddMonoid.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (Ring.toAddGroupWithOne.{u2} R _inst_2))) (MulSemiringAction.toDistribMulAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Ring.toSemiring.{u2} R _inst_2) _inst_3))))) (Inv.inv.{u1} M (InvOneClass.toInv.{u1} M (DivInvOneMonoid.toInvOneClass.{u1} M (DivisionMonoid.toDivInvOneMonoid.{u1} M (Group.toDivisionMonoid.{u1} M _inst_1)))) a) x) S)
Case conversion may be inaccurate. Consider using '#align subring.mem_pointwise_smul_iff_inv_smul_mem Subring.mem_pointwise_smul_iff_inv_smul_memₓ'. -/
theorem mem_pointwise_smul_iff_inv_smul_mem {a : M} {S : Subring R} {x : R} :
    x ∈ a • S ↔ a⁻¹ • x ∈ S :=
  mem_smul_set_iff_inv_smul_mem
#align subring.mem_pointwise_smul_iff_inv_smul_mem Subring.mem_pointwise_smul_iff_inv_smul_mem

/- warning: subring.mem_inv_pointwise_smul_iff -> Subring.mem_inv_pointwise_smul_iff is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : Group.{u1} M] [_inst_2 : Ring.{u2} R] [_inst_3 : MulSemiringAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Ring.toSemiring.{u2} R _inst_2)] {a : M} {S : Subring.{u2} R _inst_2} {x : R}, Iff (Membership.Mem.{u2, u2} R (Subring.{u2} R _inst_2) (SetLike.hasMem.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.setLike.{u2} R _inst_2)) x (SMul.smul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toHasSmul.{u1, u2} M (Subring.{u2} R _inst_2) (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Subring.pointwiseMulAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) _inst_2 _inst_3)) (Inv.inv.{u1} M (DivInvMonoid.toHasInv.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) a) S)) (Membership.Mem.{u2, u2} R (Subring.{u2} R _inst_2) (SetLike.hasMem.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.setLike.{u2} R _inst_2)) (SMul.smul.{u1, u2} M R (SMulZeroClass.toHasSmul.{u1, u2} M R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_2))))))) (DistribSMul.toSmulZeroClass.{u1, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_2)))))) (DistribMulAction.toDistribSMul.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_2))))) (MulSemiringAction.toDistribMulAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Ring.toSemiring.{u2} R _inst_2) _inst_3)))) a x) S)
but is expected to have type
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : Group.{u1} M] [_inst_2 : Ring.{u2} R] [_inst_3 : MulSemiringAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Ring.toSemiring.{u2} R _inst_2)] {a : M} {S : Subring.{u2} R _inst_2} {x : R}, Iff (Membership.mem.{u2, u2} R (Subring.{u2} R _inst_2) (SetLike.instMembership.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.instSetLikeSubring.{u2} R _inst_2)) x (HSMul.hSMul.{u1, u2, u2} M (Subring.{u2} R _inst_2) (Subring.{u2} R _inst_2) (instHSMul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toSMul.{u1, u2} M (Subring.{u2} R _inst_2) (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Subring.pointwiseMulAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) _inst_2 _inst_3))) (Inv.inv.{u1} M (InvOneClass.toInv.{u1} M (DivInvOneMonoid.toInvOneClass.{u1} M (DivisionMonoid.toDivInvOneMonoid.{u1} M (Group.toDivisionMonoid.{u1} M _inst_1)))) a) S)) (Membership.mem.{u2, u2} R (Subring.{u2} R _inst_2) (SetLike.instMembership.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.instSetLikeSubring.{u2} R _inst_2)) (HSMul.hSMul.{u1, u2, u2} M R R (instHSMul.{u1, u2} M R (SMulZeroClass.toSMul.{u1, u2} M R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_2))) (DistribSMul.toSMulZeroClass.{u1, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (Ring.toAddGroupWithOne.{u2} R _inst_2)))) (DistribMulAction.toDistribSMul.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (AddMonoidWithOne.toAddMonoid.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (Ring.toAddGroupWithOne.{u2} R _inst_2))) (MulSemiringAction.toDistribMulAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Ring.toSemiring.{u2} R _inst_2) _inst_3))))) a x) S)
Case conversion may be inaccurate. Consider using '#align subring.mem_inv_pointwise_smul_iff Subring.mem_inv_pointwise_smul_iffₓ'. -/
theorem mem_inv_pointwise_smul_iff {a : M} {S : Subring R} {x : R} : x ∈ a⁻¹ • S ↔ a • x ∈ S :=
  mem_inv_smul_set_iff
#align subring.mem_inv_pointwise_smul_iff Subring.mem_inv_pointwise_smul_iff

/- warning: subring.pointwise_smul_le_pointwise_smul_iff -> Subring.pointwise_smul_le_pointwise_smul_iff is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : Group.{u1} M] [_inst_2 : Ring.{u2} R] [_inst_3 : MulSemiringAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Ring.toSemiring.{u2} R _inst_2)] {a : M} {S : Subring.{u2} R _inst_2} {T : Subring.{u2} R _inst_2}, Iff (LE.le.{u2} (Subring.{u2} R _inst_2) (Preorder.toLE.{u2} (Subring.{u2} R _inst_2) (PartialOrder.toPreorder.{u2} (Subring.{u2} R _inst_2) (SetLike.partialOrder.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.setLike.{u2} R _inst_2)))) (SMul.smul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toHasSmul.{u1, u2} M (Subring.{u2} R _inst_2) (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Subring.pointwiseMulAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) _inst_2 _inst_3)) a S) (SMul.smul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toHasSmul.{u1, u2} M (Subring.{u2} R _inst_2) (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Subring.pointwiseMulAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) _inst_2 _inst_3)) a T)) (LE.le.{u2} (Subring.{u2} R _inst_2) (Preorder.toLE.{u2} (Subring.{u2} R _inst_2) (PartialOrder.toPreorder.{u2} (Subring.{u2} R _inst_2) (SetLike.partialOrder.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.setLike.{u2} R _inst_2)))) S T)
but is expected to have type
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : Group.{u1} M] [_inst_2 : Ring.{u2} R] [_inst_3 : MulSemiringAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Ring.toSemiring.{u2} R _inst_2)] {a : M} {S : Subring.{u2} R _inst_2} {T : Subring.{u2} R _inst_2}, Iff (LE.le.{u2} (Subring.{u2} R _inst_2) (Preorder.toLE.{u2} (Subring.{u2} R _inst_2) (PartialOrder.toPreorder.{u2} (Subring.{u2} R _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subring.{u2} R _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subring.{u2} R _inst_2) (Subring.instCompleteLatticeSubring.{u2} R _inst_2))))) (HSMul.hSMul.{u1, u2, u2} M (Subring.{u2} R _inst_2) (Subring.{u2} R _inst_2) (instHSMul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toSMul.{u1, u2} M (Subring.{u2} R _inst_2) (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Subring.pointwiseMulAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) _inst_2 _inst_3))) a S) (HSMul.hSMul.{u1, u2, u2} M (Subring.{u2} R _inst_2) (Subring.{u2} R _inst_2) (instHSMul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toSMul.{u1, u2} M (Subring.{u2} R _inst_2) (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Subring.pointwiseMulAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) _inst_2 _inst_3))) a T)) (LE.le.{u2} (Subring.{u2} R _inst_2) (Preorder.toLE.{u2} (Subring.{u2} R _inst_2) (PartialOrder.toPreorder.{u2} (Subring.{u2} R _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subring.{u2} R _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subring.{u2} R _inst_2) (Subring.instCompleteLatticeSubring.{u2} R _inst_2))))) S T)
Case conversion may be inaccurate. Consider using '#align subring.pointwise_smul_le_pointwise_smul_iff Subring.pointwise_smul_le_pointwise_smul_iffₓ'. -/
@[simp]
theorem pointwise_smul_le_pointwise_smul_iff {a : M} {S T : Subring R} : a • S ≤ a • T ↔ S ≤ T :=
  set_smul_subset_set_smul_iff
#align subring.pointwise_smul_le_pointwise_smul_iff Subring.pointwise_smul_le_pointwise_smul_iff

/- warning: subring.pointwise_smul_subset_iff -> Subring.pointwise_smul_subset_iff is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : Group.{u1} M] [_inst_2 : Ring.{u2} R] [_inst_3 : MulSemiringAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Ring.toSemiring.{u2} R _inst_2)] {a : M} {S : Subring.{u2} R _inst_2} {T : Subring.{u2} R _inst_2}, Iff (LE.le.{u2} (Subring.{u2} R _inst_2) (Preorder.toLE.{u2} (Subring.{u2} R _inst_2) (PartialOrder.toPreorder.{u2} (Subring.{u2} R _inst_2) (SetLike.partialOrder.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.setLike.{u2} R _inst_2)))) (SMul.smul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toHasSmul.{u1, u2} M (Subring.{u2} R _inst_2) (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Subring.pointwiseMulAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) _inst_2 _inst_3)) a S) T) (LE.le.{u2} (Subring.{u2} R _inst_2) (Preorder.toLE.{u2} (Subring.{u2} R _inst_2) (PartialOrder.toPreorder.{u2} (Subring.{u2} R _inst_2) (SetLike.partialOrder.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.setLike.{u2} R _inst_2)))) S (SMul.smul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toHasSmul.{u1, u2} M (Subring.{u2} R _inst_2) (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Subring.pointwiseMulAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) _inst_2 _inst_3)) (Inv.inv.{u1} M (DivInvMonoid.toHasInv.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) a) T))
but is expected to have type
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : Group.{u1} M] [_inst_2 : Ring.{u2} R] [_inst_3 : MulSemiringAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Ring.toSemiring.{u2} R _inst_2)] {a : M} {S : Subring.{u2} R _inst_2} {T : Subring.{u2} R _inst_2}, Iff (LE.le.{u2} (Subring.{u2} R _inst_2) (Preorder.toLE.{u2} (Subring.{u2} R _inst_2) (PartialOrder.toPreorder.{u2} (Subring.{u2} R _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subring.{u2} R _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subring.{u2} R _inst_2) (Subring.instCompleteLatticeSubring.{u2} R _inst_2))))) (HSMul.hSMul.{u1, u2, u2} M (Subring.{u2} R _inst_2) (Subring.{u2} R _inst_2) (instHSMul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toSMul.{u1, u2} M (Subring.{u2} R _inst_2) (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Subring.pointwiseMulAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) _inst_2 _inst_3))) a S) T) (LE.le.{u2} (Subring.{u2} R _inst_2) (Preorder.toLE.{u2} (Subring.{u2} R _inst_2) (PartialOrder.toPreorder.{u2} (Subring.{u2} R _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subring.{u2} R _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subring.{u2} R _inst_2) (Subring.instCompleteLatticeSubring.{u2} R _inst_2))))) S (HSMul.hSMul.{u1, u2, u2} M (Subring.{u2} R _inst_2) (Subring.{u2} R _inst_2) (instHSMul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toSMul.{u1, u2} M (Subring.{u2} R _inst_2) (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Subring.pointwiseMulAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) _inst_2 _inst_3))) (Inv.inv.{u1} M (InvOneClass.toInv.{u1} M (DivInvOneMonoid.toInvOneClass.{u1} M (DivisionMonoid.toDivInvOneMonoid.{u1} M (Group.toDivisionMonoid.{u1} M _inst_1)))) a) T))
Case conversion may be inaccurate. Consider using '#align subring.pointwise_smul_subset_iff Subring.pointwise_smul_subset_iffₓ'. -/
theorem pointwise_smul_subset_iff {a : M} {S T : Subring R} : a • S ≤ T ↔ S ≤ a⁻¹ • T :=
  set_smul_subset_iff
#align subring.pointwise_smul_subset_iff Subring.pointwise_smul_subset_iff

/- warning: subring.subset_pointwise_smul_iff -> Subring.subset_pointwise_smul_iff is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : Group.{u1} M] [_inst_2 : Ring.{u2} R] [_inst_3 : MulSemiringAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Ring.toSemiring.{u2} R _inst_2)] {a : M} {S : Subring.{u2} R _inst_2} {T : Subring.{u2} R _inst_2}, Iff (LE.le.{u2} (Subring.{u2} R _inst_2) (Preorder.toLE.{u2} (Subring.{u2} R _inst_2) (PartialOrder.toPreorder.{u2} (Subring.{u2} R _inst_2) (SetLike.partialOrder.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.setLike.{u2} R _inst_2)))) S (SMul.smul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toHasSmul.{u1, u2} M (Subring.{u2} R _inst_2) (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Subring.pointwiseMulAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) _inst_2 _inst_3)) a T)) (LE.le.{u2} (Subring.{u2} R _inst_2) (Preorder.toLE.{u2} (Subring.{u2} R _inst_2) (PartialOrder.toPreorder.{u2} (Subring.{u2} R _inst_2) (SetLike.partialOrder.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.setLike.{u2} R _inst_2)))) (SMul.smul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toHasSmul.{u1, u2} M (Subring.{u2} R _inst_2) (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Subring.pointwiseMulAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) _inst_2 _inst_3)) (Inv.inv.{u1} M (DivInvMonoid.toHasInv.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) a) S) T)
but is expected to have type
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : Group.{u1} M] [_inst_2 : Ring.{u2} R] [_inst_3 : MulSemiringAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Ring.toSemiring.{u2} R _inst_2)] {a : M} {S : Subring.{u2} R _inst_2} {T : Subring.{u2} R _inst_2}, Iff (LE.le.{u2} (Subring.{u2} R _inst_2) (Preorder.toLE.{u2} (Subring.{u2} R _inst_2) (PartialOrder.toPreorder.{u2} (Subring.{u2} R _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subring.{u2} R _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subring.{u2} R _inst_2) (Subring.instCompleteLatticeSubring.{u2} R _inst_2))))) S (HSMul.hSMul.{u1, u2, u2} M (Subring.{u2} R _inst_2) (Subring.{u2} R _inst_2) (instHSMul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toSMul.{u1, u2} M (Subring.{u2} R _inst_2) (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Subring.pointwiseMulAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) _inst_2 _inst_3))) a T)) (LE.le.{u2} (Subring.{u2} R _inst_2) (Preorder.toLE.{u2} (Subring.{u2} R _inst_2) (PartialOrder.toPreorder.{u2} (Subring.{u2} R _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subring.{u2} R _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subring.{u2} R _inst_2) (Subring.instCompleteLatticeSubring.{u2} R _inst_2))))) (HSMul.hSMul.{u1, u2, u2} M (Subring.{u2} R _inst_2) (Subring.{u2} R _inst_2) (instHSMul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toSMul.{u1, u2} M (Subring.{u2} R _inst_2) (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) (Subring.pointwiseMulAction.{u1, u2} M R (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)) _inst_2 _inst_3))) (Inv.inv.{u1} M (InvOneClass.toInv.{u1} M (DivInvOneMonoid.toInvOneClass.{u1} M (DivisionMonoid.toDivInvOneMonoid.{u1} M (Group.toDivisionMonoid.{u1} M _inst_1)))) a) S) T)
Case conversion may be inaccurate. Consider using '#align subring.subset_pointwise_smul_iff Subring.subset_pointwise_smul_iffₓ'. -/
theorem subset_pointwise_smul_iff {a : M} {S T : Subring R} : S ≤ a • T ↔ a⁻¹ • S ≤ T :=
  subset_set_smul_iff
#align subring.subset_pointwise_smul_iff Subring.subset_pointwise_smul_iff

/-! TODO: add `equiv_smul` like we have for subgroup. -/


end Group

section GroupWithZero

variable [GroupWithZero M] [Ring R] [MulSemiringAction M R]

open Pointwise

/- warning: subring.smul_mem_pointwise_smul_iff₀ -> Subring.smul_mem_pointwise_smul_iff₀ is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : GroupWithZero.{u1} M] [_inst_2 : Ring.{u2} R] [_inst_3 : MulSemiringAction.{u1, u2} M R (MonoidWithZero.toMonoid.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)) (Ring.toSemiring.{u2} R _inst_2)] {a : M}, (Ne.{succ u1} M a (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)))))))) -> (forall (S : Subring.{u2} R _inst_2) (x : R), Iff (Membership.Mem.{u2, u2} R (Subring.{u2} R _inst_2) (SetLike.hasMem.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.setLike.{u2} R _inst_2)) (SMul.smul.{u1, u2} M R (SMulZeroClass.toHasSmul.{u1, u2} M R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_2))))))) (DistribSMul.toSmulZeroClass.{u1, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_2)))))) (DistribMulAction.toDistribSMul.{u1, u2} M R (MonoidWithZero.toMonoid.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)) (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_2))))) (MulSemiringAction.toDistribMulAction.{u1, u2} M R (MonoidWithZero.toMonoid.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)) (Ring.toSemiring.{u2} R _inst_2) _inst_3)))) a x) (SMul.smul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toHasSmul.{u1, u2} M (Subring.{u2} R _inst_2) (MonoidWithZero.toMonoid.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)) (Subring.pointwiseMulAction.{u1, u2} M R (MonoidWithZero.toMonoid.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)) _inst_2 _inst_3)) a S)) (Membership.Mem.{u2, u2} R (Subring.{u2} R _inst_2) (SetLike.hasMem.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.setLike.{u2} R _inst_2)) x S))
but is expected to have type
  forall {M : Type.{u2}} {R : Type.{u1}} [_inst_1 : GroupWithZero.{u2} M] [_inst_2 : Ring.{u1} R] [_inst_3 : MulSemiringAction.{u2, u1} M R (MonoidWithZero.toMonoid.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1)) (Ring.toSemiring.{u1} R _inst_2)] {a : M}, (Ne.{succ u2} M a (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (MonoidWithZero.toZero.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1))))) -> (forall (S : Subring.{u1} R _inst_2) (x : R), Iff (Membership.mem.{u1, u1} R (Subring.{u1} R _inst_2) (SetLike.instMembership.{u1, u1} (Subring.{u1} R _inst_2) R (Subring.instSetLikeSubring.{u1} R _inst_2)) (HSMul.hSMul.{u2, u1, u1} M R R (instHSMul.{u2, u1} M R (SMulZeroClass.toSMul.{u2, u1} M R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_2))) (DistribSMul.toSMulZeroClass.{u2, u1} M R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (Ring.toAddGroupWithOne.{u1} R _inst_2)))) (DistribMulAction.toDistribSMul.{u2, u1} M R (MonoidWithZero.toMonoid.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1)) (AddMonoidWithOne.toAddMonoid.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (Ring.toAddGroupWithOne.{u1} R _inst_2))) (MulSemiringAction.toDistribMulAction.{u2, u1} M R (MonoidWithZero.toMonoid.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1)) (Ring.toSemiring.{u1} R _inst_2) _inst_3))))) a x) (HSMul.hSMul.{u2, u1, u1} M (Subring.{u1} R _inst_2) (Subring.{u1} R _inst_2) (instHSMul.{u2, u1} M (Subring.{u1} R _inst_2) (MulAction.toSMul.{u2, u1} M (Subring.{u1} R _inst_2) (MonoidWithZero.toMonoid.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1)) (Subring.pointwiseMulAction.{u2, u1} M R (MonoidWithZero.toMonoid.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1)) _inst_2 _inst_3))) a S)) (Membership.mem.{u1, u1} R (Subring.{u1} R _inst_2) (SetLike.instMembership.{u1, u1} (Subring.{u1} R _inst_2) R (Subring.instSetLikeSubring.{u1} R _inst_2)) x S))
Case conversion may be inaccurate. Consider using '#align subring.smul_mem_pointwise_smul_iff₀ Subring.smul_mem_pointwise_smul_iff₀ₓ'. -/
@[simp]
theorem smul_mem_pointwise_smul_iff₀ {a : M} (ha : a ≠ 0) (S : Subring R) (x : R) :
    a • x ∈ a • S ↔ x ∈ S :=
  smul_mem_smul_set_iff₀ ha (S : Set R) x
#align subring.smul_mem_pointwise_smul_iff₀ Subring.smul_mem_pointwise_smul_iff₀

/- warning: subring.mem_pointwise_smul_iff_inv_smul_mem₀ -> Subring.mem_pointwise_smul_iff_inv_smul_mem₀ is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : GroupWithZero.{u1} M] [_inst_2 : Ring.{u2} R] [_inst_3 : MulSemiringAction.{u1, u2} M R (MonoidWithZero.toMonoid.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)) (Ring.toSemiring.{u2} R _inst_2)] {a : M}, (Ne.{succ u1} M a (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)))))))) -> (forall (S : Subring.{u2} R _inst_2) (x : R), Iff (Membership.Mem.{u2, u2} R (Subring.{u2} R _inst_2) (SetLike.hasMem.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.setLike.{u2} R _inst_2)) x (SMul.smul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toHasSmul.{u1, u2} M (Subring.{u2} R _inst_2) (MonoidWithZero.toMonoid.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)) (Subring.pointwiseMulAction.{u1, u2} M R (MonoidWithZero.toMonoid.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)) _inst_2 _inst_3)) a S)) (Membership.Mem.{u2, u2} R (Subring.{u2} R _inst_2) (SetLike.hasMem.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.setLike.{u2} R _inst_2)) (SMul.smul.{u1, u2} M R (SMulZeroClass.toHasSmul.{u1, u2} M R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_2))))))) (DistribSMul.toSmulZeroClass.{u1, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_2)))))) (DistribMulAction.toDistribSMul.{u1, u2} M R (MonoidWithZero.toMonoid.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)) (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_2))))) (MulSemiringAction.toDistribMulAction.{u1, u2} M R (MonoidWithZero.toMonoid.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)) (Ring.toSemiring.{u2} R _inst_2) _inst_3)))) (Inv.inv.{u1} M (DivInvMonoid.toHasInv.{u1} M (GroupWithZero.toDivInvMonoid.{u1} M _inst_1)) a) x) S))
but is expected to have type
  forall {M : Type.{u2}} {R : Type.{u1}} [_inst_1 : GroupWithZero.{u2} M] [_inst_2 : Ring.{u1} R] [_inst_3 : MulSemiringAction.{u2, u1} M R (MonoidWithZero.toMonoid.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1)) (Ring.toSemiring.{u1} R _inst_2)] {a : M}, (Ne.{succ u2} M a (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (MonoidWithZero.toZero.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1))))) -> (forall (S : Subring.{u1} R _inst_2) (x : R), Iff (Membership.mem.{u1, u1} R (Subring.{u1} R _inst_2) (SetLike.instMembership.{u1, u1} (Subring.{u1} R _inst_2) R (Subring.instSetLikeSubring.{u1} R _inst_2)) x (HSMul.hSMul.{u2, u1, u1} M (Subring.{u1} R _inst_2) (Subring.{u1} R _inst_2) (instHSMul.{u2, u1} M (Subring.{u1} R _inst_2) (MulAction.toSMul.{u2, u1} M (Subring.{u1} R _inst_2) (MonoidWithZero.toMonoid.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1)) (Subring.pointwiseMulAction.{u2, u1} M R (MonoidWithZero.toMonoid.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1)) _inst_2 _inst_3))) a S)) (Membership.mem.{u1, u1} R (Subring.{u1} R _inst_2) (SetLike.instMembership.{u1, u1} (Subring.{u1} R _inst_2) R (Subring.instSetLikeSubring.{u1} R _inst_2)) (HSMul.hSMul.{u2, u1, u1} M R R (instHSMul.{u2, u1} M R (SMulZeroClass.toSMul.{u2, u1} M R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_2))) (DistribSMul.toSMulZeroClass.{u2, u1} M R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (Ring.toAddGroupWithOne.{u1} R _inst_2)))) (DistribMulAction.toDistribSMul.{u2, u1} M R (MonoidWithZero.toMonoid.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1)) (AddMonoidWithOne.toAddMonoid.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (Ring.toAddGroupWithOne.{u1} R _inst_2))) (MulSemiringAction.toDistribMulAction.{u2, u1} M R (MonoidWithZero.toMonoid.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1)) (Ring.toSemiring.{u1} R _inst_2) _inst_3))))) (Inv.inv.{u2} M (GroupWithZero.toInv.{u2} M _inst_1) a) x) S))
Case conversion may be inaccurate. Consider using '#align subring.mem_pointwise_smul_iff_inv_smul_mem₀ Subring.mem_pointwise_smul_iff_inv_smul_mem₀ₓ'. -/
theorem mem_pointwise_smul_iff_inv_smul_mem₀ {a : M} (ha : a ≠ 0) (S : Subring R) (x : R) :
    x ∈ a • S ↔ a⁻¹ • x ∈ S :=
  mem_smul_set_iff_inv_smul_mem₀ ha (S : Set R) x
#align subring.mem_pointwise_smul_iff_inv_smul_mem₀ Subring.mem_pointwise_smul_iff_inv_smul_mem₀

/- warning: subring.mem_inv_pointwise_smul_iff₀ -> Subring.mem_inv_pointwise_smul_iff₀ is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : GroupWithZero.{u1} M] [_inst_2 : Ring.{u2} R] [_inst_3 : MulSemiringAction.{u1, u2} M R (MonoidWithZero.toMonoid.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)) (Ring.toSemiring.{u2} R _inst_2)] {a : M}, (Ne.{succ u1} M a (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)))))))) -> (forall (S : Subring.{u2} R _inst_2) (x : R), Iff (Membership.Mem.{u2, u2} R (Subring.{u2} R _inst_2) (SetLike.hasMem.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.setLike.{u2} R _inst_2)) x (SMul.smul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toHasSmul.{u1, u2} M (Subring.{u2} R _inst_2) (MonoidWithZero.toMonoid.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)) (Subring.pointwiseMulAction.{u1, u2} M R (MonoidWithZero.toMonoid.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)) _inst_2 _inst_3)) (Inv.inv.{u1} M (DivInvMonoid.toHasInv.{u1} M (GroupWithZero.toDivInvMonoid.{u1} M _inst_1)) a) S)) (Membership.Mem.{u2, u2} R (Subring.{u2} R _inst_2) (SetLike.hasMem.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.setLike.{u2} R _inst_2)) (SMul.smul.{u1, u2} M R (SMulZeroClass.toHasSmul.{u1, u2} M R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_2))))))) (DistribSMul.toSmulZeroClass.{u1, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_2)))))) (DistribMulAction.toDistribSMul.{u1, u2} M R (MonoidWithZero.toMonoid.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)) (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_2))))) (MulSemiringAction.toDistribMulAction.{u1, u2} M R (MonoidWithZero.toMonoid.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)) (Ring.toSemiring.{u2} R _inst_2) _inst_3)))) a x) S))
but is expected to have type
  forall {M : Type.{u2}} {R : Type.{u1}} [_inst_1 : GroupWithZero.{u2} M] [_inst_2 : Ring.{u1} R] [_inst_3 : MulSemiringAction.{u2, u1} M R (MonoidWithZero.toMonoid.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1)) (Ring.toSemiring.{u1} R _inst_2)] {a : M}, (Ne.{succ u2} M a (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (MonoidWithZero.toZero.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1))))) -> (forall (S : Subring.{u1} R _inst_2) (x : R), Iff (Membership.mem.{u1, u1} R (Subring.{u1} R _inst_2) (SetLike.instMembership.{u1, u1} (Subring.{u1} R _inst_2) R (Subring.instSetLikeSubring.{u1} R _inst_2)) x (HSMul.hSMul.{u2, u1, u1} M (Subring.{u1} R _inst_2) (Subring.{u1} R _inst_2) (instHSMul.{u2, u1} M (Subring.{u1} R _inst_2) (MulAction.toSMul.{u2, u1} M (Subring.{u1} R _inst_2) (MonoidWithZero.toMonoid.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1)) (Subring.pointwiseMulAction.{u2, u1} M R (MonoidWithZero.toMonoid.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1)) _inst_2 _inst_3))) (Inv.inv.{u2} M (GroupWithZero.toInv.{u2} M _inst_1) a) S)) (Membership.mem.{u1, u1} R (Subring.{u1} R _inst_2) (SetLike.instMembership.{u1, u1} (Subring.{u1} R _inst_2) R (Subring.instSetLikeSubring.{u1} R _inst_2)) (HSMul.hSMul.{u2, u1, u1} M R R (instHSMul.{u2, u1} M R (SMulZeroClass.toSMul.{u2, u1} M R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_2))) (DistribSMul.toSMulZeroClass.{u2, u1} M R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (Ring.toAddGroupWithOne.{u1} R _inst_2)))) (DistribMulAction.toDistribSMul.{u2, u1} M R (MonoidWithZero.toMonoid.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1)) (AddMonoidWithOne.toAddMonoid.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (Ring.toAddGroupWithOne.{u1} R _inst_2))) (MulSemiringAction.toDistribMulAction.{u2, u1} M R (MonoidWithZero.toMonoid.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1)) (Ring.toSemiring.{u1} R _inst_2) _inst_3))))) a x) S))
Case conversion may be inaccurate. Consider using '#align subring.mem_inv_pointwise_smul_iff₀ Subring.mem_inv_pointwise_smul_iff₀ₓ'. -/
theorem mem_inv_pointwise_smul_iff₀ {a : M} (ha : a ≠ 0) (S : Subring R) (x : R) :
    x ∈ a⁻¹ • S ↔ a • x ∈ S :=
  mem_inv_smul_set_iff₀ ha (S : Set R) x
#align subring.mem_inv_pointwise_smul_iff₀ Subring.mem_inv_pointwise_smul_iff₀

/- warning: subring.pointwise_smul_le_pointwise_smul_iff₀ -> Subring.pointwise_smul_le_pointwise_smul_iff₀ is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : GroupWithZero.{u1} M] [_inst_2 : Ring.{u2} R] [_inst_3 : MulSemiringAction.{u1, u2} M R (MonoidWithZero.toMonoid.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)) (Ring.toSemiring.{u2} R _inst_2)] {a : M}, (Ne.{succ u1} M a (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)))))))) -> (forall {S : Subring.{u2} R _inst_2} {T : Subring.{u2} R _inst_2}, Iff (LE.le.{u2} (Subring.{u2} R _inst_2) (Preorder.toLE.{u2} (Subring.{u2} R _inst_2) (PartialOrder.toPreorder.{u2} (Subring.{u2} R _inst_2) (SetLike.partialOrder.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.setLike.{u2} R _inst_2)))) (SMul.smul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toHasSmul.{u1, u2} M (Subring.{u2} R _inst_2) (MonoidWithZero.toMonoid.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)) (Subring.pointwiseMulAction.{u1, u2} M R (MonoidWithZero.toMonoid.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)) _inst_2 _inst_3)) a S) (SMul.smul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toHasSmul.{u1, u2} M (Subring.{u2} R _inst_2) (MonoidWithZero.toMonoid.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)) (Subring.pointwiseMulAction.{u1, u2} M R (MonoidWithZero.toMonoid.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)) _inst_2 _inst_3)) a T)) (LE.le.{u2} (Subring.{u2} R _inst_2) (Preorder.toLE.{u2} (Subring.{u2} R _inst_2) (PartialOrder.toPreorder.{u2} (Subring.{u2} R _inst_2) (SetLike.partialOrder.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.setLike.{u2} R _inst_2)))) S T))
but is expected to have type
  forall {M : Type.{u2}} {R : Type.{u1}} [_inst_1 : GroupWithZero.{u2} M] [_inst_2 : Ring.{u1} R] [_inst_3 : MulSemiringAction.{u2, u1} M R (MonoidWithZero.toMonoid.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1)) (Ring.toSemiring.{u1} R _inst_2)] {a : M}, (Ne.{succ u2} M a (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (MonoidWithZero.toZero.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1))))) -> (forall {S : Subring.{u1} R _inst_2} {T : Subring.{u1} R _inst_2}, Iff (LE.le.{u1} (Subring.{u1} R _inst_2) (Preorder.toLE.{u1} (Subring.{u1} R _inst_2) (PartialOrder.toPreorder.{u1} (Subring.{u1} R _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subring.{u1} R _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subring.{u1} R _inst_2) (Subring.instCompleteLatticeSubring.{u1} R _inst_2))))) (HSMul.hSMul.{u2, u1, u1} M (Subring.{u1} R _inst_2) (Subring.{u1} R _inst_2) (instHSMul.{u2, u1} M (Subring.{u1} R _inst_2) (MulAction.toSMul.{u2, u1} M (Subring.{u1} R _inst_2) (MonoidWithZero.toMonoid.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1)) (Subring.pointwiseMulAction.{u2, u1} M R (MonoidWithZero.toMonoid.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1)) _inst_2 _inst_3))) a S) (HSMul.hSMul.{u2, u1, u1} M (Subring.{u1} R _inst_2) (Subring.{u1} R _inst_2) (instHSMul.{u2, u1} M (Subring.{u1} R _inst_2) (MulAction.toSMul.{u2, u1} M (Subring.{u1} R _inst_2) (MonoidWithZero.toMonoid.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1)) (Subring.pointwiseMulAction.{u2, u1} M R (MonoidWithZero.toMonoid.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1)) _inst_2 _inst_3))) a T)) (LE.le.{u1} (Subring.{u1} R _inst_2) (Preorder.toLE.{u1} (Subring.{u1} R _inst_2) (PartialOrder.toPreorder.{u1} (Subring.{u1} R _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subring.{u1} R _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subring.{u1} R _inst_2) (Subring.instCompleteLatticeSubring.{u1} R _inst_2))))) S T))
Case conversion may be inaccurate. Consider using '#align subring.pointwise_smul_le_pointwise_smul_iff₀ Subring.pointwise_smul_le_pointwise_smul_iff₀ₓ'. -/
@[simp]
theorem pointwise_smul_le_pointwise_smul_iff₀ {a : M} (ha : a ≠ 0) {S T : Subring R} :
    a • S ≤ a • T ↔ S ≤ T :=
  set_smul_subset_set_smul_iff₀ ha
#align subring.pointwise_smul_le_pointwise_smul_iff₀ Subring.pointwise_smul_le_pointwise_smul_iff₀

/- warning: subring.pointwise_smul_le_iff₀ -> Subring.pointwise_smul_le_iff₀ is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : GroupWithZero.{u1} M] [_inst_2 : Ring.{u2} R] [_inst_3 : MulSemiringAction.{u1, u2} M R (MonoidWithZero.toMonoid.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)) (Ring.toSemiring.{u2} R _inst_2)] {a : M}, (Ne.{succ u1} M a (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)))))))) -> (forall {S : Subring.{u2} R _inst_2} {T : Subring.{u2} R _inst_2}, Iff (LE.le.{u2} (Subring.{u2} R _inst_2) (Preorder.toLE.{u2} (Subring.{u2} R _inst_2) (PartialOrder.toPreorder.{u2} (Subring.{u2} R _inst_2) (SetLike.partialOrder.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.setLike.{u2} R _inst_2)))) (SMul.smul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toHasSmul.{u1, u2} M (Subring.{u2} R _inst_2) (MonoidWithZero.toMonoid.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)) (Subring.pointwiseMulAction.{u1, u2} M R (MonoidWithZero.toMonoid.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)) _inst_2 _inst_3)) a S) T) (LE.le.{u2} (Subring.{u2} R _inst_2) (Preorder.toLE.{u2} (Subring.{u2} R _inst_2) (PartialOrder.toPreorder.{u2} (Subring.{u2} R _inst_2) (SetLike.partialOrder.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.setLike.{u2} R _inst_2)))) S (SMul.smul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toHasSmul.{u1, u2} M (Subring.{u2} R _inst_2) (MonoidWithZero.toMonoid.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)) (Subring.pointwiseMulAction.{u1, u2} M R (MonoidWithZero.toMonoid.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)) _inst_2 _inst_3)) (Inv.inv.{u1} M (DivInvMonoid.toHasInv.{u1} M (GroupWithZero.toDivInvMonoid.{u1} M _inst_1)) a) T)))
but is expected to have type
  forall {M : Type.{u2}} {R : Type.{u1}} [_inst_1 : GroupWithZero.{u2} M] [_inst_2 : Ring.{u1} R] [_inst_3 : MulSemiringAction.{u2, u1} M R (MonoidWithZero.toMonoid.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1)) (Ring.toSemiring.{u1} R _inst_2)] {a : M}, (Ne.{succ u2} M a (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (MonoidWithZero.toZero.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1))))) -> (forall {S : Subring.{u1} R _inst_2} {T : Subring.{u1} R _inst_2}, Iff (LE.le.{u1} (Subring.{u1} R _inst_2) (Preorder.toLE.{u1} (Subring.{u1} R _inst_2) (PartialOrder.toPreorder.{u1} (Subring.{u1} R _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subring.{u1} R _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subring.{u1} R _inst_2) (Subring.instCompleteLatticeSubring.{u1} R _inst_2))))) (HSMul.hSMul.{u2, u1, u1} M (Subring.{u1} R _inst_2) (Subring.{u1} R _inst_2) (instHSMul.{u2, u1} M (Subring.{u1} R _inst_2) (MulAction.toSMul.{u2, u1} M (Subring.{u1} R _inst_2) (MonoidWithZero.toMonoid.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1)) (Subring.pointwiseMulAction.{u2, u1} M R (MonoidWithZero.toMonoid.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1)) _inst_2 _inst_3))) a S) T) (LE.le.{u1} (Subring.{u1} R _inst_2) (Preorder.toLE.{u1} (Subring.{u1} R _inst_2) (PartialOrder.toPreorder.{u1} (Subring.{u1} R _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subring.{u1} R _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subring.{u1} R _inst_2) (Subring.instCompleteLatticeSubring.{u1} R _inst_2))))) S (HSMul.hSMul.{u2, u1, u1} M (Subring.{u1} R _inst_2) (Subring.{u1} R _inst_2) (instHSMul.{u2, u1} M (Subring.{u1} R _inst_2) (MulAction.toSMul.{u2, u1} M (Subring.{u1} R _inst_2) (MonoidWithZero.toMonoid.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1)) (Subring.pointwiseMulAction.{u2, u1} M R (MonoidWithZero.toMonoid.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1)) _inst_2 _inst_3))) (Inv.inv.{u2} M (GroupWithZero.toInv.{u2} M _inst_1) a) T)))
Case conversion may be inaccurate. Consider using '#align subring.pointwise_smul_le_iff₀ Subring.pointwise_smul_le_iff₀ₓ'. -/
theorem pointwise_smul_le_iff₀ {a : M} (ha : a ≠ 0) {S T : Subring R} : a • S ≤ T ↔ S ≤ a⁻¹ • T :=
  set_smul_subset_iff₀ ha
#align subring.pointwise_smul_le_iff₀ Subring.pointwise_smul_le_iff₀

/- warning: subring.le_pointwise_smul_iff₀ -> Subring.le_pointwise_smul_iff₀ is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : GroupWithZero.{u1} M] [_inst_2 : Ring.{u2} R] [_inst_3 : MulSemiringAction.{u1, u2} M R (MonoidWithZero.toMonoid.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)) (Ring.toSemiring.{u2} R _inst_2)] {a : M}, (Ne.{succ u1} M a (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)))))))) -> (forall {S : Subring.{u2} R _inst_2} {T : Subring.{u2} R _inst_2}, Iff (LE.le.{u2} (Subring.{u2} R _inst_2) (Preorder.toLE.{u2} (Subring.{u2} R _inst_2) (PartialOrder.toPreorder.{u2} (Subring.{u2} R _inst_2) (SetLike.partialOrder.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.setLike.{u2} R _inst_2)))) S (SMul.smul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toHasSmul.{u1, u2} M (Subring.{u2} R _inst_2) (MonoidWithZero.toMonoid.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)) (Subring.pointwiseMulAction.{u1, u2} M R (MonoidWithZero.toMonoid.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)) _inst_2 _inst_3)) a T)) (LE.le.{u2} (Subring.{u2} R _inst_2) (Preorder.toLE.{u2} (Subring.{u2} R _inst_2) (PartialOrder.toPreorder.{u2} (Subring.{u2} R _inst_2) (SetLike.partialOrder.{u2, u2} (Subring.{u2} R _inst_2) R (Subring.setLike.{u2} R _inst_2)))) (SMul.smul.{u1, u2} M (Subring.{u2} R _inst_2) (MulAction.toHasSmul.{u1, u2} M (Subring.{u2} R _inst_2) (MonoidWithZero.toMonoid.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)) (Subring.pointwiseMulAction.{u1, u2} M R (MonoidWithZero.toMonoid.{u1} M (GroupWithZero.toMonoidWithZero.{u1} M _inst_1)) _inst_2 _inst_3)) (Inv.inv.{u1} M (DivInvMonoid.toHasInv.{u1} M (GroupWithZero.toDivInvMonoid.{u1} M _inst_1)) a) S) T))
but is expected to have type
  forall {M : Type.{u2}} {R : Type.{u1}} [_inst_1 : GroupWithZero.{u2} M] [_inst_2 : Ring.{u1} R] [_inst_3 : MulSemiringAction.{u2, u1} M R (MonoidWithZero.toMonoid.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1)) (Ring.toSemiring.{u1} R _inst_2)] {a : M}, (Ne.{succ u2} M a (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (MonoidWithZero.toZero.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1))))) -> (forall {S : Subring.{u1} R _inst_2} {T : Subring.{u1} R _inst_2}, Iff (LE.le.{u1} (Subring.{u1} R _inst_2) (Preorder.toLE.{u1} (Subring.{u1} R _inst_2) (PartialOrder.toPreorder.{u1} (Subring.{u1} R _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subring.{u1} R _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subring.{u1} R _inst_2) (Subring.instCompleteLatticeSubring.{u1} R _inst_2))))) S (HSMul.hSMul.{u2, u1, u1} M (Subring.{u1} R _inst_2) (Subring.{u1} R _inst_2) (instHSMul.{u2, u1} M (Subring.{u1} R _inst_2) (MulAction.toSMul.{u2, u1} M (Subring.{u1} R _inst_2) (MonoidWithZero.toMonoid.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1)) (Subring.pointwiseMulAction.{u2, u1} M R (MonoidWithZero.toMonoid.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1)) _inst_2 _inst_3))) a T)) (LE.le.{u1} (Subring.{u1} R _inst_2) (Preorder.toLE.{u1} (Subring.{u1} R _inst_2) (PartialOrder.toPreorder.{u1} (Subring.{u1} R _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subring.{u1} R _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subring.{u1} R _inst_2) (Subring.instCompleteLatticeSubring.{u1} R _inst_2))))) (HSMul.hSMul.{u2, u1, u1} M (Subring.{u1} R _inst_2) (Subring.{u1} R _inst_2) (instHSMul.{u2, u1} M (Subring.{u1} R _inst_2) (MulAction.toSMul.{u2, u1} M (Subring.{u1} R _inst_2) (MonoidWithZero.toMonoid.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1)) (Subring.pointwiseMulAction.{u2, u1} M R (MonoidWithZero.toMonoid.{u2} M (GroupWithZero.toMonoidWithZero.{u2} M _inst_1)) _inst_2 _inst_3))) (Inv.inv.{u2} M (GroupWithZero.toInv.{u2} M _inst_1) a) S) T))
Case conversion may be inaccurate. Consider using '#align subring.le_pointwise_smul_iff₀ Subring.le_pointwise_smul_iff₀ₓ'. -/
theorem le_pointwise_smul_iff₀ {a : M} (ha : a ≠ 0) {S T : Subring R} : S ≤ a • T ↔ a⁻¹ • S ≤ T :=
  subset_set_smul_iff₀ ha
#align subring.le_pointwise_smul_iff₀ Subring.le_pointwise_smul_iff₀

end GroupWithZero

end Subring

