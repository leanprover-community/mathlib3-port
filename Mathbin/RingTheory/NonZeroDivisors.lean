/-
Copyright (c) 2020 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau, Devon Tuma

! This file was ported from Lean 3 source module ring_theory.non_zero_divisors
! leanprover-community/mathlib commit 32253a1a1071173b33dc7d6a218cf722c6feb514
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.GroupTheory.Submonoid.Operations
import Mathbin.GroupTheory.Submonoid.Membership

/-!
# Non-zero divisors

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file we define the submonoid `non_zero_divisors` of a `monoid_with_zero`.

## Notations

This file declares the notation `R⁰` for the submonoid of non-zero-divisors of `R`,
in the locale `non_zero_divisors`. Use the statement `open_locale non_zero_divisors`
to access this notation in your own code.

-/


section nonZeroDivisors

#print nonZeroDivisors /-
/-- The submonoid of non-zero-divisors of a `monoid_with_zero` `R`. -/
def nonZeroDivisors (R : Type _) [MonoidWithZero R] : Submonoid R
    where
  carrier := { x | ∀ z, z * x = 0 → z = 0 }
  one_mem' z hz := by rwa [mul_one] at hz
  mul_mem' x₁ x₂ hx₁ hx₂ z hz :=
    have : z * x₁ * x₂ = 0 := by rwa [mul_assoc]
    hx₁ z <| hx₂ (z * x₁) this
#align non_zero_divisors nonZeroDivisors
-/

-- mathport name: non_zero_divisors
scoped[nonZeroDivisors] notation:9000 R "⁰" => nonZeroDivisors R

variable {M M' M₁ R R' F : Type _} [MonoidWithZero M] [MonoidWithZero M'] [CommMonoidWithZero M₁]
  [Ring R] [CommRing R']

/- warning: mem_non_zero_divisors_iff -> mem_nonZeroDivisors_iff is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : MonoidWithZero.{u1} M] {r : M}, Iff (Membership.Mem.{u1, u1} M (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) M (Submonoid.setLike.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) r (nonZeroDivisors.{u1} M _inst_1)) (forall (x : M), (Eq.{succ u1} M (HMul.hMul.{u1, u1, u1} M M M (instHMul.{u1} M (MulZeroClass.toHasMul.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) x r) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))))))) -> (Eq.{succ u1} M x (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))))))))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : MonoidWithZero.{u1} M] {r : M}, Iff (Membership.mem.{u1, u1} M (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) M (Submonoid.instSetLikeSubmonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) r (nonZeroDivisors.{u1} M _inst_1)) (forall (x : M), (Eq.{succ u1} M (HMul.hMul.{u1, u1, u1} M M M (instHMul.{u1} M (MulZeroClass.toMul.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) x r) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (MonoidWithZero.toZero.{u1} M _inst_1)))) -> (Eq.{succ u1} M x (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (MonoidWithZero.toZero.{u1} M _inst_1)))))
Case conversion may be inaccurate. Consider using '#align mem_non_zero_divisors_iff mem_nonZeroDivisors_iffₓ'. -/
theorem mem_nonZeroDivisors_iff {r : M} : r ∈ M⁰ ↔ ∀ x, x * r = 0 → x = 0 :=
  Iff.rfl
#align mem_non_zero_divisors_iff mem_nonZeroDivisors_iff

/- warning: mul_right_mem_non_zero_divisors_eq_zero_iff -> mul_right_mem_nonZeroDivisors_eq_zero_iff is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : MonoidWithZero.{u1} M] {x : M} {r : M}, (Membership.Mem.{u1, u1} M (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) M (Submonoid.setLike.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) r (nonZeroDivisors.{u1} M _inst_1)) -> (Iff (Eq.{succ u1} M (HMul.hMul.{u1, u1, u1} M M M (instHMul.{u1} M (MulZeroClass.toHasMul.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) x r) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))))))) (Eq.{succ u1} M x (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))))))))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : MonoidWithZero.{u1} M] {x : M} {r : M}, (Membership.mem.{u1, u1} M (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) M (Submonoid.instSetLikeSubmonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) r (nonZeroDivisors.{u1} M _inst_1)) -> (Iff (Eq.{succ u1} M (HMul.hMul.{u1, u1, u1} M M M (instHMul.{u1} M (MulZeroClass.toMul.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) x r) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (MonoidWithZero.toZero.{u1} M _inst_1)))) (Eq.{succ u1} M x (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (MonoidWithZero.toZero.{u1} M _inst_1)))))
Case conversion may be inaccurate. Consider using '#align mul_right_mem_non_zero_divisors_eq_zero_iff mul_right_mem_nonZeroDivisors_eq_zero_iffₓ'. -/
theorem mul_right_mem_nonZeroDivisors_eq_zero_iff {x r : M} (hr : r ∈ M⁰) : x * r = 0 ↔ x = 0 :=
  ⟨hr _, by simp (config := { contextual := true })⟩
#align mul_right_mem_non_zero_divisors_eq_zero_iff mul_right_mem_nonZeroDivisors_eq_zero_iff

/- warning: mul_right_coe_non_zero_divisors_eq_zero_iff -> mul_right_coe_nonZeroDivisors_eq_zero_iff is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : MonoidWithZero.{u1} M] {x : M} {c : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) M (Submonoid.setLike.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) (nonZeroDivisors.{u1} M _inst_1)}, Iff (Eq.{succ u1} M (HMul.hMul.{u1, u1, u1} M M M (instHMul.{u1} M (MulZeroClass.toHasMul.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) M (Submonoid.setLike.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) (nonZeroDivisors.{u1} M _inst_1)) M (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) M (Submonoid.setLike.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) (nonZeroDivisors.{u1} M _inst_1)) M (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) M (Submonoid.setLike.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) (nonZeroDivisors.{u1} M _inst_1)) M (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) M (Submonoid.setLike.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) (nonZeroDivisors.{u1} M _inst_1)) M (coeSubtype.{succ u1} M (fun (x : M) => Membership.Mem.{u1, u1} M (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) M (Submonoid.setLike.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) x (nonZeroDivisors.{u1} M _inst_1)))))) c)) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))))))) (Eq.{succ u1} M x (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))))))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : MonoidWithZero.{u1} M] {x : M} {c : Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) M (Submonoid.instSetLikeSubmonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) x (nonZeroDivisors.{u1} M _inst_1))}, Iff (Eq.{succ u1} M (HMul.hMul.{u1, u1, u1} M M M (instHMul.{u1} M (MulZeroClass.toMul.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) x (Subtype.val.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Set.{u1} M) (Set.instMembershipSet.{u1} M) x (SetLike.coe.{u1, u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) M (Submonoid.instSetLikeSubmonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (nonZeroDivisors.{u1} M _inst_1))) c)) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (MonoidWithZero.toZero.{u1} M _inst_1)))) (Eq.{succ u1} M x (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (MonoidWithZero.toZero.{u1} M _inst_1))))
Case conversion may be inaccurate. Consider using '#align mul_right_coe_non_zero_divisors_eq_zero_iff mul_right_coe_nonZeroDivisors_eq_zero_iffₓ'. -/
@[simp]
theorem mul_right_coe_nonZeroDivisors_eq_zero_iff {x : M} {c : M⁰} : x * c = 0 ↔ x = 0 :=
  mul_right_mem_nonZeroDivisors_eq_zero_iff c.Prop
#align mul_right_coe_non_zero_divisors_eq_zero_iff mul_right_coe_nonZeroDivisors_eq_zero_iff

/- warning: mul_left_mem_non_zero_divisors_eq_zero_iff -> mul_left_mem_nonZeroDivisors_eq_zero_iff is a dubious translation:
lean 3 declaration is
  forall {M₁ : Type.{u1}} [_inst_3 : CommMonoidWithZero.{u1} M₁] {r : M₁} {x : M₁}, (Membership.Mem.{u1, u1} M₁ (Submonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) M₁ (Submonoid.setLike.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))))) r (nonZeroDivisors.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))) -> (Iff (Eq.{succ u1} M₁ (HMul.hMul.{u1, u1, u1} M₁ M₁ M₁ (instHMul.{u1} M₁ (MulZeroClass.toHasMul.{u1} M₁ (MulZeroOneClass.toMulZeroClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))))) r x) (OfNat.ofNat.{u1} M₁ 0 (OfNat.mk.{u1} M₁ 0 (Zero.zero.{u1} M₁ (MulZeroClass.toHasZero.{u1} M₁ (MulZeroOneClass.toMulZeroClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))))))) (Eq.{succ u1} M₁ x (OfNat.ofNat.{u1} M₁ 0 (OfNat.mk.{u1} M₁ 0 (Zero.zero.{u1} M₁ (MulZeroClass.toHasZero.{u1} M₁ (MulZeroOneClass.toMulZeroClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))))))))
but is expected to have type
  forall {M₁ : Type.{u1}} [_inst_3 : CommMonoidWithZero.{u1} M₁] {r : M₁} {x : M₁}, (Membership.mem.{u1, u1} M₁ (Submonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) M₁ (Submonoid.instSetLikeSubmonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))))) r (nonZeroDivisors.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))) -> (Iff (Eq.{succ u1} M₁ (HMul.hMul.{u1, u1, u1} M₁ M₁ M₁ (instHMul.{u1} M₁ (MulZeroClass.toMul.{u1} M₁ (MulZeroOneClass.toMulZeroClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))))) r x) (OfNat.ofNat.{u1} M₁ 0 (Zero.toOfNat0.{u1} M₁ (CommMonoidWithZero.toZero.{u1} M₁ _inst_3)))) (Eq.{succ u1} M₁ x (OfNat.ofNat.{u1} M₁ 0 (Zero.toOfNat0.{u1} M₁ (CommMonoidWithZero.toZero.{u1} M₁ _inst_3)))))
Case conversion may be inaccurate. Consider using '#align mul_left_mem_non_zero_divisors_eq_zero_iff mul_left_mem_nonZeroDivisors_eq_zero_iffₓ'. -/
theorem mul_left_mem_nonZeroDivisors_eq_zero_iff {r x : M₁} (hr : r ∈ M₁⁰) : r * x = 0 ↔ x = 0 := by
  rw [mul_comm, mul_right_mem_nonZeroDivisors_eq_zero_iff hr]
#align mul_left_mem_non_zero_divisors_eq_zero_iff mul_left_mem_nonZeroDivisors_eq_zero_iff

/- warning: mul_left_coe_non_zero_divisors_eq_zero_iff -> mul_left_coe_nonZeroDivisors_eq_zero_iff is a dubious translation:
lean 3 declaration is
  forall {M₁ : Type.{u1}} [_inst_3 : CommMonoidWithZero.{u1} M₁] {c : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) M₁ (Submonoid.setLike.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))))) (nonZeroDivisors.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))} {x : M₁}, Iff (Eq.{succ u1} M₁ (HMul.hMul.{u1, u1, u1} M₁ M₁ M₁ (instHMul.{u1} M₁ (MulZeroClass.toHasMul.{u1} M₁ (MulZeroOneClass.toMulZeroClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) M₁ (Submonoid.setLike.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))))) (nonZeroDivisors.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))) M₁ (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) M₁ (Submonoid.setLike.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))))) (nonZeroDivisors.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))) M₁ (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) M₁ (Submonoid.setLike.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))))) (nonZeroDivisors.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))) M₁ (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) M₁ (Submonoid.setLike.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))))) (nonZeroDivisors.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))) M₁ (coeSubtype.{succ u1} M₁ (fun (x : M₁) => Membership.Mem.{u1, u1} M₁ (Submonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) M₁ (Submonoid.setLike.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))))) x (nonZeroDivisors.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))))))) c) x) (OfNat.ofNat.{u1} M₁ 0 (OfNat.mk.{u1} M₁ 0 (Zero.zero.{u1} M₁ (MulZeroClass.toHasZero.{u1} M₁ (MulZeroOneClass.toMulZeroClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))))))) (Eq.{succ u1} M₁ x (OfNat.ofNat.{u1} M₁ 0 (OfNat.mk.{u1} M₁ 0 (Zero.zero.{u1} M₁ (MulZeroClass.toHasZero.{u1} M₁ (MulZeroOneClass.toMulZeroClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))))))))
but is expected to have type
  forall {M₁ : Type.{u1}} [_inst_3 : CommMonoidWithZero.{u1} M₁] {c : Subtype.{succ u1} M₁ (fun (x : M₁) => Membership.mem.{u1, u1} M₁ (Submonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) M₁ (Submonoid.instSetLikeSubmonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))))) x (nonZeroDivisors.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))} {x : M₁}, Iff (Eq.{succ u1} M₁ (HMul.hMul.{u1, u1, u1} M₁ M₁ M₁ (instHMul.{u1} M₁ (MulZeroClass.toMul.{u1} M₁ (MulZeroOneClass.toMulZeroClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))))) (Subtype.val.{succ u1} M₁ (fun (x : M₁) => Membership.mem.{u1, u1} M₁ (Set.{u1} M₁) (Set.instMembershipSet.{u1} M₁) x (SetLike.coe.{u1, u1} (Submonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) M₁ (Submonoid.instSetLikeSubmonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) (nonZeroDivisors.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) c) x) (OfNat.ofNat.{u1} M₁ 0 (Zero.toOfNat0.{u1} M₁ (CommMonoidWithZero.toZero.{u1} M₁ _inst_3)))) (Eq.{succ u1} M₁ x (OfNat.ofNat.{u1} M₁ 0 (Zero.toOfNat0.{u1} M₁ (CommMonoidWithZero.toZero.{u1} M₁ _inst_3))))
Case conversion may be inaccurate. Consider using '#align mul_left_coe_non_zero_divisors_eq_zero_iff mul_left_coe_nonZeroDivisors_eq_zero_iffₓ'. -/
@[simp]
theorem mul_left_coe_nonZeroDivisors_eq_zero_iff {c : M₁⁰} {x : M₁} : (c : M₁) * x = 0 ↔ x = 0 :=
  mul_left_mem_nonZeroDivisors_eq_zero_iff c.Prop
#align mul_left_coe_non_zero_divisors_eq_zero_iff mul_left_coe_nonZeroDivisors_eq_zero_iff

/- warning: mul_cancel_right_mem_non_zero_divisor -> mul_cancel_right_mem_nonZeroDivisors is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_4 : Ring.{u1} R] {x : R} {y : R} {r : R}, (Membership.Mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4)))))) r (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4)))) -> (Iff (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_4))) x r) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_4))) y r)) (Eq.{succ u1} R x y))
but is expected to have type
  forall {R : Type.{u1}} [_inst_4 : Ring.{u1} R] {x : R} {y : R} {r : R}, (Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4)))))) r (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4)))) -> (Iff (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_4)))) x r) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_4)))) y r)) (Eq.{succ u1} R x y))
Case conversion may be inaccurate. Consider using '#align mul_cancel_right_mem_non_zero_divisor mul_cancel_right_mem_nonZeroDivisorsₓ'. -/
theorem mul_cancel_right_mem_nonZeroDivisors {x y r : R} (hr : r ∈ R⁰) : x * r = y * r ↔ x = y :=
  by
  refine' ⟨fun h => _, congr_arg _⟩
  rw [← sub_eq_zero, ← mul_right_mem_nonZeroDivisors_eq_zero_iff hr, sub_mul, h, sub_self]
#align mul_cancel_right_mem_non_zero_divisor mul_cancel_right_mem_nonZeroDivisors

/- warning: mul_cancel_right_coe_non_zero_divisor -> mul_cancel_right_coe_nonZeroDivisors is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_4 : Ring.{u1} R] {x : R} {y : R} {c : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4)))))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4)))}, Iff (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_4))) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4)))))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4)))) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4)))))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4)))) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4)))))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4)))) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4)))))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4)))) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4)))))) x (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4)))))))) c)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_4))) y ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4)))))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4)))) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4)))))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4)))) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4)))))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4)))) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4)))))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4)))) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4)))))) x (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4)))))))) c))) (Eq.{succ u1} R x y)
but is expected to have type
  forall {R : Type.{u1}} [_inst_4 : Ring.{u1} R] {x : R} {y : R} {c : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4)))))) x (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))}, Iff (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_4)))) x (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))) c)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_4)))) y (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_4))))) c))) (Eq.{succ u1} R x y)
Case conversion may be inaccurate. Consider using '#align mul_cancel_right_coe_non_zero_divisor mul_cancel_right_coe_nonZeroDivisorsₓ'. -/
theorem mul_cancel_right_coe_nonZeroDivisors {x y : R} {c : R⁰} : x * c = y * c ↔ x = y :=
  mul_cancel_right_mem_nonZeroDivisors c.Prop
#align mul_cancel_right_coe_non_zero_divisor mul_cancel_right_coe_nonZeroDivisors

/- warning: mul_cancel_left_mem_non_zero_divisor -> mul_cancel_left_mem_nonZeroDivisors is a dubious translation:
lean 3 declaration is
  forall {R' : Type.{u1}} [_inst_5 : CommRing.{u1} R'] {x : R'} {y : R'} {r : R'}, (Membership.Mem.{u1, u1} R' (Submonoid.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))) R' (Submonoid.setLike.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5))))))) r (nonZeroDivisors.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5))))) -> (Iff (Eq.{succ u1} R' (HMul.hMul.{u1, u1, u1} R' R' R' (instHMul.{u1} R' (Distrib.toHasMul.{u1} R' (Ring.toDistrib.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))) r x) (HMul.hMul.{u1, u1, u1} R' R' R' (instHMul.{u1} R' (Distrib.toHasMul.{u1} R' (Ring.toDistrib.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))) r y)) (Eq.{succ u1} R' x y))
but is expected to have type
  forall {R' : Type.{u1}} [_inst_5 : CommRing.{u1} R'] {x : R'} {y : R'} {r : R'}, (Membership.mem.{u1, u1} R' (Submonoid.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))) R' (Submonoid.instSetLikeSubmonoid.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5))))))) r (nonZeroDivisors.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5))))) -> (Iff (Eq.{succ u1} R' (HMul.hMul.{u1, u1, u1} R' R' R' (instHMul.{u1} R' (NonUnitalNonAssocRing.toMul.{u1} R' (NonAssocRing.toNonUnitalNonAssocRing.{u1} R' (Ring.toNonAssocRing.{u1} R' (CommRing.toRing.{u1} R' _inst_5))))) r x) (HMul.hMul.{u1, u1, u1} R' R' R' (instHMul.{u1} R' (NonUnitalNonAssocRing.toMul.{u1} R' (NonAssocRing.toNonUnitalNonAssocRing.{u1} R' (Ring.toNonAssocRing.{u1} R' (CommRing.toRing.{u1} R' _inst_5))))) r y)) (Eq.{succ u1} R' x y))
Case conversion may be inaccurate. Consider using '#align mul_cancel_left_mem_non_zero_divisor mul_cancel_left_mem_nonZeroDivisorsₓ'. -/
@[simp]
theorem mul_cancel_left_mem_nonZeroDivisors {x y r : R'} (hr : r ∈ R'⁰) : r * x = r * y ↔ x = y :=
  by simp_rw [mul_comm r, mul_cancel_right_mem_nonZeroDivisors hr]
#align mul_cancel_left_mem_non_zero_divisor mul_cancel_left_mem_nonZeroDivisors

/- warning: mul_cancel_left_coe_non_zero_divisor -> mul_cancel_left_coe_nonZeroDivisors is a dubious translation:
lean 3 declaration is
  forall {R' : Type.{u1}} [_inst_5 : CommRing.{u1} R'] {x : R'} {y : R'} {c : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))) R' (Submonoid.setLike.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5))))))) (nonZeroDivisors.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5))))}, Iff (Eq.{succ u1} R' (HMul.hMul.{u1, u1, u1} R' R' R' (instHMul.{u1} R' (Distrib.toHasMul.{u1} R' (Ring.toDistrib.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))) R' (Submonoid.setLike.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5))))))) (nonZeroDivisors.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5))))) R' (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))) R' (Submonoid.setLike.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5))))))) (nonZeroDivisors.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5))))) R' (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))) R' (Submonoid.setLike.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5))))))) (nonZeroDivisors.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5))))) R' (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))) R' (Submonoid.setLike.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5))))))) (nonZeroDivisors.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5))))) R' (coeSubtype.{succ u1} R' (fun (x : R') => Membership.Mem.{u1, u1} R' (Submonoid.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))) R' (Submonoid.setLike.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5))))))) x (nonZeroDivisors.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5))))))))) c) x) (HMul.hMul.{u1, u1, u1} R' R' R' (instHMul.{u1} R' (Distrib.toHasMul.{u1} R' (Ring.toDistrib.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))) R' (Submonoid.setLike.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5))))))) (nonZeroDivisors.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5))))) R' (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))) R' (Submonoid.setLike.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5))))))) (nonZeroDivisors.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5))))) R' (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))) R' (Submonoid.setLike.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5))))))) (nonZeroDivisors.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5))))) R' (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))) R' (Submonoid.setLike.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5))))))) (nonZeroDivisors.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5))))) R' (coeSubtype.{succ u1} R' (fun (x : R') => Membership.Mem.{u1, u1} R' (Submonoid.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))) R' (Submonoid.setLike.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5))))))) x (nonZeroDivisors.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5))))))))) c) y)) (Eq.{succ u1} R' x y)
but is expected to have type
  forall {R' : Type.{u1}} [_inst_5 : CommRing.{u1} R'] {x : R'} {y : R'} {c : Subtype.{succ u1} R' (fun (x : R') => Membership.mem.{u1, u1} R' (Submonoid.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))) R' (Submonoid.instSetLikeSubmonoid.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5))))))) x (nonZeroDivisors.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))}, Iff (Eq.{succ u1} R' (HMul.hMul.{u1, u1, u1} R' R' R' (instHMul.{u1} R' (NonUnitalNonAssocRing.toMul.{u1} R' (NonAssocRing.toNonUnitalNonAssocRing.{u1} R' (Ring.toNonAssocRing.{u1} R' (CommRing.toRing.{u1} R' _inst_5))))) (Subtype.val.{succ u1} R' (fun (x : R') => Membership.mem.{u1, u1} R' (Set.{u1} R') (Set.instMembershipSet.{u1} R') x (SetLike.coe.{u1, u1} (Submonoid.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))) R' (Submonoid.instSetLikeSubmonoid.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))) (nonZeroDivisors.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))) c) x) (HMul.hMul.{u1, u1, u1} R' R' R' (instHMul.{u1} R' (NonUnitalNonAssocRing.toMul.{u1} R' (NonAssocRing.toNonUnitalNonAssocRing.{u1} R' (Ring.toNonAssocRing.{u1} R' (CommRing.toRing.{u1} R' _inst_5))))) (Subtype.val.{succ u1} R' (fun (x : R') => Membership.mem.{u1, u1} R' (Set.{u1} R') (Set.instMembershipSet.{u1} R') x (SetLike.coe.{u1, u1} (Submonoid.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))) R' (Submonoid.instSetLikeSubmonoid.{u1} R' (MulZeroOneClass.toMulOneClass.{u1} R' (MonoidWithZero.toMulZeroOneClass.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))) (nonZeroDivisors.{u1} R' (Semiring.toMonoidWithZero.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_5)))))) c) y)) (Eq.{succ u1} R' x y)
Case conversion may be inaccurate. Consider using '#align mul_cancel_left_coe_non_zero_divisor mul_cancel_left_coe_nonZeroDivisorsₓ'. -/
theorem mul_cancel_left_coe_nonZeroDivisors {x y : R'} {c : R'⁰} : (c : R') * x = c * y ↔ x = y :=
  mul_cancel_left_mem_nonZeroDivisors c.Prop
#align mul_cancel_left_coe_non_zero_divisor mul_cancel_left_coe_nonZeroDivisors

/- warning: non_zero_divisors.ne_zero -> nonZeroDivisors.ne_zero is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : MonoidWithZero.{u1} M] [_inst_6 : Nontrivial.{u1} M] {x : M}, (Membership.Mem.{u1, u1} M (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) M (Submonoid.setLike.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) x (nonZeroDivisors.{u1} M _inst_1)) -> (Ne.{succ u1} M x (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))))))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : MonoidWithZero.{u1} M] [_inst_6 : Nontrivial.{u1} M] {x : M}, (Membership.mem.{u1, u1} M (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) M (Submonoid.instSetLikeSubmonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) x (nonZeroDivisors.{u1} M _inst_1)) -> (Ne.{succ u1} M x (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (MonoidWithZero.toZero.{u1} M _inst_1))))
Case conversion may be inaccurate. Consider using '#align non_zero_divisors.ne_zero nonZeroDivisors.ne_zeroₓ'. -/
theorem nonZeroDivisors.ne_zero [Nontrivial M] {x} (hx : x ∈ M⁰) : x ≠ 0 := fun h =>
  one_ne_zero (hx _ <| (one_mul _).trans h)
#align non_zero_divisors.ne_zero nonZeroDivisors.ne_zero

/- warning: non_zero_divisors.coe_ne_zero -> nonZeroDivisors.coe_ne_zero is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : MonoidWithZero.{u1} M] [_inst_6 : Nontrivial.{u1} M] (x : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) M (Submonoid.setLike.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) (nonZeroDivisors.{u1} M _inst_1)), Ne.{succ u1} M ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) M (Submonoid.setLike.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) (nonZeroDivisors.{u1} M _inst_1)) M (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) M (Submonoid.setLike.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) (nonZeroDivisors.{u1} M _inst_1)) M (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) M (Submonoid.setLike.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) (nonZeroDivisors.{u1} M _inst_1)) M (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) M (Submonoid.setLike.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) (nonZeroDivisors.{u1} M _inst_1)) M (coeSubtype.{succ u1} M (fun (x : M) => Membership.Mem.{u1, u1} M (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) M (Submonoid.setLike.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) x (nonZeroDivisors.{u1} M _inst_1)))))) x) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))))))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : MonoidWithZero.{u1} M] [_inst_6 : Nontrivial.{u1} M] (x : Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) M (Submonoid.instSetLikeSubmonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) x (nonZeroDivisors.{u1} M _inst_1))), Ne.{succ u1} M (Subtype.val.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Set.{u1} M) (Set.instMembershipSet.{u1} M) x (SetLike.coe.{u1, u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) M (Submonoid.instSetLikeSubmonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (nonZeroDivisors.{u1} M _inst_1))) x) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (MonoidWithZero.toZero.{u1} M _inst_1)))
Case conversion may be inaccurate. Consider using '#align non_zero_divisors.coe_ne_zero nonZeroDivisors.coe_ne_zeroₓ'. -/
theorem nonZeroDivisors.coe_ne_zero [Nontrivial M] (x : M⁰) : (x : M) ≠ 0 :=
  nonZeroDivisors.ne_zero x.2
#align non_zero_divisors.coe_ne_zero nonZeroDivisors.coe_ne_zero

/- warning: mul_mem_non_zero_divisors -> mul_mem_nonZeroDivisors is a dubious translation:
lean 3 declaration is
  forall {M₁ : Type.{u1}} [_inst_3 : CommMonoidWithZero.{u1} M₁] {a : M₁} {b : M₁}, Iff (Membership.Mem.{u1, u1} M₁ (Submonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) M₁ (Submonoid.setLike.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))))) (HMul.hMul.{u1, u1, u1} M₁ M₁ M₁ (instHMul.{u1} M₁ (MulZeroClass.toHasMul.{u1} M₁ (MulZeroOneClass.toMulZeroClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))))) a b) (nonZeroDivisors.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))) (And (Membership.Mem.{u1, u1} M₁ (Submonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) M₁ (Submonoid.setLike.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))))) a (nonZeroDivisors.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))) (Membership.Mem.{u1, u1} M₁ (Submonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) M₁ (Submonoid.setLike.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))))) b (nonZeroDivisors.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))))
but is expected to have type
  forall {M₁ : Type.{u1}} [_inst_3 : CommMonoidWithZero.{u1} M₁] {a : M₁} {b : M₁}, Iff (Membership.mem.{u1, u1} M₁ (Submonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) M₁ (Submonoid.instSetLikeSubmonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))))) (HMul.hMul.{u1, u1, u1} M₁ M₁ M₁ (instHMul.{u1} M₁ (MulZeroClass.toMul.{u1} M₁ (MulZeroOneClass.toMulZeroClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))))) a b) (nonZeroDivisors.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))) (And (Membership.mem.{u1, u1} M₁ (Submonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) M₁ (Submonoid.instSetLikeSubmonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))))) a (nonZeroDivisors.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))) (Membership.mem.{u1, u1} M₁ (Submonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) M₁ (Submonoid.instSetLikeSubmonoid.{u1} M₁ (MulZeroOneClass.toMulOneClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))))) b (nonZeroDivisors.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))))
Case conversion may be inaccurate. Consider using '#align mul_mem_non_zero_divisors mul_mem_nonZeroDivisorsₓ'. -/
theorem mul_mem_nonZeroDivisors {a b : M₁} : a * b ∈ M₁⁰ ↔ a ∈ M₁⁰ ∧ b ∈ M₁⁰ :=
  by
  constructor
  · intro h
    constructor <;> intro x h' <;> apply h
    · rw [← mul_assoc, h', zero_mul]
    · rw [mul_comm a b, ← mul_assoc, h', zero_mul]
  · rintro ⟨ha, hb⟩ x hx
    apply ha
    apply hb
    rw [mul_assoc, hx]
#align mul_mem_non_zero_divisors mul_mem_nonZeroDivisors

/- warning: is_unit_of_mem_non_zero_divisors -> isUnit_of_mem_nonZeroDivisors is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_6 : GroupWithZero.{u1} G₀] {x : G₀}, (Membership.Mem.{u1, u1} G₀ (Submonoid.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_6)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_6)))) G₀ (Submonoid.setLike.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_6))))) x (nonZeroDivisors.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_6))) -> (IsUnit.{u1} G₀ (MonoidWithZero.toMonoid.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_6)) x)
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_6 : GroupWithZero.{u1} G₀] {x : G₀}, (Membership.mem.{u1, u1} G₀ (Submonoid.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_6)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_6)))) G₀ (Submonoid.instSetLikeSubmonoid.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_6))))) x (nonZeroDivisors.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_6))) -> (IsUnit.{u1} G₀ (MonoidWithZero.toMonoid.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_6)) x)
Case conversion may be inaccurate. Consider using '#align is_unit_of_mem_non_zero_divisors isUnit_of_mem_nonZeroDivisorsₓ'. -/
theorem isUnit_of_mem_nonZeroDivisors {G₀ : Type _} [GroupWithZero G₀] {x : G₀}
    (hx : x ∈ nonZeroDivisors G₀) : IsUnit x :=
  ⟨⟨x, x⁻¹, mul_inv_cancel (nonZeroDivisors.ne_zero hx),
      inv_mul_cancel (nonZeroDivisors.ne_zero hx)⟩,
    rfl⟩
#align is_unit_of_mem_non_zero_divisors isUnit_of_mem_nonZeroDivisors

/- warning: eq_zero_of_ne_zero_of_mul_right_eq_zero -> eq_zero_of_ne_zero_of_mul_right_eq_zero is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : MonoidWithZero.{u1} M] [_inst_6 : NoZeroDivisors.{u1} M (MulZeroClass.toHasMul.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))] {x : M} {y : M}, (Ne.{succ u1} M x (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))))))) -> (Eq.{succ u1} M (HMul.hMul.{u1, u1, u1} M M M (instHMul.{u1} M (MulZeroClass.toHasMul.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) y x) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))))))) -> (Eq.{succ u1} M y (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))))))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : MonoidWithZero.{u1} M] [_inst_6 : NoZeroDivisors.{u1} M (MulZeroClass.toMul.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (MonoidWithZero.toZero.{u1} M _inst_1)] {x : M} {y : M}, (Ne.{succ u1} M x (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (MonoidWithZero.toZero.{u1} M _inst_1)))) -> (Eq.{succ u1} M (HMul.hMul.{u1, u1, u1} M M M (instHMul.{u1} M (MulZeroClass.toMul.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) y x) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (MonoidWithZero.toZero.{u1} M _inst_1)))) -> (Eq.{succ u1} M y (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (MonoidWithZero.toZero.{u1} M _inst_1))))
Case conversion may be inaccurate. Consider using '#align eq_zero_of_ne_zero_of_mul_right_eq_zero eq_zero_of_ne_zero_of_mul_right_eq_zeroₓ'. -/
theorem eq_zero_of_ne_zero_of_mul_right_eq_zero [NoZeroDivisors M] {x y : M} (hnx : x ≠ 0)
    (hxy : y * x = 0) : y = 0 :=
  Or.resolve_right (eq_zero_or_eq_zero_of_mul_eq_zero hxy) hnx
#align eq_zero_of_ne_zero_of_mul_right_eq_zero eq_zero_of_ne_zero_of_mul_right_eq_zero

/- warning: eq_zero_of_ne_zero_of_mul_left_eq_zero -> eq_zero_of_ne_zero_of_mul_left_eq_zero is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : MonoidWithZero.{u1} M] [_inst_6 : NoZeroDivisors.{u1} M (MulZeroClass.toHasMul.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))] {x : M} {y : M}, (Ne.{succ u1} M x (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))))))) -> (Eq.{succ u1} M (HMul.hMul.{u1, u1, u1} M M M (instHMul.{u1} M (MulZeroClass.toHasMul.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) x y) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))))))) -> (Eq.{succ u1} M y (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))))))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : MonoidWithZero.{u1} M] [_inst_6 : NoZeroDivisors.{u1} M (MulZeroClass.toMul.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (MonoidWithZero.toZero.{u1} M _inst_1)] {x : M} {y : M}, (Ne.{succ u1} M x (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (MonoidWithZero.toZero.{u1} M _inst_1)))) -> (Eq.{succ u1} M (HMul.hMul.{u1, u1, u1} M M M (instHMul.{u1} M (MulZeroClass.toMul.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) x y) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (MonoidWithZero.toZero.{u1} M _inst_1)))) -> (Eq.{succ u1} M y (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (MonoidWithZero.toZero.{u1} M _inst_1))))
Case conversion may be inaccurate. Consider using '#align eq_zero_of_ne_zero_of_mul_left_eq_zero eq_zero_of_ne_zero_of_mul_left_eq_zeroₓ'. -/
theorem eq_zero_of_ne_zero_of_mul_left_eq_zero [NoZeroDivisors M] {x y : M} (hnx : x ≠ 0)
    (hxy : x * y = 0) : y = 0 :=
  Or.resolve_left (eq_zero_or_eq_zero_of_mul_eq_zero hxy) hnx
#align eq_zero_of_ne_zero_of_mul_left_eq_zero eq_zero_of_ne_zero_of_mul_left_eq_zero

/- warning: mem_non_zero_divisors_of_ne_zero -> mem_nonZeroDivisors_of_ne_zero is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : MonoidWithZero.{u1} M] [_inst_6 : NoZeroDivisors.{u1} M (MulZeroClass.toHasMul.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))] {x : M}, (Ne.{succ u1} M x (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))))))) -> (Membership.Mem.{u1, u1} M (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) M (Submonoid.setLike.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) x (nonZeroDivisors.{u1} M _inst_1))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : MonoidWithZero.{u1} M] [_inst_6 : NoZeroDivisors.{u1} M (MulZeroClass.toMul.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (MonoidWithZero.toZero.{u1} M _inst_1)] {x : M}, (Ne.{succ u1} M x (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (MonoidWithZero.toZero.{u1} M _inst_1)))) -> (Membership.mem.{u1, u1} M (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) M (Submonoid.instSetLikeSubmonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) x (nonZeroDivisors.{u1} M _inst_1))
Case conversion may be inaccurate. Consider using '#align mem_non_zero_divisors_of_ne_zero mem_nonZeroDivisors_of_ne_zeroₓ'. -/
theorem mem_nonZeroDivisors_of_ne_zero [NoZeroDivisors M] {x : M} (hx : x ≠ 0) : x ∈ M⁰ := fun _ =>
  eq_zero_of_ne_zero_of_mul_right_eq_zero hx
#align mem_non_zero_divisors_of_ne_zero mem_nonZeroDivisors_of_ne_zero

/- warning: mem_non_zero_divisors_iff_ne_zero -> mem_nonZeroDivisors_iff_ne_zero is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : MonoidWithZero.{u1} M] [_inst_6 : NoZeroDivisors.{u1} M (MulZeroClass.toHasMul.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))] [_inst_7 : Nontrivial.{u1} M] {x : M}, Iff (Membership.Mem.{u1, u1} M (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) M (Submonoid.setLike.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) x (nonZeroDivisors.{u1} M _inst_1)) (Ne.{succ u1} M x (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))))))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : MonoidWithZero.{u1} M] [_inst_6 : NoZeroDivisors.{u1} M (MulZeroClass.toMul.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (MonoidWithZero.toZero.{u1} M _inst_1)] [_inst_7 : Nontrivial.{u1} M] {x : M}, Iff (Membership.mem.{u1, u1} M (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) M (Submonoid.instSetLikeSubmonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) x (nonZeroDivisors.{u1} M _inst_1)) (Ne.{succ u1} M x (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (MonoidWithZero.toZero.{u1} M _inst_1))))
Case conversion may be inaccurate. Consider using '#align mem_non_zero_divisors_iff_ne_zero mem_nonZeroDivisors_iff_ne_zeroₓ'. -/
theorem mem_nonZeroDivisors_iff_ne_zero [NoZeroDivisors M] [Nontrivial M] {x : M} :
    x ∈ M⁰ ↔ x ≠ 0 :=
  ⟨nonZeroDivisors.ne_zero, mem_nonZeroDivisors_of_ne_zero⟩
#align mem_non_zero_divisors_iff_ne_zero mem_nonZeroDivisors_iff_ne_zero

/- warning: map_ne_zero_of_mem_non_zero_divisors -> map_ne_zero_of_mem_nonZeroDivisors is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {M' : Type.{u2}} {F : Type.{u3}} [_inst_1 : MonoidWithZero.{u1} M] [_inst_2 : MonoidWithZero.{u2} M'] [_inst_6 : Nontrivial.{u1} M] [_inst_7 : ZeroHomClass.{u3, u1, u2} F M M' (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (MulZeroClass.toHasZero.{u2} M' (MulZeroOneClass.toMulZeroClass.{u2} M' (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2)))] (g : F), (Function.Injective.{succ u1, succ u2} M M' (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => M -> M') (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F M (fun (_x : M) => M') (ZeroHomClass.toFunLike.{u3, u1, u2} F M M' (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (MulZeroClass.toHasZero.{u2} M' (MulZeroOneClass.toMulZeroClass.{u2} M' (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2))) _inst_7)) g)) -> (forall {x : M}, (Membership.Mem.{u1, u1} M (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) M (Submonoid.setLike.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) x (nonZeroDivisors.{u1} M _inst_1)) -> (Ne.{succ u2} M' (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => M -> M') (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F M (fun (_x : M) => M') (ZeroHomClass.toFunLike.{u3, u1, u2} F M M' (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (MulZeroClass.toHasZero.{u2} M' (MulZeroOneClass.toMulZeroClass.{u2} M' (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2))) _inst_7)) g x) (OfNat.ofNat.{u2} M' 0 (OfNat.mk.{u2} M' 0 (Zero.zero.{u2} M' (MulZeroClass.toHasZero.{u2} M' (MulZeroOneClass.toMulZeroClass.{u2} M' (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2))))))))
but is expected to have type
  forall {M : Type.{u3}} {M' : Type.{u1}} {F : Type.{u2}} [_inst_1 : MonoidWithZero.{u3} M] [_inst_2 : MonoidWithZero.{u1} M'] [_inst_6 : Nontrivial.{u3} M] [_inst_7 : ZeroHomClass.{u2, u3, u1} F M M' (MonoidWithZero.toZero.{u3} M _inst_1) (MonoidWithZero.toZero.{u1} M' _inst_2)] (g : F), (Function.Injective.{succ u3, succ u1} M M' (FunLike.coe.{succ u2, succ u3, succ u1} F M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.124 : M) => M') _x) (ZeroHomClass.toFunLike.{u2, u3, u1} F M M' (MonoidWithZero.toZero.{u3} M _inst_1) (MonoidWithZero.toZero.{u1} M' _inst_2) _inst_7) g)) -> (forall {x : M}, (Membership.mem.{u3, u3} M (Submonoid.{u3} M (MulZeroOneClass.toMulOneClass.{u3} M (MonoidWithZero.toMulZeroOneClass.{u3} M _inst_1))) (SetLike.instMembership.{u3, u3} (Submonoid.{u3} M (MulZeroOneClass.toMulOneClass.{u3} M (MonoidWithZero.toMulZeroOneClass.{u3} M _inst_1))) M (Submonoid.instSetLikeSubmonoid.{u3} M (MulZeroOneClass.toMulOneClass.{u3} M (MonoidWithZero.toMulZeroOneClass.{u3} M _inst_1)))) x (nonZeroDivisors.{u3} M _inst_1)) -> (Ne.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.124 : M) => M') x) (FunLike.coe.{succ u2, succ u3, succ u1} F M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.124 : M) => M') _x) (ZeroHomClass.toFunLike.{u2, u3, u1} F M M' (MonoidWithZero.toZero.{u3} M _inst_1) (MonoidWithZero.toZero.{u1} M' _inst_2) _inst_7) g x) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.124 : M) => M') x) 0 (Zero.toOfNat0.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.124 : M) => M') x) (MonoidWithZero.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.124 : M) => M') x) _inst_2)))))
Case conversion may be inaccurate. Consider using '#align map_ne_zero_of_mem_non_zero_divisors map_ne_zero_of_mem_nonZeroDivisorsₓ'. -/
theorem map_ne_zero_of_mem_nonZeroDivisors [Nontrivial M] [ZeroHomClass F M M'] (g : F)
    (hg : Function.Injective (g : M → M')) {x : M} (h : x ∈ M⁰) : g x ≠ 0 := fun h0 =>
  one_ne_zero (h 1 ((one_mul x).symm ▸ hg (trans h0 (map_zero g).symm)))
#align map_ne_zero_of_mem_non_zero_divisors map_ne_zero_of_mem_nonZeroDivisors

/- warning: map_mem_non_zero_divisors -> map_mem_nonZeroDivisors is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {M' : Type.{u2}} {F : Type.{u3}} [_inst_1 : MonoidWithZero.{u1} M] [_inst_2 : MonoidWithZero.{u2} M'] [_inst_6 : Nontrivial.{u1} M] [_inst_7 : NoZeroDivisors.{u2} M' (MulZeroClass.toHasMul.{u2} M' (MulZeroOneClass.toMulZeroClass.{u2} M' (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2))) (MulZeroClass.toHasZero.{u2} M' (MulZeroOneClass.toMulZeroClass.{u2} M' (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2)))] [_inst_8 : ZeroHomClass.{u3, u1, u2} F M M' (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (MulZeroClass.toHasZero.{u2} M' (MulZeroOneClass.toMulZeroClass.{u2} M' (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2)))] (g : F), (Function.Injective.{succ u1, succ u2} M M' (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => M -> M') (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F M (fun (_x : M) => M') (ZeroHomClass.toFunLike.{u3, u1, u2} F M M' (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (MulZeroClass.toHasZero.{u2} M' (MulZeroOneClass.toMulZeroClass.{u2} M' (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2))) _inst_8)) g)) -> (forall {x : M}, (Membership.Mem.{u1, u1} M (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) M (Submonoid.setLike.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) x (nonZeroDivisors.{u1} M _inst_1)) -> (Membership.Mem.{u2, u2} M' (Submonoid.{u2} M' (MulZeroOneClass.toMulOneClass.{u2} M' (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2))) (SetLike.hasMem.{u2, u2} (Submonoid.{u2} M' (MulZeroOneClass.toMulOneClass.{u2} M' (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2))) M' (Submonoid.setLike.{u2} M' (MulZeroOneClass.toMulOneClass.{u2} M' (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2)))) (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => M -> M') (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F M (fun (_x : M) => M') (ZeroHomClass.toFunLike.{u3, u1, u2} F M M' (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (MulZeroClass.toHasZero.{u2} M' (MulZeroOneClass.toMulZeroClass.{u2} M' (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2))) _inst_8)) g x) (nonZeroDivisors.{u2} M' _inst_2)))
but is expected to have type
  forall {M : Type.{u3}} {M' : Type.{u2}} {F : Type.{u1}} [_inst_1 : MonoidWithZero.{u3} M] [_inst_2 : MonoidWithZero.{u2} M'] [_inst_6 : Nontrivial.{u3} M] [_inst_7 : NoZeroDivisors.{u2} M' (MulZeroClass.toMul.{u2} M' (MulZeroOneClass.toMulZeroClass.{u2} M' (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2))) (MonoidWithZero.toZero.{u2} M' _inst_2)] [_inst_8 : ZeroHomClass.{u1, u3, u2} F M M' (MonoidWithZero.toZero.{u3} M _inst_1) (MonoidWithZero.toZero.{u2} M' _inst_2)] (g : F), (Function.Injective.{succ u3, succ u2} M M' (FunLike.coe.{succ u1, succ u3, succ u2} F M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.124 : M) => M') _x) (ZeroHomClass.toFunLike.{u1, u3, u2} F M M' (MonoidWithZero.toZero.{u3} M _inst_1) (MonoidWithZero.toZero.{u2} M' _inst_2) _inst_8) g)) -> (forall {x : M}, (Membership.mem.{u3, u3} M (Submonoid.{u3} M (MulZeroOneClass.toMulOneClass.{u3} M (MonoidWithZero.toMulZeroOneClass.{u3} M _inst_1))) (SetLike.instMembership.{u3, u3} (Submonoid.{u3} M (MulZeroOneClass.toMulOneClass.{u3} M (MonoidWithZero.toMulZeroOneClass.{u3} M _inst_1))) M (Submonoid.instSetLikeSubmonoid.{u3} M (MulZeroOneClass.toMulOneClass.{u3} M (MonoidWithZero.toMulZeroOneClass.{u3} M _inst_1)))) x (nonZeroDivisors.{u3} M _inst_1)) -> (Membership.mem.{u2, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.124 : M) => M') x) (Submonoid.{u2} M' (MulZeroOneClass.toMulOneClass.{u2} M' (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} M' (MulZeroOneClass.toMulOneClass.{u2} M' (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2))) M' (Submonoid.instSetLikeSubmonoid.{u2} M' (MulZeroOneClass.toMulOneClass.{u2} M' (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2)))) (FunLike.coe.{succ u1, succ u3, succ u2} F M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.124 : M) => M') _x) (ZeroHomClass.toFunLike.{u1, u3, u2} F M M' (MonoidWithZero.toZero.{u3} M _inst_1) (MonoidWithZero.toZero.{u2} M' _inst_2) _inst_8) g x) (nonZeroDivisors.{u2} M' _inst_2)))
Case conversion may be inaccurate. Consider using '#align map_mem_non_zero_divisors map_mem_nonZeroDivisorsₓ'. -/
theorem map_mem_nonZeroDivisors [Nontrivial M] [NoZeroDivisors M'] [ZeroHomClass F M M'] (g : F)
    (hg : Function.Injective g) {x : M} (h : x ∈ M⁰) : g x ∈ M'⁰ := fun z hz =>
  eq_zero_of_ne_zero_of_mul_right_eq_zero (map_ne_zero_of_mem_nonZeroDivisors g hg h) hz
#align map_mem_non_zero_divisors map_mem_nonZeroDivisors

/- warning: le_non_zero_divisors_of_no_zero_divisors -> le_nonZeroDivisors_of_noZeroDivisors is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : MonoidWithZero.{u1} M] [_inst_6 : NoZeroDivisors.{u1} M (MulZeroClass.toHasMul.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))] {S : Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))}, (Not (Membership.Mem.{u1, u1} M (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) M (Submonoid.setLike.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))))) S)) -> (LE.le.{u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (Preorder.toLE.{u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (SetLike.partialOrder.{u1, u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) M (Submonoid.setLike.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))))) S (nonZeroDivisors.{u1} M _inst_1))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : MonoidWithZero.{u1} M] [_inst_6 : NoZeroDivisors.{u1} M (MulZeroClass.toMul.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (MonoidWithZero.toZero.{u1} M _inst_1)] {S : Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))}, (Not (Membership.mem.{u1, u1} M (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) M (Submonoid.instSetLikeSubmonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (MonoidWithZero.toZero.{u1} M _inst_1))) S)) -> (LE.le.{u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (Preorder.toLE.{u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (Submonoid.instCompleteLatticeSubmonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))))))) S (nonZeroDivisors.{u1} M _inst_1))
Case conversion may be inaccurate. Consider using '#align le_non_zero_divisors_of_no_zero_divisors le_nonZeroDivisors_of_noZeroDivisorsₓ'. -/
theorem le_nonZeroDivisors_of_noZeroDivisors [NoZeroDivisors M] {S : Submonoid M}
    (hS : (0 : M) ∉ S) : S ≤ M⁰ := fun x hx y hy =>
  Or.rec_on (eq_zero_or_eq_zero_of_mul_eq_zero hy) (fun h => h) fun h =>
    absurd (h ▸ hx : (0 : M) ∈ S) hS
#align le_non_zero_divisors_of_no_zero_divisors le_nonZeroDivisors_of_noZeroDivisors

/- warning: powers_le_non_zero_divisors_of_no_zero_divisors -> powers_le_nonZeroDivisors_of_noZeroDivisors is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : MonoidWithZero.{u1} M] [_inst_6 : NoZeroDivisors.{u1} M (MulZeroClass.toHasMul.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))] {a : M}, (Ne.{succ u1} M a (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))))))) -> (LE.le.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M (MonoidWithZero.toMonoid.{u1} M _inst_1))) (Preorder.toLE.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M (MonoidWithZero.toMonoid.{u1} M _inst_1))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M (MonoidWithZero.toMonoid.{u1} M _inst_1))) (SetLike.partialOrder.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M (MonoidWithZero.toMonoid.{u1} M _inst_1))) M (Submonoid.setLike.{u1} M (Monoid.toMulOneClass.{u1} M (MonoidWithZero.toMonoid.{u1} M _inst_1)))))) (Submonoid.powers.{u1} M (MonoidWithZero.toMonoid.{u1} M _inst_1) a) (nonZeroDivisors.{u1} M _inst_1))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : MonoidWithZero.{u1} M] [_inst_6 : NoZeroDivisors.{u1} M (MulZeroClass.toMul.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (MonoidWithZero.toZero.{u1} M _inst_1)] {a : M}, (Ne.{succ u1} M a (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (MonoidWithZero.toZero.{u1} M _inst_1)))) -> (LE.le.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M (MonoidWithZero.toMonoid.{u1} M _inst_1))) (Preorder.toLE.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M (MonoidWithZero.toMonoid.{u1} M _inst_1))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M (MonoidWithZero.toMonoid.{u1} M _inst_1))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M (MonoidWithZero.toMonoid.{u1} M _inst_1))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M (MonoidWithZero.toMonoid.{u1} M _inst_1))) (Submonoid.instCompleteLatticeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M (MonoidWithZero.toMonoid.{u1} M _inst_1))))))) (Submonoid.powers.{u1} M (MonoidWithZero.toMonoid.{u1} M _inst_1) a) (nonZeroDivisors.{u1} M _inst_1))
Case conversion may be inaccurate. Consider using '#align powers_le_non_zero_divisors_of_no_zero_divisors powers_le_nonZeroDivisors_of_noZeroDivisorsₓ'. -/
theorem powers_le_nonZeroDivisors_of_noZeroDivisors [NoZeroDivisors M] {a : M} (ha : a ≠ 0) :
    Submonoid.powers a ≤ M⁰ :=
  le_nonZeroDivisors_of_noZeroDivisors fun h => absurd (h.recOn fun _ hn => pow_eq_zero hn) ha
#align powers_le_non_zero_divisors_of_no_zero_divisors powers_le_nonZeroDivisors_of_noZeroDivisors

/- warning: map_le_non_zero_divisors_of_injective -> map_le_nonZeroDivisors_of_injective is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {M' : Type.{u2}} {F : Type.{u3}} [_inst_1 : MonoidWithZero.{u1} M] [_inst_2 : MonoidWithZero.{u2} M'] [_inst_6 : NoZeroDivisors.{u2} M' (MulZeroClass.toHasMul.{u2} M' (MulZeroOneClass.toMulZeroClass.{u2} M' (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2))) (MulZeroClass.toHasZero.{u2} M' (MulZeroOneClass.toMulZeroClass.{u2} M' (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2)))] [_inst_7 : MonoidWithZeroHomClass.{u3, u1, u2} F M M' (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1) (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2)] (f : F), (Function.Injective.{succ u1, succ u2} M M' (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => M -> M') (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F M (fun (_x : M) => M') (MulHomClass.toFunLike.{u3, u1, u2} F M M' (MulOneClass.toHasMul.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (MulOneClass.toHasMul.{u2} M' (MulZeroOneClass.toMulOneClass.{u2} M' (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2))) (MonoidHomClass.toMulHomClass.{u3, u1, u2} F M M' (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} M' (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2)) (MonoidWithZeroHomClass.toMonoidHomClass.{u3, u1, u2} F M M' (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1) (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2) _inst_7)))) f)) -> (forall {S : Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))}, (LE.le.{u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (Preorder.toLE.{u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (SetLike.partialOrder.{u1, u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) M (Submonoid.setLike.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))))) S (nonZeroDivisors.{u1} M _inst_1)) -> (LE.le.{u2} (Submonoid.{u2} M' (MulZeroOneClass.toMulOneClass.{u2} M' (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2))) (Preorder.toLE.{u2} (Submonoid.{u2} M' (MulZeroOneClass.toMulOneClass.{u2} M' (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2))) (PartialOrder.toPreorder.{u2} (Submonoid.{u2} M' (MulZeroOneClass.toMulOneClass.{u2} M' (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2))) (SetLike.partialOrder.{u2, u2} (Submonoid.{u2} M' (MulZeroOneClass.toMulOneClass.{u2} M' (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2))) M' (Submonoid.setLike.{u2} M' (MulZeroOneClass.toMulOneClass.{u2} M' (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2)))))) (Submonoid.map.{u1, u2, u3} M M' (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} M' (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2)) F (MonoidWithZeroHomClass.toMonoidHomClass.{u3, u1, u2} F M M' (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1) (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2) _inst_7) f S) (nonZeroDivisors.{u2} M' _inst_2)))
but is expected to have type
  forall {M : Type.{u1}} {M' : Type.{u3}} {F : Type.{u2}} [_inst_1 : MonoidWithZero.{u1} M] [_inst_2 : MonoidWithZero.{u3} M'] [_inst_6 : NoZeroDivisors.{u3} M' (MulZeroClass.toMul.{u3} M' (MulZeroOneClass.toMulZeroClass.{u3} M' (MonoidWithZero.toMulZeroOneClass.{u3} M' _inst_2))) (MonoidWithZero.toZero.{u3} M' _inst_2)] [_inst_7 : MonoidWithZeroHomClass.{u2, u1, u3} F M M' (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1) (MonoidWithZero.toMulZeroOneClass.{u3} M' _inst_2)] (f : F), (Function.Injective.{succ u1, succ u3} M M' (FunLike.coe.{succ u2, succ u1, succ u3} F M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : M) => M') _x) (MulHomClass.toFunLike.{u2, u1, u3} F M M' (MulOneClass.toMul.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (MulOneClass.toMul.{u3} M' (MulZeroOneClass.toMulOneClass.{u3} M' (MonoidWithZero.toMulZeroOneClass.{u3} M' _inst_2))) (MonoidHomClass.toMulHomClass.{u2, u1, u3} F M M' (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)) (MulZeroOneClass.toMulOneClass.{u3} M' (MonoidWithZero.toMulZeroOneClass.{u3} M' _inst_2)) (MonoidWithZeroHomClass.toMonoidHomClass.{u2, u1, u3} F M M' (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1) (MonoidWithZero.toMulZeroOneClass.{u3} M' _inst_2) _inst_7))) f)) -> (forall {S : Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))}, (LE.le.{u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (Preorder.toLE.{u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (Submonoid.instCompleteLatticeSubmonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))))))) S (nonZeroDivisors.{u1} M _inst_1)) -> (LE.le.{u3} (Submonoid.{u3} M' (MulZeroOneClass.toMulOneClass.{u3} M' (MonoidWithZero.toMulZeroOneClass.{u3} M' _inst_2))) (Preorder.toLE.{u3} (Submonoid.{u3} M' (MulZeroOneClass.toMulOneClass.{u3} M' (MonoidWithZero.toMulZeroOneClass.{u3} M' _inst_2))) (PartialOrder.toPreorder.{u3} (Submonoid.{u3} M' (MulZeroOneClass.toMulOneClass.{u3} M' (MonoidWithZero.toMulZeroOneClass.{u3} M' _inst_2))) (CompleteSemilatticeInf.toPartialOrder.{u3} (Submonoid.{u3} M' (MulZeroOneClass.toMulOneClass.{u3} M' (MonoidWithZero.toMulZeroOneClass.{u3} M' _inst_2))) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Submonoid.{u3} M' (MulZeroOneClass.toMulOneClass.{u3} M' (MonoidWithZero.toMulZeroOneClass.{u3} M' _inst_2))) (Submonoid.instCompleteLatticeSubmonoid.{u3} M' (MulZeroOneClass.toMulOneClass.{u3} M' (MonoidWithZero.toMulZeroOneClass.{u3} M' _inst_2))))))) (Submonoid.map.{u1, u3, u2} M M' (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)) (MulZeroOneClass.toMulOneClass.{u3} M' (MonoidWithZero.toMulZeroOneClass.{u3} M' _inst_2)) F (MonoidWithZeroHomClass.toMonoidHomClass.{u2, u1, u3} F M M' (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1) (MonoidWithZero.toMulZeroOneClass.{u3} M' _inst_2) _inst_7) f S) (nonZeroDivisors.{u3} M' _inst_2)))
Case conversion may be inaccurate. Consider using '#align map_le_non_zero_divisors_of_injective map_le_nonZeroDivisors_of_injectiveₓ'. -/
theorem map_le_nonZeroDivisors_of_injective [NoZeroDivisors M'] [MonoidWithZeroHomClass F M M']
    (f : F) (hf : Function.Injective f) {S : Submonoid M} (hS : S ≤ M⁰) : S.map f ≤ M'⁰ :=
  by
  cases subsingleton_or_nontrivial M
  · simp [Subsingleton.elim S ⊥]
  ·
    exact
      le_nonZeroDivisors_of_noZeroDivisors fun h =>
        let ⟨x, hx, hx0⟩ := h
        zero_ne_one (hS (hf (trans hx0 (map_zero f).symm) ▸ hx : 0 ∈ S) 1 (mul_zero 1)).symm
#align map_le_non_zero_divisors_of_injective map_le_nonZeroDivisors_of_injective

/- warning: non_zero_divisors_le_comap_non_zero_divisors_of_injective -> nonZeroDivisors_le_comap_nonZeroDivisors_of_injective is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {M' : Type.{u2}} {F : Type.{u3}} [_inst_1 : MonoidWithZero.{u1} M] [_inst_2 : MonoidWithZero.{u2} M'] [_inst_6 : NoZeroDivisors.{u2} M' (MulZeroClass.toHasMul.{u2} M' (MulZeroOneClass.toMulZeroClass.{u2} M' (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2))) (MulZeroClass.toHasZero.{u2} M' (MulZeroOneClass.toMulZeroClass.{u2} M' (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2)))] [_inst_7 : MonoidWithZeroHomClass.{u3, u1, u2} F M M' (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1) (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2)] (f : F), (Function.Injective.{succ u1, succ u2} M M' (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => M -> M') (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F M (fun (_x : M) => M') (MulHomClass.toFunLike.{u3, u1, u2} F M M' (MulOneClass.toHasMul.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (MulOneClass.toHasMul.{u2} M' (MulZeroOneClass.toMulOneClass.{u2} M' (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2))) (MonoidHomClass.toMulHomClass.{u3, u1, u2} F M M' (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} M' (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2)) (MonoidWithZeroHomClass.toMonoidHomClass.{u3, u1, u2} F M M' (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1) (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2) _inst_7)))) f)) -> (LE.le.{u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (Preorder.toLE.{u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (SetLike.partialOrder.{u1, u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) M (Submonoid.setLike.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)))))) (nonZeroDivisors.{u1} M _inst_1) (Submonoid.comap.{u1, u2, u3} M M' (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} M' (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2)) F (MonoidWithZeroHomClass.toMonoidHomClass.{u3, u1, u2} F M M' (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1) (MonoidWithZero.toMulZeroOneClass.{u2} M' _inst_2) _inst_7) f (nonZeroDivisors.{u2} M' _inst_2)))
but is expected to have type
  forall {M : Type.{u1}} {M' : Type.{u3}} {F : Type.{u2}} [_inst_1 : MonoidWithZero.{u1} M] [_inst_2 : MonoidWithZero.{u3} M'] [_inst_6 : NoZeroDivisors.{u3} M' (MulZeroClass.toMul.{u3} M' (MulZeroOneClass.toMulZeroClass.{u3} M' (MonoidWithZero.toMulZeroOneClass.{u3} M' _inst_2))) (MonoidWithZero.toZero.{u3} M' _inst_2)] [_inst_7 : MonoidWithZeroHomClass.{u2, u1, u3} F M M' (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1) (MonoidWithZero.toMulZeroOneClass.{u3} M' _inst_2)] (f : F), (Function.Injective.{succ u1, succ u3} M M' (FunLike.coe.{succ u2, succ u1, succ u3} F M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : M) => M') _x) (MulHomClass.toFunLike.{u2, u1, u3} F M M' (MulOneClass.toMul.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (MulOneClass.toMul.{u3} M' (MulZeroOneClass.toMulOneClass.{u3} M' (MonoidWithZero.toMulZeroOneClass.{u3} M' _inst_2))) (MonoidHomClass.toMulHomClass.{u2, u1, u3} F M M' (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)) (MulZeroOneClass.toMulOneClass.{u3} M' (MonoidWithZero.toMulZeroOneClass.{u3} M' _inst_2)) (MonoidWithZeroHomClass.toMonoidHomClass.{u2, u1, u3} F M M' (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1) (MonoidWithZero.toMulZeroOneClass.{u3} M' _inst_2) _inst_7))) f)) -> (LE.le.{u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (Preorder.toLE.{u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))) (Submonoid.instCompleteLatticeSubmonoid.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1))))))) (nonZeroDivisors.{u1} M _inst_1) (Submonoid.comap.{u1, u3, u2} M M' (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1)) (MulZeroOneClass.toMulOneClass.{u3} M' (MonoidWithZero.toMulZeroOneClass.{u3} M' _inst_2)) F (MonoidWithZeroHomClass.toMonoidHomClass.{u2, u1, u3} F M M' (MonoidWithZero.toMulZeroOneClass.{u1} M _inst_1) (MonoidWithZero.toMulZeroOneClass.{u3} M' _inst_2) _inst_7) f (nonZeroDivisors.{u3} M' _inst_2)))
Case conversion may be inaccurate. Consider using '#align non_zero_divisors_le_comap_non_zero_divisors_of_injective nonZeroDivisors_le_comap_nonZeroDivisors_of_injectiveₓ'. -/
theorem nonZeroDivisors_le_comap_nonZeroDivisors_of_injective [NoZeroDivisors M']
    [MonoidWithZeroHomClass F M M'] (f : F) (hf : Function.Injective f) : M⁰ ≤ M'⁰.comap f :=
  Submonoid.le_comap_of_map_le _ (map_le_nonZeroDivisors_of_injective _ hf le_rfl)
#align non_zero_divisors_le_comap_non_zero_divisors_of_injective nonZeroDivisors_le_comap_nonZeroDivisors_of_injective

/- warning: prod_zero_iff_exists_zero -> prod_zero_iff_exists_zero is a dubious translation:
lean 3 declaration is
  forall {M₁ : Type.{u1}} [_inst_3 : CommMonoidWithZero.{u1} M₁] [_inst_6 : NoZeroDivisors.{u1} M₁ (MulZeroClass.toHasMul.{u1} M₁ (MulZeroOneClass.toMulZeroClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) (MulZeroClass.toHasZero.{u1} M₁ (MulZeroOneClass.toMulZeroClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))))] [_inst_7 : Nontrivial.{u1} M₁] {s : Multiset.{u1} M₁}, Iff (Eq.{succ u1} M₁ (Multiset.prod.{u1} M₁ (CommMonoidWithZero.toCommMonoid.{u1} M₁ _inst_3) s) (OfNat.ofNat.{u1} M₁ 0 (OfNat.mk.{u1} M₁ 0 (Zero.zero.{u1} M₁ (MulZeroClass.toHasZero.{u1} M₁ (MulZeroOneClass.toMulZeroClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))))))) (Exists.{succ u1} M₁ (fun (r : M₁) => Exists.{0} (Membership.Mem.{u1, u1} M₁ (Multiset.{u1} M₁) (Multiset.hasMem.{u1} M₁) r s) (fun (hr : Membership.Mem.{u1, u1} M₁ (Multiset.{u1} M₁) (Multiset.hasMem.{u1} M₁) r s) => Eq.{succ u1} M₁ r (OfNat.ofNat.{u1} M₁ 0 (OfNat.mk.{u1} M₁ 0 (Zero.zero.{u1} M₁ (MulZeroClass.toHasZero.{u1} M₁ (MulZeroOneClass.toMulZeroClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3))))))))))
but is expected to have type
  forall {M₁ : Type.{u1}} [_inst_3 : CommMonoidWithZero.{u1} M₁] [_inst_6 : NoZeroDivisors.{u1} M₁ (MulZeroClass.toMul.{u1} M₁ (MulZeroOneClass.toMulZeroClass.{u1} M₁ (MonoidWithZero.toMulZeroOneClass.{u1} M₁ (CommMonoidWithZero.toMonoidWithZero.{u1} M₁ _inst_3)))) (CommMonoidWithZero.toZero.{u1} M₁ _inst_3)] [_inst_7 : Nontrivial.{u1} M₁] {s : Multiset.{u1} M₁}, Iff (Eq.{succ u1} M₁ (Multiset.prod.{u1} M₁ (CommMonoidWithZero.toCommMonoid.{u1} M₁ _inst_3) s) (OfNat.ofNat.{u1} M₁ 0 (Zero.toOfNat0.{u1} M₁ (CommMonoidWithZero.toZero.{u1} M₁ _inst_3)))) (Exists.{succ u1} M₁ (fun (r : M₁) => Exists.{0} (Membership.mem.{u1, u1} M₁ (Multiset.{u1} M₁) (Multiset.instMembershipMultiset.{u1} M₁) r s) (fun (hr : Membership.mem.{u1, u1} M₁ (Multiset.{u1} M₁) (Multiset.instMembershipMultiset.{u1} M₁) r s) => Eq.{succ u1} M₁ r (OfNat.ofNat.{u1} M₁ 0 (Zero.toOfNat0.{u1} M₁ (CommMonoidWithZero.toZero.{u1} M₁ _inst_3))))))
Case conversion may be inaccurate. Consider using '#align prod_zero_iff_exists_zero prod_zero_iff_exists_zeroₓ'. -/
theorem prod_zero_iff_exists_zero [NoZeroDivisors M₁] [Nontrivial M₁] {s : Multiset M₁} :
    s.Prod = 0 ↔ ∃ (r : M₁)(hr : r ∈ s), r = 0 :=
  by
  constructor; swap
  · rintro ⟨r, hrs, rfl⟩
    exact Multiset.prod_eq_zero hrs
  refine' Multiset.induction _ (fun a s ih => _) s
  · intro habs
    simpa using habs
  · rw [Multiset.prod_cons]
    intro hprod
    replace hprod := eq_zero_or_eq_zero_of_mul_eq_zero hprod
    cases' hprod with ha
    · exact ⟨a, Multiset.mem_cons_self a s, ha⟩
    · apply (ih hprod).imp _
      rintro b ⟨hb₁, hb₂⟩
      exact ⟨Multiset.mem_cons_of_mem hb₁, hb₂⟩
#align prod_zero_iff_exists_zero prod_zero_iff_exists_zero

end nonZeroDivisors

